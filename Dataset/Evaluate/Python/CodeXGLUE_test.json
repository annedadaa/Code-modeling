{"id": 51, "input": "<s> import threading <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> import GafferImage <EOL> __all__ = [ ] <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferImage . Display , <EOL> \"<STR_LIT:description>\" , <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> plugs = { <EOL> \"<STR_LIT:port>\" : [ <EOL> \"<STR_LIT:description>\" , <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> ] , <EOL> } <EOL> ) <EOL> __plugsPendingUpdate = [ ] <EOL> __plugsPendingUpdateLock = threading . Lock ( ) <EOL> def __scheduleUpdate ( plug , force = False ) : <EOL> if not force : <EOL> global __plugsPendingUpdate <EOL> global __plugsPendingUpdateLock <EOL> with __plugsPendingUpdateLock : <EOL> for p in __plugsPendingUpdate : <EOL> if plug . isSame ( p ) : <EOL> return <EOL> __plugsPendingUpdate . append ( plug ) <EOL> GafferUI . EventLoop . executeOnUIThread ( lambda : __update ( plug ) ) <EOL> def __update ( plug ) : <EOL> node = plug . node ( ) <EOL> if node : <EOL> updateCountPlug = node [ \"<STR_LIT>\" ] <EOL> updateCountPlug . setValue ( updateCountPlug . getValue ( )", "gt": ""}
{"id": 40753, "input": "<s> import re , operator <EOL> def str_find_all ( str , ch ) : <EOL> result = [ ] <EOL> index = <NUM_LIT:0> <EOL> while index >= <NUM_LIT:0> : <EOL> index = str . find ( ch , index ) <EOL> if index >= <NUM_LIT:0> : <EOL> result . append ( index ) <EOL> index += <NUM_LIT:1> <EOL> return result <EOL> word_pattern = re . compile ( \"<STR_LIT>\" ) <EOL> def markwords ( str , iswordfun ) : <EOL> markers = { True : \"<STR_LIT:x>\" , False : \"<STR_LIT:o>\" } <EOL> return \"<STR_LIT>\" . join ( [ markers [ iswordfun ( ch ) ] for ch in str ] ) <EOL> def split_words ( str , iswordfun ) : <EOL> return [ x for x in word_pattern . split ( markwords ( str , iswordfun ) ) if x != \"<STR_LIT>\" ] <EOL> def mark_start_segment ( str , is_segment ) : <EOL> def mark_start ( s ) : <EOL> if s [ <NUM_LIT:0> : <NUM_LIT:1> ] == \"<STR_LIT:x>\" : <EOL> return \"<STR_LIT:s>\" + s [ <NUM_LIT:1> : ] <EOL> else : <EOL> return s <EOL> return \"<STR_LIT>\" . join ( map ( mark_start , split_words ( str , is_segment ) ) ) <EOL> def mark_end_segment ( str , is_segment ) : <EOL> def mark_start ( s ) : <EOL> if s [ <NUM_LIT:0> : <NUM_LIT:1> ] == \"<STR_LIT:x>\" : <EOL> return s [ : - <NUM_LIT:1> ] + \"<STR_LIT:s>\" <EOL> else : <EOL> return s <EOL> return \"<STR_LIT>\" . join ( map ( mark_start , split_words ( str , is_segment ) ) ) <EOL> def mark_start_segment_index ( str , is_segment ) : <EOL> return str_find_all ( mark_start_segment ( str , is_segment ) , \"<STR_LIT:s>\" ) <EOL> def mark_end_segment_index ( str , is_segment ) : <EOL> return [ x + <NUM_LIT:1> for x in str_find_all ( mark_end_segment ( str , is_segment ) , \"<STR_LIT:s>\" ) ] <EOL> def is_word_token ( str ) : <EOL> return not is_non_word_token ( str ) <EOL> def is_non_word_token ( str ) : <EOL> if len ( str ) != <NUM_LIT:1> or str in \"<STR_LIT>\" : <EOL> return True <EOL> else : <EOL> return False <EOL> def next_start_segment ( str , is_segment ) : <EOL> str = \"<STR_LIT>\" . join ( str ) <EOL> result = [ ] <EOL> for start in mark_start_segment_index ( str , is_segment ) : <EOL> result [ len ( result ) : start ] = [ start for x in range ( start - len ( result ) ) ] <EOL> result [ len ( result ) : len ( str ) ] = [ len ( str ) for x in range ( len ( str ) - len ( result ) + <NUM_LIT:1> ) ] <EOL> return result <EOL> def next_end_segment ( str , is_segment ) : <EOL> str = \"<STR_LIT>\" . join ( str ) <EOL> result = [ ] <EOL> for start in mark_end_segment_index ( str , is_segment ) : <EOL> result [ len ( result ) : start ] = [ start for x in range ( start -", "gt": ""}
{"id": 32889, "input": "<s> import unittest <EOL> import pymel . internal . startup <EOL> class TestGetMayaVersion ( unittest . TestCase ) : <EOL> versions = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> extensions = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT> ] <EOL>", "gt": ""}
{"id": 49349, "input": "<s> import time <EOL> import logging <EOL> import datetime <EOL> from django . db import transaction <EOL> from django . utils . encoding import smart_unicode <EOL> from jellyroll . models import Item , CodeRepository , CodeCommit <EOL> from jellyroll . providers import utils <EOL> try : <EOL> import pysvn <EOL> except ImportError : <EOL> pysvn = None <EOL> log = logging . getLogger ( \"<STR_LIT>\" ) <EOL> def enabled ( ) : <EOL> ok = pysvn is not None <EOL> if not ok : <EOL> log . warn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> return ok <EOL> def update ( ) : <EOL> for repository in CodeRepository . objects . filter ( type = \"<STR_LIT>\" ) : <EOL> _update_repository ( repository ) <EOL> def _update_repository ( repository ) : <EOL> source_identifier = \"<STR_LIT>\" %", "gt": ""}
{"id": 27038, "input": "<s> import os <EOL> import os . path as osp <EOL> import textwrap <EOL> import waflib . Utils <EOL> import waflib . Logs as msg <EOL> from waflib . Configure import conf <EOL> _heptooldir = osp . dirname ( osp . abspath ( __file__ ) ) <EOL> def options ( opt ) : <EOL> opt . load ( '<STR_LIT>' , tooldir = _heptooldir ) <EOL> opt . add_option ( <EOL> '<STR_LIT>' , <EOL> default = None , <EOL> help = \"<STR_LIT>\" ) <EOL> return <EOL> def configure ( conf ) : <EOL> conf . load ( '<STR_LIT>' , tooldir = _heptooldir ) <EOL> return <EOL> @ conf <EOL> def find_cmake ( ctx , ** kwargs ) : <EOL> if not ctx . env . HWAF_FOUND_C_COMPILER : <EOL> ctx . fatal ( '<STR_LIT>' ) <EOL> pass <EOL>", "gt": ""}
{"id": 42397, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> from pypy . objspace . flow . model import Block <EOL> from pypy . objspace . flow . model import traverse <EOL> def ordered_blocks ( graph ) : <EOL> allblocks = [ ] <EOL> def visit ( block ) : <EOL> if isinstance ( block , Block ) : <EOL> if block . operations : <EOL> ofs = block . operations [ <NUM_LIT:0> ] . offset <EOL> else : <EOL> ofs = sys . maxint <EOL> if block . inputargs : <EOL> txt = str ( block . inputargs [ <NUM_LIT:0> ] ) <EOL> else : <EOL> txt = \"<STR_LIT>\" <EOL> allblocks . append ( ( ofs , txt , block ) ) <EOL> traverse ( visit , graph ) <EOL> allblocks . sort ( ) <EOL> return [ block for ofs , txt , block in allblocks ] <EOL> class UniqueList ( list ) : <EOL> def __init__ ( self , * args , ** kwds ) : <EOL> list . __init__ ( self , * args , ** kwds ) <EOL> self . dic = { } <EOL> def append1 ( self , arg ) : <EOL> try : <EOL> self . dic [ arg ] <EOL> except KeyError : <EOL> self . dic [ arg ] = <NUM_LIT:1> <EOL> list . append ( self , arg ) <EOL> except TypeError : <EOL> if arg not in self : <EOL> list . append ( self , arg ) <EOL> def builtin_base ( obj ) : <EOL> typ = type ( obj ) <EOL> return builtin_type_base ( typ ) <EOL> def builtin_type_base ( typ ) : <EOL> from copy_reg import _HEAPTYPE <EOL> while typ . __flags__ & _HEAPTYPE : <EOL> typ = typ . __base__ <EOL> return typ <EOL> def c_string ( s ) : <EOL> return '<STR_LIT>' % ( s . replace ( '<STR_LIT:\\\\>' , '<STR_LIT>' ) . replace ( '<STR_LIT:\">' , '<STR_LIT>' ) , ) <EOL> def uniquemodulename ( name , SEEN = { } ) : <EOL> i = <NUM_LIT:0> <EOL> while True : <EOL> i += <NUM_LIT:1> <EOL> result = '<STR_LIT>' % ( name , i ) <EOL> if result not in SEEN : <EOL> SEEN [ result ] = True <EOL> return result <EOL> C_IDENTIFIER = '<STR_LIT>' . join ( [ ( ( '<STR_LIT:0>' <= chr ( i ) <= '<STR_LIT>' or <EOL> '<STR_LIT:a>' <= chr ( i ) <= '<STR_LIT:z>' or <EOL> '<STR_LIT:A>' <= chr ( i ) <= '<STR_LIT>' ) and chr ( i ) or '<STR_LIT:_>' ) <EOL> for i in range ( <NUM_LIT> ) ] ) <EOL> class NameManager ( object ) : <EOL> def __init__ ( self , global_prefix = '<STR_LIT>' , number_sep = '<STR_LIT:_>' ) : <EOL> self . seennames = { } <EOL> self . scope = <NUM_LIT:0> <EOL> self . scopelist = [ ] <EOL> self . global_prefix = global_prefix <EOL> self . number_sep = number_sep <EOL> def make_reserved_names", "gt": ""}
{"id": 8256, "input": "<s> import time <EOL> import unittest <EOL> from robotide . robotapi import TestCaseFile <EOL> from robotide . controller . filecontrollers import TestCaseFileController <EOL> from resources import COMPLEX_SUITE_PATH <EOL> from nose . tools import assert_equals , assert_true <EOL> class TestCaseAndUserKeywordCopyingTest ( unittest . TestCase ) : <EOL> controller = TestCaseFileController ( <EOL> TestCaseFile ( source = COMPLEX_SUITE_PATH ) . populate ( ) ) <EOL> def test_test_case_copy ( self ) : <EOL> test = self . controller . tests [ <NUM_LIT:0> ] <EOL> copy = test . copy ( '<STR_LIT>' ) <EOL> assert_equals ( copy . name , '<STR_LIT>' ) <EOL> for orig , copied in zip ( test . settings , copy . settings ) : <EOL> assert_equals ( orig . value , copied . value ) <EOL> assert_true ( copied is not orig ) <EOL> assert_equals ( test . steps , copy . steps ) <EOL> assert_true ( test . steps is not copy . steps ) <EOL> def test_keyword_copy ( self ) : <EOL> test =", "gt": ""}
{"id": 45314, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> class TreeNode : <EOL> def __init__ ( self , x ) : <EOL> self . val = x <EOL> self . left = None <EOL> self . right = None <EOL> class ListNode : <EOL> def __init__ ( self , x ) : <EOL> self . val = x <EOL> self . next = None <EOL> class Solution : <EOL> def __init__ ( self ) : <EOL> self . current_node = None <EOL> def sortedListToBST ( self , head ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not head : <EOL> return head <EOL> self . current_node = head <EOL> length = self . getLength ( head ) <EOL> return self", "gt": ""}
{"id": 19145, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import yaki . Engine , yaki . Store <EOL> from yaki . Utils import * <EOL> from BeautifulSoup import * <EOL> import re , urlparse <EOL> template = \"\"\"<STR_LIT>\"\"\" <EOL> class FlashMovieWikiPlugin ( yaki . Plugins . WikiPlugin ) : <EOL> def __init__ ( self , registry , webapp ) : <EOL> self . ac = webapp . getContext ( ) <EOL> registry . register ( '<STR_LIT>' , self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def", "gt": ""}
{"id": 27415, "input": "<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . maxDiff = None <EOL> filename = '<STR_LIT>' <EOL> test_dir = '<STR_LIT>' <EOL> self . got_filename = test_dir + '<STR_LIT>' + filename <EOL> self . exp_filename = test_dir + '<STR_LIT>' + filename <EOL> self . ignore_files = [ ] <EOL> self . ignore_elements = { '<STR_LIT>' : [ '<STR_LIT>' ] } <EOL> def test_create_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> workbook = Workbook ( self . got_filename ) <EOL> worksheet = workbook . add_worksheet ( ) <EOL> chart = workbook . add_chart ( { '<STR_LIT:type>' : '<STR_LIT>' } ) <EOL> date_format = workbook . add_format ( { '<STR_LIT>' : <NUM_LIT> } ) <EOL> chart . axis_ids = [ <NUM_LIT> , <NUM_LIT> ] <EOL> data = [ <EOL> [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , <EOL> ] <EOL> for row in range ( <NUM_LIT:5> ) : <EOL> worksheet . write ( row , <NUM_LIT:0> , data [ <NUM_LIT:0> ] [ row ] , date_format ) <EOL> worksheet . write ( row , <NUM_LIT:1> , data [ <NUM_LIT:1> ] [ row ] ) <EOL> worksheet . write ( row , <NUM_LIT:2> , data [ <NUM_LIT:2> ] [ row ] ) <EOL> worksheet . write ( row , <NUM_LIT:3> , data [ <NUM_LIT:3> ] [ row ] ) <EOL> worksheet . set_column ( '<STR_LIT>' ,", "gt": ""}
{"id": 47345, "input": "<s> from collections import Iterator , namedtuple <EOL> from operator import add , setitem <EOL> import pickle <EOL> from random import random <EOL> from toolz import identity , partial <EOL> import pytest <EOL> from dask . compatibility import PY2 , PY3 <EOL> from dask . delayed import delayed , to_task_dasks , compute , Delayed <EOL> from dask . utils import raises <EOL> def test_value ( ) : <EOL> v = delayed ( <NUM_LIT:1> ) <EOL> assert v . compute ( ) == <NUM_LIT:1> <EOL> assert <NUM_LIT:1> in v . dask . values ( ) <EOL> def test_to_task_dasks ( ) : <EOL> a = delayed ( <NUM_LIT:1> , name = '<STR_LIT:a>' ) <EOL> b = delayed ( <NUM_LIT:2> , name = '<STR_LIT:b>' ) <EOL> task , dasks = to_task_dasks ( [ a , b , <NUM_LIT:3> ] ) <EOL> assert task == [ '<STR_LIT:a>' , '<STR_LIT:b>' , <NUM_LIT:3> ] <EOL> assert len ( dasks ) == <NUM_LIT:2> <EOL> assert a . dask in dasks <EOL> assert b . dask in dasks <EOL> task , dasks = to_task_dasks ( { a : <NUM_LIT:1> , b : <NUM_LIT:2> } ) <EOL> assert ( task == ( dict , [ [ '<STR_LIT:b>' , <NUM_LIT:2> ] , [ '<STR_LIT:a>' , <NUM_LIT:1> ] ] ) or <EOL> task == ( dict , [ [ '<STR_LIT:a>' , <NUM_LIT:1> ] , [ '<STR_LIT:b>' , <NUM_LIT:2> ] ] ) ) <EOL> assert len ( dasks ) == <NUM_LIT:2> <EOL> assert a . dask in dasks <EOL> assert b . dask in dasks <EOL> f = namedtuple ( '<STR_LIT:f>' , [ '<STR_LIT:x>' , '<STR_LIT:y>' ] ) <EOL> x = f ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> task , dasks = to_task_dasks ( x ) <EOL> assert task == x <EOL> assert dasks == [ ] <EOL> def test_operators ( ) : <EOL> a = delayed ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ) <EOL> assert a [ <NUM_LIT:0> ] . compute ( ) == <NUM_LIT:1> <EOL> assert ( a + a ) . compute ( ) == [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] <EOL> a = delayed ( <NUM_LIT:10> ) <EOL> assert ( a + <NUM_LIT:1> ) . compute ( ) == <NUM_LIT:11> <EOL> assert ( <NUM_LIT:1> + a ) . compute ( ) == <NUM_LIT:11> <EOL> assert ( a >> <NUM_LIT:1> ) . compute ( ) == <NUM_LIT:5> <EOL> assert ( a > <NUM_LIT:2> ) . compute ( ) <EOL> assert ( a ** <NUM_LIT:2> ) . compute ( ) == <NUM_LIT:100> <EOL> def test_methods ( ) : <EOL> a = delayed ( \"<STR_LIT>\" ) <EOL> assert a . split ( '<STR_LIT:U+0020>' ) . compute ( ) == [ '<STR_LIT:a>' , '<STR_LIT:b>' , '<STR_LIT:c>' , '<STR_LIT:d>' , '<STR_LIT:e>' ] <EOL> assert a . upper ( ) . replace ( '<STR_LIT:B>' , '<STR_LIT:A>' ) . split ( ) . count ( '<STR_LIT:A>' ) . compute ( ) == <NUM_LIT:2> <EOL> assert a . split ( '<STR_LIT:U+0020>' , pure = True ) . key == a . split ( '<STR_LIT:U+0020>' , pure = True ) . key <EOL> def test_attributes ( ) : <EOL> a = delayed ( <NUM_LIT:2> + <NUM_LIT> ) <EOL> assert a . real . compute ( ) == <NUM_LIT:2> <EOL> assert a . imag . compute ( ) == <NUM_LIT:1> <EOL> def test_value_errors ( ) : <EOL> a = delayed ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ) <EOL> assert raises ( TypeError , lambda : setattr ( a , '<STR_LIT:foo>' , <NUM_LIT:1> ) ) <EOL> assert raises ( TypeError , lambda : setattr ( a , '<STR_LIT>' , '<STR_LIT:test>' ) ) <EOL> assert raises ( TypeError , lambda : setitem ( a , <NUM_LIT:1> , <NUM_LIT:0> ) ) <EOL> assert raises ( TypeError , lambda : <NUM_LIT:1> in a ) <EOL> assert raises ( TypeError , lambda : list ( a ) ) <EOL> assert raises ( AttributeError , lambda : a . __len__ ( ) ) <EOL> assert raises ( TypeError , lambda : bool ( a ) ) <EOL> def test_delayed ( ) : <EOL> add2 = delayed ( add ) <EOL> assert add2 ( <NUM_LIT:1> , <NUM_LIT:2> ) . compute ( ) == <NUM_LIT:3> <EOL> assert ( add2 ( <NUM_LIT:1> , <NUM_LIT:2> ) + <NUM_LIT:3> ) . compute ( ) == <NUM_LIT:6> <EOL> assert add2 ( add2 ( <NUM_LIT:1> , <NUM_LIT:2> ) , <NUM_LIT:3> ) . compute ( ) == <NUM_LIT:6> <EOL> a = delayed ( <NUM_LIT:1> ) <EOL> b = add2 ( add2 ( a , <NUM_LIT:2> ) , <NUM_LIT:3> ) <EOL> assert a . key in b . dask <EOL> def test_compute ( ) : <EOL> a = delayed ( <NUM_LIT:1> ) + <NUM_LIT:5> <EOL> b = a + <NUM_LIT:1> <EOL> c = a + <NUM_LIT:2> <EOL> assert compute ( b , c ) == ( <NUM_LIT:7> , <NUM_LIT:8> ) <EOL> assert compute ( b ) == ( <NUM_LIT:7> , ) <EOL> assert compute ( [ a , b ] , c ) == ( [ <NUM_LIT:6> , <NUM_LIT:7> ] , <NUM_LIT:8> ) <EOL> def test_named_value ( ) : <EOL> assert '<STR_LIT:X>' in delayed ( <NUM_LIT:1> , name = '<STR_LIT:X>' ) . dask <EOL> def test_common_subexpressions ( ) : <EOL> a = delayed ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ) <EOL> res = a [ <NUM_LIT:0> ] + a [ <NUM_LIT:0> ] <EOL> assert a [ <NUM_LIT:0> ] . key in res . dask <EOL> assert a . key in res . dask <EOL> assert len ( res . dask ) == <NUM_LIT:3> <EOL> def test_lists ( ) : <EOL> a = delayed ( <NUM_LIT:1> ) <EOL> b = delayed ( <NUM_LIT:2> ) <EOL> c = delayed ( sum ) ( [ a , b ] ) <EOL> assert c . compute ( ) == <NUM_LIT:3> <EOL> def test_literates ( ) : <EOL> a = delayed ( <NUM_LIT:1> ) <EOL> b = a + <NUM_LIT:1> <EOL> lit = ( a , b , <NUM_LIT:3> ) <EOL> assert delayed ( lit ) . compute ( ) == ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> lit = set ( ( a , b , <NUM_LIT:3> ) ) <EOL> assert delayed ( lit ) . compute ( ) == set ( ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> lit = { a : '<STR_LIT:a>' , b : '<STR_LIT:b>' , <NUM_LIT:3> : '<STR_LIT:c>' } <EOL> assert delayed ( lit ) . compute ( ) == { <NUM_LIT:1> : '<STR_LIT:a>' , <NUM_LIT:2> : '<STR_LIT:b>' , <NUM_LIT:3> : '<STR_LIT:c>' } <EOL> assert delayed ( lit ) [ a ] . compute ( ) == '<STR_LIT:a>' <EOL> lit = { '<STR_LIT:a>' : a , '<STR_LIT:b>' : b , '<STR_LIT:c>' : <NUM_LIT:3> } <EOL> assert delayed ( lit ) . compute ( ) == { '<STR_LIT:a>' : <NUM_LIT:1> , '<STR_LIT:b>' : <NUM_LIT:2> , '<STR_LIT:c>' : <NUM_LIT:3> } <EOL> assert delayed ( lit ) [ '<STR_LIT:a>' ] . compute ( ) == <NUM_LIT:1> <EOL> def test_lists_are_concrete ( ) : <EOL> a = delayed ( <NUM_LIT:1> ) <EOL> b = delayed ( <NUM_LIT:2> ) <EOL> c = delayed ( max ) ( [ [ a , <NUM_LIT:10> ] , [ b , <NUM_LIT:20> ] ] , key = lambda x : x [ <NUM_LIT:0> ] ) [ <NUM_LIT:1> ] <EOL> assert c . compute ( ) == <NUM_LIT:20> <EOL> @ pytest . mark . xfail <EOL> def test_iterators ( ) : <EOL> a = delayed ( <NUM_LIT:1> ) <EOL> b = delayed ( <NUM_LIT:2> ) <EOL> c = delayed ( sum ) ( iter ( [ a , b ] ) ) <EOL> assert c . compute ( ) == <NUM_LIT:3> <EOL> def f ( seq ) : <EOL> assert isinstance ( seq , Iterator ) <EOL> return sum ( seq ) <EOL> c = delayed ( f ) ( iter ( [ a , b ] ) ) <EOL> assert c . compute ( ) == <NUM_LIT:3> <EOL> def test_pure ( ) : <EOL> v1 = delayed ( add , pure = True ) ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> v2 = delayed ( add , pure = True ) ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> assert v1 . key == v2 . key <EOL> myrand = delayed ( random ) <EOL> assert myrand ( ) . key != myrand ( ) . key <EOL> def test_kwargs ( ) : <EOL> def mysum ( a , b , c = ( ) , ** kwargs ) : <EOL> return a + b + sum ( c ) + sum ( kwargs . values ( ) ) <EOL> dmysum = delayed ( mysum ) <EOL> ten = dmysum ( <NUM_LIT:1> , <NUM_LIT:2> , c = [ delayed ( <NUM_LIT:3> ) , <NUM_LIT:0> ] , four = dmysum ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> assert ten . compute ( ) == <NUM_LIT:10> <EOL> dmysum = delayed ( mysum , pure = True ) <EOL> ten = dmysum ( <NUM_LIT:1> , <NUM_LIT:2> , c = [ delayed ( <NUM_LIT:3> ) , <NUM_LIT:0> ] , four = dmysum ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> assert ten . compute ( ) == <NUM_LIT:10> <EOL> def test_array_delayed ( ) : <EOL> np = pytest . importorskip ( '<STR_LIT>' ) <EOL> da = pytest . importorskip ( '<STR_LIT>' ) <EOL> arr = np . arange ( <NUM_LIT:100> ) . reshape ( ( <NUM_LIT:10> , <NUM_LIT:10> ) ) <EOL> darr = da . from_array ( arr , chunks = ( <NUM_LIT:5> , <NUM_LIT:5> ) ) <EOL> val = delayed ( sum ) ( [ arr , darr , <NUM_LIT:1> ] ) <EOL> assert isinstance ( val , Delayed ) <EOL> assert np . allclose ( val . compute ( ) , arr + arr + <NUM_LIT:1> ) <EOL> assert val . sum ( ) . compute ( ) == ( arr + arr + <NUM_LIT:1> ) . sum ( ) <EOL> assert val [ <NUM_LIT:0> , <NUM_LIT:0> ] . compute ( ) == ( arr + arr + <NUM_LIT:1> ) [ <NUM_LIT:0> , <NUM_LIT:0> ] <EOL> task , dasks = to_task_dasks ( darr ) <EOL> assert len ( dasks ) == <NUM_LIT:1> <EOL> orig = set ( darr . dask ) <EOL> final = set ( dasks [ <NUM_LIT:0> ] ) <EOL> assert orig . issubset ( final ) <EOL> diff = final . difference ( orig ) <EOL> assert len ( diff ) == <NUM_LIT:1> <EOL> def test_array_bag_delayed ( ) : <EOL> db = pytest . importorskip ( '<STR_LIT>' ) <EOL> da = pytest . importorskip ( '<STR_LIT>' ) <EOL>", "gt": ""}
{"id": 25489, "input": "<s> from __future__ import unicode_literals <EOL> from cms . plugin_pool import plugin_pool <EOL> from cms . plugin_base import CMSPluginBase <EOL> from django . templatetags . static import static <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from cmsplugin_filer_video import settings <EOL> from cmsplugin_filer_video . models import FilerVideo <EOL> from cmsplugin_filer_video . forms import VideoForm <EOL> class FilerVideoPlugin ( CMSPluginBase ) : <EOL> module = '<STR_LIT>' <EOL> model = FilerVideo <EOL> name = _ ( \"<STR_LIT>\" ) <EOL> form = VideoForm <EOL> render_template = \"<STR_LIT>\" <EOL> text_enabled = True <EOL> general_fields = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:image>' , <EOL> ( '<STR_LIT:width>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> color_fields = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "gt": ""}
{"id": 33204, "input": "<s> from flask_assets import Bundle <EOL> common_css = Bundle ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> filters = '<STR_LIT>' , <EOL> output = '<STR_LIT>' <EOL> ) <EOL> common_js", "gt": ""}
{"id": 42995, "input": "<s> from apps import base <EOL> import setting <EOL> class BaseHandler ( base . BaseHandler ) : <EOL>", "gt": ""}
{"id": 31041, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from collections import namedtuple <EOL> from inspect import cleandoc <EOL> from textwrap import dedent <EOL> from unittest import TestCase <EOL> from sphinx . ext . napoleon import Config <EOL> from sphinx . ext . napoleon . docstring import GoogleDocstring , NumpyDocstring <EOL> from util import mock <EOL> class NamedtupleSubclass ( namedtuple ( '<STR_LIT>' , ( '<STR_LIT>' , '<STR_LIT>' ) ) ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __slots__ = ( ) <EOL> def __new__ ( cls , attr1 , attr2 = None ) : <EOL> return super ( NamedtupleSubclass , cls ) . __new__ ( cls , attr1 , attr2 ) <EOL> class BaseDocstringTest ( TestCase ) : <EOL> pass <EOL> class NamedtupleSubclassTest ( BaseDocstringTest ) : <EOL> def test_attributes_docstring ( self ) : <EOL> config = Config ( ) <EOL> actual = str ( NumpyDocstring ( cleandoc ( NamedtupleSubclass . __doc__ ) , <EOL> config = config , app = None , what = '<STR_LIT:class>' , <EOL> name = '<STR_LIT>' , obj = NamedtupleSubclass ) ) <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( expected , actual ) <EOL> class GoogleDocstringTest ( BaseDocstringTest ) : <EOL> docstrings = [ ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) ] <EOL> def test_docstrings ( self ) : <EOL> config = Config ( <EOL> napoleon_use_param = False , <EOL> napoleon_use_rtype = False , <EOL> napoleon_use_keyword = False <EOL> ) <EOL> for docstring , expected in self . docstrings : <EOL> actual = str ( GoogleDocstring ( dedent ( docstring ) , config ) ) <EOL> expected = dedent ( expected ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_parameters_with_class_reference ( self ) : <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> actual = str ( GoogleDocstring ( docstring ) ) <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( expected , actual ) <EOL> def test_attributes_with_class_reference ( self ) : <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> actual = str ( GoogleDocstring ( docstring ) ) <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( expected , actual ) <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> actual = str ( GoogleDocstring ( docstring ) ) <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( expected , actual ) <EOL> def test_code_block_in_returns_section ( self ) : <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> actual = str ( GoogleDocstring ( docstring ) ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_colon_in_return_type ( self ) : <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> actual = str ( GoogleDocstring ( docstring ) ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_xrefs_in_return_type ( self ) : <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> actual = str ( GoogleDocstring ( docstring ) ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_raises_types ( self ) : <EOL> docstrings = [ ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" <EOL> \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" <EOL> \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" <EOL> \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) ] <EOL> for docstring , expected in docstrings : <EOL> actual = str ( GoogleDocstring ( docstring ) ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_kwargs_in_arguments ( self ) : <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> actual = str ( GoogleDocstring ( docstring ) ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_section_header_formatting ( self ) : <EOL> docstrings = [ ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) , <EOL> ( \"\"\"<STR_LIT>\"\"\" , \"\"\"<STR_LIT>\"\"\" ) ] <EOL> for docstring , expected in docstrings : <EOL> actual = str ( GoogleDocstring ( docstring ) ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_list_in_parameter_description ( self ) : <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> config = Config ( napoleon_use_param = True ) <EOL> actual = str ( GoogleDocstring ( docstring , config ) ) <EOL> self . assertEqual ( expected , actual ) <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> config = Config ( napoleon_use_param = False ) <EOL> actual = str ( GoogleDocstring ( docstring , config ) ) <EOL> self . assertEqual ( expected , actual ) <EOL> class NumpyDocstringTest ( BaseDocstringTest ) : <EOL> docstrings = [ ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) , ( <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ) ] <EOL> def test_docstrings ( self ) : <EOL> config = Config ( <EOL> napoleon_use_param = False , <EOL> napoleon_use_rtype = False , <EOL> napoleon_use_keyword = False ) <EOL> for docstring , expected in self . docstrings : <EOL> actual = str ( NumpyDocstring ( dedent ( docstring ) , config ) ) <EOL> expected = dedent ( expected ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_parameters_with_class_reference ( self ) : <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> config = Config ( napoleon_use_param = False ) <EOL> actual = str ( NumpyDocstring ( docstring , config ) ) <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( expected , actual ) <EOL> config = Config ( napoleon_use_param = True ) <EOL> actual = str ( NumpyDocstring ( docstring , config ) ) <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( expected , actual ) <EOL> def test_parameters_without_class_reference ( self ) : <EOL> docstring = \"\"\"<STR_LIT>\"\"\" <EOL> config = Config ( napoleon_use_param = False ) <EOL> actual = str ( NumpyDocstring ( docstring , config ) ) <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( expected , actual ) <EOL> config = Config ( napoleon_use_param = True ) <EOL> actual = str ( NumpyDocstring ( dedent ( docstring ) , config ) ) <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> self .", "gt": ""}
{"id": 42956, "input": "<s> from watson . framework import views <EOL> from watson . framework . views . decorators import view <EOL> class MyController ( object ) : <EOL> @ view ( format = '<STR_LIT>' ) <EOL> def xml_action ( self , * args , ** kwargs ) : <EOL> return { } <EOL> @ view ( format = '<STR_LIT>' ) <EOL> def xml_full_mime_action ( self ) : <EOL> return { } <EOL> @ view ( format = '<STR_LIT:html>' , template = '<STR_LIT:test>' ) <EOL> def html_action ( self ) : <EOL> return { } <EOL> @ view ( format = '<STR_LIT>' ) <EOL> def bool_action ( self ) : <EOL> return True <EOL> class TestViewDecorator ( object ) : <EOL> def test_view_model_format ( self ) : <EOL> controller = MyController ( ) <EOL> controller_response = controller . xml_action", "gt": ""}
{"id": 16694, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import codecs <EOL> def encode ( input , errors = '<STR_LIT:strict>' ) : <EOL> return ( codecs . BOM_UTF8 + codecs . utf_8_encode ( input , errors ) [ <NUM_LIT:0> ] , len ( input ) ) <EOL> def decode ( input , errors = '<STR_LIT:strict>' ) : <EOL> prefix = <NUM_LIT:0> <EOL> if input [ : <NUM_LIT:3> ] == codecs . BOM_UTF8 : <EOL> input = input [ <NUM_LIT:3> : ] <EOL> prefix = <NUM_LIT:3> <EOL> ( output , consumed ) = codecs . utf_8_decode ( input , errors , True ) <EOL> return ( output , consumed + prefix ) <EOL> class IncrementalEncoder ( codecs . IncrementalEncoder ) : <EOL> def __init__ ( self , errors = '<STR_LIT:strict>' ) : <EOL> codecs . IncrementalEncoder . __init__ ( self , errors ) <EOL> self . first = <NUM_LIT:1> <EOL> def encode ( self , input , final = False ) : <EOL> if self . first : <EOL> self . first = <NUM_LIT:0> <EOL> return codecs . BOM_UTF8 + codecs . utf_8_encode ( input , self . errors ) [ <NUM_LIT:0> ] <EOL> else : <EOL> return codecs . utf_8_encode ( input , self . errors ) [ <NUM_LIT:0> ] <EOL> def reset ( self ) : <EOL> codecs . IncrementalEncoder . reset ( self ) <EOL> self . first = <NUM_LIT:1> <EOL> def getstate ( self ) : <EOL> return self . first <EOL> def setstate ( self , state ) : <EOL> self . first = state <EOL> class IncrementalDecoder ( codecs . BufferedIncrementalDecoder ) : <EOL> def __init__ ( self , errors = '<STR_LIT:strict>' ) : <EOL> codecs . BufferedIncrementalDecoder . __init__ ( self , errors ) <EOL> self . first = True <EOL> def _buffer_decode ( self , input , errors , final ) : <EOL> if self . first : <EOL> if len ( input ) < <NUM_LIT:3> : <EOL> if codecs . BOM_UTF8 . startswith ( input ) : <EOL> return ( u\"<STR_LIT>\" , <NUM_LIT:0> ) <EOL> else : <EOL> self . first = None <EOL> else : <EOL> self . first = None <EOL> if input [ : <NUM_LIT:3> ] == codecs . BOM_UTF8 : <EOL> ( output , consumed ) = codecs . utf_8_decode ( input [ <NUM_LIT:3> : ] , errors , final ) <EOL> return ( output , consumed + <NUM_LIT:3> ) <EOL> return codecs . utf_8_decode ( input , errors , final ) <EOL> def reset (", "gt": ""}
{"id": 29542, "input": "<s> import click <EOL> def test_basic_functionality ( runner ) : <EOL> @ click . command ( ) <EOL> def cli ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = runner . invoke ( cli , [ '<STR_LIT>' ] , terminal_width = <NUM_LIT> ) <EOL> assert not result . exception <EOL> assert result . output . splitlines ( ) == [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> def test_wrapping_long_options_strings ( runner ) : <EOL> @ click . group ( ) <EOL> def cli ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ cli . group ( ) <EOL> def a_very_long ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ a_very_long . command ( ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> def command ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = runner . invoke ( cli , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> terminal_width = <NUM_LIT> ) <EOL> assert not result . exception <EOL> assert result . output . splitlines ( ) == [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> def test_wrapping_long_command_name ( runner ) : <EOL> @ click . group ( ) <EOL> def cli ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ cli . group ( ) <EOL> def a_very_very_very_long ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ a_very_very_very_long . command ( ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> def command ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = runner . invoke ( cli , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> terminal_width = <NUM_LIT> ) <EOL> assert not result . exception <EOL> assert result . output . splitlines ( ) == [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> def test_formatting_empty_help_lines ( runner ) : <EOL> @ click . command ( ) <EOL> def cli ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = runner . invoke ( cli , [ '<STR_LIT>' ] ) <EOL> assert not result . exception <EOL> assert result . output . splitlines ( ) == [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> def test_formatting_usage_error ( runner ) : <EOL> @ click . command ( ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> def cmd ( arg ) : <EOL> click . echo ( '<STR_LIT>' + arg ) <EOL> result = runner . invoke ( cmd , [ ] ) <EOL> assert result . exit_code == <NUM_LIT:2> <EOL> assert result . output . splitlines ( ) == [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> def test_formatting_usage_error_nested ( runner ) : <EOL> @ click . group ( ) <EOL> def cmd ( ) : <EOL> pass <EOL> @ cmd . command ( ) <EOL> @ click . argument (", "gt": ""}
{"id": 46429, "input": "<s> import pytest <EOL> from bepasty . utils . _compat import range_type <EOL> from bepasty . utils . name import ItemName , encode , make_id <EOL> def test_create ( ) : <EOL> fake_storage = { } <EOL> n = ItemName . create ( fake_storage ) <EOL> assert n <EOL> def test_create_many ( ) : <EOL> fake_storage = { } <EOL> length = <NUM_LIT:1> <EOL> count = <NUM_LIT> <EOL> max_seen_length = <NUM_LIT:0> <EOL> for i in range_type ( count ) : <EOL> name = ItemName . create ( fake_storage , length = length , max_length = length * <NUM_LIT:4> , max_tries = <NUM_LIT:10> ) <EOL> fake_storage [ name ] = None <EOL> max_seen_length = max ( max_seen_length , len ( name ) ) <EOL> assert max_seen_length > length <EOL> assert len ( list ( fake_storage ) ) == count <EOL> def test_make_id_type ( ) : <EOL> assert isinstance ( make_id ( <NUM_LIT:2> ) , str ) <EOL> def test_make_id_length ( ) : <EOL> for length in range_type ( <NUM_LIT:10> ) : <EOL> assert len ( make_id ( length ) ) == length <EOL> def test_make_id_alphabet ( ) : <EOL> assert set ( make_id ( <NUM_LIT:10> , alphabet = \"<STR_LIT:abc>\" ) ) <= set ( [ '<STR_LIT:a>' , '<STR_LIT:b>' , '<STR_LIT:c>' ] ) <EOL> def test_make_id_unique ( ) : <EOL> length , count = <NUM_LIT:6> , <NUM_LIT> <EOL> ids = set ( make_id ( length ) for i in range_type ( count ) ) <EOL> assert len ( ids ) == count <EOL> def test_encode_length ( ) : <EOL> length = <NUM_LIT> <EOL> assert len ( encode ( <NUM_LIT> , length ) ) == length <EOL> def test_encode_binary ( ) : <EOL> assert encode ( <NUM_LIT:0> , <NUM_LIT:0> , \"<STR_LIT>\" ) == [ ] <EOL> assert encode ( <NUM_LIT:1> , <NUM_LIT:0> , \"<STR_LIT>\" ) == [ ] <EOL> assert encode ( <NUM_LIT:0> , <NUM_LIT:1> , \"<STR_LIT>\" ) == [ '<STR_LIT:0>' ] <EOL> assert encode ( <NUM_LIT:1> , <NUM_LIT:1> , \"<STR_LIT>\" ) == [ '<STR_LIT:1>' ] <EOL> assert encode ( <NUM_LIT:0> , <NUM_LIT:2> , \"<STR_LIT>\" ) == [ '<STR_LIT:0>' , '<STR_LIT:0>' ] <EOL> assert encode ( <NUM_LIT:1> , <NUM_LIT:2> , \"<STR_LIT>\" ) == [ '<STR_LIT:0>' , '<STR_LIT:1>' ] <EOL> assert encode ( <NUM_LIT:2> , <NUM_LIT:2> , \"<STR_LIT>\" ) == [ '<STR_LIT:1>' , '<STR_LIT:0>' ] <EOL> assert encode ( <NUM_LIT:3> , <NUM_LIT:2> , \"<STR_LIT>\" ) == [ '<STR_LIT:1>' , '<STR_LIT:1>' ] <EOL> assert encode ( <NUM_LIT:4> , <NUM_LIT:2> , \"<STR_LIT>\" ) == [ '<STR_LIT:0>' , '<STR_LIT:0>' ] <EOL> def test_encode_special ( ) : <EOL> assert encode ( <NUM_LIT:0> , <NUM_LIT:2> , \"<STR_LIT>\" ) == [ '<STR_LIT:.>' , '<STR_LIT:.>' ] <EOL> assert encode ( <NUM_LIT:1> , <NUM_LIT:2>", "gt": ""}
{"id": 48320, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from jinja2 import DictLoader , Environment <EOL> def filter_more ( content ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ( first , more , second ) = content . partition ( \"<STR_LIT>\" ) <EOL> if more == \"<STR_LIT>\" : <EOL> return first <EOL> else : <EOL> return content <EOL> def filter_filter ( site , key , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filtered = site . get ( key , value ) <EOL> if type ( filtered ) != list : <EOL> return [ filtered ] <EOL> return filtered <EOL> def filter_get ( site , key , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filtered = site . get ( key , value ) <EOL> if type ( filtered ) == list : <EOL> raise Exception ( \"<STR_LIT>\" , key , value ) <EOL> if filtered is None : <EOL> raise Exception ( \"<STR_LIT>\" , key , value ) <EOL> return filtered <EOL> class Render ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , site , config ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . site = site <EOL> self . config = config <EOL> def run ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> env = Environment ( <EOL> loader = DictLoader ( self . site . templates", "gt": ""}
{"id": 44445, "input": "<s> import copy <EOL> from cloudferry . lib . base . action import action <EOL> from cloudferry . lib . utils import utils as utl <EOL> CEPH = '<STR_LIT>' <EOL> ISCSI = '<STR_LIT>' <EOL> PATH_COPY_DIFF = <NUM_LIT:0> <EOL> DEFAULT = <NUM_LIT:1> <EOL> INST = utl . INSTANCES_TYPE <EOL> BODY = utl . INSTANCE_BODY <EOL> class IsNotCopyDiffFile ( action . Action ) : <EOL> def run ( self , info = None , ** kwargs ) : <EOL> self . set_next_path ( DEFAULT ) <EOL> info = copy . deepcopy ( info ) <EOL> src_compute = self . src_cloud . resources [ utl . COMPUTE_RESOURCE ] <EOL> dst_compute = self . dst_cloud . resources [ utl . COMPUTE_RESOURCE ] <EOL> backend_ephem_drv_src = src_compute . config . compute . backend <EOL> backend_ephem_drv_dst = dst_compute . config . compute . backend <EOL> for instance in info [ INST ] . values ( ) : <EOL> instance_boot", "gt": ""}
{"id": 40890, "input": "<s> from nose . tools import * <EOL> from exercise47 . game import Room <EOL> def test_room ( ) : <EOL> gold = Room ( \"<STR_LIT>\" , <EOL> \"\"\"<STR_LIT>\"\"\" ) <EOL> assert_equal ( gold . name , \"<STR_LIT>\" ) <EOL> assert_equal ( gold . paths , { } ) <EOL> def test_room_paths ( ) : <EOL> center = Room ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> north = Room ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> south = Room ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> center . add_paths ( { '<STR_LIT>' : north , '<STR_LIT>' : south } ) <EOL> assert_equal ( center . go ( '<STR_LIT>' ) , north ) <EOL> assert_equal ( center . go ( '<STR_LIT>' ) , south ) <EOL> def test_map (", "gt": ""}
{"id": 5374, "input": "<s> from setup import * <EOL> from pyglet_gui . manager import Manager <EOL> from pyglet_gui . buttons import Button <EOL> from pyglet_gui . mixins import HighlightMixin <EOL> from pyglet_gui . theme import Theme <EOL> theme = Theme ( { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT:12> , <EOL> \"<STR_LIT>\" : <NUM_LIT:10> , <EOL> \"<STR_LIT>\" : [ <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> ] , <EOL> \"<STR_LIT>\" : [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:255> ] , <EOL> \"<STR_LIT>\" : [ <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> ] , <EOL> \"<STR_LIT>\" : [ <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:64> ] , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:image>\" : { <EOL> \"<STR_LIT:source>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ <NUM_LIT:8> , <NUM_LIT:6> , <NUM_LIT:2> , <NUM_LIT:2> ] , <EOL> \"<STR_LIT>\" : [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT:8> , <NUM_LIT:6> ] <EOL> } <EOL> } , <EOL> \"<STR_LIT:image>\" : { <EOL> \"<STR_LIT:source>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ <NUM_LIT:6> , <NUM_LIT:6> , <NUM_LIT:3> , <NUM_LIT:3> ] , <EOL> \"<STR_LIT>\" : [ <NUM_LIT:12> , <NUM_LIT:12> , <NUM_LIT:4> , <NUM_LIT:2> ] <EOL> } , <EOL> \"<STR_LIT>\" : [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:255> ] <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:image>\" : { <EOL> \"<STR_LIT:source>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ <NUM_LIT:8> , <NUM_LIT:6> ,", "gt": ""}
{"id": 10524, "input": "<s> from decoders import * <EOL> typeinfos = [ <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:7> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:4> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:5> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:6> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:32> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:2> ) , { <NUM_LIT:0> : ( '<STR_LIT>' , <NUM_LIT:3> ) , <NUM_LIT:1> : ( '<STR_LIT>' , <NUM_LIT:4> ) , <NUM_LIT:2> : ( '<STR_LIT>' , <NUM_LIT:5> ) , <NUM_LIT:3> : ( '<STR_LIT>' , <NUM_LIT:6> ) } ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:2> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:8> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:8> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:0> ) , ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:1> ) , ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:6> , <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT:6> , <NUM_LIT:5> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:3> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:9> , <NUM_LIT:0> ) , ( '<STR_LIT>' , <NUM_LIT:11> , <NUM_LIT:1> ) , ( '<STR_LIT>' , <NUM_LIT:12> , <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:6> , <NUM_LIT:3> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:7> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:64> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:0> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:1> ) , ( '<STR_LIT>' , <NUM_LIT:6> , <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:15> , <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:16> , <NUM_LIT:4> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:0> ) , ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:1> ) , ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:3> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:2> ) ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT:10> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:9> , <NUM_LIT:0> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:1> ) , ( '<STR_LIT>' , <NUM_LIT:9> , <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT:1> , <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:8> ) , ( '<STR_LIT>' , <NUM_LIT:20> , <NUM_LIT:9> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:5> ) , <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:10> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:11> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:0> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ] ) , <EOL> ( '<STR_LIT>' , [ ( - <NUM_LIT> , <NUM_LIT:64> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:12> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT> , <NUM_LIT:0> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:6> ) , <NUM_LIT:30> ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:6> ) , <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:0> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:1> ) , ( '<STR_LIT>' , <NUM_LIT:9> , <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:8> ) , ( '<STR_LIT>' , <NUM_LIT:10> , <NUM_LIT:15> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:9> ) , ( '<STR_LIT>' , <NUM_LIT:32> , <NUM_LIT:10> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:11> ) , ( '<STR_LIT>' , <NUM_LIT:12> , <NUM_LIT:12> ) , ( '<STR_LIT>' , <NUM_LIT:3> , <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT:9> ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT:6> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:20> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:20> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:9> , - <NUM_LIT:12> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:11> ) , ( '<STR_LIT>' , <NUM_LIT:20> , - <NUM_LIT:10> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:9> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:8> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:5> ) , <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:12> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:11> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:10> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:9> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:8> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:16> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:1> , <NUM_LIT:4> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:1> , <NUM_LIT:8> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:6> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:8> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:2> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:7> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:5> ) , <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT:12> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT:12> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT:2> , - <NUM_LIT:20> ) , ( '<STR_LIT>' , <NUM_LIT:2> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT:2> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT:3> , - <NUM_LIT:16> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:15> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT:10> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT:10> , - <NUM_LIT:12> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:11> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:10> ) , ( '<STR_LIT>' , <NUM_LIT:9> , - <NUM_LIT:9> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:8> ) , ( '<STR_LIT>' , <NUM_LIT:50> , - <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT:3> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT:0> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT:1> ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT:2> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:6> ) , <NUM_LIT:6> ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:9> ) , <NUM_LIT:6> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:10> , - <NUM_LIT> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:12> ) , ( '<STR_LIT>' , <NUM_LIT:1> , - <NUM_LIT:11> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:10> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:9> ) , ( '<STR_LIT>' , <NUM_LIT:3> , - <NUM_LIT:8> ) , ( '<STR_LIT>' , <NUM_LIT:0> , - <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT:0> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT:20> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:15> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:5> ) , <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:12> , - <NUM_LIT:10> ) , ( '<STR_LIT>' , <NUM_LIT:2> , - <NUM_LIT:9> ) , ( '<STR_LIT>' , <NUM_LIT:2> , - <NUM_LIT:8> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:3> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:0> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:15> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:6> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:15> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:5> ) , <NUM_LIT:10> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:15> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:16> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT:x>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT:y>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:12> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:9> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( - <NUM_LIT> , <NUM_LIT:32> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT:x>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT:y>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:20> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:2> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:20> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT:x>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT:y>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT:z>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:10> , - <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT:10> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:2> ) , { <NUM_LIT:0> : ( '<STR_LIT:None>' , <NUM_LIT> ) , <NUM_LIT:1> : ( '<STR_LIT>' , <NUM_LIT> ) , <NUM_LIT:2> : ( '<STR_LIT>' , <NUM_LIT> ) , <NUM_LIT:3> : ( '<STR_LIT>' , <NUM_LIT:6> ) } ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:9> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:9> ) ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:9> ) , <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:2> ) , { <NUM_LIT:0> : ( '<STR_LIT:None>' , <NUM_LIT> ) , <NUM_LIT:1> : ( '<STR_LIT>' , <NUM_LIT> ) , <NUM_LIT:2> : ( '<STR_LIT>' , <NUM_LIT> ) , <NUM_LIT:3> : ( '<STR_LIT>' , <NUM_LIT> ) } ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT:10> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:10> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:9> ) , <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:1> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:1> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:1> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:3> ) , <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:1> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( - <NUM_LIT> , <NUM_LIT:8> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT:x>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT:y>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT:z>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:9> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:8> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:7> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:6> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:12> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:10> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT:15> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:1> , - <NUM_LIT:5> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT:9> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:5> ) , <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:1> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:3> ) , { <NUM_LIT:0> : ( '<STR_LIT:None>' , <NUM_LIT> ) , <NUM_LIT:1> : ( '<STR_LIT>' , <NUM_LIT> ) , <NUM_LIT:2> : ( '<STR_LIT>' , <NUM_LIT:6> ) , <NUM_LIT:3> : ( '<STR_LIT>' , <NUM_LIT> ) , <NUM_LIT:4> : ( '<STR_LIT>' , <NUM_LIT> ) , <NUM_LIT:5> : ( '<STR_LIT>' , <NUM_LIT:6> ) } ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:7> ) , <NUM_LIT:6> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ <NUM_LIT> ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT:11> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT:x>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT:y>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:2> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:6> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ ( <NUM_LIT:0> , <NUM_LIT> ) ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT:15> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:15> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT:15> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:15> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT:15> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:4> ) , ( '<STR_LIT>' , <NUM_LIT:9> , - <NUM_LIT:3> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:2> ) , ( '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT:1> ) ] ] ) , <EOL> ( '<STR_LIT>' , [ [ ( '<STR_LIT>'", "gt": ""}
{"id": 37001, "input": "<s> from __future__ import absolute_import <EOL> import struct <EOL> from io import BytesIO <EOL> from thriftpy . _compat import CYTHON <EOL> from . . import TTransportBase , readall <EOL> from . . buffered import TBufferedTransport <EOL> class TFramedTransport ( TTransportBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , trans ) : <EOL> self . _trans = trans <EOL> self . _rbuf = BytesIO ( ) <EOL> self . _wbuf = BytesIO ( ) <EOL> def is_open ( self ) : <EOL> return self . _trans . is_open ( ) <EOL> def open ( self ) : <EOL> return self . _trans . open ( ) <EOL> def close ( self ) : <EOL> return self . _trans . close ( ) <EOL> def read ( self , sz ) : <EOL> if sz == <NUM_LIT:0> : <EOL> return b'<STR_LIT>' <EOL> ret = self . _rbuf . read ( sz ) <EOL> if len ( ret ) != <NUM_LIT:0> : <EOL> return ret <EOL> self . read_frame ( ) <EOL> return self", "gt": ""}
{"id": 16418, "input": "<s> import datetime as dt <EOL> import numpy as np <EOL> import matplotlib . pyplot as plt <EOL> import matplotlib . dates as mdates <EOL> from mpldatacursor import datacursor <EOL> t = mdates . drange ( dt . datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:15> ) , dt . datetime ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) , <EOL> dt . timedelta ( hours = <NUM_LIT:2> ) ) <EOL> y = np . sin ( t ) <EOL> fig , ax = plt . subplots ( ) <EOL> ax . plot_date", "gt": ""}
{"id": 20773, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import threading <EOL> import struct <EOL> import uuid <EOL> import random <EOL> import time <EOL> import os <EOL> import re <EOL> import sys <EOL> import logging <EOL> import socket <EOL> import base64 <EOL> import zlib <EOL> _struct_2_long_long = struct . Struct ( '<STR_LIT>' ) <EOL> python_version = sys . version_info [ <NUM_LIT:0> ] <EOL> if python_version == <NUM_LIT:2> : <EOL> import cPickle as pickle <EOL> else : <EOL> import pickle <EOL> from hashlib import md5 , sha1 , sha224 , sha256 , sha384 , sha512 <EOL> try : <EOL> from Crypto . Cipher import AES <EOL> except ImportError : <EOL> import gluon . contrib . aes as AES <EOL> import hmac <EOL> try : <EOL> try : <EOL> from gluon . contrib . pbkdf2_ctypes import pbkdf2_hex <EOL> except ( ImportError , AttributeError ) : <EOL> from gluon . contrib . pbkdf2 import pbkdf2_hex <EOL> HAVE_PBKDF2 = True <EOL> except ImportError : <EOL> try : <EOL> from . pbkdf2 import pbkdf2_hex <EOL> HAVE_PBKDF2 = True <EOL> except ( ImportError , ValueError ) : <EOL> HAVE_PBKDF2 = False <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> def AES_new ( key , IV = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if IV is None : <EOL> IV = fast_urandom16 ( ) <EOL> return AES . new ( key , AES . MODE_CBC , IV ) , IV <EOL> def compare ( a , b ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( a ) != len ( b ) : <EOL> return False <EOL> result = <NUM_LIT:0> <EOL> for x , y in zip ( a , b ) : <EOL> result |= ord ( x ) ^ ord ( y ) <EOL> return result == <NUM_LIT:0> <EOL> def md5_hash ( text ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return md5 ( text ) . hexdigest ( ) <EOL> def simple_hash ( text , key = '<STR_LIT>' , salt = '<STR_LIT>' , digest_alg = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not digest_alg : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> elif not isinstance ( digest_alg , str ) : <EOL> h = digest_alg ( text + key + salt ) <EOL> elif digest_alg . startswith ( '<STR_LIT>' ) : <EOL> iterations , keylen , alg = digest_alg [ <NUM_LIT:7> : - <NUM_LIT:1> ] . split ( '<STR_LIT:U+002C>' ) <EOL> return pbkdf2_hex ( text , salt , int ( iterations ) , <EOL> int ( keylen ) , get_digest ( alg ) ) <EOL> elif key : <EOL> digest_alg = get_digest ( digest_alg ) <EOL> h = hmac . new ( key + salt , text , digest_alg ) <EOL> else : <EOL> h = get_digest ( digest_alg ) ( ) <EOL> h . update ( text + salt ) <EOL> return h . hexdigest ( ) <EOL> def get_digest ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( value , str ) : <EOL> return value <EOL> value = value . lower ( ) <EOL> if value == \"<STR_LIT>\" : <EOL> return md5 <EOL> elif value == \"<STR_LIT>\" : <EOL> return sha1 <EOL> elif value == \"<STR_LIT>\" : <EOL> return sha224 <EOL> elif value == \"<STR_LIT>\" : <EOL> return sha256 <EOL> elif value == \"<STR_LIT>\" : <EOL> return sha384 <EOL> elif value == \"<STR_LIT>\" : <EOL> return sha512 <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" % value ) <EOL> DIGEST_ALG_BY_SIZE = { <EOL> <NUM_LIT> / <NUM_LIT:4> : '<STR_LIT>' , <EOL> <NUM_LIT> / <NUM_LIT:4> : '<STR_LIT>' , <EOL> <NUM_LIT> / <NUM_LIT:4> : '<STR_LIT>' , <EOL> <NUM_LIT> / <NUM_LIT:4> : '<STR_LIT>' , <EOL> <NUM_LIT> / <NUM_LIT:4> : '<STR_LIT>' , <EOL> <NUM_LIT> / <NUM_LIT:4> : '<STR_LIT>' , <EOL> } <EOL> def pad ( s , n = <NUM_LIT:32> , padchar = '<STR_LIT:U+0020>' ) : <EOL> return s + ( <NUM_LIT:32> - len ( s ) % <NUM_LIT:32> ) * padchar <EOL> def secure_dumps ( data , encryption_key , hash_key = None , compression_level = None ) : <EOL> if not hash_key : <EOL> hash_key = sha1 ( encryption_key ) . hexdigest ( ) <EOL> dump = pickle . dumps ( data ) <EOL> if compression_level : <EOL> dump = zlib . compress ( dump , compression_level ) <EOL> key = pad ( encryption_key [ : <NUM_LIT:32> ] ) <EOL> cipher , IV = AES_new ( key ) <EOL> encrypted_data = base64 . urlsafe_b64encode ( IV + cipher . encrypt ( pad ( dump ) ) ) <EOL> signature = hmac . new ( hash_key , encrypted_data ) . hexdigest ( ) <EOL> return signature + '<STR_LIT::>' + encrypted_data <EOL> def secure_loads ( data , encryption_key , hash_key = None , compression_level = None ) : <EOL> if not '<STR_LIT::>' in data : <EOL> return None <EOL> if not hash_key : <EOL> hash_key = sha1 ( encryption_key ) . hexdigest ( ) <EOL> signature , encrypted_data = data . split ( '<STR_LIT::>' , <NUM_LIT:1> ) <EOL> actual_signature = hmac . new ( hash_key , encrypted_data ) . hexdigest ( ) <EOL> if not compare ( signature , actual_signature ) : <EOL> return None <EOL> key = pad ( encryption_key [ : <NUM_LIT:32> ] ) <EOL> encrypted_data = base64 . urlsafe_b64decode ( encrypted_data ) <EOL> IV , encrypted_data = encrypted_data [ : <NUM_LIT:16> ] , encrypted_data [ <NUM_LIT:16> : ] <EOL> cipher , _ = AES_new ( key , IV = IV ) <EOL> try : <EOL> data = cipher . decrypt ( encrypted_data ) <EOL> data = data . rstrip ( '<STR_LIT:U+0020>' ) <EOL> if compression_level : <EOL> data = zlib . decompress ( data ) <EOL> return pickle . loads ( data ) <EOL> except Exception , e : <EOL> return None <EOL> def initialize_urandom ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> node_id = uuid . getnode ( ) <EOL> microseconds = int ( time . time ( ) * <NUM_LIT> ) <EOL> ctokens = [ ( ( node_id + microseconds ) >> ( ( i % <NUM_LIT:6> ) * <NUM_LIT:8> ) ) % <EOL> <NUM_LIT> for i in range ( <NUM_LIT:16> ) ] <EOL> random . seed ( node_id + microseconds ) <EOL> try : <EOL> os . urandom ( <NUM_LIT:1> ) <EOL> have_urandom = True <EOL> try : <EOL> frandom = open ( '<STR_LIT>' , '<STR_LIT:wb>' ) <EOL> try : <EOL> if python_version == <NUM_LIT:2> : <EOL> frandom . write ( '<STR_LIT>' . join ( chr ( t ) for t in ctokens ) ) <EOL> else : <EOL> frandom . write ( bytes ( [ ] ) . join ( bytes ( [ t ] ) for t in ctokens ) ) <EOL> finally : <EOL> frandom . close ( ) <EOL> except IOError : <EOL> pass <EOL> except NotImplementedError : <EOL> have_urandom = False <EOL> logger . warning ( <EOL> \"\"\"<STR_LIT>\"\"\" ) <EOL> if python_version == <NUM_LIT:2> : <EOL> packed = '<STR_LIT>' . join ( chr ( x ) for x in ctokens ) <EOL> else : <EOL> packed = bytes ( [ ] ) . join ( bytes ( [ x ] ) for x in ctokens ) <EOL> unpacked_ctokens = _struct_2_long_long . unpack ( packed ) <EOL> return unpacked_ctokens , have_urandom <EOL> UNPACKED_CTOKENS , HAVE_URANDOM = initialize_urandom ( ) <EOL> def fast_urandom16 ( urandom = [ ] , locker = threading . RLock ( ) ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> return urandom . pop ( ) <EOL> except IndexError : <EOL> try : <EOL> locker . acquire ( ) <EOL> ur = os . urandom ( <NUM_LIT:16> * <NUM_LIT> ) <EOL> urandom += [ ur [ i : i + <NUM_LIT:16> ] for i in xrange ( <NUM_LIT:16> , <NUM_LIT> * <NUM_LIT:16> , <NUM_LIT:16> ) ] <EOL> return ur [ <NUM_LIT:0> : <NUM_LIT:16> ] <EOL> finally : <EOL> locker . release ( ) <EOL> def web2py_uuid ( ctokens = UNPACKED_CTOKENS ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rand_longs = ( random . getrandbits ( <NUM_LIT:64> ) , random . getrandbits ( <NUM_LIT:64> ) ) <EOL> if HAVE_URANDOM : <EOL> urand_longs = _struct_2_long_long . unpack ( fast_urandom16 ( ) ) <EOL> byte_s = _struct_2_long_long . pack ( rand_longs [ <NUM_LIT:0> ] ^ urand_longs [ <NUM_LIT:0> ] ^ ctokens [ <NUM_LIT:0> ] , <EOL> rand_longs [ <NUM_LIT:1> ] ^ urand_longs [ <NUM_LIT:1> ] ^ ctokens [ <NUM_LIT:1> ] ) <EOL> else : <EOL> byte_s = _struct_2_long_long . pack ( rand_longs [ <NUM_LIT:0> ] ^ ctokens [ <NUM_LIT:0> ] , <EOL> rand_longs [ <NUM_LIT:1> ] ^ ctokens [ <NUM_LIT:1> ] ) <EOL> return str ( uuid . UUID ( bytes = byte_s , version = <NUM_LIT:4> ) ) <EOL> REGEX_IPv4 = re .", "gt": ""}
{"id": 32793, "input": "<s> from django . core . urlresolvers import reverse <EOL> from django import http <EOL> from mox import IsA <EOL> from openstack_dashboard import api <EOL> from openstack_dashboard . test import helpers as test <EOL> INDEX_URL = reverse ( '<STR_LIT>' ) <EOL> DETAILS_URL = reverse ( <EOL> '<STR_LIT>' , args = [ '<STR_LIT:id>' ] ) <EOL> class DataProcessingJobBinaryTests ( test . TestCase ) : <EOL> @ test . create_stubs ( { api . sahara : ( '<STR_LIT>' , ) } ) <EOL> def test_index ( self ) : <EOL> api . sahara . job_binary_list ( IsA ( http . HttpRequest ) ) . AndReturn ( self . job_binaries . list ( ) ) <EOL> self . mox . ReplayAll ( ) <EOL> res = self . client . get ( INDEX_URL ) <EOL> self . assertTemplateUsed ( <EOL> res , '<STR_LIT>' ) <EOL> self . assertContains ( res , '<STR_LIT>' ) <EOL> self . assertContains ( res , '<STR_LIT:Name>' ) <EOL> self .", "gt": ""}
{"id": 32024, "input": "<s> import os <EOL> import sys <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . abspath ( '<STR_LIT:..>' ) ) <EOL> extensions = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> autodoc_member_order = '<STR_LIT>' <EOL> intersphinx_mapping = { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , None ) <EOL> } <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> release = '<STR_LIT>' <EOL> exclude_patterns = [ '<STR_LIT>' ] <EOL> pygments_style = '<STR_LIT>' <EOL> html_theme = '<STR_LIT:default>' <EOL> on_rtd = os . environ . get ( '<STR_LIT>' , None ) == '<STR_LIT:True>' <EOL> if not on_rtd : <EOL> import sphinx_rtd_theme <EOL> html_theme = '<STR_LIT>' <EOL> html_theme_path = [ sphinx_rtd_theme", "gt": ""}
{"id": 49179, "input": "<s> from lixian_commands . util import * <EOL> from lixian_cli_parser import * <EOL> from lixian_config import get_config <EOL> import lixian_help <EOL> import lixian_query <EOL> @ command_line_parser ( help = lixian_help . add ) <EOL> @ with_parser ( parse_login ) <EOL> @ with_parser ( parse_colors ) <EOL> @ with_parser ( parse_logging ) <EOL> @ with_parser ( parse_size ) <EOL> @ command_line_value ( '<STR_LIT>' , default = get_config ( '<STR_LIT>' ) ) <EOL> @ command_line_value ( '<STR_LIT>' , default = get_config", "gt": ""}
{"id": 30177, "input": "<s> import os . path , shutil , sys , random <EOL> from functools import wraps <EOL> from whoosh . filedb . filestore import FileStorage <EOL> from whoosh . util import now <EOL> class TempDir ( object ) : <EOL> def __init__ ( self , parentdir = \"<STR_LIT>\" , basename = None , ext = \"<STR_LIT>\" , <EOL> suppress = frozenset ( ) , keepdir = False ) : <EOL> self . basename = basename or hex ( random . randint ( <NUM_LIT:0> , <NUM_LIT> ) ) [ <NUM_LIT:2> : ] <EOL> dirname = os . path . join ( parentdir , self . basename + ext ) <EOL> self . dir = os . path . abspath ( dirname ) <EOL> self . suppress = suppress <EOL> self . keepdir = keepdir <EOL> def __enter__ ( self ) : <EOL> if not os . path . exists ( self . dir ) : <EOL> os . makedirs ( self . dir ) <EOL> return self . dir <EOL> def __exit__ ( self , exc_type , exc_val , exc_tb ) : <EOL> if not self . keepdir : <EOL> try : <EOL> shutil . rmtree ( self . dir ) <EOL> except OSError : <EOL> e =", "gt": ""}
{"id": 16848, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import atexit <EOL> import ctypes . util <EOL> import platform <EOL> from string import Template <EOL> import sys <EOL> import warnings <EOL> import numpy as np <EOL> import cuda <EOL> _version_list = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> if '<STR_LIT>' in sys . platform : <EOL> _libcusparse_libname_list = [ '<STR_LIT>' ] + [ '<STR_LIT>' % v for v in _version_list ] <EOL> elif sys . platform == '<STR_LIT>' : <EOL> _libcusparse_libname_list = [ '<STR_LIT>' ] <EOL> elif sys . platform == '<STR_LIT:win32>' : <EOL> if platform . machine ( ) . endswith ( '<STR_LIT>' ) : <EOL> _libcusparse_libname_list = [ '<STR_LIT>' ] + [ '<STR_LIT>' % int ( <NUM_LIT:10> * v ) for v in _version_list ] <EOL> else : <EOL> _libcusparse_libname_list = [ '<STR_LIT>' ] + [ '<STR_LIT>' % int ( <NUM_LIT:10> * v ) for v in _version_list ] <EOL> else : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> _libcusparse = None <EOL> for _libcusparse_libname in _libcusparse_libname_list : <EOL> try : <EOL> if sys . platform == '<STR_LIT:win32>' : <EOL> _libcusparse = ctypes . windll . LoadLibrary ( _libcusparse_libname ) <EOL> else : <EOL> _libcusparse = ctypes . cdll . LoadLibrary ( _libcusparse_libname ) <EOL> except OSError : <EOL> pass <EOL> else : <EOL> break <EOL> if _libcusparse == None : <EOL> OSError ( '<STR_LIT>' ) <EOL> class cusparseError ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class cusparseStatusNotInitialized ( cusparseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class cusparseStatusAllocFailed ( cusparseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class cusparseStatusInvalidValue ( cusparseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class cusparseStatusArchMismatch ( cusparseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class cusparseStatusMappingError ( cusparseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class cusparseStatusExecutionFailed ( cusparseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class cusparseStatusInternalError ( cusparseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class cusparseStatusMatrixTypeNotSupported ( cusparseError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> cusparseExceptions = { <EOL> <NUM_LIT:1> : cusparseStatusNotInitialized , <EOL> <NUM_LIT:2> : cusparseStatusAllocFailed , <EOL> <NUM_LIT:3> : cusparseStatusInvalidValue , <EOL> <NUM_LIT:4> : cusparseStatusArchMismatch , <EOL> <NUM_LIT:5> : cusparseStatusMappingError , <EOL> <NUM_LIT:6> : cusparseStatusExecutionFailed , <EOL> <NUM_LIT:7> : cusparseStatusInternalError , <EOL> <NUM_LIT:8> : cusparseStatusMatrixTypeNotSupported , <EOL> } <EOL> CUSPARSE_MATRIX_TYPE_GENERAL = <NUM_LIT:0> <EOL> CUSPARSE_MATRIX_TYPE_SYMMETRIC = <NUM_LIT:1> <EOL> CUSPARSE_MATRIX_TYPE_HERMITIAN = <NUM_LIT:2> <EOL> CUSPARSE_MATRIX_TYPE_TRIANGULAR = <NUM_LIT:3> <EOL> CUSPARSE_FILL_MODE_LOWER = <NUM_LIT:0> <EOL> CUSPARSE_FILL_MODE_UPPER = <NUM_LIT:1> <EOL> CUSPARSE_DIAG_TYPE_NON_UNIT = <NUM_LIT:0> <EOL> CUSPARSE_DIAG_TYPE_UNIT = <NUM_LIT:1> <EOL> CUSPARSE_INDEX_BASE_ZERO = <NUM_LIT:0> <EOL> CUSPARSE_INDEX_BASE_ONE = <NUM_LIT:1> <EOL> CUSPARSE_OPERATION_NON_TRANSPOSE = <NUM_LIT:0> <EOL> CUSPARSE_OPERATION_TRANSPOSE = <NUM_LIT:1> <EOL> CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE = <NUM_LIT:2> <EOL> CUSPARSE_DIRECTION_ROW = <NUM_LIT:0> <EOL> CUSPARSE_DIRECTION_COLUMN = <NUM_LIT:1> <EOL> class cusparseMatDescr ( ctypes . Structure ) : <EOL> _fields_ = [ <EOL> ( '<STR_LIT>' , ctypes . c_int ) , <EOL> ( '<STR_LIT>' , ctypes . c_int ) , <EOL> ( '<STR_LIT>' , ctypes . c_int ) , <EOL> ( '<STR_LIT>' , ctypes . c_int ) <EOL> ] <EOL> def cusparseCheckStatus ( status ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if status != <NUM_LIT:0> : <EOL> try : <EOL> raise cusparseExceptions [ status ] <EOL> except KeyError : <EOL> raise cusparseError <EOL> _libcusparse . cusparseCreate . restype = int <EOL> _libcusparse . cusparseCreate . argtypes = [ ctypes . c_void_p ] <EOL> def cusparseCreate ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> handle = ctypes . c_int ( ) <EOL> status = _libcusparse . cusparseCreate ( ctypes . byref ( handle ) ) <EOL> cusparseCheckStatus ( status ) <EOL> return handle . value <EOL> _libcusparse . cusparseDestroy . restype = int <EOL> _libcusparse . cusparseDestroy . argtypes = [ ctypes . c_int ] <EOL> def cusparseDestroy ( handle ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> status = _libcusparse . cusparseDestroy ( handle ) <EOL> cusparseCheckStatus ( status ) <EOL> _libcusparse . cusparseGetVersion . restype = int <EOL> _libcusparse . cusparseGetVersion . argtypes = [ ctypes . c_int , <EOL> ctypes . c_void_p ] <EOL> def cusparseGetVersion ( handle ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> version = ctypes . c_int ( ) <EOL> status = _libcusparse . cusparseGetVersion ( handle , <EOL> ctypes . byref ( version ) ) <EOL> cusparseCheckStatus ( status ) <EOL> return version . value <EOL> _libcusparse . cusparseSetStream . restype = int <EOL> _libcusparse . cusparseSetStream . argtypes = [ ctypes . c_int , <EOL> ctypes . c_int ] <EOL> def cusparseSetStream ( handle , id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> status = _libcusparse . cusparseSetStream ( handle , id ) <EOL> cusparseCheckStatus ( status ) <EOL> _libcusparse . cusparseCreateMatDescr . restype = int <EOL>", "gt": ""}
{"id": 19603, "input": "<s> import pprint <EOL> import re <EOL> from testrunner import testhelp <EOL> from conary_test import rephelp <EOL> from conary import versions <EOL> from conary . build import cook <EOL> from conary . deps import deps <EOL> from conary . build . errors import GroupPathConflicts <EOL> VFS = versions . VersionFromString <EOL> class GroupSetTest ( rephelp . RepositoryHelper ) : <EOL> def build ( self , str , name , dict = { } , serverIdx = <NUM_LIT:0> , returnName = None , <EOL> groupOptions = None , logLevel = None ) : <EOL> ( built , d ) = self . buildRecipe ( str , name , dict , <EOL> groupOptions = groupOptions , <EOL> logLevel = logLevel ) <EOL> if returnName : <EOL> name , verStr , flavor = [ x for x in built if x [ <NUM_LIT:0> ] == returnName ] [ <NUM_LIT:0> ] <EOL> else : <EOL> name , verStr , flavor = built [ <NUM_LIT:0> ] <EOL> repos = self . openRepository ( serverIdx ) <EOL> version = VFS ( verStr ) <EOL> pkg = repos . getTrove ( name , version , flavor ) <EOL> return pkg <EOL> def checkTroves ( self , collection , desiredList ) : <EOL> refs = sorted ( <EOL> ( ( x [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , x [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] . asString ( ) , str ( x [ <NUM_LIT:0> ] [ <NUM_LIT:2> ] ) ) , x [ <NUM_LIT:1> ] , x [ <NUM_LIT:2> ] ) <EOL> for x in collection . iterTroveListInfo ( ) ) <EOL> desiredList = sorted ( desiredList ) <EOL> if refs != desiredList : <EOL> self . fail ( \"<STR_LIT>\" % ( <EOL> pprint . pformat ( desiredList ) , <EOL> pprint . pformat ( refs ) ) ) <EOL> def _build ( self , * coreList ) : <EOL> recipe = ( <EOL> \"\"\"<STR_LIT>\"\"\" % \"<STR_LIT:\\n>\" . join ( [ \"<STR_LIT>\" % x for x in coreList ] ) ) <EOL> grp = self . build ( recipe , \"<STR_LIT>\" ) <EOL> repos = self . openRepository ( ) <EOL> return repos . getTrove ( '<STR_LIT>' , grp . getVersion ( ) , grp . getFlavor ( ) ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testInstallAndOptional ( self ) : <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , [ <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , False , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , [ <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , [ <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , False , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , [ <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , [ <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , False , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , [ <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , False , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , [ <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , False , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , [ <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , False , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , False , True ) <EOL> ] ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testComponents ( self ) : <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addCollection ( '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT:foo>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , False ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , False , False ) <EOL> ] ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testDependencies ( self ) : <EOL> self . addComponent ( '<STR_LIT>' , <EOL> requires = deps . parseDep ( '<STR_LIT>' ) ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> self . assertRaises ( cook . CookError , self . _build , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testDependencyChain ( self ) : <EOL> self . addComponent ( '<STR_LIT>' , <EOL> requires = deps . parseDep ( '<STR_LIT>' ) ) <EOL> self . addComponent ( '<STR_LIT>' , <EOL> requires = deps . parseDep ( '<STR_LIT>' ) ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ] ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testDependenciesSearchPath ( self ) : <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addCollection ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> d = deps . parseDep ( '<STR_LIT>' ) <EOL> d . union ( deps . parseDep ( '<STR_LIT>' ) ) <EOL> self . addComponent ( '<STR_LIT>' , requires = d ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT:foo>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , False ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT:foo>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , False ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) <EOL> ] ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testDifference ( self ) : <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) ] ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) ] ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testEmpty ( self ) : <EOL> self . addComponent ( \"<STR_LIT>\" ) <EOL> self . addComponent ( \"<STR_LIT>\" ) <EOL> self . addCollection ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ) <EOL> self . assertRaises ( cook . CookError , <EOL> self . _build , <EOL> \"<STR_LIT>\" ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ) <EOL> self . assertRaises ( cook . CookError , <EOL> self . _build , <EOL> \"<STR_LIT>\" ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testFindByName ( self ) : <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . cfg . debugRecipeExceptions = True <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) ] ) <EOL> self . assertRaises ( cook . CookError , self . _build , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) ] ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testFindBySourceName ( self ) : <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addCollection ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> self . addComponent ( '<STR_LIT>' , sourceName = '<STR_LIT>' ) <EOL> self . addCollection ( '<STR_LIT>' , [ '<STR_LIT>' ] , <EOL> sourceName = '<STR_LIT>' ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addCollection ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> grp = self . _build ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ) <EOL> self . checkTroves ( grp , <EOL> [ ( ( '<STR_LIT:foo>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , False ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , True ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , True , False ) <EOL> ] ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testImageGroup ( self ) : <EOL> repos = self . openRepository ( ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addCollection ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> subGrp = repos . getTrove ( '<STR_LIT>' , grp . getVersion ( ) , <EOL> grp . getFlavor ( ) ) <EOL> assert ( not grp . troveInfo . imageGroup ( ) ) <EOL> assert ( not subGrp . troveInfo . imageGroup ( ) ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> subGrp = repos . getTrove ( '<STR_LIT>' , grp . getVersion ( ) , <EOL> grp . getFlavor ( ) ) <EOL> assert ( grp . troveInfo . imageGroup ( ) ) <EOL> assert ( not subGrp . troveInfo . imageGroup ( ) ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> subGrp = repos . getTrove ( '<STR_LIT>' , grp . getVersion ( ) , <EOL> grp . getFlavor ( ) ) <EOL> assert ( grp . troveInfo . imageGroup ( ) ) <EOL> assert ( subGrp . troveInfo . imageGroup ( ) ) <EOL> @ testhelp . context ( '<STR_LIT>' ) <EOL> def testOptionalSubgroup ( self ) : <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> self . addComponent ( '<STR_LIT>' ) <EOL> grp = self . _build ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . checkTroves ( grp , <EOL> [ (", "gt": ""}
{"id": 11664, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> import utils <EOL> from demos import demo_services <EOL> import random <EOL> import string <EOL> import httplib2 <EOL> import json <EOL> import logging <EOL> from apiclient . discovery import build <EOL> from apiclient . errors import HttpError <EOL> from apiclient . errors import UnknownApiNameOrVersion <EOL> from google . appengine . ext import ndb <EOL> from oauth2client . client import AccessTokenRefreshError <EOL> from oauth2client . client import flow_from_clientsecrets <EOL> from oauth2client . client import FlowExchangeError <EOL> from oauth2client . appengine import StorageByKeyName <EOL> def get_credentials ( gplus_id , test ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if test is not None : <EOL> storage = StorageByKeyName ( utils . TestUser , gplus_id , \"<STR_LIT>\" ) <EOL> else : <EOL> storage = StorageByKeyName ( utils . User , gplus_id , \"<STR_LIT>\" ) <EOL> credentials = storage . get ( ) <EOL> return credentials <EOL> def store_credentials ( gplus_id , test , credentials ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if test is not None : <EOL> storage = StorageByKeyName ( utils . TestUser , gplus_id , \"<STR_LIT>\" ) <EOL> else : <EOL> storage = StorageByKeyName ( utils . User , gplus_id , \"<STR_LIT>\" ) <EOL> storage . put ( credentials ) <EOL> def get_auth_service ( gplus_id , test , api = \"<STR_LIT>\" , version = \"<STR_LIT>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if test is not None and api == \"<STR_LIT>\" and version == \"<STR_LIT>\" : <EOL> discovery_service_url = utils . discovery_service_url <EOL> else : <EOL> discovery_service_url = None <EOL> credentials = get_credentials ( gplus_id , test ) <EOL> if credentials is None : <EOL> return None <EOL> http = httplib2 . Http ( ) <EOL> http = credentials . authorize ( http ) <EOL> http . timeout = <NUM_LIT> <EOL> if discovery_service_url is None : <EOL> service = build ( api , version , http = http ) <EOL> else : <EOL> service = build ( api , version , http = http , discoveryServiceUrl = discovery_service_url ) <EOL> return service <EOL> def _disconnect ( gplus_id , test ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> store_credentials ( gplus_id , test , None ) <EOL> class ConnectHandler ( utils . BaseHandler ) : <EOL> def post ( self , test ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . response . content_type = \"<STR_LIT:application/json>\" <EOL> state = self . request . get ( \"<STR_LIT:state>\" ) <EOL> gplus_id = self . request . get ( \"<STR_LIT>\" ) <EOL> code = self . request . body <EOL> if state != self . session . get ( \"<STR_LIT:state>\" ) : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) ) <EOL> return <EOL> try : <EOL> oauth_flow = flow_from_clientsecrets ( '<STR_LIT>' , scope = '<STR_LIT>' ) <EOL> oauth_flow . redirect_uri = '<STR_LIT>' <EOL> credentials = oauth_flow . step2_exchange ( code ) <EOL> except FlowExchangeError : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( <EOL> utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) <EOL> ) <EOL> return <EOL> access_token = credentials . access_token <EOL> url = ( \"<STR_LIT>\" % access_token ) <EOL> h = httplib2 . Http ( ) <EOL> result = json . loads ( h . request ( url , '<STR_LIT:GET>' ) [ <NUM_LIT:1> ] ) <EOL> if result . get ( \"<STR_LIT:error>\" ) is not None : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( json . dumps ( result . get ( \"<STR_LIT:error>\" ) ) ) <EOL> return <EOL> if result [ \"<STR_LIT>\" ] != gplus_id : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( <EOL> utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) <EOL> ) <EOL> return <EOL> if result [ '<STR_LIT>' ] != utils . CLIENT_ID : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( <EOL> utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) <EOL> ) <EOL> return <EOL> self . session [ \"<STR_LIT>\" ] = gplus_id <EOL> stored_credentials = get_credentials ( gplus_id , test ) <EOL> new_user = False <EOL> if stored_credentials is None : <EOL> new_user = True <EOL> store_credentials ( gplus_id , test , credentials ) <EOL> credentials = get_credentials ( gplus_id , test ) <EOL> if credentials . refresh_token is None : <EOL> _disconnect ( gplus_id , test ) <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( <EOL> utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) <EOL> ) <EOL> return <EOL> try : <EOL> service = get_auth_service ( gplus_id , test ) <EOL> plus_service = get_auth_service ( gplus_id , test , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> except AccessTokenRefreshError : <EOL> _disconnect ( gplus_id , test ) <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) ) <EOL> return <EOL> except UnknownApiNameOrVersion : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) ) <EOL> return <EOL> except HttpError as e : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" % e ) ) <EOL> return <EOL> try : <EOL> result = plus_service . people ( ) . get ( userId = \"<STR_LIT>\" , fields = \"<STR_LIT>\" ) . execute ( ) <EOL> except AccessTokenRefreshError : <EOL> _disconnect ( gplus_id , test ) <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) ) <EOL> return <EOL> except HttpError as e : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" % e ) ) <EOL> return <EOL> if test is not None : <EOL> user = ndb . Key ( \"<STR_LIT>\" , gplus_id ) . get ( ) <EOL> else : <EOL> user = ndb . Key ( \"<STR_LIT>\" , gplus_id ) . get ( ) <EOL> user . displayName = result [ \"<STR_LIT>\" ] <EOL> user . imageUrl = result [ \"<STR_LIT:image>\" ] [ \"<STR_LIT:url>\" ] <EOL> user . put ( ) <EOL> try : <EOL> result = plus_service . people ( ) . list ( userId = \"<STR_LIT>\" , collection = \"<STR_LIT>\" , maxResults = <NUM_LIT:100> , orderBy = \"<STR_LIT>\" , fields = \"<STR_LIT>\" ) . execute ( ) <EOL> except AccessTokenRefreshError : <EOL> _disconnect ( gplus_id , test ) <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) ) <EOL> return <EOL> except HttpError as e : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" % e ) ) <EOL> return <EOL> friends = [ ] <EOL> if \"<STR_LIT>\" in result : <EOL> for item in result [ \"<STR_LIT>\" ] : <EOL> friends . append ( item [ \"<STR_LIT:id>\" ] ) <EOL> user . friends = friends <EOL> user . put ( ) <EOL> try : <EOL> result = service . contacts ( ) . list ( ) . execute ( ) <EOL> if \"<STR_LIT>\" in result : <EOL> for contact in result [ \"<STR_LIT>\" ] : <EOL> del_result = service . contacts ( ) . delete ( id = contact [ \"<STR_LIT:id>\" ] ) . execute ( ) <EOL> except AccessTokenRefreshError : <EOL> _disconnect ( gplus_id , test ) <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) ) <EOL> return <EOL> except HttpError as e : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" % e ) ) <EOL> return <EOL> contacts = [ ] <EOL> for demo_service in demo_services : <EOL> if hasattr ( demo_service , \"<STR_LIT>\" ) : <EOL> contacts . extend ( demo_service . CONTACTS ) <EOL> for contact in contacts : <EOL> try : <EOL> result = service . contacts ( ) . insert ( body = contact ) . execute ( ) <EOL> except AccessTokenRefreshError : <EOL> _disconnect ( gplus_id , test ) <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) ) <EOL> return <EOL> except HttpError as e : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" % e ) ) <EOL> return <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> result = service . subscriptions ( ) . list ( ) . execute ( ) <EOL> if \"<STR_LIT>\" in result : <EOL> for subscription in result [ \"<STR_LIT>\" ] : <EOL> del_result = service . subscriptions ( ) . delete ( id = subscription [ \"<STR_LIT:id>\" ] ) . execute ( ) <EOL> except AccessTokenRefreshError : <EOL> _disconnect ( gplus_id , test ) <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" ) ) <EOL> return <EOL> except HttpError as e : <EOL> self . response . status = <NUM_LIT> <EOL> self . response . out . write ( utils . createError ( <NUM_LIT> , \"<STR_LIT>\" % e ) ) <EOL> return <EOL> verifyToken = '<STR_LIT>' . join ( random . choice ( string . ascii_letters + string . digits ) for x in range (", "gt": ""}
{"id": 48433, "input": "<s> from foam . core import json <EOL> class SliverURN ( json . JSONInput ) : <EOL> @ staticmethod <EOL> def validate", "gt": ""}
{"id": 21796, "input": "<s> try : <EOL> set <EOL> except NameError : <EOL> from sets import Set as set <EOL> from django . core . exceptions import ImproperlyConfigured <EOL> from django . db import models <EOL> from django . forms . models import BaseModelForm , BaseModelFormSet , fields_for_model , _get_foreign_key <EOL> from django . contrib . admin . options import flatten_fieldsets , BaseModelAdmin <EOL> from django . contrib . admin . options import HORIZONTAL , VERTICAL <EOL> __all__ = [ '<STR_LIT>' ] <EOL> def validate ( cls , model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> models . get_apps ( ) <EOL> opts = model . _meta <EOL> validate_base ( cls , model ) <EOL> if hasattr ( cls , '<STR_LIT>' ) : <EOL> check_isseq ( cls , '<STR_LIT>' , cls . list_display ) <EOL> for idx , field in enumerate ( cls . list_display ) : <EOL> if not callable ( field ) : <EOL> if not hasattr ( cls , field ) : <EOL> if not hasattr ( model , field ) : <EOL> try : <EOL> opts . get_field ( field ) <EOL> except models . FieldDoesNotExist : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> % ( cls . __name__ , idx , field , cls . __name__ , model . _meta . object_name ) ) <EOL> else : <EOL> f = fetch_attr ( cls , model , opts , \"<STR_LIT>\" % idx , field ) <EOL> if isinstance ( f , models . ManyToManyField ) : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> % ( cls . __name__ , idx , field ) ) <EOL> if hasattr ( cls , '<STR_LIT>' ) : <EOL> check_isseq ( cls , '<STR_LIT>' , cls . list_display_links ) <EOL> for idx , field in enumerate ( cls . list_display_links ) : <EOL> fetch_attr ( cls , model , opts , '<STR_LIT>' % idx , field ) <EOL> if field not in cls . list_display : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( cls . __name__ , idx , field ) ) <EOL> if hasattr ( cls , '<STR_LIT>' ) : <EOL> check_isseq ( cls , '<STR_LIT>' , cls . list_filter ) <EOL> for idx , field in enumerate ( cls . list_filter ) : <EOL> get_field ( cls , model , opts , '<STR_LIT>' % idx , field ) <EOL> if hasattr ( cls , '<STR_LIT>' ) and not isinstance ( cls . list_per_page , int ) : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> % cls . __name__ ) <EOL> if hasattr ( cls , '<STR_LIT>' ) and cls . list_editable : <EOL> check_isseq ( cls , '<STR_LIT>' , cls . list_editable ) <EOL> for idx , field_name in enumerate ( cls . list_editable ) : <EOL> try : <EOL> field = opts . get_field_by_name ( field_name ) [ <NUM_LIT:0> ] <EOL> except models . FieldDoesNotExist : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( cls . __name__ , idx , field_name , model . __name__ ) ) <EOL> if field_name not in cls . list_display : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( cls . __name__ , idx , field_name ) ) <EOL> if field_name in cls . list_display_links : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( field_name , cls . __name__ , cls . __name__ ) ) <EOL> if not cls . list_display_links and cls . list_display [ <NUM_LIT:0> ] in cls . list_editable : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( cls . __name__ , idx , cls . list_display [ <NUM_LIT:0> ] ) ) <EOL> if not field . editable : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( cls . __name__ , idx , field_name ) ) <EOL> if hasattr ( cls , '<STR_LIT>' ) : <EOL> check_isseq ( cls , '<STR_LIT>' , cls . search_fields ) <EOL> if cls . date_hierarchy : <EOL> f = get_field ( cls , model , opts , '<STR_LIT>' , cls . date_hierarchy ) <EOL> if not isinstance ( f , ( models . DateField , models . DateTimeField ) ) : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % cls . __name__ ) <EOL> if cls . ordering : <EOL> check_isseq ( cls , '<STR_LIT>' , cls . ordering ) <EOL> for idx , field in enumerate ( cls . ordering ) : <EOL> if field == '<STR_LIT:?>' and len ( cls . ordering ) != <NUM_LIT:1> : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % cls . __name__ ) <EOL> if field == '<STR_LIT:?>' : <EOL> continue <EOL> if field . startswith ( '<STR_LIT:->' ) : <EOL> field =", "gt": ""}
{"id": 10884, "input": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . OneToOneField ( parent_link = True , auto_created", "gt": ""}
{"id": 4680, "input": "<s> from sys import hexversion <EOL> import random <EOL> from . context import sortedcontainers <EOL> from sortedcontainers import SortedList <EOL> from itertools import chain <EOL> from nose . tools import raises <EOL> if hexversion < <NUM_LIT> : <EOL> from itertools import izip as zip <EOL> range = xrange <EOL> def test_init ( ) : <EOL> slt = SortedList ( ) <EOL> slt . _check ( ) <EOL> slt = SortedList ( load = <NUM_LIT> ) <EOL> assert slt . _load == <NUM_LIT> <EOL> assert slt . _twice == <NUM_LIT> <EOL> assert slt . _half == <NUM_LIT> <EOL> slt . _check ( ) <EOL> slt = SortedList ( range ( <NUM_LIT> ) ) <EOL> assert all ( tup [ <NUM_LIT:0> ] == tup [ <NUM_LIT:1> ] for tup in zip ( slt , range ( <NUM_LIT> ) ) ) <EOL> slt . clear ( ) <EOL> assert slt . _len == <NUM_LIT:0> <EOL> assert slt . _maxes == [ ] <EOL> assert slt . _lists == [ ] <EOL> slt . _check ( ) <EOL> def test_add ( ) : <EOL> random . seed ( <NUM_LIT:0> ) <EOL> slt = SortedList ( ) <EOL> for val in range ( <NUM_LIT:1000> ) : <EOL> slt . add ( val ) <EOL> slt . _check ( ) <EOL> slt = SortedList ( ) <EOL> for val in range ( <NUM_LIT:1000> , <NUM_LIT:0> , - <NUM_LIT:1> ) : <EOL> slt . add ( val ) <EOL> slt . _check ( ) <EOL> slt = SortedList ( ) <EOL> for val in range ( <NUM_LIT:1000> ) : <EOL> slt . add ( random . random ( ) ) <EOL> slt . _check ( ) <EOL> def test_update ( ) : <EOL> slt = SortedList ( ) <EOL> slt . update ( range ( <NUM_LIT:1000> ) ) <EOL> assert len ( slt ) == <NUM_LIT:1000> <EOL> slt . _check ( ) <EOL> slt . update ( range ( <NUM_LIT:100> ) ) <EOL> assert len ( slt ) == <NUM_LIT> <EOL> slt . _check ( ) <EOL> slt . update ( range ( <NUM_LIT> ) ) <EOL> assert len ( slt ) == <NUM_LIT> <EOL> slt . _check ( ) <EOL> values = sorted ( chain ( range ( <NUM_LIT:1000> ) , range ( <NUM_LIT:100> ) , range ( <NUM_LIT> ) ) ) <EOL> assert all ( tup [ <NUM_LIT:0> ] == tup [ <NUM_LIT:1> ] for tup in zip ( slt , values ) ) <EOL> def test_contains ( ) : <EOL> slt = SortedList ( ) <EOL> assert <NUM_LIT:0> not in slt <EOL> slt . update ( range ( <NUM_LIT> ) ) <EOL> for val in range ( <NUM_LIT> ) : <EOL> assert val in slt <EOL> assert <NUM_LIT> not in slt <EOL> slt . _check ( ) <EOL> def test_discard ( ) : <EOL> slt = SortedList ( ) <EOL> assert slt . discard ( <NUM_LIT:0> ) == None <EOL> assert len ( slt ) == <NUM_LIT:0> <EOL> slt . _check ( ) <EOL> slt = SortedList ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:5> ] , load = <NUM_LIT:4> ) <EOL> slt . discard ( <NUM_LIT:6> ) <EOL> slt . _check ( ) <EOL> slt . discard ( <NUM_LIT:4> ) <EOL> slt . _check ( ) <EOL> slt . discard ( <NUM_LIT:2> ) <EOL> slt . _check ( ) <EOL> assert all ( tup [ <NUM_LIT:0> ] == tup [ <NUM_LIT:1> ] for tup in zip ( slt , [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:5> ] ) ) <EOL> def test_remove ( ) : <EOL> slt = SortedList ( ) <EOL> assert slt . discard ( <NUM_LIT:0> ) == None <EOL> assert len ( slt ) == <NUM_LIT:0> <EOL> slt . _check ( ) <EOL> slt = SortedList ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:5> ] , load = <NUM_LIT:4> ) <EOL> slt . remove ( <NUM_LIT:2> ) <EOL> slt . _check ( ) <EOL> assert all ( tup [ <NUM_LIT:0> ] == tup [ <NUM_LIT:1> ] for tup in zip ( slt , [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:5> ] ) ) <EOL> @ raises ( ValueError ) <EOL> def test_remove_valueerror1 ( ) : <EOL> slt = SortedList ( ) <EOL> slt . remove ( <NUM_LIT:0> ) <EOL> @ raises ( ValueError ) <EOL> def test_remove_valueerror2 ( ) : <EOL> slt = SortedList ( range ( <NUM_LIT:100> ) , load = <NUM_LIT:10> ) <EOL> slt . remove ( <NUM_LIT:100> ) <EOL> @ raises ( ValueError ) <EOL> def test_remove_valueerror3 ( ) : <EOL> slt = SortedList ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:5> ] ) <EOL> slt . remove ( <NUM_LIT:4> ) <EOL> def test_delete ( ) : <EOL> slt = SortedList ( range ( <NUM_LIT:20> ) , load = <NUM_LIT:4> ) <EOL> slt . _check ( ) <EOL> for val in range ( <NUM_LIT:20> ) : <EOL> slt . remove ( val ) <EOL> slt . _check ( ) <EOL> assert len ( slt ) == <NUM_LIT:0> <EOL> assert slt . _maxes == [ ] <EOL> assert slt . _lists == [ ] <EOL> def test_getitem ( ) : <EOL> random . seed ( <NUM_LIT:0> ) <EOL> slt = SortedList ( load = <NUM_LIT> ) <EOL> lst = list ( ) <EOL> for rpt in range ( <NUM_LIT:100> ) : <EOL> val = random . random ( ) <EOL> slt . add ( val ) <EOL> lst . append ( val ) <EOL> lst . sort ( ) <EOL> assert all ( slt [ idx ] == lst [ idx ] for idx in range ( <NUM_LIT:100> ) ) <EOL> assert all ( slt [ idx - <NUM_LIT> ] == lst [ idx - <NUM_LIT> ] for idx in range ( <NUM_LIT:100> ) ) <EOL> def test_getitem_slice ( ) : <EOL> random . seed ( <NUM_LIT:0> ) <EOL> slt = SortedList ( load = <NUM_LIT> ) <EOL> lst = list ( ) <EOL> for rpt in range ( <NUM_LIT:100> ) : <EOL> val = random . random ( ) <EOL> slt . add ( val ) <EOL> lst . append ( val ) <EOL> lst . sort ( ) <EOL> assert all ( slt [ start : ] == lst [ start : ] <EOL> for start in [ - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> ] ) <EOL> assert all ( slt [ : stop ] == lst [ : stop ] <EOL> for stop in [ - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> ] ) <EOL> assert all ( slt [ : : step ] == lst [ : : step ] <EOL> for step in [ - <NUM_LIT:5> , - <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:5> ] ) <EOL> assert all ( slt [ start : stop ] == lst [ start : stop ] <EOL> for start in [ - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> ] <EOL> for stop in [ - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> ] ) <EOL> assert all ( slt [ : stop : step ] == lst [ : stop : step ] <EOL> for stop in [ - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> ] <EOL> for step in [ - <NUM_LIT:5> , - <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:5> ] ) <EOL> assert all ( slt [ start : : step ] == lst [ start : : step ] <EOL> for start in [ - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> ] <EOL> for step in [ - <NUM_LIT:5> , - <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:5> ] ) <EOL> assert all ( slt [ start : stop : step ] == lst [ start : stop : step ] <EOL> for start in [ - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> ] <EOL> for stop in [ - <NUM_LIT> , - <NUM_LIT> ,", "gt": ""}
{"id": 19398, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from docutils . parsers import rst <EOL> from docutils . nodes import Admonition , Element <EOL> from docutils . parsers . rst import directives <EOL> class OddEvenNode ( Admonition , Element ) : <EOL> pass <EOL> class OddEven ( rst . Directive", "gt": ""}
{"id": 37515, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> try : <EOL> from pycarddav import model <EOL> import xdg . BaseDirectory <EOL> import sys <EOL> import sqlite3 <EOL> import logging <EOL> from os import path <EOL> except ImportError , error : <EOL> print ( error ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> OK = <NUM_LIT:0> <EOL> NEW = <NUM_LIT:1> <EOL> CHANGED = <NUM_LIT:2> <EOL> DELETED = <NUM_LIT:9> <EOL> class SQLiteDb ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , <EOL> db_path = None , <EOL> encoding = \"<STR_LIT:utf-8>\" , <EOL> errors = \"<STR_LIT:strict>\" , <EOL> debug = False ) : <EOL> if db_path is None : <EOL> db_path = xdg . BaseDirectory . save_data_path ( '<STR_LIT>' ) + '<STR_LIT>' <EOL> self . db_path = path . expanduser ( db_path ) <EOL> self . conn = sqlite3 . connect ( self . db_path ) <EOL> self . cursor = self . conn . cursor ( ) <EOL> self . encoding = encoding <EOL> self . errors = errors <EOL> self . debug = debug <EOL> self . display_all = False <EOL> self . print_function = \"<STR_LIT>\" <EOL> self . _create_default_tables ( ) <EOL> self . _check_table_version ( ) <EOL> def __del__ ( self ) : <EOL> self . conn . close ( ) <EOL> def search ( self , search_string , accounts , where = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if where not in ( '<STR_LIT>' , '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> search_str = '<STR_LIT:%>' + search_string + '<STR_LIT:%>' <EOL> sql_fmt = '<STR_LIT>' <EOL> if where == '<STR_LIT>' : <EOL> sql_fmt += '<STR_LIT>' <EOL> sql_args = ( search_str , search_str ) <EOL> else : <EOL> sql_fmt += where + '<STR_LIT>' <EOL> sql_args = ( search_str , ) <EOL> result = list ( ) <EOL> for account in accounts : <EOL> rows = self . sql_ex ( sql_fmt . format ( account + '<STR_LIT>' ) , sql_args ) <EOL> result . extend ( ( self . get_vcard_from_data ( account , * r ) for r in rows ) ) <EOL> return result <EOL> def _dump ( self , account_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> sql_s = '<STR_LIT>' . format ( account_name + '<STR_LIT>' ) <EOL> result = self . sql_ex ( sql_s ) <EOL> return result <EOL> def _check_table_version ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> database_version = <NUM_LIT:11> <EOL> self . cursor . execute ( '<STR_LIT>' ) <EOL> result = self . cursor . fetchone ( ) <EOL> if result is None : <EOL> stuple = ( database_version , ) <EOL> self . cursor . execute ( '<STR_LIT>' , <EOL> stuple ) <EOL> self . conn .", "gt": ""}
{"id": 32117, "input": "<s> from __future__ import absolute_import <EOL> import socket <EOL> from . import util , exception <EOL> from . const import * <EOL> try : <EOL> from settings import RAW_LOG <EOL> except ImportError : <EOL> RAW_LOG = False <EOL> class BaseSocket ( object ) : <EOL> def __init__ ( self , addr , charset = '<STR_LIT:utf-8>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . addr = addr <EOL> self . charset = charset <EOL> self . msgqueue = [ ] <EOL> self . recvbuffer = '<STR_LIT>' <EOL> self . connected = None <EOL> self . create_socket ( ) <EOL> def create_socket ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . socket = socket . socket ( ) <EOL> def send ( self , line ) : <EOL> raise NotImplementedError <EOL> def connect ( self ) : <EOL> self . msgqueue . append ( CONNECTED ) <EOL> self . connected = True <EOL> raise NotImplementedError <EOL> def disconnect ( self ) : <EOL> self . msgqueue . append ( DISCONNECTED ) <EOL> raise NotImplementedError <EOL> def _recv ( self ) : <EOL> raise NotImplementedError <EOL> def sendln ( self , line , * arg , ** kwargs ) : <EOL> if len ( arg ) or len ( kwargs ) : <EOL> line = line . format ( * arg , ** kwargs ) <EOL> self . send ( line + '<STR_LIT:\\r\\n>' ) <EOL> def cmds ( self , cmd , * args ) : <EOL> self . sendln ( u'<STR_LIT:U+0020>' . join ( map ( unicode , [ cmd ] + list ( args ) ) ) ) <EOL> def cmdl ( self , cmd , * args ) : <EOL> nargs = list ( args [ : - <NUM_LIT:1> ] ) + [ '<STR_LIT::>' + args [ - <NUM_LIT:1> ] ] <EOL> self . cmds ( cmd , * nargs ) <EOL> def cmd ( self , cmd , * args ) : <EOL> if '<STR_LIT:U+0020>' in args [ - <NUM_LIT:1> ] : <EOL> self . cmdl ( cmd , * args ) <EOL> else : <EOL> self . cmds ( cmd , * args ) <EOL> def dispatch ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( self . msgqueue ) == <NUM_LIT:0> : <EOL> return None <EOL> msg = self . msgqueue [ <NUM_LIT:0> ] <EOL> del ( self . msgqueue [ <NUM_LIT:0> ] ) <EOL> if RAW_LOG : <EOL> print '<STR_LIT:>>' , msg <EOL> return msg <EOL> def dispatch_all (", "gt": ""}
{"id": 4637, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> custom_targeting_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> targeting_key_statement = dfp . FilterStatement ( ) <EOL> all_keys = [ ] <EOL> while True : <EOL> response = custom_targeting_service . getCustomTargetingKeysByStatement ( <EOL> targeting_key_statement . ToStatement ( ) ) <EOL> if '<STR_LIT>' in response : <EOL> all_keys . extend ( response [ '<STR_LIT>'", "gt": ""}
{"id": 12068, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from airflow import DAG <EOL> from airflow . operators import BashOperator <EOL> from datetime import datetime , timedelta <EOL> seven_days_ago = datetime . combine ( datetime . today ( ) - timedelta ( <NUM_LIT:7> ) , <EOL> datetime . min . time ( ) ) <EOL> default_args = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : seven_days_ago , <EOL> '<STR_LIT:email>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : timedelta ( minutes = <NUM_LIT:5> ) , <EOL> } <EOL> dag = DAG ( '<STR_LIT>' , default_args = default_args ) <EOL> t1 = BashOperator ( <EOL> task_id = '<STR_LIT>' , <EOL> bash_command = '<STR_LIT:date>' , <EOL> dag = dag ) <EOL> t1 . doc_md = \"\"\"<STR_LIT>\"\"\" <EOL> dag . doc_md = __doc__ <EOL> t2 =", "gt": ""}
{"id": 42877, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> import json <EOL> import logging <EOL> import os <EOL> import sys <EOL> import time <EOL> from functools import partial <EOL> from operator import attrgetter <EOL> from tornado import httpclient , ioloop , options <EOL> from viewfinder . backend . base import util <EOL> from viewfinder . resources . geodata . geoprocessor import GeoProcessor <EOL> options . define ( '<STR_LIT>' , default = '<STR_LIT>' , help = '<STR_LIT>' ) <EOL> options . define ( '<STR_LIT>' , default = <NUM_LIT:10> , help = '<STR_LIT>' ) <EOL> class GeoLookup ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , io_loop , geoproc ) : <EOL> self . _io_loop = io_loop <EOL> self . _geoproc = geoproc <EOL> self . _http_client = httpclient . AsyncHTTPClient ( ) <EOL> try : <EOL> with open ( options . options . lookupdb , '<STR_LIT:r>' ) as rf : <EOL> self . _lookup_db = json . load ( rf ) <EOL> except : <EOL> self . _lookup_db = { } <EOL> def RefreshDB ( self , callback ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _OnLookup ( city , barrier_cb , response ) : <EOL> if response . code != <NUM_LIT:200> : <EOL> logging . error ( '<STR_LIT>' % response ) <EOL> else : <EOL> try : <EOL> json_response = json . loads ( response . body ) <EOL> components = [ ] <EOL> if len ( json_response [ '<STR_LIT>' ] ) > <NUM_LIT:0> : <EOL> for comp in json_response [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] : <EOL> for t in comp [ '<STR_LIT>' ] : <EOL> if t in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL>", "gt": ""}
{"id": 4956, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , unicode_literals <EOL> import collections <EOL> import datetime <EOL> import logging <EOL> import random <EOL> import re <EOL> import sys <EOL> import time <EOL> try : <EOL> from urllib import quote as _quote <EOL> from urllib import unquote as _unquote <EOL> from urllib import urlencode as _urlencode <EOL> except ImportError : <EOL> from urllib . parse import quote as _quote <EOL> from urllib . parse import unquote as _unquote <EOL> from urllib . parse import urlencode as _urlencode <EOL> try : <EOL> import urlparse <EOL> except ImportError : <EOL> import urllib . parse as urlparse <EOL> UNICODE_ASCII_CHARACTER_SET = ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> CLIENT_ID_CHARACTER_SET = ( r'<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> SANITIZE_PATTERN = re . compile ( r'<STR_LIT>' , re . IGNORECASE ) <EOL> INVALID_HEX_PATTERN = re . compile ( r'<STR_LIT>' ) <EOL> always_safe = ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' '<STR_LIT>' ) <EOL> log = logging . getLogger ( '<STR_LIT>' ) <EOL> PY3 = sys . version_info [ <NUM_LIT:0> ] == <NUM_LIT:3> <EOL> if PY3 : <EOL> unicode_type = str <EOL> bytes_type = bytes <EOL> else : <EOL> unicode_type = unicode <EOL> bytes_type = str <EOL> def quote ( s , safe = b'<STR_LIT:/>' ) : <EOL> s = s . encode ( '<STR_LIT:utf-8>' ) if isinstance ( s , unicode_type ) else s <EOL> s = _quote ( s , safe ) <EOL> if isinstance ( s , bytes_type ) : <EOL> s = s . decode ( '<STR_LIT:utf-8>' ) <EOL> return s <EOL> def unquote ( s ) : <EOL> s = _unquote ( s ) <EOL> if isinstance ( s , bytes_type ) : <EOL> s = s . decode ( '<STR_LIT:utf-8>' ) <EOL> return s <EOL> def urlencode ( params ) : <EOL> utf8_params = encode_params_utf8 ( params ) <EOL> urlencoded = _urlencode ( utf8_params ) <EOL> if isinstance ( urlencoded , unicode_type ) : <EOL> return urlencoded <EOL> else : <EOL> return urlencoded . decode ( \"<STR_LIT:utf-8>\" ) <EOL> def encode_params_utf8 ( params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> encoded = [ ] <EOL> for k , v in params : <EOL> encoded . append ( ( <EOL> k . encode ( '<STR_LIT:utf-8>' ) if isinstance ( k , unicode_type ) else k , <EOL> v . encode ( '<STR_LIT:utf-8>' ) if isinstance ( v , unicode_type ) else v ) ) <EOL> return encoded <EOL> def decode_params_utf8 ( params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> decoded = [ ] <EOL> for k , v in params : <EOL> decoded . append ( ( <EOL> k . decode ( '<STR_LIT:utf-8>' ) if isinstance ( k , bytes_type ) else k , <EOL> v . decode ( '<STR_LIT:utf-8>' ) if isinstance ( v , bytes_type ) else v ) ) <EOL> return decoded <EOL> urlencoded = set ( always_safe ) | set ( '<STR_LIT>' ) <EOL> def urldecode ( query ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if query and not set ( query ) <= urlencoded : <EOL> error = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> raise ValueError ( error % ( set ( query ) - urlencoded , query ) ) <EOL> if INVALID_HEX_PATTERN . search ( query ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> query = query . encode ( <EOL> '<STR_LIT:utf-8>' ) if not PY3 and isinstance ( query , unicode_type ) else query <EOL> params = urlparse . parse_qsl ( query , keep_blank_values = True ) <EOL> return decode_params_utf8 ( params ) <EOL> def extract_params ( raw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( raw , bytes_type ) or isinstance ( raw , unicode_type ) : <EOL> try : <EOL> params = urldecode ( raw ) <EOL> except ValueError : <EOL> params = None <EOL> elif hasattr ( raw , '<STR_LIT>' ) : <EOL> try : <EOL> dict ( raw ) <EOL> except ValueError : <EOL> params = None <EOL> except TypeError : <EOL> params = None <EOL> else : <EOL> params = list ( raw . items ( ) if isinstance ( raw , dict ) else raw ) <EOL> params = decode_params_utf8 ( params ) <EOL> else : <EOL> params = None <EOL> return params <EOL> def generate_nonce ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return unicode_type ( unicode_type ( random . getrandbits ( <NUM_LIT:64> ) ) + generate_timestamp ( ) ) <EOL> def generate_timestamp ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return unicode_type ( int ( time . time ( ) ) ) <EOL> def generate_token ( length = <NUM_LIT:30> , chars = UNICODE_ASCII_CHARACTER_SET ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rand = random . SystemRandom ( ) <EOL> return '<STR_LIT>' . join ( rand . choice ( chars ) for x in range ( length ) ) <EOL> def generate_signed_token ( private_pem , request ) : <EOL> import jwt <EOL> now = datetime . datetime . utcnow ( ) <EOL> claims = { <EOL> '<STR_LIT>' : request . scope , <EOL> '<STR_LIT>' : now + datetime . timedelta ( seconds = request . expires_in ) <EOL> } <EOL> claims . update ( request . claims ) <EOL> token = jwt . encode ( claims , private_pem , '<STR_LIT>' ) <EOL>", "gt": ""}
{"id": 22148, "input": "<s> from __future__ import division , print_function , unicode_literals <EOL> import numpy as np <EOL> from brainstorm . handlers . base_handler import Handler <EOL> class DebugArray ( object ) : <EOL> def __init__ ( self , arr ) : <EOL> assert arr is not None <EOL> self . shape = arr . shape <EOL> self . array = arr <EOL> self . size = self . array . size <EOL> def __getitem__ ( self , item ) : <EOL> if isinstance ( item , ( int , slice ) ) : <EOL> item = tuple ( [ item ] ) <EOL> assert isinstance ( item , tuple ) <EOL> for i in item : <EOL> assert isinstance ( i , ( int , slice ) ) <EOL> if isinstance ( i , slice ) : <EOL> assert i . step is None <EOL> return DebugArray ( arr = self . array . __getitem__ ( item ) ) <EOL> def reshape ( self , new_shape ) : <EOL> if isinstance ( new_shape , ( tuple , list ) ) : <EOL> assert all ( [ t >= <NUM_LIT:0> for t in tuple ( new_shape ) ] ) <EOL> else : <EOL> assert isinstance ( new_shape , int ) <EOL> assert new_shape >= <NUM_LIT:0> <EOL> return DebugArray ( arr = self . array . reshape ( new_shape ) ) <EOL> def _check_for_inf ( handler , arg , name ) : <EOL> if isinstance ( arg , ( int , float ) ) and not np . isfinite ( arg ) : <EOL> raise ValueError ( '<STR_LIT>' <EOL> . format ( name ) ) <EOL> if isinstance ( arg , DebugArray ) and not handler . is_fully_finite ( arg ) : <EOL> raise ValueError ( '<STR_LIT>' . format ( name ) ) <EOL> def check_for_inf_or_nan ( f ) : <EOL> def checked_f ( * args , ** kwargs ) : <EOL> result = f ( * args , ** kwargs ) <EOL> handler = args [ <NUM_LIT:0> ] <EOL> for i , arg in enumerate ( args , start = <NUM_LIT:1> ) : <EOL> _check_for_inf ( handler , arg , '<STR_LIT>' . format ( i ) ) <EOL> for n , v in kwargs . items ( ) : <EOL> _check_for_inf ( handler , v , n ) <EOL> return result <EOL> return checked_f <EOL> class DebugHandler ( Handler ) : <EOL> __undescribed__ = { '<STR_LIT>' , '<STR_LIT>' } <EOL> def __init__ ( self , handler ) : <EOL> super ( DebugHandler , self ) . __init__ ( ) <EOL> self . handler = handler <EOL> self . EMPTY = DebugArray ( arr = handler . EMPTY ) <EOL> self . array_type = DebugArray <EOL> def __init_from_description__ ( self , description ) : <EOL> self . __init__ ( self . handler ) <EOL> def allocate ( self , shape ) : <EOL> assert_is_shape ( shape ) <EOL> return DebugArray ( self . handler . allocate ( shape ) ) <EOL> def ones ( self , shape ) : <EOL> assert_is_shape ( shape ) <EOL> return DebugArray ( self . handler . ones ( shape ) ) <EOL> def zeros ( self , shape ) : <EOL> assert_is_shape ( shape ) <EOL> return DebugArray ( self . handler . zeros ( shape ) ) <EOL> @ check_for_inf_or_nan <EOL> def copy_to ( self , src , dest ) : <EOL> assert_debug_arrays ( dest , src ) <EOL> assert_shapes_equal ( dest , src ) <EOL> assert dest . size == src . size , \"<STR_LIT>\" . format ( dest . size , src . size ) <EOL> self . handler . copy_to ( src . array , dest . array ) <EOL> @ check_for_inf_or_nan <EOL> def copy_to_if ( self , src , dest , cond ) : <EOL> assert_debug_arrays ( src , dest , cond ) <EOL> assert_shapes_equal ( src , dest , cond ) <EOL> self . handler . copy_to_if ( src . array , dest . array , cond . array ) <EOL> @ check_for_inf_or_nan <EOL> def create_from_numpy ( self , arr ) : <EOL> assert isinstance ( arr , np . ndarray ) <EOL> return DebugArray ( self . handler . create_from_numpy ( arr ) ) <EOL> @ check_for_inf_or_nan <EOL> def fill ( self , mem , val ) : <EOL> assert_debug_arrays ( mem ) <EOL> assert_is_scalar ( val ) <EOL> self . handler . fill ( mem . array , val ) <EOL> @ check_for_inf_or_nan <EOL> def fill_if ( self , mem , val , cond ) : <EOL> assert_is_scalar ( val ) <EOL> assert_debug_arrays ( mem , cond ) <EOL> assert_shapes_equal ( mem , cond ) <EOL> self . handler . fill_if ( mem . array , val , cond . array ) <EOL> @ check_for_inf_or_nan <EOL> def get_numpy_copy ( self , mem ) : <EOL> assert_debug_arrays ( mem ) <EOL> return self . handler . get_numpy_copy ( mem . array ) <EOL> @ check_for_inf_or_nan <EOL> def set_from_numpy ( self , mem , arr ) : <EOL> assert_debug_arrays ( mem ) <EOL> assert isinstance ( arr , np . ndarray ) <EOL> assert mem . shape == arr . shape , \"<STR_LIT>\" . format ( mem . shape , arr . shape ) <EOL> self . handler . set_from_numpy ( mem . array , arr ) <EOL> def is_fully_finite ( self , a ) : <EOL> return self . handler . is_fully_finite ( a . array ) <EOL> @ check_for_inf_or_nan <EOL> def abs_t ( self , a , out ) : <EOL> assert_debug_arrays ( a , out ) <EOL> assert_shapes_equal ( a , out ) <EOL> self . handler . abs_t ( a . array , out . array ) <EOL> @ check_for_inf_or_nan <EOL> def add_into_if ( self , a , out , cond ) : <EOL> assert_debug_arrays ( a , out , cond ) <EOL> assert_shapes_equal ( a , out , cond ) <EOL> self . handler . add_into_if ( a . array , out . array , cond . array ) <EOL> @ check_for_inf_or_nan <EOL> def add_mv ( self , m , v , out ) : <EOL> assert_debug_arrays ( m , v , out ) <EOL> assert_shapes_equal ( m , out ) <EOL> assert len ( m . shape ) == <NUM_LIT:2> , \"<STR_LIT>\" . format ( m . shape ) <EOL> assert v . shape == ( m . shape [ <NUM_LIT:0> ] , <NUM_LIT:1> ) or v . shape == ( <NUM_LIT:1> , m . shape [ <NUM_LIT:1> ] ) , \"<STR_LIT>\" . format ( v . shape ) <EOL> self . handler . add_mv ( m . array , v . array , out . array ) <EOL> @ check_for_inf_or_nan <EOL> def add_st ( self , s , t , out ) : <EOL> assert_debug_arrays ( t , out ) <EOL> assert_is_scalar ( s ) <EOL> assert_shapes_equal ( t , out ) <EOL> self . handler . add_st ( s , t . array , out . array ) <EOL> @ check_for_inf_or_nan <EOL> def add_tt ( self , a , b , out ) : <EOL> assert_debug_arrays ( a , b , out ) <EOL> assert_shapes_equal ( a , b , out ) <EOL> self . handler . add_tt ( a . array , b . array , out . array ) <EOL> @ check_for_inf_or_nan <EOL> def avgpool2d_backward_batch ( self , inputs , window , outputs , padding , <EOL> stride , in_deltas , out_deltas ) : <EOL> assert_debug_arrays ( inputs , outputs , in_deltas , out_deltas ) <EOL> assert_is_shape ( window ) <EOL> assert len ( window ) == <NUM_LIT:2> , \"<STR_LIT>\" . format ( window ) <EOL> assert_is_shape ( stride ) <EOL> assert len ( stride ) == <NUM_LIT:2> , \"<STR_LIT>\" . format ( stride ) <EOL> assert isinstance ( padding , int ) and <NUM_LIT:0> <= padding , \"<STR_LIT>\" . format ( padding ) <EOL> assert_shapes_equal ( inputs , in_deltas ) <EOL> assert_shapes_equal ( outputs , out_deltas ) <EOL>", "gt": ""}
{"id": 45074, "input": "<s> from __future__ import absolute_import <EOL> import logging <EOL> from operator import itemgetter <EOL> from pyleus . storm import SimpleBolt <EOL> log = logging . getLogger ( '<STR_LIT>' ) <EOL> class TopGlobalBolt ( SimpleBolt ) : <EOL> OPTIONS = [ \"<STR_LIT:N>\" ] <EOL> OUTPUT_FIELDS = [ \"<STR_LIT>\" ] <EOL> def initialize ( self ) : <EOL> self . top_N = [ ] <EOL> self . N = self . options [ \"<STR_LIT:N>\" ] <EOL> def process_tick ( self ) : <EOL> log . debug ( \"<STR_LIT>\" ) <EOL> log . debug ( self . top_N ) <EOL> self . emit ( ( self . top_N , ) ) <EOL> self . top_N = [ ] <EOL> def process_tuple ( self , tup ) : <EOL> task_ranking , = tup . values <EOL> log . debug ( \"<STR_LIT>\" . format ( tup . task", "gt": ""}
{"id": 43810, "input": "<s> import inspect <EOL> import sys <EOL> import django . shortcuts <EOL> import django . views . defaults <EOL> def dispatcher ( request , test_name ) : <EOL> from horizon . test . jasmine import jasmine_tests as tests <EOL>", "gt": ""}
{"id": 42128, "input": "<s> import sys <EOL> import os <EOL> _ROOT = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) , \"<STR_LIT:src>\" ) <EOL> sys . path . insert ( <NUM_LIT:0> , _ROOT ) <EOL> execfile ( os", "gt": ""}
{"id": 6636, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os , sys <EOL> sys . path . append ( \"<STR_LIT>\" ) <EOL> from launch_experiment import * <EOL> curr_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> experiment_list = [ ] <EOL> supported_alg_ids = [ '<STR_LIT>' ] <EOL> alg_list = [ ] <EOL> for alg_id in supported_alg_ids : <EOL> alg_item = { } <EOL> alg_item [ '<STR_LIT>' ] = alg_id <EOL> alg_item [ '<STR_LIT>' ] = alg_id <EOL> alg_item [ '<STR_LIT>' ] = { } <EOL> alg_list . append ( alg_item ) <EOL> algorithm_management_settings = { } <EOL> params = { } <EOL> params [ '<STR_LIT>' ] = [ ] <EOL> for algorithm in alg_list : <EOL> params [ '<STR_LIT>' ] . append ( { '<STR_LIT>' : algorithm [ '<STR_LIT>' ] , '<STR_LIT>' : <NUM_LIT:1.> / len ( alg_list ) } ) <EOL> algorithm_management_settings [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> algorithm_management_settings [ '<STR_LIT>' ] = params <EOL> cap_list = [ '<STR_LIT>' ] <EOL> for cap in cap_list : <EOL> initExp = { } <EOL> initExp [ '<STR_LIT:args>' ] = { } <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT:n>' ] = <NUM_LIT> <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT:k>' ] = <NUM_LIT:8> <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT>' ] = <NUM_LIT> <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> initExp [ '<STR_LIT:args>' ] [ '<STR_LIT>' ] = algorithm_management_settings <EOL>", "gt": ""}
{"id": 32204, "input": "<s> from __future__ import absolute_import <EOL> from optparse import make_option <EOL> from django . core . management . base import BaseCommand <EOL> from zerver . lib . actions import delete_all_user_sessions , delete_realm_user_sessions <EOL> from zerver . models import get_realm <EOL> class Command ( BaseCommand ) : <EOL> help = \"<STR_LIT>\" <EOL> option_list = BaseCommand . option_list + ( <EOL> make_option ( '<STR_LIT>' , <EOL> dest = '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> default = None , <EOL> help = \"<STR_LIT>\" ) , <EOL> ) <EOL> def handle ( self , * args , ** options ) : <EOL> if", "gt": ""}
{"id": 48669, "input": "<s> from __future__ import absolute_import <EOL> from django . core . urlresolvers import reverse <EOL> from django . contrib import messages <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from sentry . models import Rule <EOL> from sentry . web . frontend . base import ProjectView <EOL> class ProjectRuleRemoveView ( ProjectView ) : <EOL> required_scope = '<STR_LIT>' <EOL> def post ( self , request , organization , team , project , rule_id ) : <EOL> path = reverse ( '<STR_LIT>' , args = [ organization . slug , project . slug ] ) <EOL> try : <EOL> rule = Rule . objects . get ( project = project , id =", "gt": ""}
{"id": 37912, "input": "<s> from __future__ import print_function , division , absolute_import <EOL> from . base_commandline_predictor import BaseCommandlinePredictor <EOL> from . file_formats import parse_netmhcpan_stdout <EOL> class NetMHCpan ( BaseCommandlinePredictor ) : <EOL> def __init__ ( <EOL> self , <EOL> alleles , <EOL> epitope_lengths = [ <NUM_LIT:9> ] , <EOL>", "gt": ""}
{"id": 23969, "input": "<s> __version__ = '<STR_LIT>' <EOL> from . error_handling import ErrorHandledApi <EOL>", "gt": ""}
{"id": 14986, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> import numpy <EOL> from threading import Thread <EOL> from time import sleep <EOL> from mayavi . scripts import mayavi2 <EOL> from traits . api import HasTraits , Button , Instance <EOL> from traitsui . api import View , Item <EOL> from mayavi . sources . array_source import ArraySource <EOL> from mayavi . modules . outline import Outline <EOL> from mayavi . modules . image_plane_widget import ImagePlaneWidget <EOL> from pyface . api import GUI <EOL> def make_data ( dims = ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> np = dims [ <NUM_LIT:0> ] * dims [ <NUM_LIT:1>", "gt": ""}
{"id": 40352, "input": "<s> from __future__ import print_function <EOL> import getpass <EOL> import inspect <EOL> import os <EOL> import sys <EOL> import textwrap <EOL> from oslo_utils import encodeutils <EOL> from oslo_utils import strutils <EOL> import prettytable <EOL> import six <EOL> from six import moves <EOL> from magnumclient . openstack . common . _i18n import _ <EOL> class MissingArgs ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , missing ) : <EOL> self . missing = missing <EOL> msg = _ ( \"<STR_LIT>\" ) % \"<STR_LIT:U+002CU+0020>\" . join ( missing ) <EOL> super ( MissingArgs , self ) . __init__ ( msg ) <EOL> def validate_args ( fn , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> argspec = inspect . getargspec ( fn ) <EOL> num_defaults = len ( argspec . defaults or [ ] ) <EOL> required_args = argspec . args [ : len ( argspec . args ) - num_defaults ] <EOL> def isbound ( method ) : <EOL> return getattr ( method , '<STR_LIT>' , None ) is not None <EOL> if isbound ( fn ) : <EOL> required_args . pop ( <NUM_LIT:0> ) <EOL> missing = [ arg for arg in required_args if arg not in kwargs ] <EOL> missing = missing [ len ( args ) : ] <EOL> if missing : <EOL> raise MissingArgs ( missing ) <EOL> def arg ( * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _decorator ( func ) : <EOL> add_arg ( func , * args , ** kwargs ) <EOL> return func <EOL> return _decorator <EOL> def env ( * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for arg in args : <EOL> value = os . environ . get ( arg ) <EOL> if value : <EOL> return value <EOL> return kwargs . get ( '<STR_LIT:default>' , '<STR_LIT>' ) <EOL> def add_arg ( func , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not hasattr ( func", "gt": ""}
{"id": 3020, "input": "<s> import win32gui <EOL> import win32con <EOL> import win32api <EOL> import time <EOL> import math <EOL> import os <EOL> import sys <EOL> import re <EOL> if sys . version_info . major == <NUM_LIT:2> : <EOL> from urllib import pathname2url as urllib_pathname2url <EOL> else : <EOL> from urllib . request import pathname2url as urllib_pathname2url <EOL> g_debug = False <EOL> g_windows = { } <EOL> g_registeredClasses = { } <EOL> def Debug ( msg ) : <EOL> if not g_debug : <EOL> return <EOL> msg = \"<STR_LIT>\" + str ( msg ) <EOL> print ( msg ) <EOL> with open ( GetRealPath ( \"<STR_LIT>\" ) , \"<STR_LIT:a>\" ) as file : <EOL> file . write ( msg + \"<STR_LIT:\\n>\" ) <EOL> def GetRealPath ( file = None , encodeURL = False ) : <EOL> if file is None : file = \"<STR_LIT>\" <EOL> if file . find ( \"<STR_LIT:/>\" ) != <NUM_LIT:0> and file . find ( \"<STR_LIT:\\\\>\" ) != <NUM_LIT:0> and not re . search ( r\"<STR_LIT>\" , file ) : <EOL> if hasattr ( sys , \"<STR_LIT>\" ) : path = os . path . dirname ( sys . executable ) <EOL> elif \"<STR_LIT>\" in globals ( ) : path = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL> else : path = os . getcwd ( ) <EOL> path = path + os . sep + file <EOL> path = re . sub ( r\"<STR_LIT>\" , re . escape ( os . sep ) , path ) <EOL> path = re . sub ( r\"<STR_LIT>\" , \"<STR_LIT>\" , path ) <EOL> if encodeURL : <EOL> return urllib_pathname2url ( path ) <EOL> else : <EOL> return path <EOL> return file <EOL> def CreateWindow ( title , className , width , height , xpos = None , ypos = None", "gt": ""}
{"id": 21059, "input": "<s> import markdown <EOL> from yaml import load <EOL> try : <EOL> from yaml import CLoader as Loader <EOL> except ImportError : <EOL> from yaml import Loader <EOL> def parse ( content , modified = None , content_type = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pos1 = content . index ( '<STR_LIT>' ) <EOL> pos2 = content . index ( '<STR_LIT>' , pos1 + <NUM_LIT:1> ) <EOL> header = content [ pos1 : pos2 ] . strip", "gt": ""}
{"id": 28299, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> __author__ = '<STR_LIT>' <EOL> __license__ = '<STR_LIT>' <EOL> __version__ = '<STR_LIT>' <EOL> __credits__ = \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import string <EOL> try : <EOL> if sys . version >= '<STR_LIT>' : <EOL> import textwrap <EOL> elif sys . version >= '<STR_LIT>' : <EOL> from optparse import textwrap <EOL> else : <EOL> from optik import textwrap <EOL> except ImportError : <EOL> sys . stderr . write ( \"<STR_LIT>\" ) <EOL> raise <EOL> try : <EOL> True , False <EOL> except NameError : <EOL> ( True , False ) = ( <NUM_LIT:1> , <NUM_LIT:0> ) <EOL> def len ( iterable ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( iterable , str ) : <EOL> return iterable . __len__ ( ) <EOL> try : <EOL> return len ( unicode ( iterable , '<STR_LIT>' ) ) <EOL> except : <EOL> return iterable . __len__ ( ) <EOL> class ArraySizeError ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , msg ) : <EOL> self . msg = msg <EOL> Exception . __init__ ( self , msg , '<STR_LIT>' ) <EOL> def __str__ ( self ) : <EOL> return self . msg <EOL> class Texttable : <EOL> BORDER = <NUM_LIT:1> <EOL> HEADER = <NUM_LIT:1> << <NUM_LIT:1> <EOL> HLINES = <NUM_LIT:1> << <NUM_LIT:2> <EOL> VLINES = <NUM_LIT:1> << <NUM_LIT:3> <EOL> def __init__ ( self , max_width = <NUM_LIT> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if max_width <= <NUM_LIT:0> : <EOL> max_width = False <EOL> self . _max_width = max_width <EOL> self . _precision = <NUM_LIT:3> <EOL> self . _deco = Texttable . VLINES | Texttable . HLINES | Texttable . BORDER | Texttable . HEADER <EOL> self . set_chars ( [ '<STR_LIT:->' , '<STR_LIT:|>' , '<STR_LIT:+>' , '<STR_LIT:=>' ] ) <EOL> self . reset ( ) <EOL> def reset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _hline_string = None <EOL> self . _row_size = None <EOL> self . _header = [ ] <EOL> self . _rows = [ ] <EOL> def set_chars ( self , array ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( array ) != <NUM_LIT:4> : <EOL> raise ArraySizeError , \"<STR_LIT>\" <EOL> array = [ x [ : <NUM_LIT:1> ] for x in [ str ( s ) for s in array ] ] <EOL> ( self . _char_horiz , self . _char_vert , <EOL> self . _char_corner , self . _char_header ) = array <EOL> def set_deco ( self , deco ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _deco = deco <EOL> def set_cols_align ( self , array ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _check_row_size ( array ) <EOL> self . _align = array <EOL> def set_cols_valign ( self , array ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _check_row_size ( array ) <EOL> self . _valign = array <EOL> def set_cols_dtype ( self , array ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _check_row_size ( array ) <EOL> self . _dtype = array <EOL> def set_cols_width ( self , array ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _check_row_size ( array ) <EOL> try : <EOL> array = map ( int , array ) <EOL> if reduce ( min , array ) <= <NUM_LIT:0> : <EOL> raise ValueError <EOL> except ValueError : <EOL> sys . stderr . write ( \"<STR_LIT>\" ) <EOL> raise <EOL> self . _width = array <EOL> def set_precision ( self , width ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not type ( width ) is int or width < <NUM_LIT:0> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> self . _precision = width <EOL> def header ( self , array ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _check_row_size ( array ) <EOL> self . _header = map ( str , array ) <EOL> def add_row ( self , array ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _check_row_size ( array ) <EOL> if not hasattr ( self , \"<STR_LIT>\" ) : <EOL> self . _dtype = [ \"<STR_LIT:a>\" ] * self . _row_size <EOL> cells = [ ] <EOL> for i , x in enumerate ( array ) : <EOL> cells . append ( self . _str ( i , x ) ) <EOL> self . _rows . append ( cells ) <EOL> def add_rows ( self , rows , header = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if header : <EOL> if hasattr ( rows , '<STR_LIT>' ) and hasattr ( rows , '<STR_LIT>' ) : <EOL> self . header ( rows . next ( ) ) <EOL> else : <EOL> self . header ( rows [ <NUM_LIT:0> ] ) <EOL> rows = rows [ <NUM_LIT:1> : ] <EOL> for row in rows : <EOL> self . add_row ( row ) <EOL> def draw ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . _header and not self . _rows : <EOL> return <EOL> self . _compute_cols_width ( ) <EOL> self . _check_align ( ) <EOL> out = \"<STR_LIT>\" <EOL> if self . _has_border ( ) : <EOL> out += self . _hline ( ) <EOL> if self . _header : <EOL> out += self . _draw_line ( self . _header , isheader = True ) <EOL> if self . _has_header ( ) : <EOL> out += self . _hline_header ( ) <EOL> length = <NUM_LIT:0> <EOL> for row in self . _rows : <EOL> length += <NUM_LIT:1> <EOL> out += self . _draw_line ( row ) <EOL> if self . _has_hlines ( ) and length < len ( self . _rows ) : <EOL> out += self . _hline ( ) <EOL> if self . _has_border ( ) : <EOL> out += self . _hline ( ) <EOL> return out [ : - <NUM_LIT:1> ] <EOL> def _str ( self , i , x ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> f = float ( x ) <EOL> except : <EOL> return str ( x ) <EOL> n = self . _precision <EOL> dtype = self . _dtype [ i ] <EOL> if dtype == '<STR_LIT:i>' : <EOL> return str ( int ( round ( f ) ) ) <EOL> elif dtype == '<STR_LIT:f>' : <EOL> return '<STR_LIT>' % ( n , f ) <EOL> elif dtype == '<STR_LIT:e>' : <EOL> return '<STR_LIT>' % ( n , f ) <EOL> elif dtype == '<STR_LIT:t>' : <EOL> return str ( x ) <EOL> else : <EOL> if f - round ( f ) == <NUM_LIT:0> : <EOL> if abs ( f ) > <NUM_LIT> : <EOL> return '<STR_LIT>' % ( n , f ) <EOL> else : <EOL> return str ( int ( round ( f ) ) ) <EOL> else : <EOL> if abs ( f ) > <NUM_LIT> : <EOL> return '<STR_LIT>' % ( n , f ) <EOL> else : <EOL> return '<STR_LIT>' % ( n , f ) <EOL> def _check_row_size ( self , array ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . _row_size : <EOL> self . _row_size = len ( array ) <EOL> elif self . _row_size != len ( array ) : <EOL> raise ArraySizeError , \"<STR_LIT>\" % self . _row_size <EOL> def _has_vlines ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _deco & Texttable . VLINES > <NUM_LIT:0> <EOL> def _has_hlines ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _deco & Texttable . HLINES > <NUM_LIT:0> <EOL> def _has_border ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _deco & Texttable . BORDER > <NUM_LIT:0> <EOL> def _has_header ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _deco & Texttable . HEADER > <NUM_LIT:0> <EOL> def _hline_header ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return", "gt": ""}
{"id": 2125, "input": "<s> import csv <EOL> from operator import add <EOL> from datetime import datetime <EOL> from StringIO import StringIO <EOL> from collections import namedtuple <EOL> from pyspark import SparkConf , SparkContext <EOL> DATE_FMT = \"<STR_LIT>\" <EOL> Order = namedtuple ( '<STR_LIT>' , ( '<STR_LIT:id>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:date>' ) ) <EOL> def parse ( row ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> row [ <NUM_LIT:0> ] = int", "gt": ""}
{"id": 39046, "input": "<s> from __future__ import unicode_literals <EOL> from lino . projects . std . settings import * <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> class Site ( Site ) : <EOL> verbose_name = \"<STR_LIT>\" <EOL> description = _ ( \"<STR_LIT>\" ) <EOL> version = \"<STR_LIT>\" <EOL> url = \"<STR_LIT>\" <EOL> author", "gt": ""}
{"id": 40673, "input": "<s> import numpy <EOL> from chainer import cuda <EOL> from chainer import function <EOL> from chainer . utils import type_check <EOL> class Sum ( function . Function ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , axis = None ) : <EOL> if axis is None : <EOL> self . axis = None <EOL> elif isinstance ( axis , int ) : <EOL> self . axis = ( axis , ) <EOL> elif isinstance ( axis , tuple ) and all ( isinstance ( a , int )", "gt": ""}
{"id": 33724, "input": "<s> from sharpy . product import CheddarProduct <EOL> product = CheddarProduct ( <EOL> username = CHEDDAR_USERNAME , <EOL> password = CHEDDAR_PASSWORD , <EOL> product_code = CHEDDAR_PRODUCT , <EOL> ) <EOL> customer = product . create_customer ( <EOL> code = '<STR_LIT>' , <EOL> first_name = '<STR_LIT>' , <EOL> last_name = '<STR_LIT>' , <EOL> email = '<STR_LIT>' , <EOL> plan_code = '<STR_LIT>' , <EOL> method = '<STR_LIT>' , <EOL> cc_first_name = '<STR_LIT>' , <EOL> cc_last_name = '<STR_LIT>' , <EOL> return_url = '<STR_LIT>' , <EOL>", "gt": ""}
{"id": 25811, "input": "<s> from warnings import warnpy3k <EOL> warnpy3k ( \"<STR_LIT>\" , stacklevel = <NUM_LIT:2> ) <EOL> del warnpy3k <EOL> _MIPS_ISA_MIPS1 = <NUM_LIT:1> <EOL> _MIPS_ISA_MIPS2 = <NUM_LIT:2> <EOL> _MIPS_ISA_MIPS3 = <NUM_LIT:3> <EOL> _MIPS_ISA_MIPS4 = <NUM_LIT:4> <EOL> _MIPS_SIM_ABI32 = <NUM_LIT:1> <EOL> _MIPS_SIM_NABI32 = <NUM_LIT:2> <EOL> _MIPS_SIM_ABI64 = <NUM_LIT:3> <EOL> P_MYID = ( - <NUM_LIT:1> ) <EOL> P_MYHOSTID = ( - <NUM_LIT:1> ) <EOL> ONBITSMAJOR = <NUM_LIT:7> <EOL> ONBITSMINOR = <NUM_LIT:8> <EOL> OMAXMAJ = <NUM_LIT> <EOL> OMAXMIN = <NUM_LIT> <EOL> NBITSMAJOR = <NUM_LIT> <EOL> NBITSMINOR = <NUM_LIT> <EOL> MAXMAJ = <NUM_LIT> <EOL> MAXMIN = <NUM_LIT> <EOL> OLDDEV = <NUM_LIT:0> <EOL> NEWDEV = <NUM_LIT:1> <EOL> MKDEV_VER = NEWDEV <EOL> def major ( dev ) : return __major ( MKDEV_VER , dev ) <EOL> def minor ( dev ) : return __minor ( MKDEV_VER , dev ) <EOL> FD_SETSIZE = <NUM_LIT> <EOL> NBBY = <NUM_LIT:8> <EOL> HP_NOPOLICY = <NUM_LIT:0> <EOL> HP_ADDOFF = <NUM_LIT:1> <EOL> HP_MULOFF = <NUM_LIT:2> <EOL> SEMA_NAMSZ = <NUM_LIT:8> <EOL> SEMA_NOHIST = <NUM_LIT> <EOL> SEMA_LIFO = <NUM_LIT> <EOL> SEMA_MUTEX = <NUM_LIT> <EOL> SEMA_METER = <NUM_LIT> <EOL> SEMAOP_PSEMA = <NUM_LIT:1> <EOL> SEMAOP_VSEMA = <NUM_LIT:2> <EOL> SEMAOP_CPSEMA = <NUM_LIT:3> <EOL> SEMAOP_CVSEMA = <NUM_LIT:4> <EOL> SEMAOP_WSEMA = <NUM_LIT:5> <EOL> SEMAOP_UNSEMA = <NUM_LIT:6> <EOL> SEMAOP_INIT = <NUM_LIT:7> <EOL> SEMAOP_FREE = <NUM_LIT:8> <EOL> SSOP_PHIT = <NUM_LIT:1> <EOL> SSOP_PSLP = <NUM_LIT:2> <EOL> SSOP_PWAKE = <NUM_LIT:6> <EOL> SSOP_PRESIG = <NUM_LIT:7> <EOL> SSOP_POSTSIG = <NUM_LIT:8> <EOL> SSOP_VNOWAKE = <NUM_LIT:3> <EOL> SSOP_VWAKE = <NUM_LIT:4> <EOL> SSOP_CPHIT = <NUM_LIT:1> <EOL> SSOP_CPMISS = <NUM_LIT:5> <EOL> SSOP_CVNOWAKE = <NUM_LIT:3> <EOL> SSOP_CVWAKE = <NUM_LIT:4> <EOL> SSOP_WMISS = <NUM_LIT:5> <EOL> SSOP_WWAKE = <NUM_LIT:4> <EOL> SSOP_RMV = <NUM_LIT:9> <EOL> TZERO = <NUM_LIT:10> <EOL> SEMA_NOP = <NUM_LIT:0> <EOL> SEMA_WAKE = <NUM_LIT:1> <EOL> SEMA_VSEMA = <NUM_LIT:2> <EOL> SEMA_SPINOP = <NUM_LIT:3> <EOL> MR_ACCESS = <NUM_LIT> <EOL> MR_UPDATE = <NUM_LIT> <EOL> def cv_signal ( cv ) : return cvsema ( cv ) ; <EOL> def cv_destroy ( cv ) : return freesema ( cv ) <EOL> def mutex_enter ( m ) : return psema ( m , PZERO | PNOSTOP ) <EOL> def mutex_exit ( m ) : return vsema ( m ) <EOL> def mutex_destroy ( m ) : return freesema ( m ) <EOL> def MUTEX_HELD ( m ) : return ( ownsema ( m ) ) <EOL> def MUTEX_HELD ( m ) : return ( <NUM_LIT:1> ) <EOL> RW_READER = MR_ACCESS <EOL> RW_WRITER = MR_UPDATE <EOL> def rw_exit ( r ) : return mrunlock ( r ) <EOL> def rw_tryupgrade ( r ) : return cmrpromote ( r ) <EOL> def rw_downgrade ( r ) : return mrdemote ( r ) <EOL> def rw_destroy ( r ) : return mrfree ( r ) <EOL> def RW_WRITE_HELD ( r ) : return ismrlocked ( r , MR_UPDATE ) <EOL> def RW_READ_HELD ( r ) : return ismrlocked ( r , MR_ACCESS ) <EOL> SPLOCKNAMSIZ = <NUM_LIT:8> <EOL> SPLOCK_NONE = <NUM_LIT:0> <EOL> SPLOCK_SOFT = <NUM_LIT:1> <EOL> SPLOCK_HARD = <NUM_LIT:2> <EOL> OWNER_NONE = - <NUM_LIT:1> <EOL> MAP_LOCKID = <NUM_LIT:0> <EOL> SPLOCK_MAX = ( <NUM_LIT> * <NUM_LIT> ) <EOL> SPLOCK_MAX = <NUM_LIT> <EOL> MIN_POOL_SIZE = <NUM_LIT> <EOL> MAX_POOL_SIZE = <NUM_LIT> <EOL> DEF_SEMA_POOL = <NUM_LIT> <EOL> DEF_VNODE_POOL = <NUM_LIT> <EOL> DEF_FILE_POOL = <NUM_LIT> <EOL> def ownlock ( x ) : return <NUM_LIT:1> <EOL> def splock ( x ) : return <NUM_LIT:1> <EOL> def io_splock ( x ) : return <NUM_LIT:1> <EOL> def apvsema ( x ) : return vsema ( x ) <EOL> def apcpsema ( x ) : return cpsema ( x ) <EOL> def apcvsema ( x ) : return cvsema ( x ) <EOL> def mp_mrunlock ( a ) : return mrunlock ( a ) <EOL> def apvsema ( x ) : return <NUM_LIT:0> <EOL> def apcpsema ( x ) : return <NUM_LIT:1> <EOL> def apcvsema ( x ) : return <NUM_LIT:0> <EOL> def mp_mrunlock ( a ) : return <NUM_LIT:0> <EOL> FNDELAY = <NUM_LIT> <EOL> FAPPEND = <NUM_LIT> <EOL> FSYNC = <NUM_LIT> <EOL> FNONBLOCK = <NUM_LIT> <EOL> FASYNC = <NUM_LIT> <EOL> FNONBLK = FNONBLOCK <EOL> FDIRECT = <NUM_LIT> <EOL> FCREAT = <NUM_LIT> <EOL> FTRUNC = <NUM_LIT> <EOL> FEXCL = <NUM_LIT> <EOL> FNOCTTY = <NUM_LIT> <EOL> O_RDONLY = <NUM_LIT:0> <EOL> O_WRONLY = <NUM_LIT:1> <EOL> O_RDWR = <NUM_LIT:2> <EOL> O_NDELAY = <NUM_LIT> <EOL> O_APPEND = <NUM_LIT> <EOL> O_SYNC = <NUM_LIT> <EOL> O_NONBLOCK = <NUM_LIT> <EOL> O_DIRECT = <NUM_LIT> <EOL> O_CREAT = <NUM_LIT> <EOL> O_TRUNC = <NUM_LIT> <EOL> O_EXCL = <NUM_LIT> <EOL> O_NOCTTY = <NUM_LIT> <EOL> F_DUPFD = <NUM_LIT:0> <EOL> F_GETFD = <NUM_LIT:1> <EOL> F_SETFD = <NUM_LIT:2> <EOL> F_GETFL = <NUM_LIT:3> <EOL> F_SETFL = <NUM_LIT:4> <EOL> F_GETLK = <NUM_LIT> <EOL> F_SETLK = <NUM_LIT:6> <EOL> F_SETLKW = <NUM_LIT:7> <EOL> F_CHKFL = <NUM_LIT:8> <EOL> F_ALLOCSP = <NUM_LIT:10> <EOL> F_FREESP = <NUM_LIT:11> <EOL> F_SETBSDLK = <NUM_LIT:12> <EOL> F_SETBSDLKW = <NUM_LIT> <EOL> F_DIOINFO = <NUM_LIT:30> <EOL> F_FSGETXATTR = <NUM_LIT> <EOL> F_FSSETXATTR = <NUM_LIT:32> <EOL> F_GETLK64 = <NUM_LIT> <EOL> F_SETLK64 = <NUM_LIT> <EOL> F_SETLKW64 = <NUM_LIT> <EOL> F_ALLOCSP64", "gt": ""}
{"id": 30856, "input": "<s> from robot . utils import setter <EOL> from . itemlist import ItemList <EOL> from . keyword import Keyword , Keywords <EOL> from . modelobject import ModelObject <EOL> from . tags import Tags <EOL> class TestCase ( ModelObject ) : <EOL> __slots__ = [ '<STR_LIT>' , '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> keyword_class = Keyword <EOL> def __init__ ( self , name = '<STR_LIT>' , doc = '<STR_LIT>' , tags = None , timeout = '<STR_LIT>'", "gt": ""}
{"id": 20838, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import time <EOL> import numpy as np <EOL> from scipy . spatial import cKDTree <EOL> from vispy import gloo <EOL> from vispy import app <EOL> VERT_SHADER = \"\"\"<STR_LIT>\"\"\" <EOL> FRAG_SHADER = \"\"\"<STR_LIT>\"\"\" <EOL> class Canvas ( app . Canvas ) : <EOL> def __init__ ( self ) : <EOL> app . Canvas . __init__ ( self , keys = '<STR_LIT>' ) <EOL> ps = self . pixel_scale <EOL> n = <NUM_LIT:1000> <EOL> self . particles = np . zeros ( <NUM_LIT:2> + n , [ ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:3> ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:3> ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:3> ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:3> ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:4> ) , <EOL> ( '<STR_LIT:size>' , '<STR_LIT>' , <NUM_LIT:1> * ps ) ] ) <EOL> self . boids = self . particles [ <NUM_LIT:2> : ] <EOL> self . target = self . particles [ <NUM_LIT:0> ] <EOL> self . predator = self . particles [ <NUM_LIT:1> ] <EOL> self . boids [ '<STR_LIT>' ] = np . random . uniform ( - <NUM_LIT> , + <NUM_LIT> , ( n , <NUM_LIT:3> ) ) <EOL> self . boids [ '<STR_LIT>' ] = np . random . uniform ( - <NUM_LIT> , + <NUM_LIT> , ( n , <NUM_LIT:3> ) ) <EOL> self . boids [ '<STR_LIT:size>' ] = <NUM_LIT:4> * ps <EOL> self . boids [ '<STR_LIT>' ] = <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> <EOL> self . target [ '<STR_LIT:size>' ] = <NUM_LIT:16> * ps <EOL> self . target [ '<STR_LIT>' ] [ : ] = <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> <EOL> self . predator [ '<STR_LIT:size>' ] = <NUM_LIT:16> * ps <EOL> self . predator [ '<STR_LIT>' ] [ : ] = <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> <EOL> self . target [ '<STR_LIT>' ] [ : ] = <NUM_LIT> , <NUM_LIT:0.0> , <NUM_LIT:0> <EOL> self . _t = time . time ( ) <EOL> self . _pos = <NUM_LIT:0.0> , <NUM_LIT:0.0> <EOL> self . _button = None <EOL> width , height = self . physical_size <EOL> gloo . set_viewport ( <NUM_LIT:0> , <NUM_LIT:0> , width , height ) <EOL> self . program = gloo . Program ( VERT_SHADER , FRAG_SHADER ) <EOL> self . vbo_position = gloo . VertexBuffer ( self . particles [ '<STR_LIT>' ] <EOL> . copy ( ) ) <EOL> self . vbo_color = gloo . VertexBuffer ( self . particles [ '<STR_LIT>' ] . copy ( ) ) <EOL> self . vbo_size = gloo . VertexBuffer ( self . particles [ '<STR_LIT:size>' ] . copy ( ) ) <EOL> self . program [ '<STR_LIT>' ] = self . vbo_color <EOL> self . program [ '<STR_LIT:size>' ] = self . vbo_size <EOL> self . program [ '<STR_LIT>' ] = self . vbo_position <EOL> gloo . set_state ( clear_color = ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ) , blend = True , <EOL> blend_func = ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> self . _timer = app . Timer ( '<STR_LIT>' , connect = self . update , start = True ) <EOL> self . show ( ) <EOL> def on_resize ( self , event ) : <EOL> width , height = event . physical_size <EOL> gloo . set_viewport ( <NUM_LIT:0> , <NUM_LIT:0> , width , height ) <EOL> def on_mouse_press ( self , event ) : <EOL> self . _button = event . button <EOL> self . on_mouse_move ( event ) <EOL> def on_mouse_release ( self , event ) : <EOL> self . _button = None <EOL> self . on_mouse_move ( event ) <EOL> def on_mouse_move ( self , event ) : <EOL> if not self . _button : <EOL> return <EOL> w , h = self . size <EOL> x , y = event . pos <EOL> sx = <NUM_LIT:2> * x / float ( w ) - <NUM_LIT:1.0> <EOL> sy = - ( <NUM_LIT:2> * y / float (", "gt": ""}
{"id": 13300, "input": "<s> __credits__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] <EOL> from unittest import TestCase , main <EOL> from pyqi . core . interfaces . optparse . input_handler import command_handler <EOL> from pyqi . commands . make_optparse import MakeOptparse <EOL> class OptparseInputHandlerTests ( TestCase ) : <EOL> def setUp ( self ) : <EOL> pass <EOL> def test_command_handler ( self ) : <EOL> exp = MakeOptparse ( ) <EOL> obs = command_handler ( '<STR_LIT>' ) <EOL>", "gt": ""}
{"id": 4562, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from google . apputils import app <EOL> import logging <EOL> from google . apputils import basetest as googletest <EOL> import paillier <EOL> _KEY1 = '<STR_LIT>' <EOL> _PAILLIER1 = paillier . Paillier ( _KEY1 ) <EOL> class PaillierTest ( googletest . TestCase ) : <EOL> def testInitRegression ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> self . assertEquals ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , str ( _PAILLIER1 . n ) ) <EOL> self . assertEquals ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , str ( _PAILLIER1 . nsquare ) ) <EOL> self . assertEquals ( _PAILLIER1 . n + <NUM_LIT:1> , _PAILLIER1 . g ) <EOL> def testModExp ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> self . assertTrue ( paillier . _FOUND_SSL ) <EOL> a = <NUM_LIT:255> <EOL> b = <NUM_LIT> <EOL> c = <NUM_LIT> <EOL> expect = <NUM_LIT> <EOL> m1 = paillier . ModExp ( a , b , c ) <EOL> m2 = pow ( a , b , c ) <EOL> self . assertEqual ( m1 , expect ) <EOL> self . assertEqual ( m2 , expect ) <EOL> def testEncryptDecrypt ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> data = <NUM_LIT> <EOL> ciphertext = _PAILLIER1 . Encrypt ( data ) <EOL> decryption = _PAILLIER1 . Decrypt ( ciphertext ) <EOL> self . assertEquals ( data , decryption ) <EOL> def testAdd ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> plaintext1 = <NUM_LIT> <EOL> ciphertext1 = _PAILLIER1 . Encrypt ( plaintext1 ) <EOL> plaintext2 = <NUM_LIT> <EOL> ciphertext2 = _PAILLIER1 . Encrypt ( plaintext2 ) <EOL> ciphertext3 = _PAILLIER1 . Add ( ciphertext1 , ciphertext2 ) <EOL> decryption = _PAILLIER1 . Decrypt ( ciphertext3 ) <EOL> self . assertEquals ( plaintext1 + plaintext2 , decryption ) <EOL> def testAddWraparound ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> plaintext1 = _PAILLIER1 . n - <NUM_LIT:1> <EOL> ciphertext1 = _PAILLIER1 . Encrypt ( plaintext1 ) <EOL> self . assertEquals ( plaintext1 , _PAILLIER1 . Decrypt ( ciphertext1 ) ) <EOL> plaintext2 = _PAILLIER1 . n <EOL> ciphertext2 = _PAILLIER1 . Encrypt ( plaintext2 ) <EOL> self . assertEquals ( <NUM_LIT:0> , _PAILLIER1 . Decrypt ( ciphertext2 ) ) <EOL> plaintext3 = _PAILLIER1 . n + <NUM_LIT:1> <EOL> ciphertext3 = _PAILLIER1 . Encrypt ( plaintext3 ) <EOL> self . assertEquals ( <NUM_LIT:1> , _PAILLIER1 . Decrypt ( ciphertext3 ) ) <EOL> def testAffine ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> plaintext1 = <NUM_LIT> <EOL> ciphertext1 = _PAILLIER1 . Encrypt ( plaintext1 ) <EOL> a = <NUM_LIT:2> <EOL> b = <NUM_LIT> <EOL> ciphertext3 = _PAILLIER1 . Affine ( ciphertext1 , a , b ) <EOL> decryption3 = _PAILLIER1 . Decrypt ( ciphertext3 ) <EOL> self . assertEquals ( a * plaintext1 + b , decryption3 ) <EOL> ciphertext4 = _PAILLIER1 . Affine ( ciphertext1 , <NUM_LIT:0> , b ) <EOL> decryption4 = _PAILLIER1 . Decrypt ( ciphertext4 ) <EOL> self . assertEquals ( b , decryption4 ) <EOL> ciphertext5 = _PAILLIER1 . Affine ( ciphertext1 , <NUM_LIT:1> , b ) <EOL> decryption5 = _PAILLIER1 . Decrypt ( ciphertext5 ) <EOL> self . assertEquals ( plaintext1 + b , decryption5 ) <EOL> ciphertext6 = _PAILLIER1 . Affine ( ciphertext1 , <NUM_LIT:2> , <NUM_LIT:0> ) <EOL> decryption6 = _PAILLIER1 . Decrypt ( ciphertext6 ) <EOL> self . assertEquals ( <NUM_LIT:2> * plaintext1 , decryption6 ) <EOL> ciphertext7 = _PAILLIER1 . Affine ( ciphertext1 , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> decryption7 = _PAILLIER1 . Decrypt ( ciphertext7 ) <EOL> self . assertEquals ( <NUM_LIT:0> , decryption7 ) <EOL> def testEncryptDecryptRegression ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> paillier1 = paillier . Paillier ( None , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> ciphertext = paillier1 . Encrypt ( <NUM_LIT> , <NUM_LIT> ) <EOL> self . assertEquals ( <NUM_LIT> , ciphertext ) <EOL> decryption = paillier1 . Decrypt ( <NUM_LIT> ) <EOL> self . assertEquals ( <NUM_LIT> , decryption ) <EOL> def testGetRandomFromZNStar ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> not_relatively_prime_to_143 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> for _ in xrange ( <NUM_LIT:20> ) : <EOL> r = _PAILLIER1 . _GetRandomFromZNStar ( <NUM_LIT:8> , <NUM_LIT> ) <EOL> self . assertFalse ( r in not_relatively_prime_to_143 ) <EOL> def testEncryptInt64DecryptInt64 ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> ciphertext = _PAILLIER1 . EncryptInt64 ( <NUM_LIT:15> ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> self . assertEquals ( <NUM_LIT:15> , decryption ) <EOL> ciphertext = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:15> ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> self . assertEquals ( - <NUM_LIT:15> , decryption ) <EOL> ciphertext = _PAILLIER1 . EncryptInt64 ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> self . assertEquals ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> , decryption ) <EOL> ciphertext = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:2> ** <NUM_LIT> ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> self . assertEquals ( - <NUM_LIT:2> ** <NUM_LIT> , decryption ) <EOL> def testAddWithEncryptDecryptInt64 ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> ciphertext1 = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:15> ) <EOL> ciphertext2 = _PAILLIER1 . EncryptInt64 ( <NUM_LIT:1> ) <EOL> ciphertext3 = _PAILLIER1 . Add ( ciphertext1 , ciphertext2 ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext3 ) <EOL> self . assertEquals ( - <NUM_LIT> , decryption ) <EOL> ciphertext1 = _PAILLIER1 . EncryptInt64 ( <NUM_LIT:15> ) <EOL> ciphertext2 = _PAILLIER1 . EncryptInt64 ( <NUM_LIT:1> ) <EOL> ciphertext3 = _PAILLIER1 . Add ( ciphertext1 , ciphertext2 ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext3 ) <EOL> self . assertEquals ( <NUM_LIT:16> , decryption ) <EOL> ciphertext1 = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:15> ) <EOL> ciphertext2 = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:1> ) <EOL> ciphertext3 = _PAILLIER1 . Add ( ciphertext1 , ciphertext2 ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext3 ) <EOL> self . assertEquals ( - <NUM_LIT:16> , decryption ) <EOL> def testMultipleAddWithEncryptDecryptInt64 ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> c123456789 = _PAILLIER1 . EncryptInt64 ( <NUM_LIT> L ) <EOL> c314159265359 = _PAILLIER1 . EncryptInt64 ( <NUM_LIT> L ) <EOL> c271828182846 = _PAILLIER1 . EncryptInt64 ( <NUM_LIT> L ) <EOL> c987654321neg = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT> L ) <EOL> c161803398874neg = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT> L ) <EOL> c1414213562373095neg = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT> L ) <EOL> ciphertext = _PAILLIER1 . Add ( c123456789 , c314159265359 ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext , c271828182846 ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> self . assertEquals ( <NUM_LIT> + <NUM_LIT> + <NUM_LIT> , decryption ) <EOL> ciphertext = _PAILLIER1 . Add ( c987654321neg , c161803398874neg ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext , c1414213562373095neg ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> self . assertEquals ( - <NUM_LIT> + - <NUM_LIT> + - <NUM_LIT> , <EOL> decryption ) <EOL> ciphertext = _PAILLIER1 . Add ( c123456789 , c314159265359 ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext , c271828182846 ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext , c987654321neg ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext , c161803398874neg ) <EOL> ciphertext_3pos_2neg = ciphertext <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> sum_3pos_2neg = ( <NUM_LIT> + <NUM_LIT> + <NUM_LIT> + - <NUM_LIT> + <EOL> - <NUM_LIT> ) <EOL> self . assertEquals ( sum_3pos_2neg , decryption ) <EOL> ciphertext = _PAILLIER1 . Add ( c123456789 , c314159265359 ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext , c271828182846 ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext , c987654321neg ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext , c161803398874neg ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext , c1414213562373095neg ) <EOL> ciphertext_3pos_3neg = ciphertext <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> sum_3pos_3neg = ( <NUM_LIT> + <NUM_LIT> + <NUM_LIT> + - <NUM_LIT> + <EOL> - <NUM_LIT> + - <NUM_LIT> ) <EOL> self . assertEquals ( sum_3pos_3neg , decryption ) <EOL> ciphertext = _PAILLIER1 . EncryptInt64 ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> - sum_3pos_2neg ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext_3pos_2neg , ciphertext ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> self . assertEquals ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> , decryption ) <EOL> ciphertext = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:2> ** <NUM_LIT> + <NUM_LIT:1> - sum_3pos_3neg ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext_3pos_3neg , ciphertext ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> self . assertEquals ( - <NUM_LIT:2> ** <NUM_LIT> + <NUM_LIT:1> , decryption ) <EOL> ciphertext = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:2> ** <NUM_LIT> - sum_3pos_3neg ) <EOL> ciphertext = _PAILLIER1 . Add ( ciphertext_3pos_3neg , ciphertext ) <EOL> decryption = _PAILLIER1 . DecryptInt64 ( ciphertext ) <EOL> self . assertEquals ( - <NUM_LIT:2> ** <NUM_LIT> , decryption ) <EOL> def testEncryptInt64Fail ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> try : <EOL> _PAILLIER1 . EncryptInt64 ( <NUM_LIT:2> ** <NUM_LIT> ) <EOL> self . fail ( ) <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> _PAILLIER1 . EncryptInt64 ( <NUM_LIT:2> ** <NUM_LIT> ) <EOL> self . fail ( ) <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> ) <EOL> self . fail ( ) <EOL> except ValueError : <EOL> pass <EOL> try : <EOL> _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:2> ** <NUM_LIT> ) <EOL> self . fail ( ) <EOL> except ValueError : <EOL> pass <EOL> ciphertext1 = _PAILLIER1 . EncryptInt64 ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> ) <EOL> ciphertext2 = _PAILLIER1 . EncryptInt64 ( <NUM_LIT:1> ) <EOL> ciphertext3 = _PAILLIER1 . Add ( ciphertext1 , ciphertext2 ) <EOL> try : <EOL> _PAILLIER1 . DecryptInt64 ( ciphertext3 ) <EOL> self . fail ( ) <EOL> except OverflowError : <EOL> pass <EOL> ciphertext1 = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:2> ** <NUM_LIT> ) <EOL> ciphertext2 = _PAILLIER1 . EncryptInt64 ( - <NUM_LIT:1> ) <EOL> ciphertext3 = _PAILLIER1 . Add ( ciphertext1 , ciphertext2 ) <EOL> try : <EOL> _PAILLIER1 . DecryptInt64 ( ciphertext3 ) <EOL> self . fail ( ) <EOL> except OverflowError : <EOL> pass <EOL> def testFloatBasicMethods ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> self . assertTrue ( paillier . IsNan ( float ( '<STR_LIT>' ) ) ) <EOL> for f in ( <NUM_LIT> , <NUM_LIT> ) : <EOL> self . assertTrue ( paillier . IsInfPlus ( f ) ) <EOL> self . assertFalse ( paillier . IsInfMinus ( f ) ) <EOL> self . assertFalse ( paillier . IsNan ( f ) ) <EOL> for f in ( - <NUM_LIT> , - <NUM_LIT> ) : <EOL> self . assertTrue ( paillier . IsInfMinus ( f ) ) <EOL> self . assertFalse ( paillier . IsInfPlus ( f ) ) <EOL> self . assertFalse ( paillier . IsNan ( f ) ) <EOL> def testEncryptDecryptFloatInfAndNan ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> nan_value = float ( '<STR_LIT>' ) <EOL> c_nan = _PAILLIER1 . EncryptFloat ( nan_value ) <EOL> self . assertTrue ( paillier . IsNan ( _PAILLIER1 . DecryptFloat ( c_nan ) ) ) <EOL> c_2nan = _PAILLIER1 . Add ( c_nan , c_nan ) <EOL> self . assertTrue ( paillier . IsNan ( _PAILLIER1 . DecryptFloat ( c_2nan ) ) ) <EOL> c_plus_inf = _PAILLIER1 . EncryptFloat ( <NUM_LIT> ) <EOL> self . assertTrue ( paillier . IsInfPlus ( _PAILLIER1 . DecryptFloat ( c_plus_inf ) ) ) <EOL> c_2plus_inf = _PAILLIER1 . Add ( c_plus_inf , c_plus_inf ) <EOL> self . assertTrue ( paillier . IsInfPlus ( _PAILLIER1 . DecryptFloat ( c_2plus_inf ) ) ) <EOL> c_minus_inf = _PAILLIER1 . EncryptFloat ( - <NUM_LIT> ) <EOL> self . assertTrue ( paillier . IsInfMinus ( _PAILLIER1 . DecryptFloat ( c_minus_inf ) ) ) <EOL> c_2minus_inf = _PAILLIER1 . Add ( c_minus_inf , c_minus_inf ) <EOL> self . assertTrue ( paillier . IsInfMinus ( _PAILLIER1 . DecryptFloat ( c_2minus_inf ) ) ) <EOL> c_sum_plus_minus_inf = _PAILLIER1 . Add ( c_plus_inf , c_minus_inf ) <EOL> self . assertTrue ( <EOL> paillier . IsNan ( _PAILLIER1 . DecryptFloat ( c_sum_plus_minus_inf ) ) ) <EOL> c_sum_inf_nan = _PAILLIER1 . Add ( c_plus_inf , c_nan ) <EOL> self . assertTrue ( paillier . IsNan ( _PAILLIER1 . DecryptFloat ( c_sum_inf_nan ) ) ) <EOL> c_1_0 = _PAILLIER1 . EncryptFloat ( <NUM_LIT:1.0> ) <EOL> c_1_0neg = _PAILLIER1 . EncryptFloat ( - <NUM_LIT:1.0> ) <EOL> c_sum_fin_nan = _PAILLIER1 . Add ( c_1_0 , c_nan ) <EOL> self . assertTrue ( paillier . IsNan ( _PAILLIER1 . DecryptFloat ( c_sum_fin_nan ) ) ) <EOL> c_sum_fin_nan = _PAILLIER1 . Add ( c_1_0neg , c_nan ) <EOL> self . assertTrue ( paillier . IsNan ( _PAILLIER1 . DecryptFloat ( c_sum_fin_nan ) ) ) <EOL> c_sum_plus_inf = _PAILLIER1 . Add ( c_1_0 , c_plus_inf ) <EOL> self . assertTrue ( <EOL> paillier . IsInfPlus ( _PAILLIER1 . DecryptFloat ( c_sum_plus_inf ) ) ) <EOL> c_sum_plus_inf = _PAILLIER1 . Add ( c_1_0neg , c_plus_inf ) <EOL> self . assertTrue ( <EOL> paillier . IsInfPlus ( _PAILLIER1 . DecryptFloat ( c_sum_plus_inf ) ) ) <EOL> c_sum_minus_inf = _PAILLIER1 . Add ( c_1_0 , c_minus_inf ) <EOL> self . assertTrue ( <EOL> paillier . IsInfMinus ( _PAILLIER1 . DecryptFloat ( c_sum_minus_inf ) ) ) <EOL> c_sum_minus_inf = _PAILLIER1 . Add ( c_1_0neg , c_minus_inf ) <EOL> self . assertTrue ( <EOL> paillier . IsInfMinus ( _PAILLIER1 . DecryptFloat ( c_sum_minus_inf ) ) ) <EOL> def testEncryptDecryptFloatSmallNormalNumbers ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> c_1_0 = _PAILLIER1 . EncryptFloat ( <NUM_LIT:1.0> ) <EOL> self . assertEquals ( <NUM_LIT:1.0> , _PAILLIER1 . DecryptFloat ( c_1_0 ) ) <EOL> c_15_1234 = _PAILLIER1 . EncryptFloat ( <NUM_LIT> ) <EOL> self . assertEquals ( <NUM_LIT> , _PAILLIER1 . DecryptFloat ( c_15_1234 ) ) <EOL> c_1_0neg = _PAILLIER1 . EncryptFloat ( - <NUM_LIT:1.0> ) <EOL> self . assertEquals ( - <NUM_LIT:1.0> , _PAILLIER1 . DecryptFloat ( c_1_0neg ) ) <EOL> c_15_1234neg = _PAILLIER1 . EncryptFloat ( - <NUM_LIT> ) <EOL> self . assertEquals ( - <NUM_LIT> , _PAILLIER1 . DecryptFloat ( c_15_1234neg ) ) <EOL> data = <NUM_LIT> <EOL> c_smallest_gt_1 = _PAILLIER1 . EncryptFloat ( data ) <EOL> self . assertEquals ( data , <EOL> _PAILLIER1 . DecryptFloat ( c_smallest_gt_1 ) ) <EOL> self . assertNotEquals ( <NUM_LIT:1.0> , _PAILLIER1 . DecryptFloat ( c_smallest_gt_1 ) ) <EOL> data = <NUM_LIT> <EOL> self . assertEquals ( <EOL> <NUM_LIT:1.0> , _PAILLIER1 . DecryptFloat ( _PAILLIER1 . EncryptFloat ( data ) ) ) <EOL> data = - <NUM_LIT> <EOL> c_smallest_lt_1neg = _PAILLIER1 . EncryptFloat ( data ) <EOL> self . assertEquals ( data , <EOL> _PAILLIER1 . DecryptFloat ( c_smallest_lt_1neg ) ) <EOL> self . assertNotEquals ( - <NUM_LIT:1.0> , _PAILLIER1 . DecryptFloat ( c_smallest_lt_1neg ) ) <EOL> self . assertEquals ( - <NUM_LIT:1.0> , <EOL> _PAILLIER1 . DecryptFloat ( _PAILLIER1 . EncryptFloat ( <EOL> - <NUM_LIT> ) ) ) <EOL> c_onethird = _PAILLIER1 . EncryptFloat ( <NUM_LIT:1.0> / <NUM_LIT> ) <EOL> self . assertEquals ( <NUM_LIT:1.0> / <NUM_LIT> , _PAILLIER1 . DecryptFloat ( c_onethird ) ) <EOL> c_onethird = _PAILLIER1 . EncryptFloat ( - <NUM_LIT:1.0> / <NUM_LIT> ) <EOL> self . assertEquals ( - <NUM_LIT:1.0> / <NUM_LIT> , _PAILLIER1 . DecryptFloat ( c_onethird ) ) <EOL> smallest_normal = <NUM_LIT:2> ** - <NUM_LIT> <EOL> self . assertEquals ( smallest_normal , _PAILLIER1 . DecryptFloat ( <EOL> _PAILLIER1 . EncryptFloat ( smallest_normal ) ) ) <EOL> near_smallest_normal = <NUM_LIT> * <NUM_LIT:2> ** - <NUM_LIT> <EOL> self . assertEquals ( near_smallest_normal , _PAILLIER1 . DecryptFloat ( <EOL> _PAILLIER1 . EncryptFloat ( near_smallest_normal ) ) ) <EOL> smallest_normal = - <NUM_LIT:2> ** - <NUM_LIT> <EOL> self . assertEquals ( smallest_normal , _PAILLIER1 . DecryptFloat ( <EOL> _PAILLIER1 . EncryptFloat ( smallest_normal ) ) ) <EOL> near_smallest_normal = - <NUM_LIT> * <NUM_LIT:2> ** - <NUM_LIT> <EOL> self . assertEquals ( near_smallest_normal , _PAILLIER1 . DecryptFloat ( <EOL> _PAILLIER1 . EncryptFloat ( near_smallest_normal ) ) ) <EOL> def testEncryptDecryptFloatSubNormalNumbers ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> smallest_subnormal = <NUM_LIT:2> ** - <NUM_LIT> <EOL> c_smallest_subnormal = _PAILLIER1 . EncryptFloat ( smallest_subnormal ) <EOL> self . assertEquals ( smallest_subnormal , <EOL> _PAILLIER1 . DecryptFloat ( c_smallest_subnormal ) ) <EOL> self . assertEquals ( <NUM_LIT:0.0> , _PAILLIER1 . DecryptFloat ( _PAILLIER1 . EncryptFloat ( <EOL> <NUM_LIT:2> ** - <NUM_LIT> ) ) ) <EOL> smallest_subnormal = - <NUM_LIT:2> ** - <NUM_LIT> <EOL> c_smallest_subnormal = _PAILLIER1 . EncryptFloat ( smallest_subnormal ) <EOL> self . assertEquals ( smallest_subnormal , <EOL> _PAILLIER1 . DecryptFloat ( c_smallest_subnormal ) ) <EOL> self . assertEquals ( <NUM_LIT:0.0> , _PAILLIER1 . DecryptFloat ( _PAILLIER1 . EncryptFloat ( <EOL> - <NUM_LIT:2> ** - <NUM_LIT> ) ) ) <EOL> def testEncryptDecryptFloatLargeFiniteNumbers ( self ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> large1 = <NUM_LIT> * <NUM_LIT:2> ** <NUM_LIT> <EOL> large2 = <NUM_LIT> * <NUM_LIT:2> ** <NUM_LIT:100> <EOL> c_large1 = _PAILLIER1 . EncryptFloat ( large1 ) <EOL> self . assertEquals ( large1 , _PAILLIER1 . DecryptFloat ( c_large1 ) ) <EOL> c_large2 = _PAILLIER1 . EncryptFloat ( large2 ) <EOL> self . assertEquals ( large2 , _PAILLIER1 . DecryptFloat ( c_large2 ) ) <EOL>", "gt": ""}
{"id": 49881, "input": "<s> import logging <EOL> from cactus . listener . polling import PollingListener <EOL> logger = logging . getLogger ( __name__ ) <EOL> try : <EOL> from", "gt": ""}
{"id": 42833, "input": "<s> import os <EOL> import sys <EOL> import cStringIO <EOL> import gluon . contrib . shell <EOL> import gluon . dal <EOL> import gluon . html <EOL> import gluon . validators <EOL> import code <EOL> import thread <EOL> from gluon . debug import communicate , web_debugger , qdb_debugger <EOL> import pydoc <EOL> if DEMO_MODE or MULTI_USER_MODE : <EOL> session . flash = T ( '<STR_LIT>' ) <EOL> redirect ( URL ( '<STR_LIT:default>' , '<STR_LIT>' ) ) <EOL> FE = <NUM_LIT:10> ** <NUM_LIT:9> <EOL> def index ( ) : <EOL> app = request . args ( <NUM_LIT:0> ) or '<STR_LIT>' <EOL> reset ( ) <EOL> data = communicate ( ) <EOL> return dict ( app = app , data = data ) <EOL> def callback ( ) : <EOL> app = request . args [ <NUM_LIT:0> ] <EOL> command = request . vars . statement <EOL> session [ '<STR_LIT>' + app ] . append ( command ) <EOL> output = communicate ( command ) <EOL> k = len ( session [ '<STR_LIT>' + app ] ) - <NUM_LIT:1> <EOL> return '<STR_LIT>' % ( k + <NUM_LIT:1> , command , output ) <EOL> def reset ( ) : <EOL> app = request . args ( <NUM_LIT:0> ) or '<STR_LIT>' <EOL> session [ '<STR_LIT>' + app ] = [ ] <EOL> return '<STR_LIT>' <EOL> def interact ( ) : <EOL> app = request . args ( <NUM_LIT:0> ) or '<STR_LIT>' <EOL> reset ( ) <EOL> web_debugger . run ( ) <EOL> filename = web_debugger . filename <EOL> lineno = web_debugger . lineno <EOL> if filename : <EOL> lines = dict ( [ ( i + <NUM_LIT:1> , l ) for ( i , l ) in enumerate ( <EOL> [ l . strip ( \"<STR_LIT:\\n>\" ) . strip ( \"<STR_LIT:\\r>\" ) for l <EOL> in open ( filename ) . readlines ( ) ] ) ] ) <EOL> filename = os . path . basename ( filename ) <EOL> else : <EOL> lines = { } <EOL> if filename : <EOL> web_debugger . set_burst ( <NUM_LIT:2> ) <EOL> env = web_debugger . do_environment ( ) <EOL> f_locals = env [ '<STR_LIT>' ] <EOL> f_globals = { } <EOL> for name , value in env [ '<STR_LIT>' ] . items ( ) : <EOL> if name not in gluon . html . __all__ and name not in gluon . validators . __all__ and name not in gluon . dal . __all__ : <EOL> f_globals [ name ] = pydoc . text . repr ( value ) <EOL> else : <EOL> f_locals = { } <EOL> f_globals = { } <EOL> response . headers [ '<STR_LIT>' ] = \"<STR_LIT:3>\" <EOL> if web_debugger . exception_info : <EOL> response . flash = T ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> return dict ( app = app , data = \"<STR_LIT>\" , <EOL> filename = web_debugger . filename , lines = lines , lineno = lineno , <EOL> f_globals = f_globals , f_locals = f_locals , <EOL> exception = web_debugger . exception_info ) <EOL> def step ( ) : <EOL> web_debugger . do_step ( ) <EOL> redirect ( URL ( \"<STR_LIT>\" ) ) <EOL> def next ( ) : <EOL> web_debugger . do_next ( ) <EOL> redirect ( URL ( \"<STR_LIT>\" ) ) <EOL> def cont ( ) : <EOL> web_debugger . do_continue ( ) <EOL> redirect ( URL ( \"<STR_LIT>\" ) ) <EOL> def ret ( ) : <EOL> web_debugger . do_return ( ) <EOL> redirect ( URL ( \"<STR_LIT>\" ) ) <EOL> def stop ( ) : <EOL> web_debugger . do_quit ( ) <EOL> redirect ( URL ( \"<STR_LIT>\" ) ) <EOL> def execute ( ) : <EOL> app = request . args [ <NUM_LIT:0> ] <EOL> command = request . vars . statement <EOL> session [ '<STR_LIT>' + app ] . append ( command ) <EOL> try : <EOL> output = web_debugger . do_exec ( command ) <EOL> if output is None : <EOL> output = \"<STR_LIT>\" <EOL> except Exception , e : <EOL> output = T ( \"<STR_LIT>\" ) % str ( e ) <EOL> k = len ( session [ '<STR_LIT>' + app ] ) - <NUM_LIT:1> <EOL> return '<STR_LIT>' % ( k + <NUM_LIT:1> , command , output ) <EOL> def breakpoints ( ) : <EOL> \"<STR_LIT>\" <EOL> files = listdir ( apath ( '<STR_LIT>' , r = request ) , '<STR_LIT>' ) <EOL> files = [ filename for filename in files <EOL> if filename and '<STR_LIT>' not in filename <EOL> and not filename . startswith ( \"<STR_LIT>\" ) <EOL> and not filename . startswith ( \"<STR_LIT>\" ) ] <EOL> form = SQLFORM . factory ( <EOL> Field ( '<STR_LIT:filename>' , requires = IS_IN_SET ( files ) , label = T ( \"<STR_LIT>\" ) ) , <EOL> Field ( '<STR_LIT>' , '<STR_LIT>' , label", "gt": ""}
{"id": 29487, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import inspect <EOL> import os <EOL> import pkgutil <EOL> from extensions . objects . models import objects <EOL> import feconf <EOL> import jinja_utils <EOL> FUZZY_RULE_TYPE = '<STR_LIT>' <EOL> def get_obj_type_for_param_name ( rule_class , param_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> param_list = get_param_list ( rule_class . description ) <EOL> for item in param_list : <EOL> if item [ <NUM_LIT:0> ] == param_name : <EOL> return item [ <NUM_LIT:1> ] <EOL> raise Exception ( <EOL> '<STR_LIT>' % ( rule_class . __name__ , param_name ) ) <EOL> def get_default_object_values ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <NUM_LIT:0.0> , <NUM_LIT:0.0> ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : [ ] <EOL> } , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : u'<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0.0> , <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : u'<STR_LIT>' <EOL> } <EOL> def get_rules_for_obj_type ( obj_type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rule_dir = os . path . join ( os . getcwd ( ) , feconf . RULES_DIR ) <EOL> rule_class_name = '<STR_LIT>' % obj_type <EOL> results = [ ] <EOL> for loader , name , _ in pkgutil . iter_modules ( path = [ rule_dir ] ) : <EOL> if name . endswith ( '<STR_LIT>' ) : <EOL> continue <EOL> module = loader . find_module ( name ) . load_module ( name ) <EOL> for name , clazz in inspect . getmembers ( module , inspect . isclass ) : <EOL> ancestors = clazz . __bases__ <EOL> ancestor_class_names = [ c . __name__ for c in ancestors ] <EOL> if rule_class_name in ancestor_class_names : <EOL> results . append ( clazz ) <EOL> return results <EOL> def get_description_strings_for_obj_type ( obj_type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rules = get_rules_for_obj_type ( obj_type ) <EOL> return { <EOL> rule . __name__ : rule . description <EOL> for rule in rules <EOL> } <EOL> def get_param_list ( description ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> param_list = [ ] <EOL> while description . find ( '<STR_LIT>' ) != - <NUM_LIT:1> : <EOL> opening_index = description . find ( '<STR_LIT>' ) <EOL> description = description [ opening_index + <NUM_LIT:2> : ] <EOL> bar_index = description . find ( '<STR_LIT:|>' ) <EOL> param_name = description [ : bar_index ] <EOL> description = description [ bar_index + <NUM_LIT:1> : ] <EOL> closing_index = description . find (", "gt": ""}
{"id": 43134, "input": "<s> from __future__ import division <EOL> import colorsys <EOL> from itertools import cycle <EOL> import numpy as np <EOL> import matplotlib as mpl <EOL> from six import string_types <EOL> from six . moves import range <EOL> from . import husl <EOL> from . xkcd_rgb import xkcd_rgb <EOL> def desaturate ( color , prop ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not <NUM_LIT:0> <= prop <= <NUM_LIT:1> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> rgb = mplcol . colorConverter . to_rgb ( color ) <EOL> h , l , s = colorsys . rgb_to_hls ( * rgb ) <EOL> s *= prop <EOL> new_color = colorsys . hls_to_rgb ( h , l , s ) <EOL> return new_color <EOL> class _ColorPalette ( list ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __enter__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . rcmod import set_palette <EOL> self . _orig_palette = color_palette ( ) <EOL> set_palette ( self , len ( self ) ) <EOL> return self <EOL> def __exit__ ( self , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . rcmod import set_palette <EOL> set_palette ( self . _orig_palette , len ( self . _orig_palette ) ) <EOL> def color_palette ( name = None , n_colors = <NUM_LIT:6> , desat = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> seaborn_palettes = dict ( <EOL> deep = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> muted = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> pastel = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> bright = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> dark = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> colorblind = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> ) <EOL> if name is None : <EOL> palette = mpl . rcParams [ \"<STR_LIT>\" ] <EOL> elif not isinstance ( name , string_types ) : <EOL> palette = name <EOL> elif name == \"<STR_LIT>\" : <EOL> palette = hls_palette ( n_colors ) <EOL> elif name == \"<STR_LIT>\" : <EOL> palette = husl_palette ( n_colors ) <EOL> elif name in seaborn_palettes : <EOL> palette = seaborn_palettes [ name ] <EOL> elif name in dir ( mpl . cm ) : <EOL> palette = mpl_palette ( name , n_colors ) <EOL> elif name [ : - <NUM_LIT:2> ] in dir ( mpl . cm ) : <EOL> palette = mpl_palette ( name , n_colors ) <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" % name ) <EOL> if desat is not None : <EOL> palette = [ desaturate ( c , desat ) for c in palette ] <EOL> pal_cycle = cycle ( palette ) <EOL> palette = [ next ( pal_cycle ) for _ in range ( n_colors ) ] <EOL> try : <EOL> palette = map ( mpl . colors . colorConverter . to_rgb , palette ) <EOL> palette = _ColorPalette ( palette ) <EOL> except ValueError : <EOL> raise ValueError ( \"<STR_LIT>\" % str ( name ) ) <EOL> return palette <EOL> def hls_palette ( n_colors = <NUM_LIT:6> , h = <NUM_LIT> , l = <NUM_LIT> , s = <NUM_LIT> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hues = np . linspace ( <NUM_LIT:0> , <NUM_LIT:1> , n_colors + <NUM_LIT:1> ) [ : - <NUM_LIT:1> ] <EOL> hues += h <EOL> hues %= <NUM_LIT:1> <EOL> hues -= hues . astype ( int ) <EOL> palette = [ colorsys . hls_to_rgb ( h_i , l , s ) for h_i in hues ] <EOL> return palette <EOL> def husl_palette ( n_colors = <NUM_LIT:6> , h = <NUM_LIT> , s = <NUM_LIT> , l = <NUM_LIT> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hues = np . linspace ( <NUM_LIT:0> , <NUM_LIT:1> , n_colors + <NUM_LIT:1> ) [ : - <NUM_LIT:1> ] <EOL> hues += h <EOL> hues %= <NUM_LIT:1> <EOL> hues *= <NUM_LIT> <EOL> s *= <NUM_LIT> <EOL> l *= <NUM_LIT> <EOL> palette = [ husl . husl_to_rgb ( h_i , s , l ) for h_i in hues ] <EOL> return palette <EOL> def mpl_palette ( name , n_colors = <NUM_LIT:6> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> brewer_qual_pals = { \"<STR_LIT>\" : <NUM_LIT:8> , \"<STR_LIT>\" : <NUM_LIT:8> , \"<STR_LIT>\" : <NUM_LIT:12> , <EOL> \"<STR_LIT>\" : <NUM_LIT:9> , \"<STR_LIT>\" : <NUM_LIT:8> , <EOL> \"<STR_LIT>\" : <NUM_LIT:9> , \"<STR_LIT>\" : <NUM_LIT:8> , \"<STR_LIT>\" : <NUM_LIT:12> } <EOL> if name . endswith ( \"<STR_LIT>\" ) : <EOL> pal = [ \"<STR_LIT>\" ] <EOL> pal . extend ( color_palette ( name . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <NUM_LIT:2> ) ) <EOL> cmap = blend_palette ( pal , n_colors , as_cmap = True ) <EOL> else : <EOL> cmap = getattr ( mpl . cm , name ) <EOL> if name in brewer_qual_pals : <EOL> bins = np", "gt": ""}
{"id": 24893, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __revision__ = \"<STR_LIT>\" <EOL> from Crypto . Cipher import _ARC4 <EOL> class ARC4Cipher : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , key , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _cipher = _ARC4 . new ( key ,", "gt": ""}
{"id": 38140, "input": "<s> import unittest2 as unittest <EOL> import numpy as np <EOL> class TestBeagleComposite ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> from vsm . corpus . util . corpusbuilders import random_corpus <EOL> from vsm . model . beaglecomposite import BeagleComposite <EOL> from vsm . model . beagleenvironment import BeagleEnvironment <EOL> from vsm . model . beaglecontext import BeagleContextSeq <EOL> from vsm . model . beagleorder import BeagleOrderSeq <EOL> self . ec = random_corpus ( <NUM_LIT:1000> , <NUM_LIT:50> , <NUM_LIT:0> , <NUM_LIT:20> , context_type = '<STR_LIT>' ) <EOL> self . cc = self . ec . apply_stoplist ( stoplist = [ str ( i ) for i in xrange ( <NUM_LIT:0> , <NUM_LIT:50> , <NUM_LIT:7> ) ] ) <EOL> self . e = BeagleEnvironment ( self . ec , n_cols = <NUM_LIT:5> ) <EOL> self . e . train ( ) <EOL> self . cm = BeagleContextSeq ( self . cc , self . ec , self . e . matrix ) <EOL> self . cm . train ( ) <EOL> self . om = BeagleOrderSeq ( self . ec , self . e . matrix ) <EOL> self . om . train ( ) <EOL> self . m = BeagleComposite ( self . cc , self . cm . matrix ,", "gt": ""}
{"id": 17778, "input": "<s> from __future__ import unicode_literals <EOL> from django . conf . urls import url <EOL> from . import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . index , name = '<STR_LIT:index>' ) , <EOL> url ( r'<STR_LIT>' , views . index_author , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , views . publish , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , views . publish , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , views . detail , kwargs = { '<STR_LIT>' : \"<STR_LIT>\" , } , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , views . detail , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , views . create_access , name =", "gt": ""}
{"id": 33032, "input": "<s> import os <EOL> from io import StringIO <EOL> __all__ = ( '<STR_LIT>' , ) <EOL> debug_base = '<STR_LIT>' <EOL> debug_base_2 = '<STR_LIT>' <EOL> file_regex = r'<STR_LIT>' <EOL> def load ( text , path , out ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dirname = os . path . dirname ( path ) <EOL> out . set_path ( dirname , file_regex ) <EOL> if text . startswith ( '<STR_LIT>' ) : <EOL> text = text [ <NUM_LIT> : ] <EOL> try : <EOL> from xml . parsers . expat import ExpatError , ErrorString <EOL> except ImportError : <EOL> try : <EOL> import plist_parser <EOL> except ImportError : <EOL> out . write_line ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> return <EOL> else : <EOL> out . write_line ( \"<STR_LIT>\" ) <EOL> try : <EOL> data = plist_parser . parse_string ( text ) <EOL> except plist_parser . PropertyListParseError as e : <EOL> out . write_line ( debug_base_2 % ( path , str ( e ) ) ) <EOL> else : <EOL> return data <EOL> else : <EOL> import plistlib <EOL> try : <EOL> return plistlib . readPlistFromBytes ( text . encode ( '<STR_LIT:utf-8>' ) ) <EOL> except ExpatError as e : <EOL> out . write_line ( debug_base <EOL> % ( path , <EOL> ErrorString ( e . code ) , <EOL> e . lineno , <EOL> e . offset + <NUM_LIT:1> ) <EOL> ) <EOL> def to_csscheme ( data , out , skip_names ) : <EOL> with StringIO ( ) as stream : <EOL> name = data . get ( '<STR_LIT:name>' , \"<STR_LIT>\" ) <EOL> stream . write ( '<STR_LIT>' % name ) <EOL> uuid = data . get ( '<STR_LIT>' ) <EOL> if uuid : <EOL> stream . write ( '<STR_LIT>' % uuid ) <EOL> items = data [ '<STR_LIT>' ] <EOL> settings = None <EOL> for i , item in enumerate ( items ) : <EOL> if '<STR_LIT>' not in item : <EOL> if '<STR_LIT>' not in item : <EOL> out . write_line ( \"<STR_LIT>\" ) <EOL> return <EOL> settings = item [ '<STR_LIT>' ] <EOL> del items [ i ] <EOL> break <EOL> if not settings : <EOL> settings = [ ] <EOL> else : <EOL> settings = list ( settings . items ( ) ) <EOL> settings . sort ( key = lambda x : x [ <NUM_LIT:0> ] . lower ( ) ) <EOL>", "gt": ""}
{"id": 421, "input": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import re <EOL> import sys <EOL> import os <EOL> def getRamId ( oid , sid ) : <EOL> if <NUM_LIT:0> <= sid and sid <= <NUM_LIT> : <EOL> return <NUM_LIT:0> <EOL> if <NUM_LIT:32> <= sid and sid <= <NUM_LIT> : <EOL> return <NUM_LIT:1> <EOL> if <NUM_LIT:64> <= sid and sid <= <NUM_LIT> : <EOL> return <NUM_LIT:2> <EOL> if <NUM_LIT> <= sid and sid <= <NUM_LIT> : <EOL> return <NUM_LIT:3> <EOL> def getRamSubId ( oid , sid ) : <EOL> if <NUM_LIT:0> <= sid and sid <= <NUM_LIT> : <EOL> return sid <EOL> if <NUM_LIT:32> <= sid and sid <= <NUM_LIT> : <EOL> return sid - <NUM_LIT:32> <EOL> if <NUM_LIT:64> <= sid and sid <= <NUM_LIT> : <EOL> return sid - <NUM_LIT:64> <EOL> if <NUM_LIT> <= sid and sid <= <NUM_LIT> : <EOL> return sid - <NUM_LIT> <EOL> def getChannelId ( oid , sid ) : <EOL> return oid <EOL> def getChannelSubId ( oid , sid ) : <EOL> return sid <EOL> def getRegisterId ( oid , sid ) : <EOL> return oid <EOL> def getRegisterSubId ( oid , sid ) : <EOL> return sid <EOL> def main ( ) : <EOL> f = open ( sys . argv [ <NUM_LIT:1> ] , '<STR_LIT:r>' ) <EOL> lines = f . readlines ( ) <EOL> output = [ ] <EOL> p_thread = re . compile ( '<STR_LIT>' ) <EOL> p_thread_id = re . compile ( '<STR_LIT>' ) <EOL> p_object_id = re . compile ( '<STR_LIT>' ) <EOL> p_width = re . compile ( '<STR_LIT>' ) <EOL> p_depth = re . compile ( '<STR_LIT>' ) <EOL> p_indexwidth = re . compile ( '<STR_LIT>' ) <EOL> p_logdepth = re . compile ( '<STR_LIT>' ) <EOL> p_sub_id = re . compile ( '<STR_LIT>' ) <EOL> module_name = None <EOL> thread_name = None <EOL> thread_id = None <EOL> object_id = None <EOL> sub_id = None <EOL> width = None <EOL> indexwidth = None <EOL> depth = None <EOL> mode = False <EOL> sub_id_num = None <EOL> sub_id_base = None <EOL> buffer = [ ] <EOL> print ( \"<STR_LIT>\" ) <EOL> for line in lines : <EOL> if not mode : <EOL> m = p_thread . match ( line ) <EOL> if m : <EOL> thread_name = re . match ( '<STR_LIT>' , m . group ( <NUM_LIT:2> ) ) . group ( <NUM_LIT:1> ) <EOL> module_name = re . search ( '<STR_LIT>' , line ) . group ( <NUM_LIT:1> ) <EOL> mode = True <EOL> buffer = [ ] <EOL> buffer . append ( line ) <EOL> continue <EOL> else : <EOL> m = p_thread_id . match ( line ) <EOL> if m : <EOL> tid_str = m . group ( <NUM_LIT:2> ) [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> thread_id = re . match ( '<STR_LIT>' , tid_str ) . group ( <NUM_LIT:2> ) <EOL> buffer . append ( line ) <EOL> continue <EOL> m = p_object_id . match ( line ) <EOL> if m : <EOL> oid_str = m . group ( <NUM_LIT:2> ) [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> object_id = re . match ( '<STR_LIT>' , oid_str ) . group ( <NUM_LIT:2> ) <EOL> buffer . append ( line ) <EOL> continue <EOL> m = p_width . match ( line ) <EOL> if m : <EOL> width_str = m . group ( <NUM_LIT:2> ) <EOL> width = re . match ( '<STR_LIT>' , width_str ) . group ( <NUM_LIT:1> ) <EOL> buffer . append ( line ) <EOL> continue <EOL> m = p_depth . match ( line ) <EOL> if m : <EOL> depth_str = m . group ( <NUM_LIT:2> ) <EOL> depth = re . match ( '<STR_LIT>' , depth_str ) . group (", "gt": ""}
{"id": 27445, "input": "<s> '''<STR_LIT>''' <EOL> from datetime import datetime <EOL> import inspect <EOL> from sqlalchemy import Table , Column , and_ , desc <EOL> from sqlalchemy . orm import mapper , MapperExtension , EXT_CONTINUE , object_session <EOL> from elixir import Integer , DateTime <EOL> from elixir . statements import Statement <EOL> from elixir . properties import EntityBuilder <EOL> from elixir . entity import getmembers <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> __doc_all__ = [ ] <EOL> def get_entity_where ( instance ) : <EOL> clauses = [ ] <EOL> for column in instance . table . primary_key . columns : <EOL> instance_value = getattr ( instance , column . name ) <EOL> clauses . append ( column == instance_value ) <EOL> return and_ ( * clauses ) <EOL> def get_history_where ( instance ) : <EOL> clauses = [ ] <EOL> history_columns = instance . __history_table__ . primary_key . columns <EOL> for column in instance . table . primary_key . columns : <EOL> instance_value = getattr ( instance , column . name ) <EOL> history_column = getattr ( history_columns , column . name ) <EOL> clauses . append ( history_column == instance_value ) <EOL> return and_ ( * clauses ) <EOL> class VersionedMapperExtension ( MapperExtension ) : <EOL> def before_insert ( self , mapper , connection , instance ) : <EOL> version_colname , timestamp_colname = instance . __class__ . __versioned_column_names__ <EOL> setattr ( instance , version_colname , <NUM_LIT:1> ) <EOL> setattr ( instance , timestamp_colname , datetime . now ( ) ) <EOL> return EXT_CONTINUE <EOL> def before_update ( self , mapper , connection , instance ) : <EOL> old_values = instance . table . select ( get_entity_where ( instance ) ) . execute ( ) . fetchone ( ) <EOL> ignored = instance . __class__ . __ignored_fields__ <EOL> version_colname , timestamp_colname = instance . __class__ . __versioned_column_names__ <EOL> for key in instance . table . c . keys ( ) : <EOL> if key in ignored : <EOL> continue <EOL> if getattr ( instance , key ) != old_values [ key ] : <EOL> dict_values = dict", "gt": ""}
{"id": 1967, "input": "<s> from __future__ import absolute_import <EOL> from __future__ import unicode_literals <EOL> import argparse <EOL> from pip_custom_platform . install import install <EOL> from pip_custom_platform . util import default_platform_name <EOL> from pip_custom_platform . wheel import wheel <EOL> def add_shared_arguments ( parser ) : <EOL> default_platform = default_platform_name ( ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> default = default_platform , <EOL> help = '<STR_LIT>' . format ( default_platform ) , <EOL> ) <EOL> def main ( argv = None ) : <EOL> parser = argparse . ArgumentParser ( <EOL> description = ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) , <EOL> ) <EOL> subparsers = parser . add_subparsers ( dest = '<STR_LIT>' ) <EOL> install_parser = subparsers . add_parser ( '<STR_LIT>' , help = '<STR_LIT>' ) <EOL> add_shared_arguments ( install_parser ) <EOL> wheel_parser = subparsers . add_parser ( '<STR_LIT>' , help = '<STR_LIT>' ) <EOL> add_shared_arguments ( wheel_parser ) <EOL> wheel_parser . add_argument ( <EOL> '<STR_LIT>' , '<STR_LIT>' , help = '<STR_LIT>' , <EOL> default = '<STR_LIT>' , <EOL> ) <EOL> args , argv = parser . parse_known_args ( argv ) <EOL> platform = args . platform . replace ( '<STR_LIT:->' , '<STR_LIT:_>' ) <EOL>", "gt": ""}
{"id": 19469, "input": "<s> from arangodb . tests . base import ExtendedTestCase <EOL> from arangodb . api import Database <EOL> from arangodb . user import User <EOL> class UserTestCase ( ExtendedTestCase ) : <EOL> def setUp ( self ) : <EOL> self . database_name = '<STR_LIT>' <EOL> self . db = Database . create ( name = self . database_name ) <EOL> def tearDown ( self ) : <EOL> Database . remove ( name = self . database_name ) <EOL>", "gt": ""}
{"id": 39586, "input": "<s> from filters import KeywordFilter <EOL> from django . db . models import Q <EOL> class PrefixIDFilter ( KeywordFilter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> is_default_and = False <EOL> def __init__ ( self , name , delimiter = \"<STR_LIT:->\" ) : <EOL> self . prefixlookup = \"<STR_LIT>\" <EOL> self . delimiter = delimiter <EOL> super ( PrefixIDFilter , self ) . __init__ (", "gt": ""}
{"id": 7125, "input": "<s> from django . test . utils import override_settings <EOL> from openstack_auth import policy as policy_backend <EOL> from openstack_dashboard import policy <EOL> from openstack_dashboard . test import helpers as test <EOL> class PolicyBackendTestCase ( test . TestCase ) : <EOL> def test_policy_file_load ( self ) : <EOL> policy_backend . reset ( ) <EOL> enforcer = policy_backend . _get_enforcer ( ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( enforcer ) ) <EOL> self . assertTrue ( '<STR_LIT>' in enforcer ) <EOL> self . assertTrue ( '<STR_LIT>' in enforcer ) <EOL> def test_policy_reset ( self ) : <EOL> policy_backend . _get_enforcer ( ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( policy_backend . _ENFORCER ) ) <EOL> policy_backend . reset ( ) <EOL> self . assertIsNone ( policy_backend . _ENFORCER ) <EOL> @ override_settings ( POLICY_CHECK_FUNCTION = policy_backend . check ) <EOL> def test_check_admin_required_false ( self ) : <EOL> policy_backend . reset ( ) <EOL> value = policy . check ( ( ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , ) , <EOL> request = self . request ) <EOL> self . assertFalse ( value ) <EOL> @ override_settings ( POLICY_CHECK_FUNCTION = policy_backend . check ) <EOL> def test_check_identity_rule_not_found_false ( self ) : <EOL> policy_backend . reset ( ) <EOL> value = policy . check ( ( ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , ) , <EOL> request = self . request ) <EOL> self . assertFalse ( value ) <EOL> @ override_settings ( POLICY_CHECK_FUNCTION = policy_backend . check ) <EOL> def test_check_nova_context_is_admin_false ( self ) : <EOL> policy_backend . reset ( ) <EOL> value = policy . check ( ( ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , ) , <EOL> request = self . request ) <EOL> self . assertFalse ( value ) <EOL> @ override_settings ( POLICY_CHECK_FUNCTION = policy_backend . check ) <EOL> def test_compound_check_false ( self ) : <EOL> policy_backend . reset ( ) <EOL> value = policy . check ( ( ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , ) , <EOL> request = self . request ) <EOL> self . assertFalse ( value ) <EOL> @ override_settings ( POLICY_CHECK_FUNCTION = policy_backend . check ) <EOL> def test_scope_not_found ( self ) : <EOL> policy_backend . reset ( ) <EOL> value = policy . check ( ( ( \"<STR_LIT>\" , \"<STR_LIT:default>\" ) , ) , <EOL> request", "gt": ""}
{"id": 49076, "input": "<s> from preggy import expect <EOL> def test_to_be_null ( ) : <EOL> expect ( None ) . to_be_null ( ) <EOL> try : <EOL> expect ( None ) . not_to_be_null ( ) <EOL> except AssertionError : <EOL> return <EOL> assert False , '<STR_LIT>' <EOL> def test_not_to_be_null ( ) : <EOL> expect", "gt": ""}
{"id": 40797, "input": "<s> from twisted . internet import protocol , reactor <EOL> from twisted . protocols import basic <EOL> class FingerProtocol ( basic . LineReceiver ) : <EOL> def lineReceived ( self , user ) : <EOL> self . transport . write ( \"<STR_LIT>\" ) <EOL> self . transport . loseConnection ( ) <EOL> class FingerFactory ( protocol .", "gt": ""}
{"id": 28302, "input": "<s> import sys , os <EOL> sys . path . append ( os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT:..>' ) ) <EOL> import messagebird <EOL> ACCESS_KEY = '<STR_LIT>' <EOL> try : <EOL> client = messagebird . Client ( ACCESS_KEY ) <EOL> vmsg = client . voice_message_create ( '<STR_LIT>' , '<STR_LIT>' , { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' % vmsg . id ) <EOL> print ( '<STR_LIT>' % vmsg . href ) <EOL> print ( '<STR_LIT>' % vmsg . originator ) <EOL> print ( '<STR_LIT>' % vmsg . body ) <EOL> print ( '<STR_LIT>' % vmsg . reference ) <EOL> print ( '<STR_LIT>' % vmsg . language ) <EOL> print ( '<STR_LIT>' % vmsg . voice ) <EOL> print ( '<STR_LIT>' % vmsg . repeat ) <EOL> print ( '<STR_LIT>' % vmsg . ifMachine ) <EOL> print ( '<STR_LIT>' % vmsg . scheduledDatetime ) <EOL> print", "gt": ""}
{"id": 21485, "input": "<s> from msrest . serialization import Model <EOL> class JobListOptions ( Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , filter = None , select = None , expand = None , max_results = None , timeout = <NUM_LIT:30> , client_request_id = None , return_client_request_id", "gt": ""}
{"id": 32168, "input": "<s> import numpy as np <EOL> import matplotlib . pyplot as plt <EOL> import sys <EOL> import getopt <EOL> import mesh . patch as patch <EOL> def makeplot ( myd , solver_name , outfile , W , H ) : <EOL> exec '<STR_LIT>' + solver_name + '<STR_LIT>' <EOL> sim = solver . Simulation ( solver_name , None , None ) <EOL> sim . cc_data = myd <EOL> plt . figure ( num = <NUM_LIT:1> , figsize = ( W , H ) , dpi = <NUM_LIT:100> , facecolor = '<STR_LIT:w>' ) <EOL> sim . dovis ( ) <EOL> plt . savefig ( outfile ) <EOL> plt . show ( ) <EOL> def usage ( ) : <EOL> usage = \"\"\"<STR_LIT>\"\"\" <EOL> print usage <EOL> sys . exit ( ) <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL>", "gt": ""}
{"id": 32248, "input": "<s> import flask <EOL> def get_response_meta ( ) : <EOL> return getattr ( flask . g , '<STR_LIT>' , None ) <EOL> def set_response_meta ( ** kwargs ) : <EOL> meta =", "gt": ""}
{"id": 32206, "input": "<s> from __future__ import absolute_import <EOL> from typing import Any <EOL> from django . conf import settings <EOL> from django . contrib . auth import authenticate , login , get_backends <EOL> from django . core . urlresolvers import reverse <EOL> from django . http import HttpResponseRedirect , HttpResponseForbidden , HttpResponse <EOL> from django . shortcuts import render_to_response , redirect <EOL> from django . template import RequestContext , loader <EOL> from django . utils . timezone import now <EOL> from django . utils . cache import patch_cache_control <EOL> from django . core . exceptions import ValidationError <EOL> from django . core import validators <EOL> from django . contrib . auth . views import login as django_login_page , logout_then_login as django_logout_then_login <EOL> from django . forms . models import model_to_dict <EOL> from django . core . mail import send_mail <EOL> from django . middleware . csrf import get_token <EOL> from zerver . models import Message , UserProfile , Stream , Subscription , Huddle , Recipient , Realm , UserMessage , DefaultStream , RealmEmoji , RealmAlias , RealmFilter , PreregistrationUser , get_client , MitUser , UserActivity , PushDeviceToken , get_stream , UserPresence , get_recipient , split_email_to_domain , resolve_email_to_domain , email_to_username , get_realm , completely_open , get_unique_open_realm , remote_user_to_email , email_allowed_for_realm <EOL> from zerver . lib . actions import do_change_password , do_change_full_name , do_change_is_admin , do_activate_user , do_create_user , internal_send_message , update_user_presence , do_events_register , get_status_dict , do_change_enable_offline_email_notifications , do_change_enable_digest_emails , do_set_realm_name , do_set_realm_restricted_to_domain , do_set_realm_invite_required , do_set_realm_invite_by_admins_only , get_default_subs , user_email_is_unique , do_invite_users , do_refer_friend , compute_mit_user_fullname , do_set_muted_topics , clear_followup_emails_queue , do_update_pointer , realm_user_count <EOL> from zerver . lib . push_notifications import num_push_devices_for_user <EOL> from zerver . forms import RegistrationForm , HomepageForm , ToSForm , CreateUserForm , is_inactive , OurAuthenticationForm <EOL> from django . views . decorators . csrf import csrf_exempt <EOL> from django_auth_ldap . backend import LDAPBackend , _LDAPUser <EOL> from zerver . lib import bugdown <EOL> from zerver . lib . validator import check_string , check_list , check_bool <EOL> from zerver . decorator import require_post , authenticated_json_post_view , has_request_variables , authenticated_json_view , to_non_negative_int , JsonableError , get_user_profile_by_email , REQ , require_realm_admin , zulip_login_required <EOL> from zerver . lib . avatar import avatar_url <EOL> from zerver . lib . upload import upload_message_image_through_web_client , get_signed_upload_url , get_realm_for_filename <EOL> from zerver . lib . response import json_success , json_error <EOL> from zerver . lib . utils import statsd , generate_random_token <EOL> from zproject . backends import password_auth_enabled , dev_auth_enabled <EOL> from confirmation . models import Confirmation <EOL> import requests <EOL> import subprocess <EOL> import calendar <EOL> import datetime <EOL> import ujson <EOL> import simplejson <EOL> import re <EOL> from six . moves import urllib <EOL> import base64 <EOL> import time <EOL> import logging <EOL> import jwt <EOL> import hashlib <EOL> import hmac <EOL> from zerver . lib . rest import rest_dispatch as _rest_dispatch <EOL> rest_dispatch = csrf_exempt ( ( lambda request , * args , ** kwargs : _rest_dispatch ( request , globals ( ) , * args , ** kwargs ) ) ) <EOL> def name_changes_disabled ( realm ) : <EOL> return settings . NAME_CHANGES_DISABLED or realm . name_changes_disabled <EOL> @ require_post <EOL> def accounts_register ( request ) : <EOL> key = request . POST [ '<STR_LIT:key>' ] <EOL> confirmation = Confirmation . objects . get ( confirmation_key = key ) <EOL> prereg_user = confirmation . content_object <EOL> email = prereg_user . email <EOL> mit_beta_user = isinstance ( confirmation . content_object , MitUser ) <EOL> try : <EOL> existing_user_profile = get_user_profile_by_email ( email ) <EOL> except UserProfile . DoesNotExist : <EOL> existing_user_profile = None <EOL> validators . validate_email ( email ) <EOL> unique_open_realm = get_unique_open_realm ( ) <EOL> if unique_open_realm : <EOL> realm = unique_open_realm <EOL> domain = realm . domain <EOL> elif not mit_beta_user and prereg_user . referred_by : <EOL> realm = prereg_user . referred_by . realm <EOL> domain = realm . domain <EOL> if not email_allowed_for_realm ( email , realm ) : <EOL> return render_to_response ( \"<STR_LIT>\" , { \"<STR_LIT>\" : realm . name } ) <EOL> elif not mit_beta_user and prereg_user . realm : <EOL> domain = prereg_user . realm . domain <EOL> realm = get_realm ( domain ) <EOL> else : <EOL> domain = resolve_email_to_domain ( email ) <EOL> realm = get_realm ( domain ) <EOL> if realm and realm . deactivated : <EOL> return render_to_response ( \"<STR_LIT>\" , <EOL> { \"<STR_LIT>\" : realm . name , <EOL> \"<STR_LIT>\" : settings . ZULIP_ADMINISTRATOR } ) <EOL> try : <EOL> if existing_user_profile is not None and existing_user_profile . is_mirror_dummy : <EOL> is_inactive ( email ) <EOL> else : <EOL> user_email_is_unique ( email ) <EOL> except ValidationError : <EOL> return HttpResponseRedirect ( reverse ( '<STR_LIT>' ) + '<STR_LIT>' + urllib . parse . quote_plus ( email ) ) <EOL> name_validated = False <EOL> full_name = None <EOL> if request . POST . get ( '<STR_LIT>' ) : <EOL> try : <EOL> del request . session [ '<STR_LIT>' ] <EOL> except KeyError : <EOL> pass <EOL> if domain == \"<STR_LIT>\" : <EOL> hesiod_name = compute_mit_user_fullname ( email ) <EOL> form = RegistrationForm ( <EOL> initial = { '<STR_LIT>' : hesiod_name if \"<STR_LIT:@>\" not in hesiod_name else \"<STR_LIT>\" } ) <EOL> name_validated = True <EOL> elif settings . POPULATE_PROFILE_VIA_LDAP : <EOL> for backend in get_backends ( ) : <EOL> if isinstance ( backend , LDAPBackend ) : <EOL> ldap_attrs = _LDAPUser ( backend , backend . django_to_ldap_username ( email ) ) . attrs <EOL> try : <EOL> request . session [ '<STR_LIT>' ] = ldap_attrs [ settings . AUTH_LDAP_USER_ATTR_MAP [ '<STR_LIT>' ] ] [ <NUM_LIT:0> ] <EOL> name_validated = True <EOL> form = RegistrationForm ( <EOL> { '<STR_LIT>' : request . session [ '<STR_LIT>' ] } ) <EOL> break <EOL> except TypeError : <EOL> form = RegistrationForm ( ) <EOL> elif '<STR_LIT>' in request . POST : <EOL> form = RegistrationForm ( <EOL> initial = { '<STR_LIT>' : request . POST . get ( '<STR_LIT>' ) } <EOL> ) <EOL> else : <EOL> form = RegistrationForm ( ) <EOL> else : <EOL> postdata = request . POST . copy ( ) <EOL> if name_changes_disabled ( realm ) : <EOL> try : <EOL> postdata . update ( { '<STR_LIT>' : request . session [ '<STR_LIT>' ] } ) <EOL> name_validated = True <EOL> except KeyError : <EOL> pass <EOL> form = RegistrationForm ( postdata ) <EOL> if not password_auth_enabled ( realm ) : <EOL> form [ '<STR_LIT:password>' ] . field . required = False <EOL> if form . is_valid ( ) : <EOL> if password_auth_enabled ( realm ) : <EOL> password = form . cleaned_data [ '<STR_LIT:password>' ] <EOL> else : <EOL> password = None <EOL> full_name = form . cleaned_data [ '<STR_LIT>' ] <EOL> short_name = email_to_username ( email ) <EOL> first_in_realm = len ( UserProfile . objects . filter ( realm = realm , is_bot = False ) ) == <NUM_LIT:0> <EOL> if existing_user_profile is not None and existing_user_profile . is_mirror_dummy : <EOL> try : <EOL> user_profile = existing_user_profile <EOL> do_activate_user ( user_profile ) <EOL> do_change_password ( user_profile , password ) <EOL> do_change_full_name ( user_profile , full_name ) <EOL> except UserProfile . DoesNotExist : <EOL> user_profile = do_create_user ( email , password , realm , full_name , short_name , <EOL> prereg_user = prereg_user , <EOL> newsletter_data = { \"<STR_LIT>\" : request . META [ '<STR_LIT>' ] } ) <EOL> else : <EOL> user_profile = do_create_user ( email , password , realm , full_name , short_name , <EOL> prereg_user = prereg_user , <EOL> newsletter_data = { \"<STR_LIT>\" : request . META [ '<STR_LIT>' ] } ) <EOL> login ( request , authenticate ( username = user_profile . email , use_dummy_backend = True ) ) <EOL> if first_in_realm : <EOL> do_change_is_admin ( user_profile , True ) <EOL> return HttpResponseRedirect ( reverse ( '<STR_LIT>' ) ) <EOL> else : <EOL> return HttpResponseRedirect ( reverse ( '<STR_LIT>' ) ) <EOL> return render_to_response ( '<STR_LIT>' , <EOL> { '<STR_LIT>' : form , <EOL> '<STR_LIT>' : domain , <EOL> '<STR_LIT:email>' : email , <EOL> '<STR_LIT:key>' : key , <EOL> '<STR_LIT>' : request . session . get ( '<STR_LIT>' , None ) , <EOL> '<STR_LIT>' : name_validated and name_changes_disabled ( realm ) , <EOL> '<STR_LIT>' : password_auth_enabled ( realm ) , <EOL> } , <EOL> context_instance = RequestContext ( request ) ) <EOL> @ zulip_login_required <EOL> def accounts_accept_terms ( request ) : <EOL> email = request . user . email <EOL> domain = resolve_email_to_domain ( email ) <EOL> if request . method == \"<STR_LIT:POST>\" : <EOL> form = ToSForm ( request . POST ) <EOL> if form . is_valid ( ) : <EOL> full_name = form . cleaned_data [ '<STR_LIT>' ] <EOL> send_mail ( '<STR_LIT>' + full_name , <EOL> loader . render_to_string ( '<STR_LIT>' , <EOL> { '<STR_LIT:name>' : full_name , <EOL> '<STR_LIT:email>' : email , <EOL> '<STR_LIT>' : request . META [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : request . META . get ( '<STR_LIT>' , \"<STR_LIT>\" ) } ) , <EOL> settings . EMAIL_HOST_USER , <EOL> [ \"<STR_LIT>\" ] ) <EOL> do_change_full_name ( request . user , full_name ) <EOL> return redirect ( home ) <EOL> else : <EOL> form = ToSForm ( ) <EOL> return render_to_response ( '<STR_LIT>' , <EOL> { '<STR_LIT>' : form , '<STR_LIT>' : domain , '<STR_LIT:email>' : email } , <EOL> context_instance = RequestContext ( request ) ) <EOL> from zerver . lib . ccache import make_ccache <EOL> @ authenticated_json_view <EOL> @ has_request_variables <EOL> def webathena_kerberos_login ( request , user_profile , <EOL> cred = REQ ( default = None ) ) : <EOL> if cred is None : <EOL> return json_error ( \"<STR_LIT>\" ) <EOL> if not user_profile . realm . domain == \"<STR_LIT>\" : <EOL> return json_error ( \"<STR_LIT>\" ) <EOL> try : <EOL> parsed_cred = ujson . loads ( cred ) <EOL> user = parsed_cred [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ <NUM_LIT:0> ] <EOL> if user == \"<STR_LIT>\" : <EOL> user = \"<STR_LIT>\" <EOL> assert ( user == user_profile . email . split ( \"<STR_LIT:@>\" ) [ <NUM_LIT:0> ] ) <EOL> ccache = make_ccache ( parsed_cred ) <EOL> except Exception : <EOL> return json_error ( \"<STR_LIT>\" ) <EOL> try : <EOL> subprocess . check_call ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> user , <EOL> user_profile . api_key , <EOL> base64 . b64encode ( ccache ) ] ) <EOL> except Exception : <EOL> logging . exception ( \"<STR_LIT>\" ) <EOL> return json_error ( \"<STR_LIT>\" ) <EOL> return json_success ( ) <EOL> def api_endpoint_docs ( request ) : <EOL> raw_calls = open ( '<STR_LIT>' , '<STR_LIT:r>' ) . read ( ) <EOL> calls = ujson . loads ( raw_calls ) <EOL> langs = set ( ) <EOL> for call in calls : <EOL> call [ \"<STR_LIT>\" ] = \"<STR_LIT>\" % ( settings . EXTERNAL_API_URI , call [ \"<STR_LIT>\" ] ) <EOL> call [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] = call [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] . replace ( \"<STR_LIT>\" , settings . EXTERNAL_API_URI ) <EOL> response = call [ '<STR_LIT>' ] <EOL> if not '<STR_LIT:\\n>' in response : <EOL> extended_response = response . replace ( \"<STR_LIT:U+002CU+0020>\" , \"<STR_LIT>\" ) <EOL> else : <EOL> extended_response = response <EOL> call [ '<STR_LIT>' ] = bugdown . convert ( \"<STR_LIT>\" + extended_response + \"<STR_LIT>\" , \"<STR_LIT:default>\" ) <EOL> for example_type in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> for lang in call . get ( '<STR_LIT>' + example_type , [ ] ) : <EOL> langs . add ( lang ) <EOL> return render_to_response ( <EOL> '<STR_LIT>' , { <EOL> '<STR_LIT:content>' : calls , <EOL> '<STR_LIT>' : langs , <EOL> } , <EOL> context_instance = RequestContext ( request ) ) <EOL> @ authenticated_json_post_view <EOL> @ has_request_variables <EOL> def json_invite_users ( request , user_profile , invitee_emails = REQ ) : <EOL> if not invitee_emails : <EOL> return json_error ( \"<STR_LIT>\" ) <EOL> invitee_emails = set ( re . split ( r'<STR_LIT>' , invitee_emails ) ) <EOL> stream_names = request . POST . getlist ( '<STR_LIT>' ) <EOL> if not stream_names : <EOL> return json_error ( \"<STR_LIT>\" ) <EOL> notifications_stream = user_profile . realm . notifications_stream <EOL> if notifications_stream and not notifications_stream . invite_only : <EOL> stream_names . append ( notifications_stream . name ) <EOL> streams = [ ] <EOL> for stream_name in stream_names : <EOL> stream = get_stream ( stream_name , user_profile . realm ) <EOL> if stream is None : <EOL> return json_error ( \"<STR_LIT>\" % ( stream_name , ) ) <EOL> streams . append ( stream ) <EOL> ret_error , error_data = do_invite_users ( user_profile , invitee_emails , streams ) <EOL> if ret_error is not None : <EOL> return json_error ( data = error_data , msg = ret_error ) <EOL> else : <EOL> return json_success ( ) <EOL> def create_homepage_form ( request , user_info = None ) : <EOL> if user_info : <EOL> return HomepageForm ( user_info , domain = request . session . get ( \"<STR_LIT>\" ) ) <EOL> return HomepageForm ( domain = request . session . get ( \"<STR_LIT>\" ) ) <EOL> def maybe_send_to_registration ( request , email , full_name = '<STR_LIT>' ) : <EOL> form = create_homepage_form ( request , user_info = { '<STR_LIT:email>' : email } ) <EOL> request . verified_email = None <EOL> if form . is_valid ( ) : <EOL> prereg_user = None <EOL> if settings . ONLY_SSO : <EOL> try : <EOL> prereg_user = PreregistrationUser . objects . filter ( email__iexact = email ) . latest ( \"<STR_LIT>\" ) <EOL> except PreregistrationUser . DoesNotExist : <EOL> prereg_user = create_preregistration_user ( email , request ) <EOL> else : <EOL> prereg_user = create_preregistration_user ( email , request ) <EOL> return redirect ( \"<STR_LIT>\" . join ( ( <EOL> settings . EXTERNAL_URI_SCHEME , <EOL> request . get_host ( ) , <EOL> \"<STR_LIT:/>\" , <EOL> Confirmation . objects . get_link_for_object ( prereg_user ) . split ( \"<STR_LIT:/>\" , <NUM_LIT:3> ) [ <NUM_LIT:3> ] , <EOL> '<STR_LIT>' , <EOL> urllib . parse . quote_plus ( full_name . encode ( '<STR_LIT:utf8>' ) ) ) ) ) <EOL> else : <EOL> return render_to_response ( '<STR_LIT>' , { '<STR_LIT>' : form } , <EOL> context_instance = RequestContext ( request ) ) <EOL> def login_or_register_remote_user ( request , remote_username , user_profile , full_name = '<STR_LIT>' ) : <EOL> if user_profile is None or user_profile . is_mirror_dummy : <EOL> return maybe_send_to_registration ( request , remote_user_to_email ( remote_username ) , full_name ) <EOL> else : <EOL> login ( request , user_profile ) <EOL> return HttpResponseRedirect ( \"<STR_LIT>\" % ( settings . EXTERNAL_URI_SCHEME , <EOL> request . get_host ( ) ) ) <EOL> def remote_user_sso ( request ) : <EOL> try : <EOL> remote_user = request . META [ \"<STR_LIT>\" ] <EOL> except KeyError : <EOL> raise JsonableError ( \"<STR_LIT>\" ) <EOL> user_profile = authenticate ( remote_user = remote_user ) <EOL> return login_or_register_remote_user ( request , remote_user , user_profile ) <EOL> @ csrf_exempt <EOL> def remote_user_jwt ( request ) : <EOL> try : <EOL> json_web_token = request . POST [ \"<STR_LIT>\" ] <EOL> payload , signing_input , header , signature = jwt . load ( json_web_token ) <EOL> except KeyError : <EOL> raise JsonableError ( \"<STR_LIT>\" ) <EOL> except jwt . DecodeError : <EOL> raise JsonableError ( \"<STR_LIT>\" ) <EOL> remote_user = payload . get ( \"<STR_LIT:user>\" , None ) <EOL> if remote_user is None : <EOL> raise JsonableError ( \"<STR_LIT>\" ) <EOL> domain = payload . get ( '<STR_LIT>' , None ) <EOL> if domain is None : <EOL> raise JsonableError ( \"<STR_LIT>\" ) <EOL> email = \"<STR_LIT>\" % ( remote_user , domain ) <EOL> try : <EOL> jwt . verify_signature ( payload , signing_input , header , signature , <EOL> settings . JWT_AUTH_KEYS [ domain ] ) <EOL> user_profile = authenticate ( username = email , use_dummy_backend = True ) <EOL> except ( jwt . DecodeError , jwt . ExpiredSignature ) : <EOL> raise JsonableError ( \"<STR_LIT>\" ) <EOL> except KeyError : <EOL> raise JsonableError ( \"<STR_LIT>\" ) <EOL> except UserProfile . DoesNotExist : <EOL> user_profile = None <EOL> return login_or_register_remote_user ( request , email , user_profile , remote_user ) <EOL> def google_oauth2_csrf ( request , value ) : <EOL> return hmac . new ( get_token ( request ) . encode ( '<STR_LIT:utf-8>' ) , value , hashlib . sha256 ) . hexdigest ( ) <EOL> def start_google_oauth2 ( request ) : <EOL> uri = '<STR_LIT>' <EOL> cur_time = str ( int ( time . time ( ) ) ) <EOL> csrf_state = '<STR_LIT>' . format ( <EOL> cur_time , <EOL> google_oauth2_csrf ( request , cur_time ) , <EOL> ) <EOL> prams = { <EOL> '<STR_LIT>' : '<STR_LIT:code>' , <EOL> '<STR_LIT>' : settings . GOOGLE_OAUTH2_CLIENT_ID , <EOL> '<STR_LIT>' : '<STR_LIT>' . join ( ( <EOL> settings . EXTERNAL_URI_SCHEME , <EOL> request . get_host ( ) , <EOL> reverse ( '<STR_LIT>' ) , <EOL> ) ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:state>' : csrf_state , <EOL> } <EOL> return redirect ( uri + urllib . parse . urlencode ( prams ) ) <EOL> requests_json_is_function = callable ( requests . Response . json ) <EOL> def extract_json_response ( resp ) : <EOL> if requests_json_is_function : <EOL> return resp . json ( ) <EOL> else : <EOL> return resp . json <EOL> def finish_google_oauth2 ( request ) : <EOL> error = request . GET . get ( '<STR_LIT:error>' ) <EOL> if error == '<STR_LIT>' : <EOL> return redirect ( '<STR_LIT:/>' ) <EOL> elif error is not None : <EOL> logging . warning ( '<STR_LIT>' , request . GET ) <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> value , hmac_value = request . GET . get ( '<STR_LIT:state>' ) . split ( '<STR_LIT::>' ) <EOL> if hmac_value != google_oauth2_csrf ( request , value ) : <EOL> logging . warning ( '<STR_LIT>' ) <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> resp = requests . post ( <EOL> '<STR_LIT>' , <EOL> data = { <EOL> '<STR_LIT:code>' : request . GET . get ( '<STR_LIT:code>' ) , <EOL> '<STR_LIT>' : settings . GOOGLE_OAUTH2_CLIENT_ID , <EOL> '<STR_LIT>' : settings . GOOGLE_OAUTH2_CLIENT_SECRET , <EOL> '<STR_LIT>' : '<STR_LIT>' . join ( ( <EOL> settings . EXTERNAL_URI_SCHEME , <EOL> request . get_host ( ) , <EOL> reverse ( '<STR_LIT>' ) , <EOL> ) ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ) <EOL> if resp . status_code == <NUM_LIT> : <EOL> logging . warning ( '<STR_LIT>' % ( resp . text , ) ) <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> elif resp . status_code != <NUM_LIT:200> : <EOL> raise Exception ( '<STR_LIT>' % ( resp . text , ) ) <EOL> access_token = extract_json_response ( resp ) [ '<STR_LIT>' ] <EOL> resp = requests . get ( <EOL> '<STR_LIT>' , <EOL> params = { '<STR_LIT>' : access_token } <EOL> ) <EOL> if resp . status_code == <NUM_LIT> : <EOL> logging . warning ( '<STR_LIT>' % ( resp . text , ) ) <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> elif resp . status_code != <NUM_LIT:200> : <EOL> raise Exception ( '<STR_LIT>' % ( resp . text , ) ) <EOL> body = extract_json_response ( resp ) <EOL> try : <EOL> full_name = body [ '<STR_LIT:name>' ] [ '<STR_LIT>' ] <EOL> except KeyError : <EOL> full_name = u'<STR_LIT>' . format ( <EOL> body [ '<STR_LIT:name>' ] [ '<STR_LIT>' ] , body [ '<STR_LIT:name>' ] [ '<STR_LIT>' ] <EOL> ) <EOL> for email in body [ '<STR_LIT>' ] : <EOL> if email [ '<STR_LIT:type>' ] == '<STR_LIT>' : <EOL> break <EOL> else : <EOL> raise Exception ( '<STR_LIT>' % ( body , ) ) <EOL> email_address = email [ '<STR_LIT:value>' ] <EOL> user_profile = authenticate ( username = email_address , use_dummy_backend = True ) <EOL> return login_or_register_remote_user ( request , email_address , user_profile , full_name ) <EOL> def login_page ( request , ** kwargs ) : <EOL> extra_context = kwargs . pop ( '<STR_LIT>' , { } ) <EOL> if dev_auth_enabled ( ) : <EOL> MAX_DEV_BACKEND_USERS = <NUM_LIT:100> <EOL> users_query = UserProfile . objects . select_related ( ) . filter ( is_bot = False , is_active = True ) <EOL> users = users_query . order_by ( '<STR_LIT:email>' ) [ <NUM_LIT:0> : MAX_DEV_BACKEND_USERS ] <EOL> extra_context [ '<STR_LIT>' ] = [ u . email for u in users if u . is_realm_admin ] <EOL> extra_context [ '<STR_LIT>' ] = [ u . email for u in users if not u . is_realm_admin ] <EOL> template_response = django_login_page ( <EOL> request , authentication_form = OurAuthenticationForm , <EOL> extra_context = extra_context , ** kwargs ) <EOL> try : <EOL> template_response . context_data [ '<STR_LIT:email>' ] = request . GET [ '<STR_LIT:email>' ] <EOL> except KeyError : <EOL> pass <EOL> return template_response <EOL> def dev_direct_login ( request , ** kwargs ) : <EOL> if ( not dev_auth_enabled ( ) ) or settings . PRODUCTION : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> email = request . POST [ '<STR_LIT>' ] <EOL> user_profile = authenticate ( username = email ) <EOL> login ( request , user_profile ) <EOL> return HttpResponseRedirect ( \"<STR_LIT>\" % ( settings . EXTERNAL_URI_SCHEME , <EOL> request . get_host ( ) ) ) <EOL> @ authenticated_json_post_view <EOL> @ has_request_variables <EOL> def json_bulk_invite_users ( request , user_profile , <EOL> invitee_emails = REQ ( validator = check_list ( check_string ) ) ) : <EOL> invitee_emails = set ( invitee_emails ) <EOL> streams = get_default_subs ( user_profile ) <EOL> ret_error , error_data = do_invite_users ( user_profile , invitee_emails , streams ) <EOL> if ret_error is not None : <EOL> return json_error ( data = error_data , msg = ret_error ) <EOL> else : <EOL> invited = PreregistrationUser . objects . filter ( referred_by = user_profile ) <EOL> internal_message = \"<STR_LIT>\" % ( <EOL> user_profile . full_name , user_profile . email , invited . count ( ) ) <EOL> internal_send_message ( settings . NEW_USER_BOT , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> user_profile . realm . domain , internal_message ) <EOL> return json_success ( ) <EOL> @ zulip_login_required <EOL> def initial_invite_page ( request ) : <EOL> user = request . user <EOL> domain_count = len ( UserProfile . objects . filter ( realm = user . realm ) ) <EOL> if domain_count > <NUM_LIT:1> : <EOL> return redirect ( '<STR_LIT>' ) <EOL> params = { '<STR_LIT>' : user . realm . domain } <EOL> if ( user . realm . restricted_to_domain ) : <EOL> params [ '<STR_LIT>' ] = user . realm . domain <EOL> return render_to_response ( '<STR_LIT>' , params , <EOL> context_instance = RequestContext ( request ) ) <EOL> @ require_post <EOL> def logout_then_login ( request , ** kwargs ) : <EOL> return django_logout_then_login ( request , kwargs ) <EOL> def create_preregistration_user ( email , request ) : <EOL> domain = request . session . get ( \"<STR_LIT>\" ) <EOL> if completely_open ( domain ) : <EOL> request . session [ \"<STR_LIT>\" ] = None <EOL> return PreregistrationUser . objects . create ( email = email , <EOL> realm = get_realm ( domain ) ) <EOL> if split_email_to_domain ( email ) == \"<STR_LIT>\" : <EOL> return MitUser . objects . get_or_create ( email = email ) [ <NUM_LIT:0> ] <EOL> return PreregistrationUser . objects . create ( email = email ) <EOL> def accounts_home_with_domain ( request , domain ) : <EOL> if completely_open ( domain ) : <EOL> request . session [ \"<STR_LIT>\" ] = domain <EOL> return accounts_home ( request ) <EOL> else : <EOL> return HttpResponseRedirect ( reverse ( '<STR_LIT>' ) ) <EOL> def send_registration_completion_email ( email , request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> prereg_user = create_preregistration_user ( email , request ) <EOL> context = { '<STR_LIT>' : settings . ZULIP_ADMINISTRATOR , <EOL> '<STR_LIT>' : settings . VOYAGER } <EOL> Confirmation . objects . send_confirmation ( prereg_user , email , <EOL> additional_context = context ) <EOL> def accounts_home ( request ) : <EOL> if request . method == '<STR_LIT:POST>' : <EOL> form = create_homepage_form ( request , user_info = request . POST ) <EOL> if form . is_valid ( ) : <EOL> email = form . cleaned_data [ '<STR_LIT:email>' ] <EOL> send_registration_completion_email ( email , request ) <EOL> return HttpResponseRedirect ( reverse ( '<STR_LIT>' , kwargs = { '<STR_LIT:email>' : email } ) ) <EOL> try : <EOL> email = request . POST [ '<STR_LIT:email>' ] <EOL> is_inactive ( email ) <EOL> except ValidationError : <EOL> return HttpResponseRedirect ( reverse ( '<STR_LIT>' ) + '<STR_LIT>' + urllib . parse . quote_plus ( email ) ) <EOL> else : <EOL> form = create_homepage_form ( request ) <EOL> return render_to_response ( '<STR_LIT>' , <EOL> {", "gt": ""}
{"id": 2162, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . core . management . base import BaseCommand <EOL> from ... models import set_cached_snippet , Snippet <EOL> class Command ( BaseCommand ) : <EOL> help = \"<STR_LIT>\" <EOL>", "gt": ""}
{"id": 36215, "input": "<s> from __future__ import unicode_literals <EOL> from bs4 import BeautifulSoup , NavigableString <EOL> from django . forms . models import modelform_factory <EOL> from django . test import TestCase as DjangoTestCase <EOL> from django . utils . html import conditional_escape <EOL> from wysihtml5 . tests . models import ModelTest <EOL> from wysihtml5 . widgets import ( Wysihtml5TextareaWidget , <EOL> render_cmd_icon , render_cmd_dialog ) <EOL> class Wysihtml5ToolbarTestCase ( DjangoTestCase ) : <EOL> def setUp ( self ) : <EOL> ModelForm = modelform_factory ( ModelTest ) <EOL> self . soup = BeautifulSoup ( ModelForm ( ) . __str__ ( ) ) <EOL> def", "gt": ""}
{"id": 22151, "input": "<s> from __future__ import division , print_function , unicode_literals <EOL> from six . moves . urllib . request import urlretrieve <EOL> import numpy as np <EOL> import tarfile <EOL> import h5py <EOL> import os <EOL> bs_data_dir = os . environ . get ( '<STR_LIT>' , '<STR_LIT:.>' ) <EOL> url = '<STR_LIT>' <EOL> cifar10_file = os . path . join ( bs_data_dir , '<STR_LIT>' ) <EOL> hdf_file = os . path . join ( bs_data_dir , '<STR_LIT>' ) <EOL> print ( \"<STR_LIT>\" , bs_data_dir ) <EOL> if not os . path . exists ( cifar10_file ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> urlretrieve ( url , cifar10_file ) <EOL> print ( \"<STR_LIT>\" ) <EOL> archive_paths = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> print ( \"<STR_LIT>\" ) <EOL> with tarfile . open ( cifar10_file ) as f : <EOL> res = [ ] <EOL> for fn in archive_paths : <EOL> buf = f . extractfile ( fn ) . read ( ) <EOL> tmp = np . fromstring ( buf , dtype = np . uint8 ) . reshape ( - <NUM_LIT:1> , <NUM_LIT> * <NUM_LIT:3> + <NUM_LIT:1> ) <EOL> res . append ( tmp ) <EOL> print ( \"<STR_LIT>\" ) <EOL> ds = np . concatenate ( res ) <EOL> num_tr = <NUM_LIT> <EOL> x_tr = ds [ : num_tr , <NUM_LIT:1> : ] . reshape ( ( <NUM_LIT:1> , num_tr , <NUM_LIT:3> , <NUM_LIT:32> , <NUM_LIT:32> ) ) <EOL> x_tr = x_tr . transpose ( [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:2> ] ) <EOL> y_tr = ds [ : num_tr , <NUM_LIT:0> ] . reshape ( ( <NUM_LIT:1> , num_tr , <NUM_LIT:1> ) ) <EOL> x_va = ds [ num_tr : <NUM_LIT> , <NUM_LIT:1> : ] . reshape ( ( <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:32> , <NUM_LIT:32> ) ) <EOL> x_va = x_va . transpose ( [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:2> ] ) <EOL> y_va = ds [ num_tr : <NUM_LIT> , <NUM_LIT:0> ] . reshape ( ( <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT:1> ) ) <EOL> x_te = ds [ <NUM_LIT> : , <NUM_LIT:1> : ] . reshape ( ( <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:32> , <NUM_LIT:32> ) ) <EOL> x_te = x_te . transpose ( [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:2> ] ) <EOL> y_te = ds [ <NUM_LIT> : , <NUM_LIT:0> ] . reshape ( ( <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT:1> ) ) <EOL> tr_mean = x_tr . squeeze ( ) . mean ( axis = <NUM_LIT:0> ) <EOL> tr_std = x_tr . squeeze ( ) . std ( axis = <NUM_LIT:0> ) <EOL> x_tr = ( x_tr - tr_mean ) / tr_std <EOL> x_va = ( x_va -", "gt": ""}
{"id": 6803, "input": "<s> from numba import autojit <EOL> import numpy as np <EOL> @ autojit <EOL> def mandel ( x , y , max_iters ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> i = <NUM_LIT:0> <EOL> c = complex ( x , y ) <EOL> z = <NUM_LIT> <EOL> for i in range ( max_iters ) : <EOL> z = z * z + c <EOL> if ( z . real * z . real + z . imag * z . imag ) >= <NUM_LIT:4> : <EOL> return i <EOL> return <NUM_LIT:255> <EOL> @ autojit <EOL> def create_fractal ( min_x , max_x , min_y , max_y , image , iters ) : <EOL> height = image . shape [ <NUM_LIT:0> ] <EOL> width = image . shape [ <NUM_LIT:1> ] <EOL> pixel_size_x = ( max_x - min_x ) / width <EOL> pixel_size_y = ( max_y - min_y ) / height <EOL> for x in range ( width ) : <EOL> real = min_x + x * pixel_size_x <EOL> for y in range ( height ) : <EOL> imag = min_y + y * pixel_size_y <EOL>", "gt": ""}
{"id": 39923, "input": "<s> from __future__ import absolute_import , print_function <EOL> import numpy as np <EOL> from numba import cuda <EOL> from numba . cuda . testing import unittest <EOL> class TestCudaEvent ( unittest . TestCase ) : <EOL> def test_event_elapsed ( self ) : <EOL> N = <NUM_LIT:32> <EOL> dary = cuda . device_array ( N , dtype = np . double ) <EOL> evtstart = cuda . event ( ) <EOL> evtend = cuda . event ( ) <EOL> evtstart . record ( ) <EOL> cuda .", "gt": ""}
{"id": 24092, "input": "<s> '''<STR_LIT>''' <EOL> from burp import IBurpExtender <EOL> from burp import IMessageEditorTabFactory <EOL> from burp import IMessageEditorTab <EOL> import re <EOL> class BurpExtender ( IBurpExtender , IMessageEditorTabFactory ) : <EOL> def registerExtenderCallbacks ( self , callbacks ) : <EOL> self . _callbacks = callbacks <EOL> self . _helpers = callbacks . getHelpers ( ) <EOL> callbacks . setExtensionName ( \"<STR_LIT>\" ) <EOL> callbacks . registerMessageEditorTabFactory ( self ) <EOL> def createNewInstance ( self , controller , editable ) : <EOL> tab = UrlDecoderTab ( self , controller , editable ) <EOL> return tab <EOL> class UrlDecoderTab ( IMessageEditorTab ) : <EOL> def __init__ ( self , extender , controller , editable ) : <EOL> self . _extender = extender <EOL> self . _editable = editable <EOL> self . _txtInput = extender . _callbacks . createTextEditor ( ) <EOL> self . _txtInput . setEditable ( editable ) <EOL> return <EOL> def decodeData ( self , content ) : <EOL> params = self . _extender . _helpers . analyzeRequest ( content ) . getParameters ( ) <EOL>", "gt": ""}
{"id": 30083, "input": "<s> from libqtile . config import Key , Screen , Group , Drag , Click <EOL> from libqtile . command import lazy <EOL> from libqtile import layout , bar , widget <EOL> mod = \"<STR_LIT>\" <EOL> keys = [ <EOL> Key ( <EOL> [ mod ] , \"<STR_LIT:k>\" , <EOL> lazy . layout . down ( ) <EOL> ) , <EOL> Key ( <EOL> [ mod ] , \"<STR_LIT>\" , <EOL> lazy . layout . up ( ) <EOL> ) , <EOL> Key ( <EOL> [ mod , \"<STR_LIT>\" ] , \"<STR_LIT:k>\" , <EOL> lazy . layout . shuffle_down ( ) <EOL> ) , <EOL> Key ( <EOL> [ mod , \"<STR_LIT>\" ] , \"<STR_LIT>\" , <EOL> lazy . layout . shuffle_up ( ) <EOL> ) , <EOL> Key ( <EOL> [ mod ] , \"<STR_LIT>\" , <EOL> lazy . layout . next ( ) <EOL> ) , <EOL> Key ( <EOL> [ mod , \"<STR_LIT>\" ] , \"<STR_LIT>\" , <EOL> lazy . layout . rotate ( ) <EOL> ) , <EOL> Key ( <EOL> [ mod , \"<STR_LIT>\" ] , \"<STR_LIT>\" , <EOL> lazy . layout . toggle_split ( ) <EOL> ) , <EOL> Key ( [ mod ] , \"<STR_LIT>\" , lazy . spawn ( \"<STR_LIT>\" ) ) , <EOL> Key ( [ mod ] , \"<STR_LIT>\" , lazy . next_layout ( ) ) , <EOL> Key ( [ mod ] , \"<STR_LIT:w>\" , lazy . window . kill ( ) ) , <EOL> Key ( [ mod , \"<STR_LIT>\" ] , \"<STR_LIT:r>\" , lazy . restart ( ) ) , <EOL> Key ( [ mod , \"<STR_LIT>\" ] , \"<STR_LIT:q>\" , lazy . shutdown ( ) ) , <EOL> Key ( [ mod ] , \"<STR_LIT:r>\" , lazy . spawncmd ( ) ) , <EOL> ] <EOL> groups = [ Group ( i ) for i in \"<STR_LIT>\" ] <EOL> for i in groups : <EOL> keys . append ( <EOL> Key (", "gt": ""}
{"id": 30036, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import diamond . collector <EOL> import re <EOL> class DRBDCollector ( diamond . collector . Collector ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def get_default_config_help ( self ) : <EOL> config_help = super ( DRBDCollector , self ) . get_default_config_help ( ) <EOL> config_help . update ( { <EOL> } ) <EOL> return config_help <EOL> def get_default_config ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> config = super ( DRBDCollector , self ) . get_default_config ( ) <EOL> config . update ( { <EOL> '<STR_LIT:path>' : '<STR_LIT>' <EOL> } ) <EOL> return config <EOL> def collect ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> performance_indicators = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> results = dict ( ) <EOL> try : <EOL> statusfile = open ( '<STR_LIT>' , '<STR_LIT:r>' ) <EOL> current_resource = '<STR_LIT>' <EOL> for line in statusfile : <EOL> if re . search ( '<STR_LIT:version>' , line ) is None : <EOL> if re . search ( r'<STR_LIT>' , line", "gt": ""}
{"id": 42991, "input": "<s> from pyramid . events import subscriber <EOL> from websauna . system . admin import menu <EOL> from websauna . system . admin . events import AdminConstruction <EOL> from websauna . system . admin . modeladmin import ModelAdminRoot <EOL> from websauna . system . core . traversal import Resource <EOL> @ subscriber ( AdminConstruction ) <EOL> def contribute_model_admin ( event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> admin = event . admin <EOL> request = event . admin . request <EOL> model_admin_root = ModelAdminRoot ( request ) <EOL> Resource . make_lineage ( admin , model_admin_root , \"<STR_LIT>\" ) <EOL> admin . children [ \"<STR_LIT>\" ] = model_admin_root <EOL> data_menu", "gt": ""}
{"id": 33897, "input": "<s> import vtk <EOL> sphere = vtk . vtkSphereSource ( ) <EOL> cone = vtk . vtkConeSource ( ) <EOL> glyph = vtk . vtkGlyph3D ( ) <EOL> glyph . SetInputConnection ( sphere . GetOutputPort ( ) ) <EOL> glyph . SetSource ( cone . GetOutput ( ) ) <EOL> glyph . SetVectorModeToUseNormal ( ) <EOL> glyph . SetScaleModeToScaleByVector ( ) <EOL> glyph . SetScaleFactor ( <NUM_LIT> ) <EOL> appendData = vtk . vtkAppendPolyData ( ) <EOL> appendData . AddInput ( glyph . GetOutput ( ) ) <EOL> appendData . AddInput ( sphere . GetOutput ( ) ) <EOL> maceMapper = vtk . vtkPolyDataMapper ( ) <EOL> maceMapper . SetInputConnection ( appendData . GetOutputPort ( ) ) <EOL> maceActor = vtk . vtkLODActor ( ) <EOL> maceActor . SetMapper ( maceMapper ) <EOL> maceActor . VisibilityOn ( ) <EOL> ren = vtk . vtkRenderer ( ) <EOL> renWin = vtk . vtkRenderWindow ( ) <EOL> renWin . AddRenderer ( ren ) <EOL> iren =", "gt": ""}
{"id": 18095, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from cloudcafe . compute . common . composites import BaseComputeComposite <EOL> from cloudcafe . compute . hypervisors_api . client import HypervisorsClient <EOL> class HypervisorsComposite ( BaseComputeComposite ) : <EOL> def __init__ ( self , auth_composite ) : <EOL> super ( HypervisorsComposite , self ) . __init__", "gt": ""}