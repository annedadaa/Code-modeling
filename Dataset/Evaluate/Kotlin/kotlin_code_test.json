{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.Observable  <EOL>  import io.reactivex.ObservableSource  <EOL>  import io.reactivex.Observer  <EOL>  import io.reactivex.disposables.Disposables  <EOL>  import io.reactivex.subjects.PublishSubject  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import kotlinx.coroutines.testing.flow.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableAsFlowTest : TestBase() {  <EOL>      @Test  <EOL>      fun testCancellation() = runTest {  <EOL>          var onNext =  <NUM_LIT:0>  <EOL>          var onCancelled =  <NUM_LIT:0>  <EOL>          var onError =  <NUM_LIT:0>  <EOL>   <EOL>          val source = rxObservable(currentDispatcher()) {  <EOL>              coroutineContext[Job]?.invokeOnCompletion {  <EOL>                  if (it is CancellationException) ++onCancelled  <EOL>              }  <EOL>   <EOL>              repeat( <NUM_LIT:100> ) {  <EOL>                  send(it)  <EOL>              }  <EOL>          }  <EOL>   <EOL>          source.asFlow().launchIn(CoroutineScope(Dispatchers.Unconfined)) {  <EOL>              onEach {  <EOL>                  ++onNext  <EOL>                  throw RuntimeException()  <EOL>              }  <EOL>              catch<Throwable> {  <EOL>                  ++onError  <EOL>              }  <EOL>          }.join()  <EOL>   <EOL>   <EOL>          assertEquals( <NUM_LIT:1> , onNext)  <EOL>          assertEquals( <NUM_LIT:1> , onError)  <EOL>          assertEquals( <NUM_LIT:1> , onCancelled)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testImmediateCollection() {  <EOL>          val source = PublishSubject.create<Int>()  <EOL>          val flow = source.asFlow()  <EOL>          GlobalScope.launch(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              flow.collect { expect(it) }  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          source.onNext( <NUM_LIT> )  <EOL>          expect( <NUM_LIT> )  <EOL>          source.onNext( <NUM_LIT> )  <EOL>          source.onComplete()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testOnErrorCancellation() {  <EOL>          val source = PublishSubject.create<Int>()  <EOL>          val flow = source.asFlow()  <EOL>          val exception = RuntimeException()  <EOL>          GlobalScope.launch(Dispatchers.Unconfined) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>                  flow.collect { expect(it) }  <EOL>                  expectUnreached()  <EOL>              }  <EOL>              catch (e: Exception) {  <EOL>                  assertSame(exception, e.cause)  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          source.onNext( <NUM_LIT> )  <EOL>          expect( <NUM_LIT> )  <EOL>          source.onError(exception)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testUnsubscribeOnCollectionException() {  <EOL>          val source = PublishSubject.create<Int>()  <EOL>          val flow = source.asFlow()  <EOL>          val exception = RuntimeException()  <EOL>          GlobalScope.launch(Dispatchers.Unconfined) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>                  flow.collect {  <EOL>                      expect(it)  <EOL>                      if (it ==  <NUM_LIT> ) throw exception  <EOL>                  }  <EOL>                  expectUnreached()  <EOL>              }  <EOL>              catch (e: Exception) {  <EOL>                  assertSame(exception, e.cause)  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          assertTrue(source.hasObservers())  <EOL>          source.onNext( <NUM_LIT> )  <EOL>          assertFalse(source.hasObservers())  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testLateOnSubscribe() {  <EOL>          var observer: Observer<in Int>? = null  <EOL>          val source = ObservableSource<Int> { observer = it }  <EOL>          val flow = source.asFlow()  <EOL>          assertNull(observer)  <EOL>          val job = GlobalScope.launch(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              flow.collect { expectUnreached() }  <EOL>              expectUnreached()  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          assertNotNull(observer)  <EOL>          job.cancel()  <EOL>          val disposable = Disposables.empty()  <EOL>          observer!!.onSubscribe(disposable)  <EOL>          assertTrue(disposable.isDisposed)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBufferUnlimited() = runTest {  <EOL>          val source = rxObservable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT:1> ); send( <NUM_LIT:10> )  <EOL>              expect( <NUM_LIT:2> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          source.asFlow().buffer(Channel.UNLIMITED).collect { expect(it) }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConflated() = runTest {  <EOL>          val source = Observable.range( <NUM_LIT:1> ,  <NUM_LIT> )  <EOL>          val list = source.asFlow().conflate().toList()  <EOL>          assertEquals(listOf( <NUM_LIT:1> ,  <NUM_LIT> ), list)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testLongRange() = runTest {  <EOL>          val source = Observable.range( <NUM_LIT:1> ,  <NUM_LIT:10> _ <NUM_LIT> )  <EOL>          val count = source.asFlow().count()  <EOL>          assertEquals( <NUM_LIT:10> _ <NUM_LIT> , count)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testProduce() = runTest {  <EOL>          val source = Observable.range( <NUM_LIT:0> ,  <NUM_LIT:10> )  <EOL>          val flow = source.asFlow()  <EOL>          check(( <NUM_LIT:0> .. <NUM_LIT> ).toList(), flow.produceIn(this))  <EOL>          check(( <NUM_LIT:0> .. <NUM_LIT> ).toList(), flow.buffer(Channel.UNLIMITED).produceIn(this))  <EOL>          check(( <NUM_LIT:0> .. <NUM_LIT> ).toList(), flow.buffer( <NUM_LIT:2> ).produceIn(this))  <EOL>          check(( <NUM_LIT:0> .. <NUM_LIT> ).toList(), flow.buffer( <NUM_LIT:0> ).produceIn(this))  <EOL>          check(listOf( <NUM_LIT:0> ,  <NUM_LIT> ), flow.conflate().produceIn(this))  <EOL>      }  <EOL>   <EOL>      private suspend fun check(expected: List<Int>, channel: ReceiveChannel<Int>) {  <EOL>          val result = ArrayList<Int>( <NUM_LIT:10> )  <EOL>          channel.consumeEach { result.add(it) }  <EOL>          assertEquals(expected, result) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.*  <EOL>  import io.reactivex.disposables.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableCollectTest: TestBase() {  <EOL>   <EOL>      /** Tests the behavior of [collect] when the publisher raises an error. */  <EOL>      @Test  <EOL>      fun testObservableCollectThrowingObservable() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          var sum =  <NUM_LIT:0>  <EOL>          try {  <EOL>              rxObservable {  <EOL>                  for (i in  <NUM_LIT:0> .. <NUM_LIT:100> ) {  <EOL>                      send(i)  <EOL>                  }  <EOL>                  throw TestException()  <EOL>              }.collect {  <EOL>                  sum += it  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              assertTrue(sum >  <NUM_LIT:0> )  <EOL>              finish( <NUM_LIT:2> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /** Tests the behavior of [collect] when the action throws. */  <EOL>      @Test  <EOL>      fun testObservableCollectThrowingAction() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          var sum =  <NUM_LIT:0>  <EOL>          val expectedSum =  <NUM_LIT>  <EOL>          try {  <EOL>              var disposed = false  <EOL>              ObservableSource<Int> { observer ->  <EOL>                  launch(Dispatchers.Default) {  <EOL>                      observer.onSubscribe(object : Disposable {  <EOL>                          override fun dispose() {  <EOL>                              disposed = true  <EOL>                              expect(expectedSum +  <NUM_LIT:2> )  <EOL>                          }  <EOL>   <EOL>                          override fun isDisposed(): Boolean = disposed  <EOL>                      })  <EOL>                      while (!disposed) {  <EOL>                          observer.onNext( <NUM_LIT:1> )  <EOL>                      }  <EOL>                  }  <EOL>              }.collect {  <EOL>                  expect(sum +  <NUM_LIT:2> )  <EOL>                  sum += it  <EOL>                  if (sum == expectedSum) {  <EOL>                      throw TestException()  <EOL>                  }  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              assertEquals(expectedSum, sum)  <EOL>              finish(expectedSum +  <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import java.util.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  class ObservableCompletionStressTest : TestBase() {  <EOL>      private val N_REPEATS =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>   <EOL>      private fun range(context: CoroutineContext, start: Int, count: Int) = rxObservable(context) {  <EOL>          for (x in start until start + count) send(x)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testCompletion() {  <EOL>          val rnd = Random()  <EOL>          repeat(N_REPEATS) {  <EOL>              val count = rnd.nextInt( <NUM_LIT> )  <EOL>              runBlocking {  <EOL>                  withTimeout( <NUM_LIT> ) {  <EOL>                      var received =  <NUM_LIT:0>  <EOL>                      range(Dispatchers.Default,  <NUM_LIT:1> , count).collect { x ->  <EOL>                          received++  <EOL>                          if (x != received) error( <STR_LIT> )  <EOL>                      }  <EOL>                      if (received != count) error( <STR_LIT> )  <EOL>                  }  <EOL>              }  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.exceptions.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableExceptionHandlingTest : TestBase() {  <EOL>   <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      private inline fun <reified T : Throwable> handler(expect: Int) = { t: Throwable ->  <EOL>          assertTrue(t is UndeliverableException && t.cause is T,  <STR_LIT> )  <EOL>          expect(expect)  <EOL>      }  <EOL>   <EOL>      private fun cehUnreached() = CoroutineExceptionHandler { _, _ -> expectUnreached() }  <EOL>   <EOL>      @Test  <EOL>      fun testException() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable<Int>(Dispatchers.Unconfined + cehUnreached()) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw TestException()  <EOL>          }.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expect( <NUM_LIT:2> ) // Reported to onError  <EOL>          })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalException() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable<Int>(Dispatchers.Unconfined + cehUnreached()) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw LinkageError()  <EOL>          }.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expect( <NUM_LIT:2> )  <EOL>          })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable<Int>(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw TestException()  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expectUnreached()  <EOL>              }, {  <EOL>                  expect( <NUM_LIT:2> ) // Reported to onError  <EOL>              })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable<Int>(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw LinkageError()  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expectUnreached()  <EOL>              }, {  <EOL>                  expect( <NUM_LIT:2> ) // Fatal exceptions are not treated in a special manner  <EOL>              })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>( <NUM_LIT> )) {  <EOL>          val latch = CountDownLatch( <NUM_LIT:1> )  <EOL>          rxObservable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              val result = trySend(Unit)  <EOL>              val exception = result.exceptionOrNull()  <EOL>              assertIs<UndeliverableException>(exception)  <EOL>              assertIs<LinkageError>(exception.cause)  <EOL>              assertTrue(isClosedForSend)  <EOL>              expect( <NUM_LIT> )  <EOL>              latch.countDown()  <EOL>          }.subscribe({  <EOL>              expect( <NUM_LIT:2> )  <EOL>              throw LinkageError()  <EOL>          }, { expectUnreached() }) // Unreached because RxJava bubbles up fatal exceptions, causing `onNext` to throw.  <EOL>          latch.await()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.subscribe({  <EOL>              expect( <NUM_LIT:2> )  <EOL>              throw TestException()  <EOL>          }, { expect( <NUM_LIT> ) })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsynchronousExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  throw RuntimeException()  <EOL>              }, { expect( <NUM_LIT> ) })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsynchronousFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>( <NUM_LIT> )) {  <EOL>          rxObservable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  throw LinkageError()  <EOL>              }, { expectUnreached() }) // Unreached because RxJava bubbles up fatal exceptions, causing `onNext` to throw.  <EOL>          finish( <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.selects.*  <EOL>  import org.junit.Test  <EOL>  import java.io.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  /**  <EOL>   * Test emitting multiple values with [rxObservable].  <EOL>   */  <EOL>  class ObservableMultiTest : TestBase() {  <EOL>      @Test  <EOL>      fun testNumbers() {  <EOL>          val n =  <NUM_LIT:100>  * stressTestMultiplier  <EOL>          val observable = rxObservable {  <EOL>              repeat(n) { send(it) }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list)  <EOL>          }  <EOL>      }  <EOL>   <EOL>   <EOL>      @Test  <EOL>      fun testConcurrentStress() {  <EOL>          val n =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>          val observable = rxObservable {  <EOL>              newCoroutineContext(coroutineContext)  <EOL>              // concurrent emitters (many coroutines)  <EOL>              val jobs = List(n) {  <EOL>                  // launch  <EOL>                  launch {  <EOL>                      val i = it  <EOL>                      send(i)  <EOL>                  }  <EOL>              }  <EOL>              jobs.forEach { it.join() }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(n, list.size)  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list.sorted())  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConcurrentStressOnSend() {  <EOL>          val n =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>          val observable = rxObservable<Int> {  <EOL>              newCoroutineContext(coroutineContext)  <EOL>              // concurrent emitters (many coroutines)  <EOL>              val jobs = List(n) {  <EOL>                  // launch  <EOL>                  launch(Dispatchers.Default) {  <EOL>                      val i = it  <EOL>                      select<Unit> {  <EOL>                          onSend(i) {}  <EOL>                      }  <EOL>                  }  <EOL>              }  <EOL>              jobs.forEach { it.join() }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(n, list.size)  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list.sorted())  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testIteratorResendUnconfined() {  <EOL>          val n =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>          val observable = rxObservable(Dispatchers.Unconfined) {  <EOL>              Observable.range( <NUM_LIT:0> , n).collect { send(it) }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testIteratorResendPool() {  <EOL>          val n =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>          val observable = rxObservable {  <EOL>              Observable.range( <NUM_LIT:0> , n).collect { send(it) }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSendAndCrash() {  <EOL>          val observable = rxObservable {  <EOL>              send( <STR_LIT> )  <EOL>              throw IOException( <STR_LIT> )  <EOL>          }  <EOL>          val single = rxSingle {  <EOL>              var result =  <STR_LIT>  <EOL>              try {  <EOL>                  observable.collect { result += it }  <EOL>              } catch(e: IOException) {  <EOL>                  result += e.message  <EOL>              }  <EOL>              result  <EOL>          }  <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.*  <EOL>  import io.reactivex.disposables.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.CancellationException  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableSingleTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleNoWait() {  <EOL>          val observable = rxObservable {  <EOL>              send( <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleAwait() = runBlocking {  <EOL>          assertEquals( <STR_LIT> , Observable.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleEmitAndAwait() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleWithDelay() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.timer( <NUM_LIT> , TimeUnit.MILLISECONDS).map {  <STR_LIT>  }.awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleException() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkErroneous(observable) {  <EOL>              assertIs<IllegalArgumentException>(it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirst() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirst() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrDefault() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.empty<String>().awaitFirstOrDefault( <STR_LIT> ) +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrDefaultWithValues() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirstOrDefault( <STR_LIT> ) +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrNull() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.empty<String>().awaitFirstOrNull() ?:  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrNullWithValues() {  <EOL>          val observable = rxObservable {  <EOL>              send((Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirstOrNull() ?:  <STR_LIT> ) +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrElse() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.empty<String>().awaitFirstOrElse {  <STR_LIT>  } +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrElseWithValues() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirstOrElse {  <STR_LIT>  } +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitLast() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitLast() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /** Tests that calls to [awaitFirst] (and, thus, the other methods) throw [CancellationException] and dispose of  <EOL>       * the subscription when their [Job] is cancelled. */  <EOL>      @Test  <EOL>      fun testAwaitCancellation() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = ObservableSource<Int> { s ->  <EOL>              s.onSubscribe(object: Disposable {  <EOL>                  override fun dispose() { expect( <NUM_LIT> ) }  <EOL>                  override fun isDisposed(): Boolean { expectUnreached(); return false }  <EOL>              })  <EOL>          }  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  observable.awaitFirst()  <EOL>              } catch (e: CancellationException) {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  throw e  <EOL>              }  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          job.cancelAndJoin()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromObservable() {  <EOL>          val observable = rxObservable {  <EOL>              try {  <EOL>                  send(Observable.error<String>(RuntimeException( <STR_LIT> )).awaitFirst())  <EOL>              } catch (e: RuntimeException) {  <EOL>                  send(Observable.just(e.message!!).awaitLast() +  <STR_LIT> )  <EOL>              }  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromCoroutine() {  <EOL>          val observable = rxObservable<String> {  <EOL>              throw IllegalStateException(Observable.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkErroneous(observable) {  <EOL>              assertIs<IllegalStateException>(it)  <EOL>              assertEquals( <STR_LIT> , it.message)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testObservableIteration() {  <EOL>          val observable = rxObservable {  <EOL>              var result =  <STR_LIT>  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).collect { result += it }  <EOL>              send(result)  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testObservableIterationFailure() {  <EOL>          val observable = rxObservable {  <EOL>              try {  <EOL>                  Observable.error<String>(RuntimeException( <STR_LIT> )).collect { fail( <STR_LIT> ) }  <EOL>                  send( <STR_LIT> )  <EOL>              } catch (e: RuntimeException) {  <EOL>                  send(e.message!!)  <EOL>              }  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import org.junit.*  <EOL>  import java.util.concurrent.*  <EOL>   <EOL>  class ObservableSourceAsFlowStressTest : TestBase() {  <EOL>   <EOL>      private val iterations =  <NUM_LIT:100>  * stressTestMultiplierSqrt  <EOL>   <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsFlowCancellation() = runTest {  <EOL>          repeat(iterations) {  <EOL>              val latch = Channel<Unit>( <NUM_LIT:1> )  <EOL>              var i =  <NUM_LIT:0>  <EOL>              val observable = Observable.interval( <NUM_LIT:100> L, TimeUnit.MICROSECONDS)  <EOL>                  .doOnNext {  if (++i >  <NUM_LIT:100> ) latch.trySend(Unit) }  <EOL>              val job = observable.asFlow().launchIn(CoroutineScope(Dispatchers.Default))  <EOL>              latch.receive()  <EOL>              job.cancelAndJoin()  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.selects.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.onSuccess  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableSubscriptionSelectTest : TestBase() {  <EOL>      @Test  <EOL>      fun testSelect() = runTest {  <EOL>          // source with n ints  <EOL>          val n =  <NUM_LIT>  * stressTestMultiplier  <EOL>          val source = rxObservable { repeat(n) { send(it) } }  <EOL>          var a =  <NUM_LIT:0>  <EOL>          var b =  <NUM_LIT:0>  <EOL>          // open two subs  <EOL>          val channelA = source.toChannel()  <EOL>          val channelB = source.toChannel()  <EOL>          loop@ while (true) {  <EOL>              val done: Int = select {  <EOL>                  channelA.onReceiveCatching { result ->  <EOL>                      result.onSuccess { assertEquals(a++, it) }  <EOL>                      if (result.isSuccess)  <NUM_LIT:1>  else  <NUM_LIT:0>  <EOL>                  }  <EOL>                  channelB.onReceiveCatching { result ->  <EOL>                      result.onSuccess { assertEquals(b++, it) }  <EOL>                      if (result.isSuccess)  <NUM_LIT:2>  else  <NUM_LIT:0>  <EOL>                  }  <EOL>              }  <EOL>              when (done) {  <EOL>                   <NUM_LIT:0>  -> break@loop  <EOL>                   <NUM_LIT:1>  -> {  <EOL>                      val r = channelB.receiveCatching().getOrNull()  <EOL>                      if (r != null) assertEquals(b++, r)  <EOL>                  }  <EOL>                   <NUM_LIT:2>  -> {  <EOL>                      val r = channelA.receiveCatching().getOrNull()  <EOL>                      if (r != null) assertEquals(a++, r)  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>          channelA.cancel()  <EOL>          channelB.cancel()  <EOL>          // should receive one of them fully  <EOL>          assertTrue(a == n || b == n) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.*  <EOL>  import io.reactivex.plugins.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.CancellationException  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicSuccess() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = rxObservable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              send( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          observable.subscribe { value ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertEquals( <STR_LIT> , value)  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicFailure() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = rxObservable<String>(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          observable.subscribe({  <EOL>              expectUnreached()  <EOL>          }, { error ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertIs<RuntimeException>(error)  <EOL>              assertEquals( <STR_LIT> , error.message)  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicUnsubscribe() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = rxObservable<String>(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // back to main, will get cancelled  <EOL>              expectUnreached()  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          val sub = observable.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expectUnreached()  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          expect( <NUM_LIT> )  <EOL>          sub.dispose() // will cancel coroutine  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testNotifyOnceOnCancellation() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable =  <EOL>              rxObservable(currentDispatcher()) {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  send( <STR_LIT> )  <EOL>                  try {  <EOL>                      delay(Long.MAX_VALUE)  <EOL>                  } catch (e: CancellationException) {  <EOL>                      expect( <NUM_LIT> )  <EOL>                  }  <EOL>              }  <EOL>              .doOnNext {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertEquals( <STR_LIT> , it)  <EOL>              }  <EOL>              .doOnDispose {  <EOL>                  expect( <NUM_LIT:10> ) // notified once!  <EOL>              }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              expect( <NUM_LIT> )  <EOL>              observable.collect {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertEquals( <STR_LIT> , it)  <EOL>              }  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to observable code  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to consuming coroutines  <EOL>          expect( <NUM_LIT> )  <EOL>          job.cancel()  <EOL>          job.join()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFailingConsumer() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val pub = rxObservable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT:2> )  <EOL>              send( <STR_LIT> )  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } catch (e: CancellationException) {  <EOL>                  finish( <NUM_LIT> )  <EOL>              }  <EOL>          }  <EOL>          try {  <EOL>              pub.collect {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  throw TestException()  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionAfterCancellation() {  <EOL>          // Test that no exceptions were reported to the global EH (it will fail the test if so)  <EOL>          val handler = { e: Throwable ->  <EOL>              assertFalse(e is CancellationException)  <EOL>          }  <EOL>          withExceptionHandler(handler) {  <EOL>              RxJavaPlugins.setErrorHandler {  <EOL>                  require(it !is CancellationException)  <EOL>              }  <EOL>              Observable  <EOL>                  .interval( <NUM_LIT:1> , TimeUnit.MILLISECONDS)  <EOL>                  .take( <NUM_LIT> )  <EOL>                  .switchMapSingle {  <EOL>                      rxSingle {  <EOL>                          timeBomb().await()  <EOL>                      }  <EOL>                  }  <EOL>                  .blockingSubscribe({}, {})  <EOL>          }  <EOL>      }  <EOL>  ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import java.util.concurrent.*  <EOL>   <EOL>  class SchedulerStressTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test that we don't get an OOM if we schedule many jobs at once.  <EOL>       * It's expected that if you don't dispose you'd see an OOM error.  <EOL>       */  <EOL>      @Test  <EOL>      fun testSchedulerDisposed(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableDisposed(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerDisposed(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          testRunnableDisposed(worker::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableDisposed(block: RxSchedulerBlockNoDelay) {  <EOL>          val n =  <NUM_LIT>  * stressTestMultiplier  <EOL>          repeat(n) {  <EOL>              val a = ByteArray( <NUM_LIT> ) // <NUM_LIT:1> MB  <EOL>              val disposable = block(Runnable {  <EOL>                  keepMe(a)  <EOL>                  expectUnreached()  <EOL>              })  <EOL>              disposable.dispose()  <EOL>              yield() // allow the scheduled task to observe that it was disposed  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test function that holds a reference. Used for testing OOM situations  <EOL>       */  <EOL>      private fun keepMe(a: ByteArray) {  <EOL>          Thread.sleep(a.size / (a.size +  <NUM_LIT:1> ) +  <NUM_LIT:10> L)  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test that we don't get an OOM if we schedule many delayed jobs at once. It's expected that if you don't dispose that you'd  <EOL>       * see a OOM error.  <EOL>       */  <EOL>      @Test  <EOL>      fun testSchedulerDisposedDuringDelay(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableDisposedDuringDelay(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerDisposedDuringDelay(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          testRunnableDisposedDuringDelay(worker::schedule)  <EOL>      }  <EOL>   <EOL>      private fun testRunnableDisposedDuringDelay(block: RxSchedulerBlockWithDelay) {  <EOL>          val n =  <NUM_LIT>  * stressTestMultiplier  <EOL>          repeat(n) {  <EOL>              val a = ByteArray( <NUM_LIT> ) // <NUM_LIT:1> MB  <EOL>              val delayMillis: Long =  <NUM_LIT:10>  <EOL>              val disposable = block(Runnable {  <EOL>                  keepMe(a)  <EOL>                  expectUnreached()  <EOL>              }, delayMillis, TimeUnit.MILLISECONDS)  <EOL>              disposable.dispose() ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.*  <EOL>  import io.reactivex.disposables.*  <EOL>  import io.reactivex.plugins.*  <EOL>  import io.reactivex.schedulers.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.sync.*  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.lang.Runnable  <EOL>  import java.util.concurrent.*  <EOL>  import java.util.concurrent.atomic.AtomicReference  <EOL>  import kotlin.coroutines.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class SchedulerTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testIoScheduler(): Unit = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val mainThread = Thread.currentThread()  <EOL>          withContext(Schedulers.io().asCoroutineDispatcher()) {  <EOL>              val t <NUM_LIT:1>  = Thread.currentThread()  <EOL>              assertNotSame(t <NUM_LIT:1> , mainThread)  <EOL>              expect( <NUM_LIT:2> )  <EOL>              delay( <NUM_LIT:100> )  <EOL>              val t <NUM_LIT:2>  = Thread.currentThread()  <EOL>              assertNotSame(t <NUM_LIT:2> , mainThread)  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests [toString] implementations of [CoroutineDispatcher.asScheduler] and its [Scheduler.Worker]. */  <EOL>      @Test  <EOL>      fun testSchedulerToString() {  <EOL>          val name =  <STR_LIT>  <EOL>          val scheduler = Dispatchers.Default.asScheduler()  <EOL>          assertContains(scheduler.toString(), name)  <EOL>          val worker = scheduler.createWorker()  <EOL>          val activeWorkerName = worker.toString()  <EOL>          assertContains(worker.toString(), name)  <EOL>          worker.dispose()  <EOL>          val disposedWorkerName = worker.toString()  <EOL>          assertNotEquals(activeWorkerName, disposedWorkerName)  <EOL>      }  <EOL>   <EOL>      private fun runSchedulerTest(nThreads: Int =  <NUM_LIT:1> , action: (Scheduler) -> Unit) {  <EOL>          val future = CompletableFuture<Unit>()  <EOL>          try {  <EOL>              newFixedThreadPoolContext(nThreads,  <STR_LIT:test> ).use { dispatcher ->  <EOL>                  RxJavaPlugins.setErrorHandler {  <EOL>                      if (!future.completeExceptionally(it)) {  <EOL>                          handleUndeliverableException(it, dispatcher)  <EOL>                      }  <EOL>                  }  <EOL>                  action(dispatcher.asScheduler())  <EOL>              }  <EOL>          } finally {  <EOL>              RxJavaPlugins.setErrorHandler(null)  <EOL>          }  <EOL>          future.complete(Unit)  <EOL>          future.getNow(Unit) // rethrow any encountered errors  <EOL>      }  <EOL>   <EOL>      private fun ensureSeparateThread(schedule: (Runnable, Long, TimeUnit) -> Unit, scheduleNoDelay: (Runnable) -> Unit) {  <EOL>          val mainThread = Thread.currentThread()  <EOL>          val cdl <NUM_LIT:1>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          val cdl <NUM_LIT:2>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val thread = AtomicReference<Thread?>(null)  <EOL>          fun checkThread() {  <EOL>              val current = Thread.currentThread()  <EOL>              thread.getAndSet(current)?.let { assertEquals(it, current) }  <EOL>          }  <EOL>          schedule({  <EOL>              assertNotSame(mainThread, Thread.currentThread())  <EOL>              checkThread()  <EOL>              cdl <NUM_LIT:2> .countDown()  <EOL>          },  <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>          scheduleNoDelay {  <EOL>              expect( <NUM_LIT:2> )  <EOL>              checkThread()  <EOL>              assertNotSame(mainThread, Thread.currentThread())  <EOL>              cdl <NUM_LIT:1> .countDown()  <EOL>          }  <EOL>          cdl <NUM_LIT:1> .await()  <EOL>          cdl <NUM_LIT:2> .await()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Tests [Scheduler.scheduleDirect] for [CoroutineDispatcher.asScheduler] on a single-threaded dispatcher.  <EOL>       */  <EOL>      @Test  <EOL>      fun testSingleThreadedDispatcherDirect(): Unit = runSchedulerTest( <NUM_LIT:1> ) {  <EOL>          ensureSeparateThread(it::scheduleDirect, it::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Tests [Scheduler.Worker.schedule] for [CoroutineDispatcher.asScheduler] running its tasks on the correct thread.  <EOL>       */  <EOL>      @Test  <EOL>      fun testSingleThreadedWorker(): Unit = runSchedulerTest( <NUM_LIT:1> ) {  <EOL>          val worker = it.createWorker()  <EOL>          ensureSeparateThread(worker::schedule, worker::schedule)  <EOL>      }  <EOL>   <EOL>      private fun checkCancelling(schedule: (Runnable, Long, TimeUnit) -> Disposable) {  <EOL>          // cancel the task before it has a chance to run.  <EOL>          val handle <NUM_LIT:1>  = schedule({  <EOL>              throw IllegalStateException( <STR_LIT> )  <EOL>          },  <NUM_LIT:10> _ <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>          handle <NUM_LIT:1> .dispose()  <EOL>          // cancel the task after it started running.  <EOL>          val cdl <NUM_LIT:1>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          val cdl <NUM_LIT:2>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          val handle <NUM_LIT:2>  = schedule({  <EOL>              cdl <NUM_LIT:1> .countDown()  <EOL>              cdl <NUM_LIT:2> .await()  <EOL>              if (Thread.interrupted())  <EOL>                  throw IllegalStateException( <STR_LIT> )  <EOL>          },  <NUM_LIT:100> , TimeUnit.MILLISECONDS)  <EOL>          cdl <NUM_LIT:1> .await()  <EOL>          handle <NUM_LIT:2> .dispose()  <EOL>          cdl <NUM_LIT:2> .countDown()  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test cancelling [Scheduler.scheduleDirect] for [CoroutineDispatcher.asScheduler].  <EOL>       */  <EOL>      @Test  <EOL>      fun testCancellingDirect(): Unit = runSchedulerTest {  <EOL>          checkCancelling(it::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test cancelling [Scheduler.Worker.schedule] for [CoroutineDispatcher.asScheduler].  <EOL>       */  <EOL>      @Test  <EOL>      fun testCancellingWorker(): Unit = runSchedulerTest {  <EOL>          val worker = it.createWorker()  <EOL>          checkCancelling(worker::schedule)  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test shutting down [CoroutineDispatcher.asScheduler].  <EOL>       */  <EOL>      @Test  <EOL>      fun testShuttingDown() {  <EOL>          val n =  <NUM_LIT>  <EOL>          runSchedulerTest(nThreads = n) { scheduler ->  <EOL>              val cdl <NUM_LIT:1>  = CountDownLatch(n)  <EOL>              val cdl <NUM_LIT:2>  = CountDownLatch( <NUM_LIT:1> )  <EOL>              val cdl <NUM_LIT>  = CountDownLatch(n)  <EOL>              repeat(n) {  <EOL>                  scheduler.scheduleDirect {  <EOL>                      cdl <NUM_LIT:1> .countDown()  <EOL>                      try {  <EOL>                          cdl <NUM_LIT:2> .await()  <EOL>                      } catch (e: InterruptedException) {  <EOL>                          // this is the expected outcome  <EOL>                          cdl <NUM_LIT> .countDown()  <EOL>                      }  <EOL>                  }  <EOL>              }  <EOL>              cdl <NUM_LIT:1> .await()  <EOL>              scheduler.shutdown()  <EOL>              if (!cdl <NUM_LIT> .await( <NUM_LIT:1> , TimeUnit.SECONDS)) {  <EOL>                  cdl <NUM_LIT:2> .countDown()  <EOL>                  error( <STR_LIT> )  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /** Tests that there are no uncaught exceptions if [Disposable.dispose] on a worker happens when tasks are present. */  <EOL>      @Test  <EOL>      fun testDisposingWorker() = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          yield() // so that the worker starts waiting on the channel  <EOL>          assertFalse(worker.isDisposed)  <EOL>          worker.dispose()  <EOL>          assertTrue(worker.isDisposed)  <EOL>      }  <EOL>   <EOL>      /** Tests trying to use a [Scheduler.Worker]/[Scheduler] after [Scheduler.Worker.dispose]/[Scheduler.shutdown]. */  <EOL>      @Test  <EOL>      fun testSchedulingAfterDisposing() = runSchedulerTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val worker = it.createWorker()  <EOL>          // use CDL to ensure that the worker has properly initialized  <EOL>          val cdl <NUM_LIT:1>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          setScheduler( <NUM_LIT:2> ,  <NUM_LIT> )  <EOL>          val disposable <NUM_LIT:1>  = worker.schedule {  <EOL>              cdl <NUM_LIT:1> .countDown()  <EOL>          }  <EOL>          cdl <NUM_LIT:1> .await()  <EOL>          expect( <NUM_LIT> )  <EOL>          assertFalse(disposable <NUM_LIT:1> .isDisposed)  <EOL>          setScheduler( <NUM_LIT> , - <NUM_LIT:1> )  <EOL>          // check that the worker automatically disposes of the tasks after being disposed  <EOL>          assertFalse(worker.isDisposed)  <EOL>          worker.dispose()  <EOL>          assertTrue(worker.isDisposed)  <EOL>          expect( <NUM_LIT> )  <EOL>          val disposable <NUM_LIT:2>  = worker.schedule {  <EOL>              expectUnreached()  <EOL>          }  <EOL>          assertTrue(disposable <NUM_LIT:2> .isDisposed)  <EOL>          setScheduler( <NUM_LIT> ,  <NUM_LIT> )  <EOL>          // ensure that the scheduler still works  <EOL>          val cdl <NUM_LIT:2>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          val disposable <NUM_LIT>  = it.scheduleDirect {  <EOL>              cdl <NUM_LIT:2> .countDown()  <EOL>          }  <EOL>          cdl <NUM_LIT:2> .await()  <EOL>          expect( <NUM_LIT> )  <EOL>          assertFalse(disposable <NUM_LIT> .isDisposed)  <EOL>          // check that the scheduler automatically disposes of the tasks after being shut down  <EOL>          it.shutdown()  <EOL>          setScheduler( <NUM_LIT:10> , - <NUM_LIT:1> )  <EOL>          val disposable <NUM_LIT>  = it.scheduleDirect {  <EOL>              expectUnreached()  <EOL>          }  <EOL>          assertTrue(disposable <NUM_LIT> .isDisposed)  <EOL>          RxJavaPlugins.setScheduleHandler(null)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWithNoDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithNoDelay(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerWithNoDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithNoDelay(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableWithNoDelay(block: RxSchedulerBlockNoDelay) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              block(Runnable {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  it.resume(Unit)  <EOL>              })  <EOL>          }  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWithDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler::scheduleDirect,  <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerWithDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler.createWorker()::schedule,  <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWithZeroDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerWithZeroDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableWithDelay(block: RxSchedulerBlockWithDelay, delayMillis: Long =  <NUM_LIT:0> ) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              block({  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  it.resume(Unit)  <EOL>              }, delayMillis, TimeUnit.MILLISECONDS)  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsSchedulerWithNegativeDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler::scheduleDirect, - <NUM_LIT:1> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsSchedulerWorkerWithNegativeDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler.createWorker()::schedule, - <NUM_LIT:1> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerImmediateDispose(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableImmediateDispose(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerImmediateDispose(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableImmediateDispose(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private fun testRunnableImmediateDispose(block: RxSchedulerBlockNoDelay) {  <EOL>          val disposable = block {  <EOL>              expectUnreached()  <EOL>          }  <EOL>          disposable.dispose()  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConvertDispatcherToOriginalScheduler(): Unit = runTest {  <EOL>          val originalScheduler = Schedulers.io()  <EOL>          val dispatcher = originalScheduler.asCoroutineDispatcher()  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          assertSame(originalScheduler, scheduler)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConvertSchedulerToOriginalDispatcher(): Unit = runTest {  <EOL>          val originalDispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = originalDispatcher.asScheduler()  <EOL>          val dispatcher = scheduler.asCoroutineDispatcher()  <EOL>          assertSame(originalDispatcher, dispatcher)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerExpectRxPluginsCall(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableExpectRxPluginsCall(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerExpectRxPluginsCall(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableExpectRxPluginsCall(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableExpectRxPluginsCall(block: RxSchedulerBlockNoDelay) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          setScheduler( <NUM_LIT:2> ,  <NUM_LIT> )  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              block(Runnable {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  it.resume(Unit)  <EOL>              })  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          RxJavaPlugins.setScheduleHandler(null)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerExpectRxPluginsCallWithDelay(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableExpectRxPluginsCallDelay(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerExpectRxPluginsCallWithDelay(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          testRunnableExpectRxPluginsCallDelay(worker::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableExpectRxPluginsCallDelay(block: RxSchedulerBlockWithDelay) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          setScheduler( <NUM_LIT:2> ,  <NUM_LIT> )  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              block({  <EOL>                  expect( <NUM_LIT> )  <EOL>                  it.resume(Unit)  <EOL>              },  <NUM_LIT:10> , TimeUnit.MILLISECONDS)  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          RxJavaPlugins.setScheduleHandler(null)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      private fun setScheduler(expectedCountOnSchedule: Int, expectCountOnRun: Int) {  <EOL>          RxJavaPlugins.setScheduleHandler {  <EOL>              expect(expectedCountOnSchedule)  <EOL>              Runnable {  <EOL>                  expect(expectCountOnRun)  <EOL>                  it.run()  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Tests that [Scheduler.Worker] runs all work sequentially.  <EOL>       */  <EOL>      @Test  <EOL>      fun testWorkerSequentialOrdering() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val scheduler = Dispatchers.Default.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          val iterations =  <NUM_LIT:100>  <EOL>          for (i in  <NUM_LIT:0> ..iterations) {  <EOL>              worker.schedule {  <EOL>                  expect( <NUM_LIT:2>  + i)  <EOL>              }  <EOL>          }  <EOL>          suspendCoroutine<Unit> {  <EOL>              worker.schedule {  <EOL>                  it.resume(Unit)  <EOL>              }  <EOL>          }  <EOL>          finish((iterations +  <NUM_LIT:2> ) +  <NUM_LIT:1> )  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test that ensures that delays are actually respected (tasks scheduled sooner in the future run before tasks scheduled later,  <EOL>       * even when the later task is submitted before the earlier one)  <EOL>       */  <EOL>      @Test  <EOL>      fun testSchedulerRespectsDelays(): Unit = runTest {  <EOL>          val scheduler = Dispatchers.Default.asScheduler()  <EOL>          testRunnableRespectsDelays(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerRespectsDelays(): Unit = runTest {  <EOL>          val scheduler = Dispatchers.Default.asScheduler()  <EOL>          testRunnableRespectsDelays(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableRespectsDelays(block: RxSchedulerBlockWithDelay) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val semaphore = Semaphore( <NUM_LIT:2> ,  <NUM_LIT:2> )  <EOL>          block({  <EOL>              expect( <NUM_LIT> )  <EOL>              semaphore.release()  <EOL>          },  <NUM_LIT:100> , TimeUnit.MILLISECONDS)  <EOL>          block({  <EOL>              expect( <NUM_LIT:2> )  <EOL>              semaphore.release()  <EOL>          },  <NUM_LIT:1> , TimeUnit.MILLISECONDS)  <EOL>          semaphore.acquire()  <EOL>          semaphore.acquire()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Tests that cancelling a runnable in one worker doesn't affect work in another scheduler.  <EOL>       *  <EOL>       * This is part of expected behavior documented.  <EOL>       */  <EOL>      @Test  <EOL>      fun testMultipleWorkerCancellation(): Unit = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              val workerOne = scheduler.createWorker()  <EOL>              workerOne.schedule({  <EOL>                  expect( <NUM_LIT> )  <EOL>                  it.resume(Unit)  <EOL>              },  <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>              val workerTwo = scheduler.createWorker()  <EOL>              workerTwo.schedule({  <EOL>                  expectUnreached()  <EOL>              },  <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>              workerTwo.dispose()  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>  } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT:2>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.*  <EOL>  import io.reactivex.disposables.*  <EOL>  import io.reactivex.exceptions.*  <EOL>  import io.reactivex.functions.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.CancellationException  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class SingleTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicSuccess() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>               <STR_LIT>  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          single.subscribe { value ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertEquals( <STR_LIT> , value)  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicFailure() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          single.subscribe({  <EOL>              expectUnreached()  <EOL>          }, { error ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertIs<RuntimeException>(error)  <EOL>              assertEquals( <STR_LIT> , error.message)  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>   <EOL>      @Test  <EOL>      fun testBasicUnsubscribe() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // back to main, will get cancelled  <EOL>              expectUnreached()  <EOL>   <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          // nothing is called on a disposed rx <NUM_LIT:2>  single  <EOL>          val sub = single.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expectUnreached()  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          expect( <NUM_LIT> )  <EOL>          sub.dispose() // will cancel coroutine  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleNoWait() {  <EOL>          val single = rxSingle {  <EOL>               <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleAwait() = runBlocking {  <EOL>          assertEquals( <STR_LIT> , Single.just( <STR_LIT> ).await() +  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests that calls to [await] throw [CancellationException] and dispose of the subscription when their  <EOL>       * [Job] is cancelled. */  <EOL>      @Test  <EOL>      fun testSingleAwaitCancellation() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val single = SingleSource<Int> { s ->  <EOL>              s.onSubscribe(object: Disposable {  <EOL>                  override fun dispose() { expect( <NUM_LIT> ) }  <EOL>                  override fun isDisposed(): Boolean { expectUnreached(); return false }  <EOL>              })  <EOL>          }  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  single.await()  <EOL>              } catch (e: CancellationException) {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  throw e  <EOL>              }  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          job.cancelAndJoin()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleEmitAndAwait() {  <EOL>          val single = rxSingle {  <EOL>              Single.just( <STR_LIT> ).await() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleWithDelay() {  <EOL>          val single = rxSingle {  <EOL>              Observable.timer( <NUM_LIT> , TimeUnit.MILLISECONDS).map {  <STR_LIT>  }.awaitSingle() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleException() {  <EOL>          val single = rxSingle {  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitSingle() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkErroneous(single) {  <EOL>              assert(it is IllegalArgumentException)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirst() {  <EOL>          val single = rxSingle {  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirst() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitLast() {  <EOL>          val single = rxSingle {  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitLast() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromObservable() {  <EOL>          val single = rxSingle {  <EOL>              try {  <EOL>                  Observable.error<String>(RuntimeException( <STR_LIT> )).awaitFirst()  <EOL>              } catch (e: RuntimeException) {  <EOL>                  Observable.just(e.message!!).awaitLast() +  <STR_LIT>  <EOL>              }  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromCoroutine() {  <EOL>          val single = rxSingle<String> {  <EOL>              throw IllegalStateException(Observable.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkErroneous(single) {  <EOL>              assert(it is IllegalStateException)  <EOL>              assertEquals( <STR_LIT> , it.message)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSuppressedException() = runTest {  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              launch(start = CoroutineStart.ATOMIC) {  <EOL>                  throw TestException() // child coroutine fails  <EOL>              }  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } finally {  <EOL>                  throw TestException <NUM_LIT:2> () // but parent throws another exception while cleaning up  <EOL>              }  <EOL>          }  <EOL>          try {  <EOL>              single.await()  <EOL>              expectUnreached()  <EOL>          } catch (e: TestException) {  <EOL>              assertIs<TestException <NUM_LIT:2> >(e.suppressed[ <NUM_LIT:0> ])  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionInSubscribe() = runTest {  <EOL>          val handler = { e: Throwable ->  <EOL>              assertTrue(e is UndeliverableException && e.cause is LinkageError)  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>          withExceptionHandler(handler) {  <EOL>              rxSingle(Dispatchers.Unconfined) {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>                   <NUM_LIT>  <EOL>              }.subscribe(Consumer {  <EOL>                  throw LinkageError()  <EOL>              })  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionInSingle() = runTest {  <EOL>          rxSingle(Dispatchers.Unconfined) {  <EOL>              throw LinkageError()  <EOL>          }.subscribe { _, e -> assertIs<LinkageError>(e); expect( <NUM_LIT:1> ) }  <EOL>   <EOL>          finish( <NUM_LIT:2> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testUnhandledException() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          var disposable: Disposable? = null  <EOL>          val handler = { e: Throwable ->  <EOL>              assertTrue(e is UndeliverableException && e.cause is TestException)  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } finally {  <EOL>                  throw TestException() // would not be able to handle it since mono is disposed  <EOL>              }  <EOL>          }  <EOL>          withExceptionHandler(handler) {  <EOL>              single.subscribe(object : SingleObserver<Unit> {  <EOL>                  override fun onSubscribe(d: Disposable) {  <EOL>                      expect( <NUM_LIT:2> )  <EOL>                      disposable = d  <EOL>                  }  <EOL>   <EOL>                  override fun onSuccess(t: Unit) {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>   <EOL>                  override fun onError(t: Throwable) {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>              })  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // run coroutine  <EOL>              finish( <NUM_LIT> )  <EOL>          } ", "gt": ""}
{"input": "<s> import org.jetbrains.dokka.gradle.DokkaTaskPartial  <EOL>  import java.net.*  <EOL>   <EOL>  dependencies {  <EOL>      api(project( <STR_LIT> ))  <EOL>      testImplementation( <STR_LIT> reactive_streams <STR_LIT> )  <EOL>      api( <STR_LIT> rxjava <NUM_LIT> <STR_LIT> )  <EOL>  }  <EOL>   <EOL>  tasks.withType(DokkaTaskPartial::class) {  <EOL>      dokkaSourceSets.configureEach {  <EOL>          externalDocumentationLink {  <EOL>              url = URL( <STR_LIT> )  <EOL>              packageListUrl = projectDir.toPath().resolve( <STR_LIT> ).toUri().toURL()  <EOL>          }  <EOL>      }  <EOL>  }  <EOL>   <EOL>  val testNG by tasks.registering(Test::class) {  <EOL>      useTestNG()  <EOL>      reports.html.outputLocation = file( <STR_LIT> )  <EOL>      include( <STR_LIT> )  <EOL>      // Skip testNG when tests are filtered with --tests, otherwise it simply fails  <EOL>      onlyIf {  <EOL>          filter.includePatterns.isEmpty()  <EOL>      }  <EOL>      doFirst {  <EOL>          // Classic gradle, nothing works without doFirst  <EOL>          println( <STR_LIT> )  <EOL>      }  <EOL>  }  <EOL>   <EOL>  val test by tasks.getting(Test::class) {  <EOL>      dependsOn(testNG) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.Disposable  <EOL>  import kotlinx.coroutines.CancellableContinuation  <EOL>  import kotlinx.coroutines.CancellationException  <EOL>  import kotlinx.coroutines.Job  <EOL>  import kotlinx.coroutines.suspendCancellableCoroutine  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  // ------------------------ CompletableSource ------------------------  <EOL>   <EOL>  /**  <EOL>   * Awaits for completion of this completable without blocking the thread.  <EOL>   * Returns `Unit`, or throws the corresponding exception if this completable produces an error.  <EOL>   *  <EOL>   * This suspending function is cancellable. If the [Job] of the invoking coroutine is cancelled while this  <EOL>   * suspending function is suspended, this function immediately resumes with [CancellationException] and disposes of its  <EOL>   * subscription.  <EOL>   */  <EOL>  public suspend fun CompletableSource.await(): Unit = suspendCancellableCoroutine { cont ->  <EOL>      subscribe(object : CompletableObserver {  <EOL>          override fun onSubscribe(d: Disposable) { cont.disposeOnCancellation(d) }  <EOL>          override fun onComplete() { cont.resume(Unit) }  <EOL>          override fun onError(e: Throwable) { cont.resumeWithException(e) }  <EOL>      })  <EOL>  }  <EOL>   <EOL>  // ------------------------ MaybeSource ------------------------  <EOL>   <EOL>  /**  <EOL>   * Awaits for completion of the [MaybeSource] without blocking the thread.  <EOL>   * Returns the resulting value, or `null` if no value is produced, or throws the corresponding exception if this  <EOL>   * [MaybeSource] produces an error.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this  <EOL>   * function immediately resumes with [CancellationException] and disposes of its subscription.  <EOL>   */  <EOL>  public suspend fun <T> MaybeSource<T & Any>.awaitSingleOrNull(): T? = suspendCancellableCoroutine { cont ->  <EOL>      subscribe(object : MaybeObserver<T & Any> {  <EOL>          override fun onSubscribe(d: Disposable) { cont.disposeOnCancellation(d) }  <EOL>          override fun onComplete() { cont.resume(null) }  <EOL>          override fun onSuccess(t: T & Any) { cont.resume(t) }  <EOL>          override fun onError(error: Throwable) { cont.resumeWithException(error) }  <EOL>      })  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Awaits for completion of the [MaybeSource] without blocking the thread.  <EOL>   * Returns the resulting value, or throws if either no value is produced or this [MaybeSource] produces an error.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this  <EOL>   * function immediately resumes with [CancellationException] and disposes of its subscription.  <EOL>   *  <EOL>   * @throws NoSuchElementException if no elements were produced by this [MaybeSource].  <EOL>   */  <EOL>  public suspend fun <T> MaybeSource<T & Any>.awaitSingle(): T = awaitSingleOrNull() ?: throw NoSuchElementException()  <EOL>   <EOL>  /**  <EOL>   * Awaits for completion of the maybe without blocking a thread.  <EOL>   * Returns the resulting value, null if no value was produced or throws the corresponding exception if this  <EOL>   * maybe had produced error.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function  <EOL>   * immediately resumes with [CancellationException].  <EOL>   *  <EOL>   * ### Deprecation  <EOL>   *  <EOL>   * Deprecated in favor of [awaitSingleOrNull] in order to reflect that `null` can be returned to denote the absence of  <EOL>   * a value, as opposed to throwing in such case.  <EOL>   *  <EOL>   * @suppress  <EOL>   */  <EOL>  @Deprecated(  <EOL>      message =  <STR_LIT> ,  <EOL>      level = DeprecationLevel.HIDDEN,  <EOL>      replaceWith = ReplaceWith( <STR_LIT> )  <EOL>  ) // Warning since  <NUM_LIT> , error in  <NUM_LIT> , hidden in  <NUM_LIT>  <EOL>  public suspend fun <T> MaybeSource<T & Any>.await(): T? = awaitSingleOrNull()  <EOL>   <EOL>  /**  <EOL>   * Awaits for completion of the maybe without blocking a thread.  <EOL>   * Returns the resulting value, [default] if no value was produced or throws the corresponding exception if this  <EOL>   * maybe had produced error.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function  <EOL>   * immediately resumes with [CancellationException].  <EOL>   *  <EOL>   * ### Deprecation  <EOL>   *  <EOL>   * Deprecated in favor of [awaitSingleOrNull] for naming consistency (see the deprecation of [MaybeSource.await] for  <EOL>   * details).  <EOL>   *  <EOL>   * @suppress  <EOL>   */  <EOL>  @Deprecated(  <EOL>      message =  <STR_LIT> ,  <EOL>      level = DeprecationLevel.HIDDEN,  <EOL>      replaceWith = ReplaceWith( <STR_LIT> )  <EOL>  ) // Warning since  <NUM_LIT> , error in  <NUM_LIT> , hidden in  <NUM_LIT>  <EOL>  public suspend fun <T> MaybeSource<T & Any>.awaitOrDefault(default: T): T = awaitSingleOrNull() ?: default  <EOL>   <EOL>  // ------------------------ SingleSource ------------------------  <EOL>   <EOL>  /**  <EOL>   * Awaits for completion of the single value response without blocking the thread.  <EOL>   * Returns the resulting value, or throws the corresponding exception if this response produces an error.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this  <EOL>   * function immediately disposes of its subscription and resumes with [CancellationException].  <EOL>   */  <EOL>  public suspend fun <T> SingleSource<T & Any>.await(): T = suspendCancellableCoroutine { cont ->  <EOL>      subscribe(object : SingleObserver<T & Any> {  <EOL>          override fun onSubscribe(d: Disposable) { cont.disposeOnCancellation(d) }  <EOL>          override fun onSuccess(t: T & Any) { cont.resume(t) }  <EOL>          override fun onError(error: Throwable) { cont.resumeWithException(error) }  <EOL>      })  <EOL>  }  <EOL>   <EOL>  // ------------------------ ObservableSource ------------------------  <EOL>   <EOL>  /**  <EOL>   * Awaits the first value from the given [Observable] without blocking the thread and returns the resulting value, or,  <EOL>   * if the observable has produced an error, throws the corresponding exception.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this  <EOL>   * function immediately disposes of its subscription and resumes with [CancellationException].  <EOL>   *  <EOL>   * @throws NoSuchElementException if the observable does not emit any value  <EOL>   */  <EOL>  @Suppress( <STR_LIT> )  <EOL>  public suspend fun <T> ObservableSource<T & Any>.awaitFirst(): T = awaitOne(Mode.FIRST) as T  <EOL>   <EOL>  /**  <EOL>   * Awaits the first value from the given [Observable], or returns the [default] value if none is emitted, without  <EOL>   * blocking the thread, and returns the resulting value, or, if this observable has produced an error, throws the  <EOL>   * corresponding exception.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this  <EOL>   * function immediately disposes of its subscription and resumes with [CancellationException].  <EOL>   */  <EOL>  @Suppress( <STR_LIT> )  <EOL>  public suspend fun <T> ObservableSource<T & Any>.awaitFirstOrDefault(default: T): T =  <EOL>      awaitOne(Mode.FIRST_OR_DEFAULT, default) as T  <EOL>   <EOL>  /**  <EOL>   * Awaits the first value from the given [Observable], or returns `null` if none is emitted, without blocking the  <EOL>   * thread, and returns the resulting value, or, if this observable has produced an error, throws the corresponding  <EOL>   * exception.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this  <EOL>   * function immediately disposes of its subscription and resumes with [CancellationException].  <EOL>   */  <EOL>  public suspend fun <T> ObservableSource<T & Any>.awaitFirstOrNull(): T? = awaitOne(Mode.FIRST_OR_DEFAULT)  <EOL>   <EOL>  /**  <EOL>   * Awaits the first value from the given [Observable], or calls [defaultValue] to get a value if none is emitted,  <EOL>   * without blocking the thread, and returns the resulting value, or, if this observable has produced an error, throws  <EOL>   * the corresponding exception.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this  <EOL>   * function immediately disposes of its subscription and resumes with [CancellationException].  <EOL>   */  <EOL>  public suspend fun <T> ObservableSource<T & Any>.awaitFirstOrElse(defaultValue: () -> T): T =  <EOL>      awaitOne(Mode.FIRST_OR_DEFAULT) ?: defaultValue()  <EOL>   <EOL>  /**  <EOL>   * Awaits the last value from the given [Observable] without blocking the thread and  <EOL>   * returns the resulting value, or, if this observable has produced an error, throws the corresponding exception.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this  <EOL>   * function immediately disposes of its subscription and resumes with [CancellationException].  <EOL>   *  <EOL>   * @throws NoSuchElementException if the observable does not emit any value  <EOL>   */  <EOL>  @Suppress( <STR_LIT> )  <EOL>  public suspend fun <T> ObservableSource<T & Any>.awaitLast(): T = awaitOne(Mode.LAST) as T  <EOL>   <EOL>  /**  <EOL>   * Awaits the single value from the given observable without blocking the thread and returns the resulting value, or,  <EOL>   * if this observable has produced an error, throws the corresponding exception.  <EOL>   *  <EOL>   * This suspending function is cancellable.  <EOL>   * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this  <EOL>   * function immediately disposes of its subscription and resumes with [CancellationException].  <EOL>   *  <EOL>   * @throws NoSuchElementException if the observable does not emit any value  <EOL>   * @throws IllegalArgumentException if the observable emits more than one value  <EOL>   */  <EOL>  @Suppress( <STR_LIT> )  <EOL>  public suspend fun <T> ObservableSource<T & Any>.awaitSingle(): T = awaitOne(Mode.SINGLE) as T  <EOL>   <EOL>  // ------------------------ private ------------------------  <EOL>   <EOL>  internal fun CancellableContinuation<*>.disposeOnCancellation(d: Disposable) =  <EOL>      invokeOnCancellation { d.dispose() }  <EOL>   <EOL>  private enum class Mode(@JvmField val s: String) {  <EOL>      FIRST( <STR_LIT> ),  <EOL>      FIRST_OR_DEFAULT( <STR_LIT> ),  <EOL>      LAST( <STR_LIT> ),  <EOL>      SINGLE( <STR_LIT> );  <EOL>      override fun toString(): String = s  <EOL>  }  <EOL>   <EOL>  private suspend fun <T> ObservableSource<T & Any>.awaitOne(  <EOL>      mode: Mode,  <EOL>      default: T? = null  <EOL>  ): T? = suspendCancellableCoroutine { cont ->  <EOL>      subscribe(object : Observer<T & Any> {  <EOL>          private lateinit var subscription: Disposable  <EOL>          private var value: T? = null  <EOL>          private var seenValue = false  <EOL>   <EOL>          override fun onSubscribe(sub: Disposable) {  <EOL>              subscription = sub  <EOL>              cont.invokeOnCancellation { sub.dispose() }  <EOL>          }  <EOL>   <EOL>          override fun onNext(t: T & Any) {  <EOL>              when (mode) {  <EOL>                  Mode.FIRST, Mode.FIRST_OR_DEFAULT -> {  <EOL>                      if (!seenValue) {  <EOL>                          seenValue = true  <EOL>                          cont.resume(t)  <EOL>                          subscription.dispose()  <EOL>                      }  <EOL>                  }  <EOL>                  Mode.LAST, Mode.SINGLE -> {  <EOL>                      if (mode == Mode.SINGLE && seenValue) {  <EOL>                          if (cont.isActive)  <EOL>                              cont.resumeWithException(IllegalArgumentException( <STR_LIT> ))  <EOL>                          subscription.dispose()  <EOL>                      } else {  <EOL>                          value = t  <EOL>                          seenValue = true  <EOL>                      }  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>   <EOL>          @Suppress( <STR_LIT> )  <EOL>          override fun onComplete() {  <EOL>              if (seenValue) {  <EOL>                  if (cont.isActive) cont.resume(value as T)  <EOL>                  return  <EOL>              }  <EOL>              when {  <EOL>                  mode == Mode.FIRST_OR_DEFAULT -> {  <EOL>                      cont.resume(default as T)  <EOL>                  }  <EOL>                  cont.isActive -> {  <EOL>                      cont.resumeWithException(NoSuchElementException( <STR_LIT> ))  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>   <EOL>          override fun onError(e: Throwable) {  <EOL>              cont.resumeWithException(e)  <EOL>          }  <EOL>      }) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .functions.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .plugins.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  internal class RxCancellable(private val job: Job) : Cancellable {  <EOL>      override fun cancel() {  <EOL>          job.cancel()  <EOL>      }  <EOL>  }  <EOL>   <EOL>  internal fun handleUndeliverableException(cause: Throwable, context: CoroutineContext) {  <EOL>      if (cause is CancellationException) return // Async CE should be completely ignored  <EOL>      try {  <EOL>          RxJavaPlugins.onError(cause)  <EOL>      } catch (e: Throwable) {  <EOL>          cause.addSuppressed(e)  <EOL>          handleCoroutineException(context, cause) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import kotlinx.atomicfu.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>   <EOL>  /**  <EOL>   * Subscribes to this [MaybeSource] and returns a channel to receive elements emitted by it.  <EOL>   * The resulting channel shall be [cancelled][ReceiveChannel.cancel] to unsubscribe from this source.  <EOL>   *  <EOL>   * This API is internal in the favour of [Flow].  <EOL>   * [MaybeSource] doesn't have a corresponding [Flow] adapter, so it should be transformed to [Observable] first.  <EOL>   */  <EOL>  @PublishedApi  <EOL>  internal fun <T> MaybeSource<T & Any>.openSubscription(): ReceiveChannel<T> {  <EOL>      val channel = SubscriptionChannel<T>()  <EOL>      subscribe(channel)  <EOL>      return channel  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Subscribes to this [ObservableSource] and returns a channel to receive elements emitted by it.  <EOL>   * The resulting channel shall be [cancelled][ReceiveChannel.cancel] to unsubscribe from this source.  <EOL>   *  <EOL>   * This API is internal in the favour of [Flow].  <EOL>   * [ObservableSource] doesn't have a corresponding [Flow] adapter, so it should be transformed to [Observable] first.  <EOL>   */  <EOL>  @PublishedApi  <EOL>  internal fun <T> ObservableSource<T & Any>.openSubscription(): ReceiveChannel<T> {  <EOL>      val channel = SubscriptionChannel<T>()  <EOL>      subscribe(channel)  <EOL>      return channel  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Subscribes to this [MaybeSource] and performs the specified action for each received element.  <EOL>   *  <EOL>   * If [action] throws an exception at some point or if the [MaybeSource] raises an error, the exception is rethrown from  <EOL>   * [collect].  <EOL>   */  <EOL>  public suspend inline fun <T> MaybeSource<T & Any>.collect(action: (T) -> Unit): Unit =  <EOL>      openSubscription().consumeEach(action)  <EOL>   <EOL>  /**  <EOL>   * Subscribes to this [ObservableSource] and performs the specified action for each received element.  <EOL>   *  <EOL>   * If [action] throws an exception at some point, the subscription is cancelled, and the exception is rethrown from  <EOL>   * [collect]. Also, if the [ObservableSource] signals an error, that error is rethrown from [collect].  <EOL>   */  <EOL>  public suspend inline fun <T> ObservableSource<T & Any>.collect(action: (T) -> Unit): Unit = openSubscription().consumeEach(action)  <EOL>   <EOL>  @Suppress( <STR_LIT> ,  <STR_LIT> )  <EOL>  private class SubscriptionChannel<T> :  <EOL>      BufferedChannel<T>(capacity = Channel.UNLIMITED), Observer<T & Any>, MaybeObserver<T & Any>  <EOL>  {  <EOL>      private val _subscription = atomic<Disposable?>(null)  <EOL>   <EOL>      @Suppress( <STR_LIT> )  <EOL>      override fun onClosedIdempotent() {  <EOL>          _subscription.getAndSet(null)?.dispose() // dispose exactly once  <EOL>      }  <EOL>   <EOL>      // Observer overrider  <EOL>      override fun onSubscribe(sub: Disposable) {  <EOL>          _subscription.value = sub  <EOL>      }  <EOL>   <EOL>      override fun onSuccess(t: T & Any) {  <EOL>          trySend(t)  <EOL>          close(cause = null)  <EOL>      }  <EOL>   <EOL>      override fun onNext(t: T & Any) {  <EOL>          trySend(t) // Safe to ignore return value here, expectedly racing with cancellation  <EOL>      }  <EOL>   <EOL>      override fun onComplete() {  <EOL>          close(cause = null)  <EOL>      }  <EOL>   <EOL>      override fun onError(e: Throwable) {  <EOL>          close(cause = e) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  /**  <EOL>   * Creates cold [Completable] that runs a given [block] in a coroutine and emits its result.  <EOL>   * Every time the returned completable is subscribed, it starts a new coroutine.  <EOL>   * Unsubscribing cancels running coroutine.  <EOL>   * Coroutine context can be specified with [context] argument.  <EOL>   * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.  <EOL>   * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.  <EOL>   */  <EOL>  public fun rxCompletable(  <EOL>      context: CoroutineContext = EmptyCoroutineContext,  <EOL>      block: suspend CoroutineScope.() -> Unit  <EOL>  ): Completable {  <EOL>      require(context[Job] === null) {  <STR_LIT>  +  <EOL>               <STR_LIT>  }  <EOL>      return rxCompletableInternal(GlobalScope, context, block)  <EOL>  }  <EOL>   <EOL>  private fun rxCompletableInternal(  <EOL>      scope: CoroutineScope, // support for legacy rxCompletable in scope  <EOL>      context: CoroutineContext,  <EOL>      block: suspend CoroutineScope.() -> Unit  <EOL>  ): Completable = Completable.create { subscriber ->  <EOL>      val newContext = scope.newCoroutineContext(context)  <EOL>      val coroutine = RxCompletableCoroutine(newContext, subscriber)  <EOL>      subscriber.setCancellable(RxCancellable(coroutine))  <EOL>      coroutine.start(CoroutineStart.DEFAULT, coroutine, block)  <EOL>  }  <EOL>   <EOL>  private class RxCompletableCoroutine(  <EOL>      parentContext: CoroutineContext,  <EOL>      private val subscriber: CompletableEmitter  <EOL>  ) : AbstractCoroutine<Unit>(parentContext, false, true) {  <EOL>      override fun onCompleted(value: Unit) {  <EOL>          try {  <EOL>              subscriber.onComplete()  <EOL>          } catch (e: Throwable) {  <EOL>              handleUndeliverableException(e, context)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      override fun onCancelled(cause: Throwable, handled: Boolean) {  <EOL>          try {  <EOL>              if (subscriber.tryOnError(cause)) {  <EOL>                  return  <EOL>              }  <EOL>          } catch (e: Throwable) {  <EOL>              cause.addSuppressed(e)  <EOL>          }  <EOL>          handleUndeliverableException(cause, context) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import kotlinx.coroutines.reactive.*  <EOL>  import org.reactivestreams.*  <EOL>  import java.util.concurrent.atomic.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  /**  <EOL>   * Converts this job to the hot reactive completable that signals  <EOL>   * with [onCompleted][CompletableObserver.onComplete] when the corresponding job completes.  <EOL>   *  <EOL>   * Every subscriber gets the signal at the same time.  <EOL>   * Unsubscribing from the resulting completable **does not** affect the original job in any way.  <EOL>   *  <EOL>   * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change  <EOL>   *    in the future to account for the concept of structured concurrency.  <EOL>   *  <EOL>   * @param context -- the coroutine context from which the resulting completable is going to be signalled  <EOL>   */  <EOL>  public fun Job.asCompletable(context: CoroutineContext): Completable = rxCompletable(context) {  <EOL>      this@asCompletable.join()  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Converts this deferred value to the hot reactive maybe that signals  <EOL>   * [onComplete][MaybeEmitter.onComplete], [onSuccess][MaybeEmitter.onSuccess] or [onError][MaybeEmitter.onError].  <EOL>   *  <EOL>   * Every subscriber gets the same completion value.  <EOL>   * Unsubscribing from the resulting maybe **does not** affect the original deferred value in any way.  <EOL>   *  <EOL>   * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change  <EOL>   *    in the future to account for the concept of structured concurrency.  <EOL>   *  <EOL>   * @param context -- the coroutine context from which the resulting maybe is going to be signalled  <EOL>   */  <EOL>  public fun <T> Deferred<T?>.asMaybe(context: CoroutineContext): Maybe<T & Any> = rxMaybe(context) {  <EOL>      this@asMaybe.await()  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Converts this deferred value to the hot reactive single that signals either  <EOL>   * [onSuccess][SingleObserver.onSuccess] or [onError][SingleObserver.onError].  <EOL>   *  <EOL>   * Every subscriber gets the same completion value.  <EOL>   * Unsubscribing from the resulting single **does not** affect the original deferred value in any way.  <EOL>   *  <EOL>   * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change  <EOL>   *    in the future to account for the concept of structured concurrency.  <EOL>   *  <EOL>   * @param context -- the coroutine context from which the resulting single is going to be signalled  <EOL>   */  <EOL>  public fun <T : Any> Deferred<T>.asSingle(context: CoroutineContext): Single<T> = rxSingle(context) {  <EOL>      this@asSingle.await()  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Transforms given cold [ObservableSource] into cold [Flow].  <EOL>   *  <EOL>   * The resulting flow is _cold_, which means that [ObservableSource.subscribe] is called every time a terminal operator  <EOL>   * is applied to the resulting flow.  <EOL>   *  <EOL>   * A channel with the [default][Channel.BUFFERED] buffer size is used. Use the [buffer] operator on the  <EOL>   * resulting flow to specify a user-defined value and to control what happens when data is produced faster  <EOL>   * than consumed, i.e. to control the back-pressure behavior. Check [callbackFlow] for more details.  <EOL>   */  <EOL>  public fun <T: Any> ObservableSource<T>.asFlow(): Flow<T> = callbackFlow {  <EOL>      val disposableRef = AtomicReference<Disposable>()  <EOL>      val observer = object : Observer<T> {  <EOL>          override fun onComplete() { close() }  <EOL>          override fun onSubscribe(d: Disposable) { if (!disposableRef.compareAndSet(null, d)) d.dispose() }  <EOL>          override fun onNext(t: T) {  <EOL>              /*  <EOL>               * Channel was closed by the downstream, so the exception (if any)  <EOL>               * also was handled by the same downstream  <EOL>               */  <EOL>              try {  <EOL>                  trySendBlocking(t)  <EOL>              } catch (e: InterruptedException) {  <EOL>                  // RxJava interrupts the source  <EOL>              }  <EOL>          }  <EOL>          override fun onError(e: Throwable) { close(e) }  <EOL>      }  <EOL>   <EOL>      subscribe(observer)  <EOL>      awaitClose { disposableRef.getAndSet(Disposable.disposed())?.dispose() }  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Converts the given flow to a cold observable.  <EOL>   * The original flow is cancelled when the observable subscriber is disposed.  <EOL>   *  <EOL>   * An optional [context] can be specified to control the execution context of calls to [Observer] methods.  <EOL>   * You can set a [CoroutineDispatcher] to confine them to a specific thread and/or various [ThreadContextElement] to  <EOL>   * inject additional context into the caller thread. By default, the [Unconfined][Dispatchers.Unconfined] dispatcher  <EOL>   * is used, so calls are performed from an arbitrary thread.  <EOL>   */  <EOL>  public fun <T: Any> Flow<T>.asObservable(context: CoroutineContext = EmptyCoroutineContext) : Observable<T> = Observable.create { emitter ->  <EOL>      /*  <EOL>       * ATOMIC is used here to provide stable behaviour of subscribe+dispose pair even if  <EOL>       * asObservable is already invoked from unconfined  <EOL>       */  <EOL>      val job = GlobalScope.launch(Dispatchers.Unconfined + context, start = CoroutineStart.ATOMIC) {  <EOL>          try {  <EOL>              collect { value -> emitter.onNext(value) }  <EOL>              emitter.onComplete()  <EOL>          } catch (e: Throwable) {  <EOL>              // 'create' provides safe emitter, so we can unconditionally call on* here if exception occurs in `onComplete`  <EOL>              if (e !is CancellationException) {  <EOL>                  if (!emitter.tryOnError(e)) {  <EOL>                      handleUndeliverableException(e, coroutineContext)  <EOL>                  }  <EOL>              } else {  <EOL>                  emitter.onComplete()  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>      emitter.setCancellable(RxCancellable(job))  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Converts the given flow to a cold flowable.  <EOL>   * The original flow is cancelled when the flowable subscriber is disposed.  <EOL>   *  <EOL>   * An optional [context] can be specified to control the execution context of calls to [Subscriber] methods.  <EOL>   * You can set a [CoroutineDispatcher] to confine them to a specific thread and/or various [ThreadContextElement] to  <EOL>   * inject additional context into the caller thread. By default, the [Unconfined][Dispatchers.Unconfined] dispatcher  <EOL>   * is used, so calls are performed from an arbitrary thread.  <EOL>   */  <EOL>  public fun <T: Any> Flow<T>.asFlowable(context: CoroutineContext = EmptyCoroutineContext): Flowable<T> =  <EOL>      Flowable.fromPublisher(asPublisher(context))  <EOL>   <EOL>  /** @suppress */  <EOL>  @Suppress( <STR_LIT> ) // KT- <NUM_LIT>  <EOL>  @JvmOverloads // binary compatibility  <EOL>  @JvmName( <STR_LIT> )  <EOL>  @Deprecated(level = DeprecationLevel.HIDDEN, message =  <STR_LIT> ) // Since  <NUM_LIT> , was experimental prior to that  <EOL>  public fun <T: Any> Flow<T>._asFlowable(context: CoroutineContext = EmptyCoroutineContext): Flowable<T> =  <EOL>      asFlowable(context)  <EOL>   <EOL>  /** @suppress */  <EOL>  @Suppress( <STR_LIT> ) // KT- <NUM_LIT>  <EOL>  @JvmOverloads // binary compatibility  <EOL>  @JvmName( <STR_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.reactive.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  /**  <EOL>   * Creates cold [flowable][Flowable] that will run a given [block] in a coroutine.  <EOL>   * Every time the returned flowable is subscribed, it starts a new coroutine.  <EOL>   *  <EOL>   * Coroutine emits ([ObservableEmitter.onNext]) values with `send`, completes ([ObservableEmitter.onComplete])  <EOL>   * when the coroutine completes or channel is explicitly closed and emits error ([ObservableEmitter.onError])  <EOL>   * if coroutine throws an exception or closes channel with a cause.  <EOL>   * Unsubscribing cancels running coroutine.  <EOL>   *  <EOL>   * Invocations of `send` are suspended appropriately when subscribers apply back-pressure and to ensure that  <EOL>   * `onNext` is not invoked concurrently.  <EOL>   *  <EOL>   * Coroutine context can be specified with [context] argument.  <EOL>   * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.  <EOL>   * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.  <EOL>   *  <EOL>   * **Note: This is an experimental api.** Behaviour of publishers that work as children in a parent scope with respect  <EOL>   */  <EOL>  public fun <T: Any> rxFlowable(  <EOL>      context: CoroutineContext = EmptyCoroutineContext,  <EOL>      @BuilderInference block: suspend ProducerScope<T>.() -> Unit  <EOL>  ): Flowable<T> {  <EOL>      require(context[Job] === null) {  <STR_LIT>  +  <EOL>               <STR_LIT>  }  <EOL>      return Flowable.fromPublisher(publishInternal(GlobalScope, context, RX_HANDLER, block))  <EOL>  } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  /**  <EOL>   * Creates cold [maybe][Maybe] that will run a given [block] in a coroutine and emits its result.  <EOL>   * If [block] result is `null`, [onComplete][MaybeObserver.onComplete] is invoked without a value.  <EOL>   * Every time the returned observable is subscribed, it starts a new coroutine.  <EOL>   * Unsubscribing cancels running coroutine.  <EOL>   * Coroutine context can be specified with [context] argument.  <EOL>   * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.  <EOL>   * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.  <EOL>   */  <EOL>  public fun <T> rxMaybe(  <EOL>      context: CoroutineContext = EmptyCoroutineContext,  <EOL>      block: suspend CoroutineScope.() -> T?  <EOL>  ): Maybe<T & Any> {  <EOL>      require(context[Job] === null) {  <STR_LIT>  +  <EOL>               <STR_LIT>  }  <EOL>      return rxMaybeInternal(GlobalScope, context, block)  <EOL>  }  <EOL>   <EOL>  private fun <T> rxMaybeInternal(  <EOL>      scope: CoroutineScope, // support for legacy rxMaybe in scope  <EOL>      context: CoroutineContext,  <EOL>      block: suspend CoroutineScope.() -> T?  <EOL>  ): Maybe<T & Any> = Maybe.create { subscriber ->  <EOL>      val newContext = scope.newCoroutineContext(context)  <EOL>      val coroutine = RxMaybeCoroutine(newContext, subscriber)  <EOL>      subscriber.setCancellable(RxCancellable(coroutine))  <EOL>      coroutine.start(CoroutineStart.DEFAULT, coroutine, block)  <EOL>  }  <EOL>   <EOL>  private class RxMaybeCoroutine<T: Any>(  <EOL>      parentContext: CoroutineContext,  <EOL>      private val subscriber: MaybeEmitter<T>  <EOL>  ) : AbstractCoroutine<T?>(parentContext, false, true) {  <EOL>      override fun onCompleted(value: T?) {  <EOL>          try {  <EOL>              if (value == null) subscriber.onComplete() else subscriber.onSuccess(value)  <EOL>          } catch (e: Throwable) {  <EOL>              handleUndeliverableException(e, context)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      override fun onCancelled(cause: Throwable, handled: Boolean) {  <EOL>          try {  <EOL>              if (subscriber.tryOnError(cause)) {  <EOL>                  return  <EOL>              }  <EOL>          } catch (e: Throwable) {  <EOL>              cause.addSuppressed(e)  <EOL>          }  <EOL>          handleUndeliverableException(cause, context) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .exceptions.*  <EOL>  import kotlinx.atomicfu.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.selects.*  <EOL>  import kotlinx.coroutines.sync.*  <EOL>  import kotlin.coroutines.*  <EOL>  import kotlinx.coroutines.internal.*  <EOL>   <EOL>  /**  <EOL>   * Creates cold [observable][Observable] that will run a given [block] in a coroutine.  <EOL>   * Every time the returned observable is subscribed, it starts a new coroutine.  <EOL>   *  <EOL>   * Coroutine emits ([ObservableEmitter.onNext]) values with `send`, completes ([ObservableEmitter.onComplete])  <EOL>   * when the coroutine completes or channel is explicitly closed and emits error ([ObservableEmitter.onError])  <EOL>   * if coroutine throws an exception or closes channel with a cause.  <EOL>   * Unsubscribing cancels running coroutine.  <EOL>   *  <EOL>   * Invocations of `send` are suspended appropriately to ensure that `onNext` is not invoked concurrently.  <EOL>   * Note that Rx  <NUM_LIT:2> .x [Observable] **does not support backpressure**.  <EOL>   *  <EOL>   * Coroutine context can be specified with [context] argument.  <EOL>   * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.  <EOL>   * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.  <EOL>   */  <EOL>  public fun <T : Any> rxObservable(  <EOL>      context: CoroutineContext = EmptyCoroutineContext,  <EOL>      @BuilderInference block: suspend ProducerScope<T>.() -> Unit  <EOL>  ): Observable<T> {  <EOL>      require(context[Job] === null) {  <STR_LIT>  +  <EOL>               <STR_LIT>  }  <EOL>      return rxObservableInternal(GlobalScope, context, block)  <EOL>  }  <EOL>   <EOL>  private fun <T : Any> rxObservableInternal(  <EOL>      scope: CoroutineScope, // support for legacy rxObservable in scope  <EOL>      context: CoroutineContext,  <EOL>      block: suspend ProducerScope<T>.() -> Unit  <EOL>  ): Observable<T> = Observable.create { subscriber ->  <EOL>      val newContext = scope.newCoroutineContext(context)  <EOL>      val coroutine = RxObservableCoroutine(newContext, subscriber)  <EOL>      subscriber.setCancellable(RxCancellable(coroutine)) // do it first (before starting coroutine), to await unnecessary suspensions  <EOL>      coroutine.start(CoroutineStart.DEFAULT, coroutine, block)  <EOL>  }  <EOL>   <EOL>  private const val OPEN =  <NUM_LIT:0>         // open channel, still working  <EOL>  private const val CLOSED = - <NUM_LIT:1>      // closed, but have not signalled onCompleted/onError yet  <EOL>  private const val SIGNALLED = - <NUM_LIT:2>   // already signalled subscriber onCompleted/onError  <EOL>   <EOL>  private class RxObservableCoroutine<T : Any>(  <EOL>      parentContext: CoroutineContext,  <EOL>      private val subscriber: ObservableEmitter<T>  <EOL>  ) : AbstractCoroutine<Unit>(parentContext, false, true), ProducerScope<T> {  <EOL>      override val channel: SendChannel<T> get() = this  <EOL>   <EOL>      private val _signal = atomic(OPEN)  <EOL>   <EOL>      override val isClosedForSend: Boolean get() = !isActive  <EOL>      override fun close(cause: Throwable?): Boolean = cancelCoroutine(cause)  <EOL>      override fun invokeOnClose(handler: (Throwable?) -> Unit) =  <EOL>          throw UnsupportedOperationException( <STR_LIT> )  <EOL>   <EOL>      // Mutex is locked when either nRequested ==  <NUM_LIT:0>  or while subscriber.onXXX is being invoked  <EOL>      private val mutex: Mutex = Mutex()  <EOL>   <EOL>      @Suppress( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> ) // do not remove the INVISIBLE_REFERENCE suppression: required in K <NUM_LIT:2>  <EOL>      override val onSend: SelectClause <NUM_LIT:2> <T, SendChannel<T>> get() = SelectClause <NUM_LIT:2> Impl(  <EOL>          clauseObject = this,  <EOL>          regFunc = RxObservableCoroutine<*>::registerSelectForSend as RegistrationFunction,  <EOL>          processResFunc = RxObservableCoroutine<*>::processResultSelectSend as ProcessResultFunction  <EOL>      )  <EOL>   <EOL>      @Suppress( <STR_LIT> )  <EOL>      private fun registerSelectForSend(select: SelectInstance<*>, element: Any?) {  <EOL>          // Try to acquire the mutex and complete in the registration phase.  <EOL>          if (mutex.tryLock()) {  <EOL>              select.selectInRegistrationPhase(Unit)  <EOL>              return  <EOL>          }  <EOL>          // Start a new coroutine that waits for the mutex, invoking `trySelect(..)` after that.  <EOL>          // Please note that at the point of the `trySelect(..)` invocation the corresponding  <EOL>          // `select` can still be in the registration phase, making this `trySelect(..)` bound to fail.  <EOL>          // In this case, the `onSend` clause will be re-registered, which alongside with the mutex  <EOL>          // manipulation makes the resulting solution obstruction-free.  <EOL>          launch {  <EOL>              mutex.lock()  <EOL>              if (!select.trySelect(this@RxObservableCoroutine, Unit)) {  <EOL>                  mutex.unlock()  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Suppress( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      private fun processResultSelectSend(element: Any?, selectResult: Any?): Any? {  <EOL>          doLockedNext(element as T)?.let { throw it }  <EOL>          return this@RxObservableCoroutine  <EOL>      }  <EOL>   <EOL>      override fun trySend(element: T): ChannelResult<Unit> =  <EOL>          if (!mutex.tryLock()) {  <EOL>              ChannelResult.failure()  <EOL>          } else {  <EOL>              when (val throwable = doLockedNext(element)) {  <EOL>                  null -> ChannelResult.success(Unit)  <EOL>                  else -> ChannelResult.closed(throwable)  <EOL>              }  <EOL>          }  <EOL>   <EOL>      override suspend fun send(element: T) {  <EOL>          mutex.lock()  <EOL>          doLockedNext(element)?.let { throw it }  <EOL>      }  <EOL>   <EOL>      // assert: mutex.isLocked()  <EOL>      private fun doLockedNext(elem: T): Throwable? {  <EOL>          // check if already closed for send  <EOL>          if (!isActive) {  <EOL>              doLockedSignalCompleted(completionCause, completionCauseHandled)  <EOL>              return getCancellationException()  <EOL>          }  <EOL>          // notify subscriber  <EOL>          try {  <EOL>              subscriber.onNext(elem)  <EOL>          } catch (e: Throwable) {  <EOL>              val cause = UndeliverableException(e)  <EOL>              val causeDelivered = close(cause)  <EOL>              unlockAndCheckCompleted()  <EOL>              return if (causeDelivered) {  <EOL>                  // `cause` is the reason this channel is closed  <EOL>                  cause  <EOL>              } else {  <EOL>                  // Someone else closed the channel during `onNext`. We report `cause` as an undeliverable exception.  <EOL>                  handleUndeliverableException(cause, context)  <EOL>                  getCancellationException()  <EOL>              }  <EOL>          }  <EOL>          /*  <EOL>           * There is no sense to check for `isActive` before doing `unlock`, because cancellation/completion might  <EOL>           * happen after this check and before `unlock` (see signalCompleted that does not do anything  <EOL>           * if it fails to acquire the lock that we are still holding).  <EOL>           * We have to recheck `isCompleted` after `unlock` anyway.  <EOL>           */  <EOL>          unlockAndCheckCompleted()  <EOL>          return null  <EOL>      }  <EOL>   <EOL>      private fun unlockAndCheckCompleted() {  <EOL>          mutex.unlock()  <EOL>          // recheck isActive  <EOL>          if (!isActive && mutex.tryLock())  <EOL>              doLockedSignalCompleted(completionCause, completionCauseHandled)  <EOL>      }  <EOL>   <EOL>      // assert: mutex.isLocked()  <EOL>      private fun doLockedSignalCompleted(cause: Throwable?, handled: Boolean) {  <EOL>          // cancellation failures  <EOL>          try {  <EOL>              if (_signal.value == SIGNALLED)  <EOL>                  return  <EOL>              _signal.value = SIGNALLED // we'll signal onError/onCompleted (that the final state -- no CAS needed)  <EOL>              @Suppress( <STR_LIT> ,  <STR_LIT> ) // do not remove the INVISIBLE_REFERENCE suppression: required in K <NUM_LIT:2>  <EOL>              val unwrappedCause = cause?.let { unwrap(it) }  <EOL>              if (unwrappedCause == null) {  <EOL>                  try {  <EOL>                      subscriber.onComplete()  <EOL>                  } catch (e: Exception) {  <EOL>                      handleUndeliverableException(e, context)  <EOL>                  }  <EOL>              } else if (unwrappedCause is UndeliverableException && !handled) {  <EOL>                  /** Such exceptions are not reported to `onError`, as, according to the reactive specifications,  <EOL>                   * exceptions thrown from the Subscriber methods must be treated as if the Subscriber was already  <EOL>                   * cancelled. */  <EOL>                  handleUndeliverableException(cause, context)  <EOL>              } else if (unwrappedCause !== getCancellationException() || !subscriber.isDisposed) {  <EOL>                  try {  <EOL>                      /** If the subscriber is already in a terminal state, the error will be signalled to  <EOL>                       * `RxJavaPlugins.onError`. */  <EOL>                      subscriber.onError(cause)  <EOL>                  } catch (e: Exception) {  <EOL>                      cause.addSuppressed(e)  <EOL>                      handleUndeliverableException(cause, context)  <EOL>                  }  <EOL>              }  <EOL>          } finally {  <EOL>              mutex.unlock()  <EOL>          }  <EOL>      }  <EOL>   <EOL>      private fun signalCompleted(cause: Throwable?, handled: Boolean) {  <EOL>          if (!_signal.compareAndSet(OPEN, CLOSED)) return // abort, other thread invoked doLockedSignalCompleted  <EOL>          if (mutex.tryLock()) // if we can acquire the lock  <EOL>              doLockedSignalCompleted(cause, handled)  <EOL>      }  <EOL>   <EOL>      override fun onCompleted(value: Unit) {  <EOL>          signalCompleted(null, false)  <EOL>      }  <EOL>   <EOL>      override fun onCancelled(cause: Throwable, handled: Boolean) {  <EOL>          signalCompleted(cause, handled)  <EOL>      } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .plugins.*  <EOL>  import kotlinx.atomicfu.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  /**  <EOL>   * Converts an instance of [Scheduler] to an implementation of [CoroutineDispatcher]  <EOL>   * and provides native support of [delay] and [withTimeout].  <EOL>   */  <EOL>  public fun Scheduler.asCoroutineDispatcher(): CoroutineDispatcher =  <EOL>      if (this is DispatcherScheduler) {  <EOL>          dispatcher  <EOL>      } else {  <EOL>          SchedulerCoroutineDispatcher(this)  <EOL>      }  <EOL>   <EOL>  @Deprecated(level = DeprecationLevel.HIDDEN, message =  <STR_LIT> )  <EOL>  @JvmName( <STR_LIT> )  <EOL>  public fun Scheduler.asCoroutineDispatcher <NUM_LIT:0> (): SchedulerCoroutineDispatcher =  <EOL>      SchedulerCoroutineDispatcher(this)  <EOL>   <EOL>  /**  <EOL>   * Converts an instance of [CoroutineDispatcher] to an implementation of [Scheduler].  <EOL>   */  <EOL>  public fun CoroutineDispatcher.asScheduler(): Scheduler =  <EOL>      if (this is SchedulerCoroutineDispatcher) {  <EOL>          scheduler  <EOL>      } else {  <EOL>          DispatcherScheduler(this)  <EOL>      }  <EOL>   <EOL>  private class DispatcherScheduler(@JvmField val dispatcher: CoroutineDispatcher) : Scheduler() {  <EOL>   <EOL>      private val schedulerJob = SupervisorJob()  <EOL>   <EOL>      /**  <EOL>       * The scope for everything happening in this [DispatcherScheduler].  <EOL>       *  <EOL>       * Running tasks, too, get launched under this scope, because [shutdown] should cancel the running tasks as well.  <EOL>       */  <EOL>      private val scope = CoroutineScope(schedulerJob + dispatcher)  <EOL>   <EOL>      /**  <EOL>       * The counter of created workers, for their pretty-printing.  <EOL>       */  <EOL>      private val workerCounter = atomic( <NUM_LIT:1> L)  <EOL>   <EOL>      override fun scheduleDirect(block: Runnable, delay: Long, unit: TimeUnit): Disposable =  <EOL>          scope.scheduleTask(block, unit.toMillis(delay)) { task ->  <EOL>              Runnable { scope.launch { task() } }  <EOL>          }  <EOL>   <EOL>      override fun createWorker(): Worker = DispatcherWorker(workerCounter.getAndIncrement(), dispatcher, schedulerJob)  <EOL>   <EOL>      override fun shutdown() {  <EOL>          schedulerJob.cancel()  <EOL>      }  <EOL>   <EOL>      private class DispatcherWorker(  <EOL>          private val counter: Long,  <EOL>          private val dispatcher: CoroutineDispatcher,  <EOL>          parentJob: Job  <EOL>      ) : Worker() {  <EOL>   <EOL>          private val workerJob = SupervisorJob(parentJob)  <EOL>          private val workerScope = CoroutineScope(workerJob + dispatcher)  <EOL>          private val blockChannel = Channel<suspend () -> Unit>(Channel.UNLIMITED)  <EOL>   <EOL>          init {  <EOL>              workerScope.launch {  <EOL>                  blockChannel.consumeEach {  <EOL>                      it()  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>   <EOL>          override fun schedule(block: Runnable, delay: Long, unit: TimeUnit): Disposable =  <EOL>              workerScope.scheduleTask(block, unit.toMillis(delay)) { task ->  <EOL>                  Runnable { blockChannel.trySend(task) }  <EOL>              }  <EOL>   <EOL>          override fun isDisposed(): Boolean = !workerScope.isActive  <EOL>   <EOL>          override fun dispose() {  <EOL>              blockChannel.close()  <EOL>              workerJob.cancel()  <EOL>          }  <EOL>   <EOL>          override fun toString(): String =  <STR_LIT> disposed <STR_LIT> active <STR_LIT>  <EOL>      }  <EOL>   <EOL>      override fun toString(): String = dispatcher.toString()  <EOL>  }  <EOL>   <EOL>  private typealias Task = suspend () -> Unit  <EOL>   <EOL>  /**  <EOL>   * Schedule [block] so that an adapted version of it, wrapped in [adaptForScheduling], executes after [delayMillis]  <EOL>   * milliseconds.  <EOL>   */  <EOL>  private fun CoroutineScope.scheduleTask(  <EOL>      block: Runnable,  <EOL>      delayMillis: Long,  <EOL>      adaptForScheduling: (Task) -> Runnable  <EOL>  ): Disposable {  <EOL>      val ctx = coroutineContext  <EOL>      var handle: DisposableHandle? = null  <EOL>      val disposable = Disposable.fromRunnable {  <EOL>          // null if delay <=  <NUM_LIT:0>  <EOL>          handle?.dispose()  <EOL>      }  <EOL>      val decoratedBlock = RxJavaPlugins.onSchedule(block)  <EOL>      suspend fun task() {  <EOL>          if (disposable.isDisposed) return  <EOL>          try {  <EOL>              runInterruptible {  <EOL>                  decoratedBlock.run()  <EOL>              }  <EOL>          } catch (e: Throwable) {  <EOL>              handleUndeliverableException(e, ctx)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      val toSchedule = adaptForScheduling(::task)  <EOL>      if (!isActive) return Disposable.disposed()  <EOL>      if (delayMillis <=  <NUM_LIT:0> ) {  <EOL>          toSchedule.run()  <EOL>      } else {  <EOL>          @Suppress( <STR_LIT> ,  <STR_LIT> ) // do not remove the INVISIBLE_REFERENCE suppression: required in K <NUM_LIT:2>  <EOL>          ctx.delay.invokeOnTimeout(delayMillis, toSchedule, ctx).let { handle = it }  <EOL>      }  <EOL>      return disposable  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Implements [CoroutineDispatcher] on top of an arbitrary [Scheduler].  <EOL>   */  <EOL>  public class SchedulerCoroutineDispatcher(  <EOL>      /**  <EOL>       * Underlying scheduler of current [CoroutineDispatcher].  <EOL>       */  <EOL>      public val scheduler: Scheduler  <EOL>  ) : CoroutineDispatcher(), Delay {  <EOL>      /** @suppress */  <EOL>      override fun dispatch(context: CoroutineContext, block: Runnable) {  <EOL>          scheduler.scheduleDirect(block)  <EOL>      }  <EOL>   <EOL>      /** @suppress */  <EOL>      override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {  <EOL>          val disposable = scheduler.scheduleDirect({  <EOL>              with(continuation) { resumeUndispatched(Unit) }  <EOL>          }, timeMillis, TimeUnit.MILLISECONDS)  <EOL>          continuation.disposeOnCancellation(disposable)  <EOL>      }  <EOL>   <EOL>      /** @suppress */  <EOL>      override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {  <EOL>          val disposable = scheduler.scheduleDirect(block, timeMillis, TimeUnit.MILLISECONDS)  <EOL>          return DisposableHandle { disposable.dispose() }  <EOL>      }  <EOL>   <EOL>      /** @suppress */  <EOL>      override fun toString(): String = scheduler.toString()  <EOL>   <EOL>      /** @suppress */  <EOL>      override fun equals(other: Any?): Boolean = other is SchedulerCoroutineDispatcher && other.scheduler === scheduler  <EOL>   <EOL>      /** @suppress */ ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  /**  <EOL>   * Creates cold [single][Single] that will run a given [block] in a coroutine and emits its result.  <EOL>   * Every time the returned observable is subscribed, it starts a new coroutine.  <EOL>   * Unsubscribing cancels running coroutine.  <EOL>   * Coroutine context can be specified with [context] argument.  <EOL>   * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.  <EOL>   * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.  <EOL>   */  <EOL>  public fun <T : Any> rxSingle(  <EOL>      context: CoroutineContext = EmptyCoroutineContext,  <EOL>      block: suspend CoroutineScope.() -> T  <EOL>  ): Single<T> {  <EOL>      require(context[Job] === null) {  <STR_LIT>  +  <EOL>               <STR_LIT>  }  <EOL>      return rxSingleInternal(GlobalScope, context, block)  <EOL>  }  <EOL>   <EOL>  private fun <T : Any> rxSingleInternal(  <EOL>      scope: CoroutineScope, // support for legacy rxSingle in scope  <EOL>      context: CoroutineContext,  <EOL>      block: suspend CoroutineScope.() -> T  <EOL>  ): Single<T> = Single.create { subscriber ->  <EOL>      val newContext = scope.newCoroutineContext(context)  <EOL>      val coroutine = RxSingleCoroutine(newContext, subscriber)  <EOL>      subscriber.setCancellable(RxCancellable(coroutine))  <EOL>      coroutine.start(CoroutineStart.DEFAULT, coroutine, block)  <EOL>  }  <EOL>   <EOL>  private class RxSingleCoroutine<T: Any>(  <EOL>      parentContext: CoroutineContext,  <EOL>      private val subscriber: SingleEmitter<T>  <EOL>  ) : AbstractCoroutine<T>(parentContext, false, true) {  <EOL>      override fun onCompleted(value: T) {  <EOL>          try {  <EOL>              subscriber.onSuccess(value)  <EOL>          } catch (e: Throwable) {  <EOL>              handleUndeliverableException(e, context)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      override fun onCancelled(cause: Throwable, handled: Boolean) {  <EOL>          try {  <EOL>              if (subscriber.tryOnError(cause)) {  <EOL>                  return  <EOL>              }  <EOL>          } catch (e: Throwable) {  <EOL>              cause.addSuppressed(e)  <EOL>          }  <EOL>          handleUndeliverableException(cause, context) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import kotlinx.coroutines.reactive.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class BackpressureTest : TestBase() {  <EOL>      @Test  <EOL>      fun testBackpressureDropDirect() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          Flowable.fromArray( <NUM_LIT:1> )  <EOL>              .onBackpressureDrop()  <EOL>              .collect {  <EOL>                  assertEquals( <NUM_LIT:1> , it)  <EOL>                  expect( <NUM_LIT:2> )  <EOL>              }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBackpressureDropFlow() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          Flowable.fromArray( <NUM_LIT:1> )  <EOL>              .onBackpressureDrop()  <EOL>              .asFlow()  <EOL>              .collect {  <EOL>                  assertEquals( <NUM_LIT:1> , it)  <EOL>                  expect( <NUM_LIT:2> )  <EOL>              }  <EOL>          finish( <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .plugins.*  <EOL>   <EOL>  fun <T : Any> checkSingleValue(  <EOL>      observable: Observable<T>,  <EOL>      checker: (T) -> Unit  <EOL>  ) {  <EOL>      val singleValue = observable.blockingSingle()  <EOL>      checker(singleValue)  <EOL>  }  <EOL>   <EOL>  fun checkErroneous(  <EOL>      observable: Observable<*>,  <EOL>      checker: (Throwable) -> Unit  <EOL>  ) {  <EOL>      val singleNotification = observable.materialize().blockingSingle()  <EOL>      val error = singleNotification.error ?: error( <STR_LIT> )  <EOL>      checker(error)  <EOL>  }  <EOL>   <EOL>  fun <T : Any> checkSingleValue(  <EOL>      single: Single<T>,  <EOL>      checker: (T) -> Unit  <EOL>  ) {  <EOL>      val singleValue = single.blockingGet()  <EOL>      checker(singleValue)  <EOL>  }  <EOL>   <EOL>  fun checkErroneous(  <EOL>      single: Single<*>,  <EOL>      checker: (Throwable) -> Unit  <EOL>  ) {  <EOL>      try {  <EOL>          single.blockingGet()  <EOL>          error( <STR_LIT> )  <EOL>      } catch (e: Throwable) {  <EOL>          checker(e)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun <T> checkMaybeValue(  <EOL>      maybe: Maybe<T>,  <EOL>      checker: (T?) -> Unit  <EOL>  ) {  <EOL>      val maybeValue = maybe.toFlowable().blockingIterable().firstOrNull()  <EOL>      checker(maybeValue)  <EOL>  }  <EOL>   <EOL>  @Suppress( <STR_LIT> )  <EOL>  fun checkErroneous(  <EOL>      maybe: Maybe<*>,  <EOL>      checker: (Throwable) -> Unit  <EOL>  ) {  <EOL>      try {  <EOL>          (maybe as Maybe<Any>).blockingGet()  <EOL>          error( <STR_LIT> )  <EOL>      } catch (e: Throwable) {  <EOL>          checker(e)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  inline fun withExceptionHandler(noinline handler: (Throwable) -> Unit, block: () -> Unit) {  <EOL>      val original = RxJavaPlugins.getErrorHandler()  <EOL>      RxJavaPlugins.setErrorHandler { handler(it) }  <EOL>      try {  <EOL>          block()  <EOL>      } finally {  <EOL>          RxJavaPlugins.setErrorHandler(original) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .exceptions.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class CompletableTest : TestBase() {  <EOL>      @Test  <EOL>      fun testBasicSuccess() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val completable = rxCompletable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          completable.subscribe {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to completable coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicFailure() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val completable = rxCompletable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          completable.subscribe({  <EOL>              expectUnreached()  <EOL>          }, { error ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertIs<RuntimeException>(error)  <EOL>              assertEquals( <STR_LIT> , error.message)  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to completable coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicUnsubscribe() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val completable = rxCompletable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // back to main, will get cancelled  <EOL>              expectUnreached()  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          // nothing is called on a disposed rx <NUM_LIT>  completable  <EOL>          val sub = completable.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expectUnreached()  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          expect( <NUM_LIT> )  <EOL>          sub.dispose() // will cancel coroutine  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitSuccess() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val completable = rxCompletable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          completable.await() // shall launch coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFailure() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val completable = rxCompletable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          try {  <EOL>              completable.await() // shall launch coroutine and throw exception  <EOL>              expectUnreached()  <EOL>          } catch (e: RuntimeException) {  <EOL>              finish( <NUM_LIT> )  <EOL>              assertEquals( <STR_LIT> , e.message)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /** Tests that calls to [await] throw [CancellationException] and dispose of the subscription when their [Job] is  <EOL>       * cancelled. */  <EOL>      @Test  <EOL>      fun testAwaitCancellation() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val completable = CompletableSource { s ->  <EOL>              s.onSubscribe(object: Disposable {  <EOL>                  override fun dispose() { expect( <NUM_LIT> ) }  <EOL>                  override fun isDisposed(): Boolean { expectUnreached(); return false }  <EOL>              })  <EOL>          }  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  completable.await()  <EOL>              } catch (e: CancellationException) {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  throw e  <EOL>              }  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          job.cancelAndJoin()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSuppressedException() = runTest {  <EOL>          val completable = rxCompletable(currentDispatcher()) {  <EOL>              launch(start = CoroutineStart.ATOMIC) {  <EOL>                  throw TestException() // child coroutine fails  <EOL>              }  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } finally {  <EOL>                  throw TestException <NUM_LIT:2> () // but parent throws another exception while cleaning up  <EOL>              }  <EOL>          }  <EOL>          try {  <EOL>              completable.await()  <EOL>              expectUnreached()  <EOL>          } catch (e: TestException) {  <EOL>              assertIs<TestException <NUM_LIT:2> >(e.suppressed[ <NUM_LIT:0> ])  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testUnhandledException() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          var disposable: Disposable? = null  <EOL>          val handler = { e: Throwable ->  <EOL>              assertTrue(e is UndeliverableException && e.cause is TestException)  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          val completable = rxCompletable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } finally {  <EOL>                  throw TestException() // would not be able to handle it since mono is disposed  <EOL>              }  <EOL>          }  <EOL>          withExceptionHandler(handler) {  <EOL>              completable.subscribe(object : CompletableObserver {  <EOL>                  override fun onSubscribe(d: Disposable) {  <EOL>                      expect( <NUM_LIT:2> )  <EOL>                      disposable = d  <EOL>                  }  <EOL>   <EOL>                  override fun onComplete() {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>   <EOL>                  override fun onError(t: Throwable) {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>              })  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // run coroutine  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionInSubscribe() = runTest {  <EOL>          val handler: (Throwable) -> Unit = { e ->  <EOL>              assertTrue(e is UndeliverableException && e.cause is LinkageError); expect( <NUM_LIT:2> )  <EOL>          }  <EOL>   <EOL>          withExceptionHandler(handler) {  <EOL>              rxCompletable(Dispatchers.Unconfined) {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>              }.subscribe { throw LinkageError() }  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionInSingle() = runTest {  <EOL>          rxCompletable(Dispatchers.Unconfined) {  <EOL>              throw LinkageError()  <EOL>          }.subscribe({ expectUnreached()  }, { expect( <NUM_LIT:1> ); assertIs<LinkageError>(it) })  <EOL>          finish( <NUM_LIT:2> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.flow.consumeAsFlow  <EOL>  import org.junit.Assert  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ConvertTest : TestBase() {  <EOL>      @Test  <EOL>      fun testToCompletableSuccess() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val job = launch {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          val completable = job.asCompletable(coroutineContext.minusKey(Job))  <EOL>          completable.subscribe {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testToCompletableFail() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val job = async(NonCancellable) { // don't kill parent on exception  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          val completable = job.asCompletable(coroutineContext.minusKey(Job))  <EOL>          completable.subscribe {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testToMaybe() {  <EOL>          val d = GlobalScope.async {  <EOL>              delay( <NUM_LIT> )  <EOL>               <STR_LIT>  <EOL>          }  <EOL>          val maybe <NUM_LIT:1>  = d.asMaybe(Dispatchers.Unconfined)  <EOL>          checkMaybeValue(maybe <NUM_LIT:1> ) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>          val maybe <NUM_LIT:2>  = d.asMaybe(Dispatchers.Unconfined)  <EOL>          checkMaybeValue(maybe <NUM_LIT:2> ) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testToMaybeEmpty() {  <EOL>          val d = GlobalScope.async {  <EOL>              delay( <NUM_LIT> )  <EOL>              null  <EOL>          }  <EOL>          val maybe <NUM_LIT:1>  = d.asMaybe(Dispatchers.Unconfined)  <EOL>          checkMaybeValue(maybe <NUM_LIT:1> , Assert::assertNull)  <EOL>          val maybe <NUM_LIT:2>  = d.asMaybe(Dispatchers.Unconfined)  <EOL>          checkMaybeValue(maybe <NUM_LIT:2> , Assert::assertNull)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testToMaybeFail() {  <EOL>          val d = GlobalScope.async {  <EOL>              delay( <NUM_LIT> )  <EOL>              throw TestRuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          val maybe <NUM_LIT:1>  = d.asMaybe(Dispatchers.Unconfined)  <EOL>          checkErroneous(maybe <NUM_LIT:1> ) {  <EOL>              check(it is TestRuntimeException && it.message ==  <STR_LIT> ) {  <STR_LIT>  }  <EOL>          }  <EOL>          val maybe <NUM_LIT:2>  = d.asMaybe(Dispatchers.Unconfined)  <EOL>          checkErroneous(maybe <NUM_LIT:2> ) {  <EOL>              check(it is TestRuntimeException && it.message ==  <STR_LIT> ) {  <STR_LIT>  }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testToSingle() {  <EOL>          val d = GlobalScope.async {  <EOL>              delay( <NUM_LIT> )  <EOL>               <STR_LIT>  <EOL>          }  <EOL>          val single <NUM_LIT:1>  = d.asSingle(Dispatchers.Unconfined)  <EOL>          checkSingleValue(single <NUM_LIT:1> ) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>          val single <NUM_LIT:2>  = d.asSingle(Dispatchers.Unconfined)  <EOL>          checkSingleValue(single <NUM_LIT:2> ) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testToSingleFail() {  <EOL>          val d = GlobalScope.async {  <EOL>              delay( <NUM_LIT> )  <EOL>              throw TestRuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          val single <NUM_LIT:1>  = d.asSingle(Dispatchers.Unconfined)  <EOL>          checkErroneous(single <NUM_LIT:1> ) {  <EOL>              check(it is TestRuntimeException && it.message ==  <STR_LIT> ) {  <STR_LIT>  }  <EOL>          }  <EOL>          val single <NUM_LIT:2>  = d.asSingle(Dispatchers.Unconfined)  <EOL>          checkErroneous(single <NUM_LIT:2> ) {  <EOL>              check(it is TestRuntimeException && it.message ==  <STR_LIT> ) {  <STR_LIT>  }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testToObservable() {  <EOL>          val c = GlobalScope.produce {  <EOL>              delay( <NUM_LIT> )  <EOL>              send( <STR_LIT> )  <EOL>              delay( <NUM_LIT> )  <EOL>              send( <STR_LIT> )  <EOL>          }  <EOL>          val observable = c.consumeAsFlow().asObservable()  <EOL>          checkSingleValue(observable.reduce { t <NUM_LIT:1> , t <NUM_LIT:2>  -> t <NUM_LIT:1>  + t <NUM_LIT:2>  }.toSingle()) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testToObservableFail() {  <EOL>          val c = GlobalScope.produce {  <EOL>              delay( <NUM_LIT> )  <EOL>              send( <STR_LIT> )  <EOL>              delay( <NUM_LIT> )  <EOL>              throw TestException( <STR_LIT> )  <EOL>          }  <EOL>          val observable = c.consumeAsFlow().asObservable()  <EOL>          val single = rxSingle(Dispatchers.Unconfined) {  <EOL>              var result =  <STR_LIT>  <EOL>              try {  <EOL>                  observable.collect { result += it }  <EOL>              } catch(e: Throwable) {  <EOL>                  check(e is TestException)  <EOL>                  result += e.message  <EOL>              }  <EOL>              result  <EOL>          }  <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import org.junit.Test  <EOL>  import org.reactivestreams.*  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  @Suppress( <STR_LIT> )  <EOL>  class FlowAsFlowableTest : TestBase() {  <EOL>      @Test  <EOL>      fun testUnconfinedDefaultContext() {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val thread = Thread.currentThread()  <EOL>          fun checkThread() {  <EOL>              assertSame(thread, Thread.currentThread())  <EOL>          }  <EOL>          flowOf( <NUM_LIT> ).asFlowable().subscribe(object : Subscriber<Int> {  <EOL>              private lateinit var subscription: Subscription  <EOL>   <EOL>              override fun onSubscribe(s: Subscription) {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  subscription = s  <EOL>                  subscription.request( <NUM_LIT:2> )  <EOL>              }  <EOL>   <EOL>              override fun onNext(t: Int) {  <EOL>                  checkThread()  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertEquals( <NUM_LIT> , t)  <EOL>              }  <EOL>   <EOL>              override fun onComplete() {  <EOL>                  checkThread()  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>   <EOL>              override fun onError(t: Throwable?) {  <EOL>                  expectUnreached()  <EOL>              }  <EOL>          })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConfinedContext() {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val threadName =  <STR_LIT>  <EOL>          fun checkThread() {  <EOL>              val currentThread = Thread.currentThread()  <EOL>              assertTrue(currentThread.name.startsWith(threadName),  <STR_LIT> )  <EOL>          }  <EOL>          val completed = CountDownLatch( <NUM_LIT:1> )  <EOL>          newSingleThreadContext(threadName).use { dispatcher ->  <EOL>              flowOf( <NUM_LIT> ).asFlowable(dispatcher).subscribe(object : Subscriber<Int> {  <EOL>                  private lateinit var subscription: Subscription  <EOL>   <EOL>                  override fun onSubscribe(s: Subscription) {  <EOL>                      expect( <NUM_LIT:2> )  <EOL>                      subscription = s  <EOL>                      subscription.request( <NUM_LIT:2> )  <EOL>                  }  <EOL>   <EOL>                  override fun onNext(t: Int) {  <EOL>                      checkThread()  <EOL>                      expect( <NUM_LIT> )  <EOL>                      assertEquals( <NUM_LIT> , t)  <EOL>                  }  <EOL>   <EOL>                  override fun onComplete() {  <EOL>                      checkThread()  <EOL>                      expect( <NUM_LIT> )  <EOL>                      completed.countDown()  <EOL>                  }  <EOL>   <EOL>                  override fun onError(t: Throwable?) {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>              })  <EOL>              completed.await()  <EOL>          }  <EOL>          finish( <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class FlowAsObservableTest : TestBase() {  <EOL>      @Test  <EOL>      fun testBasicSuccess() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = flow {  <EOL>              expect( <NUM_LIT> )  <EOL>              emit( <STR_LIT> )  <EOL>          }.asObservable()  <EOL>   <EOL>          expect( <NUM_LIT:2> )  <EOL>          observable.subscribe { value ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertEquals( <STR_LIT> , value)  <EOL>          }  <EOL>   <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicFailure() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = flow<Int> {  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }.asObservable()  <EOL>   <EOL>          expect( <NUM_LIT:2> )  <EOL>          observable.subscribe({ expectUnreached() }, { error ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertIs<RuntimeException>(error)  <EOL>              assertEquals( <STR_LIT> , error.message)  <EOL>          })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicUnsubscribe() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = flow<Int> {  <EOL>              expect( <NUM_LIT> )  <EOL>              hang {  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>          }.asObservable()  <EOL>   <EOL>          expect( <NUM_LIT:2> )  <EOL>          val sub = observable.subscribe({ expectUnreached() }, { expectUnreached() })  <EOL>          sub.dispose() // will cancel coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testNotifyOnceOnCancellation() = runTest {  <EOL>          val observable =  <EOL>              flow {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  emit( <STR_LIT> )  <EOL>                  hang {  <EOL>                      expect( <NUM_LIT> )  <EOL>                  }  <EOL>              }.asObservable()  <EOL>                  .doOnNext {  <EOL>                      expect( <NUM_LIT> )  <EOL>                      assertEquals( <STR_LIT> , it)  <EOL>                  }  <EOL>                  .doOnDispose {  <EOL>                      expect( <NUM_LIT> ) // notified once!  <EOL>                  }  <EOL>   <EOL>          expect( <NUM_LIT:1> )  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              expect( <NUM_LIT:2> )  <EOL>              observable.collect {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertEquals( <STR_LIT> , it)  <EOL>              }  <EOL>          }  <EOL>   <EOL>          yield()  <EOL>          job.cancelAndJoin()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFailingConsumer() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = flow {  <EOL>              expect( <NUM_LIT:2> )  <EOL>              emit( <STR_LIT> )  <EOL>              hang {  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>   <EOL>          }.asObservable()  <EOL>   <EOL>          try {  <EOL>              observable.collect {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  throw TestException()  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testNonAtomicStart() = runTest {  <EOL>          withContext(Dispatchers.Unconfined) {  <EOL>              val observable = flow<Int> {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>              }.asObservable()  <EOL>   <EOL>              val disposable = observable.subscribe({ expectUnreached() }, { expectUnreached() }, { expectUnreached() })  <EOL>              disposable.dispose()  <EOL>          }  <EOL>          finish( <NUM_LIT:2> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFlowCancelledFromWithin() = runTest {  <EOL>          val observable = flow {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              emit( <NUM_LIT:1> )  <EOL>              kotlin.coroutines.coroutineContext.cancel()  <EOL>              kotlin.coroutines.coroutineContext.ensureActive()  <EOL>              expectUnreached()  <EOL>          }.asObservable()  <EOL>   <EOL>          observable.subscribe({ expect( <NUM_LIT:2> ) }, { expectUnreached() }, { finish( <NUM_LIT> ) })  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testUnconfinedDefaultContext() {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val thread = Thread.currentThread()  <EOL>          fun checkThread() {  <EOL>              assertSame(thread, Thread.currentThread())  <EOL>          }  <EOL>          flowOf( <NUM_LIT> ).asObservable().subscribe(object : Observer<Int> {  <EOL>              override fun onSubscribe(d: Disposable) {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>              }  <EOL>   <EOL>              override fun onNext(t: Int) {  <EOL>                  checkThread()  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertEquals( <NUM_LIT> , t)  <EOL>              }  <EOL>   <EOL>              override fun onComplete() {  <EOL>                  checkThread()  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>   <EOL>              override fun onError(t: Throwable) {  <EOL>                  expectUnreached()  <EOL>              }  <EOL>          })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConfinedContext() {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val threadName =  <STR_LIT>  <EOL>          fun checkThread() {  <EOL>              val currentThread = Thread.currentThread()  <EOL>              assertTrue(currentThread.name.startsWith(threadName),  <STR_LIT> )  <EOL>          }  <EOL>          val completed = CountDownLatch( <NUM_LIT:1> )  <EOL>          newSingleThreadContext(threadName).use { dispatcher ->  <EOL>              flowOf( <NUM_LIT> ).asObservable(dispatcher).subscribe(object : Observer<Int> {  <EOL>                  override fun onSubscribe(d: Disposable) {  <EOL>                      expect( <NUM_LIT:2> )  <EOL>                  }  <EOL>   <EOL>                  override fun onNext(t: Int) {  <EOL>                      checkThread()  <EOL>                      expect( <NUM_LIT> )  <EOL>                      assertEquals( <NUM_LIT> , t)  <EOL>                  }  <EOL>   <EOL>                  override fun onComplete() {  <EOL>                      checkThread()  <EOL>                      expect( <NUM_LIT> )  <EOL>                      completed.countDown()  <EOL>                  }  <EOL>   <EOL>                  override fun onError(e: Throwable) {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>              })  <EOL>              completed.await()  <EOL>          }  <EOL>          finish( <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import kotlinx.coroutines.reactive.*  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class FlowableContextTest : TestBase() {  <EOL>      private val dispatcher = newSingleThreadContext( <STR_LIT> )  <EOL>   <EOL>      @After  <EOL>      fun tearDown() {  <EOL>          dispatcher.close()  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFlowableCreateAsFlowThread() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val mainThread = Thread.currentThread()  <EOL>          val dispatcherThread = withContext(dispatcher) { Thread.currentThread() }  <EOL>          assertTrue(dispatcherThread != mainThread)  <EOL>          Flowable.create<String>({  <EOL>              assertEquals(dispatcherThread, Thread.currentThread())  <EOL>              it.onNext( <STR_LIT> )  <EOL>              it.onComplete()  <EOL>          }, BackpressureStrategy.BUFFER)  <EOL>              .asFlow()  <EOL>              .flowOn(dispatcher)  <EOL>              .collect {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  assertEquals( <STR_LIT> , it)  <EOL>                  assertEquals(mainThread, Thread.currentThread())  <EOL>              }  <EOL>          finish( <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .exceptions.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class FlowableExceptionHandlingTest : TestBase() {  <EOL>   <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      private inline fun <reified T : Throwable> handler(expect: Int) = { t: Throwable ->  <EOL>          assertTrue(t is UndeliverableException && t.cause is T)  <EOL>          expect(expect)  <EOL>      }  <EOL>   <EOL>      private fun cehUnreached() = CoroutineExceptionHandler { _, _ -> expectUnreached() }  <EOL>   <EOL>      @Test  <EOL>      fun testException() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxFlowable<Int>(Dispatchers.Unconfined + cehUnreached()) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw TestException()  <EOL>          }.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expect( <NUM_LIT:2> ) // Reported to onError  <EOL>          })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalException() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxFlowable<Int>(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw LinkageError()  <EOL>          }.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expect( <NUM_LIT:2> ) // Fatal exceptions are not treated as special  <EOL>          })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxFlowable<Int>(Dispatchers.Unconfined + cehUnreached()) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw TestException()  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expectUnreached()  <EOL>              }, {  <EOL>                  expect( <NUM_LIT:2> ) // Reported to onError  <EOL>              })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxFlowable<Int>(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw LinkageError()  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expectUnreached()  <EOL>              }, {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>              })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>( <NUM_LIT> )) {  <EOL>          rxFlowable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.subscribe({  <EOL>              expect( <NUM_LIT:2> )  <EOL>              throw LinkageError()  <EOL>          }, { expectUnreached() }) // Fatal exception is rethrown from `onNext` => the subscription is thought to be cancelled  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxFlowable(Dispatchers.Unconfined + cehUnreached()) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.subscribe({  <EOL>              expect( <NUM_LIT:2> )  <EOL>              throw TestException()  <EOL>          }, { expect( <NUM_LIT> ) }) // not reported to onError because came from the subscribe itself  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsynchronousExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxFlowable(Dispatchers.Unconfined + cehUnreached()) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  throw RuntimeException()  <EOL>              }, { expect( <NUM_LIT> ) })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsynchronousFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>( <NUM_LIT> )) {  <EOL>          rxFlowable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  throw LinkageError()  <EOL>              }, { expectUnreached() })  <EOL>          finish( <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.reactive.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class FlowableTest : TestBase() {  <EOL>      @Test  <EOL>      fun testBasicSuccess() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = rxFlowable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              send( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          observable.subscribe { value ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertEquals( <STR_LIT> , value)  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicFailure() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = rxFlowable<String>(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          observable.subscribe({  <EOL>              expectUnreached()  <EOL>          }, { error ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertIs<RuntimeException>(error)  <EOL>              assertEquals( <STR_LIT> , error.message)  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicUnsubscribe() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = rxFlowable<String>(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // back to main, will get cancelled  <EOL>              expectUnreached()  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          val sub = observable.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expectUnreached()  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          expect( <NUM_LIT> )  <EOL>          sub.dispose() // will cancel coroutine  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testNotifyOnceOnCancellation() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable =  <EOL>              rxFlowable(currentDispatcher()) {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  send( <STR_LIT> )  <EOL>                  try {  <EOL>                      delay(Long.MAX_VALUE)  <EOL>                  } catch (e: CancellationException) {  <EOL>                      expect( <NUM_LIT> )  <EOL>                  }  <EOL>              }  <EOL>              .doOnNext {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertEquals( <STR_LIT> , it)  <EOL>              }  <EOL>              .doOnCancel {  <EOL>                  expect( <NUM_LIT:10> ) // notified once!  <EOL>              }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              expect( <NUM_LIT> )  <EOL>              observable.collect {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertEquals( <STR_LIT> , it)  <EOL>              }  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to observable code  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to consuming coroutines  <EOL>          expect( <NUM_LIT> )  <EOL>          job.cancel()  <EOL>          job.join()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFailingConsumer() = runTest {  <EOL>          val pub = rxFlowable(currentDispatcher()) {  <EOL>              repeat( <NUM_LIT> ) {  <EOL>                  expect(it +  <NUM_LIT:1> ) // expect( <NUM_LIT:1> ), expect( <NUM_LIT:2> ) *should* be invoked  <EOL>                  send(it)  <EOL>              }  <EOL>          }  <EOL>          try {  <EOL>              pub.collect {  <EOL>                  throw TestException()  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              finish( <NUM_LIT> )  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.consumeAsFlow  <EOL>  import org.junit.Test  <EOL>  import org.junit.runner.*  <EOL>  import org.junit.runners.*  <EOL>  import kotlin.coroutines.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  @RunWith(Parameterized::class)  <EOL>  class IntegrationTest(  <EOL>      private val ctx: Ctx,  <EOL>      private val delay: Boolean  <EOL>  ) : TestBase() {  <EOL>   <EOL>      enum class Ctx {  <EOL>          MAIN        { override fun invoke(context: CoroutineContext): CoroutineContext = context.minusKey(Job) },  <EOL>          DEFAULT     { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Default },  <EOL>          UNCONFINED  { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Unconfined };  <EOL>   <EOL>          abstract operator fun invoke(context: CoroutineContext): CoroutineContext  <EOL>      }  <EOL>   <EOL>      companion object {  <EOL>          @Parameterized.Parameters(name =  <STR_LIT> )  <EOL>          @JvmStatic  <EOL>          fun params(): Collection<Array<Any>> = Ctx.values().flatMap { ctx ->  <EOL>              listOf(false, true).map { delay ->  <EOL>                  arrayOf(ctx, delay)  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testEmpty(): Unit = runBlocking {  <EOL>          val observable = rxObservable<String>(ctx(coroutineContext)) {  <EOL>              if (delay) delay( <NUM_LIT:1> )  <EOL>              // does not send anything  <EOL>          }  <EOL>          assertFailsWith<NoSuchElementException> { observable.awaitFirst() }  <EOL>          assertEquals( <STR_LIT> , observable.awaitFirstOrDefault( <STR_LIT> ))  <EOL>          assertNull(observable.awaitFirstOrNull())  <EOL>          assertEquals( <STR_LIT> , observable.awaitFirstOrElse {  <STR_LIT>  })  <EOL>          assertFailsWith<NoSuchElementException> { observable.awaitLast() }  <EOL>          assertFailsWith<NoSuchElementException> { observable.awaitSingle() }  <EOL>          var cnt =  <NUM_LIT:0>  <EOL>          observable.collect {  <EOL>              cnt++  <EOL>          }  <EOL>          assertEquals( <NUM_LIT:0> , cnt)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingle() = runBlocking {  <EOL>          val observable = rxObservable(ctx(coroutineContext)) {  <EOL>              if (delay) delay( <NUM_LIT:1> )  <EOL>              send( <STR_LIT> )  <EOL>          }  <EOL>          assertEquals( <STR_LIT> , observable.awaitFirst())  <EOL>          assertEquals( <STR_LIT> , observable.awaitFirstOrDefault( <STR_LIT> ))  <EOL>          assertEquals( <STR_LIT> , observable.awaitFirstOrNull())  <EOL>          assertEquals( <STR_LIT> , observable.awaitFirstOrElse {  <STR_LIT>  })  <EOL>          assertEquals( <STR_LIT> , observable.awaitLast())  <EOL>          assertEquals( <STR_LIT> , observable.awaitSingle())  <EOL>          var cnt =  <NUM_LIT:0>  <EOL>          observable.collect {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>              cnt++  <EOL>          }  <EOL>          assertEquals( <NUM_LIT:1> , cnt)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testNumbers() = runBlocking<Unit> {  <EOL>          val n =  <NUM_LIT:100>  * stressTestMultiplier  <EOL>          val observable = rxObservable(ctx(coroutineContext)) {  <EOL>              for (i in  <NUM_LIT:1> ..n) {  <EOL>                  send(i)  <EOL>                  if (delay) delay( <NUM_LIT:1> )  <EOL>              }  <EOL>          }  <EOL>          assertEquals( <NUM_LIT:1> , observable.awaitFirst())  <EOL>          assertEquals( <NUM_LIT:1> , observable.awaitFirstOrDefault( <NUM_LIT:0> ))  <EOL>          assertEquals( <NUM_LIT:1> , observable.awaitFirstOrNull())  <EOL>          assertEquals( <NUM_LIT:1> , observable.awaitFirstOrElse {  <NUM_LIT:0>  })  <EOL>          assertEquals(n, observable.awaitLast())  <EOL>          assertFailsWith<IllegalArgumentException> { observable.awaitSingle() }  <EOL>          checkNumbers(n, observable)  <EOL>          val channel = observable.openSubscription()  <EOL>          ctx(coroutineContext)  <EOL>          checkNumbers(n, channel.consumeAsFlow().asObservable())  <EOL>          channel.cancel()  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testCancelWithoutValue() = runTest {  <EOL>          val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {  <EOL>              rxObservable<String> {  <EOL>                  hang {  }  <EOL>              }.awaitFirst()  <EOL>          }  <EOL>   <EOL>          job.cancel()  <EOL>          job.join()  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testEmptySingle() = runTest(unhandled = listOf({e -> e is NoSuchElementException})) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {  <EOL>              rxObservable<String> {  <EOL>                  yield()  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  // Nothing to emit  <EOL>              }.awaitFirst()  <EOL>          }  <EOL>   <EOL>          job.join()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testObservableWithTimeout() = runTest {  <EOL>          val observable = rxObservable<Int> {  <EOL>              expect( <NUM_LIT:2> )  <EOL>              withTimeout( <NUM_LIT:1> ) { delay( <NUM_LIT:100> ) }  <EOL>          }  <EOL>          try {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              observable.awaitFirstOrNull()  <EOL>          } catch (e: CancellationException) {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      private suspend fun checkNumbers(n: Int, observable: Observable<Int>) {  <EOL>          var last =  <NUM_LIT:0>  <EOL>          observable.collect {  <EOL>              assertEquals(++last, it)  <EOL>          }  <EOL>          assertEquals(n, last)  <EOL>      } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import org.junit.*  <EOL>  import org.reactivestreams.*  <EOL>  import org.reactivestreams.tck.*  <EOL>   <EOL>  class IterableFlowAsFlowableTckTest : PublisherVerification<Long>(TestEnvironment()) {  <EOL>   <EOL>      private fun generate(num: Long): Array<Long> {  <EOL>          return Array(if (num >= Integer.MAX_VALUE)  <NUM_LIT>  else num.toInt()) { it.toLong() }  <EOL>      }  <EOL>   <EOL>      override fun createPublisher(elements: Long): Flowable<Long> {  <EOL>          return generate(elements).asIterable().asFlow().asFlowable()  <EOL>      }  <EOL>   <EOL>      override fun createFailedPublisher(): Publisher<Long>? = null  <EOL>   <EOL>      @Ignore  <EOL>      override fun required_spec <NUM_LIT> _requestZeroMustSignalIllegalArgumentException() {  <EOL>      }  <EOL>   <EOL>      @Ignore  <EOL>      override fun required_spec <NUM_LIT> _requestNegativeNumberMustSignalIllegalArgumentException() {  <EOL>      }  <EOL>   <EOL>      @Ignore  <EOL>      override fun required_spec <NUM_LIT> _cancelMustMakeThePublisherToEventuallyStopSignaling() {  <EOL>          // ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .exceptions.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import kotlinx.coroutines.reactive.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.Executors  <EOL>  import java.util.concurrent.TimeUnit  <EOL>  import kotlin.test.*  <EOL>   <EOL>  // Check that exception is not leaked to the global exception handler  <EOL>  class LeakedExceptionTest : TestBase() {  <EOL>   <EOL>      private val handler: (Throwable) -> Unit =  <EOL>          { assertTrue { it is UndeliverableException && it.cause is TestException } }  <EOL>   <EOL>      @Test  <EOL>      fun testSingle() = withExceptionHandler(handler) {  <EOL>          withFixedThreadPool( <NUM_LIT> ) { dispatcher ->  <EOL>              val flow = rxSingle<Unit>(dispatcher) { throw TestException() }.toFlowable().asFlow()  <EOL>              runBlocking {  <EOL>                  repeat( <NUM_LIT> ) {  <EOL>                      combine(flow, flow) { _, _ -> Unit }  <EOL>                          .catch {}  <EOL>                          .collect {}  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testObservable() = withExceptionHandler(handler) {  <EOL>          withFixedThreadPool( <NUM_LIT> ) { dispatcher ->  <EOL>              val flow = rxObservable<Unit>(dispatcher) { throw TestException() }  <EOL>                  .toFlowable(BackpressureStrategy.BUFFER)  <EOL>                  .asFlow()  <EOL>              runBlocking {  <EOL>                  repeat( <NUM_LIT> ) {  <EOL>                      combine(flow, flow) { _, _ -> Unit }  <EOL>                          .catch {}  <EOL>                          .collect {}  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFlowable() = withExceptionHandler(handler) {  <EOL>          withFixedThreadPool( <NUM_LIT> ) { dispatcher ->  <EOL>              val flow = rxFlowable<Unit>(dispatcher) { throw TestException() }.asFlow()  <EOL>              runBlocking {  <EOL>                  repeat( <NUM_LIT> ) {  <EOL>                      combine(flow, flow) { _, _ -> Unit }  <EOL>                          .catch {}  <EOL>                          .collect {}  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * This test doesn't test much and was added to display a problem with straighforward use of  <EOL>       * [withExceptionHandler].  <EOL>       *  <EOL>       * If one was to remove `dispatcher` and launch `rxFlowable` with an empty coroutine context,  <EOL>       * this test would fail fairly often, while other tests were also vulnerable, but the problem is  <EOL>       * much more difficult to reproduce. Thus, this test is a justification for adding `dispatcher`  <EOL>       * to other tests.  <EOL>       *  <EOL>       * See the commit that introduced this test for a better explanation.  <EOL>       */  <EOL>      @Test  <EOL>      fun testResettingExceptionHandler() = withExceptionHandler(handler) {  <EOL>          withFixedThreadPool( <NUM_LIT> ) { dispatcher ->  <EOL>              val flow = rxFlowable<Unit>(dispatcher) {  <EOL>                  if (( <NUM_LIT:0> .. <NUM_LIT:1> ).random() ==  <NUM_LIT:0> ) {  <EOL>                      Thread.sleep( <NUM_LIT:100> )  <EOL>                  }  <EOL>                  throw TestException()  <EOL>              }.asFlow()  <EOL>              runBlocking {  <EOL>                  combine(flow, flow) { _, _ -> Unit }  <EOL>                      .catch {}  <EOL>                      .collect {}  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Run in a thread pool, then wait for all the tasks to finish.  <EOL>       */  <EOL>      private fun withFixedThreadPool(numberOfThreads: Int, block: (CoroutineDispatcher) -> Unit) {  <EOL>          val pool = Executors.newFixedThreadPool(numberOfThreads)  <EOL>          val dispatcher = pool.asCoroutineDispatcher()  <EOL>          block(dispatcher)  <EOL>          pool.shutdown()  <EOL>          while (!pool.awaitTermination( <NUM_LIT:10> , TimeUnit.SECONDS)) {  <EOL>              /* deliberately empty */  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .exceptions.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .internal.functions.Functions.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.CancellationException  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class MaybeTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicSuccess() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val maybe = rxMaybe(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>               <STR_LIT>  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          maybe.subscribe { value ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertEquals( <STR_LIT> , value)  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicEmpty() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val maybe = rxMaybe(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              null  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          maybe.subscribe (emptyConsumer(), ON_ERROR_MISSING, {  <EOL>              expect( <NUM_LIT> )  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicFailure() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val maybe = rxMaybe(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          maybe.subscribe({  <EOL>              expectUnreached()  <EOL>          }, { error ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertIs<RuntimeException>(error)  <EOL>              assertEquals( <STR_LIT> , error.message)  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>   <EOL>      @Test  <EOL>      fun testBasicUnsubscribe() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val maybe = rxMaybe(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // back to main, will get cancelled  <EOL>              expectUnreached()  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          // nothing is called on a disposed rx <NUM_LIT:2>  maybe  <EOL>          val sub = maybe.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expectUnreached()  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          expect( <NUM_LIT> )  <EOL>          sub.dispose() // will cancel coroutine  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testMaybeNoWait() {  <EOL>          val maybe = rxMaybe {  <EOL>               <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkMaybeValue(maybe) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testMaybeAwait() = runBlocking {  <EOL>          assertEquals( <STR_LIT> , Maybe.just( <STR_LIT> ).awaitSingleOrNull() +  <STR_LIT> )  <EOL>          assertEquals( <STR_LIT> , Maybe.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testMaybeAwaitForNull(): Unit = runBlocking {  <EOL>          assertNull(Maybe.empty<String>().awaitSingleOrNull())  <EOL>          assertFailsWith<NoSuchElementException> { Maybe.empty<String>().awaitSingle() }  <EOL>      }  <EOL>   <EOL>      /** Tests that calls to [awaitSingleOrNull] throw [CancellationException] and dispose of the subscription when their  <EOL>       * [Job] is cancelled. */  <EOL>      @Test  <EOL>      fun testMaybeAwaitCancellation() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val maybe = MaybeSource<Int> { s ->  <EOL>              s.onSubscribe(object: Disposable {  <EOL>                  override fun dispose() { expect( <NUM_LIT> ) }  <EOL>                  override fun isDisposed(): Boolean { expectUnreached(); return false }  <EOL>              })  <EOL>          }  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  maybe.awaitSingleOrNull()  <EOL>              } catch (e: CancellationException) {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  throw e  <EOL>              }  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          job.cancelAndJoin()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testMaybeEmitAndAwait() {  <EOL>          val maybe = rxMaybe {  <EOL>              Maybe.just( <STR_LIT> ).awaitSingleOrNull() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkMaybeValue(maybe) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testMaybeWithDelay() {  <EOL>          val maybe = rxMaybe {  <EOL>              Observable.timer( <NUM_LIT> , TimeUnit.MILLISECONDS).map {  <STR_LIT>  }.awaitSingle() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkMaybeValue(maybe) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testMaybeException() {  <EOL>          val maybe = rxMaybe {  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitSingle() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkErroneous(maybe) {  <EOL>              assert(it is IllegalArgumentException)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirst() {  <EOL>          val maybe = rxMaybe {  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirst() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkMaybeValue(maybe) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitLast() {  <EOL>          val maybe = rxMaybe {  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitLast() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkMaybeValue(maybe) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromObservable() {  <EOL>          val maybe = rxMaybe {  <EOL>              try {  <EOL>                  Observable.error<String>(RuntimeException( <STR_LIT> )).awaitFirst()  <EOL>              } catch (e: RuntimeException) {  <EOL>                  Observable.just(e.message!!).awaitLast() +  <STR_LIT>  <EOL>              }  <EOL>          }  <EOL>   <EOL>          checkMaybeValue(maybe) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromCoroutine() {  <EOL>          val maybe = rxMaybe<String> {  <EOL>              throw IllegalStateException(Observable.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkErroneous(maybe) {  <EOL>              assert(it is IllegalStateException)  <EOL>              assertEquals( <STR_LIT> , it.message)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testCancelledConsumer() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val maybe = rxMaybe(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } catch (e: CancellationException) {  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>               <NUM_LIT>  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          val timeout = withTimeoutOrNull( <NUM_LIT:100> ) {  <EOL>              expect( <NUM_LIT> )  <EOL>              maybe.collect {  <EOL>                  expectUnreached()  <EOL>              }  <EOL>              expectUnreached()  <EOL>          }  <EOL>          assertNull(timeout)  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // must cancel code inside maybe!!!  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests the simple scenario where the Maybe doesn't output a value. */  <EOL>      @Test  <EOL>      fun testMaybeCollectEmpty() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          Maybe.empty<Int>().collect {  <EOL>              expectUnreached()  <EOL>          }  <EOL>          finish( <NUM_LIT:2> )  <EOL>      }  <EOL>   <EOL>      /** Tests the simple scenario where the Maybe doesn't output a value. */  <EOL>      @Test  <EOL>      fun testMaybeCollectSingle() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          Maybe.just( <STR_LIT> ).collect {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests the behavior of [collect] when the Maybe raises an error. */  <EOL>      @Test  <EOL>      fun testMaybeCollectThrowingMaybe() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          try {  <EOL>              Maybe.error<Int>(TestException()).collect {  <EOL>                  expectUnreached()  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests the behavior of [collect] when the action throws. */  <EOL>      @Test  <EOL>      fun testMaybeCollectThrowingAction() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          try {  <EOL>              Maybe.just( <STR_LIT> ).collect {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  throw TestException()  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSuppressedException() = runTest {  <EOL>          val maybe = rxMaybe(currentDispatcher()) {  <EOL>              launch(start = CoroutineStart.ATOMIC) {  <EOL>                  throw TestException() // child coroutine fails  <EOL>              }  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } finally {  <EOL>                  throw TestException <NUM_LIT:2> () // but parent throws another exception while cleaning up  <EOL>              }  <EOL>          }  <EOL>          try {  <EOL>              maybe.awaitSingleOrNull()  <EOL>              expectUnreached()  <EOL>          } catch (e: TestException) {  <EOL>              assertIs<TestException <NUM_LIT:2> >(e.suppressed[ <NUM_LIT:0> ])  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testUnhandledException() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          var disposable: Disposable? = null  <EOL>          val handler = { e: Throwable ->  <EOL>              assertTrue(e is UndeliverableException && e.cause is TestException)  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          val maybe = rxMaybe(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } finally {  <EOL>                  throw TestException() // would not be able to handle it since mono is disposed  <EOL>              }  <EOL>          }  <EOL>          withExceptionHandler(handler) {  <EOL>              maybe.subscribe(object : MaybeObserver<Unit> {  <EOL>                  override fun onSubscribe(d: Disposable) {  <EOL>                      expect( <NUM_LIT:2> )  <EOL>                      disposable = d  <EOL>                  }  <EOL>   <EOL>                  override fun onComplete() {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>   <EOL>                  override fun onSuccess(t: Unit) {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>   <EOL>                  override fun onError(t: Throwable) {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>              })  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // run coroutine  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionInSubscribe() = runTest {  <EOL>          val handler = { e: Throwable ->  <EOL>              assertTrue(e is UndeliverableException && e.cause is LinkageError)  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>   <EOL>          withExceptionHandler(handler) {  <EOL>              rxMaybe(Dispatchers.Unconfined) {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>                   <NUM_LIT>  <EOL>              }.subscribe { throw LinkageError() }  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionInSingle() = runTest {  <EOL>          rxMaybe(Dispatchers.Unconfined) {  <EOL>              throw LinkageError()  <EOL>          }.subscribe({ expectUnreached()  }, { expect( <NUM_LIT:1> ); assertIs<LinkageError>(it) })  <EOL>          finish( <NUM_LIT:2> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.Observable  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.ObservableSource  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.Observer  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.Disposable  <EOL>  import io.reactivex.rxjava <NUM_LIT> .subjects.PublishSubject  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import kotlinx.coroutines.testing.flow.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableAsFlowTest : TestBase() {  <EOL>      @Test  <EOL>      fun testCancellation() = runTest {  <EOL>          var onNext =  <NUM_LIT:0>  <EOL>          var onCancelled =  <NUM_LIT:0>  <EOL>          var onError =  <NUM_LIT:0>  <EOL>   <EOL>          val source = rxObservable(currentDispatcher()) {  <EOL>              coroutineContext[Job]?.invokeOnCompletion {  <EOL>                  if (it is CancellationException) ++onCancelled  <EOL>              }  <EOL>   <EOL>              repeat( <NUM_LIT:100> ) {  <EOL>                  send(it)  <EOL>              }  <EOL>          }  <EOL>   <EOL>          source.asFlow().launchIn(CoroutineScope(Dispatchers.Unconfined)) {  <EOL>              onEach {  <EOL>                  ++onNext  <EOL>                  throw RuntimeException()  <EOL>              }  <EOL>              catch<Throwable> {  <EOL>                  ++onError  <EOL>              }  <EOL>          }.join()  <EOL>   <EOL>   <EOL>          assertEquals( <NUM_LIT:1> , onNext)  <EOL>          assertEquals( <NUM_LIT:1> , onError)  <EOL>          assertEquals( <NUM_LIT:1> , onCancelled)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testImmediateCollection() {  <EOL>          val source = PublishSubject.create<Int>()  <EOL>          val flow = source.asFlow()  <EOL>          GlobalScope.launch(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              flow.collect { expect(it) }  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          source.onNext( <NUM_LIT> )  <EOL>          expect( <NUM_LIT> )  <EOL>          source.onNext( <NUM_LIT> )  <EOL>          source.onComplete()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testOnErrorCancellation() {  <EOL>          val source = PublishSubject.create<Int>()  <EOL>          val flow = source.asFlow()  <EOL>          val exception = RuntimeException()  <EOL>          GlobalScope.launch(Dispatchers.Unconfined) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>                  flow.collect { expect(it) }  <EOL>                  expectUnreached()  <EOL>              }  <EOL>              catch (e: Exception) {  <EOL>                  assertSame(exception, e.cause)  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          source.onNext( <NUM_LIT> )  <EOL>          expect( <NUM_LIT> )  <EOL>          source.onError(exception)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testUnsubscribeOnCollectionException() {  <EOL>          val source = PublishSubject.create<Int>()  <EOL>          val flow = source.asFlow()  <EOL>          val exception = RuntimeException()  <EOL>          GlobalScope.launch(Dispatchers.Unconfined) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>                  flow.collect {  <EOL>                      expect(it)  <EOL>                      if (it ==  <NUM_LIT> ) throw exception  <EOL>                  }  <EOL>                  expectUnreached()  <EOL>              }  <EOL>              catch (e: Exception) {  <EOL>                  assertSame(exception, e.cause)  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          assertTrue(source.hasObservers())  <EOL>          source.onNext( <NUM_LIT> )  <EOL>          assertFalse(source.hasObservers())  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testLateOnSubscribe() {  <EOL>          var observer: Observer<in Int>? = null  <EOL>          val source = ObservableSource<Int> { observer = it }  <EOL>          val flow = source.asFlow()  <EOL>          assertNull(observer)  <EOL>          val job = GlobalScope.launch(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              flow.collect { expectUnreached() }  <EOL>              expectUnreached()  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          assertNotNull(observer)  <EOL>          job.cancel()  <EOL>          val disposable = Disposable.empty()  <EOL>          observer!!.onSubscribe(disposable)  <EOL>          assertTrue(disposable.isDisposed)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBufferUnlimited() = runTest {  <EOL>          val source = rxObservable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT:1> ); send( <NUM_LIT:10> )  <EOL>              expect( <NUM_LIT:2> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> ); send( <NUM_LIT> )  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          source.asFlow().buffer(Channel.UNLIMITED).collect { expect(it) }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConflated() = runTest {  <EOL>          val source = Observable.range( <NUM_LIT:1> ,  <NUM_LIT> )  <EOL>          val list = source.asFlow().conflate().toList()  <EOL>          assertEquals(listOf( <NUM_LIT:1> ,  <NUM_LIT> ), list)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testLongRange() = runTest {  <EOL>          val source = Observable.range( <NUM_LIT:1> ,  <NUM_LIT:10> _ <NUM_LIT> )  <EOL>          val count = source.asFlow().count()  <EOL>          assertEquals( <NUM_LIT:10> _ <NUM_LIT> , count)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testProduce() = runTest {  <EOL>          val source = Observable.range( <NUM_LIT:0> ,  <NUM_LIT:10> )  <EOL>          val flow = source.asFlow()  <EOL>          check(( <NUM_LIT:0> .. <NUM_LIT> ).toList(), flow.produceIn(this))  <EOL>          check(( <NUM_LIT:0> .. <NUM_LIT> ).toList(), flow.buffer(Channel.UNLIMITED).produceIn(this))  <EOL>          check(( <NUM_LIT:0> .. <NUM_LIT> ).toList(), flow.buffer( <NUM_LIT:2> ).produceIn(this))  <EOL>          check(( <NUM_LIT:0> .. <NUM_LIT> ).toList(), flow.buffer( <NUM_LIT:0> ).produceIn(this))  <EOL>          check(listOf( <NUM_LIT:0> ,  <NUM_LIT> ), flow.conflate().produceIn(this))  <EOL>      }  <EOL>   <EOL>      private suspend fun check(expected: List<Int>, channel: ReceiveChannel<Int>) {  <EOL>          val result = ArrayList<Int>( <NUM_LIT:10> )  <EOL>          channel.consumeEach { result.add(it) }  <EOL>          assertEquals(expected, result) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.ObservableSource  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableCollectTest: TestBase() {  <EOL>   <EOL>      /** Tests the behavior of [collect] when the publisher raises an error. */  <EOL>      @Test  <EOL>      fun testObservableCollectThrowingObservable() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          var sum =  <NUM_LIT:0>  <EOL>          try {  <EOL>              rxObservable {  <EOL>                  for (i in  <NUM_LIT:0> .. <NUM_LIT:100> ) {  <EOL>                      send(i)  <EOL>                  }  <EOL>                  throw TestException()  <EOL>              }.collect {  <EOL>                  sum += it  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              assertTrue(sum >  <NUM_LIT:0> )  <EOL>              finish( <NUM_LIT:2> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testObservableCollectThrowingAction() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          var sum =  <NUM_LIT:0>  <EOL>          val expectedSum =  <NUM_LIT>  <EOL>          try {  <EOL>              var disposed = false  <EOL>              ObservableSource<Int> { observer ->  <EOL>                  launch(Dispatchers.Default) {  <EOL>                      observer.onSubscribe(object : Disposable {  <EOL>                          override fun dispose() {  <EOL>                              disposed = true  <EOL>                              expect(expectedSum +  <NUM_LIT:2> )  <EOL>                          }  <EOL>   <EOL>                          override fun isDisposed(): Boolean = disposed  <EOL>                      })  <EOL>                      while (!disposed) {  <EOL>                          observer.onNext( <NUM_LIT:1> )  <EOL>                      }  <EOL>                  }  <EOL>              }.collect {  <EOL>                  expect(sum +  <NUM_LIT:2> )  <EOL>                  sum += it  <EOL>                  if (sum == expectedSum) {  <EOL>                      throw TestException()  <EOL>                  }  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              assertEquals(expectedSum, sum)  <EOL>              finish(expectedSum +  <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import java.util.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  class ObservableCompletionStressTest : TestBase() {  <EOL>      private val N_REPEATS =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>   <EOL>      private fun CoroutineScope.range(context: CoroutineContext, start: Int, count: Int) = rxObservable(context) {  <EOL>          for (x in start until start + count) send(x)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testCompletion() {  <EOL>          val rnd = Random()  <EOL>          repeat(N_REPEATS) {  <EOL>              val count = rnd.nextInt( <NUM_LIT> )  <EOL>              runBlocking {  <EOL>                  withTimeout( <NUM_LIT> ) {  <EOL>                      var received =  <NUM_LIT:0>  <EOL>                      range(Dispatchers.Default,  <NUM_LIT:1> , count).collect { x ->  <EOL>                          received++  <EOL>                          if (x != received) error( <STR_LIT> )  <EOL>                      }  <EOL>                      if (received != count) error( <STR_LIT> )  <EOL>                  }  <EOL>              }  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .exceptions.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableExceptionHandlingTest : TestBase() {  <EOL>   <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      private inline fun <reified T : Throwable> handler(expect: Int) = { t: Throwable ->  <EOL>          assertTrue(t is UndeliverableException && t.cause is T,  <STR_LIT> )  <EOL>          expect(expect)  <EOL>      }  <EOL>   <EOL>      private fun cehUnreached() = CoroutineExceptionHandler { _, _ -> expectUnreached() }  <EOL>   <EOL>      @Test  <EOL>      fun testException() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable<Int>(Dispatchers.Unconfined + cehUnreached()) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw TestException()  <EOL>          }.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expect( <NUM_LIT:2> ) // Reported to onError  <EOL>          })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalException() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable<Int>(Dispatchers.Unconfined + cehUnreached()) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw LinkageError()  <EOL>          }.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expect( <NUM_LIT:2> )  <EOL>          })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable<Int>(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw TestException()  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expectUnreached()  <EOL>              }, {  <EOL>                  expect( <NUM_LIT:2> ) // Reported to onError  <EOL>              })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable<Int>(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              throw LinkageError()  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expectUnreached()  <EOL>              }, {  <EOL>                  expect( <NUM_LIT:2> ) // Fatal exceptions are not treated in a special manner  <EOL>              })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>( <NUM_LIT> )) {  <EOL>          val latch = CountDownLatch( <NUM_LIT:1> )  <EOL>          rxObservable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              val result = trySend(Unit)  <EOL>              val exception = result.exceptionOrNull()  <EOL>              assertIs<UndeliverableException>(exception)  <EOL>              assertIs<LinkageError>(exception.cause)  <EOL>              assertTrue(isClosedForSend)  <EOL>              expect( <NUM_LIT> )  <EOL>              latch.countDown()  <EOL>          }.subscribe({  <EOL>              expect( <NUM_LIT:2> )  <EOL>              throw LinkageError()  <EOL>          }, { expectUnreached() }) // Unreached because RxJava bubbles up fatal exceptions, causing `onNext` to throw.  <EOL>          latch.await()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.subscribe({  <EOL>              expect( <NUM_LIT:2> )  <EOL>              throw TestException()  <EOL>          }, { expect( <NUM_LIT> ) })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsynchronousExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {  <EOL>          rxObservable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  throw RuntimeException()  <EOL>              }, { expect( <NUM_LIT> ) })  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsynchronousFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>( <NUM_LIT> )) {  <EOL>          rxObservable(Dispatchers.Unconfined) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              send(Unit)  <EOL>          }.publish()  <EOL>              .refCount()  <EOL>              .subscribe({  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  throw LinkageError()  <EOL>              }, { expectUnreached() }) // Unreached because RxJava bubbles up fatal exceptions, causing `onNext` to throw.  <EOL>          finish( <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.selects.*  <EOL>  import org.junit.Test  <EOL>  import java.io.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  /**  <EOL>   * Test emitting multiple values with [rxObservable].  <EOL>   */  <EOL>  class ObservableMultiTest : TestBase() {  <EOL>      @Test  <EOL>      fun testNumbers() {  <EOL>          val n =  <NUM_LIT:100>  * stressTestMultiplier  <EOL>          val observable = rxObservable {  <EOL>              repeat(n) { send(it) }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list)  <EOL>          }  <EOL>      }  <EOL>   <EOL>   <EOL>      @Test  <EOL>      fun testConcurrentStress() {  <EOL>          val n =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>          val observable = rxObservable {  <EOL>              newCoroutineContext(coroutineContext)  <EOL>              // concurrent emitters (many coroutines)  <EOL>              val jobs = List(n) {  <EOL>                  // launch  <EOL>                  launch(Dispatchers.Default) {  <EOL>                      val i = it  <EOL>                      send(i)  <EOL>                  }  <EOL>              }  <EOL>              jobs.forEach { it.join() }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(n, list.size)  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list.sorted())  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConcurrentStressOnSend() {  <EOL>          val n =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>          val observable = rxObservable<Int> {  <EOL>              newCoroutineContext(coroutineContext)  <EOL>              // concurrent emitters (many coroutines)  <EOL>              val jobs = List(n) {  <EOL>                  // launch  <EOL>                  launch(Dispatchers.Default) {  <EOL>                      val i = it  <EOL>                      select<Unit> {  <EOL>                          onSend(i) {}  <EOL>                      }  <EOL>                  }  <EOL>              }  <EOL>              jobs.forEach { it.join() }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(n, list.size)  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list.sorted())  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testIteratorResendUnconfined() {  <EOL>          val n =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>          val observable = rxObservable(Dispatchers.Unconfined) {  <EOL>              Observable.range( <NUM_LIT:0> , n).collect { send(it) }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testIteratorResendPool() {  <EOL>          val n =  <NUM_LIT:10> _ <NUM_LIT>  * stressTestMultiplier  <EOL>          val observable = rxObservable {  <EOL>              Observable.range( <NUM_LIT:0> , n).collect { send(it) }  <EOL>          }  <EOL>          checkSingleValue(observable.toList()) { list ->  <EOL>              assertEquals(( <NUM_LIT:0>  until n).toList(), list)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSendAndCrash() {  <EOL>          val observable = rxObservable {  <EOL>              send( <STR_LIT> )  <EOL>              throw IOException( <STR_LIT> )  <EOL>          }  <EOL>          val single = rxSingle {  <EOL>              var result =  <STR_LIT>  <EOL>              try {  <EOL>                  observable.collect { result += it }  <EOL>              } catch(e: IOException) {  <EOL>                  result += e.message  <EOL>              }  <EOL>              result  <EOL>          }  <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.CancellationException  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableSingleTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleNoWait() {  <EOL>          val observable = rxObservable {  <EOL>              send( <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleAwait() = runBlocking {  <EOL>          assertEquals( <STR_LIT> , Observable.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleEmitAndAwait() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleWithDelay() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.timer( <NUM_LIT> , TimeUnit.MILLISECONDS).map {  <STR_LIT>  }.awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleException() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkErroneous(observable) {  <EOL>              assertIs<IllegalArgumentException>(it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirst() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirst() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrDefault() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.empty<String>().awaitFirstOrDefault( <STR_LIT> ) +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrDefaultWithValues() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirstOrDefault( <STR_LIT> ) +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrNull() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.empty<String>().awaitFirstOrNull() ?:  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrNullWithValues() {  <EOL>          val observable = rxObservable {  <EOL>              send((Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirstOrNull() ?:  <STR_LIT> ) +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrElse() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.empty<String>().awaitFirstOrElse {  <STR_LIT>  } +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirstOrElseWithValues() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirstOrElse {  <STR_LIT>  } +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitLast() {  <EOL>          val observable = rxObservable {  <EOL>              send(Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitLast() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /** Tests that calls to [awaitFirst] (and, thus, the other methods) throw [CancellationException] and dispose of  <EOL>       * the subscription when their [Job] is cancelled. */  <EOL>      @Test  <EOL>      fun testAwaitCancellation() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = ObservableSource<Int> { s ->  <EOL>              s.onSubscribe(object: Disposable {  <EOL>                  override fun dispose() { expect( <NUM_LIT> ) }  <EOL>                  override fun isDisposed(): Boolean { expectUnreached(); return false }  <EOL>              })  <EOL>          }  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  observable.awaitFirst()  <EOL>              } catch (e: CancellationException) {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  throw e  <EOL>              }  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          job.cancelAndJoin()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromObservable() {  <EOL>          val observable = rxObservable {  <EOL>              try {  <EOL>                  send(Observable.error<String>(RuntimeException( <STR_LIT> )).awaitFirst())  <EOL>              } catch (e: RuntimeException) {  <EOL>                  send(Observable.just(e.message!!).awaitLast() +  <STR_LIT> )  <EOL>              }  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromCoroutine() {  <EOL>          val observable = rxObservable<String> {  <EOL>              throw IllegalStateException(Observable.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkErroneous(observable) {  <EOL>              assertIs<IllegalStateException>(it)  <EOL>              assertEquals( <STR_LIT> , it.message)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testObservableIteration() {  <EOL>          val observable = rxObservable {  <EOL>              var result =  <STR_LIT>  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).collect { result += it }  <EOL>              send(result)  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testObservableIterationFailure() {  <EOL>          val observable = rxObservable {  <EOL>              try {  <EOL>                  Observable.error<String>(RuntimeException( <STR_LIT> )).collect { fail( <STR_LIT> ) }  <EOL>                  send( <STR_LIT> )  <EOL>              } catch (e: RuntimeException) {  <EOL>                  send(e.message!!)  <EOL>              }  <EOL>          }  <EOL>   <EOL>          checkSingleValue(observable) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import org.junit.*  <EOL>  import java.util.concurrent.*  <EOL>   <EOL>  class ObservableSourceAsFlowStressTest : TestBase() {  <EOL>   <EOL>      private val iterations =  <NUM_LIT:100>  * stressTestMultiplierSqrt  <EOL>   <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsFlowCancellation() = runTest {  <EOL>          repeat(iterations) {  <EOL>              val latch = Channel<Unit>( <NUM_LIT:1> )  <EOL>              var i =  <NUM_LIT:0>  <EOL>              val observable = Observable.interval( <NUM_LIT:100> L, TimeUnit.MICROSECONDS)  <EOL>                  .doOnNext {  if (++i >  <NUM_LIT:100> ) latch.trySend(Unit) }  <EOL>              val job = observable.asFlow().launchIn(CoroutineScope(Dispatchers.Default))  <EOL>              latch.receive()  <EOL>              job.cancelAndJoin()  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.selects.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.onSuccess  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableSubscriptionSelectTest : TestBase() {  <EOL>      @Test  <EOL>      fun testSelect() = runTest {  <EOL>          // source with n ints  <EOL>          val n =  <NUM_LIT>  * stressTestMultiplier  <EOL>          val source = rxObservable { repeat(n) { send(it) } }  <EOL>          var a =  <NUM_LIT:0>  <EOL>          var b =  <NUM_LIT:0>  <EOL>          // open two subs  <EOL>          val channelA = source.openSubscription()  <EOL>          val channelB = source.openSubscription()  <EOL>          loop@ while (true) {  <EOL>              val done: Int = select {  <EOL>                  channelA.onReceiveCatching { result ->  <EOL>                      result.onSuccess { assertEquals(a++, it) }  <EOL>                      if (result.isSuccess)  <NUM_LIT:1>  else  <NUM_LIT:0>  <EOL>                  }  <EOL>                  channelB.onReceiveCatching { result ->  <EOL>                      result.onSuccess { assertEquals(b++, it) }  <EOL>                      if (result.isSuccess)  <NUM_LIT:2>  else  <NUM_LIT:0>  <EOL>                  }  <EOL>              }  <EOL>              when (done) {  <EOL>                   <NUM_LIT:0>  -> break@loop  <EOL>                   <NUM_LIT:1>  -> {  <EOL>                      val r = channelB.receiveCatching().getOrNull()  <EOL>                      if (r != null) assertEquals(b++, r)  <EOL>                  }  <EOL>                   <NUM_LIT:2>  -> {  <EOL>                      val r = channelA.receiveCatching().getOrNull()  <EOL>                      if (r != null) assertEquals(a++, r)  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>          channelA.cancel()  <EOL>          channelB.cancel()  <EOL>          // should receive one of them fully  <EOL>          assertTrue(a == n || b == n) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .plugins.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.CancellationException  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class ObservableTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicSuccess() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = rxObservable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              send( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          observable.subscribe { value ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertEquals( <STR_LIT> , value)  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicFailure() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = rxObservable<String>(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          observable.subscribe({  <EOL>              expectUnreached()  <EOL>          }, { error ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertIs<RuntimeException>(error)  <EOL>              assertEquals( <STR_LIT> , error.message)  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicUnsubscribe() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable = rxObservable<String>(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // back to main, will get cancelled  <EOL>              expectUnreached()  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          val sub = observable.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expectUnreached()  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          expect( <NUM_LIT> )  <EOL>          sub.dispose() // will cancel coroutine  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testNotifyOnceOnCancellation() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val observable =  <EOL>              rxObservable(currentDispatcher()) {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  send( <STR_LIT> )  <EOL>                  try {  <EOL>                      delay(Long.MAX_VALUE)  <EOL>                  } catch (e: CancellationException) {  <EOL>                      expect( <NUM_LIT> )  <EOL>                  }  <EOL>              }  <EOL>              .doOnNext {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertEquals( <STR_LIT> , it)  <EOL>              }  <EOL>              .doOnDispose {  <EOL>                  expect( <NUM_LIT:10> ) // notified once!  <EOL>              }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              expect( <NUM_LIT> )  <EOL>              observable.collect {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertEquals( <STR_LIT> , it)  <EOL>              }  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to observable code  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to consuming coroutines  <EOL>          expect( <NUM_LIT> )  <EOL>          job.cancel()  <EOL>          job.join()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFailingConsumer() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val pub = rxObservable(currentDispatcher()) {  <EOL>              expect( <NUM_LIT:2> )  <EOL>              send( <STR_LIT> )  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } catch (e: CancellationException) {  <EOL>                  finish( <NUM_LIT> )  <EOL>              }  <EOL>          }  <EOL>          try {  <EOL>              pub.collect {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  throw TestException()  <EOL>              }  <EOL>          } catch (e: TestException) {  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionAfterCancellation() {  <EOL>          // Test that no exceptions were reported to the global EH (it will fail the test if so)  <EOL>          val handler = { e: Throwable ->  <EOL>              assertFalse(e is CancellationException)  <EOL>          }  <EOL>          withExceptionHandler(handler) {  <EOL>              RxJavaPlugins.setErrorHandler {  <EOL>                  require(it !is CancellationException)  <EOL>              }  <EOL>              Observable  <EOL>                  .interval( <NUM_LIT:1> , TimeUnit.MILLISECONDS)  <EOL>                  .take( <NUM_LIT> )  <EOL>                  .switchMapSingle {  <EOL>                      rxSingle {  <EOL>                          timeBomb().await()  <EOL>                      }  <EOL>                  }  <EOL>                  .blockingSubscribe({}, {})  <EOL>          }  <EOL>      }  <EOL>  ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import java.util.concurrent.*  <EOL>   <EOL>  class SchedulerStressTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test that we don't get an OOM if we schedule many jobs at once.  <EOL>       * It's expected that if you don't dispose you'd see an OOM error.  <EOL>       */  <EOL>      @Test  <EOL>      fun testSchedulerDisposed(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableDisposed(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerDisposed(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          testRunnableDisposed(worker::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableDisposed(block: RxSchedulerBlockNoDelay) {  <EOL>          val n =  <NUM_LIT>  * stressTestMultiplier  <EOL>          repeat(n) {  <EOL>              val a = ByteArray( <NUM_LIT> ) // <NUM_LIT:1> MB  <EOL>              val disposable = block(Runnable {  <EOL>                  keepMe(a)  <EOL>                  expectUnreached()  <EOL>              })  <EOL>              disposable.dispose()  <EOL>              yield() // allow the scheduled task to observe that it was disposed  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test function that holds a reference. Used for testing OOM situations  <EOL>       */  <EOL>      private fun keepMe(a: ByteArray) {  <EOL>          Thread.sleep(a.size / (a.size +  <NUM_LIT:1> ) +  <NUM_LIT:10> L)  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test that we don't get an OOM if we schedule many delayed jobs at once. It's expected that if you don't dispose that you'd  <EOL>       * see a OOM error.  <EOL>       */  <EOL>      @Test  <EOL>      fun testSchedulerDisposedDuringDelay(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableDisposedDuringDelay(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerDisposedDuringDelay(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          testRunnableDisposedDuringDelay(worker::schedule)  <EOL>      }  <EOL>   <EOL>      private fun testRunnableDisposedDuringDelay(block: RxSchedulerBlockWithDelay) {  <EOL>          val n =  <NUM_LIT>  * stressTestMultiplier  <EOL>          repeat(n) {  <EOL>              val a = ByteArray( <NUM_LIT> ) // <NUM_LIT:1> MB  <EOL>              val delayMillis: Long =  <NUM_LIT:10>  <EOL>              val disposable = block(Runnable {  <EOL>                  keepMe(a)  <EOL>                  expectUnreached()  <EOL>              }, delayMillis, TimeUnit.MILLISECONDS)  <EOL>              disposable.dispose()  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .plugins.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .schedulers.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.sync.*  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.lang.Runnable  <EOL>  import java.util.concurrent.*  <EOL>  import java.util.concurrent.atomic.AtomicReference  <EOL>  import kotlin.coroutines.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class SchedulerTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testIoScheduler(): Unit = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val mainThread = Thread.currentThread()  <EOL>          withContext(Schedulers.io().asCoroutineDispatcher()) {  <EOL>              val t <NUM_LIT:1>  = Thread.currentThread()  <EOL>              assertNotSame(t <NUM_LIT:1> , mainThread)  <EOL>              expect( <NUM_LIT:2> )  <EOL>              delay( <NUM_LIT:100> )  <EOL>              val t <NUM_LIT:2>  = Thread.currentThread()  <EOL>              assertNotSame(t <NUM_LIT:2> , mainThread)  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests [toString] implementations of [CoroutineDispatcher.asScheduler] and its [Scheduler.Worker]. */  <EOL>      @Test  <EOL>      fun testSchedulerToString() {  <EOL>          val name =  <STR_LIT>  <EOL>          val scheduler = Dispatchers.Default.asScheduler()  <EOL>          assertContains(scheduler.toString(), name)  <EOL>          val worker = scheduler.createWorker()  <EOL>          val activeWorkerName = worker.toString()  <EOL>          assertContains(worker.toString(), name)  <EOL>          worker.dispose()  <EOL>          val disposedWorkerName = worker.toString()  <EOL>          assertNotEquals(activeWorkerName, disposedWorkerName)  <EOL>      }  <EOL>   <EOL>      private fun runSchedulerTest(nThreads: Int =  <NUM_LIT:1> , action: (Scheduler) -> Unit) {  <EOL>          val future = CompletableFuture<Unit>()  <EOL>          try {  <EOL>              newFixedThreadPoolContext(nThreads,  <STR_LIT:test> ).use { dispatcher ->  <EOL>                  RxJavaPlugins.setErrorHandler {  <EOL>                      if (!future.completeExceptionally(it)) {  <EOL>                          handleUndeliverableException(it, dispatcher)  <EOL>                      }  <EOL>                  }  <EOL>                  action(dispatcher.asScheduler())  <EOL>              }  <EOL>          } finally {  <EOL>              RxJavaPlugins.setErrorHandler(null)  <EOL>          }  <EOL>          future.complete(Unit)  <EOL>          future.getNow(Unit) // rethrow any encountered errors  <EOL>      }  <EOL>   <EOL>      private fun ensureSeparateThread(schedule: (Runnable, Long, TimeUnit) -> Unit, scheduleNoDelay: (Runnable) -> Unit) {  <EOL>          val mainThread = Thread.currentThread()  <EOL>          val cdl <NUM_LIT:1>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          val cdl <NUM_LIT:2>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val thread = AtomicReference<Thread?>(null)  <EOL>          fun checkThread() {  <EOL>              val current = Thread.currentThread()  <EOL>              thread.getAndSet(current)?.let { assertEquals(it, current) }  <EOL>          }  <EOL>          schedule({  <EOL>              assertNotSame(mainThread, Thread.currentThread())  <EOL>              checkThread()  <EOL>              cdl <NUM_LIT:2> .countDown()  <EOL>          },  <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>          scheduleNoDelay {  <EOL>              expect( <NUM_LIT:2> )  <EOL>              checkThread()  <EOL>              assertNotSame(mainThread, Thread.currentThread())  <EOL>              cdl <NUM_LIT:1> .countDown()  <EOL>          }  <EOL>          cdl <NUM_LIT:1> .await()  <EOL>          cdl <NUM_LIT:2> .await()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Tests [Scheduler.scheduleDirect] for [CoroutineDispatcher.asScheduler] on a single-threaded dispatcher.  <EOL>       */  <EOL>      @Test  <EOL>      fun testSingleThreadedDispatcherDirect(): Unit = runSchedulerTest( <NUM_LIT:1> ) {  <EOL>          ensureSeparateThread(it::scheduleDirect, it::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Tests [Scheduler.Worker.schedule] for [CoroutineDispatcher.asScheduler] running its tasks on the correct thread.  <EOL>       */  <EOL>      @Test  <EOL>      fun testSingleThreadedWorker(): Unit = runSchedulerTest( <NUM_LIT:1> ) {  <EOL>          val worker = it.createWorker()  <EOL>          ensureSeparateThread(worker::schedule, worker::schedule)  <EOL>      }  <EOL>   <EOL>      private fun checkCancelling(schedule: (Runnable, Long, TimeUnit) -> Disposable) {  <EOL>          // cancel the task before it has a chance to run.  <EOL>          val handle <NUM_LIT:1>  = schedule({  <EOL>              throw IllegalStateException( <STR_LIT> )  <EOL>          },  <NUM_LIT:10> _ <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>          handle <NUM_LIT:1> .dispose()  <EOL>          // cancel the task after it started running.  <EOL>          val cdl <NUM_LIT:1>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          val cdl <NUM_LIT:2>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          val handle <NUM_LIT:2>  = schedule({  <EOL>              cdl <NUM_LIT:1> .countDown()  <EOL>              cdl <NUM_LIT:2> .await()  <EOL>              if (Thread.interrupted())  <EOL>                  throw IllegalStateException( <STR_LIT> )  <EOL>          },  <NUM_LIT:100> , TimeUnit.MILLISECONDS)  <EOL>          cdl <NUM_LIT:1> .await()  <EOL>          handle <NUM_LIT:2> .dispose()  <EOL>          cdl <NUM_LIT:2> .countDown()  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test cancelling [Scheduler.scheduleDirect] for [CoroutineDispatcher.asScheduler].  <EOL>       */  <EOL>      @Test  <EOL>      fun testCancellingDirect(): Unit = runSchedulerTest {  <EOL>          checkCancelling(it::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test cancelling [Scheduler.Worker.schedule] for [CoroutineDispatcher.asScheduler].  <EOL>       */  <EOL>      @Test  <EOL>      fun testCancellingWorker(): Unit = runSchedulerTest {  <EOL>          val worker = it.createWorker()  <EOL>          checkCancelling(worker::schedule)  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test shutting down [CoroutineDispatcher.asScheduler].  <EOL>       */  <EOL>      @Test  <EOL>      fun testShuttingDown() {  <EOL>          val n =  <NUM_LIT>  <EOL>          runSchedulerTest(nThreads = n) { scheduler ->  <EOL>              val cdl <NUM_LIT:1>  = CountDownLatch(n)  <EOL>              val cdl <NUM_LIT:2>  = CountDownLatch( <NUM_LIT:1> )  <EOL>              val cdl <NUM_LIT>  = CountDownLatch(n)  <EOL>              repeat(n) {  <EOL>                  scheduler.scheduleDirect {  <EOL>                      cdl <NUM_LIT:1> .countDown()  <EOL>                      try {  <EOL>                          cdl <NUM_LIT:2> .await()  <EOL>                      } catch (e: InterruptedException) {  <EOL>                          // this is the expected outcome  <EOL>                          cdl <NUM_LIT> .countDown()  <EOL>                      }  <EOL>                  }  <EOL>              }  <EOL>              cdl <NUM_LIT:1> .await()  <EOL>              scheduler.shutdown()  <EOL>              if (!cdl <NUM_LIT> .await( <NUM_LIT:1> , TimeUnit.SECONDS)) {  <EOL>                  cdl <NUM_LIT:2> .countDown()  <EOL>                  error( <STR_LIT> )  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /** Tests that there are no uncaught exceptions if [Disposable.dispose] on a worker happens when tasks are present. */  <EOL>      @Test  <EOL>      fun testDisposingWorker() = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          yield() // so that the worker starts waiting on the channel  <EOL>          assertFalse(worker.isDisposed)  <EOL>          worker.dispose()  <EOL>          assertTrue(worker.isDisposed)  <EOL>      }  <EOL>   <EOL>      /** Tests trying to use a [Scheduler.Worker]/[Scheduler] after [Scheduler.Worker.dispose]/[Scheduler.shutdown]. */  <EOL>      @Test  <EOL>      fun testSchedulingAfterDisposing() = runSchedulerTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val worker = it.createWorker()  <EOL>          // use CDL to ensure that the worker has properly initialized  <EOL>          val cdl <NUM_LIT:1>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          setScheduler( <NUM_LIT:2> ,  <NUM_LIT> )  <EOL>          val disposable <NUM_LIT:1>  = worker.schedule {  <EOL>              cdl <NUM_LIT:1> .countDown()  <EOL>          }  <EOL>          cdl <NUM_LIT:1> .await()  <EOL>          expect( <NUM_LIT> )  <EOL>          assertFalse(disposable <NUM_LIT:1> .isDisposed)  <EOL>          setScheduler( <NUM_LIT> , - <NUM_LIT:1> )  <EOL>          // check that the worker automatically disposes of the tasks after being disposed  <EOL>          assertFalse(worker.isDisposed)  <EOL>          worker.dispose()  <EOL>          assertTrue(worker.isDisposed)  <EOL>          expect( <NUM_LIT> )  <EOL>          val disposable <NUM_LIT:2>  = worker.schedule {  <EOL>              expectUnreached()  <EOL>          }  <EOL>          assertTrue(disposable <NUM_LIT:2> .isDisposed)  <EOL>          setScheduler( <NUM_LIT> ,  <NUM_LIT> )  <EOL>          // ensure that the scheduler still works  <EOL>          val cdl <NUM_LIT:2>  = CountDownLatch( <NUM_LIT:1> )  <EOL>          val disposable <NUM_LIT>  = it.scheduleDirect {  <EOL>              cdl <NUM_LIT:2> .countDown()  <EOL>          }  <EOL>          cdl <NUM_LIT:2> .await()  <EOL>          expect( <NUM_LIT> )  <EOL>          assertFalse(disposable <NUM_LIT> .isDisposed)  <EOL>          // check that the scheduler automatically disposes of the tasks after being shut down  <EOL>          it.shutdown()  <EOL>          setScheduler( <NUM_LIT:10> , - <NUM_LIT:1> )  <EOL>          val disposable <NUM_LIT>  = it.scheduleDirect {  <EOL>              expectUnreached()  <EOL>          }  <EOL>          assertTrue(disposable <NUM_LIT> .isDisposed)  <EOL>          RxJavaPlugins.setScheduleHandler(null)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWithNoDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithNoDelay(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerWithNoDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithNoDelay(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableWithNoDelay(block: RxSchedulerBlockNoDelay) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              block(Runnable {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  it.resume(Unit)  <EOL>              })  <EOL>          }  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWithDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler::scheduleDirect,  <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerWithDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler.createWorker()::schedule,  <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWithZeroDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerWithZeroDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableWithDelay(block: RxSchedulerBlockWithDelay, delayMillis: Long =  <NUM_LIT:0> ) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              block({  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  it.resume(Unit)  <EOL>              }, delayMillis, TimeUnit.MILLISECONDS)  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsSchedulerWithNegativeDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler::scheduleDirect, - <NUM_LIT:1> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAsSchedulerWorkerWithNegativeDelay(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableWithDelay(scheduler.createWorker()::schedule, - <NUM_LIT:1> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerImmediateDispose(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableImmediateDispose(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerImmediateDispose(): Unit = runTest {  <EOL>          val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()  <EOL>          testRunnableImmediateDispose(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private fun testRunnableImmediateDispose(block: RxSchedulerBlockNoDelay) {  <EOL>          val disposable = block {  <EOL>              expectUnreached()  <EOL>          }  <EOL>          disposable.dispose()  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConvertDispatcherToOriginalScheduler(): Unit = runTest {  <EOL>          val originalScheduler = Schedulers.io()  <EOL>          val dispatcher = originalScheduler.asCoroutineDispatcher()  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          assertSame(originalScheduler, scheduler)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConvertSchedulerToOriginalDispatcher(): Unit = runTest {  <EOL>          val originalDispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = originalDispatcher.asScheduler()  <EOL>          val dispatcher = scheduler.asCoroutineDispatcher()  <EOL>          assertSame(originalDispatcher, dispatcher)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerExpectRxPluginsCall(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableExpectRxPluginsCall(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerExpectRxPluginsCall(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableExpectRxPluginsCall(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableExpectRxPluginsCall(block: RxSchedulerBlockNoDelay) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          setScheduler( <NUM_LIT:2> ,  <NUM_LIT> )  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              block(Runnable {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  it.resume(Unit)  <EOL>              })  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          RxJavaPlugins.setScheduleHandler(null)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerExpectRxPluginsCallWithDelay(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          testRunnableExpectRxPluginsCallDelay(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerExpectRxPluginsCallWithDelay(): Unit = runTest {  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          testRunnableExpectRxPluginsCallDelay(worker::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableExpectRxPluginsCallDelay(block: RxSchedulerBlockWithDelay) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          setScheduler( <NUM_LIT:2> ,  <NUM_LIT> )  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              block({  <EOL>                  expect( <NUM_LIT> )  <EOL>                  it.resume(Unit)  <EOL>              },  <NUM_LIT:10> , TimeUnit.MILLISECONDS)  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          RxJavaPlugins.setScheduleHandler(null)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      private fun setScheduler(expectedCountOnSchedule: Int, expectCountOnRun: Int) {  <EOL>          RxJavaPlugins.setScheduleHandler {  <EOL>              expect(expectedCountOnSchedule)  <EOL>              Runnable {  <EOL>                  expect(expectCountOnRun)  <EOL>                  it.run()  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Tests that [Scheduler.Worker] runs all work sequentially.  <EOL>       */  <EOL>      @Test  <EOL>      fun testWorkerSequentialOrdering() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val scheduler = Dispatchers.Default.asScheduler()  <EOL>          val worker = scheduler.createWorker()  <EOL>          val iterations =  <NUM_LIT:100>  <EOL>          for (i in  <NUM_LIT:0> ..iterations) {  <EOL>              worker.schedule {  <EOL>                  expect( <NUM_LIT:2>  + i)  <EOL>              }  <EOL>          }  <EOL>          suspendCoroutine<Unit> {  <EOL>              worker.schedule {  <EOL>                  it.resume(Unit)  <EOL>              }  <EOL>          }  <EOL>          finish((iterations +  <NUM_LIT:2> ) +  <NUM_LIT:1> )  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Test that ensures that delays are actually respected (tasks scheduled sooner in the future run before tasks scheduled later,  <EOL>       * even when the later task is submitted before the earlier one)  <EOL>       */  <EOL>      @Test  <EOL>      fun testSchedulerRespectsDelays(): Unit = runTest {  <EOL>          val scheduler = Dispatchers.Default.asScheduler()  <EOL>          testRunnableRespectsDelays(scheduler::scheduleDirect)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSchedulerWorkerRespectsDelays(): Unit = runTest {  <EOL>          val scheduler = Dispatchers.Default.asScheduler()  <EOL>          testRunnableRespectsDelays(scheduler.createWorker()::schedule)  <EOL>      }  <EOL>   <EOL>      private suspend fun testRunnableRespectsDelays(block: RxSchedulerBlockWithDelay) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val semaphore = Semaphore( <NUM_LIT:2> ,  <NUM_LIT:2> )  <EOL>          block({  <EOL>              expect( <NUM_LIT> )  <EOL>              semaphore.release()  <EOL>          },  <NUM_LIT:100> , TimeUnit.MILLISECONDS)  <EOL>          block({  <EOL>              expect( <NUM_LIT:2> )  <EOL>              semaphore.release()  <EOL>          },  <NUM_LIT:1> , TimeUnit.MILLISECONDS)  <EOL>          semaphore.acquire()  <EOL>          semaphore.acquire()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /**  <EOL>       * Tests that cancelling a runnable in one worker doesn't affect work in another scheduler.  <EOL>       *  <EOL>       * This is part of expected behavior documented.  <EOL>       */  <EOL>      @Test  <EOL>      fun testMultipleWorkerCancellation(): Unit = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val dispatcher = currentDispatcher() as CoroutineDispatcher  <EOL>          val scheduler = dispatcher.asScheduler()  <EOL>          suspendCancellableCoroutine<Unit> {  <EOL>              val workerOne = scheduler.createWorker()  <EOL>              workerOne.schedule({  <EOL>                  expect( <NUM_LIT> )  <EOL>                  it.resume(Unit)  <EOL>              },  <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>              val workerTwo = scheduler.createWorker()  <EOL>              workerTwo.schedule({  <EOL>                  expectUnreached()  <EOL>              },  <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>              workerTwo.dispose()  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>  } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.rx <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .core.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .disposables.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .exceptions.*  <EOL>  import io.reactivex.rxjava <NUM_LIT> .functions.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.CancellationException  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class SingleTest : TestBase() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicSuccess() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>               <STR_LIT>  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          single.subscribe { value ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertEquals( <STR_LIT> , value)  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testBasicFailure() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              throw RuntimeException( <STR_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          single.subscribe({  <EOL>              expectUnreached()  <EOL>          }, { error ->  <EOL>              expect( <NUM_LIT> )  <EOL>              assertIs<RuntimeException>(error)  <EOL>              assertEquals( <STR_LIT> , error.message)  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>   <EOL>      @Test  <EOL>      fun testBasicUnsubscribe() = runBlocking {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // back to main, will get cancelled  <EOL>              expectUnreached()  <EOL>   <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          // nothing is called on a disposed rx <NUM_LIT>  single  <EOL>          val sub = single.subscribe({  <EOL>              expectUnreached()  <EOL>          }, {  <EOL>              expectUnreached()  <EOL>          })  <EOL>          expect( <NUM_LIT> )  <EOL>          yield() // to started coroutine  <EOL>          expect( <NUM_LIT> )  <EOL>          sub.dispose() // will cancel coroutine  <EOL>          yield()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleNoWait() {  <EOL>          val single = rxSingle {  <EOL>               <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleAwait() = runBlocking {  <EOL>          assertEquals( <STR_LIT> , Single.just( <STR_LIT> ).await() +  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests that calls to [await] throw [CancellationException] and dispose of the subscription when their  <EOL>       * [Job] is cancelled. */  <EOL>      @Test  <EOL>      fun testSingleAwaitCancellation() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          val single = SingleSource<Int> { s ->  <EOL>              s.onSubscribe(object: Disposable {  <EOL>                  override fun dispose() { expect( <NUM_LIT> ) }  <EOL>                  override fun isDisposed(): Boolean { expectUnreached(); return false }  <EOL>              })  <EOL>          }  <EOL>          val job = launch(start = CoroutineStart.UNDISPATCHED) {  <EOL>              try {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  single.await()  <EOL>              } catch (e: CancellationException) {  <EOL>                  expect( <NUM_LIT> )  <EOL>                  throw e  <EOL>              }  <EOL>          }  <EOL>          expect( <NUM_LIT> )  <EOL>          job.cancelAndJoin()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleEmitAndAwait() {  <EOL>          val single = rxSingle {  <EOL>              Single.just( <STR_LIT> ).await() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleWithDelay() {  <EOL>          val single = rxSingle {  <EOL>              Observable.timer( <NUM_LIT> , TimeUnit.MILLISECONDS).map {  <STR_LIT>  }.awaitSingle() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSingleException() {  <EOL>          val single = rxSingle {  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitSingle() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkErroneous(single) {  <EOL>              assert(it is IllegalArgumentException)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFirst() {  <EOL>          val single = rxSingle {  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitFirst() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitLast() {  <EOL>          val single = rxSingle {  <EOL>              Observable.just( <STR_LIT> ,  <STR_LIT> ).awaitLast() +  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromObservable() {  <EOL>          val single = rxSingle {  <EOL>              try {  <EOL>                  Observable.error<String>(RuntimeException( <STR_LIT> )).awaitFirst()  <EOL>              } catch (e: RuntimeException) {  <EOL>                  Observable.just(e.message!!).awaitLast() +  <STR_LIT>  <EOL>              }  <EOL>          }  <EOL>   <EOL>          checkSingleValue(single) {  <EOL>              assertEquals( <STR_LIT> , it)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testExceptionFromCoroutine() {  <EOL>          val single = rxSingle<String> {  <EOL>              throw IllegalStateException(Observable.just( <STR_LIT> ).awaitSingle() +  <STR_LIT> )  <EOL>          }  <EOL>   <EOL>          checkErroneous(single) {  <EOL>              assert(it is IllegalStateException)  <EOL>              assertEquals( <STR_LIT> , it.message)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testSuppressedException() = runTest {  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              launch(start = CoroutineStart.ATOMIC) {  <EOL>                  throw TestException() // child coroutine fails  <EOL>              }  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } finally {  <EOL>                  throw TestException <NUM_LIT:2> () // but parent throws another exception while cleaning up  <EOL>              }  <EOL>          }  <EOL>          try {  <EOL>              single.await()  <EOL>              expectUnreached()  <EOL>          } catch (e: TestException) {  <EOL>              assertIs<TestException <NUM_LIT:2> >(e.suppressed[ <NUM_LIT:0> ])  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionInSubscribe() = runTest {  <EOL>          val handler = { e: Throwable ->  <EOL>              assertTrue(e is UndeliverableException && e.cause is LinkageError)  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>          withExceptionHandler(handler) {  <EOL>              rxSingle(Dispatchers.Unconfined) {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>                   <NUM_LIT>  <EOL>              }.subscribe(Consumer {  <EOL>                  throw LinkageError()  <EOL>              })  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFatalExceptionInSingle() = runTest {  <EOL>          rxSingle(Dispatchers.Unconfined) {  <EOL>              throw LinkageError()  <EOL>          }.subscribe { _, e -> assertIs<LinkageError>(e); expect( <NUM_LIT:1> ) }  <EOL>   <EOL>          finish( <NUM_LIT:2> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testUnhandledException() = runTest {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          var disposable: Disposable? = null  <EOL>          val handler = { e: Throwable ->  <EOL>              assertTrue(e is UndeliverableException && e.cause is TestException)  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          val single = rxSingle(currentDispatcher()) {  <EOL>              expect( <NUM_LIT> )  <EOL>              disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled  <EOL>              try {  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              } finally {  <EOL>                  throw TestException() // would not be able to handle it since mono is disposed  <EOL>              }  <EOL>          }  <EOL>          withExceptionHandler(handler) {  <EOL>              single.subscribe(object : SingleObserver<Unit> {  <EOL>                  override fun onSubscribe(d: Disposable) {  <EOL>                      expect( <NUM_LIT:2> )  <EOL>                      disposable = d  <EOL>                  }  <EOL>   <EOL>                  override fun onSuccess(t: Unit) {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>   <EOL>                  override fun onError(t: Throwable) {  <EOL>                      expectUnreached()  <EOL>                  }  <EOL>              })  <EOL>              expect( <NUM_LIT> )  <EOL>              yield() // run coroutine  <EOL>              finish( <NUM_LIT> )  <EOL>          } ", "gt": ""}
{"input": "<s> pluginManagement {  <EOL>      val javafx_plugin_version: String by settings  <EOL>      plugins {  <EOL>          id( <STR_LIT> ) version javafx_plugin_version  <EOL>          id( <STR_LIT> ) version  <STR_LIT>  <EOL>      }  <EOL>   <EOL>      repositories {  <EOL>          maven(url =  <STR_LIT> )  <EOL>          gradlePluginPortal()  <EOL>      }  <EOL>  }  <EOL>   <EOL>  rootProject.name =  <STR_LIT>  <EOL>   <EOL>  fun module(path: String) {  <EOL>      val i = path.lastIndexOf( <STR_LIT:/> )  <EOL>      val name = path.substring(i +  <NUM_LIT:1> )  <EOL>      include(name)  <EOL>      project( <STR_LIT> ).projectDir = file(path)  <EOL>  }  <EOL>  val prop = System.getProperty( <STR_LIT> )  <EOL>  var build_snapshot_train: String by extra  <EOL>  build_snapshot_train = if (prop != null && prop !=  <STR_LIT> )  <STR_LIT:true>  else  <STR_LIT:false>  <EOL>  // ---------------------------  <EOL>   <EOL>  include( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>   <EOL>  include( <STR_LIT> )  <EOL>   <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>   <EOL>   <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>   <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>  module( <STR_LIT> )  <EOL>  if (JavaVersion.current().isJava <NUM_LIT> Compatible()) {  <EOL>      module( <STR_LIT> ) ", "gt": ""}
{"input": "<s> /*  <EOL>   * Copyright  <NUM_LIT> - <NUM_LIT>  JetBrains s.r.o. Use of this source code is governed by the Apache  <NUM_LIT>  license.  <EOL>   */  <EOL>   <EOL>  kotlin {  <EOL>      sourceSets {  <EOL>          commonMain.dependencies {  <EOL>              api( <STR_LIT> kotlin <STR_LIT> )  <EOL>              api( <STR_LIT> kotlin <STR_LIT> )  <EOL>          }  <EOL>          jvmMain.dependencies {  <EOL>              api( <STR_LIT> kotlin <STR_LIT> )  <EOL>              // Workaround to make addSuppressed work in tests  <EOL>              api( <STR_LIT> kotlin <STR_LIT> )  <EOL>              api( <STR_LIT> kotlin <STR_LIT> )  <EOL>              api( <STR_LIT> kotlin <STR_LIT> )  <EOL>              api( <STR_LIT> junit <STR_LIT> )  <EOL>          }  <EOL>          jsMain.dependencies {  <EOL>              api( <STR_LIT> kotlin <STR_LIT> )  <EOL>          }  <EOL>          val wasmJsMain by getting {  <EOL>              dependencies {  <EOL>                  api( <STR_LIT> kotlin <STR_LIT> )  <EOL>              }  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing.flow  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import kotlin.jvm.*  <EOL>  import kotlin.reflect.*  <EOL>   <EOL>  public typealias Handler<T> = suspend CoroutineScope.(T) -> Unit  <EOL>   <EOL>  /*  <EOL>   * Design of this builder is not yet stable, so leaving it as is.  <EOL>   */  <EOL>  public class LaunchFlowBuilder<T> {  <EOL>      /*  <EOL>       * NB: this implementation is a temporary ad-hoc (and slightly incorrect)  <EOL>       * solution until coroutine-builders are ready  <EOL>       *  <EOL>       * NB  <NUM_LIT:2> : this internal stuff is required to workaround KT- <NUM_LIT>  <EOL>       */  <EOL>      @PublishedApi  <EOL>      internal var onEach: Handler<T>? = null  <EOL>      @PublishedApi  <EOL>      internal var finally: Handler<Throwable?>? = null  <EOL>      @PublishedApi  <EOL>      internal var exceptionHandlers = LinkedHashMap<KClass<*>, Handler<Throwable>>()  <EOL>   <EOL>      public fun onEach(action: suspend CoroutineScope.(value: T) -> Unit) {  <EOL>          check(onEach == null) {  <STR_LIT>  }  <EOL>          check(exceptionHandlers.isEmpty()) {  <STR_LIT>  }  <EOL>          check(finally == null) {  <STR_LIT>  }  <EOL>          onEach = action  <EOL>      }  <EOL>   <EOL>      public inline fun <reified T : Throwable> catch(noinline action: suspend CoroutineScope.(T) -> Unit) {  <EOL>          check(onEach != null) {  <STR_LIT>  }  <EOL>          check(finally == null) {  <STR_LIT>  }  <EOL>          @Suppress( <STR_LIT> )  <EOL>          exceptionHandlers[T::class] = action as Handler<Throwable>  <EOL>      }  <EOL>   <EOL>      public fun finally(action: suspend CoroutineScope.(cause: Throwable?) -> Unit) {  <EOL>          check(finally == null) {  <STR_LIT>  }  <EOL>          check(onEach != null) {  <STR_LIT>  }  <EOL>          if (finally == null) finally = action  <EOL>      }  <EOL>   <EOL>      internal fun build(): Handlers<T> =  <EOL>          Handlers(onEach ?: error( <STR_LIT> ), exceptionHandlers, finally)  <EOL>  }  <EOL>   <EOL>  internal class Handlers<T>(  <EOL>      @JvmField  <EOL>      internal var onEach: Handler<T>,  <EOL>      @JvmField  <EOL>      internal var exceptionHandlers: Map<KClass<*>, Handler<Throwable>>,  <EOL>      @JvmField  <EOL>      internal var finally: Handler<Throwable?>?  <EOL>  )  <EOL>   <EOL>  private fun <T> CoroutineScope.launchFlow(  <EOL>      flow: Flow<T>,  <EOL>      builder: LaunchFlowBuilder<T>.() -> Unit  <EOL>  ): Job {  <EOL>      val handlers = LaunchFlowBuilder<T>().apply(builder).build()  <EOL>      return launch {  <EOL>          var caught: Throwable? = null  <EOL>          try {  <EOL>              coroutineScope {  <EOL>                  flow.collect { value ->  <EOL>                      handlers.onEach(this, value)  <EOL>                  }  <EOL>              }  <EOL>          } catch (e: Throwable) {  <EOL>              handlers.exceptionHandlers.forEach { (key, value) ->  <EOL>                  if (key.isInstance(e)) {  <EOL>                      caught = e  <EOL>                      value.invoke(this, e)  <EOL>                      return@forEach  <EOL>                  }  <EOL>              }  <EOL>              if (caught == null) {  <EOL>                  caught = e  <EOL>                  throw e  <EOL>              }  <EOL>          } finally {  <EOL>              cancel() // TODO discuss  <EOL>              handlers.finally?.invoke(CoroutineScope(coroutineContext + NonCancellable), caught)  <EOL>          }  <EOL>      }  <EOL>  }  <EOL>   <EOL>  public fun <T> Flow<T>.launchIn(  <EOL>      scope: CoroutineScope, ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  abstract class MainDispatcherTestBase: TestBase() {  <EOL>   <EOL>      open fun shouldSkipTesting(): Boolean = false  <EOL>   <EOL>      open suspend fun spinTest(testBody: Job) {  <EOL>          testBody.join()  <EOL>      }  <EOL>   <EOL>      abstract fun isMainThread(): Boolean?  <EOL>   <EOL>      /** Runs the given block as a test, unless [shouldSkipTesting] indicates that the environment is not suitable. */  <EOL>      fun runTestOrSkip(block: suspend CoroutineScope.() -> Unit): TestResult {  <EOL>          // written as a block body to make the need to return `TestResult` explicit  <EOL>          return runTest {  <EOL>              if (shouldSkipTesting()) return@runTest  <EOL>              val testBody = launch(Dispatchers.Default) {  <EOL>                  block()  <EOL>              }  <EOL>              spinTest(testBody)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /** Tests the [toString] behavior of [Dispatchers.Main] and [MainCoroutineDispatcher.immediate] */  <EOL>      @Test  <EOL>      fun testMainDispatcherToString() {  <EOL>          assertEquals( <STR_LIT> , Dispatchers.Main.toString())  <EOL>          assertEquals( <STR_LIT> , Dispatchers.Main.immediate.toString())  <EOL>      }  <EOL>   <EOL>      /** Tests that the tasks scheduled earlier from [MainCoroutineDispatcher.immediate] will be executed earlier,  <EOL>       * even if the immediate dispatcher was entered from the main thread. */  <EOL>      @Test  <EOL>      fun testMainDispatcherOrderingInMainThread() = runTestOrSkip {  <EOL>          withContext(Dispatchers.Main) {  <EOL>              testMainDispatcherOrdering()  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /** Tests that the tasks scheduled earlier from [MainCoroutineDispatcher.immediate] will be executed earlier  <EOL>       * if the immediate dispatcher was entered from outside the main thread. */  <EOL>      @Test  <EOL>      fun testMainDispatcherOrderingOutsideMainThread() = runTestOrSkip {  <EOL>          testMainDispatcherOrdering()  <EOL>      }  <EOL>   <EOL>      /** Tests that [Dispatchers.Main] and its [MainCoroutineDispatcher.immediate] are treated as different values. */  <EOL>      @Test  <EOL>      fun testHandlerDispatcherNotEqualToImmediate() {  <EOL>          assertNotEquals(Dispatchers.Main, Dispatchers.Main.immediate)  <EOL>      }  <EOL>   <EOL>      /** Tests that [Dispatchers.Main] shares its queue with [MainCoroutineDispatcher.immediate]. */  <EOL>      @Test  <EOL>      fun testImmediateDispatcherYield() = runTestOrSkip {  <EOL>          withContext(Dispatchers.Main) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              checkIsMainThread()  <EOL>              // launch in the immediate dispatcher  <EOL>              launch(Dispatchers.Main.immediate) {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  yield()  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>              expect( <NUM_LIT> ) // after yield  <EOL>              yield() // yield back  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests that entering [MainCoroutineDispatcher.immediate] from [Dispatchers.Main] happens immediately. */  <EOL>      @Test  <EOL>      fun testEnteringImmediateFromMain() = runTestOrSkip {  <EOL>          withContext(Dispatchers.Main) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              val job = launch { expect( <NUM_LIT> ) }  <EOL>              withContext(Dispatchers.Main.immediate) {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>              }  <EOL>              job.join()  <EOL>          }  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests that dispatching to [MainCoroutineDispatcher.immediate] is required from and only from dispatchers  <EOL>       * other than the main dispatchers and that it's always required for [Dispatchers.Main] itself. */  <EOL>      @Test  <EOL>      fun testDispatchRequirements() = runTestOrSkip {  <EOL>          checkDispatchRequirements()  <EOL>          withContext(Dispatchers.Main) {  <EOL>              checkDispatchRequirements()  <EOL>              withContext(Dispatchers.Main.immediate) {  <EOL>                  checkDispatchRequirements()  <EOL>              }  <EOL>              checkDispatchRequirements()  <EOL>          }  <EOL>          checkDispatchRequirements()  <EOL>      }  <EOL>   <EOL>      private suspend fun checkDispatchRequirements() {  <EOL>          isMainThread()?.let {  <EOL>              assertNotEquals(  <EOL>                  it,  <EOL>                  Dispatchers.Main.immediate.isDispatchNeeded(currentCoroutineContext())  <EOL>              )  <EOL>          }  <EOL>          assertTrue(Dispatchers.Main.isDispatchNeeded(currentCoroutineContext()))  <EOL>          assertTrue(Dispatchers.Default.isDispatchNeeded(currentCoroutineContext()))  <EOL>      }  <EOL>   <EOL>      /** Tests that launching a coroutine in [MainScope] will execute it in the main thread. */  <EOL>      @Test  <EOL>      fun testLaunchInMainScope() = runTestOrSkip {  <EOL>          var executed = false  <EOL>          withMainScope {  <EOL>              launch {  <EOL>                  checkIsMainThread()  <EOL>                  executed = true  <EOL>              }.join()  <EOL>              if (!executed) throw AssertionError( <STR_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /** Tests that a failure in [MainScope] will not propagate upwards. */  <EOL>      @Test  <EOL>      fun testFailureInMainScope() = runTestOrSkip {  <EOL>          var exception: Throwable? = null  <EOL>          withMainScope {  <EOL>              launch(CoroutineExceptionHandler { ctx, e -> exception = e }) {  <EOL>                  checkIsMainThread()  <EOL>                  throw TestException()  <EOL>              }.join()  <EOL>          }  <EOL>          if (exception!! !is TestException) throw AssertionError( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      /** Tests cancellation in [MainScope]. */  <EOL>      @Test  <EOL>      fun testCancellationInMainScope() = runTestOrSkip {  <EOL>          withMainScope {  <EOL>              cancel()  <EOL>              launch(start = CoroutineStart.ATOMIC) {  <EOL>                  checkIsMainThread()  <EOL>                  delay(Long.MAX_VALUE)  <EOL>              }.join()  <EOL>          }  <EOL>      }  <EOL>   <EOL>      private suspend fun <R> withMainScope(block: suspend CoroutineScope.() -> R): R {  <EOL>          MainScope().apply {  <EOL>              return block().also { coroutineContext[Job]!!.cancelAndJoin() }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      private suspend fun testMainDispatcherOrdering() {  <EOL>          withContext(Dispatchers.Main.immediate) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              launch(Dispatchers.Main) {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>              }  <EOL>              withContext(Dispatchers.Main) {  <EOL>                  finish( <NUM_LIT> )  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      abstract class WithRealTimeDelay : MainDispatcherTestBase() {  <EOL>          abstract fun scheduleOnMainQueue(block: () -> Unit)  <EOL>   <EOL>          /** Tests that after a delay, the execution gets back to the main thread. */  <EOL>          @Test  <EOL>          fun testDelay() = runTestOrSkip {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              checkNotMainThread()  <EOL>              scheduleOnMainQueue { expect( <NUM_LIT:2> ) }  <EOL>              withContext(Dispatchers.Main) {  <EOL>                  checkIsMainThread()  <EOL>                  expect( <NUM_LIT> )  <EOL>                  scheduleOnMainQueue { expect( <NUM_LIT> ) }  <EOL>                  delay( <NUM_LIT:100> )  <EOL>                  checkIsMainThread()  <EOL>                  expect( <NUM_LIT> )  <EOL>              }  <EOL>              checkNotMainThread()  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>   <EOL>          /** Tests that [Dispatchers.Main] is in agreement with the default time source: it's not much slower. */  <EOL>          @Test  <EOL>          fun testWithTimeoutContextDelayNoTimeout() = runTestOrSkip {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              withTimeout( <NUM_LIT> ) {  <EOL>                  withContext(Dispatchers.Main) {  <EOL>                      checkIsMainThread()  <EOL>                      expect( <NUM_LIT:2> )  <EOL>                      delay( <NUM_LIT:100> )  <EOL>                      checkIsMainThread()  <EOL>                      expect( <NUM_LIT> )  <EOL>                  }  <EOL>              }  <EOL>              checkNotMainThread()  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>   <EOL>          /** Tests that [Dispatchers.Main] is in agreement with the default time source: it's not much faster. */  <EOL>          @Test  <EOL>          fun testWithTimeoutContextDelayTimeout() = runTestOrSkip {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              assertFailsWith<TimeoutCancellationException> {  <EOL>                  withTimeout( <NUM_LIT> ) {  <EOL>                      // A substitute for withContext(Dispatcher.Main) that is started even if the  <NUM_LIT> ms  <EOL>                      // timeout happens fsater then dispatch  <EOL>                      launch(Dispatchers.Main, start = CoroutineStart.ATOMIC) {  <EOL>                          checkIsMainThread()  <EOL>                          expect( <NUM_LIT:2> )  <EOL>                          delay( <NUM_LIT> )  <EOL>                          expectUnreached()  <EOL>                      }.join()  <EOL>                  }  <EOL>                  expectUnreached()  <EOL>              }  <EOL>              checkNotMainThread()  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>   <EOL>          /** Tests that the timeout of [Dispatchers.Main] is in agreement with its [delay]: it's not much faster. */  <EOL>          @Test  <EOL>          fun testWithContextTimeoutDelayNoTimeout() = runTestOrSkip {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              withContext(Dispatchers.Main) {  <EOL>                  withTimeout( <NUM_LIT> ) {  <EOL>                      checkIsMainThread()  <EOL>                      expect( <NUM_LIT:2> )  <EOL>                      delay( <NUM_LIT:100> )  <EOL>                      checkIsMainThread()  <EOL>                      expect( <NUM_LIT> )  <EOL>                  }  <EOL>              }  <EOL>              checkNotMainThread()  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>   <EOL>          /** Tests that the timeout of [Dispatchers.Main] is in agreement with its [delay]: it's not much slower. */  <EOL>          @Test  <EOL>          fun testWithContextTimeoutDelayTimeout() = runTestOrSkip {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              assertFailsWith<TimeoutCancellationException> {  <EOL>                  withContext(Dispatchers.Main) {  <EOL>                      withTimeout( <NUM_LIT:100> ) {  <EOL>                          checkIsMainThread()  <EOL>                          expect( <NUM_LIT:2> )  <EOL>                          delay( <NUM_LIT> )  <EOL>                          expectUnreached()  <EOL>                      }  <EOL>                  }  <EOL>                  expectUnreached()  <EOL>              }  <EOL>              checkNotMainThread()  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      fun checkIsMainThread() { isMainThread()?.let { check(it) } } ", "gt": ""}
{"input": "<s> @file:Suppress( <STR_LIT> )  <EOL>  package kotlinx.coroutines.testing  <EOL>   <EOL>  import kotlinx.atomicfu.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.internal.*  <EOL>  import kotlin.coroutines.*  <EOL>  import kotlin.test.*  <EOL>  import kotlin.time.*  <EOL>  import kotlin.time.Duration.Companion.seconds  <EOL>   <EOL>  /**  <EOL>   * The number of milliseconds that is sure not to pass [assertRunsFast].  <EOL>   */  <EOL>  const val SLOW =  <NUM_LIT:100> _ <NUM_LIT> L  <EOL>   <EOL>  /**  <EOL>   * Asserts that a block completed within [timeout].  <EOL>   */  <EOL>  inline fun <T> assertRunsFast(timeout: Duration, block: () -> T): T {  <EOL>      val result: T  <EOL>      val elapsed = TimeSource.Monotonic.measureTime { result = block() }  <EOL>      assertTrue( <STR_LIT> ) { elapsed < timeout }  <EOL>      return result  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Asserts that a block completed within two seconds.  <EOL>   */  <EOL>  inline fun <T> assertRunsFast(block: () -> T): T = assertRunsFast( <NUM_LIT:2> .seconds, block)  <EOL>   <EOL>  /**  <EOL>   * Whether the tests should trace their calls to `expect` and `finish` with `println`.  <EOL>   * `false` by default. On the JVM, can be set to `true` by setting the `test.verbose` system property.  <EOL>   */  <EOL>  expect val VERBOSE: Boolean  <EOL>   <EOL>  interface OrderedExecution {  <EOL>      /** Expect the next action to be [index] in order. */  <EOL>      fun expect(index: Int)  <EOL>   <EOL>      /** Expect this action to be final, with the given [index]. */  <EOL>      fun finish(index: Int)  <EOL>   <EOL>      /** * Asserts that this line is never executed. */  <EOL>      fun expectUnreached()  <EOL>   <EOL>      /**  <EOL>       * Checks that [finish] was called.  <EOL>       *  <EOL>       * By default, it is allowed to not call [finish] if [expect] was not called.  <EOL>       * This is useful for tests that don't check the ordering of events.  <EOL>       * When [allowNotUsingExpect] is set to `false`, it is an error to not call [finish] in any case.  <EOL>       */  <EOL>      fun checkFinishCall(allowNotUsingExpect: Boolean = true)  <EOL>   <EOL>      class Impl : OrderedExecution {  <EOL>          private val actionIndex = atomic( <NUM_LIT:0> )  <EOL>   <EOL>          override fun expect(index: Int) {  <EOL>              val wasIndex = actionIndex.incrementAndGet()  <EOL>              if (VERBOSE) println( <STR_LIT> )  <EOL>              check(index == wasIndex) {  <EOL>                  if (wasIndex <  <NUM_LIT:0> )  <STR_LIT>  <EOL>                  else  <STR_LIT>  <EOL>              }  <EOL>          }  <EOL>   <EOL>          override fun finish(index: Int) {  <EOL>              val wasIndex = actionIndex.getAndSet(Int.MIN_VALUE) +  <NUM_LIT:1>  <EOL>              if (VERBOSE) println( <STR_LIT> finished <STR_LIT> )  <EOL>              check(index == wasIndex) {  <EOL>                  if (wasIndex <  <NUM_LIT:0> )  <STR_LIT>  <EOL>                  else  <STR_LIT>  <EOL>              }  <EOL>          }  <EOL>   <EOL>          override fun expectUnreached() {  <EOL>              error(\"Should not be reached, ${  <EOL>                  actionIndex.value.let {  <EOL>                      when {  <EOL>                          it <  <NUM_LIT:0>  ->  <STR_LIT>  <EOL>                          it ==  <NUM_LIT:0>  ->  <STR_LIT>  <EOL>                          else ->  <STR_LIT>  <EOL>                      }  <EOL>                  }  <EOL>              }\")  <EOL>          }  <EOL>   <EOL>          override fun checkFinishCall(allowNotUsingExpect: Boolean) {  <EOL>              actionIndex.value.let {  <EOL>                  assertTrue(  <EOL>                      it <  <NUM_LIT:0>  || allowNotUsingExpect && it ==  <NUM_LIT:0> ,  <EOL>                       <STR_LIT>  <EOL>                  )  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>  }  <EOL>   <EOL>  interface ErrorCatching {  <EOL>      /**  <EOL>       * Returns `true` if errors were logged in the test.  <EOL>       */  <EOL>      fun hasError(): Boolean  <EOL>   <EOL>      /**  <EOL>       * Directly reports an error to the test catching facilities.  <EOL>       */  <EOL>      fun reportError(error: Throwable)  <EOL>   <EOL>      class Impl : ErrorCatching {  <EOL>   <EOL>          private val errors = mutableListOf<Throwable>()  <EOL>          private val lock = SynchronizedObject()  <EOL>          private var closed = false  <EOL>   <EOL>          override fun hasError(): Boolean = synchronized(lock) {  <EOL>              errors.isNotEmpty()  <EOL>          }  <EOL>   <EOL>          override fun reportError(error: Throwable) {  <EOL>              synchronized(lock) {  <EOL>                  if (closed) {  <EOL>                      lastResortReportException(error)  <EOL>                  } else {  <EOL>                      errors.add(error)  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>   <EOL>          fun close() {  <EOL>              synchronized(lock) {  <EOL>                  if (closed) {  <EOL>                      lastResortReportException(IllegalStateException( <STR_LIT> ))  <EOL>                  }  <EOL>                  closed = true  <EOL>                  errors.firstOrNull()?.let {  <EOL>                      for (error in errors.drop( <NUM_LIT:1> ))  <EOL>                          it.addSuppressed(error)  <EOL>                      throw it  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Reports an error *somehow* so that it doesn't get completely forgotten.  <EOL>   */  <EOL>  internal expect fun lastResortReportException(error: Throwable)  <EOL>   <EOL>  /**  <EOL>   * Throws [IllegalStateException] when `value` is false, like `check` in stdlib, but also ensures that the  <EOL>   * test will not complete successfully even if this exception is consumed somewhere in the test.  <EOL>   */  <EOL>  public inline fun ErrorCatching.check(value: Boolean, lazyMessage: () -> Any) {  <EOL>      if (!value) error(lazyMessage())  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Throws [IllegalStateException], like `error` in stdlib, but also ensures that the test will not  <EOL>   * complete successfully even if this exception is consumed somewhere in the test.  <EOL>   */  <EOL>  fun ErrorCatching.error(message: Any, cause: Throwable? = null): Nothing {  <EOL>      throw IllegalStateException(message.toString(), cause).also {  <EOL>          reportError(it)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * A class inheriting from which allows to check the execution order inside tests.  <EOL>   *  <EOL>   * @see TestBase  <EOL>   */  <EOL>  open class OrderedExecutionTestBase : OrderedExecution  <EOL>  {  <EOL>      // TODO: move to by-delegation when [reset] is no longer needed.  <EOL>      private var orderedExecutionDelegate = OrderedExecution.Impl()  <EOL>   <EOL>      @AfterTest  <EOL>      fun checkFinished() { orderedExecutionDelegate.checkFinishCall() }  <EOL>   <EOL>      /** Resets counter and finish flag. Workaround for parametrized tests absence in common */  <EOL>      public fun reset() {  <EOL>          orderedExecutionDelegate.checkFinishCall()  <EOL>          orderedExecutionDelegate = OrderedExecution.Impl()  <EOL>      }  <EOL>   <EOL>      override fun expect(index: Int) = orderedExecutionDelegate.expect(index)  <EOL>   <EOL>      override fun finish(index: Int) = orderedExecutionDelegate.finish(index)  <EOL>   <EOL>      override fun expectUnreached() = orderedExecutionDelegate.expectUnreached()  <EOL>   <EOL>      override fun checkFinishCall(allowNotUsingExpect: Boolean) =  <EOL>          orderedExecutionDelegate.checkFinishCall(allowNotUsingExpect)  <EOL>  }  <EOL>   <EOL>  fun <T> T.void() {}  <EOL>   <EOL>  @OptionalExpectation  <EOL>  expect annotation class NoJs()  <EOL>   <EOL>  @OptionalExpectation  <EOL>  expect annotation class NoNative()  <EOL>   <EOL>  expect val isStressTest: Boolean  <EOL>  expect val stressTestMultiplier: Int  <EOL>  expect val stressTestMultiplierSqrt: Int  <EOL>   <EOL>  /**  <EOL>   * The result of a multiplatform asynchronous test.  <EOL>   * Aliases into Unit on K/JVM and K/N, and into Promise on K/JS.  <EOL>   */  <EOL>  @Suppress( <STR_LIT> )  <EOL>  public expect class TestResult  <EOL>   <EOL>  public expect open class TestBase(): OrderedExecutionTestBase, ErrorCatching {  <EOL>      public fun println(message: Any?)  <EOL>   <EOL>      public fun runTest(  <EOL>          expected: ((Throwable) -> Boolean)? = null,  <EOL>          unhandled: List<(Throwable) -> Boolean> = emptyList(),  <EOL>          block: suspend CoroutineScope.() -> Unit  <EOL>      ): TestResult  <EOL>  }  <EOL>   <EOL>  public suspend inline fun hang(onCancellation: () -> Unit) {  <EOL>      try {  <EOL>          suspendCancellableCoroutine<Unit> { }  <EOL>      } finally {  <EOL>          onCancellation()  <EOL>      }  <EOL>  }  <EOL>   <EOL>  suspend inline fun <reified T : Throwable> assertFailsWith(flow: Flow<*>) = assertFailsWith<T> { flow.collect() }  <EOL>   <EOL>  public suspend fun Flow<Int>.sum() = fold( <NUM_LIT:0> ) { acc, value -> acc + value }  <EOL>  public suspend fun Flow<Long>.longSum() = fold( <NUM_LIT:0> L) { acc, value -> acc + value }  <EOL>   <EOL>  // data is added to avoid stacktrace recovery because CopyableThrowable is not accessible from common modules  <EOL>  public class TestException(message: String? = null, private val data: Any? = null) : Throwable(message)  <EOL>  public class TestException <NUM_LIT:1> (message: String? = null, private val data: Any? = null) : Throwable(message)  <EOL>  public class TestException <NUM_LIT:2> (message: String? = null, private val data: Any? = null) : Throwable(message)  <EOL>  public class TestException <NUM_LIT> (message: String? = null, private val data: Any? = null) : Throwable(message)  <EOL>  public class TestCancellationException(message: String? = null, private val data: Any? = null) :  <EOL>      CancellationException(message)  <EOL>   <EOL>  public class TestRuntimeException(message: String? = null, private val data: Any? = null) : RuntimeException(message)  <EOL>  public class RecoverableTestException(message: String? = null) : RuntimeException(message)  <EOL>  public class RecoverableTestCancellationException(message: String? = null) : CancellationException(message)  <EOL>   <EOL>  public fun wrapperDispatcher(context: CoroutineContext): CoroutineContext {  <EOL>      val dispatcher = context[ContinuationInterceptor] as CoroutineDispatcher  <EOL>      return object : CoroutineDispatcher() {  <EOL>          override fun isDispatchNeeded(context: CoroutineContext): Boolean =  <EOL>              dispatcher.isDispatchNeeded(context)  <EOL>   <EOL>          override fun dispatch(context: CoroutineContext, block: Runnable) =  <EOL>              dispatcher.dispatch(context, block)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  public suspend fun wrapperDispatcher(): CoroutineContext = wrapperDispatcher(coroutineContext)  <EOL>  class BadClass {  <EOL>      override fun equals(other: Any?): Boolean = error( <STR_LIT:equals> )  <EOL>      override fun hashCode(): Int = error( <STR_LIT:hashCode> )  <EOL>      override fun toString(): String = error( <STR_LIT:toString> )  <EOL>  }  <EOL>   <EOL>  public expect val isJavaAndWindows: Boolean  <EOL>   <EOL>  public expect val isNative: Boolean  <EOL>   <EOL>  /*  <EOL>   * In common tests we emulate parameterized tests  <EOL>   * by iterating over parameters space in the single @Test method.  <EOL>   * This kind of tests is too slow for JS and does not fit into  <EOL>   * the default Mocha timeout, so we're using this flag to bail-out  <EOL>   * and run such tests only on JVM and K/N. ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlin.test.*  <EOL>  import kotlin.js.*  <EOL>   <EOL>  actual typealias NoJs = Ignore  <EOL>   <EOL>  actual val VERBOSE = false  <EOL>   <EOL>  actual val isStressTest: Boolean = false  <EOL>  actual val stressTestMultiplier: Int =  <NUM_LIT:1>  <EOL>  actual val stressTestMultiplierSqrt: Int =  <NUM_LIT:1>  <EOL>   <EOL>  @Suppress( <STR_LIT> ,  <STR_LIT> )  <EOL>  actual typealias TestResult = Promise<Unit>  <EOL>   <EOL>  internal actual fun lastResortReportException(error: Throwable) {  <EOL>      println(error)  <EOL>      console.log(error)  <EOL>  }  <EOL>   <EOL>  actual open class TestBase(  <EOL>      private val errorCatching: ErrorCatching.Impl  <EOL>  ): OrderedExecutionTestBase(), ErrorCatching by errorCatching {  <EOL>      private var lastTestPromise: Promise<*>? = null  <EOL>   <EOL>      actual constructor(): this(errorCatching = ErrorCatching.Impl())  <EOL>   <EOL>      actual fun println(message: Any?) {  <EOL>          kotlin.io.println(message)  <EOL>      }  <EOL>   <EOL>      actual fun runTest(  <EOL>          expected: ((Throwable) -> Boolean)?,  <EOL>          unhandled: List<(Throwable) -> Boolean>,  <EOL>          block: suspend CoroutineScope.() -> Unit  <EOL>      ): TestResult {  <EOL>          var exCount =  <NUM_LIT:0>  <EOL>          var ex: Throwable? = null  <EOL>          /*  <EOL>           * This is an additional sanity check against `runTest` mis-usage on JS.  <EOL>           * The only way to write an async test on JS is to return Promise from the test function.  <EOL>           * _Just_ launching promise and returning `Unit` won't suffice as the underlying test framework  <EOL>           * won't be able to detect an asynchronous failure in a timely manner.  <EOL>           * We cannot detect such situations, but we can detect the most common erroneous pattern  <EOL>           * in our code base, an attempt to use multiple `runTest` in the same `@Test` method,  <EOL>           * which typically is a premise to the same error:  <EOL>           * ```  <EOL>           * @Test  <EOL>           * fun incorrectTestForJs() { // <- promise is not returned  <EOL>           *     for (parameter in parameters) {  <EOL>           *         runTest {  <EOL>           *             runTestForParameter(parameter)  <EOL>           *         }  <EOL>           *     }  <EOL>           * }  <EOL>           * ```  <EOL>           */  <EOL>          if (lastTestPromise != null) {  <EOL>              error( <STR_LIT> )  <EOL>          }  <EOL>          val result = GlobalScope.promise(block = block, context = CoroutineExceptionHandler { _, e ->  <EOL>              if (e is CancellationException) return@CoroutineExceptionHandler // are ignored  <EOL>              exCount++  <EOL>              when {  <EOL>                  exCount > unhandled.size ->  <EOL>                      error( <STR_LIT> , e)  <EOL>                  !unhandled[exCount -  <NUM_LIT:1> ](e) ->  <EOL>                      error( <STR_LIT> , e)  <EOL>              }  <EOL>          }).catch { e ->  <EOL>              ex = e  <EOL>              if (expected != null) {  <EOL>                  if (!expected(e)) {  <EOL>                      console.log(e)  <EOL>                      error( <STR_LIT> , e)  <EOL>                  }  <EOL>              } else  <EOL>                  throw e  <EOL>          }.finally {  <EOL>              if (ex == null && expected != null) error( <STR_LIT> )  <EOL>              if (exCount < unhandled.size)  <EOL>                  error( <STR_LIT> )  <EOL>              errorCatching.close()  <EOL>              checkFinishCall()  <EOL>          }  <EOL>          lastTestPromise = result  <EOL>          return result  <EOL>      }  <EOL>  }  <EOL>   <EOL>  actual val isNative = false  <EOL>   <EOL>  actual val isBoundByJsTestTimeout = true ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing.exceptions  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import java.io.*  <EOL>  import java.util.*  <EOL>  import kotlin.contracts.*  <EOL>  import kotlin.coroutines.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  inline fun <reified T : Throwable> checkException(exception: Throwable) {  <EOL>      assertIs<T>(exception)  <EOL>      assertTrue(exception.suppressed.isEmpty())  <EOL>      assertNull(exception.cause)  <EOL>  }  <EOL>   <EOL>  fun checkCycles(t: Throwable) {  <EOL>      val sw = StringWriter()  <EOL>      t.printStackTrace(PrintWriter(sw))  <EOL>      assertFalse(sw.toString().contains( <STR_LIT> ))  <EOL>  }  <EOL>   <EOL>  class CapturingHandler : AbstractCoroutineContextElement(CoroutineExceptionHandler),  <EOL>      CoroutineExceptionHandler  <EOL>  {  <EOL>      private var unhandled: ArrayList<Throwable>? = ArrayList()  <EOL>   <EOL>      override fun handleException(context: CoroutineContext, exception: Throwable) = synchronized<Unit>(this) {  <EOL>          unhandled!!.add(exception)  <EOL>      }  <EOL>   <EOL>      fun getException(): Throwable = synchronized(this) {  <EOL>          val size = unhandled!!.size  <EOL>          assert(size ==  <NUM_LIT:1> ) {  <STR_LIT>  }  <EOL>          return unhandled!![ <NUM_LIT:0> ].also { unhandled = null }  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun captureExceptionsRun(  <EOL>      context: CoroutineContext = EmptyCoroutineContext,  <EOL>      block: suspend CoroutineScope.() -> Unit  <EOL>  ): Throwable {  <EOL>      val handler = CapturingHandler()  <EOL>      runBlocking(context + handler, block = block)  <EOL>      return handler.getException()  <EOL>  }  <EOL>   <EOL>  @OptIn(ExperimentalContracts::class)  <EOL>  suspend inline fun <reified E: Throwable> assertCallsExceptionHandlerWith(  <EOL>      crossinline operation: suspend (CoroutineExceptionHandler) -> Unit): E {  <EOL>      contract {  <EOL>          callsInPlace(operation, InvocationKind.EXACTLY_ONCE)  <EOL>      }  <EOL>      val handler = CapturingHandler()  <EOL>      return withContext(handler) {  <EOL>          operation(handler)  <EOL>          assertIs<E>(handler.getException()) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.rules.*  <EOL>  import org.junit.runner.*  <EOL>  import org.junit.runners.model.*  <EOL>  import java.lang.Runnable  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  class ExecutorRule(private val numberOfThreads: Int) : TestRule, ExecutorCoroutineDispatcher() {  <EOL>   <EOL>      private var _executor: ExecutorCoroutineDispatcher? = null  <EOL>      override val executor: Executor  <EOL>          get() = _executor?.executor ?: error( <STR_LIT> )  <EOL>   <EOL>      override fun apply(base: Statement, description: Description): Statement {  <EOL>          return object : Statement() {  <EOL>              override fun evaluate() {  <EOL>                  val threadPrefix = description.className.substringAfterLast( <STR_LIT> ) +  <STR_LIT>  + description.methodName  <EOL>                  _executor = newFixedThreadPoolContext(numberOfThreads, threadPrefix)  <EOL>                  ignoreLostThreads(threadPrefix)  <EOL>                  try {  <EOL>                      return base.evaluate()  <EOL>                  } finally {  <EOL>                      val service = executor as ExecutorService  <EOL>                      service.shutdown()  <EOL>                      if (!service.awaitTermination( <NUM_LIT:10> , TimeUnit.SECONDS)) {  <EOL>                          error( <STR_LIT> )  <EOL>                      }  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      override fun dispatch(context: CoroutineContext, block: Runnable) {  <EOL>          _executor?.dispatch(context, block) ?: error( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun close() {  <EOL>          error( <STR_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing  <EOL>   <EOL>  import java.lang.ref.*  <EOL>  import java.lang.reflect.*  <EOL>  import java.text.*  <EOL>  import java.util.*  <EOL>  import java.util.Collections.*  <EOL>  import java.util.concurrent.*  <EOL>  import java.util.concurrent.atomic.*  <EOL>  import java.util.concurrent.locks.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  object FieldWalker {  <EOL>      sealed class Ref {  <EOL>          object RootRef : Ref()  <EOL>          class FieldRef(val parent: Any, val name: String) : Ref()  <EOL>          class ArrayRef(val parent: Any, val index: Int) : Ref()  <EOL>      }  <EOL>   <EOL>      private val fieldsCache = HashMap<Class<*>, List<Field>>()  <EOL>   <EOL>      init {  <EOL>          // excluded/terminal classes (don't walk them)  <EOL>          fieldsCache += listOf(  <EOL>              Any::class, String::class, Thread::class, Throwable::class, StackTraceElement::class,  <EOL>              WeakReference::class, ReferenceQueue::class, AbstractMap::class, Enum::class,  <EOL>              ReentrantLock::class, ReentrantReadWriteLock::class, SimpleDateFormat::class, ThreadPoolExecutor::class,  <EOL>              CountDownLatch::class,  <EOL>          )  <EOL>              .map { it.java }  <EOL>              .associateWith { emptyList() }  <EOL>      }  <EOL>   <EOL>      /*  <EOL>       * Reflectively starts to walk through object graph and returns identity set of all reachable objects.  <EOL>       * Use [walkRefs] if you need a path from root for debugging.  <EOL>       */  <EOL>      public fun walk(root: Any?): Set<Any> = walkRefs(root, false).keys  <EOL>   <EOL>      public fun assertReachableCount(expected: Int, root: Any?, rootStatics: Boolean = false, predicate: (Any) -> Boolean) {  <EOL>          val visited = walkRefs(root, rootStatics)  <EOL>          val actual = visited.keys.filter(predicate)  <EOL>          if (actual.size != expected) {  <EOL>              val textDump = actual.joinToString( <STR_LIT> ) {  <STR_LIT>  + showPath(it, visited) }  <EOL>              assertEquals(  <EOL>                  expected, actual.size,  <EOL>                   <STR_LIT>  <EOL>              )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      /*  <EOL>       * Reflectively starts to walk through object graph and map to all the reached object to their path  <EOL>       * in from root. Use [showPath] do display a path if needed.  <EOL>       */  <EOL>      private fun walkRefs(root: Any?, rootStatics: Boolean): IdentityHashMap<Any, Ref> {  <EOL>          val visited = IdentityHashMap<Any, Ref>()  <EOL>          if (root == null) return visited  <EOL>          visited[root] = Ref.RootRef  <EOL>          val stack = ArrayDeque<Any>()  <EOL>          stack.addLast(root)  <EOL>          var statics = rootStatics  <EOL>          while (stack.isNotEmpty()) {  <EOL>              val element = stack.removeLast()  <EOL>              try {  <EOL>                  visit(element, visited, stack, statics)  <EOL>                  statics = false // only scan root static when asked  <EOL>              } catch (e: Exception) {  <EOL>                  error( <STR_LIT> )  <EOL>              }  <EOL>          }  <EOL>          return visited  <EOL>      }  <EOL>   <EOL>      private fun showPath(element: Any, visited: Map<Any, Ref>): String {  <EOL>          val path = ArrayList<String>()  <EOL>          var cur = element  <EOL>          while (true) {  <EOL>              when (val ref = visited.getValue(cur)) {  <EOL>                  Ref.RootRef -> break  <EOL>                  is Ref.FieldRef -> {  <EOL>                      cur = ref.parent  <EOL>                      path +=  <STR_LIT>  <EOL>                  }  <EOL>                  is Ref.ArrayRef -> {  <EOL>                      cur = ref.parent  <EOL>                      path +=  <STR_LIT>  <EOL>                  }  <EOL>                  else -> {  <EOL>                      // Nothing, kludge for IDE  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>          path.reverse()  <EOL>          return path.joinToString( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      private fun visit(element: Any, visited: IdentityHashMap<Any, Ref>, stack: ArrayDeque<Any>, statics: Boolean) {  <EOL>          val type = element.javaClass  <EOL>          when {  <EOL>              // Special code for arrays  <EOL>              type.isArray && !type.componentType.isPrimitive -> {  <EOL>                  @Suppress( <STR_LIT> )  <EOL>                  val array = element as Array<Any?>  <EOL>                  array.forEachIndexed { index, value ->  <EOL>                      push(value, visited, stack) { Ref.ArrayRef(element, index) }  <EOL>                  }  <EOL>              }  <EOL>              // Special code for platform types that cannot be reflectively accessed on modern JDKs  <EOL>              type.name.startsWith( <STR_LIT> ) && element is Collection<*> -> {  <EOL>                  element.forEachIndexed { index, value ->  <EOL>                      push(value, visited, stack) { Ref.ArrayRef(element, index) }  <EOL>                  }  <EOL>              }  <EOL>              type.name.startsWith( <STR_LIT> ) && element is Map<*, *> -> {  <EOL>                  push(element.keys, visited, stack) { Ref.FieldRef(element,  <STR_LIT> ) }  <EOL>                  push(element.values, visited, stack) { Ref.FieldRef(element,  <STR_LIT> ) }  <EOL>              }  <EOL>              element is AtomicReference<*> -> {  <EOL>                  push(element.get(), visited, stack) { Ref.FieldRef(element,  <STR_LIT> ) }  <EOL>              }  <EOL>              element is AtomicReferenceArray<*> -> {  <EOL>                  for (index in  <NUM_LIT:0>  until element.length()) {  <EOL>                      push(element[index], visited, stack) { Ref.ArrayRef(element, index) }  <EOL>                  }  <EOL>              }  <EOL>              element is AtomicLongFieldUpdater<*> -> {  <EOL>                  /* filter it out here to suppress its subclasses too */  <EOL>              }  <EOL>              // All the other classes are reflectively scanned  <EOL>              else -> fields(type, statics).forEach { field ->  <EOL>                  push(field.get(element), visited, stack) { Ref.FieldRef(element, field.name) }  <EOL>                  // special case to scan Throwable cause (cannot get it reflectively)  <EOL>                  if (element is Throwable) {  <EOL>                      push(element.cause, visited, stack) { Ref.FieldRef(element,  <STR_LIT> ) }  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      private inline fun push(value: Any?, visited: IdentityHashMap<Any, Ref>, stack: ArrayDeque<Any>, ref: () -> Ref) {  <EOL>          if (value != null && !visited.containsKey(value)) {  <EOL>              visited[value] = ref()  <EOL>              stack.addLast(value)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      private fun fields(type <NUM_LIT:0> : Class<*>, rootStatics: Boolean): List<Field> {  <EOL>          fieldsCache[type <NUM_LIT:0> ]?.let { return it }  <EOL>          val result = ArrayList<Field>()  <EOL>          var type = type <NUM_LIT:0>  <EOL>          var statics = rootStatics  <EOL>          while (true) {  <EOL>              val fields = type.declaredFields.filter {  <EOL>                  !it.type.isPrimitive  <EOL>                      && (statics || !Modifier.isStatic(it.modifiers))  <EOL>                      && !(it.type.isArray && it.type.componentType.isPrimitive)  <EOL>                      && it.name !=  <STR_LIT>  // System.out from TestBase that we store in a field to restore later  <EOL>              }  <EOL>              check(fields.isEmpty() || !type.name.startsWith( <STR_LIT> )) {  <EOL>                   <STR_LIT> \"  <EOL>                      Trying to walk through JDK's '$type' will get into illegal reflective access on JDK  <NUM_LIT> +.  <EOL>                      Either modify your test to avoid usage of this class or update FieldWalker code to retrieve   <EOL>                      the captured state of this class without going through reflection (see how collections are handled).    <EOL>                   <STR_LIT> \".trimIndent()  <EOL>              }  <EOL>              fields.forEach { it.isAccessible = true } // make them all accessible  <EOL>              result.addAll(fields)  <EOL>              type = type.superclass  <EOL>              statics = false  <EOL>              val superFields = fieldsCache[type] // will stop at Any anyway  <EOL>              if (superFields != null) {  <EOL>                  result.addAll(superFields)  <EOL>                  break  <EOL>              }  <EOL>          }  <EOL>          fieldsCache[type <NUM_LIT:0> ] = result  <EOL>          return result ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing  <EOL>   <EOL>  import kotlinx.coroutines.scheduling.*  <EOL>  import java.io.*  <EOL>  import java.util.*  <EOL>  import kotlin.coroutines.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  actual val VERBOSE = try {  <EOL>      System.getProperty( <STR_LIT> )?.toBoolean() ?: false  <EOL>  } catch (e: SecurityException) {  <EOL>      false  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Is `true` when running in a nightly stress test mode.  <EOL>   */  <EOL>  actual val isStressTest = System.getProperty( <STR_LIT> )?.toBoolean() ?: false  <EOL>   <EOL>  actual val stressTestMultiplierSqrt = if (isStressTest)  <NUM_LIT>  else  <NUM_LIT:1>  <EOL>   <EOL>  private const val SHUTDOWN_TIMEOUT =  <NUM_LIT:1> _ <NUM_LIT> L //  <NUM_LIT:1> s at most to wait per thread  <EOL>   <EOL>  /**  <EOL>   * Multiply various constants in stress tests by this factor, so that they run longer during nightly stress test.  <EOL>   */  <EOL>  actual val stressTestMultiplier = stressTestMultiplierSqrt * stressTestMultiplierSqrt  <EOL>   <EOL>   <EOL>  @Suppress( <STR_LIT> )  <EOL>  actual typealias TestResult = Unit  <EOL>   <EOL>  internal actual fun lastResortReportException(error: Throwable) {  <EOL>      System.err.println( <STR_LIT> : $it <STR_LIT> <STR_LIT> )  <EOL>      error.cause?.printStackTrace(System.err)  <EOL>      System.err.println( <STR_LIT> )  <EOL>      Throwable().printStackTrace(System.err)  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Base class for tests, so that tests for predictable scheduling of actions in multiple coroutines sharing a single  <EOL>   * thread can be written. Use it like this:  <EOL>   *  <EOL>   * ```  <EOL>   * class MyTest : TestBase() {  <EOL>   *    @Test  <EOL>   *    fun testSomething() = runBlocking { // run in the context of the main thread  <EOL>   *        expect( <NUM_LIT:1> ) // initiate action counter  <EOL>   *        launch { // use the context of the main thread  <EOL>   *           expect( <NUM_LIT> ) // the body of this coroutine in going to be executed in the  <NUM_LIT> rd step  <EOL>   *        }  <EOL>   *        expect( <NUM_LIT:2> ) // launch just scheduled coroutine for execution later, so this line is executed second  <EOL>   *        yield() // yield main thread to the launched job  <EOL>   *        finish( <NUM_LIT> ) // fourth step is the last one. `finish` must be invoked or test fails  <EOL>   *    }  <EOL>   * }  <EOL>   * ```  <EOL>   */  <EOL>  actual open class TestBase(  <EOL>      private var disableOutCheck: Boolean,  <EOL>      private val errorCatching: ErrorCatching.Impl = ErrorCatching.Impl()  <EOL>  ): OrderedExecutionTestBase(), ErrorCatching by errorCatching {  <EOL>   <EOL>      actual constructor(): this(false)  <EOL>   <EOL>      // Shutdown sequence  <EOL>      private lateinit var threadsBefore: Set<Thread>  <EOL>      private val uncaughtExceptions = Collections.synchronizedList(ArrayList<Throwable>())  <EOL>      private var originalUncaughtExceptionHandler: Thread.UncaughtExceptionHandler? = null  <EOL>      /*  <EOL>       * System.out that we redefine in order to catch any debugging/diagnostics  <EOL>       * 'println' from main source set.  <EOL>       * NB: We do rely on the name 'previousOut' in the FieldWalker in order to skip its  <EOL>       * processing  <EOL>       */  <EOL>      private lateinit var previousOut: PrintStream  <EOL>   <EOL>      private object TestOutputStream : PrintStream(object : OutputStream() {  <EOL>          override fun write(b: Int) {  <EOL>              error( <STR_LIT> )  <EOL>          }  <EOL>      })  <EOL>   <EOL>      actual fun println(message: Any?) {  <EOL>          if (disableOutCheck) kotlin.io.println(message)  <EOL>          else previousOut.println(message)  <EOL>      }  <EOL>   <EOL>      @BeforeTest  <EOL>      fun before() {  <EOL>          initPoolsBeforeTest()  <EOL>          threadsBefore = currentThreads()  <EOL>          originalUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler()  <EOL>          Thread.setDefaultUncaughtExceptionHandler { t, e ->  <EOL>              println( <STR_LIT> ) // The same message as in default handler  <EOL>              e.printStackTrace()  <EOL>              uncaughtExceptions.add(e)  <EOL>          }  <EOL>          if (!disableOutCheck) {  <EOL>              previousOut = System.out  <EOL>              System.setOut(TestOutputStream)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @AfterTest  <EOL>      fun onCompletion() {  <EOL>          // onCompletion should not throw exceptions before it finishes all cleanup, so that other tests always  <EOL>          // start in a clear, restored state  <EOL>          checkFinishCall()  <EOL>          if (!disableOutCheck) { // Restore global System.out first  <EOL>              System.setOut(previousOut)  <EOL>          }  <EOL>          // Shutdown all thread pools  <EOL>          shutdownPoolsAfterTest()  <EOL>          // Check that are now leftover threads  <EOL>          runCatching {  <EOL>              checkTestThreads(threadsBefore)  <EOL>          }.onFailure {  <EOL>              reportError(it)  <EOL>          }  <EOL>          // Restore original uncaught exception handler after the main shutdown sequence  <EOL>          Thread.setDefaultUncaughtExceptionHandler(originalUncaughtExceptionHandler)  <EOL>          if (uncaughtExceptions.isNotEmpty()) {  <EOL>              error( <STR_LIT> )  <EOL>          }  <EOL>          // The very last action -- throw error if any was detected  <EOL>          errorCatching.close()  <EOL>      }  <EOL>   <EOL>      actual fun runTest(  <EOL>          expected: ((Throwable) -> Boolean)?,  <EOL>          unhandled: List<(Throwable) -> Boolean>,  <EOL>          block: suspend CoroutineScope.() -> Unit  <EOL>      ): TestResult {  <EOL>          var exCount =  <NUM_LIT:0>  <EOL>          var ex: Throwable? = null  <EOL>          try {  <EOL>              runBlocking(block = block, context = CoroutineExceptionHandler { _, e ->  <EOL>                  if (e is CancellationException) return@CoroutineExceptionHandler // are ignored  <EOL>                  exCount++  <EOL>                  when {  <EOL>                      exCount > unhandled.size ->  <EOL>                          error( <STR_LIT> , e)  <EOL>                      !unhandled[exCount -  <NUM_LIT:1> ](e) ->  <EOL>                          error( <STR_LIT> , e)  <EOL>                  }  <EOL>              })  <EOL>          } catch (e: Throwable) {  <EOL>              ex = e  <EOL>              if (expected != null) {  <EOL>                  if (!expected(e))  <EOL>                      error( <STR_LIT> , e)  <EOL>              } else {  <EOL>                  throw e  <EOL>              }  <EOL>          } finally {  <EOL>              if (ex == null && expected != null) error( <STR_LIT> )  <EOL>          }  <EOL>          if (exCount < unhandled.size)  <EOL>              error( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      protected suspend fun currentDispatcher() = coroutineContext[ContinuationInterceptor]!!  <EOL>  }  <EOL>   <EOL>  @Suppress( <STR_LIT> ,  <STR_LIT> )  <EOL>  fun initPoolsBeforeTest() {  <EOL>      DefaultScheduler.usePrivateScheduler()  <EOL>  }  <EOL>   <EOL>  @Suppress( <STR_LIT> ,  <STR_LIT> )  <EOL>  fun shutdownPoolsAfterTest() {  <EOL>      DefaultScheduler.shutdown(SHUTDOWN_TIMEOUT)  <EOL>      DefaultExecutor.shutdownForTests(SHUTDOWN_TIMEOUT)  <EOL>      DefaultScheduler.restore()  <EOL>  }  <EOL>   <EOL>  actual val isNative = false  <EOL>   <EOL>  actual val isBoundByJsTestTimeout = false  <EOL>   <EOL>  /*  <EOL>   * We ignore tests that test **real** non-virtualized tests with time on Windows, because  <EOL>   * our CI Windows is virtualized itself (oh, the irony) and its clock resolution is dozens of ms,  <EOL>   * which makes such tests flaky. ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import java.lang.Runnable  <EOL>   <EOL>  private const val WAIT_LOST_THREADS =  <NUM_LIT:10> _ <NUM_LIT> L //  <NUM_LIT:10> s  <EOL>  private val ignoreLostThreads = mutableSetOf<String>()  <EOL>   <EOL>  fun ignoreLostThreads(vararg s: String) { ignoreLostThreads += s }  <EOL>   <EOL>  fun currentThreads(): Set<Thread> {  <EOL>      var estimate =  <NUM_LIT:0>  <EOL>      while (true) {  <EOL>          estimate = estimate.coerceAtLeast(Thread.activeCount() +  <NUM_LIT:1> )  <EOL>          val arrayOfThreads = Array<Thread?>(estimate) { null }  <EOL>          val n = Thread.enumerate(arrayOfThreads)  <EOL>          if (n >= estimate) {  <EOL>              estimate = n +  <NUM_LIT:1>  <EOL>              continue // retry with a better size estimate  <EOL>          }  <EOL>          val threads = hashSetOf<Thread>()  <EOL>          for (i in  <NUM_LIT:0>  until n)  <EOL>              threads.add(arrayOfThreads[i]!!)  <EOL>          return threads  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun List<Thread>.dumpThreads(header: String) {  <EOL>      println( <STR_LIT> )  <EOL>      forEach { thread ->  <EOL>          println( <STR_LIT> ${thread.name}\\ <STR_LIT> )  <EOL>          val trace = thread.stackTrace  <EOL>          for (t in trace) println( <STR_LIT> )  <EOL>          println()  <EOL>      }  <EOL>      println( <STR_LIT> )  <EOL>  }  <EOL>   <EOL>  class PoolThread(  <EOL>      @JvmField val dispatcher: ExecutorCoroutineDispatcher, // for debugging & tests  <EOL>      target: Runnable, name: String  <EOL>  ) : Thread(target, name) {  <EOL>      init {  <EOL>          isDaemon = true  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun ExecutorCoroutineDispatcher.dumpThreads(header: String) =  <EOL>      currentThreads().filter { it is PoolThread && it.dispatcher == this@dumpThreads }.dumpThreads(header)  <EOL>   <EOL>  fun checkTestThreads(threadsBefore: Set<Thread>) {  <EOL>      // give threads some time to shutdown  <EOL>      val waitTill = System.currentTimeMillis() + WAIT_LOST_THREADS  <EOL>      var diff: List<Thread>  <EOL>      do {  <EOL>          val threadsAfter = currentThreads()  <EOL>          diff = (threadsAfter - threadsBefore).filter { thread ->  <EOL>              ignoreLostThreads.none { prefix -> thread.name.startsWith(prefix) }  <EOL>          }  <EOL>          if (diff.isEmpty()) break  <EOL>      } while (System.currentTimeMillis() <= waitTill)  <EOL>      ignoreLostThreads.clear()  <EOL>      if (diff.isEmpty()) return  <EOL>      val message =  <STR_LIT>  <EOL>      println( <STR_LIT> )  <EOL>      diff.dumpThreads( <STR_LIT> ) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing  <EOL>   <EOL>  import kotlin.test.*  <EOL>  import kotlinx.coroutines.*  <EOL>   <EOL>  actual val VERBOSE = false  <EOL>   <EOL>  actual typealias NoNative = Ignore  <EOL>   <EOL>  public actual val isStressTest: Boolean = false  <EOL>  public actual val stressTestMultiplier: Int =  <NUM_LIT:1>  <EOL>  public actual val stressTestMultiplierSqrt: Int =  <NUM_LIT:1>  <EOL>   <EOL>  @Suppress( <STR_LIT> )  <EOL>  public actual typealias TestResult = Unit  <EOL>   <EOL>  internal actual fun lastResortReportException(error: Throwable) {  <EOL>      println(error)  <EOL>  }  <EOL>   <EOL>  public actual open class TestBase actual constructor(): OrderedExecutionTestBase(), ErrorCatching by ErrorCatching.Impl() {  <EOL>      actual fun println(message: Any?) {  <EOL>          kotlin.io.println(message)  <EOL>      }  <EOL>   <EOL>      public actual fun runTest(  <EOL>          expected: ((Throwable) -> Boolean)?,  <EOL>          unhandled: List<(Throwable) -> Boolean>,  <EOL>          block: suspend CoroutineScope.() -> Unit  <EOL>      ): TestResult {  <EOL>          var exCount =  <NUM_LIT:0>  <EOL>          var ex: Throwable? = null  <EOL>          try {  <EOL>              runBlocking(block = block, context = CoroutineExceptionHandler { _, e ->  <EOL>                  if (e is CancellationException) return@CoroutineExceptionHandler // are ignored  <EOL>                  exCount++  <EOL>                  when {  <EOL>                      exCount > unhandled.size ->  <EOL>                          error( <STR_LIT> , e)  <EOL>                      !unhandled[exCount -  <NUM_LIT:1> ](e) ->  <EOL>                          error( <STR_LIT> , e)  <EOL>                  }  <EOL>              })  <EOL>          } catch (e: Throwable) {  <EOL>              ex = e  <EOL>              if (expected != null) {  <EOL>                  if (!expected(e))  <EOL>                      error( <STR_LIT> , e)  <EOL>              } else  <EOL>                  throw e  <EOL>          } finally {  <EOL>              if (ex == null && expected != null) error( <STR_LIT> )  <EOL>          }  <EOL>          if (exCount < unhandled.size)  <EOL>              error( <STR_LIT> )  <EOL>      }  <EOL>  }  <EOL>   <EOL>  public actual val isNative = true  <EOL>   <EOL>  public actual val isBoundByJsTestTimeout = false ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.testing  <EOL>   <EOL>  import kotlin.test.*  <EOL>  import kotlin.js.*  <EOL>  import kotlinx.coroutines.*  <EOL>   <EOL>  actual val VERBOSE = false  <EOL>   <EOL>  actual typealias NoJs = Ignore  <EOL>   <EOL>  actual val isStressTest: Boolean = false  <EOL>  actual val stressTestMultiplier: Int =  <NUM_LIT:1>  <EOL>  actual val stressTestMultiplierSqrt: Int =  <NUM_LIT:1>  <EOL>   <EOL>  @Suppress( <STR_LIT> ,  <STR_LIT> )  <EOL>  actual typealias TestResult = Promise<JsAny?>  <EOL>   <EOL>  internal actual fun lastResortReportException(error: Throwable) {  <EOL>      println(error)  <EOL>  }  <EOL>   <EOL>  actual open class TestBase(  <EOL>      private val errorCatching: ErrorCatching.Impl  <EOL>  ): OrderedExecutionTestBase(), ErrorCatching by errorCatching {  <EOL>      private var lastTestPromise: Promise<JsAny?>? = null  <EOL>   <EOL>      actual constructor(): this(errorCatching = ErrorCatching.Impl())  <EOL>   <EOL>      actual fun println(message: Any?) {  <EOL>          kotlin.io.println(message)  <EOL>      }  <EOL>   <EOL>      actual fun runTest(  <EOL>          expected: ((Throwable) -> Boolean)?,  <EOL>          unhandled: List<(Throwable) -> Boolean>,  <EOL>          block: suspend CoroutineScope.() -> Unit  <EOL>      ): TestResult {  <EOL>          var exCount =  <NUM_LIT:0>  <EOL>          var ex: Throwable? = null  <EOL>          /*  <EOL>           * This is an additional sanity check against `runTest` mis-usage on JS.  <EOL>           * The only way to write an async test on JS is to return Promise from the test function.  <EOL>           * _Just_ launching promise and returning `Unit` won't suffice as the underlying test framework  <EOL>           * won't be able to detect an asynchronous failure in a timely manner.  <EOL>           * We cannot detect such situations, but we can detect the most common erroneous pattern  <EOL>           * in our code base, an attempt to use multiple `runTest` in the same `@Test` method,  <EOL>           * which typically is a premise to the same error:  <EOL>           * ```  <EOL>           * @Test  <EOL>           * fun incorrectTestForJs() { // <- promise is not returned  <EOL>           *     for (parameter in parameters) {  <EOL>           *         runTest {  <EOL>           *             runTestForParameter(parameter)  <EOL>           *         }  <EOL>           *     }  <EOL>           * }  <EOL>           * ```  <EOL>           */  <EOL>          if (lastTestPromise != null) {  <EOL>              error( <STR_LIT> )  <EOL>          }  <EOL>          val result = GlobalScope.promise(block = block, context = CoroutineExceptionHandler { _, e ->  <EOL>              if (e is CancellationException) return@CoroutineExceptionHandler // are ignored  <EOL>              exCount++  <EOL>              when {  <EOL>                  exCount > unhandled.size ->  <EOL>                      error( <STR_LIT> , e)  <EOL>                  !unhandled[exCount -  <NUM_LIT:1> ](e) ->  <EOL>                      error( <STR_LIT> , e)  <EOL>              }  <EOL>          }).catch { jsE ->  <EOL>              val e = jsE.toThrowableOrNull() ?: error( <STR_LIT> )  <EOL>              ex = e  <EOL>              if (expected != null) {  <EOL>                  if (!expected(e)) {  <EOL>                      println(e)  <EOL>                      error( <STR_LIT> , e)  <EOL>                  }  <EOL>              } else  <EOL>                  throw e  <EOL>              null  <EOL>          }.finally {  <EOL>              if (ex == null && expected != null) error( <STR_LIT> )  <EOL>              if (exCount < unhandled.size)  <EOL>                  error( <STR_LIT> )  <EOL>              errorCatching.close()  <EOL>              checkFinishCall()  <EOL>          }  <EOL>          lastTestPromise = result  <EOL>          return result  <EOL>      }  <EOL>  }  <EOL>   <EOL>  actual val isNative = false  <EOL>   <EOL>  actual val isBoundByJsTestTimeout = true ", "gt": ""}
{"input": "<s> project.configureAar()  <EOL>   <EOL>  dependencies {  <EOL>      configureAarUnpacking()  <EOL>   <EOL>      testImplementation( <STR_LIT> android <STR_LIT> )  <EOL>      testImplementation( <STR_LIT> robolectric <STR_LIT> )  <EOL>      // Required by robolectric  <EOL>      testImplementation( <STR_LIT> )  <EOL>      testImplementation( <STR_LIT> )  <EOL>   <EOL>      testImplementation(project( <STR_LIT> )) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.android  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  // Classes for testing service loader  <EOL>  internal class EmptyCoroutineScopeImpl <NUM_LIT:1>  : CoroutineScope {  <EOL>      override val coroutineContext: CoroutineContext  <EOL>          get() = EmptyCoroutineContext  <EOL>  }  <EOL>   <EOL>  internal class EmptyCoroutineScopeImpl <NUM_LIT:2>  : CoroutineScope {  <EOL>      override val coroutineContext: CoroutineContext  <EOL>          get() = EmptyCoroutineContext  <EOL>  }  <EOL>   <EOL>  internal class EmptyCoroutineScopeImpl <NUM_LIT>  : CoroutineScope {  <EOL>      override val coroutineContext: CoroutineContext ", "gt": ""}
{"input": "<s> package ordered.tests  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.test.*  <EOL>  import org.junit.Test  <EOL>  import org.junit.runner.*  <EOL>  import org.robolectric.*  <EOL>  import org.robolectric.annotation.*  <EOL>  import org.robolectric.shadows.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>   <EOL>  class InitMainDispatcherBeforeRobolectricTestRunner(testClass: Class<*>) : RobolectricTestRunner(testClass) {  <EOL>   <EOL>      init {  <EOL>          kotlin.runCatching {  <EOL>              // touch Main, watch it burn  <EOL>              GlobalScope.launch(Dispatchers.Main + CoroutineExceptionHandler { _, _ -> }) {  }  <EOL>          }  <EOL>      }  <EOL>  }  <EOL>   <EOL>  @Config(manifest = Config.NONE, sdk = [ <NUM_LIT> ])  <EOL>  @RunWith(InitMainDispatcherBeforeRobolectricTestRunner::class)  <EOL>  @LooperMode(LooperMode.Mode.LEGACY)  <EOL>  class CustomizedRobolectricTest : TestBase() {  <EOL>      @Test  <EOL>      fun testComponent()  {  <EOL>          // Note that main is not set at all  <EOL>          val component = TestComponent()  <EOL>          checkComponent(component)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testComponentAfterReset()  {  <EOL>          // Note that main is not set at all  <EOL>          val component = TestComponent()  <EOL>          Dispatchers.setMain(Dispatchers.Unconfined)  <EOL>          Dispatchers.resetMain()  <EOL>          checkComponent(component)  <EOL>      }  <EOL>   <EOL>   <EOL>      private fun checkComponent(component: TestComponent) {  <EOL>          val mainLooper = ShadowLooper.getShadowMainLooper()  <EOL>          mainLooper.pause()  <EOL>          component.launchSomething()  <EOL>          assertFalse(component.launchCompleted)  <EOL>          mainLooper.unPause()  <EOL>          assertTrue(component.launchCompleted) ", "gt": ""}
{"input": "<s> package ordered.tests  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.test.*  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import java.lang.IllegalStateException  <EOL>  import kotlin.test.*  <EOL>   <EOL>  open class FirstMockedMainTest : TestBase() {  <EOL>   <EOL>      @Before  <EOL>      fun setUp() {  <EOL>          Dispatchers.setMain(Dispatchers.Unconfined)  <EOL>      }  <EOL>   <EOL>      @After  <EOL>      fun tearDown() {  <EOL>          Dispatchers.resetMain()  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testComponent() {  <EOL>          val component = TestComponent()  <EOL>          component.launchSomething()  <EOL>          assertTrue(component.launchCompleted)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFailureWhenReset() {  <EOL>          Dispatchers.resetMain()  <EOL>          val component = TestComponent()  <EOL>          try {  <EOL>              component.launchSomething()  <EOL>              throw component.caughtException  <EOL>          } catch (e: IllegalStateException) {  <EOL>              assertTrue(e.message!!.contains( <STR_LIT> ))  <EOL>          } ", "gt": ""}
{"input": "<s> package ordered.tests  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.test.*  <EOL>  import org.junit.Test  <EOL>  import org.junit.runner.*  <EOL>  import org.robolectric.*  <EOL>  import org.robolectric.annotation.*  <EOL>  import org.robolectric.shadows.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  @RunWith(RobolectricTestRunner::class)  <EOL>  @Config(manifest = Config.NONE, sdk = [ <NUM_LIT> ])  <EOL>  @LooperMode(LooperMode.Mode.LEGACY)  <EOL>  open class FirstRobolectricTest {  <EOL>      @Test  <EOL>      fun testComponent()  {  <EOL>          // Note that main is not set at all  <EOL>          val component = TestComponent()  <EOL>          checkComponent(component)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testComponentAfterReset()  {  <EOL>          // Note that main is not set at all  <EOL>          val component = TestComponent()  <EOL>          Dispatchers.setMain(Dispatchers.Unconfined)  <EOL>          Dispatchers.resetMain()  <EOL>          checkComponent(component)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testDelay() {  <EOL>          val component = TestComponent()  <EOL>          val mainLooper = ShadowLooper.getShadowMainLooper()  <EOL>          mainLooper.pause()  <EOL>          component.launchDelayed()  <EOL>          mainLooper.runToNextTask()  <EOL>          assertFalse(component.delayedLaunchCompleted)  <EOL>          mainLooper.runToNextTask()  <EOL>          assertTrue(component.delayedLaunchCompleted)  <EOL>      }  <EOL>   <EOL>      private fun checkComponent(component: TestComponent) {  <EOL>          val mainLooper = ShadowLooper.getShadowMainLooper()  <EOL>          mainLooper.pause()  <EOL>          component.launchSomething()  <EOL>          assertFalse(component.launchCompleted)  <EOL>          mainLooper.unPause()  <EOL>          assertTrue(component.launchCompleted) ", "gt": ""}
{"input": "<s> package ordered.tests ", "gt": ""}
{"input": "<s> package ordered.tests ", "gt": ""}
{"input": "<s> package ordered.tests  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>   <EOL>  public class TestComponent {  <EOL>      internal lateinit var caughtException: Throwable  <EOL>      private val scope =  <EOL>          CoroutineScope(SupervisorJob() + Dispatchers.Main + CoroutineExceptionHandler { _, e -> caughtException = e})  <EOL>      public var launchCompleted = false  <EOL>      public var delayedLaunchCompleted = false  <EOL>   <EOL>      fun launchSomething() {  <EOL>          scope.launch {  <EOL>              launchCompleted = true  <EOL>          }  <EOL>      }  <EOL>   <EOL>      fun launchDelayed() {  <EOL>          scope.launch {  <EOL>              delay(Long.MAX_VALUE /  <NUM_LIT:2> )  <EOL>              delayedLaunchCompleted = true  <EOL>          } ", "gt": ""}
{"input": "<s> configurations {  <EOL>      create( <STR_LIT> )  <EOL>  }  <EOL>   <EOL>  repositories {  <EOL>      mavenCentral()  <EOL>  }  <EOL>   <EOL>  project.configureAar()  <EOL>   <EOL>  dependencies {  <EOL>      configureAarUnpacking()  <EOL>   <EOL>      compileOnly( <STR_LIT> android <STR_LIT> )  <EOL>      compileOnly( <STR_LIT> androidx_annotation <STR_LIT> )  <EOL>   <EOL>      testImplementation( <STR_LIT> android <STR_LIT> )  <EOL>      testImplementation( <STR_LIT> robolectric <STR_LIT> )  <EOL>      // Required by robolectric  <EOL>      testImplementation( <STR_LIT> )  <EOL>      testImplementation( <STR_LIT> )  <EOL>   <EOL>   <EOL>      testImplementation( <STR_LIT> baksmali <STR_LIT> )  <EOL>       <STR_LIT> ( <STR_LIT> )  <EOL>  }  <EOL>   <EOL>  val optimizedDexDir = layout.buildDirectory.dir( <STR_LIT> )  <EOL>  val unOptimizedDexDir = layout.buildDirectory.dir( <STR_LIT> )  <EOL>   <EOL>  val optimizedDexFile = optimizedDexDir.map { it.dir( <STR_LIT> ) } .get().asFile  <EOL>  val unOptimizedDexFile = unOptimizedDexDir.map { it.dir( <STR_LIT> ) }.get().asFile  <EOL>   <EOL>  val runR <NUM_LIT>  by tasks.registering(RunR <NUM_LIT> ::class) {  <EOL>      outputDex = optimizedDexDir.get().asFile  <EOL>      inputConfig = file( <STR_LIT> )  <EOL>   <EOL>      dependsOn( <STR_LIT> )  <EOL>  }  <EOL>   <EOL>  val runR <NUM_LIT> NoOptim by tasks.registering(RunR <NUM_LIT> ::class) {  <EOL>      outputDex = unOptimizedDexDir.get().asFile  <EOL>      inputConfig = file( <STR_LIT> )  <EOL>   <EOL>      dependsOn( <STR_LIT> )  <EOL>  }  <EOL>   <EOL>  tasks.test {  <EOL>      // Ensure the R <NUM_LIT> -processed dex is built and supply its path as a property to the test.  <EOL>      dependsOn(runR <NUM_LIT> )  <EOL>      dependsOn(runR <NUM_LIT> NoOptim)  <EOL>   <EOL>      inputs.files(optimizedDexFile, unOptimizedDexFile)  <EOL>   <EOL>      systemProperty( <STR_LIT> , optimizedDexFile.absolutePath)  <EOL>      systemProperty( <STR_LIT> , unOptimizedDexFile.absolutePath)  <EOL>   <EOL>      // Output custom metric with the size of the optimized dex  <EOL>      doLast {  <EOL>          println( <STR_LIT> )  <EOL>      }  <EOL>  }  <EOL>   <EOL>  externalDocumentationLink(  <EOL>      url =  <STR_LIT>  <EOL>  )  <EOL>  /*  <EOL>   * Task used by our ui/android tests to test minification results and keep track of size of the binary.  <EOL>   */  <EOL>  open class RunR <NUM_LIT>  : JavaExec() {  <EOL>   <EOL>      @OutputDirectory  <EOL>      lateinit var outputDex: File  <EOL>   <EOL>      @InputFile  <EOL>      lateinit var inputConfig: File  <EOL>   <EOL>      @InputFile  <EOL>      val inputConfigCommon: File = File( <STR_LIT> )  <EOL>   <EOL>      @InputFiles  <EOL>      val jarFile: File = project.tasks.named<Zip>( <STR_LIT> ).get().archiveFile.get().asFile  <EOL>   <EOL>      init {  <EOL>          classpath = project.configurations[ <STR_LIT> ]  <EOL>          mainClass =  <STR_LIT>  <EOL>      }  <EOL>   <EOL>      override fun exec() {  <EOL>          // Resolve classpath only during execution  <EOL>          val arguments = mutableListOf(  <EOL>               <STR_LIT> ,  <EOL>               <STR_LIT> ,  <EOL>               <STR_LIT> ,  <STR_LIT> ,  <EOL>               <STR_LIT> , outputDex.absolutePath,  <EOL>               <STR_LIT> , inputConfig.absolutePath  <EOL>          )  <EOL>          arguments.addAll(project.configurations[ <STR_LIT> ].files.map { it.absolutePath })  <EOL>          arguments.add(jarFile.absolutePath)  <EOL>   <EOL>          args = arguments  <EOL>   <EOL>          project.delete(outputDex)  <EOL>          outputDex.mkdirs()  <EOL>   <EOL>          super.exec() ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.android  <EOL>   <EOL>  import android.os.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import java.lang.reflect.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  internal class AndroidExceptionPreHandler :  <EOL>      AbstractCoroutineContextElement(CoroutineExceptionHandler), CoroutineExceptionHandler  <EOL>  {  <EOL>      @Volatile  <EOL>      private var _preHandler: Any? = this // uninitialized marker  <EOL>   <EOL>      // Reflectively lookup pre-handler.  <EOL>      private fun preHandler(): Method? {  <EOL>          val current = _preHandler  <EOL>          if (current !== this) return current as Method?  <EOL>          val declared = try {  <EOL>              Thread::class.java.getDeclaredMethod( <STR_LIT> ).takeIf {  <EOL>                  Modifier.isPublic(it.modifiers) && Modifier.isStatic(it.modifiers)  <EOL>              }  <EOL>          } catch (e: Throwable) {  <EOL>              null /* not found */  <EOL>          }  <EOL>          _preHandler = declared  <EOL>          return declared  <EOL>      }  <EOL>   <EOL>      override fun handleException(context: CoroutineContext, exception: Throwable) {  <EOL>          /*  <EOL>           * Android Oreo introduced private API for a global pre-handler for uncaught exceptions, to ensure that the  <EOL>           * exceptions are logged even if the default uncaught exception handler is replaced by the app. The pre-handler  <EOL>           * is invoked from the Thread's private dispatchUncaughtException() method, so our manual invocation of the  <EOL>           * Thread's uncaught exception handler bypasses the pre-handler in Android Oreo, and uncaught coroutine  <EOL>           * exceptions are not logged. This issue was addressed in Android Pie, which added a check in the default  <EOL>           * uncaught exception handler to invoke the pre-handler if it was not invoked already (see  <EOL>           * https://android-review.googlesource.com/c/platform/frameworks/base/+/ <NUM_LIT> /). So the issue is present only  <EOL>           * in Android Oreo.  <EOL>           *  <EOL>           * We're fixing this by manually invoking the pre-handler using reflection, if running on an Android Oreo SDK  <EOL>           * version ( <NUM_LIT>  and  <NUM_LIT> ).  <EOL>           */  <EOL>          if (Build.VERSION.SDK_INT in  <NUM_LIT> .. <NUM_LIT> ) {  <EOL>              (preHandler()?.invoke(null) as? Thread.UncaughtExceptionHandler)  <EOL>                  ?.uncaughtException(Thread.currentThread(), exception)  <EOL>          } ", "gt": ""}
{"input": "<s> @file:Suppress( <STR_LIT> )  <EOL>   <EOL>  package kotlinx.coroutines.android  <EOL>   <EOL>  import android.os.*  <EOL>  import android.view.*  <EOL>  import androidx.annotation.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.internal.*  <EOL>  import java.lang.reflect.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  /**  <EOL>   * Dispatches execution onto Android [Handler].  <EOL>   *  <EOL>   * This class provides type-safety and a point for future extensions.  <EOL>   */  <EOL>  public sealed class HandlerDispatcher : MainCoroutineDispatcher(), Delay {  <EOL>      /**  <EOL>       * Returns dispatcher that executes coroutines immediately when it is already in the right context  <EOL>       * (current looper is the same as this handler's looper) without an additional [re-dispatch][CoroutineDispatcher.dispatch].  <EOL>       * This dispatcher does not use [Handler.post] when current looper is the same as looper of the handler.  <EOL>       *  <EOL>       * Immediate dispatcher is safe from stack overflows and in case of nested invocations forms event-loop similar to [Dispatchers.Unconfined].  <EOL>       * The event loop is an advanced topic and its implications can be found in [Dispatchers.Unconfined] documentation.  <EOL>       *  <EOL>       * Example of usage:  <EOL>       * ```  <EOL>       * suspend fun updateUiElement(val text: String) {  <EOL>       *   /*  <EOL>       *    * If it is known that updateUiElement can be invoked both from the Main thread and from other threads,  <EOL>       *    * `immediate` dispatcher is used as a performance optimization to avoid unnecessary dispatch.  <EOL>       *    *  <EOL>       *    * In that case, when `updateUiElement` is invoked from the Main thread, `uiElement.text` will be  <EOL>       *    * invoked immediately without any dispatching, otherwise, the `Dispatchers.Main` dispatch cycle via  <EOL>       *    * `Handler.post` will be triggered.  <EOL>       *    */  <EOL>       *   withContext(Dispatchers.Main.immediate) {  <EOL>       *     uiElement.text = text  <EOL>       *   }  <EOL>       *   // Do context-independent logic such as logging  <EOL>       * }  <EOL>       * ```  <EOL>       */  <EOL>      public abstract override val immediate: HandlerDispatcher  <EOL>  }  <EOL>   <EOL>  internal class AndroidDispatcherFactory : MainDispatcherFactory {  <EOL>   <EOL>      override fun createDispatcher(allFactories: List<MainDispatcherFactory>): MainCoroutineDispatcher {  <EOL>          val mainLooper = Looper.getMainLooper() ?: throw IllegalStateException( <STR_LIT> )  <EOL>          return HandlerContext(mainLooper.asHandler(async = true))  <EOL>      }  <EOL>   <EOL>      override fun hintOnError(): String =  <STR_LIT>  <EOL>   <EOL>      override val loadPriority: Int  <EOL>          get() = Int.MAX_VALUE /  <NUM_LIT:2>  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Represents an arbitrary [Handler] as an implementation of [CoroutineDispatcher]  <EOL>   * with an optional [name] for nicer debugging  <EOL>   *  <EOL>   * ## Rejected execution  <EOL>   *  <EOL>   * If the underlying handler is closed and its message-scheduling methods start to return `false` on  <EOL>   * an attempt to submit a continuation task to the resulting dispatcher,  <EOL>   * then the [Job] of the affected task is [cancelled][Job.cancel] and the task is submitted to the  <EOL>   * [Dispatchers.IO], so that the affected coroutine can cleanup its resources and promptly complete.  <EOL>   */  <EOL>  @JvmName( <STR_LIT> ) // this is for a nice Java API, see issue # <NUM_LIT>  <EOL>  @JvmOverloads  <EOL>  public fun Handler.asCoroutineDispatcher(name: String? = null): HandlerDispatcher =  <EOL>      HandlerContext(this, name)  <EOL>   <EOL>  private const val MAX_DELAY = Long.MAX_VALUE /  <NUM_LIT:2>  // cannot delay for too long on Android  <EOL>   <EOL>  @VisibleForTesting  <EOL>  internal fun Looper.asHandler(async: Boolean): Handler {  <EOL>      // Async support was added in API  <NUM_LIT> .  <EOL>      if (!async || Build.VERSION.SDK_INT <  <NUM_LIT> ) {  <EOL>          return Handler(this)  <EOL>      }  <EOL>   <EOL>      if (Build.VERSION.SDK_INT >=  <NUM_LIT> ) {  <EOL>          // TODO compile against API  <NUM_LIT>  so this can be invoked without reflection.  <EOL>          val factoryMethod = Handler::class.java.getDeclaredMethod( <STR_LIT> , Looper::class.java)  <EOL>          return factoryMethod.invoke(null, this) as Handler  <EOL>      }  <EOL>   <EOL>      val constructor: Constructor<Handler>  <EOL>      try {  <EOL>          constructor = Handler::class.java.getDeclaredConstructor(Looper::class.java,  <EOL>              Handler.Callback::class.java, Boolean::class.javaPrimitiveType)  <EOL>      } catch (ignored: NoSuchMethodException) {  <EOL>          // Hidden constructor absent. Fall back to non-async constructor.  <EOL>          return Handler(this)  <EOL>      }  <EOL>      return constructor.newInstance(this, null, true)  <EOL>  }  <EOL>   <EOL>  @JvmField  <EOL>  @Deprecated( <STR_LIT> , level = DeprecationLevel.HIDDEN)  <EOL>  internal val Main: HandlerDispatcher? = runCatching { HandlerContext(Looper.getMainLooper().asHandler(async = true)) }.getOrNull()  <EOL>   <EOL>  /**  <EOL>   * Implements [CoroutineDispatcher] on top of an arbitrary Android [Handler].  <EOL>   */  <EOL>  internal class HandlerContext private constructor(  <EOL>      private val handler: Handler,  <EOL>      private val name: String?,  <EOL>      private val invokeImmediately: Boolean  <EOL>  ) : HandlerDispatcher(), Delay {  <EOL>      /**  <EOL>       * Creates [CoroutineDispatcher] for the given Android [handler].  <EOL>       *  <EOL>       * @param handler a handler.  <EOL>       * @param name an optional name for debugging.  <EOL>       */  <EOL>      constructor(  <EOL>          handler: Handler,  <EOL>          name: String? = null  <EOL>      ) : this(handler, name, false)  <EOL>   <EOL>      override val immediate: HandlerContext = if (invokeImmediately) this else  <EOL>          HandlerContext(handler, name, true)  <EOL>   <EOL>      override fun isDispatchNeeded(context: CoroutineContext): Boolean {  <EOL>          return !invokeImmediately || Looper.myLooper() != handler.looper  <EOL>      }  <EOL>   <EOL>      override fun dispatch(context: CoroutineContext, block: Runnable) {  <EOL>          if (!handler.post(block)) {  <EOL>              cancelOnRejection(context, block)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {  <EOL>          val block = Runnable {  <EOL>              with(continuation) { resumeUndispatched(Unit) }  <EOL>          }  <EOL>          if (handler.postDelayed(block, timeMillis.coerceAtMost(MAX_DELAY))) {  <EOL>              continuation.invokeOnCancellation { handler.removeCallbacks(block) }  <EOL>          } else {  <EOL>              cancelOnRejection(continuation.context, block)  <EOL>          }  <EOL>      }  <EOL>   <EOL>      override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {  <EOL>          if (handler.postDelayed(block, timeMillis.coerceAtMost(MAX_DELAY))) {  <EOL>              return DisposableHandle { handler.removeCallbacks(block) }  <EOL>          }  <EOL>          cancelOnRejection(context, block)  <EOL>          return NonDisposableHandle  <EOL>      }  <EOL>   <EOL>      private fun cancelOnRejection(context: CoroutineContext, block: Runnable) {  <EOL>          context.cancel(CancellationException( <STR_LIT> ))  <EOL>          Dispatchers.IO.dispatch(context, block)  <EOL>      }  <EOL>   <EOL>      override fun toString(): String = toStringInternalImpl() ?: run {  <EOL>          val str = name ?: handler.toString()  <EOL>          if (invokeImmediately)  <STR_LIT>  else str  <EOL>      }  <EOL>   <EOL>      override fun equals(other: Any?): Boolean =  <EOL>          other is HandlerContext && other.handler === handler && other.invokeImmediately == invokeImmediately  <EOL>      // inlining `Boolean.hashCode()` for Android compatibility, as requested by Animal Sniffer  <EOL>      override fun hashCode(): Int = System.identityHashCode(handler) xor if (invokeImmediately)  <NUM_LIT>  else  <NUM_LIT>  <EOL>  }  <EOL>   <EOL>  @Volatile  <EOL>  private var choreographer: Choreographer? = null  <EOL>   <EOL>  /**  <EOL>   * Awaits the next animation frame and returns frame time in nanoseconds.  <EOL>   */  <EOL>  public suspend fun awaitFrame(): Long {  <EOL>      // fast path when choreographer is already known  <EOL>      val choreographer = choreographer  <EOL>      return if (choreographer != null) {  <EOL>          suspendCancellableCoroutine { cont ->  <EOL>              postFrameCallback(choreographer, cont)  <EOL>          }  <EOL>      } else {  <EOL>          awaitFrameSlowPath()  <EOL>      }  <EOL>  }  <EOL>   <EOL>  private suspend fun awaitFrameSlowPath(): Long = suspendCancellableCoroutine { cont ->  <EOL>      if (Looper.myLooper() === Looper.getMainLooper()) { // Check if we are already in the main looper thread  <EOL>          updateChoreographerAndPostFrameCallback(cont)  <EOL>      } else { // post into looper thread to figure it out  <EOL>          Dispatchers.Main.dispatch(cont.context, Runnable {  <EOL>              updateChoreographerAndPostFrameCallback(cont)  <EOL>          })  <EOL>      }  <EOL>  }  <EOL>   <EOL>  private fun updateChoreographerAndPostFrameCallback(cont: CancellableContinuation<Long>) {  <EOL>      val choreographer = choreographer ?: Choreographer.getInstance()!!.also { choreographer = it }  <EOL>      postFrameCallback(choreographer, cont)  <EOL>  }  <EOL>   <EOL>  private fun postFrameCallback(choreographer: Choreographer, cont: CancellableContinuation<Long>) {  <EOL>      choreographer.postFrameCallback { nanos ->  <EOL>          with(cont) { Dispatchers.Main.resumeUndispatched(nanos) } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.android  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.Test  <EOL>  import org.junit.runner.*  <EOL>  import org.robolectric.*  <EOL>  import org.robolectric.annotation.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  @RunWith(RobolectricTestRunner::class)  <EOL>  @Config(manifest = Config.NONE, sdk = [ <NUM_LIT> ])  <EOL>  @LooperMode(LooperMode.Mode.LEGACY)  <EOL>  class AndroidExceptionPreHandlerTest : TestBase() {  <EOL>      @Test  <EOL>      fun testUnhandledException() = runTest {  <EOL>          val previousHandler = Thread.getDefaultUncaughtExceptionHandler()  <EOL>          try {  <EOL>              Thread.setDefaultUncaughtExceptionHandler { _, e ->  <EOL>                  expect( <NUM_LIT> )  <EOL>                  assertIs<TestException>(e)  <EOL>              }  <EOL>              expect( <NUM_LIT:1> )  <EOL>              GlobalScope.launch(Dispatchers.Main) {  <EOL>                  expect( <NUM_LIT:2> )  <EOL>                  throw TestException()  <EOL>              }.join()  <EOL>              finish( <NUM_LIT> )  <EOL>          } finally {  <EOL>              Thread.setDefaultUncaughtExceptionHandler(previousHandler)  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.android  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import android.os.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import org.junit.runner.*  <EOL>  import org.robolectric.*  <EOL>  import org.robolectric.annotation.*  <EOL>   <EOL>  @RunWith(RobolectricTestRunner::class)  <EOL>  @Config(manifest = Config.NONE, sdk = [ <NUM_LIT> ])  <EOL>  @LooperMode(LooperMode.Mode.LEGACY)  <EOL>  class DisabledHandlerTest : TestBase() {  <EOL>   <EOL>      private var delegateToSuper = false  <EOL>      private val disabledDispatcher = object : Handler() {  <EOL>          override fun sendMessageAtTime(msg: Message?, uptimeMillis: Long): Boolean {  <EOL>              if (delegateToSuper) return super.sendMessageAtTime(msg, uptimeMillis)  <EOL>              return false  <EOL>          }  <EOL>      }.asCoroutineDispatcher()  <EOL>   <EOL>      @Test  <EOL>      fun testRunBlocking() {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          try {  <EOL>              runBlocking(disabledDispatcher) {  <EOL>                  expectUnreached()  <EOL>              }  <EOL>              expectUnreached()  <EOL>          } catch (e: CancellationException) {  <EOL>              finish( <NUM_LIT:2> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testInvokeOnCancellation() = runTest {  <EOL>          val job = launch(disabledDispatcher, start = CoroutineStart.LAZY) { expectUnreached() }  <EOL>          job.invokeOnCompletion { if (it != null) expect( <NUM_LIT:2> ) }  <EOL>          yield()  <EOL>          expect( <NUM_LIT:1> )  <EOL>          job.join()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testWithTimeout() = runTest {  <EOL>          delegateToSuper = true  <EOL>          try {  <EOL>              withContext(disabledDispatcher) {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>                  delegateToSuper = false  <EOL>                  delay(Long.MAX_VALUE -  <NUM_LIT:1> )  <EOL>                  expectUnreached()  <EOL>              }  <EOL>              expectUnreached()  <EOL>          } catch (e: CancellationException) {  <EOL>              finish( <NUM_LIT:2> )  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.android  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import android.os.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.Test  <EOL>  import org.junit.runner.*  <EOL>  import org.robolectric.*  <EOL>  import org.robolectric.Shadows.*  <EOL>  import org.robolectric.annotation.*  <EOL>  import org.robolectric.shadows.*  <EOL>  import org.robolectric.util.*  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  @RunWith(RobolectricTestRunner::class)  <EOL>  @Config(manifest = Config.NONE, sdk = [ <NUM_LIT> ])  <EOL>  @LooperMode(LooperMode.Mode.LEGACY)  <EOL>  class HandlerDispatcherAsyncTest : TestBase() {  <EOL>   <EOL>      /**  <EOL>       * Because [Dispatchers.Main] is a singleton, we cannot vary its initialization behavior. As a  <EOL>       * result we only test its behavior on the newest API level and assert that it uses async  <EOL>       * messages. We rely on the other tests to exercise the variance of the mechanism that the main  <EOL>       * dispatcher uses to ensure it has correct behavior on all API levels.  <EOL>       */  <EOL>      @Test  <EOL>      fun mainIsAsync() = runTest {  <EOL>          ReflectionHelpers.setStaticField(Build.VERSION::class.java,  <STR_LIT> ,  <NUM_LIT> )  <EOL>   <EOL>          val mainLooper = shadowOf(Looper.getMainLooper())  <EOL>          mainLooper.pause()  <EOL>          val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)  <EOL>   <EOL>          val job = launch(Dispatchers.Main) {  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>   <EOL>          val message = mainMessageQueue.head  <EOL>          assertTrue(message.isAsynchronous)  <EOL>          job.join(mainLooper)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun asyncMessagesApi <NUM_LIT> () = runTest {  <EOL>          ReflectionHelpers.setStaticField(Build.VERSION::class.java,  <STR_LIT> ,  <NUM_LIT> )  <EOL>   <EOL>          val main = Looper.getMainLooper().asHandler(async = true).asCoroutineDispatcher()  <EOL>   <EOL>          val mainLooper = shadowOf(Looper.getMainLooper())  <EOL>          mainLooper.pause()  <EOL>          val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)  <EOL>   <EOL>          val job = launch(main) {  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>   <EOL>          val message = mainMessageQueue.head  <EOL>          assertFalse(message.isAsynchronous)  <EOL>          job.join(mainLooper)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun asyncMessagesApi <NUM_LIT> () = runTest {  <EOL>          ReflectionHelpers.setStaticField(Build.VERSION::class.java,  <STR_LIT> ,  <NUM_LIT> )  <EOL>   <EOL>          val main = Looper.getMainLooper().asHandler(async = true).asCoroutineDispatcher()  <EOL>   <EOL>          val mainLooper = shadowOf(Looper.getMainLooper())  <EOL>          mainLooper.pause()  <EOL>          val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)  <EOL>   <EOL>          val job = launch(main) {  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>   <EOL>          val message = mainMessageQueue.head  <EOL>          assertTrue(message.isAsynchronous)  <EOL>          job.join(mainLooper)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun asyncMessagesApi <NUM_LIT> () = runTest {  <EOL>          ReflectionHelpers.setStaticField(Build.VERSION::class.java,  <STR_LIT> ,  <NUM_LIT> )  <EOL>   <EOL>          val main = Looper.getMainLooper().asHandler(async = true).asCoroutineDispatcher()  <EOL>   <EOL>          val mainLooper = shadowOf(Looper.getMainLooper())  <EOL>          mainLooper.pause()  <EOL>          val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)  <EOL>   <EOL>          val job = launch(main) {  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>   <EOL>          val message = mainMessageQueue.head  <EOL>          assertTrue(message.isAsynchronous)  <EOL>          job.join(mainLooper)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun noAsyncMessagesIfNotRequested() = runTest {  <EOL>          ReflectionHelpers.setStaticField(Build.VERSION::class.java,  <STR_LIT> ,  <NUM_LIT> )  <EOL>   <EOL>          val main = Looper.getMainLooper().asHandler(async = false).asCoroutineDispatcher()  <EOL>   <EOL>          val mainLooper = shadowOf(Looper.getMainLooper())  <EOL>          mainLooper.pause()  <EOL>          val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)  <EOL>   <EOL>          val job = launch(main) {  <EOL>              expect( <NUM_LIT:2> )  <EOL>          }  <EOL>   <EOL>          val message = mainMessageQueue.head  <EOL>          assertFalse(message.isAsynchronous)  <EOL>          job.join(mainLooper)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testToString() {  <EOL>          ReflectionHelpers.setStaticField(Build.VERSION::class.java,  <STR_LIT> ,  <NUM_LIT> )  <EOL>          val main = Looper.getMainLooper().asHandler(async = true).asCoroutineDispatcher( <STR_LIT> )  <EOL>          assertEquals( <STR_LIT> , main.toString())  <EOL>          assertEquals( <STR_LIT> , main.immediate.toString())  <EOL>          assertEquals( <STR_LIT> , main.immediate.immediate.toString())  <EOL>      }  <EOL>   <EOL>      private suspend fun Job.join(mainLooper: ShadowLooper) {  <EOL>          expect( <NUM_LIT:1> )  <EOL>          mainLooper.unPause()  <EOL>          join()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      // TODO compile against API  <NUM_LIT> + so this can be invoked without reflection.  <EOL>      private val Looper.queue: MessageQueue  <EOL>          get() = Looper::class.java.getDeclaredMethod( <STR_LIT> ).invoke(this) as MessageQueue  <EOL>   <EOL>      // TODO compile against API  <NUM_LIT> + so this can be invoked without reflection.  <EOL>      private val Message.isAsynchronous: Boolean ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.android  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import android.os.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import org.junit.Test  <EOL>  import org.junit.runner.*  <EOL>  import org.robolectric.*  <EOL>  import org.robolectric.annotation.*  <EOL>  import org.robolectric.shadows.*  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  @RunWith(RobolectricTestRunner::class)  <EOL>  @LooperMode(LooperMode.Mode.LEGACY)  <EOL>  @Config(manifest = Config.NONE, sdk = [ <NUM_LIT> ])  <EOL>  class HandlerDispatcherTest : MainDispatcherTestBase.WithRealTimeDelay() {  <EOL>      @Test  <EOL>      fun testDefaultDelayIsNotDelegatedToMain() = runTest {  <EOL>          val mainLooper = Shadows.shadowOf(Looper.getMainLooper())  <EOL>          mainLooper.pause()  <EOL>          assertFalse { mainLooper.scheduler.areAnyRunnable() }  <EOL>   <EOL>          val job = launch(Dispatchers.Default, start = CoroutineStart.UNDISPATCHED) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              delay(Long.MAX_VALUE)  <EOL>              expectUnreached()  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          assertEquals( <NUM_LIT:0> , mainLooper.scheduler.size())  <EOL>          job.cancelAndJoin()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testWithTimeoutIsDelegatedToMain() = runTest {  <EOL>          val mainLooper = Shadows.shadowOf(Looper.getMainLooper())  <EOL>          mainLooper.pause()  <EOL>          assertFalse { mainLooper.scheduler.areAnyRunnable() }  <EOL>          val job = launch(Dispatchers.Main, start = CoroutineStart.UNDISPATCHED) {  <EOL>              withTimeout( <NUM_LIT:1> ) {  <EOL>                  expect( <NUM_LIT:1> )  <EOL>                  hang { expect( <NUM_LIT> ) }  <EOL>              }  <EOL>              expectUnreached()  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          assertEquals( <NUM_LIT:1> , mainLooper.scheduler.size())  <EOL>          // Schedule cancellation  <EOL>          mainLooper.runToEndOfTasks()  <EOL>          job.join()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testDelayDelegatedToMain() = runTest {  <EOL>          val mainLooper = Shadows.shadowOf(Looper.getMainLooper())  <EOL>          mainLooper.pause()  <EOL>          val job = launch(Dispatchers.Main, start = CoroutineStart.UNDISPATCHED) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              delay( <NUM_LIT:1> )  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          assertEquals( <NUM_LIT:1> , mainLooper.scheduler.size())  <EOL>          // Schedule cancellation  <EOL>          mainLooper.runToEndOfTasks()  <EOL>          job.join()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAwaitFrame() = runTest {  <EOL>          doTestAwaitFrame()  <EOL>   <EOL>          reset()  <EOL>   <EOL>          // Now the second test: we cannot test it separately because we're caching choreographer in HandlerDispatcher  <EOL>          doTestAwaitWithDetectedChoreographer()  <EOL>      }  <EOL>   <EOL>      private fun CoroutineScope.doTestAwaitFrame() {  <EOL>          ShadowChoreographer.setPostFrameCallbackDelay( <NUM_LIT:100> )  <EOL>          val mainLooper = Shadows.shadowOf(Looper.getMainLooper())  <EOL>          mainLooper.pause()  <EOL>          launch(Dispatchers.Main, start = CoroutineStart.UNDISPATCHED) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              awaitFrame()  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          expect( <NUM_LIT:2> )  <EOL>          // Run choreographer detection  <EOL>          mainLooper.runOneTask()  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      private fun CoroutineScope.doTestAwaitWithDetectedChoreographer() {  <EOL>          ShadowChoreographer.setPostFrameCallbackDelay( <NUM_LIT:100> )  <EOL>          val mainLooper = Shadows.shadowOf(Looper.getMainLooper())  <EOL>          launch(Dispatchers.Main, start = CoroutineStart.UNDISPATCHED) {  <EOL>              expect( <NUM_LIT:1> )  <EOL>              awaitFrame()  <EOL>              expect( <NUM_LIT> )  <EOL>          }  <EOL>          // Run choreographer detection  <EOL>          expect( <NUM_LIT:2> )  <EOL>          mainLooper.scheduler.advanceBy( <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>          expect( <NUM_LIT> )  <EOL>          mainLooper.scheduler.advanceBy( <NUM_LIT> , TimeUnit.MILLISECONDS)  <EOL>          finish( <NUM_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun isMainThread(): Boolean = Looper.getMainLooper().thread === Thread.currentThread()  <EOL>   <EOL>      override fun scheduleOnMainQueue(block: () -> Unit) {  <EOL>          Handler(Looper.getMainLooper()).post(block)  <EOL>      }  <EOL>   <EOL>      // by default, Robolectric only schedules tasks on the main thread but doesn't run them.  <EOL>      // This function nudges it to run them,  <NUM_LIT:10>  milliseconds of virtual time at a time.  <EOL>      override suspend fun spinTest(testBody: Job) {  <EOL>          val mainLooper = Shadows.shadowOf(Looper.getMainLooper())  <EOL>          while (testBody.isActive) {  <EOL>              Thread.sleep( <NUM_LIT:10> ,  <NUM_LIT:0> )  <EOL>              mainLooper.idleFor( <NUM_LIT:10> , TimeUnit.MILLISECONDS)  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.android  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.jf.dexlib <NUM_LIT:2> .*  <EOL>  import org.junit.Test  <EOL>  import java.io.*  <EOL>  import java.util.stream.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class R <NUM_LIT> ServiceLoaderOptimizationTest : TestBase() {  <EOL>      private val r <NUM_LIT> Dex = File(System.getProperty( <STR_LIT> )!!).asDexFile()  <EOL>      private val r <NUM_LIT> DexNoOptim = File(System.getProperty( <STR_LIT> )!!).asDexFile()  <EOL>   <EOL>      @Test  <EOL>      fun testNoServiceLoaderCalls() {  <EOL>          val serviceLoaderInvocations = r <NUM_LIT> Dex.types.any {  <EOL>              it.type ==  <STR_LIT>  <EOL>          }  <EOL>          assertEquals(  <EOL>                  false,  <EOL>                  serviceLoaderInvocations,  <EOL>                   <STR_LIT>  <EOL>          )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testAndroidDispatcherIsKept() {  <EOL>          val hasAndroidDispatcher = r <NUM_LIT> DexNoOptim.classes.any {  <EOL>              it.type ==  <STR_LIT>  <EOL>          }  <EOL>   <EOL>          assertEquals(true, hasAndroidDispatcher)  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      @Ignore  <EOL>      fun testNoOptimRulesMatch() {  <EOL>          val paths = listOf(  <EOL>                   <STR_LIT> ,  <EOL>                   <STR_LIT> ,  <EOL>                   <STR_LIT>  <EOL>          )  <EOL>          paths.associateWith { path ->  <EOL>              val ruleSet = javaClass.classLoader.getResourceAsStream(path)!!.bufferedReader().lines().filter { line ->  <EOL>                  line.isNotBlank() && !line.startsWith( <STR_LIT> )  <EOL>              }.collect(Collectors.toSet())  <EOL>              ruleSet  <EOL>          }.asSequence().reduce { acc, entry ->  <EOL>              assertEquals(  <EOL>                      acc.value,  <EOL>                      entry.value,  <EOL>                       <STR_LIT>  <EOL>              )  <EOL>              entry  <EOL>          }  <EOL>      }  <EOL>  } ", "gt": ""}
{"input": "<s> plugins {  <EOL>      id( <STR_LIT> ) version  <STR_LIT>  <EOL>  }  <EOL>   <EOL>  configurations {  <EOL>      register( <STR_LIT> )  <EOL>      named( <STR_LIT> ) {  <EOL>          extendsFrom(configurations[ <STR_LIT> ])  <EOL>      }  <EOL>      named( <STR_LIT> ) {  <EOL>          extendsFrom(configurations[ <STR_LIT> ])  <EOL>      }  <EOL>  }  <EOL>   <EOL>  javafx {  <EOL>      version = version( <STR_LIT> )  <EOL>      modules = listOf( <STR_LIT> )  <EOL>      configuration =  <STR_LIT>  <EOL>  }  <EOL>   <EOL>  // Fixup moduleplugin in order to properly run with classpath  <EOL>  tasks {  <EOL>      test {  <EOL>          extensions.configure(org.javamodularity.moduleplugin.extensions.TestModuleOptions::class) {  <EOL>              addReads[ <STR_LIT> ] =  <STR_LIT>  <EOL>              addReads[ <STR_LIT> ] =  <STR_LIT>  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.javafx  <EOL>   <EOL>  import javafx.beans.value.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>   <EOL>  /**  <EOL>   * Creates an instance of a cold [Flow] that subscribes to the given [ObservableValue] and emits  <EOL>   * its values as they change. The resulting flow is conflated, meaning that if several values arrive in quick  <EOL>   * succession, only the last one will be emitted.  <EOL>   * Since this implementation uses [ObservableValue.addListener], even if this [ObservableValue]  <EOL>   * supports lazy evaluation, eager computation will be enforced while the flow is being collected.  <EOL>   * All the calls to JavaFX API are performed in [Dispatchers.JavaFx].  <EOL>   * This flow emits at least the initial value.  <EOL>   *  <EOL>   * ### Operator fusion  <EOL>   *  <EOL>   * Adjacent applications of [flowOn], [buffer], [conflate], and [produceIn] to the result of `asFlow` are fused.  <EOL>   * [conflate] has no effect, as this flow is already conflated; one can use [buffer] to change that instead.  <EOL>   */  <EOL>  @ExperimentalCoroutinesApi // Since  <NUM_LIT> .x  <EOL>  public fun <T> ObservableValue<T>.asFlow(): Flow<T> = callbackFlow<T> {  <EOL>      val listener = ChangeListener<T> { _, _, newValue ->  <EOL>          /*  <EOL>           * Do not propagate the exception to the ObservableValue, it  <EOL>           * already should've been handled by the downstream  <EOL>           */  <EOL>          trySend(newValue)  <EOL>      }  <EOL>      addListener(listener)  <EOL>      send(value)  <EOL>      awaitClose {  <EOL>          removeListener(listener) ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.javafx  <EOL>   <EOL>  import javafx.animation.*  <EOL>  import javafx.application.*  <EOL>  import javafx.event.*  <EOL>  import javafx.util.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.internal.*  <EOL>  import java.lang.UnsupportedOperationException  <EOL>  import java.lang.reflect.*  <EOL>  import java.util.concurrent.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  /**  <EOL>   * Dispatches execution onto JavaFx application thread and provides native [delay] support.  <EOL>   */  <EOL>  @Suppress( <STR_LIT> )  <EOL>  public val Dispatchers.JavaFx: JavaFxDispatcher  <EOL>      get() = kotlinx.coroutines.javafx.JavaFx  <EOL>   <EOL>  /**  <EOL>   * Dispatcher for JavaFx application thread with support for [awaitPulse].  <EOL>   *  <EOL>   * This class provides type-safety and a point for future extensions.  <EOL>   */  <EOL>  public sealed class JavaFxDispatcher : MainCoroutineDispatcher(), Delay {  <EOL>   <EOL>      /** @suppress */  <EOL>      override fun dispatch(context: CoroutineContext, block: Runnable): Unit = Platform.runLater(block)  <EOL>   <EOL>      /** @suppress */  <EOL>      override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {  <EOL>          val timeline = schedule(timeMillis) {  <EOL>              with(continuation) { resumeUndispatched(Unit) }  <EOL>          }  <EOL>          continuation.invokeOnCancellation { timeline.stop() }  <EOL>      }  <EOL>   <EOL>      /** @suppress */  <EOL>      override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {  <EOL>          val timeline = schedule(timeMillis) {  <EOL>              block.run()  <EOL>          }  <EOL>          return DisposableHandle { timeline.stop() }  <EOL>      }  <EOL>   <EOL>      private fun schedule(timeMillis: Long, handler: EventHandler<ActionEvent>): Timeline =  <EOL>          Timeline(KeyFrame(Duration.millis(timeMillis.toDouble()), handler)).apply { play() }  <EOL>  }  <EOL>   <EOL>  internal class JavaFxDispatcherFactory : MainDispatcherFactory {  <EOL>      override fun createDispatcher(allFactories: List<MainDispatcherFactory>): MainCoroutineDispatcher = JavaFx  <EOL>   <EOL>      override val loadPriority: Int  <EOL>          get() =  <NUM_LIT:1>  // Swing has  <NUM_LIT:0>  <EOL>  }  <EOL>   <EOL>  private object ImmediateJavaFxDispatcher : JavaFxDispatcher() {  <EOL>      override val immediate: MainCoroutineDispatcher  <EOL>          get() = this  <EOL>   <EOL>      override fun isDispatchNeeded(context: CoroutineContext): Boolean = !Platform.isFxApplicationThread()  <EOL>   <EOL>      override fun toString() = toStringInternalImpl() ?:  <STR_LIT>  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Dispatches execution onto JavaFx application thread and provides native [delay] support.  <EOL>   */  <EOL>  internal object JavaFx : JavaFxDispatcher() {  <EOL>      init {  <EOL>          // :kludge: to make sure Toolkit is initialized if we use JavaFx dispatcher outside of JavaFx app  <EOL>          initPlatform()  <EOL>      }  <EOL>   <EOL>      override val immediate: MainCoroutineDispatcher  <EOL>          get() = ImmediateJavaFxDispatcher  <EOL>   <EOL>      override fun toString() = toStringInternalImpl() ?:  <STR_LIT>  <EOL>  }  <EOL>   <EOL>  private val pulseTimer by lazy {  <EOL>      PulseTimer().apply { start() }  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Suspends coroutine until next JavaFx pulse and returns time of the pulse on resumption.  <EOL>   * If the [Job] of the current coroutine is completed while this suspending function is waiting, this function  <EOL>   * immediately resumes with [CancellationException][kotlinx.coroutines.CancellationException].  <EOL>   */  <EOL>  public suspend fun awaitPulse(): Long = suspendCancellableCoroutine { cont ->  <EOL>      pulseTimer.onNext(cont)  <EOL>  }  <EOL>   <EOL>  private class PulseTimer : AnimationTimer() {  <EOL>      private val next = CopyOnWriteArrayList<CancellableContinuation<Long>>()  <EOL>   <EOL>      override fun handle(now: Long) {  <EOL>          val cur = next.toTypedArray()  <EOL>          next.clear()  <EOL>          for (cont in cur)  <EOL>              with (cont) { JavaFx.resumeUndispatched(now) }  <EOL>      }  <EOL>   <EOL>      fun onNext(cont: CancellableContinuation<Long>) {  <EOL>          next += cont  <EOL>      }  <EOL>  }  <EOL>   <EOL>  /** @return true if initialized successfully, and false if no display is detected */  <EOL>  internal fun initPlatform(): Boolean = PlatformInitializer.success  <EOL>   <EOL>  // Lazily try to initialize JavaFx platform just once  <EOL>  private object PlatformInitializer {  <EOL>      @JvmField  <EOL>      val success = run {  <EOL>          /*  <EOL>           * Try to instantiate JavaFx platform in a way which works  <EOL>           * both on Java  <NUM_LIT>  and Java  <NUM_LIT>  and does not produce  <STR_LIT> .  <EOL>           */  <EOL>          try {  <EOL>              val runnable = Runnable {}  <EOL>              // Invoke the public API if it is present.  <EOL>              runCatching {  <EOL>                  Class.forName( <STR_LIT> )  <EOL>                          .getMethod( <STR_LIT> , java.lang.Runnable::class.java)  <EOL>              }.map { method ->  <EOL>                  method.invoke(null, runnable)  <EOL>                  return@run true  <EOL>              }  <EOL>              // If we are here, it means the public API is not present. Try the private API.  <EOL>              Class.forName( <STR_LIT> )  <EOL>                      .getMethod( <STR_LIT> , java.lang.Runnable::class.java)  <EOL>                      .invoke(null, runnable)  <EOL>              true  <EOL>          } catch (exception: InvocationTargetException) {  <EOL>              // Can only happen as a result of [Method.invoke].  <EOL>              val cause = exception.cause!!  <EOL>              when {  <EOL>                  // Maybe the problem is that JavaFX is already initialized? Everything is good then.  <EOL>                  cause is IllegalStateException &&  <STR_LIT>  == cause.message -> true  <EOL>                  // If the problem is the headless environment, it is okay.  <EOL>                  cause is UnsupportedOperationException &&  <STR_LIT>  == cause.message -> false  <EOL>                  // Otherwise, the exception demonstrates an anomaly.  <EOL>                  else -> throw cause  <EOL>              }  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.javafx  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import javafx.application.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class JavaFxDispatcherTest : MainDispatcherTestBase.WithRealTimeDelay() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun shouldSkipTesting(): Boolean {  <EOL>          if (!initPlatform()) {  <EOL>              println( <STR_LIT> )  <EOL>              return true // ignore test in headless environments  <EOL>          }  <EOL>          return false  <EOL>      }  <EOL>   <EOL>      override fun isMainThread() = Platform.isFxApplicationThread()  <EOL>   <EOL>      override fun scheduleOnMainQueue(block: () -> Unit) {  <EOL>          Platform.runLater { block() }  <EOL>      }  <EOL>   <EOL>      /** Tests that the Main dispatcher is in fact the JavaFx one. */  <EOL>      @Test  <EOL>      fun testMainIsJavaFx() {  <EOL>          assertSame(Dispatchers.JavaFx, Dispatchers.Main)  <EOL>      } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.javafx  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import javafx.beans.property.SimpleIntegerProperty  <EOL>  import kotlinx.coroutines.testing.TestBase  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import org.junit.Before  <EOL>  import org.junit.Test  <EOL>  import kotlin.test.*  <EOL>   <EOL>   <EOL>  class JavaFxObservableAsFlowTest : TestBase() {  <EOL>   <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testFlowOrder() = runTest {  <EOL>          if (!initPlatform()) {  <EOL>              println( <STR_LIT> )  <EOL>              return@runTest // ignore test in headless environments  <EOL>          }  <EOL>   <EOL>          val integerProperty = SimpleIntegerProperty( <NUM_LIT:0> )  <EOL>          val n =  <NUM_LIT>  <EOL>          val flow = integerProperty.asFlow().takeWhile { j -> j != n }  <EOL>          newSingleThreadContext( <STR_LIT> ).use { pool ->  <EOL>              launch(pool) {  <EOL>                  for (i in  <NUM_LIT:1> ..n) {  <EOL>                      launch(Dispatchers.JavaFx) {  <EOL>                          integerProperty.set(i)  <EOL>                      }  <EOL>                  }  <EOL>              }  <EOL>              var i = - <NUM_LIT:1>  <EOL>              flow.collect { j ->  <EOL>                  assertTrue(i < (j as Int),  <STR_LIT> )  <EOL>                  i = j  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testConflation() = runTest {  <EOL>          if (!initPlatform()) {  <EOL>              println( <STR_LIT> )  <EOL>              return@runTest // ignore test in headless environments  <EOL>          }  <EOL>   <EOL>          withContext(Dispatchers.JavaFx) {  <EOL>              val END_MARKER = - <NUM_LIT:1>  <EOL>              val integerProperty = SimpleIntegerProperty( <NUM_LIT:0> )  <EOL>              val flow = integerProperty.asFlow().takeWhile { j -> j != END_MARKER }  <EOL>              launch {  <EOL>                  yield() // to subscribe to [integerProperty]  <EOL>                  yield() // send  <NUM_LIT:0>  <EOL>                  integerProperty.set( <NUM_LIT:1> )  <EOL>                  expect( <NUM_LIT> )  <EOL>                  yield() // send  <NUM_LIT:1>  <EOL>                  expect( <NUM_LIT> )  <EOL>                  integerProperty.set( <NUM_LIT:2> )  <EOL>                  for (i in (- <NUM_LIT:100> ..- <NUM_LIT:2> )) {  <EOL>                      integerProperty.set(i) // should be skipped due to conflation  <EOL>                  }  <EOL>                  integerProperty.set( <NUM_LIT> )  <EOL>                  expect( <NUM_LIT> )  <EOL>                  yield() // send  <NUM_LIT:2>  and  <NUM_LIT>  <EOL>                  integerProperty.set(- <NUM_LIT:1> )  <EOL>              }  <EOL>              expect( <NUM_LIT:1> )  <EOL>              flow.collect { i ->  <EOL>                  when (i) {  <EOL>                       <NUM_LIT:0>  -> expect( <NUM_LIT:2> )  <EOL>                       <NUM_LIT:1>  -> expect( <NUM_LIT> )  <EOL>                       <NUM_LIT:2>  -> expect( <NUM_LIT> )  <EOL>                       <NUM_LIT>  -> expect( <NUM_LIT> )  <EOL>                      else -> fail( <STR_LIT> )  <EOL>                  }  <EOL>              }  <EOL>              finish( <NUM_LIT> )  <EOL>          }  <EOL>      }  <EOL>   <EOL>      @Test  <EOL>      fun testIntermediateCrash() = runTest {  <EOL>          if (!initPlatform()) {  <EOL>              println( <STR_LIT> )  <EOL>              return@runTest // ignore test in headless environments  <EOL>          }  <EOL>   <EOL>          val property = SimpleIntegerProperty( <NUM_LIT:0> )  <EOL>   <EOL>          assertFailsWith<TestException> {  <EOL>              property.asFlow().onEach {  <EOL>                  yield()  <EOL>                  throw TestException()  <EOL>              }.collect()  <EOL>          } ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.javafx  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import javafx.beans.property.SimpleIntegerProperty  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.first  <EOL>  import org.junit.*  <EOL>   <EOL>  class JavaFxStressTest : TestBase() {  <EOL>   <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> ,  <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      @get:Rule  <EOL>      val pool = ExecutorRule( <NUM_LIT:1> )  <EOL>   <EOL>      @Test  <EOL>      fun testCancellationRace() = runTest {  <EOL>          if (!initPlatform()) {  <EOL>              println( <STR_LIT> )  <EOL>              return@runTest // ignore test in headless environments  <EOL>          }  <EOL>   <EOL>          val integerProperty = SimpleIntegerProperty( <NUM_LIT:0> )  <EOL>          val flow = integerProperty.asFlow()  <EOL>          var i =  <NUM_LIT:1>  <EOL>          val n =  <NUM_LIT>  * stressTestMultiplier  <EOL>          repeat (n) {  <EOL>              launch(pool) {  <EOL>                  flow.first()  <EOL>              }  <EOL>              withContext(Dispatchers.JavaFx) {  <EOL>                  integerProperty.set(i)  <EOL>              }  <EOL>              i +=  <NUM_LIT:1> ", "gt": ""}
{"input": "<s> package examples  <EOL>   <EOL>  import javafx.application.Application  <EOL>  import javafx.scene.Scene  <EOL>  import javafx.scene.control.*  <EOL>  import javafx.scene.layout.GridPane  <EOL>  import javafx.stage.Stage  <EOL>  import javafx.beans.property.SimpleStringProperty  <EOL>  import javafx.event.EventHandler  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.flow.*  <EOL>  import kotlinx.coroutines.javafx.*  <EOL>  import kotlin.coroutines.CoroutineContext  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(FxAsFlowApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Adapted from  <EOL>   * https://github.com/ReactiveX/RxJavaFX/blob/a <NUM_LIT> ca <NUM_LIT> d <NUM_LIT> f <NUM_LIT> d <NUM_LIT> d <NUM_LIT> df <NUM_LIT> fafb <NUM_LIT> eba <NUM_LIT> ec <NUM_LIT> e <NUM_LIT> /src/test/java/io/reactivex/rxjavafx/RxJavaFXTest.java  <EOL>   */  <EOL>  class FxAsFlowApp: Application(), CoroutineScope {  <EOL>   <EOL>      private var job = Job()  <EOL>      override val coroutineContext: CoroutineContext  <EOL>          get() = JavaFx + job  <EOL>   <EOL>      private val incrementButton = Button( <STR_LIT> )  <EOL>      private val incrementLabel = Label( <STR_LIT> )  <EOL>      private val textInput = TextField()  <EOL>      private val flippedTextLabel = Label()  <EOL>      private val spinner = Spinner<Int>()  <EOL>      private val spinnerChangesLabel = Label()  <EOL>   <EOL>      public override fun start(  primaryStage: Stage) {  <EOL>          val gridPane = GridPane()  <EOL>          gridPane.apply {  <EOL>              hgap =  <NUM_LIT>  <EOL>              vgap =  <NUM_LIT>  <EOL>              add(incrementButton,  <NUM_LIT:0> ,  <NUM_LIT:0> )  <EOL>              add(incrementLabel,  <NUM_LIT:1> ,  <NUM_LIT:0> )  <EOL>              add(textInput,  <NUM_LIT:0> ,  <NUM_LIT:1> )  <EOL>              add(flippedTextLabel,  <NUM_LIT:1> ,  <NUM_LIT:1> )  <EOL>              add(spinner,  <NUM_LIT:0> ,  <NUM_LIT:2> )  <EOL>              add(spinnerChangesLabel,  <NUM_LIT:1> ,  <NUM_LIT:2> )  <EOL>          }  <EOL>          val scene = Scene(gridPane)  <EOL>          primaryStage.apply {  <EOL>              width =  <NUM_LIT>  <EOL>              setScene(scene)  <EOL>              show()  <EOL>          }  <EOL>      }  <EOL>   <EOL>      public override fun stop() {  <EOL>          super.stop()  <EOL>          job.cancel()  <EOL>          job = Job()  <EOL>      }  <EOL>   <EOL>      init {  <EOL>          // Initializing the  <STR_LIT>  button  <EOL>          val stringProperty = SimpleStringProperty()  <EOL>          var i =  <NUM_LIT:0>  <EOL>          incrementButton.onAction = EventHandler {  <EOL>              i +=  <NUM_LIT:1>  <EOL>              stringProperty.set(i.toString())  <EOL>          }  <EOL>          launch {  <EOL>              stringProperty.asFlow().collect {  <EOL>                  if (it != null) {  <EOL>                      stringProperty.set(it)  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>          incrementLabel.textProperty().bind(stringProperty)  <EOL>          // Initializing the reversed text field  <EOL>          val stringProperty <NUM_LIT:2>  = SimpleStringProperty()  <EOL>          launch {  <EOL>              textInput.textProperty().asFlow().collect {  <EOL>                  if (it != null) {  <EOL>                      stringProperty <NUM_LIT:2> .set(it.reversed())  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>          flippedTextLabel.textProperty().bind(stringProperty <NUM_LIT:2> )  <EOL>          // Initializing the spinner  <EOL>          spinner.valueFactory = SpinnerValueFactory.IntegerSpinnerValueFactory( <NUM_LIT:0> ,  <NUM_LIT:100> )  <EOL>          spinner.isEditable = true  <EOL>          val stringProperty <NUM_LIT>  = SimpleStringProperty()  <EOL>          launch {  <EOL>              spinner.valueProperty().asFlow().collect {  <EOL>                  if (it != null) {  <EOL>                      stringProperty <NUM_LIT> .set( <STR_LIT> )  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>          spinnerChangesLabel.textProperty().bind(stringProperty <NUM_LIT> ) ", "gt": ""}
{"input": "<s> package examples  <EOL>   <EOL>  import javafx.application.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.control.*  <EOL>  import javafx.scene.layout.*  <EOL>  import javafx.scene.paint.*  <EOL>  import javafx.scene.shape.*  <EOL>  import javafx.stage.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.javafx.*  <EOL>  import java.text.*  <EOL>  import java.util.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(FxTestApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  fun log(msg: String) = println( <STR_LIT> yyyyMMdd-HHmmss.sss <STR_LIT> )  <EOL>   <EOL>  class FxTestApp : Application(), CoroutineScope {  <EOL>      val buttons = FlowPane().apply {  <EOL>          children += Button( <STR_LIT> ).apply {  <EOL>              setOnAction { doRect() }  <EOL>          }  <EOL>          children += Button( <STR_LIT> ).apply {  <EOL>              setOnAction { doCircle() }  <EOL>          }  <EOL>          children += Button( <STR_LIT> ).apply {  <EOL>              setOnAction { doClear() }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      val root = Pane().apply {  <EOL>          children += buttons  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> )  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>      }  <EOL>   <EOL>      val random = Random()  <EOL>      var animationIndex =  <NUM_LIT:0>  <EOL>      var job = Job()  <EOL>      override val coroutineContext: CoroutineContext  <EOL>          get() = Dispatchers.JavaFx + job  <EOL>   <EOL>      private fun animation(node: Node, block: suspend CoroutineScope.() -> Unit) {  <EOL>          root.children += node  <EOL>          launch(block = block).also {  <EOL>              it.invokeOnCompletion { root.children -= node }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      fun doRect() {  <EOL>          val node = Rectangle( <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>              fill = Color.RED  <EOL>          }  <EOL>          val index = ++animationIndex  <EOL>          val speed =  <NUM_LIT>  <EOL>          animation(node) {  <EOL>              log( <STR_LIT> )  <EOL>              var vx = speed  <EOL>              var vy = speed  <EOL>              var counter =  <NUM_LIT:0>  <EOL>              while (true) {  <EOL>                  awaitPulse()  <EOL>                  node.x += vx  <EOL>                  node.y += vy  <EOL>                  val xRange =  <NUM_LIT:0.0>  .. scene.width - node.width  <EOL>                  val yRange =  <NUM_LIT:0.0>  .. scene.height - node.height  <EOL>                  if (node.x !in xRange ) {  <EOL>                      node.x = node.x.coerceIn(xRange)  <EOL>                      vx = -vx  <EOL>                  }  <EOL>                  if (node.y !in yRange) {  <EOL>                      node.y = node.y.coerceIn(yRange)  <EOL>                      vy = -vy  <EOL>                  }  <EOL>                  if (counter++ >  <NUM_LIT:100> ) {  <EOL>                      counter =  <NUM_LIT:0>  <EOL>                      delay( <NUM_LIT> ) // pause a bit  <EOL>                      log( <STR_LIT> )  <EOL>                      val t = vx  <EOL>                      vx = vy  <EOL>                      vy = -t  <EOL>                  }  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      fun doCircle() {  <EOL>          val node = Circle( <NUM_LIT> ).apply {  <EOL>              fill = Color.BLUE  <EOL>          }  <EOL>          val index = ++animationIndex  <EOL>          val acceleration =  <NUM_LIT>  <EOL>          val maxSpeed =  <NUM_LIT>  <EOL>          animation(node) {  <EOL>              log( <STR_LIT> )  <EOL>              var sx = random.nextDouble() * maxSpeed  <EOL>              var sy = random.nextDouble() * maxSpeed  <EOL>              while (true) {  <EOL>                  awaitPulse()  <EOL>                  val dx = root.width /  <NUM_LIT:2>  - node.translateX  <EOL>                  val dy = root.height /  <NUM_LIT:2>  - node.translateY  <EOL>                  val dn = Math.sqrt(dx * dx + dy * dy)  <EOL>                  sx += dx / dn * acceleration  <EOL>                  sy += dy / dn * acceleration  <EOL>                  val sn = Math.sqrt(sx * sx + sy * sy)  <EOL>                  val trim = sn.coerceAtMost(maxSpeed)  <EOL>                  sx = sx / sn * trim  <EOL>                  sy = sy / sn * trim  <EOL>                  node.translateX += sx  <EOL>                  node.translateY += sy  <EOL>              }  <EOL>          }  <EOL>      }  <EOL>   <EOL>      fun doClear() {  <EOL>          job.cancel() ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiActor <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      fab.onClick { // start coroutine when the circle is clicked  <EOL>          for (i in  <NUM_LIT:10>  downTo  <NUM_LIT:1> ) { // countdown from  <NUM_LIT:10>  to  <NUM_LIT:1>    <EOL>              hello.text =  <STR_LIT>  // update text  <EOL>              delay( <NUM_LIT> ) // wait half a second  <EOL>          }  <EOL>          hello.text =  <STR_LIT>  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun Node.onClick(action: suspend (MouseEvent) -> Unit) {  <EOL>      onMouseClicked = EventHandler { event ->  <EOL>          GlobalScope.launch(Dispatchers.Main) {   <EOL>              action(event)  <EOL>          } ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiActor <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      fab.onClick { // start coroutine when the circle is clicked  <EOL>          for (i in  <NUM_LIT:10>  downTo  <NUM_LIT:1> ) { // countdown from  <NUM_LIT:10>  to  <NUM_LIT:1>    <EOL>              hello.text =  <STR_LIT>  // update text  <EOL>              delay( <NUM_LIT> ) // wait half a second  <EOL>          }  <EOL>          hello.text =  <STR_LIT>  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun Node.onClick(action: suspend (MouseEvent) -> Unit) {  <EOL>      // launch one actor to handle all events on this node  <EOL>      val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main) {  <EOL>          for (event in channel) action(event) // pass event to action  <EOL>      }  <EOL>      // install a listener to offer events to this actor  <EOL>      onMouseClicked = EventHandler { event ->  <EOL>          eventActor.trySend(event) ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiActor <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      fab.onClick { // start coroutine when the circle is clicked  <EOL>          for (i in  <NUM_LIT:10>  downTo  <NUM_LIT:1> ) { // countdown from  <NUM_LIT:10>  to  <NUM_LIT:1>    <EOL>              hello.text =  <STR_LIT>  // update text  <EOL>              delay( <NUM_LIT> ) // wait half a second  <EOL>          }  <EOL>          hello.text =  <STR_LIT>  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun Node.onClick(action: suspend (MouseEvent) -> Unit) {  <EOL>      // launch one actor to handle all events on this node  <EOL>      val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main, capacity = Channel.CONFLATED) { // <--- Changed here  <EOL>          for (event in channel) action(event) // pass event to action  <EOL>      }  <EOL>      // install a listener to send events to this actor  <EOL>      onMouseClicked = EventHandler { event ->  <EOL>          eventActor.trySend(event) ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiAdvanced <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      fab.onMouseClicked = EventHandler {  <EOL>          println( <STR_LIT> )  <EOL>          GlobalScope.launch(Dispatchers.Main) {  <EOL>              println( <STR_LIT> )  <EOL>              delay( <NUM_LIT:100> )  <EOL>              println( <STR_LIT> )  <EOL>          }   <EOL>          println( <STR_LIT> ) ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiAdvanced <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      fab.onMouseClicked = EventHandler {  <EOL>          println( <STR_LIT> )  <EOL>          GlobalScope.launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { // <--- Notice this change  <EOL>              println( <STR_LIT> )  <EOL>              delay( <NUM_LIT:100> )                            // <--- And this is where coroutine suspends        <EOL>              println( <STR_LIT> )  <EOL>          }  <EOL>          println( <STR_LIT> ) ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiBasic <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) { ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiBasic <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      GlobalScope.launch(Dispatchers.Main) { // launch coroutine in the main thread  <EOL>          for (i in  <NUM_LIT:10>  downTo  <NUM_LIT:1> ) { // countdown from  <NUM_LIT:10>  to  <NUM_LIT:1>    <EOL>              hello.text =  <STR_LIT>  // update text  <EOL>              delay( <NUM_LIT> ) // wait half a second  <EOL>          }  <EOL>          hello.text =  <STR_LIT> ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiBasic <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      val job = GlobalScope.launch(Dispatchers.Main) { // launch coroutine in the main thread  <EOL>          for (i in  <NUM_LIT:10>  downTo  <NUM_LIT:1> ) { // countdown from  <NUM_LIT:10>  to  <NUM_LIT:1>    <EOL>              hello.text =  <STR_LIT>  // update text  <EOL>              delay( <NUM_LIT> ) // wait half a second  <EOL>          }  <EOL>          hello.text =  <STR_LIT>  <EOL>      } ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiBlocking <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun Node.onClick(action: suspend (MouseEvent) -> Unit) {  <EOL>      val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main, capacity = Channel.CONFLATED) {  <EOL>          for (event in channel) action(event) // pass event to action  <EOL>      }  <EOL>      onMouseClicked = EventHandler { event ->  <EOL>          eventActor.trySend(event)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun fib(x: Int): Int =  <EOL>      if (x <=  <NUM_LIT:1> ) x else fib(x -  <NUM_LIT:1> ) + fib(x -  <NUM_LIT:2> )  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      var result =  <STR_LIT>  // the last result  <EOL>      // counting animation   <EOL>      GlobalScope.launch(Dispatchers.Main) {  <EOL>          var counter =  <NUM_LIT:0>  <EOL>          while (true) {  <EOL>              hello.text =  <STR_LIT>  <EOL>              delay( <NUM_LIT:100> ) // update the text every  <NUM_LIT:100> ms  <EOL>          }  <EOL>      }  <EOL>      // compute the next fibonacci number of each click  <EOL>      var x =  <NUM_LIT:1>  <EOL>      fab.onClick {  <EOL>          result =  <STR_LIT>  <EOL>          x++ ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiBlocking <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun Node.onClick(action: suspend (MouseEvent) -> Unit) {  <EOL>      val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main, capacity = Channel.CONFLATED) {  <EOL>          for (event in channel) action(event) // pass event to action  <EOL>      }  <EOL>      onMouseClicked = EventHandler { event ->  <EOL>          eventActor.trySend(event)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      var result =  <STR_LIT>  // the last result  <EOL>      // counting animation   <EOL>      GlobalScope.launch(Dispatchers.Main) {  <EOL>          var counter =  <NUM_LIT:0>  <EOL>          while (true) {  <EOL>              hello.text =  <STR_LIT>  <EOL>              delay( <NUM_LIT:100> ) // update the text every  <NUM_LIT:100> ms  <EOL>          }  <EOL>      }  <EOL>      // compute next fibonacci number of each click  <EOL>      var x =  <NUM_LIT:1>  <EOL>      fab.onClick {  <EOL>          result =  <STR_LIT>  <EOL>          x++  <EOL>      }  <EOL>  }  <EOL>   <EOL>  suspend fun fib(x: Int): Int = withContext(Dispatchers.Default) { ", "gt": ""}
{"input": "<s> // This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.  <EOL>  package kotlinx.coroutines.javafx.guide.exampleUiBlocking <NUM_LIT>  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.channels.*  <EOL>  import kotlinx.coroutines.javafx.JavaFx as Main  <EOL>  import javafx.application.Application  <EOL>  import javafx.event.EventHandler  <EOL>  import javafx.geometry.*  <EOL>  import javafx.scene.*  <EOL>  import javafx.scene.input.MouseEvent  <EOL>  import javafx.scene.layout.StackPane  <EOL>  import javafx.scene.paint.Color  <EOL>  import javafx.scene.shape.Circle  <EOL>  import javafx.scene.text.Text  <EOL>  import javafx.stage.Stage  <EOL>   <EOL>  fun main(args: Array<String>) {  <EOL>      Application.launch(ExampleApp::class.java, *args)  <EOL>  }  <EOL>   <EOL>  class ExampleApp : Application() {  <EOL>      val hello = Text( <STR_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      val fab = Circle( <NUM_LIT> , Color.valueOf( <STR_LIT> ))  <EOL>   <EOL>      val root = StackPane().apply {  <EOL>          children += hello  <EOL>          children += fab  <EOL>          StackPane.setAlignment(hello, Pos.CENTER)  <EOL>          StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)  <EOL>          StackPane.setMargin(fab, Insets( <NUM_LIT> ))  <EOL>      }  <EOL>   <EOL>      val scene = Scene(root,  <NUM_LIT> ,  <NUM_LIT> ).apply {  <EOL>          fill = Color.valueOf( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun start(stage: Stage) {  <EOL>          stage.title =  <STR_LIT>  <EOL>          stage.scene = scene  <EOL>          stage.show()  <EOL>          setup(hello, fab)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun Node.onClick(action: suspend (MouseEvent) -> Unit) {  <EOL>      val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main, capacity = Channel.CONFLATED) {  <EOL>          for (event in channel) action(event) // pass event to action  <EOL>      }  <EOL>      onMouseClicked = EventHandler { event ->  <EOL>          eventActor.trySend(event)  <EOL>      }  <EOL>  }  <EOL>   <EOL>  fun setup(hello: Text, fab: Circle) {  <EOL>      var result =  <STR_LIT>  // the last result  <EOL>      // counting animation   <EOL>      GlobalScope.launch(Dispatchers.Main) {  <EOL>          var counter =  <NUM_LIT:0>  <EOL>          while (true) {  <EOL>              hello.text =  <STR_LIT>  <EOL>              delay( <NUM_LIT:100> ) // update the text every  <NUM_LIT:100> ms  <EOL>          }  <EOL>      }  <EOL>      // compute next fibonacci number of each click  <EOL>      var x =  <NUM_LIT:1>  <EOL>      fab.onClick {  <EOL>          result =  <STR_LIT>  <EOL>          x++  <EOL>      }  <EOL>  }  <EOL>   <EOL>  suspend fun fib(x: Int): Int = withContext(Dispatchers.Default) {  <EOL>      fibBlocking(x)  <EOL>  }  <EOL>  ", "gt": ""}
{"input": "<s> dependencies { ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.swing  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.internal.*  <EOL>  import java.awt.event.*  <EOL>  import javax.swing.*  <EOL>  import kotlin.coroutines.*  <EOL>   <EOL>  /**  <EOL>   * Dispatches execution onto Swing event dispatching thread and provides native [delay] support.  <EOL>   */  <EOL>  @Suppress( <STR_LIT> )  <EOL>  public val Dispatchers.Swing : SwingDispatcher  <EOL>      get() = kotlinx.coroutines.swing.Swing  <EOL>   <EOL>  /**  <EOL>   * Dispatcher for Swing event dispatching thread.  <EOL>   *  <EOL>   * This class provides type-safety and a point for future extensions.  <EOL>   */  <EOL>  public sealed class SwingDispatcher : MainCoroutineDispatcher(), Delay {  <EOL>      /** @suppress */  <EOL>      override fun dispatch(context: CoroutineContext, block: Runnable): Unit = SwingUtilities.invokeLater(block)  <EOL>   <EOL>      /** @suppress */  <EOL>      override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {  <EOL>          val timer = schedule(timeMillis) {  <EOL>              with(continuation) { resumeUndispatched(Unit) }  <EOL>          }  <EOL>          continuation.invokeOnCancellation { timer.stop() }  <EOL>      }  <EOL>   <EOL>      /** @suppress */  <EOL>      override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {  <EOL>          val timer = schedule(timeMillis) {  <EOL>              block.run()  <EOL>          }  <EOL>          return DisposableHandle { timer.stop() }  <EOL>      }  <EOL>   <EOL>      private fun schedule(timeMillis: Long, action: ActionListener): Timer =  <EOL>          Timer(timeMillis.coerceAtMost(Int.MAX_VALUE.toLong()).toInt(), action).apply {  <EOL>              isRepeats = false  <EOL>              start()  <EOL>          }  <EOL>  }  <EOL>   <EOL>  internal class SwingDispatcherFactory : MainDispatcherFactory {  <EOL>      override val loadPriority: Int  <EOL>          get() =  <NUM_LIT:0>  <EOL>   <EOL>      override fun createDispatcher(allFactories: List<MainDispatcherFactory>): MainCoroutineDispatcher = Swing  <EOL>  }  <EOL>   <EOL>  private object ImmediateSwingDispatcher : SwingDispatcher() {  <EOL>      override val immediate: MainCoroutineDispatcher  <EOL>          get() = this  <EOL>   <EOL>      override fun isDispatchNeeded(context: CoroutineContext): Boolean = !SwingUtilities.isEventDispatchThread()  <EOL>   <EOL>      override fun toString() = toStringInternalImpl() ?:  <STR_LIT>  <EOL>  }  <EOL>   <EOL>  /**  <EOL>   * Dispatches execution onto Swing event dispatching thread and provides native [delay] support.  <EOL>   */  <EOL>  internal object Swing : SwingDispatcher() {  <EOL>   <EOL>      /* A workaround so that the dispatcher's initialization crashes with an exception if running in a headless  <EOL>      environment. This is needed so that this broken dispatcher is not used as the source of delays. */  <EOL>      init {  <EOL>          Timer( <NUM_LIT:1> ) { }.apply {  <EOL>              isRepeats = false  <EOL>              start()  <EOL>          }  <EOL>      }  <EOL>   <EOL>      override val immediate: MainCoroutineDispatcher  <EOL>          get() = ImmediateSwingDispatcher  <EOL>  ", "gt": ""}
{"input": "<s> package kotlinx.coroutines.swing  <EOL>   <EOL>  import kotlinx.coroutines.testing.*  <EOL>  import kotlinx.coroutines.*  <EOL>  import org.junit.*  <EOL>  import org.junit.Test  <EOL>  import javax.swing.*  <EOL>  import kotlin.test.*  <EOL>   <EOL>  class SwingTest : MainDispatcherTestBase.WithRealTimeDelay() {  <EOL>      @Before  <EOL>      fun setup() {  <EOL>          ignoreLostThreads( <STR_LIT> )  <EOL>      }  <EOL>   <EOL>      override fun isMainThread() = SwingUtilities.isEventDispatchThread()  <EOL>   <EOL>      override fun scheduleOnMainQueue(block: () -> Unit) {  <EOL>          SwingUtilities.invokeLater { block() }  <EOL>      }  <EOL>   <EOL>      /** Tests that the Main dispatcher is in fact the JavaFx one. */  <EOL>      @Test  <EOL>      fun testMainIsJavaFx() {  <EOL>          assertSame(Dispatchers.Swing, Dispatchers.Main) ", "gt": ""}
{"input": "<s> package examples  <EOL>   <EOL>  import kotlinx.coroutines.*  <EOL>  import kotlinx.coroutines.future.*  <EOL>  import kotlinx.coroutines.swing.*  <EOL>  import java.awt.*  <EOL>  import java.util.concurrent.*  <EOL>  import javax.swing.*  <EOL>   <EOL>  private fun createAndShowGUI() {  <EOL>      val frame = JFrame( <STR_LIT> )  <EOL>      frame.defaultCloseOperation = JFrame.EXIT_ON_CLOSE  <EOL>   <EOL>      val jProgressBar = JProgressBar( <NUM_LIT:0> ,  <NUM_LIT:100> ).apply {  <EOL>          value =  <NUM_LIT:0>  <EOL>          isStringPainted = true  <EOL>      }  <EOL>   <EOL>      val jTextArea = JTextArea( <NUM_LIT> ,  <NUM_LIT:10> )  <EOL>      jTextArea.margin = Insets( <NUM_LIT> ,  <NUM_LIT> ,  <NUM_LIT> ,  <NUM_LIT> )  <EOL>      jTextArea.isEditable = false  <EOL>   <EOL>      val panel = JPanel()  <EOL>   <EOL>      panel.add(jProgressBar)  <EOL>      panel.add(jTextArea)  <EOL>   <EOL>      frame.contentPane.add(panel)  <EOL>      frame.pack()  <EOL>      frame.isVisible = true  <EOL>   <EOL>      GlobalScope.launch(Dispatchers.Swing) {  <EOL>          for (i in  <NUM_LIT:1> .. <NUM_LIT:10> ) {  <EOL>              // 'append' method and consequent 'jProgressBar.setValue' are called  <EOL>              // within Swing event dispatch thread  <EOL>              jTextArea.append(  <EOL>                      startLongAsyncOperation(i).await()  <EOL>              )  <EOL>              jProgressBar.value = i *  <NUM_LIT:10>  <EOL>          }  <EOL>      }  <EOL>  }  <EOL>   <EOL>  private fun startLongAsyncOperation(v: Int) =  <EOL>          CompletableFuture.supplyAsync {  <EOL>              Thread.sleep( <NUM_LIT> )  <EOL>               <STR_LIT>  <EOL>          }  <EOL>   <EOL>  fun main(args: Array<String>) { ", "gt": ""}
