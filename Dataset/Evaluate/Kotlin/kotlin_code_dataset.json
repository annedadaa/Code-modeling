[
    {
        "path": "benchmarks/build.gradle.kts",
        "content": "@file:Suppress(\"UnstableApiUsage\")\n\nimport org.jetbrains.kotlin.gradle.tasks.*\nimport org.jetbrains.kotlin.gradle.dsl.JvmTarget\n\nplugins {\n    id(\"com.github.johnrengelman.shadow\")\n    id(\"me.champeau.jmh\")\n}\n\nrepositories {\n    maven(\"https://repo.typesafe.com/typesafe/releases/\")\n}\n\njava {\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n}\n\ntasks.named<KotlinCompile>(\"compileJmhKotlin\") {\n    compilerOptions {\n        jvmTarget = JvmTarget.JVM_1_8\n        freeCompilerArgs.add(\"-Xjvm-default=all\")\n    }\n}\n\nval jmhJarTask = tasks.named<Jar>(\"jmhJar\") {\n    archiveBaseName = \"benchmarks\"\n    archiveClassifier = null\n    archiveVersion = null\n    archiveVersion.convention(null as String?)\n    destinationDirectory = rootDir\n}\n\ntasks {\n    // For some reason the DuplicatesStrategy from jmh is not enough\n    // and errors with duplicates appear unless I force it to WARN only:\n    withType<Copy> {\n        duplicatesStrategy = DuplicatesStrategy.WARN\n    }\n\n    build {\n        dependsOn(jmhJarTask)\n    }\n}\n\ndependencies {\n    implementation(\"org.openjdk.jmh:jmh-core:1.35\")\n    implementation(\"io.projectreactor:reactor-core:${version(\"reactor\")}\")\n    implementation(\"io.reactivex.rxjava2:rxjava:2.1.9\")\n    implementation(\"com.github.akarnokd:rxjava2-extensions:0.20.8\")\n\n    implementation(\"com.typesafe.akka:akka-actor_2.12:2.5.0\")\n    implementation(project(\":kotlinx-coroutines-core\"))\n    implementation(project(\":kotlinx-coroutines-debug\"))\n    implementation(project(\":kotlinx-coroutines-reactive\"))\n\n    // add jmh dependency on main\n    \"jmhImplementation\"(sourceSets.main.get().runtimeClasspath)\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/ChannelSinkBenchmark.kt",
        "content": "package benchmarks\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n@Warmup(iterations = 7, time = 1)\n@Measurement(iterations = 5, time = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\n@Fork(1)\nopen class ChannelSinkBenchmark {\n    private val tl = ThreadLocal.withInitial({ 42 })\n    private val tl2 = ThreadLocal.withInitial({ 239 })\n\n    private val unconfined = Dispatchers.Unconfined\n    private val unconfinedOneElement = Dispatchers.Unconfined + tl.asContextElement()\n    private val unconfinedTwoElements = Dispatchers.Unconfined + tl.asContextElement() + tl2.asContextElement()\n\n    @Benchmark\n    fun channelPipeline(): Int = runBlocking {\n        run(unconfined)\n    }\n\n    @Benchmark\n    fun channelPipelineOneThreadLocal(): Int = runBlocking {\n        run(unconfinedOneElement)\n    }\n\n    @Benchmark\n    fun channelPipelineTwoThreadLocals(): Int = runBlocking {\n        run(unconfinedTwoElements)\n    }\n\n    private suspend inline fun run(context: CoroutineContext): Int {\n        return Channel\n            .range(1, 10_000, context)\n            .filter(context) { it % 4 == 0 }\n            .fold(0) { a, b -> a + b }\n    }\n\n    private fun Channel.Factory.range(start: Int, count: Int, context: CoroutineContext) = GlobalScope.produce(context) {\n        for (i in start until (start + count))\n            send(i)\n    }\n\n    // Migrated from deprecated operators, are good only for stressing channels\n\n    private fun <E> ReceiveChannel<E>.filter(context: CoroutineContext = Dispatchers.Unconfined, predicate: suspend (E) -> Boolean): ReceiveChannel<E> =\n        GlobalScope.produce(context, onCompletion = { cancel() }) {\n            for (e in this@filter) {\n                if (predicate(e)) send(e)\n            }\n        }\n\n    private suspend inline fun <E, R> ReceiveChannel<E>.fold(initial: R, operation: (acc: R, E) -> R): R {\n        var accumulator = initial\n        consumeEach {\n            accumulator = operation(accumulator, it)\n        }\n        return accumulator\n    }\n}\n\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/ChannelSinkDepthBenchmark.kt",
        "content": "package benchmarks\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n@Warmup(iterations = 7, time = 1)\n@Measurement(iterations = 5, time = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\n@Fork(2)\nopen class ChannelSinkDepthBenchmark {\n    private val tl = ThreadLocal.withInitial({ 42 })\n\n    private val unconfinedOneElement = Dispatchers.Unconfined + tl.asContextElement()\n\n    @Benchmark\n    fun depth1(): Int = runBlocking {\n        run(1, unconfinedOneElement)\n    }\n\n    @Benchmark\n    fun depth10(): Int = runBlocking {\n        run(10, unconfinedOneElement)\n    }\n\n    @Benchmark\n    fun depth100(): Int = runBlocking {\n        run(100, unconfinedOneElement)\n    }\n\n    @Benchmark\n    fun depth1000(): Int = runBlocking {\n        run(1000, unconfinedOneElement)\n    }\n\n    private suspend inline fun run(callTraceDepth: Int, context: CoroutineContext): Int {\n        return Channel\n            .range(1, 10_000, context)\n            .filter(callTraceDepth, context) { it % 4 == 0 }\n            .fold(0) { a, b -> a + b }\n    }\n\n    private fun Channel.Factory.range(start: Int, count: Int, context: CoroutineContext) =\n        GlobalScope.produce(context) {\n            for (i in start until (start + count))\n                send(i)\n        }\n\n    // Migrated from deprecated operators, are good only for stressing channels\n\n    private fun ReceiveChannel<Int>.filter(\n        callTraceDepth: Int,\n        context: CoroutineContext = Dispatchers.Unconfined,\n        predicate: suspend (Int) -> Boolean\n    ): ReceiveChannel<Int> =\n        GlobalScope.produce(context, onCompletion = { cancel() }) {\n            deeplyNestedFilter(this, callTraceDepth, predicate)\n        }\n\n    private suspend fun ReceiveChannel<Int>.deeplyNestedFilter(\n        sink: ProducerScope<Int>,\n        depth: Int,\n        predicate: suspend (Int) -> Boolean\n    ) {\n        if (depth <= 1) {\n            for (e in this) {\n                if (predicate(e)) sink.send(e)\n            }\n        } else {\n            deeplyNestedFilter(sink, depth - 1, predicate)\n            require(true) // tail-call\n        }\n    }\n\n    private suspend inline fun <E, R> ReceiveChannel<E>.fold(initial: R, operation: (acc: R, E) -> R): R {\n        var accumulator = initial\n        consumeEach {\n            accumulator = operation(accumulator, it)\n        }\n        return accumulator\n    }\n}\n\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/ChannelSinkNoAllocationsBenchmark.kt",
        "content": "package benchmarks\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n@Warmup(iterations = 3, time = 1)\n@Measurement(iterations = 5, time = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\n@Fork(1)\nopen class ChannelSinkNoAllocationsBenchmark {\n    private val unconfined = Dispatchers.Unconfined\n\n    @Benchmark\n    fun channelPipeline(): Int = runBlocking {\n        run(unconfined)\n    }\n\n    private suspend inline fun run(context: CoroutineContext): Int {\n        var size = 0\n        Channel.range(context).consumeEach { size++ }\n        return size\n    }\n\n    private fun Channel.Factory.range(context: CoroutineContext) = GlobalScope.produce(context) {\n        for (i in 0 until 100_000)\n            send(Unit) // no allocations\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/ParametrizedDispatcherBase.kt",
        "content": "package benchmarks\n\nimport benchmarks.akka.CORES_COUNT\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.scheduling.*\nimport org.openjdk.jmh.annotations.Param\nimport org.openjdk.jmh.annotations.Setup\nimport org.openjdk.jmh.annotations.TearDown\nimport java.io.Closeable\nimport java.util.concurrent.*\nimport kotlin.coroutines.CoroutineContext\n\n/**\n * Base class to use different [CoroutineContext] in benchmarks via [Param] in inheritors.\n * Currently allowed values are \"fjp\" for [CommonPool] and ftp_n for [ThreadPoolDispatcher] with n threads.\n */\nabstract class ParametrizedDispatcherBase : CoroutineScope {\n\n    abstract var dispatcher: String\n    override lateinit var coroutineContext: CoroutineContext\n    private var closeable: Closeable? = null\n\n    @Setup\n    open fun setup() {\n        coroutineContext = when {\n            dispatcher == \"fjp\" -> ForkJoinPool.commonPool().asCoroutineDispatcher()\n            dispatcher == \"scheduler\" -> {\n                Dispatchers.Default\n            }\n            dispatcher.startsWith(\"ftp\") -> {\n                newFixedThreadPoolContext(dispatcher.substring(4).toInt(), dispatcher).also { closeable = it }\n            }\n            else -> error(\"Unexpected dispatcher: $dispatcher\")\n        }\n    }\n\n    @TearDown\n    fun tearDown() {\n        closeable?.close()\n    }\n\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/SequentialSemaphoreBenchmark.kt",
        "content": "package benchmarks\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.TimeUnit\nimport kotlin.test.*\n\n@Warmup(iterations = 5, time = 1)\n@Measurement(iterations = 10, time = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\n@Fork(1)\nopen class SequentialSemaphoreAsMutexBenchmark {\n    val s = Semaphore(1)\n\n    @Benchmark\n    fun benchmark() : Unit = runBlocking {\n        val s = Semaphore(permits = 1, acquiredPermits = 1)\n        var step = 0\n        launch(Dispatchers.Unconfined) {\n            repeat(N) {\n                assertEquals(it * 2, step)\n                step++\n                s.acquire()\n            }\n        }\n        repeat(N) {\n            assertEquals(it * 2 + 1, step)\n            step++\n            s.release()\n        }\n    }\n}\n\nfun main() = SequentialSemaphoreAsMutexBenchmark().benchmark()\n\nprivate val N = 1_000_000"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/akka/PingPongAkkaBenchmark.kt",
        "content": "package benchmarks.akka\n\nimport akka.actor.*\nimport com.typesafe.config.*\nimport org.openjdk.jmh.annotations.*\nimport scala.concurrent.*\nimport scala.concurrent.duration.*\nimport java.util.concurrent.*\n\nconst val N_MESSAGES = 100_000\n\ndata class Ball(val count: Int)\nclass Start\nclass Stop\n\n/*\n * Benchmark                                              (dispatcher)  Mode  Cnt    Score    Error  Units\n * PingPongAkkaBenchmark.coresCountPingPongs        default-dispatcher  avgt   10  277.501 \u00b1 38.583  ms/op\n * PingPongAkkaBenchmark.coresCountPingPongs  single-thread-dispatcher  avgt   10  196.192 \u00b1  9.889  ms/op\n *\n * PingPongAkkaBenchmark.singlePingPong             default-dispatcher  avgt   10  173.742 \u00b1 41.984  ms/op\n * PingPongAkkaBenchmark.singlePingPong       single-thread-dispatcher  avgt   10   24.181 \u00b1  0.730  ms/op\n */\n//@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n//@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n//@Fork(value = 2)\n//@BenchmarkMode(Mode.AverageTime)\n//@OutputTimeUnit(TimeUnit.MILLISECONDS)\n//@State(Scope.Benchmark)\nopen class PingPongAkkaBenchmark {\n\n    lateinit var system: ActorSystem\n\n    @Param(\"default-dispatcher\", \"single-thread-dispatcher\")\n    var dispatcher: String = \"akka.actor.default-dispatcher\"\n\n    @Setup\n    fun setup() {\n        system = ActorSystem.create(\"PingPong\", ConfigFactory.parseString(\"\"\"\n            akka.actor.single-thread-dispatcher {\n                type = Dispatcher\n                executor = \"thread-pool-executor\"\n                thread-pool-executor {\n                    fixed-pool-size = 1\n                }\n                throughput = 1\n            }\n            \"\"\".trimIndent()\n        ))\n    }\n\n    @TearDown\n    fun tearDown() {\n        Await.ready(system.terminate(), Duration.Inf())\n    }\n\n//    @Benchmark\n    fun singlePingPong() {\n        runPingPongs(1)\n    }\n\n//    @Benchmark\n    fun coresCountPingPongs() {\n        runPingPongs(Runtime.getRuntime().availableProcessors())\n    }\n\n    private fun runPingPongs(pairsCount: Int) {\n        val latch = CountDownLatch(pairsCount)\n        repeat(pairsCount) {\n            val pongRef = system.actorOf(Props.create(PongActorAkka::class.java)\n                    .withDispatcher(\"akka.actor.$dispatcher\"))\n            val pingRef = system.actorOf(Props.create(PingActorAkka::class.java, pongRef, latch)\n                    .withDispatcher(\"akka.actor.$dispatcher\"))\n            pingRef.tell(Start(), ActorRef.noSender())\n        }\n\n        latch.await()\n    }\n\n    class PingActorAkka(val pongRef: ActorRef, val stopLatch: CountDownLatch) : UntypedAbstractActor() {\n        override fun onReceive(msg: Any?) {\n            when (msg) {\n                is Start -> {\n                    pongRef.tell(Ball(0), self)\n                }\n                is Ball -> {\n                    pongRef.tell(Ball(count = msg.count + 1), self)\n                }\n                is Stop -> {\n                    stopLatch.countDown()\n                    context.stop(self)\n                }\n                else -> unhandled(msg)\n            }\n        }\n    }\n\n    class PongActorAkka : UntypedAbstractActor() {\n        override fun onReceive(msg: Any?) {\n            when (msg) {\n                is Ball -> {\n                    if (msg.count >= N_MESSAGES) {\n                        sender.tell(Stop(), self)\n                        context.stop(self)\n                    } else {\n                        sender.tell(Ball(msg.count + 1), self)\n                    }\n                }\n                else -> unhandled(msg)\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/akka/StatefulActorAkkaBenchmark.kt",
        "content": "package benchmarks.akka\n\nimport akka.actor.*\nimport com.typesafe.config.*\nimport org.openjdk.jmh.annotations.*\nimport scala.concurrent.*\nimport scala.concurrent.duration.*\nimport java.util.concurrent.*\n\nconst val ROUNDS = 10_000\nconst val STATE_SIZE = 1024\nval CORES_COUNT = Runtime.getRuntime().availableProcessors()\n\n/*\n * Benchmarks following computation pattern:\n * N actors, each has independent state (coefficients), receives numbers and answers with product and\n * N requestors, which randomly send requests. N roundtrips over every requestor are measured\n *\n * Benchmark                                                                      (dispatcher)  Mode  Cnt    Score    Error  Units\n * StatefulActorAkkaBenchmark.multipleComputationsMultipleRequestors        default-dispatcher  avgt   14   72.568 \u00b1 10.620  ms/op\n * StatefulActorAkkaBenchmark.multipleComputationsMultipleRequestors  single-thread-dispatcher  avgt   14   70.198 \u00b1  3.594  ms/op\n *\n * StatefulActorAkkaBenchmark.multipleComputationsSingleRequestor           default-dispatcher  avgt   14   36.737 \u00b1  3.589  ms/op\n * StatefulActorAkkaBenchmark.multipleComputationsSingleRequestor     single-thread-dispatcher  avgt   14    9.050 \u00b1  0.385  ms/op\n *\n * StatefulActorAkkaBenchmark.singleComputationMultipleRequestors           default-dispatcher  avgt   14  446.563 \u00b1 85.577  ms/op\n * StatefulActorAkkaBenchmark.singleComputationMultipleRequestors     single-thread-dispatcher  avgt   14   70.250 \u00b1  3.104  ms/op\n *\n * StatefulActorAkkaBenchmark.singleComputationSingleRequestor              default-dispatcher  avgt   14   39.964 \u00b1  2.343  ms/op\n * StatefulActorAkkaBenchmark.singleComputationSingleRequestor        single-thread-dispatcher  avgt   14   10.214 \u00b1  2.152  ms/op\n */\n//@Warmup(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n//@Measurement(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n//@Fork(value = 2)\n//@BenchmarkMode(Mode.AverageTime)\n//@OutputTimeUnit(TimeUnit.MILLISECONDS)\n//@State(Scope.Benchmark)\nopen class StatefulActorAkkaBenchmark {\n\n    lateinit var system: ActorSystem\n\n    @Param(\"default-dispatcher\", \"single-thread-dispatcher\")\n    var dispatcher: String = \"akka.actor.default-dispatcher\"\n\n    @Setup\n    fun setup() {\n        // TODO extract it to common AkkaBase if new benchmark will appear\n        system = ActorSystem.create(\"StatefulActors\", ConfigFactory.parseString(\"\"\"\n            akka.actor.single-thread-dispatcher {\n                type = Dispatcher\n                executor = \"thread-pool-executor\"\n                thread-pool-executor {\n                    fixed-pool-size = 1\n                }\n                throughput = 1\n            }\n            \"\"\".trimIndent()\n        ))\n    }\n\n    @TearDown\n    fun tearDown() {\n        Await.ready(system.terminate(), Duration.Inf())\n    }\n\n//    @Benchmark\n    fun singleComputationSingleRequestor() {\n        run(1, 1)\n    }\n\n//    @Benchmark\n    fun singleComputationMultipleRequestors() {\n        run(1, CORES_COUNT)\n    }\n\n//    @Benchmark\n    fun multipleComputationsSingleRequestor() {\n        run(CORES_COUNT, 1)\n    }\n\n//    @Benchmark\n    fun multipleComputationsMultipleRequestors() {\n        run(CORES_COUNT, CORES_COUNT)\n    }\n\n    private fun run(computationActors: Int, requestorActors: Int) {\n        val stopLatch = CountDownLatch(requestorActors)\n        /*\n         * For complex setups Akka creates actors slowly,\n         * so first start message may become dead letter (and freeze benchmark)\n         */\n        val initLatch = CountDownLatch(computationActors + requestorActors)\n        val computations = createComputationActors(initLatch, computationActors)\n        val requestors = createRequestorActors(requestorActors, computations, initLatch, stopLatch)\n\n        initLatch.await()\n        for (requestor in requestors) {\n            requestor.tell(1L, ActorRef.noSender())\n        }\n\n        stopLatch.await()\n        computations.forEach { it.tell(Stop(), ActorRef.noSender()) }\n    }\n\n    private fun createRequestorActors(requestorActors: Int, computations: List<ActorRef>, initLatch: CountDownLatch, stopLatch: CountDownLatch): List<ActorRef> {\n        return (0 until requestorActors).map {\n            system.actorOf(Props.create(RequestorActor::class.java, computations, initLatch, stopLatch)\n                    .withDispatcher(\"akka.actor.$dispatcher\"))\n        }\n    }\n\n    private fun createComputationActors(initLatch: CountDownLatch, count: Int): List<ActorRef> {\n        return (0 until count).map {\n            system.actorOf(Props.create(\n                ComputationActor::class.java,\n                    LongArray(STATE_SIZE) { ThreadLocalRandom.current().nextLong(0, 100) }, initLatch)\n                    .withDispatcher(\"akka.actor.$dispatcher\"))\n        }\n    }\n\n    class RequestorActor(val computations: List<ActorRef>, val initLatch: CountDownLatch,\n                         val stopLatch: CountDownLatch) : UntypedAbstractActor() {\n        private var received = 0\n\n        override fun onReceive(message: Any?) {\n            when (message) {\n                is Long -> {\n                    if (++received >= ROUNDS) {\n                        context.stop(self)\n                        stopLatch.countDown()\n                    } else {\n                        computations[ThreadLocalRandom.current().nextInt(0, computations.size)]\n                                .tell(ThreadLocalRandom.current().nextLong(), self)\n                    }\n                }\n                else -> unhandled(message)\n            }\n        }\n\n        override fun preStart() {\n            initLatch.countDown()\n        }\n    }\n\n    class ComputationActor(val coefficients: LongArray, val initLatch: CountDownLatch) : UntypedAbstractActor() {\n        override fun onReceive(message: Any?) {\n            when (message) {\n                is Long -> {\n                    var result = 0L\n                    for (coefficient in coefficients) {\n                        result += coefficient * message\n                    }\n                    sender.tell(result, self)\n                }\n                is Stop -> {\n                    context.stop(self)\n                }\n                else -> unhandled(message)\n            }\n        }\n\n        override fun preStart() {\n            initLatch.countDown()\n        }\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/debug/DebugSequenceOverheadBenchmark.kt",
        "content": "package benchmarks.debug\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.*\nimport org.openjdk.jmh.annotations.*\nimport org.openjdk.jmh.annotations.State\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.AtomicInteger\n\n/**\n * The benchmark is supposed to show the DebugProbes overhead for a non-concurrent sequence builder.\n * The code is actually part of the IDEA codebase, originally reported here: https://github.com/Kotlin/kotlinx.coroutines/issues/3527\n */\n@Warmup(iterations = 5, time = 1)\n@Measurement(iterations = 5, time = 1)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class DebugSequenceOverheadBenchmark {\n\n    private fun <Node> generateRecursiveSequence(\n        initialSequence: Sequence<Node>,\n        children: (Node) -> Sequence<Node>\n    ): Sequence<Node> {\n        return sequence {\n            val initialIterator = initialSequence.iterator()\n            if (!initialIterator.hasNext()) {\n                return@sequence\n            }\n            val visited = HashSet<Node>()\n            val sequences = ArrayDeque<Sequence<Node>>()\n            sequences.addLast(initialIterator.asSequence())\n            while (sequences.isNotEmpty()) {\n                val currentSequence = sequences.removeFirst()\n                for (node in currentSequence) {\n                    if (visited.add(node)) {\n                        yield(node)\n                        sequences.addLast(children(node))\n                    }\n                }\n            }\n        }\n    }\n\n    @Param(\"true\", \"false\")\n    var withDebugger = false\n\n    @Setup\n    fun setup() {\n        DebugProbes.sanitizeStackTraces = false\n        DebugProbes.enableCreationStackTraces = false\n        if (withDebugger) {\n            DebugProbes.install()\n        }\n    }\n\n    @TearDown\n    fun tearDown() {\n        if (withDebugger) {\n            DebugProbes.uninstall()\n        }\n    }\n\n    // Shows the overhead of sequence builder with debugger enabled\n    @Benchmark\n    fun runSequenceSingleThread(): Int = runBlocking {\n        generateRecursiveSequence((1..100).asSequence()) {\n            (1..it).asSequence()\n        }.sum()\n    }\n\n    // Shows the overhead of sequence builder with debugger enabled and debugger is concurrently stressed out\n    @Benchmark\n    fun runSequenceMultipleThreads(): Int = runBlocking {\n        val result = AtomicInteger(0)\n        repeat(Runtime.getRuntime().availableProcessors()) {\n            launch(Dispatchers.Default) {\n                result.addAndGet(generateRecursiveSequence((1..100).asSequence()) {\n                    (1..it).asSequence()\n                }.sum())\n            }\n        }\n        result.get()\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/CombineFlowsBenchmark.kt",
        "content": "package benchmarks.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.Throughput)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class CombineFlowsBenchmark {\n\n    @Param(\"10\", \"100\", \"1000\")\n    private var size = 10\n\n    @Benchmark\n    fun combine() = runBlocking {\n        combine((1 until size).map { flowOf(it) }) { a -> a}.collect()\n    }\n\n    @Benchmark\n    fun combineTransform() = runBlocking {\n        val list = (1 until size).map { flowOf(it) }.toList()\n        combineTransform((1 until size).map { flowOf(it) }) { emit(it) }.collect()\n    }\n}\n\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/CombineTwoFlowsBenchmark.kt",
        "content": "package benchmarks.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.flow.internal.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.Throughput)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class CombineTwoFlowsBenchmark {\n\n    @Param(\"100\", \"100000\", \"1000000\")\n    private var size = 100000\n\n    @Benchmark\n    fun combinePlain() = runBlocking {\n        val flow = (1 until size.toLong()).asFlow()\n        flow.combine(flow) { a, b -> a + b }.collect()\n    }\n\n    @Benchmark\n    fun combineTransform() = runBlocking {\n        val flow = (1 until size.toLong()).asFlow()\n        flow.combineTransform(flow) { a, b -> emit(a + b) }.collect()\n    }\n\n    @Benchmark\n    fun combineVararg() = runBlocking {\n        val flow = (1 until size.toLong()).asFlow()\n        combine(listOf(flow, flow)) { arr -> arr[0] + arr[1] }.collect()\n    }\n\n    @Benchmark\n    fun combineTransformVararg() = runBlocking {\n        val flow = (1 until size.toLong()).asFlow()\n        combineTransform(listOf(flow, flow)) { arr -> emit(arr[0] + arr[1]) }.collect()\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/FlatMapMergeBenchmark.kt",
        "content": "package benchmarks.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n@Warmup(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class FlatMapMergeBenchmark {\n\n    // Note: tests only absence of contention on downstream\n\n    @Param(\"10\", \"100\", \"1000\")\n    private var iterations = 100\n\n    @Benchmark\n    fun flatMapUnsafe() = runBlocking {\n        benchmarks.flow.scrabble.flow {\n            repeat(iterations) { emit(it) }\n        }.flatMapMerge { value ->\n            flowOf(value)\n        }.collect {\n            if (it == -1) error(\"\")\n        }\n    }\n\n    @Benchmark\n    fun flatMapSafe() = runBlocking {\n        kotlinx.coroutines.flow.flow {\n            repeat(iterations) { emit(it) }\n        }.flatMapMerge { value ->\n            flowOf(value)\n        }.collect {\n            if (it == -1) error(\"\")\n        }\n    }\n\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/FlowFlattenMergeBenchmark.kt",
        "content": "package benchmarks.flow\n\nimport benchmarks.common.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.TimeUnit\n\n/**\n * Benchmark to measure performance of [kotlinx.coroutines.flow.FlowKt.flattenMerge].\n * In addition to that, it can be considered as a macro benchmark for the [kotlinx.coroutines.sync.Semaphore]\n */\n@Warmup(iterations = 5, time = 1)\n@Measurement(iterations = 5, time = 1)\n@BenchmarkMode(Mode.Throughput)\n@OutputTimeUnit(TimeUnit.SECONDS)\n@State(Scope.Benchmark)\n@Fork(1)\nopen class FlowFlattenMergeBenchmark {\n    @Param\n    private var flowsNumberStrategy: FlowsNumberStrategy = FlowsNumberStrategy.`10xConcurrency flows`\n\n    @Param(\"1\", \"2\", \"4\", \"8\")\n    private var concurrency: Int = 0\n\n    private lateinit var flow: Flow<Flow<Int>>\n\n    @Setup\n    fun setup() {\n        val n = flowsNumberStrategy.get(concurrency)\n        val flowElementsToProcess = ELEMENTS / n\n\n        flow = (1..n).asFlow().map {\n            flow {\n                repeat(flowElementsToProcess) {\n                    doGeomDistrWork(WORK)\n                    emit(it)\n                }\n            }\n        }\n    }\n\n    @Benchmark\n    fun flattenMerge() = runBlocking(Dispatchers.Default) {\n        flow.flattenMerge(concurrency = concurrency).collect()\n    }\n}\n\nenum class FlowsNumberStrategy(val get: (concurrency: Int) -> Int) {\n    `10xConcurrency flows`({ concurrency -> concurrency * 10 }),\n    `1xConcurrency flows`({ it }),\n    `100 flows`({ 100 }),\n    `500 flows`({ 500 })\n}\n\n// If you change this variable please be sure that you change variable elements in the generate_plots_flow_flatten_merge.py\n// python script as well\nprivate const val ELEMENTS = 100_000\nprivate const val WORK = 100\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/NumbersBenchmark.kt",
        "content": "package benchmarks.flow\n\nimport benchmarks.flow.scrabble.flow\nimport io.reactivex.*\nimport io.reactivex.functions.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.TimeUnit\nimport java.util.concurrent.Callable\n\n@Warmup(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class NumbersBenchmark {\n\n    companion object {\n        private const val primes = 100\n        private const val natural = 1000L\n    }\n\n    private fun numbers(limit: Long = Long.MAX_VALUE) = flow {\n        for (i in 2L..limit) emit(i)\n    }\n\n    private fun primesFlow(): Flow<Long> = flow {\n        var source = numbers()\n        while (true) {\n            val next = source.take(1).single()\n            emit(next)\n            source = source.filter { it % next != 0L }\n        }\n    }\n\n    private fun rxNumbers() =\n        Flowable.generate(Callable { 1L }, BiFunction<Long, Emitter<Long>, Long> { state, emitter ->\n            val newState = state + 1\n            emitter.onNext(newState)\n            newState\n        })\n\n    private fun generateRxPrimes(): Flowable<Long> = Flowable.generate(Callable { rxNumbers() },\n        BiFunction<Flowable<Long>, Emitter<Long>, Flowable<Long>> { state, emitter ->\n            // Not the most fair comparison, but here we go\n            val prime = state.firstElement().blockingGet()\n            emitter.onNext(prime)\n            state.filter { it % prime != 0L }\n        })\n\n    @Benchmark\n    fun primes() = runBlocking {\n        primesFlow().take(primes).count()\n    }\n\n    @Benchmark\n    fun primesRx() = generateRxPrimes().take(primes.toLong()).count().blockingGet()\n\n    @Benchmark\n    fun zip() = runBlocking {\n        val numbers = numbers(natural)\n        val first = numbers\n            .filter { it % 2L != 0L }\n            .map { it * it }\n        val second = numbers\n            .filter { it % 2L == 0L }\n            .map { it * it }\n        first.zip(second) { v1, v2 -> v1 + v2 }.filter { it % 3 == 0L }.count()\n    }\n\n    @Benchmark\n    fun zipRx() {\n        val numbers = rxNumbers().take(natural)\n        val first = numbers\n            .filter { it % 2L != 0L }\n            .map { it * it }\n        val second = numbers\n            .filter { it % 2L == 0L }\n            .map { it * it }\n        first.zipWith(second, { v1, v2 -> v1 + v2 }).filter { it % 3 == 0L }.count()\n            .blockingGet()\n    }\n\n    @Benchmark\n    fun transformations(): Int = runBlocking {\n        numbers(natural)\n            .filter { it % 2L != 0L }\n            .map { it * it }\n            .filter { (it + 1) % 3 == 0L }.count()\n    }\n\n    @Benchmark\n    fun transformationsRx(): Long {\n       return rxNumbers().take(natural)\n            .filter { it % 2L != 0L }\n            .map { it * it }\n            .filter { (it + 1) % 3 == 0L }.count()\n            .blockingGet()\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/SafeFlowBenchmark.kt",
        "content": "package benchmarks.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\nimport benchmarks.flow.scrabble.flow as unsafeFlow\nimport kotlinx.coroutines.flow.flow as safeFlow\n\n@Warmup(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class SafeFlowBenchmark {\n\n    private fun numbersSafe() = safeFlow {\n        for (i in 2L..1000L) emit(i)\n    }\n\n    private fun numbersUnsafe() = unsafeFlow {\n        for (i in 2L..1000L) emit(i)\n    }\n\n    @Benchmark\n    fun safeNumbers(): Int = runBlocking {\n        numbersSafe().count()\n    }\n\n    @Benchmark\n    fun unsafeNumbers(): Int = runBlocking {\n        numbersUnsafe().count()\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/TakeBenchmark.kt",
        "content": "package benchmarks.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.TimeUnit\nimport java.util.concurrent.CancellationException\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport benchmarks.flow.scrabble.flow as unsafeFlow\n\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class TakeBenchmark {\n    @Param(\"1\", \"10\", \"100\", \"1000\")\n    private var size: Int = 0\n\n    private suspend inline fun Flow<Long>.consume() =\n        filter { it % 2L != 0L }\n            .map { it * it }.count()\n\n    @Benchmark\n    fun baseline() = runBlocking<Int> {\n        (0L until size).asFlow().consume()\n    }\n\n    @Benchmark\n    fun originalTake() = runBlocking<Int> {\n        (0L..Long.MAX_VALUE).asFlow().originalTake(size).consume()\n    }\n\n    @Benchmark\n    fun fastPathTake() = runBlocking<Int> {\n        (0L..Long.MAX_VALUE).asFlow().fastPathTake(size).consume()\n    }\n\n    @Benchmark\n    fun mergedStateMachine() = runBlocking<Int> {\n        (0L..Long.MAX_VALUE).asFlow().mergedStateMachineTake(size).consume()\n    }\n\n    internal class StacklessCancellationException() : CancellationException() {\n        override fun fillInStackTrace(): Throwable = this\n    }\n\n    public fun <T> Flow<T>.originalTake(count: Int): Flow<T> {\n        return unsafeFlow {\n            var consumed = 0\n            try {\n                collect { value ->\n                    emit(value)\n                    if (++consumed == count) {\n                        throw StacklessCancellationException()\n                    }\n                }\n            } catch (e: StacklessCancellationException) {\n                // Nothing, bail out\n            }\n        }\n    }\n\n    private suspend fun <T> FlowCollector<T>.emitAbort(value: T) {\n        emit(value)\n        throw StacklessCancellationException()\n    }\n\n    public fun <T> Flow<T>.fastPathTake(count: Int): Flow<T> {\n        return unsafeFlow {\n            var consumed = 0\n            try {\n                collect { value ->\n                    if (++consumed < count) {\n                        return@collect emit(value)\n                    } else {\n                        return@collect emitAbort(value)\n                    }\n                }\n            } catch (e: StacklessCancellationException) {\n                // Nothing, bail out\n            }\n        }\n    }\n\n\n    public fun <T> Flow<T>.mergedStateMachineTake(count: Int): Flow<T> {\n        return unsafeFlow() {\n            try {\n                val takeCollector = FlowTakeCollector(count, this)\n                collect(takeCollector)\n            } catch (e: StacklessCancellationException) {\n                // Nothing, bail out\n            }\n        }\n    }\n\n\n    private class FlowTakeCollector<T>(\n        private val count: Int,\n        downstream: FlowCollector<T>\n    ) : FlowCollector<T>, Continuation<Unit> {\n        private var consumed = 0\n        // Workaround for KT-30991\n        private val emitFun = run {\n            val suspendFun: suspend (T) -> Unit = { downstream.emit(it) }\n            suspendFun as Function2<T, Continuation<Unit>, Any?>\n        }\n\n        private var caller: Continuation<Unit>? = null // lateinit\n\n        override val context: CoroutineContext\n            get() = caller?.context ?: EmptyCoroutineContext\n\n        override fun resumeWith(result: Result<Unit>) {\n            val completion = caller!!\n            if (++consumed == count) completion.resumeWith(Result.failure(StacklessCancellationException()))\n            else completion.resumeWith(Result.success(Unit))\n        }\n\n        override suspend fun emit(value: T) = suspendCoroutineUninterceptedOrReturn<Unit> sc@{\n            // Invoke it in non-suspending way\n            caller = it\n            val result = emitFun.invoke(value, this)\n            if (result !== COROUTINE_SUSPENDED) {\n                if (++consumed == count) throw StacklessCancellationException()\n                else return@sc Unit\n            }\n            COROUTINE_SUSPENDED\n        }\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/scrabble/FlowPlaysScrabbleBase.kt",
        "content": "package benchmarks.flow.scrabble\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.openjdk.jmh.annotations.*\nimport java.lang.Long.max\nimport java.util.*\nimport java.util.concurrent.TimeUnit\nimport kotlin.math.*\n\n@Warmup(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class FlowPlaysScrabbleBase : ShakespearePlaysScrabble() {\n\n    @Benchmark\n    public override fun play(): List<Map.Entry<Int, List<String>>> {\n        val scoreOfALetter = { letter: Int -> flowOf(letterScores[letter - 'a'.toInt()]) }\n\n        val letterScore = { entry: Map.Entry<Int, LongWrapper> ->\n            flowOf(\n                letterScores[entry.key - 'a'.toInt()] * Integer.min(\n                    entry.value.get().toInt(),\n                    scrabbleAvailableLetters[entry.key - 'a'.toInt()]\n                )\n            )\n        }\n\n        val toIntegerStream = { string: String ->\n            IterableSpliterator.of(string.chars().boxed().spliterator()).asFlow()\n        }\n\n        val histoOfLetters = { word: String ->\n            flow {\n                emit(toIntegerStream(word).fold(HashMap<Int, LongWrapper>()) { accumulator, value ->\n                    var newValue: LongWrapper? = accumulator[value]\n                    if (newValue == null) {\n                        newValue = LongWrapper.zero()\n                    }\n                    accumulator[value] = newValue.incAndSet()\n                    accumulator\n                })\n            }\n        }\n\n        val blank = { entry: Map.Entry<Int, LongWrapper> ->\n            flowOf(max(0L, entry.value.get() - scrabbleAvailableLetters[entry.key - 'a'.toInt()]))\n        }\n\n        val nBlanks = { word: String ->\n            flow {\n                emit(histoOfLetters(word)\n                    .flatMapConcat { map -> map.entries.iterator().asFlow() }\n                    .flatMapConcat({ blank(it) })\n                    .reduce { a, b -> a + b })\n            }\n        }\n\n        val checkBlanks = { word: String ->\n            nBlanks(word).flatMapConcat { l -> flowOf(l <= 2L) }\n        }\n\n        val score2 = { word: String ->\n            flow {\n                emit(histoOfLetters(word)\n                    .flatMapConcat { map -> map.entries.iterator().asFlow() }\n                    .flatMapConcat { letterScore(it) }\n                    .reduce { a, b -> a + b })\n            }\n        }\n\n        val first3 = { word: String ->\n            IterableSpliterator.of(word.chars().boxed().limit(3).spliterator()).asFlow()\n        }\n\n        val last3 = { word: String ->\n            IterableSpliterator.of(word.chars().boxed().skip(3).spliterator()).asFlow()\n        }\n\n        val toBeMaxed = { word: String -> flowOf(first3(word), last3(word)).flattenConcat() }\n\n        // Bonus for double letter\n        val bonusForDoubleLetter = { word: String ->\n            flow {\n                emit(toBeMaxed(word)\n                    .flatMapConcat { scoreOfALetter(it) }\n                    .reduce { a, b -> max(a, b) })\n            }\n        }\n\n        val score3 = { word: String ->\n            flow {\n                emit(flowOf(\n                    score2(word), score2(word),\n                    bonusForDoubleLetter(word),\n                    bonusForDoubleLetter(word),\n                    flowOf(if (word.length == 7) 50 else 0)\n                ).flattenConcat().reduce { a, b -> a + b })\n            }\n        }\n\n        val buildHistoOnScore: (((String) -> Flow<Int>) -> Flow<TreeMap<Int, List<String>>>) = { score ->\n            flow {\n                emit(shakespeareWords.asFlow()\n                    .filter({ scrabbleWords.contains(it) && checkBlanks(it).single() })\n                    .fold(TreeMap<Int, List<String>>(Collections.reverseOrder())) { acc, value ->\n                        val key = score(value).single()\n                        var list = acc[key] as MutableList<String>?\n                        if (list == null) {\n                            list = ArrayList()\n                            acc[key] = list\n                        }\n                        list.add(value)\n                        acc\n                    })\n            }\n        }\n\n        return runBlocking {\n            buildHistoOnScore(score3)\n                .flatMapConcat { map -> map.entries.iterator().asFlow() }\n                .take(3)\n                .toList()\n        }\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/scrabble/FlowPlaysScrabbleOpt.kt",
        "content": "package benchmarks.flow.scrabble\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.flow.Flow\nimport org.openjdk.jmh.annotations.*\nimport java.util.*\nimport java.util.concurrent.*\nimport kotlin.math.*\n\n@Warmup(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class FlowPlaysScrabbleOpt : ShakespearePlaysScrabble() {\n\n    @Benchmark\n    public override fun play(): List<Map.Entry<Int, List<String>>> {\n        val histoOfLetters = { word: String ->\n            flow {\n                emit(word.asFlow().fold(HashMap<Int, MutableLong>()) { accumulator, value ->\n                    var newValue: MutableLong? = accumulator[value]\n                    if (newValue == null) {\n                        newValue = MutableLong()\n                        accumulator[value] = newValue\n                    }\n                    newValue.incAndSet()\n                    accumulator\n                })\n            }\n        }\n\n        val blank = { entry: Map.Entry<Int, MutableLong> ->\n            max(0L, entry.value.get() - scrabbleAvailableLetters[entry.key - 'a'.toInt()])\n        }\n\n        val nBlanks = { word: String ->\n            flow {\n                emit(histoOfLetters(word)\n                    .flatMapConcatIterable { it.entries }\n                    .map({ blank(it) })\n                    .sum()\n                )\n            }\n        }\n\n        val checkBlanks = { word: String ->\n            nBlanks(word).map { it <= 2L }\n        }\n\n        val letterScore = { entry: Map.Entry<Int, MutableLong> ->\n                letterScores[entry.key - 'a'.toInt()] * Integer.min(\n                    entry.value.get().toInt(),\n                    scrabbleAvailableLetters[entry.key - 'a'.toInt()]\n                )\n        }\n\n        val score2 = { word: String ->\n            flow {\n                emit(histoOfLetters(word)\n                    .flatMapConcatIterable { it.entries }\n                    .map { letterScore(it) }\n                    .sum())\n            }\n        }\n\n        val first3 = { word: String -> word.asFlow(endIndex = 3) }\n        val last3 = { word: String -> word.asFlow(startIndex = 3) }\n        val toBeMaxed = { word: String -> concat(first3(word), last3(word)) }\n\n        val bonusForDoubleLetter = { word: String ->\n            flow {\n                emit(toBeMaxed(word)\n                    .map { letterScores[it.toInt() - 'a'.toInt()] }\n                    .max())\n            }\n        }\n\n        val score3 = { word: String ->\n            flow {\n                val sum = score2(word).single() + bonusForDoubleLetter(word).single()\n                emit(sum * 2 + if (word.length == 7) 50 else 0)\n            }\n        }\n\n        val buildHistoOnScore: (((String) -> Flow<Int>) -> Flow<TreeMap<Int, List<String>>>) = { score ->\n            flow {\n                emit(shakespeareWords.asFlow()\n                    .filter({ scrabbleWords.contains(it) && checkBlanks(it).single() })\n                    .fold(TreeMap<Int, List<String>>(Collections.reverseOrder())) { acc, value ->\n                        val key = score(value).single()\n                        var list = acc[key] as MutableList<String>?\n                        if (list == null) {\n                            list = ArrayList()\n                            acc[key] = list\n                        }\n                        list.add(value)\n                        acc\n                    })\n            }\n        }\n\n        return runBlocking {\n            buildHistoOnScore(score3)\n                .flatMapConcatIterable { it.entries }\n                .take(3)\n                .toList()\n        }\n    }\n}\n\npublic fun String.asFlow() = flow {\n    forEach {\n        emit(it.toInt())\n    }\n}\n\npublic fun String.asFlow(startIndex: Int = 0, endIndex: Int = length) =\n    StringByCharFlow(this, startIndex, endIndex.coerceAtMost(this.length))\n\npublic suspend inline fun Flow<Int>.sum(): Int {\n    val collector = object : FlowCollector<Int> {\n        public var sum = 0\n\n        override suspend fun emit(value: Int) {\n            sum += value\n        }\n    }\n    collect(collector)\n    return collector.sum\n}\n\npublic suspend inline fun Flow<Int>.max(): Int {\n    val collector = object : FlowCollector<Int> {\n        public var max = 0\n\n        override suspend fun emit(value: Int) {\n            max = max(max, value)\n        }\n    }\n    collect(collector)\n    return collector.max\n}\n\n@JvmName(\"longSum\")\npublic suspend inline fun Flow<Long>.sum(): Long {\n    val collector = object : FlowCollector<Long> {\n        public var sum = 0L\n\n        override suspend fun emit(value: Long) {\n            sum += value\n        }\n    }\n    collect(collector)\n    return collector.sum\n}\n\npublic class StringByCharFlow(private val source: String, private val startIndex: Int, private val endIndex: Int): Flow<Char> {\n    override suspend fun collect(collector: FlowCollector<Char>) {\n        for (i in startIndex until endIndex) collector.emit(source[i])\n    }\n}\n\npublic fun <T> concat(first: Flow<T>, second: Flow<T>): Flow<T> = flow {\n    first.collect { value ->\n        return@collect emit(value)\n    }\n\n    second.collect { value ->\n        return@collect emit(value)\n    }\n}\n\npublic fun <T, R> Flow<T>.flatMapConcatIterable(transformer: (T) -> Iterable<R>): Flow<R> = flow {\n    collect { value ->\n        transformer(value).forEach { r ->\n            emit(r)\n        }\n    }\n}\n\npublic inline fun <T> flow(@BuilderInference crossinline block: suspend FlowCollector<T>.() -> Unit): Flow<T> {\n    return object : Flow<T> {\n        override suspend fun collect(collector: FlowCollector<T>) {\n            collector.block()\n        }\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/scrabble/IterableSpliterator.kt",
        "content": "package benchmarks.flow.scrabble\n\nimport java.util.*\n\nobject IterableSpliterator {\n    @JvmStatic\n    public fun <T> of(spliterator: Spliterator<T>): Iterable<T> = Iterable { Spliterators.iterator(spliterator) }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/scrabble/ReactorPlaysScrabble.kt",
        "content": "package benchmarks.flow.scrabble\n\nimport reactor.core.publisher.*\nimport java.lang.Long.*\nimport java.util.*\nimport java.util.function.Function\n\n/*@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)*/\nopen class ReactorPlaysScrabble : ShakespearePlaysScrabble() {\n\n//    @Benchmark\n    public override fun play(): List<Map.Entry<Int, List<String>>> {\n        val scoreOfALetter = Function<Int, Flux<Int>> { letter -> Flux.just(letterScores[letter - 'a'.toInt()]) }\n\n        val letterScore = Function<Map.Entry<Int, LongWrapper>, Flux<Int>> { entry ->\n            Flux.just(\n                letterScores[entry.key - 'a'.toInt()] * Integer.min(\n                    entry.value.get().toInt(),\n                    scrabbleAvailableLetters[entry.key - 'a'.toInt()]\n                )\n            )\n        }\n\n        val toIntegerStream = Function<String, Flux<Int>> { string ->\n            Flux.fromIterable(IterableSpliterator.of(string.chars().boxed().spliterator()))\n        }\n\n        val histoOfLetters = Function<String, Flux<HashMap<Int, LongWrapper>>> { word ->\n            Flux.from(toIntegerStream.apply(word)\n                .collect(\n                    { HashMap() },\n                    { map: HashMap<Int, LongWrapper>, value: Int ->\n                        var newValue: LongWrapper? = map[value]\n                        if (newValue == null) {\n                            newValue = LongWrapper.zero()\n                        }\n                        map[value] = newValue.incAndSet()\n                    }\n\n                ))\n        }\n\n        val blank = Function<Map.Entry<Int, LongWrapper>, Flux<Long>> { entry ->\n            Flux.just(max(0L, entry.value.get() - scrabbleAvailableLetters[entry.key - 'a'.toInt()]))\n        }\n\n        val nBlanks = Function<String, Flux<Long>> { word ->\n            Flux.from(histoOfLetters.apply(word)\n                .flatMap<Map.Entry<Int, LongWrapper>> { map -> Flux.fromIterable<Map.Entry<Int, LongWrapper>>(Iterable { map.entries.iterator() }) }\n                .flatMap(blank)\n                .reduce { a, b -> sum(a, b) })\n        }\n\n        val checkBlanks = Function<String, Flux<Boolean>> { word ->\n            nBlanks.apply(word)\n                .flatMap { l -> Flux.just(l <= 2L) }\n        }\n\n\n        val score2 = Function<String, Flux<Int>> { word ->\n            Flux.from(histoOfLetters.apply(word)\n                .flatMap<Map.Entry<Int, LongWrapper>> { map -> Flux.fromIterable<Map.Entry<Int, LongWrapper>>(Iterable { map.entries.iterator() }) }\n                .flatMap(letterScore)\n                .reduce { a, b -> Integer.sum(a, b) })\n\n        }\n\n        val first3 = Function<String, Flux<Int>> { word -> Flux.fromIterable(\n            IterableSpliterator.of(\n                word.chars().boxed().limit(3).spliterator()\n            )\n        ) }\n        val last3 = Function<String, Flux<Int>> { word -> Flux.fromIterable(\n            IterableSpliterator.of(\n                word.chars().boxed().skip(3).spliterator()\n            )\n        ) }\n\n        val toBeMaxed = Function<String, Flux<Int>> { word ->\n            Flux.just(first3.apply(word), last3.apply(word))\n                .flatMap { Stream -> Stream }\n        }\n\n        // Bonus for double letter\n        val bonusForDoubleLetter = Function<String, Flux<Int>>  { word ->\n            Flux.from<Int>(toBeMaxed.apply(word)\n                .flatMap<Int>(scoreOfALetter)\n                .reduce { a, b -> Integer.max(a, b) }\n            )\n        }\n\n        val score3 = Function<String, Flux<Int>> { word ->\n            Flux.from(Flux.just(\n                score2.apply(word),\n                score2.apply(word),\n                bonusForDoubleLetter.apply(word),\n                bonusForDoubleLetter.apply(word),\n                Flux.just(if (word.length == 7) 50 else 0)\n            )\n                .flatMap { Stream -> Stream }\n                .reduce { a, b -> Integer.sum(a, b) })\n        }\n\n        val buildHistoOnScore = Function<Function<String, Flux<Int>>, Flux<TreeMap<Int, List<String>>>> { score ->\n            Flux.from(Flux.fromIterable(Iterable { shakespeareWords.iterator() })\n                .filter( { scrabbleWords.contains(it) })\n                .filter({ word -> checkBlanks.apply(word).toIterable().iterator().next() })\n                .collect(\n                    { TreeMap<Int, List<String>>(Collections.reverseOrder()) },\n                    { map: TreeMap<Int, List<String>>, word: String ->\n                        val key = score.apply(word).toIterable().iterator().next()\n                        var list = map[key] as MutableList<String>?\n                        if (list == null) {\n                            list = ArrayList()\n                            map[key] = list\n                        }\n                        list.add(word)\n                    }\n                ))\n        }\n\n        val finalList2 = Flux.from<ArrayList<Map.Entry<Int, List<String>>>>(buildHistoOnScore.apply(score3)\n            .flatMap<Map.Entry<Int, List<String>>> { map -> Flux.fromIterable<Map.Entry<Int, List<String>>>(Iterable { map.entries.iterator() }) }\n            .take(3)\n            .collect<ArrayList<Map.Entry<Int, List<String>>>>(\n                { ArrayList() },\n                { list, entry -> list.add(entry) }\n            )\n        ).toIterable().iterator().next()\n\n        return finalList2\n    }\n\n}\n\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/scrabble/SaneFlowPlaysScrabble.kt",
        "content": "package benchmarks.flow.scrabble\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.openjdk.jmh.annotations.*\nimport java.lang.Long.*\nimport java.util.*\nimport java.util.concurrent.TimeUnit\n\n@Warmup(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class SaneFlowPlaysScrabble : ShakespearePlaysScrabble() {\n\n    @Benchmark\n    public override fun play(): List<Map.Entry<Int, List<String>>> {\n        val score3: suspend (String) -> Int = { word: String ->\n            val sum = score2(word) + bonusForDoubleLetter(word)\n            sum * 2 + if (word.length == 7) 50 else 0\n        }\n\n        val buildHistoOnScore: ((suspend (String) -> Int) -> Flow<TreeMap<Int, List<String>>>) = { score ->\n            flow {\n                emit(shakespeareWords.asFlow()\n                    .filter({ scrabbleWords.contains(it) && checkBlanks(it) })\n                    .fold(TreeMap<Int, List<String>>(Collections.reverseOrder())) { acc, value ->\n                        val key = score(value)\n                        var list = acc[key] as MutableList<String>?\n                        if (list == null) {\n                            list = ArrayList()\n                            acc[key] = list\n                        }\n                        list.add(value)\n                        acc\n                    })\n            }\n        }\n\n        return runBlocking {\n            buildHistoOnScore(score3)\n                .flatMapConcatIterable { it.entries }\n                .take(3)\n                .toList()\n        }\n    }\n\n    private suspend inline fun score2(word: String): Int {\n        return buildHistogram(word)\n            .map { it.letterScore() }\n            .sum()\n    }\n\n    private suspend inline fun bonusForDoubleLetter(word: String): Int {\n        return toBeMaxed(word)\n            .map { letterScores[it - 'a'.toInt()] }\n            .max()\n    }\n\n    private fun Map.Entry<Int, MutableLong>.letterScore(): Int = letterScores[key - 'a'.toInt()] * Integer.min(\n        value.get().toInt(),\n        scrabbleAvailableLetters[key - 'a'.toInt()])\n\n    private fun toBeMaxed(word: String) = concat(word.asSequence(), word.asSequence(endIndex = 3))\n\n    private suspend inline fun checkBlanks(word: String) = numBlanks(word) <= 2L\n\n    private suspend fun numBlanks(word: String): Long {\n        return buildHistogram(word)\n            .map { blanks(it) }\n            .sum()\n    }\n\n    private fun blanks(entry: Map.Entry<Int, MutableLong>): Long =\n        max(0L, entry.value.get() - scrabbleAvailableLetters[entry.key - 'a'.toInt()])\n\n    private suspend inline fun buildHistogram(word: String): HashMap<Int, MutableLong> {\n        return word.asSequence().fold(HashMap()) { accumulator, value ->\n            var newValue: MutableLong? = accumulator[value]\n            if (newValue == null) {\n                newValue = MutableLong()\n                accumulator[value] = newValue\n            }\n            newValue.incAndSet()\n            accumulator\n        }\n    }\n\n    private fun String.asSequence(startIndex: Int = 0, endIndex: Int = length) = flow {\n        for (i in  startIndex until endIndex.coerceAtMost(length)) {\n            emit(get(i).toInt())\n        }\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/scrabble/SequencePlaysScrabble.kt",
        "content": "package benchmarks.flow.scrabble\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.openjdk.jmh.annotations.*\nimport java.lang.Long.*\nimport java.util.*\nimport java.util.concurrent.TimeUnit\n\n@Warmup(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 7, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class SequencePlaysScrabble : ShakespearePlaysScrabble() {\n\n    @Benchmark\n    public override fun play(): List<Map.Entry<Int, List<String>>> {\n        val score2: (String) -> Int = { word: String ->\n            buildHistogram(word)\n                .map { it.letterScore() }\n                .sum()\n        }\n\n        val bonusForDoubleLetter: (String) -> Int = { word: String ->\n            toBeMaxed(word)\n                .map { letterScores[it - 'a'.toInt()] }\n                .maxOrNull()!!\n        }\n\n        val score3: (String) -> Int = { word: String ->\n            val sum = score2(word) + bonusForDoubleLetter(word)\n            sum * 2 + if (word.length == 7) 50 else 0\n        }\n\n        val buildHistoOnScore: (((String) -> Int) -> Flow<TreeMap<Int, List<String>>>) = { score ->\n            flow {\n                emit(shakespeareWords.asSequence()\n                    .filter({ scrabbleWords.contains(it) && checkBlanks(it) })\n                    .fold(TreeMap<Int, List<String>>(Collections.reverseOrder())) { acc, value ->\n                        val key = score(value)\n                        var list = acc[key] as MutableList<String>?\n                        if (list == null) {\n                            list = ArrayList()\n                            acc[key] = list\n                        }\n                        list.add(value)\n                        acc\n                    })\n            }\n        }\n\n        return runBlocking {\n            buildHistoOnScore(score3)\n                .flatMapConcatIterable { it.entries }\n                .take(3)\n                .toList()\n        }\n    }\n\n    private fun Map.Entry<Int, MutableLong>.letterScore(): Int = letterScores[key - 'a'.toInt()] * Integer.min(\n        value.get().toInt(),\n        scrabbleAvailableLetters[key - 'a'.toInt()])\n\n    private fun toBeMaxed(word: String) = word.asSequence(startIndex = 3) + word.asSequence(endIndex = 3)\n\n    private fun checkBlanks(word: String) = numBlanks(word) <= 2L\n\n    private fun numBlanks(word: String): Long {\n        return buildHistogram(word)\n            .map { blanks(it) }\n            .sum()\n    }\n\n    private fun blanks(entry: Map.Entry<Int, MutableLong>): Long =\n        max(0L, entry.value.get() - scrabbleAvailableLetters[entry.key - 'a'.toInt()])\n\n    private fun buildHistogram(word: String): HashMap<Int, MutableLong> {\n        return word.asSequence().fold(HashMap()) { accumulator, value ->\n            var newValue: MutableLong? = accumulator[value]\n            if (newValue == null) {\n                newValue = MutableLong()\n                accumulator[value] = newValue\n            }\n            newValue.incAndSet()\n            accumulator\n        }\n    }\n\n    private fun String.asSequence(startIndex: Int = 0, endIndex: Int = length) = object : Sequence<Int> {\n        override fun iterator(): Iterator<Int> = object : Iterator<Int> {\n            private val _endIndex = endIndex.coerceAtMost(length)\n            private var currentIndex = startIndex\n            override fun hasNext(): Boolean = currentIndex < _endIndex\n            override fun next(): Int = get(currentIndex++).toInt()\n        }\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/flow/scrabble/ShakespearePlaysScrabble.kt",
        "content": "package benchmarks.flow.scrabble\n\nimport org.openjdk.jmh.annotations.*\nimport java.io.*\nimport java.util.stream.*\nimport java.util.zip.*\n\n@State(Scope.Benchmark)\nabstract class ShakespearePlaysScrabble {\n    @Throws(Exception::class)\n    abstract fun play(): List<Map.Entry<Int, List<String>>>\n\n    public class MutableLong {\n        var value: Long = 0\n        fun get(): Long {\n            return value\n        }\n\n        fun incAndSet(): MutableLong {\n            value++\n            return this\n        }\n\n        fun add(other: MutableLong): MutableLong {\n            value += other.value\n            return this\n        }\n    }\n\n    public interface LongWrapper {\n        fun get(): Long\n\n        fun incAndSet(): LongWrapper {\n            return object : LongWrapper {\n                override fun get(): Long = this@LongWrapper.get() + 1L\n            }\n        }\n\n        fun add(other: LongWrapper): LongWrapper {\n            return object : LongWrapper {\n                override fun get(): Long = this@LongWrapper.get() + other.get()\n            }\n        }\n\n        companion object {\n            fun zero(): LongWrapper {\n                return object : LongWrapper {\n                    override fun get(): Long = 0L\n                }\n            }\n        }\n    }\n\n    @JvmField\n    public val letterScores: IntArray = intArrayOf(1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10)\n\n    @JvmField\n    public val scrabbleAvailableLetters: IntArray =\n        intArrayOf(9, 2, 2, 1, 12, 2, 3, 2, 9, 1, 1, 4, 2, 6, 8, 2, 1, 6, 4, 6, 4, 2, 2, 1, 2, 1)\n\n    @JvmField\n    public val scrabbleWords: Set<String> = readResource(\"ospd.txt.gz\")\n\n    @JvmField\n    public val shakespeareWords: Set<String> = readResource(\"words.shakespeare.txt.gz\")\n\n    private fun readResource(path: String) =\n        BufferedReader(InputStreamReader(GZIPInputStream(this.javaClass.classLoader.getResourceAsStream(path)))).lines()\n            .map { it.toLowerCase() }.collect(Collectors.toSet())\n\n    init {\n        val expected = listOf(120 to listOf(\"jezebel\", \"quickly\"),\n            118 to listOf(\"zephyrs\"), 116 to listOf(\"equinox\"))\n        val actual = play().map { it.key to it.value }\n        if (expected != actual) {\n            error(\"Incorrect benchmark, output: $actual\")\n        }\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/scheduler/DispatchersContextSwitchBenchmark.kt",
        "content": "package benchmarks.scheduler\n\nimport benchmarks.akka.*\nimport kotlinx.coroutines.*\nimport org.openjdk.jmh.annotations.*\nimport org.openjdk.jmh.annotations.State\nimport java.lang.Thread.*\nimport java.util.concurrent.*\nimport kotlin.concurrent.*\nimport kotlin.coroutines.*\n\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Thread)\nopen class DispatchersContextSwitchBenchmark {\n    private val nCoroutines = 10000\n    private val delayTimeMs = 1L\n    private val nRepeatDelay = 10\n\n    private val fjp = ForkJoinPool.commonPool().asCoroutineDispatcher()\n    private val ftp = Executors.newFixedThreadPool(CORES_COUNT - 1).asCoroutineDispatcher()\n\n    @TearDown\n    fun teardown() {\n        ftp.close()\n        (ftp.executor as ExecutorService).awaitTermination(1, TimeUnit.SECONDS)\n    }\n\n    @Benchmark\n    fun coroutinesIoDispatcher() =  runBenchmark(Dispatchers.IO)\n\n    @Benchmark\n    fun coroutinesDefaultDispatcher() = runBenchmark(Dispatchers.Default)\n\n    @Benchmark\n    fun coroutinesFjpDispatcher()  = runBenchmark(fjp)\n\n    @Benchmark\n    fun coroutinesFtpDispatcher()  = runBenchmark(ftp)\n\n    @Benchmark\n    fun coroutinesBlockingDispatcher() = runBenchmark(EmptyCoroutineContext)\n\n    @Benchmark\n    fun threads() {\n        val threads = List(nCoroutines) {\n            thread(start = true) {\n                repeat(nRepeatDelay) {\n                    sleep(delayTimeMs)\n                }\n            }\n        }\n        threads.forEach { it.join() }\n    }\n\n    private fun runBenchmark(dispatcher: CoroutineContext)  = runBlocking {\n        repeat(nCoroutines) {\n            launch(dispatcher) {\n                repeat(nRepeatDelay) {\n                    delay(delayTimeMs)\n                }\n            }\n        }\n    }\n}\n\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/scheduler/ForkJoinBenchmark.kt",
        "content": "package benchmarks.scheduler\n\nimport benchmarks.*\nimport kotlinx.coroutines.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n/*\n * Comparison of fork-join tasks using specific FJP API and classic [async] jobs.\n * FJP job is organized in perfectly balanced binary tree, every leaf node computes\n * FPU-heavy sum over its data and intermediate nodes sum results.\n *\n * Fine-grained batch size (8192 * 1024 tasks, 128 in sequential batch)\n * ForkJoinBenchmark.asyncExperimental  avgt   10  681.512 \u00b1 32.069  ms/op\n * ForkJoinBenchmark.asyncFjp           avgt   10  845.386 \u00b1 73.204  ms/op\n * ForkJoinBenchmark.fjpRecursiveTask   avgt   10  692.120 \u00b1 26.224  ms/op\n * ForkJoinBenchmark.fjpTask            avgt   10  791.087 \u00b1 66.544  ms/op\n *\n * Too small tasks (8192 * 1024 tasks, 128 batch, 16 in sequential batch)\n * Benchmark                            Mode  Cnt     Score     Error  Units\n * ForkJoinBenchmark.asyncExperimental  avgt   10  1273.271 \u00b1 190.372  ms/op\n * ForkJoinBenchmark.asyncFjp           avgt   10  1406.102 \u00b1 216.793  ms/op\n * ForkJoinBenchmark.fjpRecursiveTask   avgt   10   849.941 \u00b1 141.254  ms/op\n * ForkJoinBenchmark.fjpTask            avgt   10   831.554 \u00b1  57.276  ms/op\n */\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 2)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class ForkJoinBenchmark : ParametrizedDispatcherBase() {\n\n    companion object {\n        /*\n         * Change task size to control global granularity of benchmark\n         * Change batch size to control affinity/work stealing/scheduling overhead effects\n         */\n        const val TASK_SIZE = 8192 * 1024\n        const val BATCH_SIZE = 32 * 8192\n    }\n\n    lateinit var coefficients: LongArray\n    override var dispatcher: String = \"scheduler\"\n\n    @Setup\n    override fun setup() {\n        super.setup()\n        coefficients = LongArray(TASK_SIZE) { ThreadLocalRandom.current().nextLong(0, 1024 * 1024) }\n    }\n\n    @Benchmark\n    fun asyncFjp() = runBlocking {\n        CoroutineScope(ForkJoinPool.commonPool().asCoroutineDispatcher()).startAsync(coefficients, 0, coefficients.size).await()\n    }\n\n    @Benchmark\n    fun asyncExperimental() = runBlocking {\n        startAsync(coefficients, 0, coefficients.size).await()\n    }\n\n    @Benchmark\n    fun fjpRecursiveTask(): Double {\n        val task = RecursiveAction(coefficients, 0, coefficients.size)\n        return ForkJoinPool.commonPool().submit(task).join()\n    }\n\n    @Benchmark\n    fun fjpTask(): Double {\n        val task = Task(coefficients, 0, coefficients.size)\n        return ForkJoinPool.commonPool().submit(task).join()\n    }\n\n    suspend fun CoroutineScope.startAsync(coefficients: LongArray, start: Int, end: Int): Deferred<Double> = async {\n        if (end - start <= BATCH_SIZE) {\n            compute(coefficients, start, end)\n        } else {\n            val first = startAsync(coefficients, start, start + (end - start) / 2)\n            val second = startAsync(coefficients, start + (end - start) / 2, end)\n            first.await() + second.await()\n        }\n    }\n\n    class Task(val coefficients: LongArray, val start: Int, val end: Int) : RecursiveTask<Double>() {\n        override fun compute(): Double {\n            if (end - start <= BATCH_SIZE) {\n                return compute(coefficients, start, end)\n            }\n\n            val first = Task(coefficients, start, start + (end - start) / 2).fork()\n            val second = Task(coefficients, start + (end - start) / 2, end).fork()\n\n            var result = 0.0\n            result += first.join()\n            result += second.join()\n            return result\n        }\n\n        private fun compute(coefficients: LongArray, start: Int, end: Int): Double {\n            var result = 0.0\n            for (i in start until end) {\n                result += Math.sin(Math.pow(coefficients[i].toDouble(), 1.1)) + 1e-8\n            }\n\n            return result\n        }\n    }\n\n    class RecursiveAction(val coefficients: LongArray, val start: Int, val end: Int, @Volatile var result: Double = 0.0,\n                          parent: RecursiveAction? = null) : CountedCompleter<Double>(parent) {\n\n        private var first: ForkJoinTask<Double>? = null\n        private var second: ForkJoinTask<Double>? = null\n\n        override fun getRawResult(): Double {\n            return result\n        }\n\n        override fun setRawResult(t: Double) {\n            result = t\n        }\n\n        override fun compute() {\n            if (end - start <= BATCH_SIZE) {\n                rawResult = compute(coefficients, start, end)\n            } else {\n                pendingCount = 2\n                // One may fork only once here and executing second task here with looping over firstComplete to be even more efficient\n                first = RecursiveAction(\n                    coefficients,\n                    start,\n                    start + (end - start) / 2,\n                    parent = this\n                ).fork()\n                second = RecursiveAction(\n                    coefficients,\n                    start + (end - start) / 2,\n                    end,\n                    parent = this\n                ).fork()\n            }\n\n            tryComplete()\n        }\n\n        override fun onCompletion(caller: CountedCompleter<*>?) {\n            if (caller !== this) {\n                rawResult = first!!.rawResult + second!!.rawResult\n            }\n            super.onCompletion(caller)\n        }\n    }\n}\n\n\nprivate fun compute(coefficients: LongArray, start: Int, end: Int): Double {\n    var result = 0.0\n    for (i in start until end) {\n        result += Math.sin(Math.pow(coefficients[i].toDouble(), 1.1)) + 1e-8\n    }\n\n    return result\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/scheduler/LaunchBenchmark.kt",
        "content": "package benchmarks.scheduler\n\nimport benchmarks.*\nimport kotlinx.coroutines.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n/*\n * Benchmark to measure scheduling overhead in comparison with FJP.\n * LaunchBenchmark.massiveLaunch  experimental  avgt   30  328.662 \u00b1 52.789  us/op\n * LaunchBenchmark.massiveLaunch           fjp  avgt   30  179.762 \u00b1  3.931  us/op\n */\n@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 2)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class LaunchBenchmark : ParametrizedDispatcherBase() {\n\n    @Param(\"scheduler\", \"fjp\")\n    override var dispatcher: String = \"fjp\"\n\n    private val jobsToLaunch = 100\n    private val submitters = 4\n\n    private val allLaunched = CyclicBarrier(submitters)\n    private val stopBarrier = CyclicBarrier(submitters + 1)\n\n    @Benchmark\n    fun massiveLaunch() {\n        repeat(submitters) {\n            launch {\n                // Wait until all cores are occupied\n                allLaunched.await()\n                allLaunched.reset()\n\n                (1..jobsToLaunch).map {\n                    launch {\n                        // do nothing\n                    }\n                }.map { it.join() }\n\n                stopBarrier.await()\n            }\n        }\n\n        stopBarrier.await()\n        stopBarrier.reset()\n    }\n\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/scheduler/StatefulAwaitsBenchmark.kt",
        "content": "package benchmarks.scheduler\n\nimport benchmarks.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n/*\n * Benchmark which launches multiple async jobs each with either own private or global shared state,\n * each job iterates over its state multiple times and suspends after every iteration.\n * Benchmark is intended to indicate pros and cons of coroutines affinity (assuming threads are rarely migrated)\n * and comparison with single thread and ForkJoinPool\n *\n * Benchmark                                     (dispatcher)  (jobsCount)  Mode  Cnt    Score    Error  Units\n * StatefulAsyncBenchmark.dependentStateAsync             fjp            1  avgt   10   42.147 \u00b1 11.563  us/op\n * StatefulAsyncBenchmark.dependentStateAsync             fjp            8  avgt   10  111.053 \u00b1 40.097  us/op\n * StatefulAsyncBenchmark.dependentStateAsync             fjp           16  avgt   10  239.992 \u00b1 52.839  us/op\n * StatefulAsyncBenchmark.dependentStateAsync           ftp_1            1  avgt   10   32.851 \u00b1 11.385  us/op\n * StatefulAsyncBenchmark.dependentStateAsync           ftp_1            8  avgt   10   51.692 \u00b1  0.961  us/op\n * StatefulAsyncBenchmark.dependentStateAsync           ftp_1           16  avgt   10  101.511 \u00b1  3.060  us/op\n * StatefulAsyncBenchmark.dependentStateAsync           ftp_8            1  avgt   10   31.549 \u00b1  1.014  us/op\n * StatefulAsyncBenchmark.dependentStateAsync           ftp_8            8  avgt   10  103.990 \u00b1  1.588  us/op\n * StatefulAsyncBenchmark.dependentStateAsync           ftp_8           16  avgt   10  156.384 \u00b1  2.914  us/op\n *\n * StatefulAsyncBenchmark.independentStateAsync           fjp            1  avgt   10   32.503 \u00b1  0.721  us/op\n * StatefulAsyncBenchmark.independentStateAsync           fjp            8  avgt   10   73.000 \u00b1  1.686  us/op\n * StatefulAsyncBenchmark.independentStateAsync           fjp           16  avgt   10   98.629 \u00b1  7.541  us/op\n * StatefulAsyncBenchmark.independentStateAsync         ftp_1            1  avgt   10   26.111 \u00b1  0.814  us/op\n * StatefulAsyncBenchmark.independentStateAsync         ftp_1            8  avgt   10   54.644 \u00b1  1.261  us/op\n * StatefulAsyncBenchmark.independentStateAsync         ftp_1           16  avgt   10  104.871 \u00b1  1.599  us/op\n * StatefulAsyncBenchmark.independentStateAsync         ftp_8            1  avgt   10   31.929 \u00b1  0.698  us/op\n * StatefulAsyncBenchmark.independentStateAsync         ftp_8            8  avgt   10  108.959 \u00b1  1.029  us/op\n * StatefulAsyncBenchmark.independentStateAsync         ftp_8           16  avgt   10  159.593 \u00b1  5.262  us/op\n *\n */\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 2)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class StatefulAsyncBenchmark : ParametrizedDispatcherBase() {\n\n    private val stateSize = 2048\n    private val jobSuspensions = 2 // multiplicative factor for throughput\n\n    // it's useful to have more jobs than cores so run queue always will be non empty\n    @Param(\"1\", \"8\", \"16\")\n    var jobsCount = 1\n\n    @Param(\"fjp\", \"ftp_1\", \"dispatcher\")\n    override var dispatcher: String = \"fjp\"\n\n    @Volatile\n    private var state: Array<LongArray>? = null\n\n    @Setup\n    override fun setup() {\n        super.setup()\n        state = Array(Runtime.getRuntime().availableProcessors() * 4) { LongArray(stateSize) { ThreadLocalRandom.current().nextLong() } }\n    }\n\n    @Benchmark\n    fun independentStateAsync() = runBlocking {\n        val broadcastChannel = BroadcastChannel<Int>(1)\n        val subscriptionChannel = Channel<Int>(jobsCount)\n        val jobs= (0 until jobsCount).map { launchJob(it, broadcastChannel, subscriptionChannel) }.toList()\n\n        repeat(jobsCount) {\n            subscriptionChannel.receive() // await all jobs to start\n        }\n\n        // Fire barrier to start execution\n        broadcastChannel.send(1)\n        jobs.forEach { it.await() }\n    }\n\n    @Benchmark\n    fun dependentStateAsync() = runBlocking {\n        val broadcastChannel = BroadcastChannel<Int>(1)\n        val subscriptionChannel = Channel<Int>(jobsCount)\n        val jobs= (0 until jobsCount).map { launchJob(0, broadcastChannel, subscriptionChannel) }.toList()\n\n        repeat(jobsCount) {\n            subscriptionChannel.receive() // await all jobs to start\n        }\n\n        // Fire barrier to start execution\n        broadcastChannel.send(1)\n        jobs.forEach { it.await() }\n    }\n\n    private fun launchJob(\n        stateNum: Int,\n        channel: BroadcastChannel<Int>,\n        subscriptionChannel: Channel<Int>\n    ): Deferred<Long> =\n        async {\n            val subscription = channel.openSubscription()\n            subscriptionChannel.send(1)\n            subscription.receive()\n\n            var sum = 0L\n            repeat(jobSuspensions) {\n                val arr = state!![stateNum]\n                for (i in 0 until stateSize) {\n                    sum += arr[i]\n\n                }\n\n                yield()\n            }\n            sum\n        }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/scheduler/actors/ConcurrentStatefulActorBenchmark.kt",
        "content": "package benchmarks.scheduler.actors\n\nimport benchmarks.*\nimport benchmarks.akka.*\nimport benchmarks.scheduler.actors.StatefulActorBenchmark.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n/*\n * Noisy benchmarks useful to measure scheduling fairness and migration of affinity-sensitive tasks.\n *\n * Benchmark: single actor fans out requests to all (#cores count) computation actors and then ping pongs each in loop.\n * Fair benchmark expects that every computation actor will receive exactly N messages, unfair expects N * cores messages received in total.\n *\n * Benchmark                                                    (dispatcher)  (stateSize)  Mode  Cnt      Score      Error  Units\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair             fjp         1024  avgt    5    215.439 \u00b1   29.685  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair           ftp_1         1024  avgt    5     85.374 \u00b1    4.477  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair           ftp_8         1024  avgt    5    418.510 \u00b1   46.906  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair    experimental         1024  avgt    5    165.250 \u00b1   20.309  ms/op\n *\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair             fjp         8192  avgt    5    220.576 \u00b1   35.596  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair           ftp_1         8192  avgt    5    298.276 \u00b1   22.256  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair           ftp_8         8192  avgt    5    426.105 \u00b1   29.870  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair    experimental         8192  avgt    5    288.546 \u00b1   20.280  ms/op\n *\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair             fjp       262144  avgt    5   4146.057 \u00b1  284.377  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair           ftp_1       262144  avgt    5  10250.107 \u00b1 1421.253  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair           ftp_8       262144  avgt    5   6761.283 \u00b1 4091.452  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsFair    experimental       262144  avgt    5   6521.436 \u00b1  346.726  ms/op\n *\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair           fjp         1024  avgt    5    289.875 \u00b1   14.241  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair         ftp_1         1024  avgt    5     87.336 \u00b1    5.160  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair         ftp_8         1024  avgt    5    430.718 \u00b1   23.497  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair  experimental         1024  avgt    5    153.704 \u00b1   13.869  ms/op\n *\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair           fjp         8192  avgt    5    289.836 \u00b1    9.719  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair         ftp_1         8192  avgt    5    299.523 \u00b1   17.357  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair         ftp_8         8192  avgt    5    433.959 \u00b1   27.669  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair  experimental         8192  avgt    5    283.441 \u00b1   22.740  ms/op\n *\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair           fjp       262144  avgt    5   7804.066 \u00b1 1386.595  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair         ftp_1       262144  avgt    5  11142.530 \u00b1  381.401  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair         ftp_8       262144  avgt    5   7739.136 \u00b1 1317.885  ms/op\n * ConcurrentStatefulActorBenchmark.multipleComputationsUnfair  experimental       262144  avgt    5   7076.911 \u00b1 1971.615  ms/op\n *\n */\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class ConcurrentStatefulActorBenchmark : ParametrizedDispatcherBase() {\n\n    @Param(\"1024\", \"8192\")\n    var stateSize: Int = -1\n\n    @Param(\"fjp\", \"scheduler\")\n    override var dispatcher: String = \"fjp\"\n\n    @Benchmark\n    fun multipleComputationsUnfair() = runBlocking {\n        val resultChannel: Channel<Unit> = Channel(1)\n        val computations = (0 until CORES_COUNT).map { computationActor(stateSize) }\n        val requestor = requestorActorUnfair(computations, resultChannel)\n        requestor.send(Letter(Start(), requestor))\n        resultChannel.receive()\n    }\n\n    @Benchmark\n    fun multipleComputationsFair() = runBlocking {\n        val resultChannel: Channel<Unit> = Channel(1)\n        val computations = (0 until CORES_COUNT).map { computationActor(stateSize) }\n        val requestor = requestorActorFair(computations, resultChannel)\n        requestor.send(Letter(Start(), requestor))\n        resultChannel.receive()\n    }\n\n    fun requestorActorUnfair(\n        computations: List<SendChannel<Letter>>,\n        stopChannel: Channel<Unit>\n    ) =\n        actor<Letter>(capacity = 1024) {\n            var received = 0\n            for (letter in channel) with(letter) {\n                when (message) {\n                    is Start -> {\n                        computations.shuffled()\n                            .forEach { it.send(Letter(ThreadLocalRandom.current().nextLong(), channel)) }\n                    }\n                    is Long -> {\n                        if (++received >= ROUNDS * 8) {\n                            computations.forEach { it.close() }\n                            stopChannel.send(Unit)\n                            return@actor\n                        } else {\n                            sender.send(Letter(ThreadLocalRandom.current().nextLong(), channel))\n                        }\n                    }\n                    else -> error(\"Cannot happen: $letter\")\n                }\n            }\n        }\n\n    fun requestorActorFair(\n        computations: List<SendChannel<Letter>>,\n        stopChannel: Channel<Unit>\n    ) =\n        actor<Letter>(capacity = 1024) {\n            val received = hashMapOf(*computations.map { it to 0 }.toTypedArray())\n            var receivedTotal = 0\n\n            for (letter in channel) with(letter) {\n                when (message) {\n                    is Start -> {\n                        computations.shuffled()\n                            .forEach { it.send(Letter(ThreadLocalRandom.current().nextLong(), channel)) }\n                    }\n                    is Long -> {\n                        if (++receivedTotal >= ROUNDS * computations.size) {\n                            computations.forEach { it.close() }\n                            stopChannel.send(Unit)\n                            return@actor\n                        } else {\n                            val receivedFromSender = received[sender]!!\n                            if (receivedFromSender <= ROUNDS) {\n                                received[sender] = receivedFromSender + 1\n                                sender.send(Letter(ThreadLocalRandom.current().nextLong(), channel))\n                            }\n                        }\n                    }\n                    else -> error(\"Cannot happen: $letter\")\n                }\n            }\n        }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/scheduler/actors/CycledActorsBenchmark.kt",
        "content": "package benchmarks.scheduler.actors\n\nimport benchmarks.*\nimport benchmarks.akka.*\nimport benchmarks.scheduler.actors.PingPongActorBenchmark.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n/*\n * Cores count actors chained into single cycle pass message and process it using its private state.\n *\n * Benchmark                           (actorStateSize)  (dispatcher)  Mode  Cnt     Score     Error  Units\n * CycledActorsBenchmark.cycledActors                 1           fjp  avgt   14    22.751 \u00b1   1.351  ms/op\n * CycledActorsBenchmark.cycledActors                 1         ftp_1  avgt   14     4.535 \u00b1   0.076  ms/op\n * CycledActorsBenchmark.cycledActors                 1  experimental  avgt   14     6.728 \u00b1   0.048  ms/op\n *\n * CycledActorsBenchmark.cycledActors              1024           fjp  avgt   14    43.725 \u00b1  14.393  ms/op\n * CycledActorsBenchmark.cycledActors              1024         ftp_1  avgt   14    13.827 \u00b1   1.554  ms/op\n * CycledActorsBenchmark.cycledActors              1024  experimental  avgt   14    23.823 \u00b1   1.643  ms/op\n *\n * CycledActorsBenchmark.cycledActors            262144           fjp  avgt   14  1885.708 \u00b1 532.634  ms/op\n * CycledActorsBenchmark.cycledActors            262144         ftp_1  avgt   14  1394.997 \u00b1 101.938  ms/op\n * CycledActorsBenchmark.cycledActors            262144  experimental  avgt   14  1804.146 \u00b1  57.275  ms/op\n */\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class CycledActorsBenchmark : ParametrizedDispatcherBase() {\n\n    companion object {\n        val NO_CHANNEL = Channel<Letter>(0)\n    }\n\n    @Param(\"fjp\", \"ftp_1\", \"scheduler\")\n    override var dispatcher: String = \"fjp\"\n\n    @Param(\"1\", \"1024\")\n    var actorStateSize = 1\n\n    @Benchmark\n    fun cycledActors() = runBlocking {\n        val stopChannel = Channel<Unit>(CORES_COUNT)\n        runCycle(stopChannel)\n        repeat(CORES_COUNT) {\n            stopChannel.receive()\n        }\n    }\n\n    private suspend fun runCycle(stopChannel: Channel<Unit>) {\n        val trailingActor = lastActor(stopChannel)\n\n        var previous = trailingActor\n        for (i in 1 until CORES_COUNT) {\n            previous = createActor(previous, stopChannel)\n        }\n\n        trailingActor.send(Letter(Start(), previous))\n    }\n\n    private fun lastActor(stopChannel: Channel<Unit>) = actor<Letter>(capacity = 1024) {\n        var nextChannel: SendChannel<Letter>? = null\n        val state = LongArray(actorStateSize) { ThreadLocalRandom.current().nextLong(1024) }\n\n        for (letter in channel) with(letter) {\n            when (message) {\n                is Start -> {\n                    nextChannel = sender\n                    sender.send(Letter(Ball(ThreadLocalRandom.current().nextInt(1, 100)), NO_CHANNEL))\n                }\n                is Ball -> {\n                    nextChannel!!.send(Letter(Ball(transmogrify(message.count, state)), NO_CHANNEL))\n                }\n                is Stop -> {\n                    stopChannel.send(Unit)\n                    return@actor\n                }\n                else -> error(\"Can't happen\")\n            }\n        }\n    }\n\n    private fun createActor(nextActor: SendChannel<Letter>, stopChannel: Channel<Unit>) = actor<Letter>(capacity = 1024) {\n        var received = 0\n        val state = LongArray(actorStateSize) { ThreadLocalRandom.current().nextLong(1024) }\n\n        for (letter in channel) with(letter) {\n            when (message) {\n                is Ball -> {\n                    if (++received > 1_000) {\n                        nextActor.send(Letter(Stop(), NO_CHANNEL))\n                        stopChannel.send(Unit)\n                        return@actor\n                    } else {\n                        nextActor.send(Letter(Ball(transmogrify(message.count, state)), NO_CHANNEL))\n                    }\n                }\n                is Stop -> {\n                    nextActor.send(Letter(Stop(), NO_CHANNEL))\n                    stopChannel.send(Unit)\n                }\n                else -> error(\"Can't happen\")\n            }\n        }\n    }\n\n    private fun transmogrify(value: Int, coefficients: LongArray): Int {\n        var result = 0L\n        for (coefficient in coefficients) {\n            result += coefficient * value\n        }\n\n        return result.toInt()\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/scheduler/actors/PingPongActorBenchmark.kt",
        "content": "package benchmarks.scheduler.actors\n\nimport benchmarks.*\nimport benchmarks.akka.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n/*\n * Benchmark                                   (dispatcher)  Mode  Cnt    Score    Error  Units\n * PingPongActorBenchmark.coresCountPingPongs  experimental  avgt   10  185.066 \u00b1 21.692  ms/op\n * PingPongActorBenchmark.coresCountPingPongs           fjp  avgt   10  200.581 \u00b1 22.669  ms/op\n * PingPongActorBenchmark.coresCountPingPongs         ftp_1  avgt   10  494.334 \u00b1 27.450  ms/op\n * PingPongActorBenchmark.coresCountPingPongs         ftp_2  avgt   10  498.754 \u00b1 27.743  ms/op\n * PingPongActorBenchmark.coresCountPingPongs         ftp_8  avgt   10  804.498 \u00b1 69.826  ms/op\n *\n * PingPongActorBenchmark.singlePingPong       experimental  avgt   10   45.521 \u00b1  3.281  ms/op\n * PingPongActorBenchmark.singlePingPong                fjp  avgt   10  217.005 \u00b1 18.693  ms/op\n * PingPongActorBenchmark.singlePingPong              ftp_1  avgt   10   57.632 \u00b1  1.835  ms/op\n * PingPongActorBenchmark.singlePingPong              ftp_2  avgt   10  112.723 \u00b1  5.280  ms/op\n * PingPongActorBenchmark.singlePingPong              ftp_8  avgt   10  276.958 \u00b1 21.447  ms/op\n */\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class PingPongActorBenchmark : ParametrizedDispatcherBase() {\n    data class Letter(val message: Any?, val sender: SendChannel<Letter>)\n\n    @Param(\"scheduler\", \"fjp\", \"ftp_1\")\n    override var dispatcher: String = \"fjp\"\n\n    @Benchmark\n    fun singlePingPong() = runBlocking {\n        runPingPongs(1)\n    }\n\n    @Benchmark\n    fun coresCountPingPongs() = runBlocking {\n        runPingPongs(Runtime.getRuntime().availableProcessors())\n    }\n\n    private suspend fun runPingPongs(count: Int) {\n        val me = Channel<Letter>()\n        repeat(count) {\n            val pong = pongActorCoroutine()\n            val ping = pingActorCoroutine(pong)\n            ping.send(Letter(Start(), me))\n        }\n\n        repeat(count) {\n            me.receive()\n        }\n    }\n}\n\nfun CoroutineScope.pingActorCoroutine(\n    pingChannel: SendChannel<PingPongActorBenchmark.Letter>,\n    capacity: Int = 1\n) =\n    actor<PingPongActorBenchmark.Letter>(capacity = capacity) {\n        var initiator: SendChannel<PingPongActorBenchmark.Letter>? = null\n        for (letter in channel) with(letter) {\n            when (message) {\n                is Start -> {\n                    initiator = sender\n                    pingChannel.send(PingPongActorBenchmark.Letter(Ball(0), channel))\n                }\n                is Ball -> {\n                    pingChannel.send(PingPongActorBenchmark.Letter(Ball(message.count + 1), channel))\n                }\n                is Stop -> {\n                    initiator!!.send(PingPongActorBenchmark.Letter(Stop(), channel))\n                    return@actor\n                }\n                else -> error(\"Cannot happen $message\")\n            }\n        }\n    }\n\nfun CoroutineScope.pongActorCoroutine(capacity: Int = 1) =\n    actor<PingPongActorBenchmark.Letter>(capacity = capacity) {\n        for (letter in channel) with(letter) {\n            when (message) {\n                is Ball -> {\n                    if (message.count >= N_MESSAGES) {\n                        sender.send(PingPongActorBenchmark.Letter(Stop(), channel))\n                        return@actor\n                    } else {\n                        sender.send(PingPongActorBenchmark.Letter(Ball(message.count + 1), channel))\n                    }\n                }\n                else -> error(\"Cannot happen $message\")\n            }\n        }\n    }\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/scheduler/actors/PingPongWithBlockingContext.kt",
        "content": "package benchmarks.scheduler.actors\n\nimport benchmarks.akka.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.scheduling.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n\n/*\n * Benchmark                                                  Mode  Cnt    Score     Error  Units\n * PingPongWithBlockingContext.commonPoolWithContextPingPong  avgt   20  972.662 \u00b1 103.448  ms/op\n * PingPongWithBlockingContext.limitingDispatcherPingPong     avgt   20  136.167 \u00b1   4.971  ms/op\n * PingPongWithBlockingContext.withContextPingPong            avgt   20  761.669 \u00b1  41.371  ms/op\n */\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class PingPongWithBlockingContext {\n\n    private val experimental = Dispatchers.Default\n    private val blocking = Dispatchers.IO.limitedParallelism(8)\n    private val threadPool = newFixedThreadPoolContext(8, \"PongCtx\")\n\n    @TearDown\n    fun tearDown() {\n        threadPool.close()\n    }\n\n\n    @Benchmark\n    fun limitingDispatcherPingPong() = runBlocking {\n        runPingPongs(experimental, blocking)\n    }\n\n\n    @Benchmark\n    fun withContextPingPong() = runBlocking {\n        runPingPongs(experimental, threadPool)\n    }\n\n    @Benchmark\n    fun commonPoolWithContextPingPong() = runBlocking {\n        runPingPongs(ForkJoinPool.commonPool().asCoroutineDispatcher(), threadPool)\n    }\n\n    private suspend fun runPingPongs(pingContext: CoroutineContext, pongContext: CoroutineContext) {\n        val me = Channel<PingPongActorBenchmark.Letter>()\n        val pong = CoroutineScope(pongContext).pongActorCoroutine()\n        val ping = CoroutineScope(pingContext).pingActorCoroutine(pong)\n        ping.send(PingPongActorBenchmark.Letter(Start(), me))\n\n        me.receive()\n    }\n}\n"
    },
    {
        "path": "benchmarks/src/jmh/kotlin/benchmarks/scheduler/actors/StatefulActorBenchmark.kt",
        "content": "package benchmarks.scheduler.actors\n\nimport benchmarks.*\nimport benchmarks.akka.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n/*\n * kotlinx-based counterpart of [StatefulActorAkkaBenchmark]\n *\n * Benchmark                                                      (dispatcher)  Mode  Cnt    Score    Error  Units\n * StatefulActorBenchmark.multipleComputationsMultipleRequestors           fjp  avgt   10   81.649 \u00b1  9.671  ms/op\n * StatefulActorBenchmark.multipleComputationsMultipleRequestors         ftp_1  avgt   10  160.590 \u00b1 50.342  ms/op\n * StatefulActorBenchmark.multipleComputationsMultipleRequestors         ftp_8  avgt   10  275.798 \u00b1 32.795  ms/op\n *\n * StatefulActorBenchmark.multipleComputationsSingleRequestor              fjp  avgt   10   67.206 \u00b1  4.023  ms/op\n * StatefulActorBenchmark.multipleComputationsSingleRequestor            ftp_1  avgt   10   17.883 \u00b1  1.314  ms/op\n * StatefulActorBenchmark.multipleComputationsSingleRequestor            ftp_8  avgt   10   77.052 \u00b1 10.132  ms/op\n *\n * StatefulActorBenchmark.singleComputationMultipleRequestors              fjp  avgt   10  488.003 \u00b1 53.014  ms/op\n * StatefulActorBenchmark.singleComputationMultipleRequestors            ftp_1  avgt   10  120.445 \u00b1 24.659  ms/op\n * StatefulActorBenchmark.singleComputationMultipleRequestors            ftp_8  avgt   10  527.118 \u00b1 51.139  ms/op\n *\n * StatefulActorBenchmark.singleComputationSingleRequestor                 fjp  avgt   10   95.030 \u00b1 23.850  ms/op\n * StatefulActorBenchmark.singleComputationSingleRequestor               ftp_1  avgt   10   16.005 \u00b1  0.629  ms/op\n * StatefulActorBenchmark.singleComputationSingleRequestor               ftp_8  avgt   10   76.435 \u00b1  5.076  ms/op\n */\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class StatefulActorBenchmark : ParametrizedDispatcherBase() {\n\n    data class Letter(val message: Any, val sender: SendChannel<Letter>)\n\n    @Param(\"fjp\", \"ftp_1\", \"ftp_8\", \"scheduler\")\n    override var dispatcher: String = \"fjp\"\n\n    @Benchmark\n    fun singleComputationSingleRequestor() = runBlocking {\n        run(1, 1)\n    }\n\n    @Benchmark\n    fun singleComputationMultipleRequestors() = runBlocking {\n        run(1, CORES_COUNT)\n    }\n\n    @Benchmark\n    fun multipleComputationsSingleRequestor() = runBlocking {\n        run(CORES_COUNT, 1)\n    }\n\n    @Benchmark\n    fun multipleComputationsMultipleRequestors() = runBlocking {\n        run(CORES_COUNT, CORES_COUNT)\n    }\n\n    private suspend fun run(computationActorsCount: Int, requestorActorsCount: Int) {\n        val resultChannel: Channel<Unit> = Channel(requestorActorsCount)\n        val computations = (0 until computationActorsCount).map { computationActor() }\n        val requestors = (0 until requestorActorsCount).map { requestorActor(computations, resultChannel) }\n\n        for (requestor in requestors) {\n            requestor.send(Letter(1L, Channel()))\n        }\n\n        repeat(requestorActorsCount) {\n            resultChannel.receive()\n        }\n    }\n\n    private fun CoroutineScope.requestorActor(computations: List<SendChannel<Letter>>, stopChannel: Channel<Unit>) =\n        actor<Letter>(capacity = 1024) {\n            var received = 0\n            for (letter in channel) with(letter) {\n                when (message) {\n                    is Long -> {\n                        if (++received >= ROUNDS) {\n                            stopChannel.send(Unit)\n                            return@actor\n                        } else {\n                            computations[ThreadLocalRandom.current().nextInt(0, computations.size)]\n                                    .send(Letter(ThreadLocalRandom.current().nextLong(), channel))\n                        }\n                    }\n                    else -> error(\"Cannot happen: $letter\")\n                }\n            }\n        }\n}\n\nfun CoroutineScope.computationActor(stateSize: Int = STATE_SIZE) =\n    actor<StatefulActorBenchmark.Letter>(capacity = 1024) {\n        val coefficients = LongArray(stateSize) { ThreadLocalRandom.current().nextLong(0, 100) }\n\n        for (letter in channel) with(letter) {\n            when (message) {\n                is Long -> {\n                    var result = 0L\n                    for (coefficient in coefficients) {\n                        result += message * coefficient\n                    }\n\n                    sender.send(StatefulActorBenchmark.Letter(result, channel))\n                }\n                is Stop -> return@actor\n                else -> error(\"Cannot happen: $letter\")\n            }\n        }\n    }\n"
    },
    {
        "path": "benchmarks/src/main/kotlin/benchmarks/common/BenchmarkUtils.kt",
        "content": "package benchmarks.common\n\nimport java.util.concurrent.*\n\npublic fun doGeomDistrWork(work: Int) {\n    // We use geometric distribution here. We also checked on macbook pro 13\" (2017) that the resulting work times\n    // are distributed geometrically, see https://github.com/Kotlin/kotlinx.coroutines/pull/1464#discussion_r355705325\n    val p = 1.0 / work\n    val r = ThreadLocalRandom.current()\n    while (true) {\n        if (r.nextDouble() < p) break\n    }\n}\n"
    },
    {
        "path": "build.gradle.kts",
        "content": "import org.jetbrains.kotlin.config.KotlinCompilerVersion\nimport org.jetbrains.kotlin.gradle.dsl.*\nimport org.gradle.kotlin.dsl.*\n\nbuildscript {\n    if (shouldUseLocalMaven(rootProject)) {\n        repositories {\n            mavenLocal()\n        }\n    }\n\n    repositories {\n        mavenCentral()\n        maven(url = \"https://plugins.gradle.org/m2/\")\n        addDevRepositoryIfEnabled(this, project)\n        mavenLocal()\n    }\n\n    dependencies {\n        // Please ensure that atomicfu-gradle-plugin is added to the classpath first, do not change the order, for details see #3984.\n        // The corresponding issue in kotlinx-atomicfu: https://github.com/Kotlin/kotlinx-atomicfu/issues/384\n        classpath(\"org.jetbrains.kotlinx:atomicfu-gradle-plugin:${version(\"atomicfu\")}\")\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:${version(\"kotlin\")}\")\n        classpath(\"org.jetbrains.dokka:dokka-gradle-plugin:${version(\"dokka\")}\")\n        classpath(\"org.jetbrains.kotlinx:kotlinx-knit:${version(\"knit\")}\")\n        classpath(\"org.jetbrains.kotlinx:binary-compatibility-validator:${version(\"binary_compatibility_validator\")}\")\n        classpath(\"ru.vyarus:gradle-animalsniffer-plugin:${version(\"animalsniffer\")}\") // Android API check\n        classpath(\"org.jetbrains.kotlin:atomicfu:${version(\"kotlin\")}\")\n        classpath(\"org.jetbrains.kotlinx:kover-gradle-plugin:${version(\"kover\")}\")\n\n        // JMH plugins\n        classpath(\"gradle.plugin.com.github.johnrengelman:shadow:${version(\"shadow\")}\")\n    }\n\n    with(CacheRedirector) { buildscript.configureBuildScript(rootProject) }\n}\n\n// Configure subprojects with Kotlin sources\napply(plugin = \"configure-compilation-conventions\")\n\nallprojects {\n    val deployVersion = properties[\"DeployVersion\"]\n    if (deployVersion != null) version = deployVersion\n\n    if (isSnapshotTrainEnabled(rootProject)) {\n        val skipSnapshotChecks = rootProject.properties[\"skip_snapshot_checks\"] != null\n        if (!skipSnapshotChecks && version != version(\"atomicfu\")) {\n            throw IllegalStateException(\"Current deploy version is $version, but atomicfu version is not overridden (${version(\"atomicfu\")}) for $this\")\n        }\n    }\n\n    if (shouldUseLocalMaven(rootProject)) {\n        repositories {\n            mavenLocal()\n        }\n    }\n\n    // This project property is set during nightly stress test\n    val stressTest = project.properties[\"stressTest\"]\n    // Copy it to all test tasks\n    tasks.withType(Test::class).configureEach {\n        if (stressTest != null) {\n            systemProperty(\"stressTest\", stressTest)\n        }\n    }\n}\n\nplugins {\n    id(\"org.jetbrains.kotlinx.binary-compatibility-validator\") version \"0.13.2\"\n}\n\napply(plugin = \"base\")\napply(plugin = \"kover-conventions\")\n\napiValidation {\n    ignoredProjects += unpublished + listOf(\"kotlinx-coroutines-bom\")\n    if (isSnapshotTrainEnabled(rootProject)) {\n        ignoredProjects += coreModule\n    }\n    ignoredPackages += \"kotlinx.coroutines.internal\"\n}\n\n// Configure repositories\nallprojects {\n    repositories {\n        /*\n         * google should be first in the repository list because some of the play services\n         * transitive dependencies was removed from jcenter, thus breaking gradle dependency resolution\n         */\n        google()\n        mavenCentral()\n        addDevRepositoryIfEnabled(this, project)\n    }\n}\n\n// needs to be before evaluationDependsOn due to weird Gradle ordering\napply(plugin = \"animalsniffer-conventions\")\n\nconfigure(subprojects.filter { !sourceless.contains(it.name) }) {\n    if (isMultiplatform) {\n        apply(plugin = \"kotlin-multiplatform\")\n        apply(plugin = \"kotlin-multiplatform-conventions\")\n    } else if (platformOf(this) == \"jvm\") {\n        apply(plugin = \"kotlin-jvm-conventions\")\n    } else {\n        val platform = platformOf(this)\n        throw IllegalStateException(\"No configuration rules for $platform\")\n    }\n}\n\nconfigure(subprojects.filter { !sourceless.contains(it.name) && it.name != testUtilsModule }) {\n    if (isMultiplatform) {\n        configure<KotlinMultiplatformExtension> {\n            sourceSets.commonTest.dependencies { implementation(project(\":$testUtilsModule\")) }\n        }\n    } else {\n        dependencies { add(\"testImplementation\", project(\":$testUtilsModule\")) }\n    }\n}\n\n// Add dependency to the core module in all the other subprojects.\nconfigure(subprojects.filter { !sourceless.contains(it.name) && it.name != coreModule }) {\n    evaluationDependsOn(\":$coreModule\")\n    if (isMultiplatform) {\n        configure<KotlinMultiplatformExtension> {\n            sourceSets.commonMain.dependencies { api(project(\":$coreModule\")) }\n        }\n    } else {\n        dependencies { add(\"api\", project(\":$coreModule\")) }\n    }\n}\n\napply(plugin = \"bom-conventions\")\napply(plugin = \"java-modularity-conventions\")\napply(plugin = \"version-file-conventions\")\n\nrootProject.configureCommunityBuildTweaks()\n\napply(plugin = \"source-set-conventions\")\napply(plugin = \"dokka-conventions\")\napply(plugin = \"knit-conventions\")\n\n/*\n * TODO: core and non-core cannot be configured via 'configure(subprojects)'\n * because of 'afterEvaluate' issue. This one should be migrated to\n * `plugins { id(\"pub-conventions\") }` eventually\n */\nconfigure(subprojects.filter {\n    !unpublished.contains(it.name) && it.name != coreModule\n}) {\n    apply(plugin = \"pub-conventions\")\n}\n\nAuxBuildConfiguration.configure(rootProject)\nrootProject.registerTopLevelDeployTask()\n\n// Report Kotlin compiler version when building project\nprintln(\"Using Kotlin compiler version: ${KotlinCompilerVersion.VERSION}\")\n\n"
    },
    {
        "path": "buildSrc/build.gradle.kts",
        "content": "import java.util.*\n\nplugins {\n    `kotlin-dsl`\n}\n\nval cacheRedirectorEnabled = System.getenv(\"CACHE_REDIRECTOR\")?.toBoolean() == true\nval buildSnapshotTrain = properties[\"build_snapshot_train\"]?.toString()?.toBoolean() == true\nval kotlinDevUrl = project.rootProject.properties[\"kotlin_repo_url\"] as? String\n\nrepositories {\n    mavenCentral()\n    if (cacheRedirectorEnabled) {\n        maven(\"https://cache-redirector.jetbrains.com/plugins.gradle.org/m2\")\n    } else {\n        maven(\"https://plugins.gradle.org/m2\")\n    }\n    if (!kotlinDevUrl.isNullOrEmpty()) {\n        maven(kotlinDevUrl)\n    }\n    if (buildSnapshotTrain) {\n        mavenLocal()\n    }\n}\n\nval gradleProperties = Properties().apply {\n    file(\"../gradle.properties\").inputStream().use { load(it) }\n}\n\nfun version(target: String): String {\n    // Intercept reading from properties file\n    if (target == \"kotlin\") {\n        val snapshotVersion = properties[\"kotlin_snapshot_version\"]\n        if (snapshotVersion != null) return snapshotVersion.toString()\n    }\n    val version = \"${target}_version\"\n    // Read from CLI first, used in aggregate builds\n    return properties[version]?.let{\"$it\"} ?: gradleProperties.getProperty(version)\n}\n\ndependencies {\n    implementation(kotlin(\"gradle-plugin\", version(\"kotlin\")))\n    /*\n     * Dokka is compiled with language level = 1.4, but depends on Kotlin 1.6.0, while\n     * our version of Gradle bundles Kotlin 1.4.x and can read metadata only up to 1.5.x,\n     * thus we're excluding stdlib compiled with 1.6.0 from dependencies.\n     */\n    implementation(\"org.jetbrains.dokka:dokka-gradle-plugin:${version(\"dokka\")}\") {\n        exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib-jdk8\")\n        exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib-jdk7\")\n        exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib\")\n    }\n    implementation(\"org.jetbrains.dokka:dokka-core:${version(\"dokka\")}\") {\n        exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib-jdk8\")\n        exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib-jdk7\")\n        exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib\")\n    }\n    implementation(\"ru.vyarus:gradle-animalsniffer-plugin:${version(\"animalsniffer\")}\") // Android API check\n    implementation(\"org.jetbrains.kotlinx:kover-gradle-plugin:${version(\"kover\")}\") {\n        exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib-jdk8\")\n        exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib-jdk7\")\n        exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib\")\n    }\n    implementation(\"org.jetbrains.kotlinx:kotlinx-benchmark-plugin:0.4.9\")\n    implementation(\"org.jetbrains.kotlinx:kotlinx-knit:${version(\"knit\")}\")\n}\n"
    },
    {
        "path": "buildSrc/settings.gradle.kts",
        "content": "pluginManagement {\n    val build_snapshot_train: String? by settings\n    repositories {\n        val cacheRedirectorEnabled = System.getenv(\"CACHE_REDIRECTOR\")?.toBoolean() == true\n        if (cacheRedirectorEnabled) {\n            println(\"Redirecting repositories for buildSrc buildscript\")\n            maven(\"https://cache-redirector.jetbrains.com/plugins.gradle.org/m2\")\n        } else {\n            maven(\"https://plugins.gradle.org/m2\")\n        }\n        if (build_snapshot_train?.toBoolean() == true) {\n            mavenLocal()\n        }\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/AuxBuildConfiguration.kt",
        "content": "import CacheRedirector.configure\nimport org.gradle.api.Project\nimport org.gradle.api.tasks.*\nimport org.gradle.kotlin.dsl.*\n\n/**\n * Auxiliary build configuration that is grouped in a single place for convenience:\n * - Workarounds for Gradle/KGP issues\n * - Cache redirector\n */\nobject AuxBuildConfiguration {\n\n    @JvmStatic\n    fun configure(rootProject: Project) {\n        rootProject.allprojects {\n            workaroundForCleanTask()\n            CacheRedirector.configure(this)\n            workaroundForCoroutinesLeakageToClassPath()\n        }\n\n        CacheRedirector.configureJsPackageManagers(rootProject)\n        CacheRedirector.configureWasmNodeRepositories(rootProject)\n\n        // Sigh, there is no BuildScanExtension in classpath when there is no --scan\n        rootProject.extensions.findByName(\"buildScan\")?.withGroovyBuilder {\n            setProperty(\"termsOfServiceUrl\", \"https://gradle.com/terms-of-service\")\n            setProperty(\"termsOfServiceAgree\", \"yes\")\n        }\n    }\n\n    private fun Project.workaroundForCleanTask() {\n        // the 'clean' task cannot delete expanded.lock file on Windows as it is still held by Gradle, failing the build\n        // Gradle issue: https://github.com/gradle/gradle/issues/25752\n        tasks {\n            val clean by existing(Delete::class) {\n                setDelete(fileTree(layout.buildDirectory) {\n                    exclude(\"tmp/.cache/expanded/expanded.lock\")\n                })\n            }\n        }\n    }\n\n    /*\n     * 'kotlinx-coroutines-core' dependency leaks into test runtime classpath via 'kotlin-compiler-embeddable'\n     * and conflicts with our own test/runtime incompatibilities (e.g. when class is moved from a main to test),\n     * so we do substitution here.\n     * TODO figure out if it's still the problem\n     */\n    private fun Project.workaroundForCoroutinesLeakageToClassPath() {\n        configurations\n            .matching {\n                // Excluding substituted project itself because of circular dependencies, but still do it\n                // for \"*Test*\" configurations\n                name != coreModule || it.name.contains(\"Test\")\n            }\n            .configureEach {\n                resolutionStrategy.dependencySubstitution {\n                    substitute(module(\"org.jetbrains.kotlinx:$coreModule\"))\n                        .using(project(\":$coreModule\"))\n                        .because(\n                            \"Because Kotlin compiler embeddable leaks coroutines into the runtime classpath, \" +\n                                \"triggering all sort of incompatible class changes errors\"\n                        )\n                }\n            }\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/CacheRedirector.kt",
        "content": "import org.gradle.api.*\nimport org.gradle.api.artifacts.dsl.*\nimport org.gradle.api.artifacts.repositories.*\nimport org.gradle.api.initialization.dsl.*\nimport org.gradle.kotlin.dsl.*\nimport org.jetbrains.kotlin.gradle.targets.js.nodejs.*\nimport org.jetbrains.kotlin.gradle.targets.js.npm.tasks.*\nimport org.jetbrains.kotlin.gradle.targets.js.yarn.*\nimport java.net.*\n\n/**\n * Enabled via environment variable, so that it can be reliably accessed from any piece of the build script,\n * including buildSrc within TeamCity CI.\n */\nprivate val cacheRedirectorEnabled = System.getenv(\"CACHE_REDIRECTOR\")?.toBoolean() == true\n\n/**\n *  The list of repositories supported by cache redirector should be synced with the list at https://cache-redirector.jetbrains.com/redirects_generated.html\n *  To add a repository to the list create an issue in ADM project (example issue https://youtrack.jetbrains.com/issue/IJI-149)\n */\nprivate val mirroredUrls = listOf(\n    \"https://cdn.azul.com/zulu/bin\",\n    \"https://clojars.org/repo\",\n    \"https://dl.google.com/android/repository\",\n    \"https://dl.google.com/dl/android/maven2\",\n    \"https://dl.google.com/dl/android/studio/ide-zips\",\n    \"https://dl.google.com/go\",\n    \"https://download.jetbrains.com\",\n    \"https://github.com/yarnpkg/yarn/releases/download\",\n    \"https://jitpack.io\",\n    \"https://maven.pkg.jetbrains.space/kotlin/p/kotlin/bootstrap\",\n    \"https://maven.pkg.jetbrains.space/kotlin/p/kotlin/dev\",\n    \"https://maven.pkg.jetbrains.space/kotlin/p/kotlin/eap\",\n    \"https://nodejs.org/dist\",\n    \"https://oss.sonatype.org/content/repositories/releases\",\n    \"https://oss.sonatype.org/content/repositories/snapshots\",\n    \"https://oss.sonatype.org/content/repositories/staging\",\n    \"https://packages.confluent.io/maven/\",\n    \"https://plugins.gradle.org/m2\",\n    \"https://plugins.jetbrains.com/maven\",\n    \"https://repo.grails.org/grails/core\",\n    \"https://repo.jenkins-ci.org/releases\",\n    \"https://repo.maven.apache.org/maven2\",\n    \"https://repo.spring.io/milestone\",\n    \"https://repo.typesafe.com/typesafe/ivy-releases\",\n    \"https://repo1.maven.org/maven2\",\n    \"https://services.gradle.org\",\n    \"https://www.exasol.com/artifactory/exasol-releases\",\n    \"https://www.jetbrains.com/intellij-repository/nightly\",\n    \"https://www.jetbrains.com/intellij-repository/releases\",\n    \"https://www.jetbrains.com/intellij-repository/snapshots\",\n    \"https://www.myget.org/F/intellij-go-snapshots/maven\",\n    \"https://www.myget.org/F/rd-model-snapshots/maven\",\n    \"https://www.myget.org/F/rd-snapshots/maven\",\n    \"https://www.python.org/ftp\",\n)\n\nprivate val aliases = mapOf(\n    \"https://repo.maven.apache.org/maven2\" to \"https://repo1.maven.org/maven2\" // Maven Central\n)\n\nprivate fun URI.toCacheRedirectorUri() = URI(\"https://cache-redirector.jetbrains.com/$host/$path\")\n\nprivate fun URI.maybeRedirect(): URI? {\n    val url = toString().trimEnd('/')\n    val dealiasedUrl = aliases.getOrDefault(url, url)\n\n    return if (mirroredUrls.any { dealiasedUrl.startsWith(it) }) {\n        URI(dealiasedUrl).toCacheRedirectorUri()\n    } else {\n        null\n    }\n}\n\nprivate fun URI.isCachedOrLocal() = scheme == \"file\" ||\n    host == \"cache-redirector.jetbrains.com\" ||\n    host == \"teamcity.jetbrains.com\" ||\n    host == \"buildserver.labs.intellij.net\"\n\nprivate fun Project.checkRedirectUrl(url: URI, containerName: String): URI {\n    val redirected = url.maybeRedirect()\n    if (redirected == null && !url.isCachedOrLocal()) {\n        val msg = \"Repository $url in $containerName should be cached with cache-redirector\"\n        val details = \"Using non cached repository may lead to download failures in CI builds.\" +\n            \" Check buildSrc/src/main/kotlin/CacheRedirector.kt for details.\"\n        logger.warn(\"WARNING - $msg\\n$details\")\n    }\n    return if (cacheRedirectorEnabled) redirected ?: url else url\n}\n\nprivate fun Project.checkRedirect(repositories: RepositoryHandler, containerName: String) {\n    if (cacheRedirectorEnabled) {\n        logger.info(\"Redirecting repositories for $containerName\")\n    }\n    for (repository in repositories) {\n        when (repository) {\n            is MavenArtifactRepository -> repository.url = checkRedirectUrl(repository.url, containerName)\n            is IvyArtifactRepository -> repository.url = checkRedirectUrl(repository.url, containerName)\n        }\n    }\n}\n\nprivate fun Project.configureYarnAndNodeRedirects() {\n    if (CacheRedirector.isEnabled) {\n        val yarnRootExtension = extensions.findByType<YarnRootExtension>()\n        yarnRootExtension?.downloadBaseUrl?.let {\n            yarnRootExtension.downloadBaseUrl = CacheRedirector.maybeRedirect(it)\n        }\n\n        val nodeJsExtension = rootProject.extensions.findByType<NodeJsRootExtension>()\n        nodeJsExtension?.nodeDownloadBaseUrl?.let {\n            nodeJsExtension.nodeDownloadBaseUrl = CacheRedirector.maybeRedirect(it)\n        }\n    }\n}\n\n// Used from Groovy scripts\n// TODO get rid of Groovy, come up with a proper convention for rootProject vs arbitrary project argument\nobject CacheRedirector {\n    /**\n     * Substitutes repositories in buildScript { } block.\n     */\n    @JvmStatic\n    fun ScriptHandler.configureBuildScript(rootProject: Project) {\n        rootProject.checkRedirect(repositories, \"${rootProject.displayName} buildscript\")\n    }\n\n    @JvmStatic\n    fun configure(project: Project) {\n        project.checkRedirect(project.repositories, project.displayName)\n    }\n\n    /**\n     * Configures JS-specific extensions to use\n     */\n    @JvmStatic\n    fun configureJsPackageManagers(project: Project) {\n        project.configureYarnAndNodeRedirects()\n    }\n\n    /**\n     * Temporary repositories to depend on until GC milestone 4 in KGP\n     * and stable Node release. Safe to remove when its removal does not break WASM tests.\n     */\n    @JvmStatic\n    fun configureWasmNodeRepositories(project: Project) {\n        val extension = project.extensions.findByType<NodeJsRootExtension>()\n        if (extension != null) {\n            extension.nodeVersion = \"21.0.0-v8-canary202309167e82ab1fa2\"\n            extension.nodeDownloadBaseUrl = \"https://nodejs.org/download/v8-canary\"\n        }\n\n        project.tasks.withType<KotlinNpmInstallTask>().configureEach {\n            args.add(\"--ignore-engines\")\n        }\n    }\n\n    @JvmStatic\n    fun maybeRedirect(url: String): String {\n        if (!cacheRedirectorEnabled) return url\n        return URI(url).maybeRedirect()?.toString() ?: url\n    }\n\n    @JvmStatic\n    val isEnabled get() = cacheRedirectorEnabled\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/CommunityProjectsBuild.kt",
        "content": "@file:JvmName(\"CommunityProjectsBuild\")\n\nimport org.gradle.api.*\nimport org.gradle.api.artifacts.dsl.*\nimport org.gradle.api.tasks.testing.Test\nimport org.gradle.kotlin.dsl.*\nimport java.net.*\nimport java.util.logging.*\nimport org.jetbrains.kotlin.gradle.dsl.KotlinVersion\n\nprivate val LOGGER: Logger = Logger.getLogger(\"Kotlin settings logger\")\n\n/**\n * Functions in this file are responsible for configuring kotlinx.coroutines build against a custom dev version\n * of Kotlin compiler.\n * Such configuration is used in a composite community build of Kotlin in order to check whether not-yet-released changes\n * are compatible with our libraries (aka \"integration testing that substitutes lack of unit testing\").\n *\n * When `build_snapshot_train` is set to true (and [isSnapshotTrainEnabled] returns `true`),\n * - `kotlin_version property` is overridden with `kotlin_snapshot_version` (see [getOverriddenKotlinVersion]),\n * - `atomicfu_version` is overwritten by TeamCity environment (AFU is built with snapshot and published to mavenLocal\n *   as previous step or the snapshot build).\n * Additionally, mavenLocal and Sonatype snapshots are added to repository list and stress tests are disabled\n * (see [configureCommunityBuildTweaks]).\n *\n * DO NOT change the name of these properties without adapting the kotlinx.train build chain.\n*/\n\n/**\n * Should be used for running against of non-released Kotlin compiler on a system test level.\n *\n * @return a Kotlin API version parametrized from command line nor gradle.properties, null otherwise\n */\nfun getOverriddenKotlinApiVersion(project: Project): KotlinVersion? {\n    val apiVersion = project.rootProject.properties[\"kotlin_api_version\"] as? String\n    return if (apiVersion != null) {\n        LOGGER.info(\"\"\"Configured Kotlin API version: '$apiVersion' for project $${project.name}\"\"\")\n        KotlinVersion.fromVersion(apiVersion)\n    } else {\n        null\n    }\n}\n\n/**\n * Should be used for running against of non-released Kotlin compiler on a system test level\n *\n * @return a Kotlin Language version parametrized from command line nor gradle.properties, null otherwise\n */\nfun getOverriddenKotlinLanguageVersion(project: Project): KotlinVersion? {\n    val languageVersion = project.rootProject.properties[\"kotlin_language_version\"] as? String\n    return if (languageVersion != null) {\n        LOGGER.info(\"\"\"Configured Kotlin Language version: '$languageVersion' for project ${project.name}\"\"\")\n        KotlinVersion.fromVersion(languageVersion)\n    } else {\n        null\n    }\n}\n\n/**\n * Should be used for running against of non-released Kotlin compiler on a system test level\n * Kotlin compiler artifacts are expected to be downloaded from maven central by default.\n * In case of compiling with not-published into the MC kotlin compiler artifacts, a kotlin_repo_url gradle parameter should be specified.\n * To reproduce a build locally, a kotlin/dev repo should be passed\n *\n * @return an url for a kotlin compiler repository parametrized from command line nor gradle.properties, empty string otherwise\n */\nfun getKotlinDevRepositoryUrl(project: Project): URI? {\n    val url: String? = project.rootProject.properties[\"kotlin_repo_url\"] as? String\n    if (url != null) {\n        LOGGER.info(\"\"\"Configured Kotlin Compiler repository url: '$url' for project ${project.name}\"\"\")\n        return URI.create(url)\n    }\n    return null\n}\n\n/**\n * Adds a kotlin-dev space repository with dev versions of Kotlin if Kotlin aggregate build is enabled\n */\nfun addDevRepositoryIfEnabled(rh: RepositoryHandler, project: Project) {\n    val devRepoUrl = getKotlinDevRepositoryUrl(project) ?: return\n    rh.maven {\n        url = devRepoUrl\n    }\n}\n\n/**\n * Changes the build config when 'build_snapshot_train' is enabled:\n * Disables flaky and Kotlin-specific tests, prints the real version of Kotlin applied (to be sure overridden version of Kotlin is properly picked).\n */\nfun Project.configureCommunityBuildTweaks() {\n    if (!isSnapshotTrainEnabled(this)) return\n    allprojects {\n        // Disable stress tests and tests that are flaky on Kotlin version specific\n        tasks.withType<Test>().configureEach {\n            exclude(\"**/*LinearizabilityTest*\")\n            exclude(\"**/*LFTest*\")\n            exclude(\"**/*StressTest*\")\n            exclude(\"**/*scheduling*\")\n            exclude(\"**/*Timeout*\")\n            exclude(\"**/*definitely/not/kotlinx*\")\n            exclude(\"**/*PrecompiledDebugProbesTest*\")\n        }\n    }\n\n    println(\"Manifest of kotlin-compiler-embeddable.jar for coroutines\")\n    val coreProject = subprojects.single { it.name == coreModule }\n    configure(listOf(coreProject)) {\n        configurations.matching { it.name == \"kotlinCompilerClasspath\" }.configureEach {\n            val config = resolvedConfiguration.files.single { it.name.contains(\"kotlin-compiler-embeddable\") }\n\n            val manifest = zipTree(config).matching {\n                include(\"META-INF/MANIFEST.MF\")\n            }.files.single()\n\n            manifest.readLines().forEach {\n                println(it)\n            }\n        }\n    }\n}\n\n/**\n * Ensures that, if [isSnapshotTrainEnabled] is true, the project is built with a snapshot version of Kotlin compiler.\n */\nfun getOverriddenKotlinVersion(project: Project): String? =\n    if (isSnapshotTrainEnabled(project)) {\n        val snapshotVersion = project.rootProject.properties[\"kotlin_snapshot_version\"]\n            ?: error(\"'kotlin_snapshot_version' should be defined when building with a snapshot compiler\")\n        snapshotVersion.toString()\n    } else {\n        null\n    }\n\n/**\n * Checks if the project is built with a snapshot version of Kotlin compiler.\n */\nfun isSnapshotTrainEnabled(project: Project): Boolean =\n    when (project.rootProject.properties[\"build_snapshot_train\"]) {\n        null -> false\n        \"\" -> false\n        else -> true\n    }\n\nfun shouldUseLocalMaven(project: Project): Boolean {\n    var someDependencyIsSnapshot = false\n    project.rootProject.properties.forEach { key, value ->\n        if (key.endsWith(\"_version\") && value is String && value.endsWith(\"-SNAPSHOT\")) {\n            println(\"NOTE: USING SNAPSHOT VERSION: $key=$value\")\n            someDependencyIsSnapshot = true\n        }\n    }\n    return isSnapshotTrainEnabled(project) || someDependencyIsSnapshot\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/Dokka.kt",
        "content": "import org.gradle.api.*\nimport org.gradle.kotlin.dsl.*\nimport org.jetbrains.dokka.gradle.*\nimport java.io.*\nimport java.net.*\n\n/**\n * Package-list by external URL for documentation generation.\n */\nfun Project.externalDocumentationLink(\n    url: String,\n    packageList: File = projectDir.resolve(\"package.list\")\n) {\n    tasks.withType<AbstractDokkaLeafTask>().configureEach {\n        dokkaSourceSets.configureEach {\n            externalDocumentationLink {\n                this.url = URL(url)\n                packageListUrl = packageList.toPath().toUri().toURL()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/Idea.kt",
        "content": "object Idea {\n    @JvmStatic // for Gradle\n    val active: Boolean\n        get() = System.getProperty(\"idea.active\") == \"true\"\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/Java9Modularity.kt",
        "content": "import org.gradle.api.*\nimport org.gradle.api.attributes.*\nimport org.gradle.api.file.*\nimport org.gradle.api.tasks.*\nimport org.gradle.api.tasks.bundling.*\nimport org.gradle.api.tasks.compile.*\nimport org.gradle.jvm.toolchain.*\nimport org.gradle.kotlin.dsl.*\nimport org.gradle.work.*\nimport org.jetbrains.kotlin.gradle.dsl.*\n\n/**\n * This object configures the Java compilation of a JPMS (aka Jigsaw) module descriptor.\n * The source file for the module descriptor is expected at <project-dir>/src/module-info.java.\n *\n * To maintain backwards compatibility with Java 8, the jvm JAR is marked as a multi-release JAR\n * with the module-info.class being moved to META-INF/versions/9/module-info.class.\n *\n * The Java toolchains feature of Gradle is used to detect or provision a JDK 11,\n * which is used to compile the module descriptor.\n */\nobject Java9Modularity {\n\n    /**\n     * Task that patches `module-info.java` and removes `requires kotlinx.atomicfu` directive.\n     *\n     * To have JPMS properly supported, Kotlin compiler **must** be supplied with the correct `module-info.java`.\n     * The correct module info has to contain `atomicfu` requirement because atomicfu plugin kicks-in **after**\n     * the compilation process. But `atomicfu` is compile-only dependency that shouldn't be present in the final\n     * `module-info.java` and that's exactly what this task ensures.\n     */\n    abstract class ProcessModuleInfoFile : DefaultTask() {\n        @get:InputFile\n        @get:NormalizeLineEndings\n        abstract val moduleInfoFile: RegularFileProperty\n\n        @get:OutputFile\n        abstract val processedModuleInfoFile: RegularFileProperty\n\n        private val projectPath = project.path\n\n        @TaskAction\n        fun process() {\n            val sourceFile = moduleInfoFile.get().asFile\n            if (!sourceFile.exists()) {\n                throw IllegalStateException(\"$sourceFile not found in $projectPath\")\n            }\n            val outputFile = processedModuleInfoFile.get().asFile\n            sourceFile.useLines { lines ->\n                outputFile.outputStream().bufferedWriter().use { writer ->\n                    for (line in lines) {\n                        if (\"kotlinx.atomicfu\" in line) continue\n                        writer.write(line)\n                        writer.newLine()\n                    }\n                }\n            }\n        }\n    }\n\n    @JvmStatic\n    fun configure(project: Project) = with(project) {\n        val javaToolchains = extensions.findByType(JavaToolchainService::class.java)\n            ?: error(\"Gradle JavaToolchainService is not available\")\n        val target = when (val kotlin = extensions.getByName(\"kotlin\")) {\n            is KotlinJvmProjectExtension -> kotlin.target\n            is KotlinMultiplatformExtension -> kotlin.targets.getByName(\"jvm\")\n            else -> throw IllegalStateException(\"Unknown Kotlin project extension in $project\")\n        }\n        val compilation = target.compilations.getByName(\"main\")\n\n        // Force the use of JARs for compile dependencies, so any JPMS descriptors are picked up.\n        // For more details, see https://github.com/gradle/gradle/issues/890#issuecomment-623392772\n        configurations.getByName(compilation.compileDependencyConfigurationName).attributes {\n            attribute(\n                LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE,\n                objects.named(LibraryElements::class, LibraryElements.JAR)\n            )\n        }\n\n        val processModuleInfoFile by tasks.registering(ProcessModuleInfoFile::class) {\n            moduleInfoFile = file(\"${target.name.ifEmpty { \".\" }}/src/module-info.java\")\n            processedModuleInfoFile = project.layout.buildDirectory.file(\"generated-sources/module-info-processor/module-info.java\")\n        }\n\n        val compileJavaModuleInfo = tasks.register(\"compileModuleInfoJava\", JavaCompile::class.java) {\n            val moduleName = project.name.replace('-', '.') // this module's name\n            val compileKotlinTask =\n                compilation.compileTaskProvider.get() as? org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n                    ?: error(\"Cannot access Kotlin compile task ${compilation.compileKotlinTaskName}\")\n            val targetDir = compileKotlinTask.destinationDirectory.dir(\"../java9\")\n\n            // Use a Java 11 compiler for the module-info.\n            javaCompiler = javaToolchains.compilerFor {\n                languageVersion = JavaLanguageVersion.of(11)\n            }\n\n            // Always compile kotlin classes before the module descriptor.\n            dependsOn(compileKotlinTask)\n\n            // Add the module-info source file.\n            // Note that we use the parent dir and an include filter,\n            // this is needed for Gradle's module detection to work in\n            // org.gradle.api.tasks.compile.JavaCompile.createSpec\n            source(processModuleInfoFile.map { it.processedModuleInfoFile.asFile.get().parentFile })\n            val generatedModuleInfoFile = processModuleInfoFile.flatMap { it.processedModuleInfoFile.asFile }\n            include { it.file == generatedModuleInfoFile.get() }\n\n            // Set the task outputs and destination directory\n            outputs.dir(targetDir)\n            destinationDirectory = targetDir\n\n            // Configure JVM compatibility\n            sourceCompatibility = JavaVersion.VERSION_1_9.toString()\n            targetCompatibility = JavaVersion.VERSION_1_9.toString()\n\n            // Set the Java release version.\n            options.release = 9\n\n            // Ignore warnings about using 'requires transitive' on automatic modules.\n            // not needed when compiling with recent JDKs, e.g. 17\n            options.compilerArgs.add(\"-Xlint:-requires-transitive-automatic\")\n\n            // Patch the compileKotlinJvm output classes into the compilation so exporting packages works correctly.\n            val destinationDirProperty = compileKotlinTask.destinationDirectory.asFile\n            options.compilerArgumentProviders.add {\n                val kotlinCompileDestinationDir = destinationDirProperty.get()\n                listOf(\"--patch-module\", \"$moduleName=$kotlinCompileDestinationDir\")\n            }\n\n            // Use the classpath of the compileKotlinJvm task.\n            // Also ensure that the module path is used instead of classpath.\n            classpath = compileKotlinTask.libraries\n            modularity.inferModulePath = true\n        }\n\n        tasks.named<Jar>(target.artifactsTaskName) {\n            manifest {\n                attributes(\"Multi-Release\" to true)\n            }\n            from(compileJavaModuleInfo) {\n                // Include **only** file we are interested in as JavaCompile output also contains some tmp files\n                include(\"module-info.class\")\n                into(\"META-INF/versions/9/\")\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/Platform.kt",
        "content": "import org.gradle.api.Project\n\n// Use from Groovy for now\nfun platformOf(project: Project): String =\n    when (project.name.substringAfterLast(\"-\")) {\n        \"js\" -> \"js\"\n        \"common\", \"native\" -> throw IllegalStateException(\"${project.name} platform is not supported\")\n        else -> \"jvm\"\n    }\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/Projects.kt",
        "content": "@file:JvmName(\"Projects\")\n\nimport org.gradle.api.*\nimport org.gradle.api.tasks.*\n\nfun Project.version(target: String): String {\n    if (target == \"kotlin\") {\n        getOverriddenKotlinVersion(this)?.let { return it }\n    }\n    return property(\"${target}_version\") as String\n}\n\nval Project.jdkToolchainVersion: Int get() = property(\"jdk_toolchain_version\").toString().toInt()\n\n/**\n * TODO: check if this is still relevant.\n * It was introduced in <https://github.com/Kotlin/kotlinx.coroutines/pull/2389>, and the project for which this was\n * done is already long finished.\n */\nval Project.nativeTargetsAreEnabled: Boolean get() = rootProject.properties[\"disable_native_targets\"] == null\n\nval Project.sourceSets: SourceSetContainer\n    get() = extensions.getByName(\"sourceSets\") as SourceSetContainer\n\nval coreModule = \"kotlinx-coroutines-core\"\nval jdk8ObsoleteModule = \"kotlinx-coroutines-jdk8\"\nval testUtilsModule = \"test-utils\"\n\n// Not applicable for Kotlin plugin\nval sourceless = setOf(\"kotlinx.coroutines\", \"kotlinx-coroutines-bom\")\n\n// Not published\nval unpublished = setOf(\"kotlinx.coroutines\", \"benchmarks\", \"android-unit-tests\", testUtilsModule)\n\nval Project.isMultiplatform: Boolean get() = name in setOf(coreModule, \"kotlinx-coroutines-test\", testUtilsModule)\nval Project.isBom: Boolean get() = name == \"kotlinx-coroutines-bom\"\n\n// Projects that we do not check for Android API level 14 check due to various limitations\nval androidNonCompatibleProjects = setOf(\n    \"kotlinx-coroutines-debug\",\n    \"kotlinx-coroutines-swing\",\n    \"kotlinx-coroutines-javafx\",\n    \"kotlinx-coroutines-jdk8\",\n    \"kotlinx-coroutines-jdk9\",\n    \"kotlinx-coroutines-reactor\",\n    \"kotlinx-coroutines-test\"\n)\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/Publishing.kt",
        "content": "@file:Suppress(\"UnstableApiUsage\")\n\nimport groovy.util.Node\nimport groovy.util.NodeList\nimport org.gradle.api.Project\nimport org.gradle.api.XmlProvider\nimport org.gradle.api.artifacts.dsl.*\nimport org.gradle.api.publish.PublishingExtension\nimport org.gradle.api.publish.maven.*\nimport org.gradle.api.publish.maven.tasks.AbstractPublishToMaven\nimport org.gradle.api.tasks.*\nimport org.gradle.api.tasks.bundling.Jar\nimport org.gradle.kotlin.dsl.*\nimport org.gradle.plugins.signing.*\nimport java.net.*\n\n// Pom configuration\n\nfun MavenPom.configureMavenCentralMetadata(project: Project) {\n    name = project.name\n    description = \"Coroutines support libraries for Kotlin\"\n    url = \"https://github.com/Kotlin/kotlinx.coroutines\"\n\n    licenses {\n        license {\n            name = \"The Apache Software License, Version 2.0\"\n            url = \"https://www.apache.org/licenses/LICENSE-2.0.txt\"\n            distribution = \"repo\"\n        }\n    }\n\n    developers {\n        developer {\n            id = \"JetBrains\"\n            name = \"JetBrains Team\"\n            organization = \"JetBrains\"\n            organizationUrl = \"https://www.jetbrains.com\"\n        }\n    }\n\n    scm {\n        url = \"https://github.com/Kotlin/kotlinx.coroutines\"\n    }\n}\n\n/**\n * 'libs.space.pub' is a dev option that is set on our CI in order to publish\n * dev build into 'https://maven.pkg.jetbrains.space/public/p/kotlinx-coroutines/maven' Maven repository.\n * In order to use it, pass the corresponding ENV to the TC 'Deploy' task.\n */\nprivate val spacePublicationEnabled = System.getenv(\"libs.space.pub\")?.equals(\"true\") ?: false\n\nfun mavenRepositoryUri(): URI {\n    if (spacePublicationEnabled) {\n        return URI(\"https://maven.pkg.jetbrains.space/public/p/kotlinx-coroutines/maven\")\n    }\n\n    val repositoryId: String? = System.getenv(\"libs.repository.id\")\n    return if (repositoryId == null) {\n        URI(\"https://oss.sonatype.org/service/local/staging/deploy/maven2/\")\n    } else {\n        URI(\"https://oss.sonatype.org/service/local/staging/deployByRepositoryId/$repositoryId\")\n    }\n}\n\nfun configureMavenPublication(rh: RepositoryHandler, project: Project) {\n    rh.maven {\n        url = mavenRepositoryUri()\n        credentials {\n            if (spacePublicationEnabled) {\n                // Configure space credentials\n                username = project.getSensitiveProperty(\"libs.space.user\")\n                password = project.getSensitiveProperty(\"libs.space.password\")\n            } else {\n                // Configure sonatype credentials\n                username = project.getSensitiveProperty(\"libs.sonatype.user\")\n                password = project.getSensitiveProperty(\"libs.sonatype.password\")\n            }\n        }\n    }\n}\n\nfun signPublicationIfKeyPresent(project: Project, publication: MavenPublication) {\n    val keyId = project.getSensitiveProperty(\"libs.sign.key.id\")\n    val signingKey = project.getSensitiveProperty(\"libs.sign.key.private\")\n    val signingKeyPassphrase = project.getSensitiveProperty(\"libs.sign.passphrase\")\n    if (!signingKey.isNullOrBlank()) {\n        project.extensions.configure<SigningExtension>(\"signing\") {\n            useInMemoryPgpKeys(keyId, signingKey, signingKeyPassphrase)\n            sign(publication)\n        }\n    }\n}\n\nprivate fun Project.getSensitiveProperty(name: String): String? {\n    return project.findProperty(name) as? String ?: System.getenv(name)\n}\n\n/**\n * This unbelievable piece of engineering^W programming is a workaround for the following issues:\n * - https://github.com/gradle/gradle/issues/26132\n * - https://youtrack.jetbrains.com/issue/KT-61313/\n *\n * Long story short:\n * 1) Single module produces multiple publications\n * 2) 'Sign' plugin signs them\n * 3) Signature files are re-used, which Gradle detects and whines about an implicit dependency\n *\n * There are three patterns that we workaround:\n * 1) 'Sign' does not depend on 'publish'\n * 2) Empty 'javadoc.jar.asc' got reused between publications (kind of a implication of the previous one)\n * 3) `klib` signatures are reused where appropriate\n *\n * It addresses the following failures:\n * ```\n * Gradle detected a problem with the following location: 'kotlinx.coroutines/kotlinx-coroutines-core/build/classes/kotlin/macosArm64/main/klib/kotlinx-coroutines-core.klib.asc'.\n * Reason: Task ':kotlinx-coroutines-core:linkWorkerTestDebugTestMacosArm64' uses this output of task ':kotlinx-coroutines-core:signMacosArm64Publication' without declaring an explicit or implicit dependency. This can lead to incorrect results being produced, depending on what order the tasks are executed.\n *\n * ```\n * and\n * ```\n * Gradle detected a problem with the following location: 'kotlinx-coroutines-core/build/libs/kotlinx-coroutines-core-1.7.2-SNAPSHOT-javadoc.jar.asc'.\n * Reason: Task ':kotlinx-coroutines-core:publishAndroidNativeArm32PublicationToMavenLocal' uses this output of task ':kotlinx-coroutines-core:signAndroidNativeArm64Publication' without declaring an explicit or implicit dependency.\n * ```\n */\nfun Project.establishSignDependencies() {\n    tasks.withType<Sign>().configureEach {\n        val pubName = name.removePrefix(\"sign\").removeSuffix(\"Publication\")\n        // Gradle#26132 -- establish dependency between sign and link tasks, as well as compile ones\n        mustRunAfter(tasks.matching { it.name == \"linkDebugTest$pubName\" })\n        mustRunAfter(tasks.matching { it.name == \"linkWorkerTestDebugTest$pubName\" })\n        mustRunAfter(tasks.matching { it.name == \"compileTestKotlin$pubName\" })\n    }\n\n    // Sign plugin issues and publication:\n    // Establish dependency between 'sign' and 'publish*' tasks\n    tasks.withType<AbstractPublishToMaven>().configureEach {\n        dependsOn(tasks.withType<Sign>())\n    }\n}\n\n/**\n * Re-configure common publication to depend on JVM artifact only in pom.xml.\n * It allows us to keep backwards compatibility with pre-multiplatform 'kotlinx-coroutines' publication scheme\n * for Maven consumers:\n * - Previously, we published 'kotlinx-coroutines-core' as the JVM artifact\n * - With a multiplatform enabled as is, 'kotlinx-coroutines-core' is a common artifact not consumable from Maven,\n *   instead, users should depend on 'kotlinx-coroutines-core-jvm'\n * - To keep the compatibility and experience, we do add dependency on 'kotlinx-coroutines-core-jvm' for\n *   'kotlinx-coroutines-core' in pom.xml only (e.g. Gradle will keep using the metadata), so Maven users can\n *   depend on previous coordinates.\n *\n * Original code comment:\n *  Publish the platform JAR and POM so that consumers who depend on this module and can't read Gradle module\n *  metadata can still get the platform artifact and transitive dependencies from the POM.\n */\npublic fun Project.reconfigureMultiplatformPublication(jvmPublication: MavenPublication) {\n    val mavenPublications =\n        extensions.getByType(PublishingExtension::class.java).publications.withType<MavenPublication>()\n    val kmpPublication = mavenPublications.getByName(\"kotlinMultiplatform\")\n\n    var jvmPublicationXml: XmlProvider? = null\n    jvmPublication.pom.withXml { jvmPublicationXml = this }\n\n    kmpPublication.pom.withXml {\n        val root = asNode()\n        // Remove the original content and add the content from the platform POM:\n        root.children().toList().forEach { root.remove(it as Node) }\n        jvmPublicationXml!!.asNode().children().forEach { root.append(it as Node) }\n\n        // Adjust the self artifact ID, as it should match the root module's coordinates:\n        ((root[\"artifactId\"] as NodeList).first() as Node).setValue(kmpPublication.artifactId)\n\n        // Set packaging to POM to indicate that there's no artifact:\n        root.appendNode(\"packaging\", \"pom\")\n\n        // Remove the original platform dependencies and add a single dependency on the platform module:\n        val dependencies = (root[\"dependencies\"] as NodeList).first() as Node\n        dependencies.children().toList().forEach { dependencies.remove(it as Node) }\n        dependencies.appendNode(\"dependency\").apply {\n            appendNode(\"groupId\", jvmPublication.groupId)\n            appendNode(\"artifactId\", jvmPublication.artifactId)\n            appendNode(\"version\", jvmPublication.version)\n            appendNode(\"scope\", \"compile\")\n        }\n    }\n\n    // TODO verify if this is still relevant\n    tasks.matching { it.name == \"generatePomFileForKotlinMultiplatformPublication\" }.configureEach {\n        @Suppress(\"DEPRECATION\")\n        dependsOn(tasks[\"generatePomFileFor${jvmPublication.name.capitalize()}Publication\"])\n    }\n}\n\n// Top-level deploy task that publishes all artifacts\npublic fun Project.registerTopLevelDeployTask() {\n    assert(this === rootProject)\n    tasks.register(\"deploy\") {\n        allprojects {\n            val publishTasks = tasks.matching { it.name == \"publish\" }\n            dependsOn(publishTasks)\n        }\n    }\n}\n\npublic fun Project.registerEmptyJavadocArtifact(): TaskProvider<Jar> {\n    return tasks.register(\"javadocJar\", Jar::class) {\n        archiveClassifier = \"javadoc\"\n        // contents are deliberately left empty\n    }\n}\n\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/SourceSets.kt",
        "content": "import org.gradle.api.*\nimport org.jetbrains.kotlin.gradle.plugin.*\nimport org.gradle.kotlin.dsl.*\n\nfun KotlinSourceSet.configureDirectoryPaths() {\n    if (project.isMultiplatform) {\n        val srcDir = if (name.endsWith(\"Main\")) \"src\" else \"test\"\n        val platform = name.dropLast(4)\n        kotlin.srcDir(\"$platform/$srcDir\")\n        if (name == \"jvmMain\") {\n            resources.srcDir(\"$platform/resources\")\n        } else if (name == \"jvmTest\") {\n            resources.srcDir(\"$platform/test-resources\")\n        }\n    } else if (platformOf(project) == \"jvm\") {\n        when (name) {\n            \"main\" -> {\n                kotlin.srcDir(\"src\")\n                resources.srcDir(\"resources\")\n            }\n            \"test\" -> {\n                kotlin.srcDir(\"test\")\n                resources.srcDir(\"test-resources\")\n            }\n        }\n    } else {\n        throw IllegalArgumentException(\"Unclear how to configure source sets for ${project.name}\")\n    }\n}\n\n/**\n * Creates shared source sets for a group of source sets.\n *\n * [reverseDependencies] is a list of prefixes of names of source sets that depend on the new source set.\n * [dependencies] is a list of prefixes of names of source sets that the new source set depends on.\n * [groupName] is the prefix of the names of the new source sets.\n *\n * The suffixes of the source sets are \"Main\" and \"Test\".\n */\nfun NamedDomainObjectContainer<KotlinSourceSet>.groupSourceSets(\n    groupName: String,\n    reverseDependencies: List<String>,\n    dependencies: List<String>\n) {\n    val sourceSetSuffixes = listOf(\"Main\", \"Test\")\n    for (suffix in sourceSetSuffixes) {\n        register(groupName + suffix) {\n            for (dep in dependencies) {\n                dependsOn(get(dep + suffix))\n            }\n            for (revDep in reverseDependencies) {\n                get(revDep + suffix).dependsOn(this)\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/UnpackAar.kt",
        "content": "import org.gradle.api.*\nimport org.gradle.api.artifacts.transform.InputArtifact\nimport org.gradle.api.artifacts.transform.TransformAction\nimport org.gradle.api.artifacts.transform.TransformOutputs\nimport org.gradle.api.artifacts.transform.TransformParameters\nimport org.gradle.api.attributes.*\nimport org.gradle.api.file.FileSystemLocation\nimport org.gradle.api.provider.Provider\nimport org.gradle.kotlin.dsl.*\nimport java.io.File\nimport java.nio.file.Files\nimport java.util.zip.ZipEntry\nimport java.util.zip.ZipFile\n\n// Attributes used by aar dependencies\nval artifactType = Attribute.of(\"artifactType\", String::class.java)\nval unpackedAar = Attribute.of(\"unpackedAar\", Boolean::class.javaObjectType)\n\nfun Project.configureAar() = configurations.configureEach {\n    afterEvaluate {\n        if (isCanBeResolved && !isCanBeConsumed) {\n            attributes.attribute(unpackedAar, true) // request all AARs to be unpacked\n        }\n    }\n}\n\nfun DependencyHandlerScope.configureAarUnpacking() {\n    attributesSchema {\n        attribute(unpackedAar)\n    }\n\n    artifactTypes {\n        create(\"aar\") {\n            attributes.attribute(unpackedAar, false)\n        }\n    }\n\n    registerTransform(UnpackAar::class.java) {\n        from.attribute(unpackedAar, false).attribute(artifactType, \"aar\")\n        to.attribute(unpackedAar, true).attribute(artifactType, \"jar\")\n    }\n}\n\n@Suppress(\"UnstableApiUsage\")\nabstract class UnpackAar : TransformAction<TransformParameters.None> {\n    @get:InputArtifact\n    abstract val inputArtifact: Provider<FileSystemLocation>\n\n    override fun transform(outputs: TransformOutputs) {\n        ZipFile(inputArtifact.get().asFile).use { zip ->\n            zip.entries().asSequence()\n                .filter { !it.isDirectory }\n                .filter { it.name.endsWith(\".jar\") }\n                .forEach { zip.unzip(it, outputs.file(it.name)) }\n        }\n    }\n}\n\nprivate fun ZipFile.unzip(entry: ZipEntry, output: File) {\n    getInputStream(entry).use {\n        Files.copy(it, output.toPath())\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/VersionFile.kt",
        "content": "import org.gradle.api.*\nimport org.gradle.api.tasks.*\n\n/**\n * Adds 'module_name.version' file to the project's JAR META-INF\n * for the better toolability. See #2941\n */\nobject VersionFile {\n    fun registerVersionFileTask(project: Project): TaskProvider<Task> {\n        val versionFile = project.layout.buildDirectory.file(\"${project.name.replace('-', '_')}.version\")\n        val version = project.version.toString()\n        return project.tasks.register(\"versionFileTask\") {\n            outputs.file(versionFile)\n            doLast {\n                versionFile.get().asFile.writeText(version)\n            }\n        }\n    }\n\n    fun fromVersionFile(target: AbstractCopyTask, versionFileTask: TaskProvider<Task>) {\n        target.from(versionFileTask) {\n            into(\"META-INF\")\n        }\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/animalsniffer-conventions.gradle.kts",
        "content": "import ru.vyarus.gradle.plugin.animalsniffer.*\n\nconfigure(subprojects) {\n    // Skip JDK 8 projects or unpublished ones\n    if (!shouldSniff()) return@configure\n    apply(plugin = \"ru.vyarus.animalsniffer\")\n    project.plugins.withType(JavaPlugin::class.java) {\n        configure<AnimalSnifferExtension> {\n            sourceSets = listOf((project.extensions.getByName(\"sourceSets\") as SourceSetContainer).getByName(\"main\"))\n        }\n        val signature: Configuration by configurations\n        dependencies {\n            signature(\"net.sf.androidscents.signature:android-api-level-14:4.0_r4@signature\")\n            signature(\"org.codehaus.mojo.signature:java17:1.0@signature\")\n        }\n\n        if (project.name == coreModule) {\n            // Specific files so nothing from core is accidentally skipped\n            tasks.withType<AnimalSniffer>().configureEach {\n                exclude(\"**/future/FutureKt*\")\n                exclude(\"**/future/ContinuationHandler*\")\n                exclude(\"**/future/CompletableFutureCoroutine*\")\n\n                exclude(\"**/stream/StreamKt*\")\n                exclude(\"**/stream/StreamFlow*\")\n\n                exclude(\"**/time/TimeKt*\")\n            }\n        }\n    }\n}\n\nfun Project.shouldSniff(): Boolean {\n    // Skip all non-JVM projects\n    if (platformOf(project) != \"jvm\") return false\n    val name = project.name\n    if (name in unpublished || name in sourceless || name in androidNonCompatibleProjects) return false\n    return true\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/bom-conventions.gradle.kts",
        "content": "import org.gradle.kotlin.dsl.*\nimport org.jetbrains.kotlin.gradle.dsl.*\n\n\nconfigure(subprojects.filter { it.name !in unpublished }) {\n    if (name == \"kotlinx-coroutines-bom\" || name == \"kotlinx.coroutines\") return@configure\n    if (isMultiplatform) {\n        kotlinExtension.sourceSets.getByName(\"jvmMain\").dependencies {\n            api(project.dependencies.platform(project(\":kotlinx-coroutines-bom\")))\n        }\n    } else {\n        dependencies {\n            \"api\"(platform(project(\":kotlinx-coroutines-bom\")))\n        }\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/configure-compilation-conventions.gradle.kts",
        "content": "import org.jetbrains.kotlin.gradle.dsl.*\nimport org.jetbrains.kotlin.gradle.dsl.KotlinCompile\nimport org.jetbrains.kotlin.gradle.tasks.*\nimport org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile\n\nconfigure(subprojects) {\n    val project = this\n    if (name in sourceless) return@configure\n    apply(plugin = \"kotlinx-atomicfu\")\n    tasks.withType<KotlinCompilationTask<*>>().configureEach {\n        val isMainTaskName = name.startsWith(\"compileKotlin\")\n        compilerOptions {\n            var versionsAreNotOverridden = true\n            getOverriddenKotlinLanguageVersion(project)?.let {\n                languageVersion = it\n                versionsAreNotOverridden = false\n            }\n            getOverriddenKotlinApiVersion(project)?.let {\n                apiVersion = it\n                versionsAreNotOverridden = false\n            }\n            if (isMainTaskName && versionsAreNotOverridden && !unpublished.contains(project.name)) {\n                allWarningsAsErrors = true\n                freeCompilerArgs.add(\"-Xexplicit-api=strict\")\n            }\n            /* Coroutines do not interop with Java and these flags provide a significant\n             * (i.e. close to double-digit) reduction in both bytecode and optimized dex size */\n            if (this@configureEach is KotlinJvmCompile) {\n                freeCompilerArgs.addAll(\n                    \"-Xno-param-assertions\",\n                    \"-Xno-call-assertions\",\n                    \"-Xno-receiver-assertions\"\n                )\n            }\n            if (this@configureEach is KotlinNativeCompile) {\n                optIn.addAll(\n                    \"kotlinx.cinterop.ExperimentalForeignApi\",\n                    \"kotlinx.cinterop.UnsafeNumber\",\n                    \"kotlin.experimental.ExperimentalNativeApi\",\n                )\n            }\n            freeCompilerArgs.addAll(\"-progressive\", \"-Xexpect-actual-classes\")\n            optIn.addAll(\n                \"kotlin.experimental.ExperimentalTypeInference\",\n                \"kotlin.ExperimentalMultiplatform\",\n                // our own opt-ins that we don't want to bother with in our own code:\n                \"kotlinx.coroutines.DelicateCoroutinesApi\",\n                \"kotlinx.coroutines.ExperimentalCoroutinesApi\",\n                \"kotlinx.coroutines.ObsoleteCoroutinesApi\",\n                \"kotlinx.coroutines.InternalCoroutinesApi\",\n                \"kotlinx.coroutines.FlowPreview\"\n            )\n        }\n\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/dokka-conventions.gradle.kts",
        "content": "import org.jetbrains.dokka.gradle.*\nimport java.net.*\n\n\nplugins {\n    id(\"org.jetbrains.dokka\")\n}\n\nval knit_version: String by project\nprivate val projetsWithoutDokka = unpublished + \"kotlinx-coroutines-bom\" + jdk8ObsoleteModule\nprivate val coreModuleDocsUrl = \"https://kotlinlang.org/api/kotlinx.coroutines/$coreModule/\"\nprivate val coreModuleDocsPackageList = \"$projectDir/kotlinx-coroutines-core/build/dokka/htmlPartial/package-list\"\n\nconfigure(subprojects.filterNot { projetsWithoutDokka.contains(it.name) }) {\n    apply(plugin = \"org.jetbrains.dokka\")\n    configurePathsaver()\n    condigureDokkaSetup()\n    configureExternalLinks()\n}\n\n// Setup top-level 'dokkaHtmlMultiModule' with templates\ntasks.withType<DokkaMultiModuleTask>().named(\"dokkaHtmlMultiModule\") {\n    setupDokkaTemplatesDir(this)\n}\n\ndependencies {\n    // Add explicit dependency between Dokka and Knit plugin\n    add(\"dokkaHtmlMultiModulePlugin\", \"org.jetbrains.kotlinx:dokka-pathsaver-plugin:$knit_version\")\n}\n\n// Dependencies for Knit processing: Knit plugin to work with Dokka\nprivate fun Project.configurePathsaver() {\n    tasks.withType(DokkaTaskPartial::class).configureEach {\n        dependencies {\n            plugins(\"org.jetbrains.kotlinx:dokka-pathsaver-plugin:$knit_version\")\n        }\n    }\n}\n\n// Configure Dokka setup\nprivate fun Project.condigureDokkaSetup() {\n    tasks.withType(DokkaTaskPartial::class).configureEach {\n        suppressInheritedMembers = true\n        setupDokkaTemplatesDir(this)\n\n        dokkaSourceSets.configureEach {\n            jdkVersion = 11\n            includes.from(\"README.md\")\n            noStdlibLink = true\n\n            externalDocumentationLink {\n                url = URL(\"https://kotlinlang.org/api/latest/jvm/stdlib/\")\n                packageListUrl = rootProject.projectDir.toPath().resolve(\"site/stdlib.package.list\").toUri().toURL()\n            }\n\n            // Something suspicious to figure out, probably legacy of earlier days\n            if (!project.isMultiplatform) {\n                dependsOn(project.configurations[\"compileClasspath\"])\n            }\n        }\n\n        // Source links\n        dokkaSourceSets.configureEach {\n            sourceLink {\n                localDirectory = rootDir\n                remoteUrl = URL(\"https://github.com/kotlin/kotlinx.coroutines/tree/master\")\n                remoteLineSuffix =\"#L\"\n            }\n        }\n    }\n}\n\nprivate fun Project.configureExternalLinks() {\n    tasks.withType<DokkaTaskPartial>() {\n        dokkaSourceSets.configureEach {\n            externalDocumentationLink {\n                url = URL(coreModuleDocsUrl)\n                packageListUrl = File(coreModuleDocsPackageList).toURI().toURL()\n            }\n        }\n    }\n}\n\n/**\n * Setups Dokka templates. While this directory is empty in our repository,\n * 'kotlinlang' build pipeline adds templates there when preparing our documentation\n * to be published on kotlinlang.\n *\n * See:\n * - Template setup: https://github.com/JetBrains/kotlin-web-site/blob/master/.teamcity/builds/apiReferences/kotlinx/coroutines/KotlinxCoroutinesPrepareDokkaTemplates.kt\n * - Templates repository: https://github.com/JetBrains/kotlin-web-site/tree/master/dokka-templates\n */\nprivate fun Project.setupDokkaTemplatesDir(dokkaTask: AbstractDokkaTask) {\n    dokkaTask.pluginsMapConfiguration = mapOf(\n        \"org.jetbrains.dokka.base.DokkaBase\" to \"\"\"{ \"templatesDir\" : \"${\n            project.rootProject.projectDir.toString().replace('\\\\', '/')\n        }/dokka-templates\" }\"\"\"\n    )\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/java-modularity-conventions.gradle.kts",
        "content": "// Currently the compilation of the module-info fails for\n// kotlinx-coroutines-play-services because it depends on Android JAR's\n// which do not have an explicit module-info descriptor.\n// Because the JAR's are all named `classes.jar`,\n// the automatic module name also becomes `classes`.\n// This conflicts since there are multiple JAR's with identical names.\nval invalidModules = listOf(\"kotlinx-coroutines-play-services\")\n\nconfigure(subprojects.filter {\n    !unpublished.contains(it.name) && !invalidModules.contains(it.name) && it.extensions.findByName(\"kotlin\") != null\n}) {\n    Java9Modularity.configure(project)\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/knit-conventions.gradle.kts",
        "content": "plugins {\n    id(\"kotlinx-knit\")\n}\n\nknit {\n    siteRoot = \"https://kotlinlang.org/api/kotlinx.coroutines\"\n    moduleRoots = listOf(\".\", \"integration\", \"reactive\", \"ui\")\n    moduleDocs = \"build/dokka/htmlPartial\"\n    dokkaMultiModuleRoot = \"build/dokka/htmlMultiModule/\"\n}\n\ntasks.named(\"knitPrepare\").configure {\n    val knitTask = this\n    // In order for knit to operate, it should depend on and collect\n    // all Dokka outputs from each module\n    allprojects {\n        val dokkaTasks = tasks.matching { it.name == \"dokkaHtmlMultiModule\" }\n        knitTask.dependsOn(dokkaTasks)\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/kotlin-jvm-conventions.gradle.kts",
        "content": "// Platform-specific configuration to compile JVM modules\n\nimport org.gradle.api.*\nimport org.jetbrains.kotlin.gradle.dsl.*\n\nplugins {\n    kotlin(\"jvm\")\n}\n\njava {\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n}\n\nkotlin {\n    compilerOptions {\n        jvmTarget = JvmTarget.JVM_1_8\n    }\n    jvmToolchain(jdkToolchainVersion)\n}\n\ndependencies {\n    testImplementation(kotlin(\"test\"))\n    // Workaround to make addSuppressed work in tests\n    testImplementation(kotlin(\"reflect\"))\n    testImplementation(kotlin(\"stdlib-jdk7\"))\n    testImplementation(kotlin(\"test-junit\"))\n    testImplementation(\"junit:junit:${version(\"junit\")}\")\n}\n\ntasks.withType<Test> {\n    testLogging {\n        showStandardStreams = true\n        events(\"passed\", \"failed\")\n    }\n    val stressTest = project.properties[\"stressTest\"]\n    if (stressTest != null) systemProperties[\"stressTest\"] = stressTest\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/kotlin-multiplatform-conventions.gradle.kts",
        "content": "import org.gradle.api.*\nimport org.gradle.api.tasks.testing.logging.*\nimport org.jetbrains.kotlin.gradle.dsl.*\n\nplugins {\n    kotlin(\"multiplatform\")\n}\n\njava {\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n}\n\nkotlin {\n    jvm {\n        compilations.all {\n            compilerOptions.configure {\n                jvmTarget = JvmTarget.JVM_1_8\n            }\n        }\n    }\n    jvmToolchain(jdkToolchainVersion)\n    if (nativeTargetsAreEnabled) {\n        // According to https://kotlinlang.org/docs/native-target-support.html\n        // Tier 1\n        linuxX64()\n        macosX64()\n        macosArm64()\n        iosSimulatorArm64()\n        iosX64()\n        // Tier 2\n        linuxArm64()\n        watchosSimulatorArm64()\n        watchosX64()\n        watchosArm32()\n        watchosArm64()\n        tvosSimulatorArm64()\n        tvosX64()\n        tvosArm64()\n        iosArm64()\n        // Tier 3\n        androidNativeArm32()\n        androidNativeArm64()\n        androidNativeX86()\n        androidNativeX64()\n        mingwX64()\n        watchosDeviceArm64()\n    }\n    js {\n        moduleName = project.name\n        nodejs()\n        compilations[\"main\"]?.dependencies {\n            api(\"org.jetbrains.kotlinx:atomicfu-js:${version(\"atomicfu\")}\")\n        }\n    }\n    @OptIn(org.jetbrains.kotlin.gradle.targets.js.dsl.ExperimentalWasmDsl::class)\n    wasmJs {\n        // Module name should be different from the one from JS\n        // otherwise IC tasks that start clashing different modules with the same module name\n        moduleName = project.name + \"Wasm\"\n        nodejs()\n        compilations[\"main\"]?.dependencies {\n            api(\"org.jetbrains.kotlinx:atomicfu-wasm-js:${version(\"atomicfu\")}\")\n        }\n    }\n    applyDefaultHierarchyTemplate()\n    sourceSets {\n        commonTest {\n            dependencies {\n                api(\"org.jetbrains.kotlin:kotlin-test-common:${version(\"kotlin\")}\")\n                api(\"org.jetbrains.kotlin:kotlin-test-annotations-common:${version(\"kotlin\")}\")\n            }\n        }\n        jvmMain.dependencies {\n            compileOnly(\"org.codehaus.mojo:animal-sniffer-annotations:1.20\")\n            // Workaround until https://github.com/JetBrains/kotlin/pull/4999 is picked up\n            api(\"org.jetbrains:annotations:23.0.0\")\n        }\n        jvmTest.dependencies {\n            api(\"org.jetbrains.kotlin:kotlin-test:${version(\"kotlin\")}\")\n            // Workaround to make addSuppressed work in tests\n            api(\"org.jetbrains.kotlin:kotlin-reflect:${version(\"kotlin\")}\")\n            api(\"org.jetbrains.kotlin:kotlin-stdlib-jdk7:${version(\"kotlin\")}\")\n            api(\"org.jetbrains.kotlin:kotlin-test-junit:${version(\"kotlin\")}\")\n            api(\"junit:junit:${version(\"junit\")}\")\n        }\n        nativeMain.dependencies {\n            // workaround for #3968 until this is fixed on atomicfu's side\n            api(\"org.jetbrains.kotlinx:atomicfu:0.23.1\")\n        }\n        jsMain { }\n        jsTest {\n            dependencies {\n                api(\"org.jetbrains.kotlin:kotlin-test-js:${version(\"kotlin\")}\")\n            }\n        }\n        val wasmJsMain by getting {\n        }\n        val wasmJsTest by getting {\n            dependencies {\n                api(\"org.jetbrains.kotlin:kotlin-test-wasm-js:${version(\"kotlin\")}\")\n            }\n        }\n        groupSourceSets(\"jsAndWasmShared\", listOf(\"js\", \"wasmJs\"), listOf(\"common\"))\n    }\n}\n\n// Disable intermediate sourceSet compilation because we do not need js-wasmJs artifact\ntasks.configureEach {\n    if (name == \"compileJsAndWasmSharedMainKotlinMetadata\") {\n        enabled = false\n    }\n}\n\ntasks.named(\"jvmTest\", Test::class) {\n    testLogging {\n        showStandardStreams = true\n        events = setOf(TestLogEvent.PASSED, TestLogEvent.FAILED)\n    }\n    project.properties[\"stressTest\"]?.let { systemProperty(\"stressTest\", it) }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/kover-conventions.gradle.kts",
        "content": "import kotlinx.kover.gradle.plugin.dsl.*\n\nplugins {\n    id(\"org.jetbrains.kotlinx.kover\")\n}\n\nval notCovered = sourceless + unpublished\n\nval expectedCoverage = mutableMapOf(\n    // These have lower coverage in general, it can be eventually fixed\n    \"kotlinx-coroutines-swing\" to 70, // awaitFrame is not tested\n    \"kotlinx-coroutines-javafx\" to 35, // JavaFx is not tested on TC because its graphic subsystem cannot be initialized in headless mode\n\n    // Reactor has lower coverage in general due to various fatal error handling features\n    \"kotlinx-coroutines-reactor\" to 75\n)\n\nval conventionProject = project\n\nsubprojects {\n    val projectName = name\n    if (projectName in notCovered) return@subprojects\n\n    project.apply(plugin = \"org.jetbrains.kotlinx.kover\")\n    conventionProject.dependencies.add(\"kover\", this)\n\n    extensions.configure<KoverProjectExtension>(\"kover\") {\n        /*\n        * Is explicitly enabled on TC in a separate build step.\n        * Examples:\n        * ./gradlew :p:check -- doesn't verify coverage\n        * ./gradlew :p:check -Pkover.enabled=true -- verifies coverage\n        * ./gradlew :p:koverHtmlReport -Pkover.enabled=true -- generates HTML report\n        */\n        if (properties[\"kover.enabled\"]?.toString()?.toBoolean() != true) {\n            disable()\n        }\n    }\n\n    extensions.configure<KoverProjectExtension>(\"kover\") {\n        reports {\n            total {\n                html {\n                    htmlDir = conventionProject.layout.buildDirectory.dir(\"kover/${project.name}/html\")\n                }\n\n                verify {\n                    rule {\n                        /*\n                        * 85 is our baseline that we aim to raise to 90+.\n                        * Missing coverage is typically due to bugs in the agent\n                        * (e.g. signatures deprecated with an error are counted),\n                        * sometimes it's various diagnostic `toString` or `catch` for OOMs/VerificationErrors,\n                        * but some places are definitely worth visiting.\n                        */\n                        minBound(expectedCoverage[projectName] ?: 85) // COVERED_LINES_PERCENTAGE\n                    }\n                }\n            }\n        }\n    }\n}\n\nkover {\n    reports {\n        total {\n            verify {\n                rule {\n                    minBound(85) // COVERED_LINES_PERCENTAGE\n                }\n            }\n        }\n    }\n}\n\nconventionProject.tasks.register(\"koverReport\") {\n    dependsOn(conventionProject.tasks.named(\"koverHtmlReport\"))\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/pub-conventions.gradle.kts",
        "content": "import org.gradle.kotlin.dsl.*\n\n/*\n * For some absolutely cursed reason the name 'publication-conventions' doesn't work in my IDE.\n * TODO: recheck after full repair\n */\nplugins {\n    id(\"maven-publish\")\n    id(\"signing\")\n}\n\napply(plugin = \"maven-publish\")\napply(plugin = \"signing\")\n\npublishing {\n    repositories {\n        configureMavenPublication(this, project)\n    }\n\n    if (!isMultiplatform && !isBom) {\n        // Configure java publications for regular non-MPP modules\n        apply(plugin = \"java-library\")\n\n        // MPP projects pack their sources automatically, java libraries need to explicitly pack them\n        val sources = tasks.register(\"sourcesJar\", Jar::class) {\n            archiveClassifier = \"sources\"\n            from(sourceSets.named(\"main\").get().allSource)\n        }\n\n        publications {\n            register(\"mavenJava\", MavenPublication::class) {\n                from(components[\"java\"])\n                artifact(sources)\n            }\n        }\n    }\n\n    val emptyJavadoc = if (!isBom) registerEmptyJavadocArtifact() else null\n    publications.withType(MavenPublication::class).all {\n        pom.configureMavenCentralMetadata(project)\n        signPublicationIfKeyPresent(project, this)\n        if (!isBom && name != \"kotlinMultiplatform\") {\n            artifact(emptyJavadoc)\n        }\n\n        val type = name\n        when (type) {\n            \"kotlinMultiplatform\" -> {\n                // With Kotlin 1.4 & HMPP, the root module should have no suffix in the ID, but for compatibility with\n                // the consumers who can't read Gradle module metadata, we publish the JVM artifacts in it, too\n                artifactId = project.name\n                project.reconfigureMultiplatformPublication(publications.getByName(\"jvm\") as MavenPublication)\n            }\n\n            \"metadata\", \"jvm\", \"js\", \"native\" -> {\n                artifactId = \"${project.name}-$type\"\n            }\n        }\n    }\n\n    project.establishSignDependencies()\n}\n\n\n// Legacy from https://github.com/Kotlin/kotlinx.coroutines/pull/2031\n// Should be fixed with the rest of the hacks around publication\ntasks.matching { it.name == \"generatePomFileForKotlinMultiplatformPublication\" }.configureEach {\n    dependsOn(tasks.matching { it.name == \"generatePomFileForJvmPublication\" })\n}\n\n// Compatibility with old TeamCity configurations that perform :kotlinx-coroutines-core:bintrayUpload\ntasks.register(\"bintrayUpload\") { dependsOn(tasks.matching { it.name == \"publish\" }) }\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/source-set-conventions.gradle.kts",
        "content": "import org.jetbrains.kotlin.gradle.dsl.*\n\n// Redefine source sets because we are not using 'kotlin/main/fqn' folder convention\n// TODO: port benchmarks to the same scheme\nconfigure(subprojects.filter { !sourceless.contains(it.name) && it.name != \"benchmarks\" }) {\n    kotlinExtension.sourceSets.forEach {\n        it.configureDirectoryPaths()\n    }\n}\n"
    },
    {
        "path": "buildSrc/src/main/kotlin/version-file-conventions.gradle.kts",
        "content": "import org.gradle.api.tasks.bundling.*\n\nconfigure(subprojects.filter { !unpublished.contains(it.name) && it.name !in sourceless }) {\n    val project = this\n    val jarTaskName = when {\n        project.name == \"kotlinx-coroutines-debug\" -> {\n            project.apply(plugin = \"com.github.johnrengelman.shadow\")\n            \"shadowJar\"\n        }\n        isMultiplatform -> \"jvmJar\"\n        else -> \"jar\"\n    }\n    val versionFileTask = VersionFile.registerVersionFileTask(project)\n    tasks.withType(Jar::class.java).named(jarTaskName) {\n        VersionFile.fromVersionFile(this, versionFileTask)\n    }\n}\n"
    },
    {
        "path": "integration-testing/smokeTest/src/commonMain/kotlin/Sample.kt",
        "content": "import kotlinx.coroutines.*\n\nsuspend fun doWorld() = coroutineScope {\n    launch {\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello\")\n}\n"
    },
    {
        "path": "integration-testing/smokeTest/src/commonTest/kotlin/SampleTest.kt",
        "content": "import kotlinx.coroutines.test.*\nimport kotlin.test.*\n\nclass SampleTest {\n    @Test\n    fun test() = runTest {\n        doWorld()\n    }\n}\n"
    },
    {
        "path": "integration-testing/src/coreAgentTest/kotlin/CoreAgentTest.kt",
        "content": "import org.junit.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\nimport org.junit.Test\nimport java.io.*\n\nclass CoreAgentTest {\n\n    @Test\n    fun testAgentDumpsCoroutines() = runBlocking {\n        val baos = ByteArrayOutputStream()\n        @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n        DebugProbesImpl.dumpCoroutines(PrintStream(baos))\n        // if the agent works, then dumps should contain something,\n        // at least the fact that this test is running.\n        Assert.assertTrue(baos.toString().contains(\"testAgentDumpsCoroutines\"))\n    }\n\n}\n"
    },
    {
        "path": "integration-testing/src/debugAgentTest/kotlin/DebugAgentTest.kt",
        "content": "import org.junit.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.*\nimport org.junit.Test\nimport java.io.*\n\nclass DebugAgentTest {\n\n    @Test\n    fun testAgentDumpsCoroutines() = runBlocking {\n        val baos = ByteArrayOutputStream()\n        DebugProbes.dumpCoroutines(PrintStream(baos))\n        // if the agent works, then dumps should contain something,\n        // at least the fact that this test is running.\n        Assert.assertTrue(baos.toString().contains(\"testAgentDumpsCoroutines\"))\n    }\n\n}\n"
    },
    {
        "path": "integration-testing/src/debugAgentTest/kotlin/DebugProbes.kt",
        "content": "@file:Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npackage kotlin.coroutines.jvm.internal\n\nimport kotlinx.coroutines.debug.internal.*\nimport kotlin.coroutines.*\n\ninternal fun <T> probeCoroutineCreated(completion: Continuation<T>): Continuation<T> = DebugProbesImpl.probeCoroutineCreated(completion)\n\ninternal fun probeCoroutineResumed(frame: Continuation<*>) = DebugProbesImpl.probeCoroutineResumed(frame)\n\ninternal fun probeCoroutineSuspended(frame: Continuation<*>) = DebugProbesImpl.probeCoroutineSuspended(frame)\n"
    },
    {
        "path": "integration-testing/src/debugAgentTest/kotlin/PrecompiledDebugProbesTest.kt",
        "content": "import org.junit.Test\nimport java.io.*\nimport kotlin.test.*\n\n/*\n * This is intentionally put here instead of coreAgentTest to avoid accidental classpath replacing\n * and ruining core agent test.\n */\nclass PrecompiledDebugProbesTest {\n\n    private val overwrite = java.lang.Boolean.getBoolean(\"overwrite.probes\")\n\n    @Test\n    fun testClassFileContent() {\n        val clz = Class.forName(\"kotlin.coroutines.jvm.internal.DebugProbesKt\")\n        val classFileResourcePath = clz.name.replace(\".\", \"/\") + \".class\"\n        val array = clz.classLoader.getResourceAsStream(classFileResourcePath).use { it.readBytes() }\n        assertJava8Compliance(array)\n        // we expect the integration testing project to be in a subdirectory of the main kotlinx.coroutines project\n        val base = File(\"\").absoluteFile.parentFile\n        val probes = File(base, \"kotlinx-coroutines-core/jvm/resources/DebugProbesKt.bin\")\n        val binContent = probes.readBytes()\n        if (overwrite) {\n            FileOutputStream(probes).use { it.write(array) }\n            println(\"Content was successfully overwritten!\")\n        } else {\n            assertTrue(\n                array.contentEquals(binContent),\n                \"Compiled DebugProbesKt.class does not match the file shipped as a resource in kotlinx-coroutines-core. \" +\n                        \"Typically it happens because of the Kotlin version update (-> binary metadata). \" +\n                        \"In that case, run the same test with -Poverwrite.probes=true.\"\n            )\n        }\n    }\n\n    private fun assertJava8Compliance(classBytes: ByteArray) {\n        DataInputStream(classBytes.inputStream()).use {\n            val magic: Int = it.readInt()\n            if (magic != -0x35014542) throw IllegalArgumentException(\"Not a valid class!\")\n            val minor: Int = it.readUnsignedShort()\n            val major: Int = it.readUnsignedShort()\n            assertEquals(52, major)\n            assertEquals(0, minor)\n        }\n    }\n}\n"
    },
    {
        "path": "integration-testing/src/debugDynamicAgentTest/kotlin/DynamicAttachDebugTest.kt",
        "content": "import org.junit.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.*\nimport org.junit.Test\nimport java.io.*\nimport java.lang.IllegalStateException\n\nclass DynamicAttachDebugTest {\n\n    @Test\n    fun testAgentDumpsCoroutines() =\n        DebugProbes.withDebugProbes {\n            runBlocking {\n                val baos = ByteArrayOutputStream()\n                DebugProbes.dumpCoroutines(PrintStream(baos))\n                // if the agent works, then dumps should contain something,\n                // at least the fact that this test is running.\n                Assert.assertTrue(baos.toString().contains(\"testAgentDumpsCoroutines\"))\n            }\n        }\n\n    @Test(expected = IllegalStateException::class)\n    fun testAgentIsNotInstalled() {\n        DebugProbes.dumpCoroutines(PrintStream(ByteArrayOutputStream()))\n    }\n}\n"
    },
    {
        "path": "integration-testing/src/jvmCoreTest/kotlin/Jdk8InCoreIntegration.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.future.*\nimport org.junit.Test\nimport kotlin.test.*\n\n/*\n * Integration test that ensures signatures from both the jdk8 and the core source sets of the kotlinx-coroutines-core subproject are used.\n */\nclass Jdk8InCoreIntegration {\n\n    @Test\n    fun testFuture() = runBlocking<Unit> {\n        val future = future { yield(); 42 }\n        future.whenComplete { r, _ -> assertEquals(42, r)  }\n        assertEquals(42, future.await())\n    }\n}\n"
    },
    {
        "path": "integration-testing/src/jvmCoreTest/kotlin/ListAllCoroutineThrowableSubclassesTest.kt",
        "content": "package kotlinx.coroutines\n\nimport com.google.common.reflect.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.io.Serializable\nimport java.lang.reflect.Modifier\nimport kotlin.test.*\n\nclass ListAllCoroutineThrowableSubclassesTest {\n\n    /*\n     * These are all the known throwables in kotlinx.coroutines.\n     * If you add one, this test will fail to make\n     * you ensure your exception type is java.io.Serializable.\n     *\n     * We do not have means to check it automatically, so checks are delegated to humans.\n     *\n     * See #3328 for serialization rationale.\n     */\n    private val knownThrowables = setOf(\n        \"kotlinx.coroutines.TimeoutCancellationException\",\n        \"kotlinx.coroutines.JobCancellationException\",\n        \"kotlinx.coroutines.internal.UndeliveredElementException\",\n        \"kotlinx.coroutines.CompletionHandlerException\",\n        \"kotlinx.coroutines.internal.DiagnosticCoroutineContextException\",\n        \"kotlinx.coroutines.internal.ExceptionSuccessfullyProcessed\",\n        \"kotlinx.coroutines.CoroutinesInternalError\",\n        \"kotlinx.coroutines.channels.ClosedSendChannelException\",\n        \"kotlinx.coroutines.channels.ClosedReceiveChannelException\",\n        \"kotlinx.coroutines.flow.internal.ChildCancelledException\",\n        \"kotlinx.coroutines.flow.internal.AbortFlowException\",\n    )\n\n    @Test\n    fun testThrowableSubclassesAreSerializable() {\n        val classes = ClassPath.from(this.javaClass.classLoader)\n            .getTopLevelClassesRecursive(\"kotlinx.coroutines\");\n        val throwables = classes.filter { Throwable::class.java.isAssignableFrom(it.load()) }.map { it.toString() }\n        for (throwable in throwables) {\n            for (field in throwable.javaClass.declaredFields) {\n                if (Modifier.isStatic(field.modifiers)) continue\n                val type = field.type\n                assertTrue(type.isPrimitive || Serializable::class.java.isAssignableFrom(type),\n                    \"Throwable $throwable has non-serializable field $field\")\n            }\n        }\n        assertEquals(knownThrowables.sorted(), throwables.sorted())\n    }\n}\n"
    },
    {
        "path": "integration-testing/src/mavenTest/kotlin/MavenPublicationAtomicfuValidator.kt",
        "content": "package kotlinx.coroutines.validator\n\nimport org.junit.Test\nimport org.objectweb.asm.*\nimport org.objectweb.asm.ClassReader.*\nimport org.objectweb.asm.ClassWriter.*\nimport org.objectweb.asm.Opcodes.*\nimport java.util.jar.*\nimport kotlin.test.*\n\nclass MavenPublicationAtomicfuValidator {\n    private val ATOMIC_FU_REF = \"Lkotlinx/atomicfu/\".toByteArray()\n    private val KOTLIN_METADATA_DESC = \"Lkotlin/Metadata;\"\n\n    @Test\n    fun testNoAtomicfuInClasspath() {\n        val result = runCatching { Class.forName(\"kotlinx.atomicfu.AtomicInt\") }\n        assertTrue(result.exceptionOrNull() is ClassNotFoundException)\n    }\n\n    @Test\n    fun testNoAtomicfuInMppJar() {\n        val clazz = Class.forName(\"kotlinx.coroutines.Job\")\n        JarFile(clazz.protectionDomain.codeSource.location.file).checkForAtomicFu()\n    }\n\n    @Test\n    fun testNoAtomicfuInAndroidJar() {\n        val clazz = Class.forName(\"kotlinx.coroutines.android.HandlerDispatcher\")\n        JarFile(clazz.protectionDomain.codeSource.location.file).checkForAtomicFu()\n    }\n\n    private fun JarFile.checkForAtomicFu() {\n        val foundClasses = mutableListOf<String>()\n        for (e in entries()) {\n            if (!e.name.endsWith(\".class\")) continue\n            val bytes = getInputStream(e).use { it.readBytes() }\n            // The atomicfu compiler plugin does not remove atomic properties from metadata,\n            // so for now we check that there are no ATOMIC_FU_REF left in the class bytecode excluding metadata.\n            // This may be reverted after the fix in the compiler plugin transformer (for Kotlin 1.8.0).\n            val outBytes = bytes.eraseMetadata()\n            if (outBytes.checkBytes()) {\n                foundClasses += e.name // report error at the end with all class names\n            }\n        }\n        if (foundClasses.isNotEmpty()) {\n            error(\"Found references to atomicfu in jar file $name in the following class files: ${\n                foundClasses.joinToString(\"\") { \"\\n\\t\\t\" + it }\n            }\")\n        }\n        close()\n    }\n\n    private fun ByteArray.checkBytes(): Boolean {\n        loop@for (i in 0 until this.size - ATOMIC_FU_REF.size) {\n            for (j in 0 until ATOMIC_FU_REF.size) {\n                if (this[i + j] != ATOMIC_FU_REF[j]) continue@loop\n            }\n            return true\n        }\n        return false\n    }\n\n    private fun ByteArray.eraseMetadata(): ByteArray {\n        val cw = ClassWriter(COMPUTE_MAXS or COMPUTE_FRAMES)\n        ClassReader(this).accept(object : ClassVisitor(ASM9, cw) {\n            override fun visitAnnotation(descriptor: String?, visible: Boolean): AnnotationVisitor? {\n                return if (descriptor == KOTLIN_METADATA_DESC) null else super.visitAnnotation(descriptor, visible)\n            }\n        }, SKIP_FRAMES)\n        return cw.toByteArray()\n    }\n}\n"
    },
    {
        "path": "integration-testing/src/mavenTest/kotlin/MavenPublicationMetaInfValidator.kt",
        "content": "package kotlinx.coroutines.validator\n\nimport org.junit.Test\nimport org.objectweb.asm.*\nimport org.objectweb.asm.ClassReader.*\nimport org.objectweb.asm.ClassWriter.*\nimport org.objectweb.asm.Opcodes.*\nimport java.util.jar.*\nimport kotlin.test.*\n\nclass MavenPublicationMetaInfValidator {\n\n    @Test\n    fun testMetaInfCoreStructure() {\n        val clazz = Class.forName(\"kotlinx.coroutines.Job\")\n        JarFile(clazz.protectionDomain.codeSource.location.file).checkMetaInfStructure(\n            setOf(\n                \"MANIFEST.MF\",\n                \"kotlinx-coroutines-core.kotlin_module\",\n                \"com.android.tools/proguard/coroutines.pro\",\n                \"com.android.tools/r8/coroutines.pro\",\n                \"proguard/coroutines.pro\",\n                \"versions/9/module-info.class\",\n                \"kotlinx_coroutines_core.version\"\n            )\n        )\n    }\n\n    @Test\n    fun testMetaInfAndroidStructure() {\n        val clazz = Class.forName(\"kotlinx.coroutines.android.HandlerDispatcher\")\n        JarFile(clazz.protectionDomain.codeSource.location.file).checkMetaInfStructure(\n            setOf(\n                \"MANIFEST.MF\",\n                \"kotlinx-coroutines-android.kotlin_module\",\n                \"services/kotlinx.coroutines.CoroutineExceptionHandler\",\n                \"services/kotlinx.coroutines.internal.MainDispatcherFactory\",\n                \"com.android.tools/r8-from-1.6.0/coroutines.pro\",\n                \"com.android.tools/r8-upto-3.0.0/coroutines.pro\",\n                \"com.android.tools/proguard/coroutines.pro\",\n                \"proguard/coroutines.pro\",\n                \"versions/9/module-info.class\",\n                \"kotlinx_coroutines_android.version\"\n            )\n        )\n    }\n\n    private fun JarFile.checkMetaInfStructure(expected: Set<String>) {\n        val actual = HashSet<String>()\n        for (e in entries()) {\n            if (e.isDirectory() || !e.realName.contains(\"META-INF\")) {\n                continue\n            }\n            val partialName = e.realName.substringAfter(\"META-INF/\")\n            actual.add(partialName)\n        }\n\n        if (actual != expected) {\n            val intersection = actual.intersect(expected)\n            val mismatch = actual.subtract(intersection) + expected.subtract(intersection)\n            fail(\"Mismatched files: \" + mismatch)\n        }\n\n        close()\n    }\n}\n"
    },
    {
        "path": "integration-testing/src/mavenTest/kotlin/MavenPublicationVersionValidator.kt",
        "content": "package kotlinx.coroutines.validator\n\nimport org.junit.Test\nimport java.util.jar.*\nimport kotlin.test.*\n\nclass MavenPublicationVersionValidator {\n\n    @Test\n    fun testMppJar() {\n        val clazz = Class.forName(\"kotlinx.coroutines.Job\")\n        JarFile(clazz.protectionDomain.codeSource.location.file).checkForVersion(\"kotlinx_coroutines_core.version\")\n    }\n\n    @Test\n    fun testAndroidJar() {\n        val clazz = Class.forName(\"kotlinx.coroutines.android.HandlerDispatcher\")\n        JarFile(clazz.protectionDomain.codeSource.location.file).checkForVersion(\"kotlinx_coroutines_android.version\")\n    }\n\n    private fun JarFile.checkForVersion(file: String) {\n        val actualFile = \"META-INF/$file\"\n        val version = System.getenv(\"version\")\n        use {\n            for (e in entries()) {\n                if (e.name == actualFile) {\n                    val string = getInputStream(e).readAllBytes().decodeToString()\n                    assertEquals(version, string)\n                    return\n                }\n            }\n            error(\"File $file not found\")\n        }\n    }\n}\n"
    },
    {
        "path": "integration/kotlinx-coroutines-guava/build.gradle.kts",
        "content": "val guavaVersion = \"31.0.1-jre\"\n\ndependencies {\n    api(\"com.google.guava:guava:$guavaVersion\")\n}\n\njava {\n    targetCompatibility = JavaVersion.VERSION_1_8\n    sourceCompatibility = JavaVersion.VERSION_1_8\n}\n\nexternalDocumentationLink(\n    url = \"https://google.github.io/guava/releases/$guavaVersion/api/docs/\"\n)\n"
    },
    {
        "path": "integration/kotlinx-coroutines-guava/src/ListenableFuture.kt",
        "content": "package kotlinx.coroutines.guava\n\nimport com.google.common.util.concurrent.*\nimport com.google.common.util.concurrent.internal.*\nimport kotlinx.coroutines.*\nimport java.util.concurrent.*\nimport java.util.concurrent.CancellationException\nimport kotlin.coroutines.*\n\n/**\n * Starts [block] in a new coroutine and returns a [ListenableFuture] pointing to its result.\n *\n * The coroutine is started immediately. Passing [CoroutineStart.LAZY] to [start] throws\n * [IllegalArgumentException], because Futures don't have a way to start lazily.\n *\n * When the created coroutine [isCompleted][Job.isCompleted], it will try to\n * *synchronously* complete the returned Future with the same outcome. This will\n * succeed, barring a race with external cancellation of returned [ListenableFuture].\n *\n * Cancellation is propagated bidirectionally.\n *\n * `CoroutineContext` is inherited from this [CoroutineScope]. Additional context elements can be\n * added/overlaid by passing [context].\n *\n * If the context does not have a [CoroutineDispatcher], nor any other [ContinuationInterceptor]\n * member, [Dispatchers.Default] is used.\n *\n * The parent job is inherited from this [CoroutineScope], and can be overridden by passing\n * a [Job] in [context].\n *\n * See [newCoroutineContext][CoroutineScope.newCoroutineContext] for a description of debugging\n * facilities.\n *\n * Note that the error and cancellation semantics of [future] are _different_ than [async]'s.\n * In contrast to [Deferred], [Future] doesn't have an intermediate `Cancelling` state. If\n * the returned `Future` is successfully cancelled, and `block` throws afterward, the thrown\n * error is dropped, and getting the `Future`'s value will throw a `CancellationException` with\n * no cause. This is to match the specification and behavior of\n * `java.util.concurrent.FutureTask`.\n *\n * @param context added overlaying [CoroutineScope.coroutineContext] to form the new context.\n * @param start coroutine start option. The default value is [CoroutineStart.DEFAULT].\n * @param block the code to execute.\n */\npublic fun <T> CoroutineScope.future(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -> T\n): ListenableFuture<T> {\n    require(!start.isLazy) { \"$start start is not supported\" }\n    val newContext = newCoroutineContext(context)\n    val coroutine = ListenableFutureCoroutine<T>(newContext)\n    coroutine.start(start, coroutine, block)\n    return coroutine.future\n}\n\n/**\n * Returns a [Deferred] that is completed or failed by `this` [ListenableFuture].\n *\n * Completion is non-atomic between the two promises.\n *\n * Cancellation is propagated bidirectionally.\n *\n * When `this` `ListenableFuture` completes (either successfully or exceptionally) it will try to\n * complete the returned `Deferred` with the same value or exception. This will succeed, barring a\n * race with cancellation of the `Deferred`.\n *\n * When `this` `ListenableFuture` is [successfully cancelled][java.util.concurrent.Future.cancel],\n * it will cancel the returned `Deferred`.\n *\n * When the returned `Deferred` is [cancelled][Deferred.cancel], it will try to propagate the\n * cancellation to `this` `ListenableFuture`. Propagation will succeed, barring a race with the\n * `ListenableFuture` completing normally. This is the only case in which the returned `Deferred`\n * will complete with a different outcome than `this` `ListenableFuture`.\n */\npublic fun <T> ListenableFuture<T>.asDeferred(): Deferred<T> {\n    /* This method creates very specific behaviour as it entangles the `Deferred` and\n     * `ListenableFuture`. This behaviour is the best discovered compromise between the possible\n     * states and interface contracts of a `Future` and the states of a `Deferred`. The specific\n     * behaviour is described here.\n     *\n     * When `this` `ListenableFuture` is successfully cancelled - meaning\n     * `ListenableFuture.cancel()` returned `true` - it will synchronously cancel the returned\n     * `Deferred`. This can only race with cancellation of the returned `Deferred`, so the\n     * `Deferred` will always be put into its \"cancelling\" state and (barring uncooperative\n     * cancellation) _eventually_ reach its \"cancelled\" state when either promise is successfully\n     * cancelled.\n     *\n     * When the returned `Deferred` is cancelled, `ListenableFuture.cancel()` will be synchronously\n     * called on `this` `ListenableFuture`. This will attempt to cancel the `Future`, though\n     * cancellation may not succeed and the `ListenableFuture` may complete in a non-cancelled\n     * terminal state.\n     *\n     * The returned `Deferred` may receive and suppress the `true` return value from\n     * `ListenableFuture.cancel()` when the task is cancelled via the `Deferred` reference to it.\n     * This is unavoidable, so make sure no idempotent cancellation work is performed by a\n     * reference-holder of the `ListenableFuture` task. The idempotent work won't get done if\n     * cancellation was from the `Deferred` representation of the task.\n     *\n     * This is inherently a race. See `Future.cancel()` for a description of `Future` cancellation\n     * semantics. See `Job` for a description of coroutine cancellation semantics.\n     */\n    // First, try the fast-fast error path for Guava ListenableFutures. This will save allocating an\n    // Exception by using the same instance the Future created.\n    if (this is InternalFutureFailureAccess) {\n        val t: Throwable? = InternalFutures.tryInternalFastPathGetFailure(this)\n        if (t != null) {\n            return CompletableDeferred<T>().also {\n                it.completeExceptionally(t)\n            }\n        }\n    }\n\n    // Second, try the fast path for a completed Future. The Future is known to be done, so get()\n    // will not block, and thus it won't be interrupted. Calling getUninterruptibly() instead of\n    // getDone() in this known-non-interruptible case saves the volatile read that getDone() uses to\n    // handle interruption.\n    if (isDone) {\n        return try {\n            CompletableDeferred(Uninterruptibles.getUninterruptibly(this))\n        } catch (e: CancellationException) {\n            CompletableDeferred<T>().also { it.cancel(e) }\n        } catch (e: ExecutionException) {\n            // ExecutionException is the only kind of exception that can be thrown from a gotten\n            // Future. Anything else showing up here indicates a very fundamental bug in a\n            // Future implementation.\n            CompletableDeferred<T>().also { it.completeExceptionally(e.nonNullCause()) }\n        }\n    }\n\n    // Finally, if this isn't done yet, attach a Listener that will complete the Deferred.\n    val deferred = CompletableDeferred<T>()\n    Futures.addCallback(this, object : FutureCallback<T> {\n        override fun onSuccess(result: T) {\n            runCatching { deferred.complete(result) }\n                .onFailure { handleCoroutineException(EmptyCoroutineContext, it) }\n        }\n\n        override fun onFailure(t: Throwable) {\n            runCatching { deferred.completeExceptionally(t) }\n                .onFailure { handleCoroutineException(EmptyCoroutineContext, it) }\n        }\n    }, MoreExecutors.directExecutor())\n\n    // ... And cancel the Future when the deferred completes. Since the return type of this method\n    // is Deferred, the only interaction point from the caller is to cancel the Deferred. If this\n    // completion handler runs before the Future is completed, the Deferred must have been\n    // cancelled and should propagate its cancellation. If it runs after the Future is completed,\n    // this is a no-op.\n    deferred.invokeOnCompletion {\n        cancel(false)\n    }\n    // Return hides the CompletableDeferred. This should prevent casting.\n    return object : Deferred<T> by deferred {}\n}\n\n/**\n * Returns the cause from an [ExecutionException] thrown by a [Future.get] or similar.\n *\n * [ExecutionException] _always_ wraps a non-null cause when Future.get() throws. A Future cannot\n * fail without a non-null `cause`, because the only way a Future _can_ fail is an uncaught\n * [Exception].\n *\n * If this !! throws [NullPointerException], a Future is breaking its interface contract and losing\n * state - a serious fundamental bug.\n */\nprivate fun ExecutionException.nonNullCause(): Throwable {\n    return this.cause!!\n}\n\n/**\n * Returns a [ListenableFuture] that is completed or failed by `this` [Deferred].\n *\n * Completion is non-atomic between the two promises.\n *\n * When either promise successfully completes, it will attempt to synchronously complete its\n * counterpart with the same value. This will succeed barring a race with cancellation.\n *\n * When either promise completes with an Exception, it will attempt to synchronously complete its\n * counterpart with the same Exception. This will succeed barring a race with cancellation.\n *\n * Cancellation is propagated bidirectionally.\n *\n * When the returned [Future] is successfully cancelled - meaning [Future.cancel] returned true -\n * [Deferred.cancel] will be synchronously called on `this` [Deferred]. This will attempt to cancel\n * the `Deferred`, though cancellation may not succeed and the `Deferred` may complete in a\n * non-cancelled terminal state.\n *\n * When `this` `Deferred` reaches its \"cancelled\" state with a successful cancellation - meaning it\n * completes with [kotlinx.coroutines.CancellationException] - `this` `Deferred` will synchronously\n * cancel the returned `Future`. This can only race with cancellation of the returned `Future`, so\n * the returned `Future` will always _eventually_ reach its cancelled state when either promise is\n * successfully cancelled, for their different meanings of \"successfully cancelled\".\n *\n * This is inherently a race. See [Future.cancel] for a description of `Future` cancellation\n * semantics. See [Job] for a description of coroutine cancellation semantics. See\n * [JobListenableFuture.cancel] for greater detail on the overlapped cancellation semantics and\n * corner cases of this method.\n */\npublic fun <T> Deferred<T>.asListenableFuture(): ListenableFuture<T> {\n    val listenableFuture = JobListenableFuture<T>(this)\n    // This invokeOnCompletion completes the JobListenableFuture with the same result as `this` Deferred.\n    // The JobListenableFuture may have completed earlier if it got cancelled! See JobListenableFuture.cancel().\n    invokeOnCompletion { throwable ->\n        if (throwable == null) {\n            listenableFuture.complete(getCompleted())\n        } else {\n            listenableFuture.completeExceptionallyOrCancel(throwable)\n        }\n    }\n    return listenableFuture\n}\n\n/**\n * Awaits completion of `this` [ListenableFuture] without blocking a thread.\n *\n * This suspend function is cancellable.\n *\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function\n * stops waiting for the future and immediately resumes with [CancellationException][kotlinx.coroutines.CancellationException].\n *\n * This method is intended to be used with one-shot Futures, so on coroutine cancellation, the Future is cancelled as well.\n * If cancelling the given future is undesired, use [Futures.nonCancellationPropagating] or\n * [kotlinx.coroutines.NonCancellable].\n */\npublic suspend fun <T> ListenableFuture<T>.await(): T {\n    try {\n        if (isDone) return Uninterruptibles.getUninterruptibly(this)\n    } catch (e: ExecutionException) {\n        // ExecutionException is the only kind of exception that can be thrown from a gotten\n        // Future, other than CancellationException. Cancellation is propagated upward so that\n        // the coroutine running this suspend function may process it.\n        // Any other Exception showing up here indicates a very fundamental bug in a\n        // Future implementation.\n        throw e.nonNullCause()\n    }\n\n    return suspendCancellableCoroutine { cont: CancellableContinuation<T> ->\n        addListener(\n            ToContinuation(this, cont),\n            MoreExecutors.directExecutor())\n        cont.invokeOnCancellation {\n            cancel(false)\n        }\n    }\n}\n\n/**\n * Propagates the outcome of [futureToObserve] to [continuation] on completion.\n *\n * Cancellation is propagated as cancelling the continuation. If [futureToObserve] completes\n * and fails, the cause of the Future will be propagated without a wrapping\n * [ExecutionException] when thrown.\n */\nprivate class ToContinuation<T>(\n    val futureToObserve: ListenableFuture<T>,\n    val continuation: CancellableContinuation<T>\n): Runnable {\n    override fun run() {\n        if (futureToObserve.isCancelled) {\n            continuation.cancel()\n        } else {\n            try {\n                continuation.resume(Uninterruptibles.getUninterruptibly(futureToObserve))\n            } catch (e: ExecutionException) {\n                // ExecutionException is the only kind of exception that can be thrown from a gotten\n                // Future. Anything else showing up here indicates a very fundamental bug in a\n                // Future implementation.\n                continuation.resumeWithException(e.nonNullCause())\n            }\n        }\n    }\n}\n\n/**\n * An [AbstractCoroutine] intended for use directly creating a [ListenableFuture] handle to\n * completion.\n *\n * If [future] is successfully cancelled, cancellation is propagated to `this` `Coroutine`.\n * By documented contract, a [Future] has been cancelled if\n * and only if its `isCancelled()` method returns true.\n *\n * Any error that occurs after successfully cancelling a [ListenableFuture] is lost.\n * The contract of [Future] does not permit it to return an error after it is successfully cancelled.\n * On the other hand, we can't report an unhandled exception to [CoroutineExceptionHandler],\n * otherwise [Future.cancel] can lead to an app crash which arguably is a contract violation.\n * In contrast to [Future] which can't change its outcome after a successful cancellation,\n * cancelling a [Deferred] places that [Deferred] in the cancelling/cancelled states defined by [Job],\n * which _can_ show the error.\n *\n * This may be counterintuitive, but it maintains the error and cancellation contracts of both\n * the [Deferred] and [ListenableFuture] types, while permitting both kinds of promise to point\n * to the same running task.\n */\nprivate class ListenableFutureCoroutine<T>(\n    context: CoroutineContext\n) : AbstractCoroutine<T>(context, initParentJob = true, active = true) {\n\n    // JobListenableFuture propagates external cancellation to `this` coroutine. See JobListenableFuture.\n    @JvmField\n    val future = JobListenableFuture<T>(this)\n\n    override fun onCompleted(value: T) {\n        future.complete(value)\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        // Note: if future was cancelled in a race with a cancellation of this\n        // coroutine, and the future was successfully cancelled first, the cause of coroutine\n        // cancellation is dropped in this promise. A Future can only be completed once.\n        //\n        // This is consistent with FutureTask behaviour. A race between a Future.cancel() and\n        // a FutureTask.setException() for the same Future will similarly drop the\n        // cause of a failure-after-cancellation.\n        future.completeExceptionallyOrCancel(cause)\n    }\n}\n\n/**\n * A [ListenableFuture] that delegates to an internal [SettableFuture], collaborating with it.\n *\n * This setup allows the returned [ListenableFuture] to maintain the following properties:\n *\n * - Correct implementation of [Future]'s happens-after semantics documented for [get], [isDone]\n *   and [isCancelled] methods\n * - Cancellation propagation both to and from [Deferred]\n * - Correct cancellation and completion semantics even when this [ListenableFuture] is combined\n *   with different concrete implementations of [ListenableFuture]\n *   - Fully correct cancellation and listener happens-after obeying [Future] and\n *     [ListenableFuture]'s documented and implicit contracts is surprisingly difficult to achieve.\n *     The best way to be correct, especially given the fun corner cases from\n *     [AbstractFuture.setFuture], is to just use an [AbstractFuture].\n *   - To maintain sanity, this class implements [ListenableFuture] and uses an auxiliary [SettableFuture]\n *     around coroutine's result as a state engine to establish happens-after-completion. This\n *     could probably be compressed into one subclass of [AbstractFuture] to save an allocation, at the\n *     cost of the implementation's readability.\n */\nprivate class JobListenableFuture<T>(private val jobToCancel: Job): ListenableFuture<T> {\n    /**\n     * Serves as a state machine for [Future] cancellation.\n     *\n     * [AbstractFuture] has a highly-correct atomic implementation of `Future`'s completion and\n     * cancellation semantics. By using that type, the [JobListenableFuture] can delegate its semantics to\n     * `auxFuture.get()` the result in such a way that the `Deferred` is always complete when returned.\n     *\n     * To preserve Coroutine's [CancellationException], this future points to either `T` or [Cancelled].\n     */\n    private val auxFuture = SettableFuture.create<Any?>()\n\n    /**\n     * `true` if [auxFuture.get][ListenableFuture.get] throws [ExecutionException].\n     *\n     * Note: this is eventually consistent with the state of [auxFuture].\n     *\n     * Unfortunately, there's no API to figure out if [ListenableFuture] throws [ExecutionException]\n     * apart from calling [ListenableFuture.get] on it. To avoid unnecessary [ExecutionException] allocation\n     * we use this field as an optimization.\n     */\n    private var auxFutureIsFailed: Boolean = false\n\n    /**\n     * When the attached coroutine [isCompleted][Job.isCompleted] successfully\n     * its outcome should be passed to this method.\n     *\n     * This should succeed barring a race with external cancellation.\n     */\n    fun complete(result: T): Boolean = auxFuture.set(result)\n\n    /**\n     * When the attached coroutine [isCompleted][Job.isCompleted] [exceptionally][Job.isCancelled]\n     * its outcome should be passed to this method.\n     *\n     * This method will map coroutine's exception into corresponding Future's exception.\n     *\n     * This should succeed barring a race with external cancellation.\n     */\n    // CancellationException is wrapped into `Cancelled` to preserve original cause and message.\n    // All the other exceptions are delegated to SettableFuture.setException.\n    fun completeExceptionallyOrCancel(t: Throwable): Boolean =\n        if (t is CancellationException) auxFuture.set(Cancelled(t))\n        else auxFuture.setException(t).also { if (it) auxFutureIsFailed = true }\n\n    /**\n     * Returns cancellation _in the sense of [Future]_. This is _not_ equivalent to\n     * [Job.isCancelled].\n     *\n     * When done, this Future is cancelled if its [auxFuture] is cancelled, or if [auxFuture]\n     * contains [CancellationException].\n     *\n     * See [cancel].\n     */\n    override fun isCancelled(): Boolean {\n        // This expression ensures that isCancelled() will *never* return true when isDone() returns false.\n        // In the case that the deferred has completed with cancellation, completing `this`, its\n        // reaching the \"cancelled\" state with a cause of CancellationException is treated as the\n        // same thing as auxFuture getting cancelled. If the Job is in the \"cancelling\" state and\n        // this Future hasn't itself been successfully cancelled, the Future will return\n        // isCancelled() == false. This is the only discovered way to reconcile the two different\n        // cancellation contracts.\n        return auxFuture.isCancelled || isDone && !auxFutureIsFailed && try {\n            Uninterruptibles.getUninterruptibly(auxFuture) is Cancelled\n        } catch (e: CancellationException) {\n            // `auxFuture` got cancelled right after `auxFuture.isCancelled` returned false.\n            true\n        } catch (e: ExecutionException) {\n            // `auxFutureIsFailed` hasn't been updated yet.\n            auxFutureIsFailed = true\n            false\n        }\n    }\n\n    /**\n     * Waits for [auxFuture] to complete by blocking, then uses its `result`\n     * to get the `T` value `this` [ListenableFuture] is pointing to or throw a [CancellationException].\n     * This establishes happens-after ordering for completion of the entangled coroutine.\n     *\n     * [SettableFuture.get] can only throw [CancellationException] if it was cancelled externally.\n     * Otherwise it returns [Cancelled] that encapsulates outcome of the entangled coroutine.\n     *\n     * [auxFuture] _must be complete_ in order for the [isDone] and [isCancelled] happens-after\n     * contract of [Future] to be correctly followed.\n     */\n    override fun get(): T {\n        return getInternal(auxFuture.get())\n    }\n\n    /** See [get()]. */\n    override fun get(timeout: Long, unit: TimeUnit): T {\n        return getInternal(auxFuture.get(timeout, unit))\n    }\n\n    /** See [get()]. */\n    private fun getInternal(result: Any?): T = if (result is Cancelled) {\n        throw CancellationException().initCause(result.exception)\n    } else {\n        // We know that `auxFuture` can contain either `T` or `Cancelled`.\n        @Suppress(\"UNCHECKED_CAST\")\n        result as T\n    }\n\n    override fun addListener(listener: Runnable, executor: Executor) {\n        auxFuture.addListener(listener, executor)\n    }\n\n    override fun isDone(): Boolean {\n        return auxFuture.isDone\n    }\n\n    /**\n     * Tries to cancel [jobToCancel] if `this` future was cancelled. This is fundamentally racy.\n     *\n     * The call to `cancel()` will try to cancel [auxFuture]: if and only if cancellation of [auxFuture]\n     * succeeds, [jobToCancel] will have its [Job.cancel] called.\n     *\n     * This arrangement means that [jobToCancel] _might not successfully cancel_, if the race resolves\n     * in a particular way. [jobToCancel] may also be in its \"cancelling\" state while this\n     * ListenableFuture is complete and cancelled.\n     */\n    override fun cancel(mayInterruptIfRunning: Boolean): Boolean {\n        // TODO: call jobToCancel.cancel() _before_ running the listeners.\n        //  `auxFuture.cancel()` will execute auxFuture's listeners. This delays cancellation of\n        //  `jobToCancel` until after auxFuture's listeners have already run.\n        //  Consider moving `jobToCancel.cancel()` into [AbstractFuture.afterDone] when the API is finalized.\n        return if (auxFuture.cancel(mayInterruptIfRunning)) {\n            jobToCancel.cancel()\n            true\n        } else {\n            false\n        }\n    }\n\n    override fun toString(): String = buildString {\n        append(super.toString())\n        append(\"[status=\")\n        if (isDone) {\n            try {\n                when (val result = Uninterruptibles.getUninterruptibly(auxFuture)) {\n                    is Cancelled -> append(\"CANCELLED, cause=[${result.exception}]\")\n                    else -> append(\"SUCCESS, result=[$result]\")\n                }\n            } catch (e: CancellationException) {\n                // `this` future was cancelled by `Future.cancel`. In this case there's no cause or message.\n                append(\"CANCELLED\")\n            } catch (e: ExecutionException) {\n                append(\"FAILURE, cause=[${e.cause}]\")\n            } catch (t: Throwable) {\n                // Violation of Future's contract, should never happen.\n                append(\"UNKNOWN, cause=[${t.javaClass} thrown from get()]\")\n            }\n        } else {\n            append(\"PENDING, delegate=[$auxFuture]\")\n        }\n        append(']')\n    }\n}\n\n/**\n * A wrapper for `Coroutine`'s [CancellationException].\n *\n * If the coroutine is _cancelled normally_, we want to show the reason of cancellation to the user. Unfortunately,\n * [SettableFuture] can't store the reason of cancellation. To mitigate this, we wrap cancellation exception into this\n * class and pass it into [SettableFuture.complete]. See implementation of [JobListenableFuture].\n */\nprivate class Cancelled(@JvmField val exception: CancellationException)\n"
    },
    {
        "path": "integration/kotlinx-coroutines-guava/test/FutureAsDeferredUnhandledCompletionExceptionTest.kt",
        "content": "package kotlinx.coroutines.guava\n\nimport kotlinx.coroutines.testing.*\nimport com.google.common.util.concurrent.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass FutureAsDeferredUnhandledCompletionExceptionTest : TestBase() {\n\n    // This is a separate test in order to avoid interference with uncaught exception handlers in other tests\n    private val exceptionHandler = Thread.getDefaultUncaughtExceptionHandler()\n    private lateinit var caughtException: Throwable\n\n    @Before\n    fun setUp() {\n        Thread.setDefaultUncaughtExceptionHandler { _, e -> caughtException = e }\n    }\n\n    @After\n    fun tearDown() {\n        Thread.setDefaultUncaughtExceptionHandler(exceptionHandler)\n    }\n\n    @Test\n    fun testLostExceptionOnSuccess() = runTest {\n        val future = SettableFuture.create<Int>()\n        val deferred = future.asDeferred()\n        deferred.invokeOnCompletion { throw TestException() }\n        future.set(1)\n        assertTrue { caughtException is CompletionHandlerException && caughtException.cause is TestException }\n    }\n\n    @Test\n    fun testLostExceptionOnFailure() = runTest {\n        val future = SettableFuture.create<Int>()\n        val deferred = future.asDeferred()\n        deferred.invokeOnCompletion { throw TestException() }\n        future.setException(TestException2())\n        assertTrue { caughtException is CompletionHandlerException && caughtException.cause is TestException }\n    }\n}\n"
    },
    {
        "path": "integration/kotlinx-coroutines-guava/test/ListenableFutureExceptionsTest.kt",
        "content": "package kotlinx.coroutines.guava\n\nimport kotlinx.coroutines.testing.*\nimport com.google.common.base.*\nimport com.google.common.util.concurrent.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.io.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass ListenableFutureExceptionsTest : TestBase() {\n\n    @Test\n    fun testAwait() {\n        testException(IOException(), { it is IOException })\n    }\n\n    @Test\n    fun testAwaitChained() {\n        testException(IOException(), { it is IOException }, { i -> i!! + 1 })\n    }\n\n    @Test\n    fun testAwaitCompletionException() {\n        testException(CompletionException(\"test\", IOException()), { it is CompletionException })\n    }\n\n    @Test\n    fun testAwaitChainedCompletionException() {\n        testException(\n            CompletionException(\"test\", IOException()),\n            { it is CompletionException },\n            { i -> i!! + 1 })\n    }\n\n    @Test\n    fun testAwaitTestException() {\n        testException(TestException(), { it is TestException })\n    }\n\n    @Test\n    fun testAwaitChainedTestException() {\n        testException(TestException(), { it is TestException }, { i -> i!! + 1 })\n    }\n\n    private fun testException(\n        exception: Throwable,\n        expected: ((Throwable) -> Boolean),\n        transformer: ((Int?) -> Int?)? = null\n    ) {\n\n        // Fast path\n        runTest {\n            val future = SettableFuture.create<Int>()\n            val chained = if (transformer == null) {\n                future\n            } else {\n                Futures.transform(future, Function(transformer), MoreExecutors.directExecutor())\n            }\n            future.setException(exception)\n            try {\n                chained.await()\n            } catch (e: Throwable) {\n                assertTrue(expected(e))\n            }\n        }\n\n        // Slow path\n        runTest {\n            val future = SettableFuture.create<Int>()\n            val chained = if (transformer == null) {\n                future\n            } else {\n                Futures.transform(future, Function(transformer), MoreExecutors.directExecutor())\n            }\n            launch {\n                future.setException(exception)\n            }\n\n            try {\n                chained.await()\n            } catch (e: Throwable) {\n                assertTrue(expected(e))\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "integration/kotlinx-coroutines-guava/test/ListenableFutureTest.kt",
        "content": "package kotlinx.coroutines.guava\n\nimport kotlinx.coroutines.testing.*\nimport com.google.common.util.concurrent.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Ignore\nimport org.junit.Test\nimport java.util.concurrent.*\nimport java.util.concurrent.CancellationException\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\nclass ListenableFutureTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"ForkJoinPool.commonPool-worker-\")\n    }\n\n    @Test\n    fun testSimpleAwait() {\n        val service = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n        val future = GlobalScope.future {\n            service.submit(Callable<String> {\n                \"O\"\n            }).await() + \"K\"\n        }\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testAwaitWithContext() = runTest {\n        val future = SettableFuture.create<Int>()\n        val deferred = async {\n            withContext(Dispatchers.Default) {\n                future.await()\n            }\n        }\n\n        future.set(1)\n        assertEquals(1, deferred.await())\n    }\n\n    @Test\n    fun testAwaitWithCancellation() = runTest(expected = {it is TestCancellationException}) {\n        val future = SettableFuture.create<Int>()\n        val deferred = async {\n            withContext(Dispatchers.Default) {\n                future.await()\n            }\n        }\n\n        deferred.cancel(TestCancellationException())\n        deferred.await() // throws TCE\n        expectUnreached()\n    }\n\n    @Test\n    fun testCompletedFuture() {\n        val toAwait = SettableFuture.create<String>()\n        toAwait.set(\"O\")\n        val future = GlobalScope.future {\n            toAwait.await() + \"K\"\n        }\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testWaitForFuture() {\n        val toAwait = SettableFuture.create<String>()\n        val future = GlobalScope.future {\n            toAwait.await() + \"K\"\n        }\n        assertFalse(future.isDone)\n        toAwait.set(\"O\")\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testCompletedFutureExceptionally() {\n        val toAwait = SettableFuture.create<String>()\n        toAwait.setException(IllegalArgumentException(\"O\"))\n        val future = GlobalScope.future {\n            try {\n                toAwait.await()\n            } catch (e: RuntimeException) {\n                assertIs<IllegalArgumentException>(e)\n                e.message!!\n            } + \"K\"\n        }\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testWaitForFutureWithException() {\n        val toAwait = SettableFuture.create<String>()\n        val future = GlobalScope.future {\n            try {\n                toAwait.await()\n            } catch (e: RuntimeException) {\n                assertIs<IllegalArgumentException>(e)\n                e.message!!\n            } + \"K\"\n        }\n        assertFalse(future.isDone)\n        toAwait.setException(IllegalArgumentException(\"O\"))\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testExceptionInsideCoroutine() {\n        val service = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n        val future = GlobalScope.future {\n            if (service.submit(Callable<Boolean> { true }).await()) {\n                throw IllegalStateException(\"OK\")\n            }\n            \"fail\"\n        }\n        try {\n            future.get()\n            fail(\"'get' should've throw an exception\")\n        } catch (e: ExecutionException) {\n            assertIs<IllegalStateException>(e.cause)\n            assertEquals(\"OK\", e.cause!!.message)\n        }\n    }\n\n    @Test\n    fun testFutureLazyStartThrows() {\n        expect(1)\n        val e = assertFailsWith<IllegalArgumentException> {\n            GlobalScope.future(start = CoroutineStart.LAZY) {}\n        }\n\n        assertEquals(\"LAZY start is not supported\", e.message)\n        finish(2)\n    }\n\n    @Test\n    fun testCompletedDeferredAsListenableFuture() = runBlocking {\n        expect(1)\n        val deferred = async(start = CoroutineStart.UNDISPATCHED) {\n            expect(2) // completed right away\n            \"OK\"\n        }\n        expect(3)\n        val future = deferred.asListenableFuture()\n        assertEquals(\"OK\", future.await())\n        finish(4)\n    }\n\n    @Test\n    fun testWaitForDeferredAsListenableFuture() = runBlocking {\n        expect(1)\n        val deferred = async {\n            expect(3) // will complete later\n            \"OK\"\n        }\n        expect(2)\n        val future = deferred.asListenableFuture()\n        assertEquals(\"OK\", future.await()) // await yields main thread to deferred coroutine\n        finish(4)\n    }\n\n    @Test\n    fun testAsListenableFutureThrowable() {\n        val deferred = GlobalScope.async {\n            throw OutOfMemoryError()\n        }\n\n        val future = deferred.asListenableFuture()\n        try {\n            future.get()\n        } catch (e: ExecutionException) {\n            assertTrue(future.isDone)\n            assertIs<OutOfMemoryError>(e.cause)\n        }\n    }\n\n    @Test\n    fun testCancellableAwait() = runBlocking {\n        expect(1)\n        val toAwait = SettableFuture.create<String>()\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                toAwait.await() // suspends\n            } catch (e: CancellationException) {\n                expect(5) // should throw cancellation exception\n                throw e\n            }\n        }\n        expect(3)\n        job.cancel() // cancel the job\n        toAwait.set(\"fail\") // too late, the waiting job was already cancelled\n        expect(4) // job processing of cancellation was scheduled, not executed yet\n        yield() // yield main thread to job\n        finish(6)\n    }\n\n    @Test\n    fun testFutureAwaitCancellationPropagatingToDeferred() = runTest {\n\n        val latch = CountDownLatch(1)\n        val executor = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n        val future = executor.submit(Callable { latch.await(); 42 })\n        val deferred = async {\n            expect(2)\n            future.await()\n        }\n        expect(1)\n        yield()\n        future.cancel(/*mayInterruptIfRunning=*/true)\n        expect(3)\n        latch.countDown()\n        deferred.join()\n        assertTrue(future.isCancelled)\n        assertTrue(deferred.isCancelled)\n        assertFailsWith<CancellationException> { future.get() }\n        finish(4)\n    }\n\n    @Test\n    fun testFutureAwaitCancellationPropagatingToDeferredNoInterruption() = runTest {\n\n        val latch = CountDownLatch(1)\n        val executor = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n        val future = executor.submit(Callable { latch.await(); 42 })\n        val deferred = async {\n            expect(2)\n            future.await()\n        }\n        expect(1)\n        yield()\n        future.cancel(/*mayInterruptIfRunning=*/false)\n        expect(3)\n        latch.countDown()\n        deferred.join()\n        assertTrue(future.isCancelled)\n        assertTrue(deferred.isCancelled)\n        assertFailsWith<CancellationException> { future.get() }\n        finish(4)\n    }\n\n    @Test\n    fun testAsListenableFutureCancellationPropagatingToDeferred() = runTest {\n        val latch = CountDownLatch(1)\n        val executor = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n        val future = executor.submit(Callable { latch.await(); 42 })\n        val deferred = async {\n            expect(2)\n            future.await()\n        }\n        val asListenableFuture = deferred.asListenableFuture()\n        expect(1)\n        yield()\n        asListenableFuture.cancel(/*mayInterruptIfRunning=*/true)\n        expect(3)\n        latch.countDown()\n        deferred.join()\n        assertTrue(future.isCancelled)\n        assertTrue(deferred.isCancelled)\n        assertTrue(asListenableFuture.isCancelled)\n        assertFailsWith<CancellationException> { future.get() }\n        finish(4)\n    }\n\n    @Test\n    fun testAsListenableFutureCancellationPropagatingToDeferredNoInterruption() = runTest {\n        val latch = CountDownLatch(1)\n        val executor = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n        val future = executor.submit(Callable { latch.await(); 42 })\n        val deferred = async {\n            expect(2)\n            future.await()\n        }\n        val asListenableFuture = deferred.asListenableFuture()\n        expect(1)\n        yield()\n        asListenableFuture.cancel(/*mayInterruptIfRunning=*/false)\n        expect(3)\n        latch.countDown()\n        deferred.join()\n        assertFailsWith<CancellationException> { asListenableFuture.get() }\n        assertTrue(future.isCancelled)\n        assertTrue(asListenableFuture.isCancelled)\n        assertTrue(deferred.isCancelled)\n        assertFailsWith<CancellationException> { future.get() }\n        finish(4)\n    }\n\n    @Test\n    fun testAsListenableFutureCancellationThroughSetFuture() = runTest {\n        val latch = CountDownLatch(1)\n        val future = SettableFuture.create<Void>()\n        val deferred = async {\n            expect(2)\n            future.await()\n        }\n        val asListenableFuture = deferred.asListenableFuture()\n        expect(1)\n        yield()\n        future.setFuture(Futures.immediateCancelledFuture())\n        expect(3)\n        latch.countDown()\n        deferred.join()\n        assertFailsWith<CancellationException> { asListenableFuture.get() }\n        // Future was not interrupted, but also wasn't blocking, so it will be successfully\n        // cancelled by its  parent Coroutine.\n        assertTrue(future.isCancelled)\n        assertTrue(asListenableFuture.isCancelled)\n        assertTrue(deferred.isCancelled)\n        assertFailsWith<CancellationException> { future.get() }\n        finish(4)\n    }\n\n    @Test\n    @Ignore  // TODO: propagate cancellation before running listeners.\n    fun testAsListenableFuturePropagatesCancellationBeforeRunningListeners() = runTest {\n        expect(1)\n        val deferred = async(context = Dispatchers.Unconfined) {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                expect(3) // Cancelled.\n            }\n        }\n        val asFuture = deferred.asListenableFuture()\n        asFuture.addListener(Runnable { expect(4) }, MoreExecutors.directExecutor())\n        assertFalse(asFuture.isDone)\n        expect(2)\n        asFuture.cancel(false)\n        assertTrue(asFuture.isDone)\n        assertTrue(asFuture.isCancelled)\n        assertFailsWith<CancellationException> { deferred.await() }\n        finish(5)\n    }\n\n    @Test\n    fun testFutureCancellation() = runTest {\n        val future = awaitFutureWithCancel(true)\n        assertTrue(future.isCancelled)\n        assertFailsWith<CancellationException> { future.get() }\n        finish(4)\n    }\n\n    @Test\n    fun testAsListenableDeferredCancellationCauseAndMessagePropagate() = runTest {\n        val deferred = CompletableDeferred<Int>()\n        val inputCancellationException = CancellationException(\"Foobar\")\n        inputCancellationException.initCause(OutOfMemoryError(\"Foobaz\"))\n        deferred.cancel(inputCancellationException)\n        val asFuture = deferred.asListenableFuture()\n\n        val outputCancellationException =\n            assertFailsWith<CancellationException> { asFuture.get() }\n        val cause = outputCancellationException.cause\n        assertNotNull(cause)\n        assertEquals(cause.message, \"Foobar\")\n        assertIs<OutOfMemoryError>(cause.cause)\n        assertEquals(cause.cause?.message, \"Foobaz\")\n    }\n\n    @Test\n    fun testNoFutureCancellation() = runTest {\n        val future = awaitFutureWithCancel(false)\n        assertFalse(future.isCancelled)\n        @Suppress(\"BlockingMethodInNonBlockingContext\")\n        assertEquals(42, future.get())\n        finish(4)\n    }\n\n    @Test\n    fun testCancelledDeferredAsListenableFutureAwaitThrowsCancellation() = runTest {\n        val future = Futures.immediateCancelledFuture<Int>()\n        val asDeferred = future.asDeferred()\n        val asDeferredAsFuture = asDeferred.asListenableFuture()\n\n        assertTrue(asDeferredAsFuture.isCancelled)\n        assertFailsWith<CancellationException> {\n            asDeferredAsFuture.await()\n        }\n    }\n\n    @Test\n    fun testCancelledDeferredAsListenableFutureAsDeferredPassesCancellationAlong() = runTest {\n        val deferred = CompletableDeferred<Int>()\n        deferred.completeExceptionally(CancellationException())\n        val asFuture = deferred.asListenableFuture()\n        val asFutureAsDeferred = asFuture.asDeferred()\n\n        assertTrue(asFutureAsDeferred.isCancelled)\n        assertTrue(asFutureAsDeferred.isCompleted)\n        // By documentation, join() shouldn't throw when asDeferred is already complete.\n        asFutureAsDeferred.join()\n        assertIs<CancellationException>(asFutureAsDeferred.getCompletionExceptionOrNull())\n    }\n\n    @Test\n    fun testCancelledFutureAsDeferredAwaitThrowsCancellation() = runTest {\n        val future = Futures.immediateCancelledFuture<Int>()\n        val asDeferred = future.asDeferred()\n\n        assertTrue(asDeferred.isCancelled)\n        assertFailsWith<CancellationException> {\n            asDeferred.await()\n        }\n    }\n\n    @Test\n    fun testCancelledFutureAsDeferredJoinDoesNotThrow() = runTest {\n        val future = Futures.immediateCancelledFuture<Int>()\n        val asDeferred = future.asDeferred()\n\n        assertTrue(asDeferred.isCancelled)\n        assertTrue(asDeferred.isCompleted)\n        // By documentation, join() shouldn't throw when asDeferred is already complete.\n        asDeferred.join()\n        assertIs<CancellationException>(asDeferred.getCompletionExceptionOrNull())\n    }\n\n    @Test\n    fun testCompletedFutureAsDeferred() = runTest {\n        val future = SettableFuture.create<Int>()\n        val task = async {\n            expect(2)\n            assertEquals(42, future.asDeferred().await())\n            expect(4)\n        }\n\n        expect(1)\n        yield()\n        expect(3)\n        future.set(42)\n        task.join()\n        finish(5)\n    }\n\n    @Test\n    fun testFailedFutureAsDeferred() = runTest {\n        val future = SettableFuture.create<Int>().apply {\n            setException(TestException())\n        }\n        val deferred = future.asDeferred()\n        assertTrue(deferred.isCancelled && deferred.isCompleted)\n        val completionException = deferred.getCompletionExceptionOrNull()!!\n        assertIs<TestException>(completionException)\n\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: Throwable) {\n            assertIs<TestException>(e)\n        }\n    }\n\n    @Test\n    fun testFutureCompletedWithNullFastPathAsDeferred() = runTest {\n        val executor = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n        val future = executor.submit(Callable<Int> { null }).also {\n            @Suppress(\"BlockingMethodInNonBlockingContext\")\n            it.get()\n        }\n        assertNull(future.asDeferred().await())\n    }\n\n    @Test\n    fun testFutureCompletedWithNullSlowPathAsDeferred() = runTest {\n        val latch = CountDownLatch(1)\n        val executor = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n\n        val future = executor.submit(Callable<Int> {\n            latch.await()\n            null\n        })\n\n        val awaiter = async(start = CoroutineStart.UNDISPATCHED) {\n            future.asDeferred().await()\n        }\n\n        latch.countDown()\n        assertNull(awaiter.await())\n    }\n\n    @Test\n    fun testThrowingFutureAsDeferred() = runTest {\n        val executor = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n        val future = executor.submit(Callable { throw TestException() })\n        try {\n            future.asDeferred().await()\n            expectUnreached()\n        } catch (e: Throwable) {\n            assertIs<TestException>(e)\n        }\n    }\n\n    @Test\n    fun testStructuredException() = runTest(\n        expected = { it is TestException } // exception propagates to parent with structured concurrency\n    ) {\n        val result = future<Int>(Dispatchers.Unconfined) {\n            throw TestException(\"FAIL\")\n        }\n        result.checkFutureException<TestException>()\n    }\n\n    @Test\n    fun testChildException() = runTest(\n        expected = { it is TestException } // exception propagates to parent with structured concurrency\n    ) {\n        val result = future(Dispatchers.Unconfined) {\n            // child crashes\n            launch { throw TestException(\"FAIL\") }\n            42\n        }\n        result.checkFutureException<TestException>()\n    }\n\n    @Test\n    fun testExternalCancellation() = runTest {\n        val future = future(Dispatchers.Unconfined) {\n            try {\n                delay(Long.MAX_VALUE)\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(2)\n                throw e\n            }\n        }\n\n        yield()\n        expect(1)\n        future.cancel(true)\n        finish(3)\n    }\n\n    @Test\n    fun testExceptionOnExternalCancellation() = runTest(expected = {it is TestException}) {\n        val result = future(Dispatchers.Unconfined) {\n            try {\n                expect(1)\n                delay(Long.MAX_VALUE)\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(3)\n                throw TestException()\n            }\n        }\n        expect(2)\n        result.cancel(true)\n        finish(4)\n    }\n\n    @Test\n    fun testUnhandledExceptionOnExternalCancellation() = runTest {\n        expect(1)\n        // No parent here (NonCancellable), so nowhere to propagate exception\n        val result = future(NonCancellable + Dispatchers.Unconfined) {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                expect(2)\n                throw TestException() // this exception cannot be handled and is set to be lost.\n            }\n        }\n        result.cancel(true)\n        finish(3)\n    }\n\n    /** This test ensures that we never pass [CancellationException] to [CoroutineExceptionHandler]. */\n    @Test\n    fun testCancellationExceptionOnExternalCancellation() = runTest {\n        expect(1)\n        // No parent here (NonCancellable), so nowhere to propagate exception\n        val result = future(NonCancellable + Dispatchers.Unconfined) {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                expect(2)\n                throw TestCancellationException() // this exception cannot be handled\n            }\n        }\n        assertTrue(result.cancel(true))\n        finish(3)\n    }\n\n    @Test\n    fun testCancellingFutureContextJobCancelsFuture() = runTest {\n        expect(1)\n        val supervisorJob = SupervisorJob()\n        val future = future(context = supervisorJob) {\n            expect(2)\n            try {\n                delay(Long.MAX_VALUE)\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(4)\n                throw e\n            }\n        }\n        yield()\n        expect(3)\n        supervisorJob.cancel(CancellationException(\"Parent cancelled\", TestException()))\n        supervisorJob.join()\n        assertTrue(future.isDone)\n        assertTrue(future.isCancelled)\n        val thrown = assertFailsWith<CancellationException> { future.get() }\n        val cause = thrown.cause\n        assertNotNull(cause)\n        assertIs<CancellationException>(cause)\n        assertEquals(\"Parent cancelled\", cause.message)\n        assertIs<TestException>(cause.cause)\n        finish(5)\n    }\n\n    @Test\n    fun testFutureChildException() = runTest {\n        val future = future(context = NonCancellable + Dispatchers.Unconfined) {\n            val foo = async { delay(Long.MAX_VALUE); 42 }\n            val bar = async<Int> { throw TestException() }\n            foo.await() + bar.await()\n        }\n        future.checkFutureException<TestException>()\n    }\n\n    @Test\n    fun testFutureIsDoneAfterChildrenCompleted() = runTest {\n        expect(1)\n        val testException = TestException()\n        // Don't propagate exception to the test and use different dispatchers as we are going to block test thread.\n        val future = future(context = NonCancellable + Dispatchers.Default) {\n            val foo = async {\n                try {\n                    delay(Long.MAX_VALUE)\n                    42\n                } finally {\n                    withContext(NonCancellable) {\n                        delay(200)\n                    }\n                }\n            }\n            foo.invokeOnCompletion {\n                expect(3)\n            }\n            val bar = async<Int> { throw testException }\n            foo.await() + bar.await()\n        }\n        yield()\n        expect(2)\n        // Blocking get should succeed after internal coroutine completes.\n        val thrown = assertFailsWith<ExecutionException> { future.get() }\n        expect(4)\n        assertEquals(testException, thrown.cause)\n        finish(5)\n    }\n\n    @Test\n    @Ignore  // TODO: propagate cancellation before running listeners.\n    fun testFuturePropagatesCancellationBeforeRunningListeners() = runTest {\n        expect(1)\n        val future = future(context = Dispatchers.Unconfined) {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                expect(3) // Cancelled.\n            }\n        }\n        future.addListener(Runnable { expect(4) }, MoreExecutors.directExecutor())\n        assertFalse(future.isDone)\n        expect(2)\n        future.cancel(false)\n        assertTrue(future.isDone)\n        assertTrue(future.isCancelled)\n        finish(5)\n    }\n\n    @Test\n    fun testFutureCompletedExceptionally() = runTest {\n        val testException = TestException()\n        // NonCancellable to not propagate error to this scope.\n        val future = future(context = NonCancellable) {\n            throw testException\n        }\n        yield()\n        assertTrue(future.isDone)\n        assertFalse(future.isCancelled)\n        val thrown = assertFailsWith<ExecutionException> { future.get() }\n        assertEquals(testException, thrown.cause)\n    }\n\n    @Test\n    fun testAsListenableFutureCompletedExceptionally() = runTest {\n        val testException = TestException()\n        val deferred = CompletableDeferred<String>().apply {\n            completeExceptionally(testException)\n        }\n        val asListenableFuture = deferred.asListenableFuture()\n        assertTrue(asListenableFuture.isDone)\n        assertFalse(asListenableFuture.isCancelled)\n        val thrown = assertFailsWith<ExecutionException> { asListenableFuture.get() }\n        assertEquals(testException, thrown.cause)\n    }\n\n    private inline fun <reified T: Throwable> ListenableFuture<*>.checkFutureException() {\n        val e = assertFailsWith<ExecutionException> { get() }\n        val cause = e.cause!!\n        assertIs<T>(cause)\n    }\n\n    @Suppress(\"SuspendFunctionOnCoroutineScope\")\n    private suspend fun CoroutineScope.awaitFutureWithCancel(cancellable: Boolean): ListenableFuture<Int> {\n        val latch = CountDownLatch(1)\n        val executor = MoreExecutors.listeningDecorator(ForkJoinPool.commonPool())\n        val future = executor.submit(Callable { latch.await(); 42 })\n        val deferred = async {\n            expect(2)\n            if (cancellable) future.await()\n            else future.asDeferred().await()\n        }\n        expect(1)\n        yield()\n        deferred.cancel()\n        expect(3)\n        latch.countDown()\n        return future\n    }\n\n    @Test\n    fun testCancelledParent() = runTest({ it is CancellationException }) {\n        cancel()\n        future { expectUnreached() }\n        future(start = CoroutineStart.ATOMIC) { }\n        future(start = CoroutineStart.UNDISPATCHED) { }\n    }\n\n    @Test\n    fun testStackOverflow() = runTest {\n        val future = SettableFuture.create<Int>()\n        val completed = AtomicLong()\n        val count = 10000L\n        val children = ArrayList<Job>()\n        for (i in 0 until count) {\n            children += launch(Dispatchers.Default) {\n                future.asDeferred().await()\n                completed.incrementAndGet()\n            }\n        }\n        future.set(1)\n        withTimeout(60_000) {\n            children.forEach { it.join() }\n            assertEquals(count, completed.get())\n        }\n    }\n\n    @Test\n    fun testFuturePropagatesExceptionToParentAfterCancellation() = runTest {\n        val throwLatch = CompletableDeferred<Boolean>()\n        val cancelLatch = CompletableDeferred<Boolean>()\n        val parent = Job()\n        val scope = CoroutineScope(parent)\n        val exception = TestException(\"propagated to parent\")\n        val future = scope.future {\n            cancelLatch.complete(true)\n            withContext(NonCancellable) {\n                throwLatch.await()\n                throw exception\n            }\n        }\n        cancelLatch.await()\n        future.cancel(true)\n        throwLatch.complete(true)\n        parent.join()\n        assertTrue(parent.isCancelled)\n        assertEquals(exception, parent.getCancellationException().cause)\n    }\n\n    // Stress tests.\n\n    @Test\n    fun testFutureDoesNotReportToCoroutineExceptionHandler() = runTest {\n        repeat(1000) {\n            supervisorScope { // Don't propagate failures in children to parent and other children.\n                val innerFuture = SettableFuture.create<Unit>()\n                val outerFuture = async { innerFuture.await() }\n\n                withContext(Dispatchers.Default) {\n                    launch { innerFuture.setException(TestException(\"can be lost\")) }\n                    launch { outerFuture.cancel() }\n                    // nothing should be reported to CoroutineExceptionHandler, otherwise `Future.cancel` contract violation.\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testJobListenableFutureIsCancelledDoesNotThrow() = runTest {\n        repeat(1000) {\n            val deferred = CompletableDeferred<String>()\n            val asListenableFuture = deferred.asListenableFuture()\n            // We heed two threads to test a race condition.\n            withContext(Dispatchers.Default) {\n                val cancellationJob = launch {\n                    asListenableFuture.cancel(false)\n                }\n                while (!cancellationJob.isCompleted) {\n                    asListenableFuture.isCancelled // Shouldn't throw.\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "integration/kotlinx-coroutines-guava/test/ListenableFutureToStringTest.kt",
        "content": "package kotlinx.coroutines.guava\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass ListenableFutureToStringTest : TestBase() {\n    @Test\n    fun testSuccessfulFuture() = runTest {\n        val deferred = CompletableDeferred(\"OK\")\n        val succeededFuture = deferred.asListenableFuture()\n        val toString = succeededFuture.toString()\n        assertTrue(message = \"Unexpected format: $toString\") {\n            toString.matches(Regex(\"\"\"kotlinx\\.coroutines\\.guava\\.JobListenableFuture@[^\\[]*\\[status=SUCCESS, result=\\[OK]]\"\"\"))\n        }\n    }\n\n    @Test\n    fun testFailedFuture() = runTest {\n        val exception = TestRuntimeException(\"test\")\n        val deferred = CompletableDeferred<String>().apply {\n            completeExceptionally(exception)\n        }\n        val failedFuture = deferred.asListenableFuture()\n        val toString = failedFuture.toString()\n        assertTrue(message = \"Unexpected format: $toString\") {\n            toString.matches(Regex(\"\"\"kotlinx\\.coroutines\\.guava\\.JobListenableFuture@[^\\[]*\\[status=FAILURE, cause=\\[$exception]]\"\"\"))\n        }\n    }\n\n    @Test\n    fun testPendingFuture() = runTest {\n        val deferred = CompletableDeferred<String>()\n        val pendingFuture = deferred.asListenableFuture()\n        val toString = pendingFuture.toString()\n        assertTrue(message = \"Unexpected format: $toString\") {\n            toString.matches(Regex(\"\"\"kotlinx\\.coroutines\\.guava\\.JobListenableFuture@[^\\[]*\\[status=PENDING, delegate=\\[.*]]\"\"\"))\n        }\n    }\n\n    @Test\n    fun testCancelledCoroutineAsListenableFuture() = runTest {\n        val exception = CancellationException(\"test\")\n        val deferred = CompletableDeferred<String>().apply {\n            cancel(exception)\n        }\n        val cancelledFuture = deferred.asListenableFuture()\n        val toString = cancelledFuture.toString()\n        assertTrue(message = \"Unexpected format: $toString\") {\n            toString.matches(Regex(\"\"\"kotlinx\\.coroutines\\.guava\\.JobListenableFuture@[^\\[]*\\[status=CANCELLED, cause=\\[$exception]]\"\"\"))\n        }\n    }\n\n    @Test\n    fun testCancelledFuture() = runTest {\n        val deferred = CompletableDeferred<String>()\n        val cancelledFuture = deferred.asListenableFuture().apply {\n            cancel(false)\n        }\n        val toString = cancelledFuture.toString()\n        assertTrue(message = \"Unexpected format: $toString\") {\n            toString.matches(Regex(\"\"\"kotlinx\\.coroutines\\.guava\\.JobListenableFuture@[^\\[]*\\[status=CANCELLED]\"\"\"))\n        }\n    }\n}\n"
    },
    {
        "path": "integration/kotlinx-coroutines-jdk8/build.gradle.kts",
        "content": ""
    },
    {
        "path": "integration/kotlinx-coroutines-play-services/build.gradle.kts",
        "content": "val tasksVersion = \"16.0.1\"\n\nproject.configureAar()\n\ndependencies {\n    configureAarUnpacking()\n    api(\"com.google.android.gms:play-services-tasks:$tasksVersion\") {\n        exclude(group=\"com.android.support\")\n    }\n\n    // Required by robolectric\n    testImplementation(\"androidx.test:core:1.2.0\")\n    testImplementation(\"androidx.test:monitor:1.2.0\")\n}\n\nexternalDocumentationLink(\n    url = \"https://developers.google.com/android/reference/\"\n)\n"
    },
    {
        "path": "integration/kotlinx-coroutines-play-services/src/Tasks.kt",
        "content": "@file:Suppress(\"RedundantVisibilityModifier\")\n\npackage kotlinx.coroutines.tasks\n\nimport com.google.android.gms.tasks.*\nimport kotlinx.coroutines.*\nimport java.lang.Runnable\nimport java.util.concurrent.Executor\nimport kotlin.coroutines.*\n\n/**\n * Converts this deferred to the instance of [Task].\n * If deferred is cancelled then resulting task will be cancelled as well.\n */\npublic fun <T> Deferred<T>.asTask(): Task<T> {\n    val cancellation = CancellationTokenSource()\n    val source = TaskCompletionSource<T>(cancellation.token)\n\n    invokeOnCompletion callback@{\n        if (it is CancellationException) {\n            cancellation.cancel()\n            return@callback\n        }\n\n        val t = getCompletionExceptionOrNull()\n        if (t == null) {\n            source.setResult(getCompleted())\n        } else {\n            source.setException(t as? Exception ?: RuntimeExecutionException(t))\n        }\n    }\n\n    return source.task\n}\n\n/**\n * Converts this task to an instance of [Deferred].\n * If task is cancelled then resulting deferred will be cancelled as well.\n * However, the opposite is not true: if the deferred is cancelled, the [Task] will not be cancelled.\n * For bi-directional cancellation, an overload that accepts [CancellationTokenSource] can be used.\n */\npublic fun <T> Task<T>.asDeferred(): Deferred<T> = asDeferredImpl(null)\n\n/**\n * Converts this task to an instance of [Deferred] with a [CancellationTokenSource] to control cancellation.\n * The cancellation of this function is bi-directional:\n * - If the given task is cancelled, the resulting deferred will be cancelled.\n * - If the resulting deferred is cancelled, the provided [cancellationTokenSource] will be cancelled.\n *\n * Providing a [CancellationTokenSource] that is unrelated to the receiving [Task] is not supported and\n * leads to an unspecified behaviour.\n */\n@ExperimentalCoroutinesApi // Since 1.5.1, tentatively until 1.6.0\npublic fun <T> Task<T>.asDeferred(cancellationTokenSource: CancellationTokenSource): Deferred<T> =\n    asDeferredImpl(cancellationTokenSource)\n\nprivate fun <T> Task<T>.asDeferredImpl(cancellationTokenSource: CancellationTokenSource?): Deferred<T> {\n    val deferred = CompletableDeferred<T>()\n    if (isComplete) {\n        val e = exception\n        if (e == null) {\n            if (isCanceled) {\n                deferred.cancel()\n            } else {\n                @Suppress(\"UNCHECKED_CAST\")\n                deferred.complete(result as T)\n            }\n        } else {\n            deferred.completeExceptionally(e)\n        }\n    } else {\n        // Run the callback directly to avoid unnecessarily scheduling on the main thread.\n        addOnCompleteListener(DirectExecutor) {\n            val e = it.exception\n            if (e == null) {\n                @Suppress(\"UNCHECKED_CAST\")\n                if (it.isCanceled) deferred.cancel() else deferred.complete(it.result as T)\n            } else {\n                deferred.completeExceptionally(e)\n            }\n        }\n    }\n\n    if (cancellationTokenSource != null) {\n        deferred.invokeOnCompletion {\n            cancellationTokenSource.cancel()\n        }\n    }\n    // Prevent casting to CompletableDeferred and manual completion.\n    return object : Deferred<T> by deferred {}\n}\n\n/**\n * Awaits the completion of the task without blocking a thread.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function\n * stops waiting for the completion stage and immediately resumes with [CancellationException].\n *\n * For bi-directional cancellation, an overload that accepts [CancellationTokenSource] can be used.\n */\npublic suspend fun <T> Task<T>.await(): T = awaitImpl(null)\n\n/**\n * Awaits the completion of the task that is linked to the given [CancellationTokenSource] to control cancellation.\n *\n * This suspending function is cancellable and cancellation is bi-directional:\n * - If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function\n * cancels the [cancellationTokenSource] and throws a [CancellationException].\n * - If the task is cancelled, then this function will throw a [CancellationException].\n *\n * Providing a [CancellationTokenSource] that is unrelated to the receiving [Task] is not supported and\n * leads to an unspecified behaviour.\n */\n@ExperimentalCoroutinesApi // Since 1.5.1, tentatively until 1.6.0\npublic suspend fun <T> Task<T>.await(cancellationTokenSource: CancellationTokenSource): T =\n    awaitImpl(cancellationTokenSource)\n\nprivate suspend fun <T> Task<T>.awaitImpl(cancellationTokenSource: CancellationTokenSource?): T {\n    // fast path\n    if (isComplete) {\n        val e = exception\n        return if (e == null) {\n            if (isCanceled) {\n                throw CancellationException(\"Task $this was cancelled normally.\")\n            } else {\n                @Suppress(\"UNCHECKED_CAST\")\n                result as T\n            }\n        } else {\n            throw e\n        }\n    }\n\n    return suspendCancellableCoroutine { cont ->\n        // Run the callback directly to avoid unnecessarily scheduling on the main thread.\n        addOnCompleteListener(DirectExecutor) {\n            val e = it.exception\n            if (e == null) {\n                @Suppress(\"UNCHECKED_CAST\")\n                if (it.isCanceled) cont.cancel() else cont.resume(it.result as T)\n            } else {\n                cont.resumeWithException(e)\n            }\n        }\n\n        if (cancellationTokenSource != null) {\n            cont.invokeOnCancellation {\n                cancellationTokenSource.cancel()\n            }\n        }\n    }\n}\n\n/**\n * An [Executor] that just directly executes the [Runnable].\n */\nprivate object DirectExecutor : Executor {\n    override fun execute(r: Runnable) {\n        r.run()\n    }\n}\n"
    },
    {
        "path": "integration/kotlinx-coroutines-play-services/test/FakeAndroid.kt",
        "content": "package android.os\n\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\nimport java.util.concurrent.*\n\nclass Handler(val looper: Looper) {\n    fun post(r: Runnable): Boolean {\n        try {\n            GlobalScope.launch { r.run() }\n        } catch (e: RejectedExecutionException) {\n            // Execute leftover callbacks in place for tests\n            r.run()\n        }\n\n        return true\n    }\n}\n\nclass Looper {\n    companion object {\n        @JvmStatic\n        fun getMainLooper() = Looper()\n    }\n}\n"
    },
    {
        "path": "integration/kotlinx-coroutines-play-services/test/TaskTest.kt",
        "content": "package kotlinx.coroutines.tasks\n\nimport kotlinx.coroutines.testing.*\nimport com.google.android.gms.tasks.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.locks.*\nimport kotlin.concurrent.*\nimport kotlin.test.*\n\nclass TaskTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"ForkJoinPool.commonPool-worker-\")\n    }\n\n    @Test\n    fun testCompletedDeferredAsTask() = runTest {\n        expect(1)\n        val deferred = async(start = CoroutineStart.UNDISPATCHED) {\n            expect(2) // Completed immediately\n            \"OK\"\n        }\n        expect(3)\n        val task = deferred.asTask()\n        assertEquals(\"OK\", task.await())\n        finish(4)\n    }\n\n    @Test\n    fun testDeferredAsTask() = runTest {\n        expect(1)\n        val deferred = async {\n            expect(3) // Completed later\n            \"OK\"\n        }\n        expect(2)\n        val task = deferred.asTask()\n        assertEquals(\"OK\", task.await())\n        finish(4)\n    }\n\n    @Test\n    fun testCancelledAsTask() = runTest {\n        val deferred = async(Dispatchers.Default) {\n            delay(100)\n        }.apply { cancel() }\n\n        val task = deferred.asTask()\n        try {\n            runTest { task.await() }\n        } catch (e: Exception) {\n            assertIs<CancellationException>(e)\n            assertTrue(task.isCanceled)\n        }\n    }\n\n    @Test\n    fun testThrowingAsTask() = runTest({ e -> e is TestException }) {\n        val deferred = async<Int>(Dispatchers.Default) {\n            throw TestException(\"Fail\")\n        }\n\n        val task = deferred.asTask()\n        runTest(expected = { it is TestException }) {\n            task.await()\n        }\n    }\n\n    @Test\n    fun testStateAsTask() = runTest {\n        val lock = ReentrantLock().apply { lock() }\n\n        val deferred: Deferred<Int> = Tasks.call {\n            lock.withLock { 42 }\n        }.asDeferred()\n\n        assertFalse(deferred.isCompleted)\n        lock.unlock()\n\n        assertEquals(42, deferred.await())\n        assertTrue(deferred.isCompleted)\n    }\n\n    @Test\n    fun testTaskAsDeferred() = runTest {\n        val deferred = Tasks.forResult(42).asDeferred()\n        assertEquals(42, deferred.await())\n    }\n\n    @Test\n    fun testNullResultTaskAsDeferred() = runTest {\n        assertNull(Tasks.forResult(null).asDeferred().await())\n    }\n\n    @Test\n    fun testCancelledTaskAsDeferred() = runTest {\n        val deferred = Tasks.forCanceled<Int>().asDeferred()\n\n        assertTrue(deferred.isCancelled)\n        try {\n            deferred.await()\n            fail(\"deferred.await() should be cancelled\")\n        } catch (e: Exception) {\n            assertIs<CancellationException>(e)\n        }\n    }\n\n    @Test\n    fun testFailedTaskAsDeferred() = runTest {\n        val deferred = Tasks.forException<Int>(TestException(\"something went wrong\")).asDeferred()\n\n        assertTrue(deferred.isCancelled && deferred.isCompleted)\n        val completionException = deferred.getCompletionExceptionOrNull()!!\n        assertIs<TestException>(completionException)\n        assertEquals(\"something went wrong\", completionException.message)\n\n        try {\n            deferred.await()\n            fail(\"deferred.await() should throw an exception\")\n        } catch (e: Exception) {\n            assertIs<TestException>(e)\n            assertEquals(\"something went wrong\", e.message)\n        }\n    }\n\n    @Test\n    fun testFailingTaskAsDeferred() = runTest {\n        val lock = ReentrantLock().apply { lock() }\n\n        val deferred: Deferred<Int> = Tasks.call {\n            lock.withLock { throw TestException(\"something went wrong\") }\n        }.asDeferred()\n\n        assertFalse(deferred.isCompleted)\n        lock.unlock()\n\n        try {\n            deferred.await()\n            fail(\"deferred.await() should throw an exception\")\n        } catch (e: Exception) {\n            assertIs<TestException>(e)\n            assertEquals(\"something went wrong\", e.message)\n            assertSame(e.cause, deferred.getCompletionExceptionOrNull()) // debug mode stack augmentation\n        }\n    }\n\n    @Test\n    fun testCancellableTaskAsDeferred() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val deferred = Tasks.forResult(42).asDeferred(cancellationTokenSource)\n        assertEquals(42, deferred.await())\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testNullResultCancellableTaskAsDeferred() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        assertNull(Tasks.forResult(null).asDeferred(cancellationTokenSource).await())\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testCancelledCancellableTaskAsDeferred() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val deferred = Tasks.forCanceled<Int>().asDeferred(cancellationTokenSource)\n\n        assertTrue(deferred.isCancelled)\n        try {\n            deferred.await()\n            fail(\"deferred.await() should be cancelled\")\n        } catch (e: Exception) {\n            assertIs<CancellationException>(e)\n        }\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testCancellingCancellableTaskAsDeferred() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val task = TaskCompletionSource<Int>(cancellationTokenSource.token).task\n        val deferred = task.asDeferred(cancellationTokenSource)\n\n        deferred.cancel()\n        try {\n            deferred.await()\n            fail(\"deferred.await() should be cancelled\")\n        } catch (e: Exception) {\n            assertIs<CancellationException>(e)\n        }\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testExternallyCancelledCancellableTaskAsDeferred() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val task = TaskCompletionSource<Int>(cancellationTokenSource.token).task\n        val deferred = task.asDeferred(cancellationTokenSource)\n\n        cancellationTokenSource.cancel()\n\n        try {\n            deferred.await()\n            fail(\"deferred.await() should be cancelled\")\n        } catch (e: Exception) {\n            assertIs<CancellationException>(e)\n        }\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testSeparatelyCancelledCancellableTaskAsDeferred() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val task = TaskCompletionSource<Int>().task\n        task.asDeferred(cancellationTokenSource)\n\n        cancellationTokenSource.cancel()\n\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testFailedCancellableTaskAsDeferred() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val deferred =\n            Tasks.forException<Int>(TestException(\"something went wrong\")).asDeferred(cancellationTokenSource)\n\n        assertTrue(deferred.isCancelled && deferred.isCompleted)\n        val completionException = deferred.getCompletionExceptionOrNull()!!\n        assertIs<TestException>(completionException)\n        assertEquals(\"something went wrong\", completionException.message)\n\n        try {\n            deferred.await()\n            fail(\"deferred.await() should throw an exception\")\n        } catch (e: Exception) {\n            assertIs<TestException>(e)\n            assertEquals(\"something went wrong\", e.message)\n        }\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testFailingCancellableTaskAsDeferred() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val lock = ReentrantLock().apply { lock() }\n\n        val deferred: Deferred<Int> = Tasks.call {\n            lock.withLock { throw TestException(\"something went wrong\") }\n        }.asDeferred(cancellationTokenSource)\n\n        assertFalse(deferred.isCompleted)\n        lock.unlock()\n\n        try {\n            deferred.await()\n            fail(\"deferred.await() should throw an exception\")\n        } catch (e: Exception) {\n            assertIs<TestException>(e)\n            assertEquals(\"something went wrong\", e.message)\n            assertSame(e.cause, deferred.getCompletionExceptionOrNull()) // debug mode stack augmentation\n        }\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testFastPathCompletedTaskWithCancelledTokenSourceAsDeferred() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val deferred = Tasks.forResult(42).asDeferred(cancellationTokenSource)\n        cancellationTokenSource.cancel()\n        assertEquals(42, deferred.await())\n    }\n\n    @Test\n    fun testAwaitCancellableTask() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val taskCompletionSource = TaskCompletionSource<Int>(cancellationTokenSource.token)\n\n        val deferred: Deferred<Int> = async(start = CoroutineStart.UNDISPATCHED) {\n            taskCompletionSource.task.await(cancellationTokenSource)\n        }\n\n        assertFalse(deferred.isCompleted)\n        taskCompletionSource.setResult(42)\n\n        assertEquals(42, deferred.await())\n        assertTrue(deferred.isCompleted)\n    }\n\n    @Test\n    fun testFailedAwaitTask() = runTest(expected = { it is TestException }) {\n        val cancellationTokenSource = CancellationTokenSource()\n        val taskCompletionSource = TaskCompletionSource<Int>(cancellationTokenSource.token)\n\n        val deferred: Deferred<Int> = async(start = CoroutineStart.UNDISPATCHED) {\n            taskCompletionSource.task.await(cancellationTokenSource)\n        }\n\n        assertFalse(deferred.isCompleted)\n        taskCompletionSource.setException(TestException(\"something went wrong\"))\n\n        deferred.await()\n    }\n\n    @Test\n    fun testCancelledAwaitCancellableTask() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val taskCompletionSource = TaskCompletionSource<Int>(cancellationTokenSource.token)\n\n        val deferred: Deferred<Int> = async(start = CoroutineStart.UNDISPATCHED) {\n            taskCompletionSource.task.await(cancellationTokenSource)\n        }\n\n        assertFalse(deferred.isCompleted)\n        // Cancel the deferred\n        deferred.cancel()\n\n        try {\n            deferred.await()\n            fail(\"deferred.await() should be cancelled\")\n        } catch (e: Exception) {\n            assertIs<CancellationException>(e)\n        }\n\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testExternallyCancelledAwaitCancellableTask() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        val taskCompletionSource = TaskCompletionSource<Int>(cancellationTokenSource.token)\n\n        val deferred: Deferred<Int> = async(start = CoroutineStart.UNDISPATCHED) {\n            taskCompletionSource.task.await(cancellationTokenSource)\n        }\n\n        assertFalse(deferred.isCompleted)\n        // Cancel the cancellation token source\n        cancellationTokenSource.cancel()\n\n        try {\n            deferred.await()\n            fail(\"deferred.await() should be cancelled\")\n        } catch (e: Exception) {\n            assertIs<CancellationException>(e)\n        }\n\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n    }\n\n    @Test\n    fun testFastPathCancellationTokenSourceCancelledAwaitCancellableTask() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        // Construct a task without the cancellation token source\n        val taskCompletionSource = TaskCompletionSource<Int>()\n\n        val deferred: Deferred<Int> = async(start = CoroutineStart.LAZY) {\n            taskCompletionSource.task.await(cancellationTokenSource)\n        }\n\n        assertFalse(deferred.isCompleted)\n        cancellationTokenSource.cancel()\n\n        // Cancelling the token doesn't cancel the deferred\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n        assertFalse(deferred.isCompleted)\n\n        // Cleanup\n        deferred.cancel()\n    }\n\n    @Test\n    fun testSlowPathCancellationTokenSourceCancelledAwaitCancellableTask() = runTest {\n        val cancellationTokenSource = CancellationTokenSource()\n        // Construct a task without the cancellation token source\n        val taskCompletionSource = TaskCompletionSource<Int>()\n\n        val deferred: Deferred<Int> = async(start = CoroutineStart.UNDISPATCHED) {\n            taskCompletionSource.task.await(cancellationTokenSource)\n        }\n\n        assertFalse(deferred.isCompleted)\n        cancellationTokenSource.cancel()\n\n        // Cancelling the token doesn't cancel the deferred\n        assertTrue(cancellationTokenSource.token.isCancellationRequested)\n        assertFalse(deferred.isCompleted)\n\n        // Cleanup\n        deferred.cancel()\n    }\n\n    @Test\n    fun testFastPathWithCompletedTaskAndCanceledTokenSourceAwaitTask() = runTest {\n        val firstCancellationTokenSource = CancellationTokenSource()\n        val secondCancellationTokenSource = CancellationTokenSource()\n        // Construct a task with a different cancellation token source\n        val taskCompletionSource = TaskCompletionSource<Int>(firstCancellationTokenSource.token)\n\n        val deferred: Deferred<Int> = async(start = CoroutineStart.LAZY) {\n            taskCompletionSource.task.await(secondCancellationTokenSource)\n        }\n\n        assertFalse(deferred.isCompleted)\n        secondCancellationTokenSource.cancel()\n\n        assertFalse(deferred.isCompleted)\n        taskCompletionSource.setResult(42)\n\n        assertEquals(42, deferred.await())\n        assertTrue(deferred.isCompleted)\n    }\n\n    class TestException(message: String) : Exception(message)\n}\n"
    },
    {
        "path": "integration/kotlinx-coroutines-slf4j/build.gradle.kts",
        "content": "dependencies {\n    implementation(\"org.slf4j:slf4j-api:1.7.32\")\n    testImplementation(\"io.github.microutils:kotlin-logging:2.1.0\")\n    testRuntimeOnly(\"ch.qos.logback:logback-classic:1.2.7\")\n    testRuntimeOnly(\"ch.qos.logback:logback-core:1.2.7\")\n}\n\nexternalDocumentationLink(\n    url = \"https://www.slf4j.org/apidocs/\"\n)\n"
    },
    {
        "path": "integration/kotlinx-coroutines-slf4j/src/MDCContext.kt",
        "content": "package kotlinx.coroutines.slf4j\n\nimport kotlinx.coroutines.*\nimport org.slf4j.MDC\nimport kotlin.coroutines.AbstractCoroutineContextElement\nimport kotlin.coroutines.CoroutineContext\n\n/**\n * The value of [MDC] context map.\n * See [MDC.getCopyOfContextMap].\n */\npublic typealias MDCContextMap = Map<String, String>?\n\n/**\n * [MDC] context element for [CoroutineContext].\n *\n * Example:\n *\n * ```\n * MDC.put(\"kotlin\", \"rocks\") // Put a value into the MDC context\n *\n * launch(MDCContext()) {\n *     logger.info { \"...\" }   // The MDC context contains the mapping here\n * }\n * ```\n *\n * Note that you cannot update MDC context from inside the coroutine simply\n * using [MDC.put]. These updates are going to be lost on the next suspension and\n * reinstalled to the MDC context that was captured or explicitly specified in\n * [contextMap] when this object was created on the next resumption.\n *\n * For example, the following code will not work as expected:\n *\n * ```\n * launch(MDCContext()) {\n *    MDC.put(\"key\", \"value\") // This update will be lost\n *    delay(100)\n *    println(MDC.get(\"key\")) // This will print null\n * }\n * ```\n *\n * Instead, you should use [withContext] to capture the updated MDC context:\n *\n * ```\n * launch(MDCContext()) {\n *     MDC.put(\"key\", \"value\") // This update will be captured\n *     withContext(MDCContext()) {\n *         delay(100)\n *         println(MDC.get(\"key\")) // This will print \"value\"\n *     }\n * }\n * ```\n *\n * There is no way to implicitly propagate MDC context updates from inside the coroutine to the outer scope.\n * You have to capture the updated MDC context and restore it explicitly. For example:\n *\n * ```\n * MDC.put(\"a\", \"b\")\n * val contextMap = withContext(MDCContext()) {\n *     MDC.put(\"key\", \"value\")\n *     withContext(MDCContext()) {\n *         MDC.put(\"key2\", \"value2\")\n *         withContext(MDCContext()) {\n *             yield()\n *             MDC.getCopyOfContextMap()\n *         }\n *     }\n * }\n * // contextMap contains: {\"a\"=\"b\", \"key\"=\"value\", \"key2\"=\"value2\"}\n * MDC.setContextMap(contextMap)\n * ```\n *\n * @param contextMap the value of [MDC] context map.\n * Default value is the copy of the current thread's context map that is acquired via\n * [MDC.getCopyOfContextMap].\n */\npublic class MDCContext(\n    /**\n     * The value of [MDC] context map.\n     */\n    @Suppress(\"MemberVisibilityCanBePrivate\")\n    public val contextMap: MDCContextMap = MDC.getCopyOfContextMap()\n) : ThreadContextElement<MDCContextMap>, AbstractCoroutineContextElement(Key) {\n    /**\n     * Key of [MDCContext] in [CoroutineContext].\n     */\n    public companion object Key : CoroutineContext.Key<MDCContext>\n\n    /** @suppress */\n    override fun updateThreadContext(context: CoroutineContext): MDCContextMap {\n        val oldState = MDC.getCopyOfContextMap()\n        setCurrent(contextMap)\n        return oldState\n    }\n\n    /** @suppress */\n    override fun restoreThreadContext(context: CoroutineContext, oldState: MDCContextMap) {\n        setCurrent(oldState)\n    }\n\n    private fun setCurrent(contextMap: MDCContextMap) {\n        if (contextMap == null) {\n            MDC.clear()\n        } else {\n            MDC.setContextMap(contextMap)\n        }\n    }\n}\n"
    },
    {
        "path": "integration/kotlinx-coroutines-slf4j/test/MDCContextTest.kt",
        "content": "package kotlinx.coroutines.slf4j\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport org.slf4j.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass MDCContextTest : TestBase() {\n    @Before\n    fun setUp() {\n        MDC.clear()\n    }\n\n    @After\n    fun tearDown() {\n        MDC.clear()\n    }\n\n    @Test\n    fun testContextIsNotPassedByDefaultBetweenCoroutines() = runTest {\n        expect(1)\n        MDC.put(\"myKey\", \"myValue\")\n        // Standalone launch\n        GlobalScope.launch {\n            assertNull(MDC.get(\"myKey\"))\n            expect(2)\n        }.join()\n        finish(3)\n    }\n\n    @Test\n    fun testContextCanBePassedBetweenCoroutines() = runTest {\n        expect(1)\n        MDC.put(\"myKey\", \"myValue\")\n        // Scoped launch with MDCContext element\n        launch(MDCContext()) {\n            assertEquals(\"myValue\", MDC.get(\"myKey\"))\n            expect(2)\n        }.join()\n\n        finish(3)\n    }\n\n    @Test\n    fun testContextInheritance() = runTest {\n        expect(1)\n        MDC.put(\"myKey\", \"myValue\")\n        withContext(MDCContext()) {\n            MDC.put(\"myKey\", \"myValue2\")\n            // Scoped launch with inherited MDContext element\n            launch(Dispatchers.Default) {\n                assertEquals(\"myValue\", MDC.get(\"myKey\"))\n                expect(2)\n            }.join()\n\n            finish(3)\n        }\n        assertEquals(\"myValue\", MDC.get(\"myKey\"))\n    }\n\n    @Test\n    fun testContextPassedWhileOnMainThread() {\n        MDC.put(\"myKey\", \"myValue\")\n        // No MDCContext element\n        runBlocking {\n            assertEquals(\"myValue\", MDC.get(\"myKey\"))\n        }\n    }\n\n    @Test\n    fun testContextCanBePassedWhileOnMainThread() {\n        MDC.put(\"myKey\", \"myValue\")\n        runBlocking(MDCContext()) {\n            assertEquals(\"myValue\", MDC.get(\"myKey\"))\n        }\n    }\n\n    @Test\n    fun testContextNeededWithOtherContext() {\n        MDC.put(\"myKey\", \"myValue\")\n        runBlocking(MDCContext()) {\n            assertEquals(\"myValue\", MDC.get(\"myKey\"))\n        }\n    }\n\n    @Test\n    fun testContextMayBeEmpty() {\n        runBlocking(MDCContext()) {\n            assertNull(MDC.get(\"myKey\"))\n        }\n    }\n\n    @Test\n    fun testContextWithContext() = runTest {\n        MDC.put(\"myKey\", \"myValue\")\n        val mainDispatcher = kotlin.coroutines.coroutineContext[ContinuationInterceptor]!!\n        withContext(Dispatchers.Default + MDCContext()) {\n            assertEquals(\"myValue\", MDC.get(\"myKey\"))\n            assertEquals(\"myValue\", coroutineContext[MDCContext]?.contextMap?.get(\"myKey\"))\n            withContext(mainDispatcher) {\n                assertEquals(\"myValue\", MDC.get(\"myKey\"))\n            }\n        }\n    }\n\n    /** Tests that the initially captured MDC context gets restored after suspension. */\n    @Test\n    fun testSuspensionsUndoingMdcContextUpdates() = runTest {\n        MDC.put(\"a\", \"b\")\n        withContext(MDCContext()) {\n            MDC.put(\"key\", \"value\")\n            assertEquals(\"b\", MDC.get(\"a\"))\n            yield()\n            assertNull(MDC.get(\"key\"))\n            assertEquals(\"b\", MDC.get(\"a\"))\n        }\n    }\n\n    /** Tests capturing and restoring the MDC context. */\n    @Test\n    fun testRestoringMdcContext() = runTest {\n        MDC.put(\"a\", \"b\")\n        val contextMap = withContext(MDCContext()) {\n            MDC.put(\"key\", \"value\")\n            assertEquals(\"b\", MDC.get(\"a\"))\n            withContext(MDCContext()) {\n                assertEquals(\"value\", MDC.get(\"key\"))\n                MDC.put(\"key2\", \"value2\")\n                assertEquals(\"value2\", MDC.get(\"key2\"))\n                withContext(MDCContext()) {\n                    yield()\n                    MDC.getCopyOfContextMap()\n                }\n            }\n        }\n        MDC.setContextMap(contextMap)\n        assertEquals(\"value2\", MDC.get(\"key2\"))\n        assertEquals(\"value\", MDC.get(\"key\"))\n        assertEquals(\"b\", MDC.get(\"a\"))\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-bom/build.gradle.kts",
        "content": "import org.gradle.api.publish.maven.internal.publication.DefaultMavenPublication\n\nplugins {\n    id(\"java-platform\")\n}\n\nval name = project.name\n\ndependencies {\n    constraints {\n        rootProject.subprojects.forEach {\n            if (unpublished.contains(it.name)) return@forEach\n            if (it.name == name) return@forEach\n            if (!it.plugins.hasPlugin(\"maven-publish\")) return@forEach\n            evaluationDependsOn(it.path)\n            it.publishing.publications.all {\n                this as MavenPublication\n                if (artifactId.endsWith(\"-kotlinMultiplatform\")) return@all\n                if (artifactId.endsWith(\"-metadata\")) return@all\n                // Skip platform artifacts (like *-linuxx64, *-macosx64)\n                // It leads to inconsistent bom when publishing from different platforms\n                // (e.g. on linux it will include only linuxx64 artifacts and no macosx64)\n                // It shouldn't be a problem as usually consumers need to use generic *-native artifact\n                // Gradle will choose correct variant by using metadata attributes\n                if (artifacts.any { it.extension == \"klib\" }) return@all\n                this@constraints.api(mapOf(\"group\" to groupId, \"name\" to artifactId, \"version\" to version))\n            }\n        }\n    }\n}\n\npublishing {\n    publications {\n        val mavenBom by creating(MavenPublication::class) {\n            from(components[\"javaPlatform\"])\n        }\n        // Disable metadata publication\n        forEach { pub ->\n            pub as DefaultMavenPublication\n            pub.unsetModuleDescriptorGenerator()\n            tasks.matching { it.name == \"generateMetadataFileFor${pub.name.capitalize()}Publication\" }.all {\n                onlyIf { false }\n            }\n        }\n    }\n}\n\nfun DefaultMavenPublication.unsetModuleDescriptorGenerator() {\n    @Suppress(\"NULL_FOR_NONNULL_TYPE\")\n    val generator: TaskProvider<Task> = null\n    setModuleDescriptorGenerator(generator)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/build.gradle.kts",
        "content": "import org.gradle.api.tasks.testing.*\nimport org.gradle.kotlin.dsl.*\nimport org.jetbrains.kotlin.gradle.plugin.mpp.*\nimport org.jetbrains.kotlin.gradle.targets.native.tasks.*\nimport org.jetbrains.kotlin.gradle.tasks.*\nimport org.jetbrains.kotlin.gradle.testing.*\n\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"org.jetbrains.kotlinx.benchmark\")\n    id(\"org.jetbrains.dokka\")\n    id(\"org.jetbrains.kotlinx.kover\")\n}\n\napply(plugin = \"pub-conventions\")\n\n/* ==========================================================================\n  Configure source sets structure for kotlinx-coroutines-core:\n\n     TARGETS                            SOURCE SETS\n     -------         ----------------------------------------------\n     wasmJs \\----------> jsAndWasmShared --------------------+\n     js     /                                                |\n                                                             V\n     jvmCore\\ --------> jvm ---------> concurrent -------> common\n     jdk8   /                           ^\n                                        |\n     ios     \\                          |\n     macos   | ---> nativeDarwin ---> native ---+\n     tvos    |                         ^\n     watchos /                         |\n                                       |\n     linux  \\  ---> nativeOther -------+\n     mingw  /\n\n\nExplanation of JVM source sets structure:\n\nThe overall structure is just a hack to support the scenario we are interested in:\n\n* We would like to have two source-sets \"core\" and \"jdk8\"\n* \"jdk8\" is allowed to use API from Java 8 and from \"core\"\n* \"core\" is prohibited to use any API from \"jdk8\"\n* It is okay to have tests in a single test source-set\n* And we want to publish a **single** artifact kotlinx-coroutines-core.jar that contains classes from both source-sets\n* Current limitation: only classes from \"core\" are checked with animal-sniffer\n\nFor that, we have following compilations:\n* jvmMain compilation: [jvmCoreMain, jdk8Main]\n* jvmCore compilation: [commonMain]\n* jdk8    compilation: [commonMain, jvmCoreMain]\n\nTheoretically, \"jvmCore\" could've been \"jvmMain\", it is not for technical reasons,\nhere is the explanation from Seb:\n\n\"\"\"\nThe jvmCore is theoretically not necessary. All code for jdk6 compatibility can be in jvmMain and jdk8 dependent code can be in jdk8Main.\nEffectively there is no reason for ever putting code into jvmCoreMain.\nHowever, when creating a new compilation, we have to take care of creating a defaultSourceSet. Without creating the jvmCoreMain source set,\n the creation of the compilation fails. That is the only reason for this source set.\n\"\"\"\n ========================================================================== */\n\nkotlin {\n    sourceSets {\n        // using the source set names from <https://kotlinlang.org/docs/multiplatform-hierarchy.html#see-the-full-hierarchy-template>\n        groupSourceSets(\"concurrent\", listOf(\"jvm\", \"native\"), listOf(\"common\"))\n        if (project.nativeTargetsAreEnabled) {\n            // TODO: 'nativeDarwin' behaves exactly like 'apple', we can remove it\n            groupSourceSets(\"nativeDarwin\", listOf(\"apple\"), listOf(\"native\"))\n            groupSourceSets(\"nativeOther\", listOf(\"linux\", \"mingw\", \"androidNative\"), listOf(\"native\"))\n        }\n        jvmMain {\n            dependencies {\n                compileOnly(\"com.google.android:annotations:4.1.1.4\")\n            }\n        }\n        jvmTest {\n            dependencies {\n                api(\"org.jetbrains.kotlinx:lincheck:${version(\"lincheck\")}\")\n                api(\"org.jetbrains.kotlinx:kotlinx-knit-test:${version(\"knit\")}\")\n                implementation(project(\":android-unit-tests\"))\n                implementation(\"org.openjdk.jol:jol-core:0.16\")\n            }\n        }\n    }\n    /*\n     * Configure two test runs for Native:\n     * 1) Main thread\n     * 2) BG thread (required for Dispatchers.Main tests on Darwin)\n     *\n     * All new MM targets are build with optimize = true to have stress tests properly run.\n     */\n    targets.withType(KotlinNativeTargetWithTests::class).configureEach {\n        binaries.getTest(DEBUG).apply {\n            optimized = true\n        }\n\n        binaries.test(\"workerTest\", listOf(DEBUG)) {\n            val thisTest = this\n            optimized = true\n            freeCompilerArgs = freeCompilerArgs + listOf(\"-e\", \"kotlinx.coroutines.mainBackground\")\n            testRuns.create(\"workerTest\") {\n                this as KotlinTaskTestRun<*, *>\n                setExecutionSourceFrom(thisTest)\n                executionTask.configure {\n                    this as KotlinNativeTest\n                    targetName = \"$targetName worker with new MM\"\n                }\n            }\n        }\n    }\n\n    /**\n     * See: https://youtrack.jetbrains.com/issue/KTIJ-25959\n     * The introduction of jvmCore is only for CLI builds and not intended for the IDE.\n     * In the current setup there are two tooling unfriendly configurations used:\n     * 1: - jvmMain, despite being a platform source set, is not a leaf (jvmCoreMain and jdk8Main dependOn it)\n     * 2: - jvmMain effectively becomes a 'shared jvm' source set\n     *\n     * Using this kludge here, will prevent issue 2 from being visible to the IDE.\n     * Therefore jvmMain will resolve using the 'single' compilation it participates in (from the perspective of the IDE)\n     */\n    val jvmCoreMain = if (Idea.active) null else sourceSets.create(\"jvmCoreMain\") {\n        dependsOn(sourceSets.jvmMain.get())\n    }\n    val jdk8Main = sourceSets.create(\"jdk8Main\") {\n        dependsOn(sourceSets.jvmMain.get())\n    }\n\n    jvm {\n        compilations.named(\"main\") {\n            jvmCoreMain?.let { source(it) }\n            source(jdk8Main)\n        }\n\n        /* Create compilation for jvmCore to prove that jvmMain does not rely on jdk8 */\n        compilations.create(\"CoreMain\") {\n            /* jvmCore is automatically matched as 'defaultSourceSet' for the compilation, due to its name */\n            tasks.getByName(\"check\").dependsOn(compileTaskProvider)\n        }\n\n        // For animal sniffer\n        withJava()\n        compilations.create(\"benchmark\") { associateWith(this@jvm.compilations.getByName(\"main\")) }\n    }\n}\n\nbenchmark {\n    targets {\n        register(\"jvmBenchmark\")\n    }\n}\n\n// Update module name for metadata artifact to avoid conflicts\n// see https://github.com/Kotlin/kotlinx.coroutines/issues/1797\nval compileKotlinMetadata by tasks.getting(KotlinCompilationTask::class) {\n    compilerOptions {\n        freeCompilerArgs.addAll(\"-module-name\", \"kotlinx-coroutines-core-common\")\n    }\n}\n\nval jvmTest by tasks.getting(Test::class) {\n    minHeapSize = \"1g\"\n    maxHeapSize = \"1g\"\n    enableAssertions = true\n    if (!Idea.active) {\n        // We should not set this security manager when `jvmTest`\n        // is invoked by IntelliJ IDEA since we need to pass\n        // system properties for Lincheck and stress tests.\n        // TODO Remove once IDEA is smart enough to select between `jvmTest`/`jvmStressTest`/`jvmLincheckTest` #KTIJ-599\n        systemProperty(\"java.security.manager\", \"kotlinx.coroutines.TestSecurityManager\")\n    }\n    // 'stress' is required to be able to run all subpackage tests like \":jvmTests --tests \"*channels*\" -Pstress=true\"\n    if (!Idea.active && rootProject.properties[\"stress\"] == null) {\n        exclude(\"**/*LincheckTest*\")\n        exclude(\"**/*StressTest.*\")\n    }\n    if (Idea.active) {\n        // Configure the IDEA runner for Lincheck\n        configureJvmForLincheck()\n    }\n}\n\n// Setup manifest for kotlinx-coroutines-core-jvm.jar\nval jvmJar by tasks.getting(Jar::class) { setupManifest(this) }\n\n/*\n * Setup manifest for kotlinx-coroutines-core.jar\n * This is convenient for users that pass -javaagent arg manually and also is a workaround #2619 and KTIJ-5659.\n * This manifest contains reference to AgentPremain that belongs to\n * kotlinx-coroutines-core-jvm, but our resolving machinery guarantees that\n * any JVM project that depends on -core artifact also depends on -core-jvm one.\n */\nval allMetadataJar by tasks.getting(Jar::class) { setupManifest(this) }\n\nfun setupManifest(jar: Jar) {\n    jar.manifest {\n        attributes(mapOf(\n            \"Premain-Class\" to \"kotlinx.coroutines.debug.AgentPremain\",\n            \"Can-Retransform-Classes\" to \"true\",\n        ))\n    }\n}\n\nval compileTestKotlinJvm by tasks.getting(KotlinJvmCompile::class)\nval jvmTestClasses by tasks.getting\n\nval jvmStressTest by tasks.registering(Test::class) {\n    dependsOn(compileTestKotlinJvm)\n    classpath = jvmTest.classpath\n    testClassesDirs = jvmTest.testClassesDirs\n    minHeapSize = \"1g\"\n    maxHeapSize = \"1g\"\n    include(\"**/*StressTest.*\")\n    enableAssertions = true\n    testLogging.showStandardStreams = true\n    systemProperty(\"kotlinx.coroutines.scheduler.keep.alive.sec\", 100000) // any unpark problem hangs test\n    // Adjust internal algorithmic parameters to increase the testing quality instead of performance.\n    systemProperty(\"kotlinx.coroutines.semaphore.segmentSize\", 1)\n    systemProperty(\"kotlinx.coroutines.semaphore.maxSpinCycles\", 10)\n    systemProperty(\"kotlinx.coroutines.bufferedChannel.segmentSize\", 2)\n    systemProperty(\"kotlinx.coroutines.bufferedChannel.expandBufferCompletionWaitIterations\", 1)\n}\n\nval jvmLincheckTest by tasks.registering(Test::class) {\n    dependsOn(compileTestKotlinJvm)\n    classpath = jvmTest.classpath\n    testClassesDirs = jvmTest.testClassesDirs\n    include(\"**/*LincheckTest*\")\n    enableAssertions = true\n    testLogging.showStandardStreams = true\n    configureJvmForLincheck()\n}\n\n// Additional Lincheck tests with `segmentSize = 2`.\n// Some bugs cannot be revealed when storing one request per segment,\n// and some are hard to detect when storing multiple requests.\nval jvmLincheckTestAdditional by tasks.registering(Test::class) {\n    dependsOn(compileTestKotlinJvm)\n    classpath = jvmTest.classpath\n    testClassesDirs = jvmTest.testClassesDirs\n    include(\"**/RendezvousChannelLincheckTest*\")\n    include(\"**/Buffered1ChannelLincheckTest*\")\n    include(\"**/Semaphore*LincheckTest*\")\n    enableAssertions = true\n    testLogging.showStandardStreams = true\n    configureJvmForLincheck(segmentSize = 2)\n}\n\nfun Test.configureJvmForLincheck(segmentSize: Int = 1) {\n    minHeapSize = \"1g\"\n    maxHeapSize = \"4g\" // we may need more space for building an interleaving tree in the model checking mode\n    // https://github.com/JetBrains/lincheck#java-9\n    jvmArgs = listOf(\"--add-opens\", \"java.base/jdk.internal.misc=ALL-UNNAMED\",   // required for transformation\n        \"--add-exports\", \"java.base/sun.security.action=ALL-UNNAMED\",\n        \"--add-exports\", \"java.base/jdk.internal.util=ALL-UNNAMED\") // in the model checking mode\n    // Adjust internal algorithmic parameters to increase the testing quality instead of performance.\n    systemProperty(\"kotlinx.coroutines.semaphore.segmentSize\", segmentSize)\n    systemProperty(\"kotlinx.coroutines.semaphore.maxSpinCycles\", 1) // better for the model checking mode\n    systemProperty(\"kotlinx.coroutines.bufferedChannel.segmentSize\", segmentSize)\n    systemProperty(\"kotlinx.coroutines.bufferedChannel.expandBufferCompletionWaitIterations\", 1)\n}\n\n// Always check additional test sets\nval moreTest by tasks.registering {\n    dependsOn(listOf(jvmStressTest, jvmLincheckTest, jvmLincheckTestAdditional))\n}\n\nval check by tasks.getting {\n    dependsOn(moreTest)\n}\n\nkover {\n    currentProject {\n        instrumentation {\n            // Always disabled, lincheck doesn't really support coverage\n            disabledForTestTasks.addAll(\"jvmLincheckTest\")\n\n            // lincheck has NPE error on `ManagedStrategyStateHolder` class\n            excludedClasses.addAll(\"org.jetbrains.kotlinx.lincheck.*\")\n        }\n    }\n\n    reports {\n        filters {\n            excludes {\n                classes(\n                    \"kotlinx.coroutines.debug.*\", // Tested by debug module\n                    \"kotlinx.coroutines.channels.ChannelsKt__DeprecatedKt*\", // Deprecated\n                    \"kotlinx.coroutines.scheduling.LimitingDispatcher\", // Deprecated\n                    \"kotlinx.coroutines.scheduling.ExperimentalCoroutineDispatcher\", // Deprecated\n                    \"kotlinx.coroutines.flow.FlowKt__MigrationKt*\", // Migrations\n                    \"kotlinx.coroutines.flow.LintKt*\", // Migrations\n                    \"kotlinx.coroutines.internal.WeakMapCtorCache\", // Fallback implementation that we never test\n                    \"_COROUTINE._CREATION\", // For IDE navigation\n                    \"_COROUTINE._BOUNDARY\", // For IDE navigation\n                )\n            }\n        }\n    }\n}\n\nval testsJar by tasks.registering(Jar::class) {\n    dependsOn(jvmTestClasses)\n    archiveClassifier = \"tests\"\n    from(compileTestKotlinJvm.destinationDirectory)\n}\n\nartifacts {\n    archives(testsJar)\n}\n\n// Workaround for https://github.com/Kotlin/dokka/issues/1833: make implicit dependency explicit\ntasks.named(\"dokkaHtmlPartial\") {\n    dependsOn(jvmJar)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/AbstractCoroutine.kt",
        "content": "@file:Suppress(\"DEPRECATION_ERROR\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.CoroutineStart.*\nimport kotlinx.coroutines.intrinsics.*\nimport kotlin.coroutines.*\n\n/**\n * Abstract base class for implementation of coroutines in coroutine builders.\n *\n * This class implements completion [Continuation], [Job], and [CoroutineScope] interfaces.\n * It stores the result of continuation in the state of the job.\n * This coroutine waits for children coroutines to finish before completing and\n * fails through an intermediate _failing_ state.\n *\n * The following methods are available for override:\n *\n * - [onStart] is invoked when the coroutine was created in non-active state and is being [started][Job.start].\n * - [onCancelling] is invoked as soon as the coroutine starts being cancelled for any reason (or completes).\n * - [onCompleted] is invoked when the coroutine completes with a value.\n * - [onCancelled] in invoked when the coroutine completes with an exception (cancelled).\n *\n * @param parentContext the context of the parent coroutine.\n * @param initParentJob specifies whether the parent-child relationship should be instantiated directly\n *               in `AbstractCoroutine` constructor. If set to `false`, it's the responsibility of the child class\n *               to invoke [initParentJob] manually.\n * @param active when `true` (by default), the coroutine is created in the _active_ state, otherwise it is created in the _new_ state.\n *               See [Job] for details.\n *\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic abstract class AbstractCoroutine<in T>(\n    parentContext: CoroutineContext,\n    initParentJob: Boolean,\n    active: Boolean\n) : JobSupport(active), Job, Continuation<T>, CoroutineScope {\n\n    init {\n        /*\n         * Setup parent-child relationship between the parent in the context and the current coroutine.\n         * It may cause this coroutine to become _cancelling_ if the parent is already cancelled.\n         * It is dangerous to install parent-child relationship here if the coroutine class\n         * operates its state from within onCancelled or onCancelling\n         * (with exceptions for rx integrations that can't have any parent)\n         */\n        if (initParentJob) initParentJob(parentContext[Job])\n    }\n\n    /**\n     * The context of this coroutine that includes this coroutine as a [Job].\n     */\n    @Suppress(\"LeakingThis\")\n    public final override val context: CoroutineContext = parentContext + this\n\n    /**\n     * The context of this scope which is the same as the [context] of this coroutine.\n     */\n    public override val coroutineContext: CoroutineContext get() = context\n\n    override val isActive: Boolean get() = super.isActive\n\n    /**\n     * This function is invoked once when the job was completed normally with the specified [value],\n     * right before all the waiters for the coroutine's completion are notified.\n     */\n    protected open fun onCompleted(value: T) {}\n\n    /**\n     * This function is invoked once when the job was cancelled with the specified [cause],\n     * right before all the waiters for coroutine's completion are notified.\n     *\n     * **Note:** the state of the coroutine might not be final yet in this function and should not be queried.\n     * You can use [completionCause] and [completionCauseHandled] to recover parameters that we passed\n     * to this `onCancelled` invocation only when [isCompleted] returns `true`.\n     *\n     * @param cause The cancellation (failure) cause\n     * @param handled `true` if the exception was handled by parent (always `true` when it is a [CancellationException])\n     */\n    protected open fun onCancelled(cause: Throwable, handled: Boolean) {}\n\n    override fun cancellationExceptionMessage(): String = \"$classSimpleName was cancelled\"\n\n    @Suppress(\"UNCHECKED_CAST\")\n    protected final override fun onCompletionInternal(state: Any?) {\n        if (state is CompletedExceptionally)\n            onCancelled(state.cause, state.handled)\n        else\n            onCompleted(state as T)\n    }\n\n    /**\n     * Completes execution of this with coroutine with the specified result.\n     */\n    public final override fun resumeWith(result: Result<T>) {\n        val state = makeCompletingOnce(result.toState())\n        if (state === COMPLETING_WAITING_CHILDREN) return\n        afterResume(state)\n    }\n\n    protected open fun afterResume(state: Any?): Unit = afterCompletion(state)\n\n    internal final override fun handleOnCompletionException(exception: Throwable) {\n        handleCoroutineException(context, exception)\n    }\n\n    internal override fun nameString(): String {\n        val coroutineName = context.coroutineName ?: return super.nameString()\n        return \"\\\"$coroutineName\\\":${super.nameString()}\"\n    }\n\n    /**\n     * Starts this coroutine with the given code [block] and [start] strategy.\n     * This function shall be invoked at most once on this coroutine.\n     * \n     * - [DEFAULT] uses [startCoroutineCancellable].\n     * - [ATOMIC] uses [startCoroutine].\n     * - [UNDISPATCHED] uses [startCoroutineUndispatched].\n     * - [LAZY] does nothing.\n     */\n    public fun <R> start(start: CoroutineStart, receiver: R, block: suspend R.() -> T) {\n        start(block, receiver, this)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Annotations.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.flow.*\n\n/**\n * Marks declarations in the coroutines that are **delicate** &mdash;\n * they have limited use-case and shall be used with care in general code.\n * Any use of a delicate declaration has to be carefully reviewed to make sure it is\n * properly used and does not create problems like memory and resource leaks.\n * Carefully read documentation of any declaration marked as `DelicateCoroutinesApi`.\n */\n@MustBeDocumented\n@Retention(value = AnnotationRetention.BINARY)\n@RequiresOptIn(\n    level = RequiresOptIn.Level.WARNING,\n    message = \"This is a delicate API and its use requires care.\" +\n        \" Make sure you fully read and understand documentation of the declaration that is marked as a delicate API.\"\n)\npublic annotation class DelicateCoroutinesApi\n\n/**\n * Marks declarations that are still **experimental** in coroutines API, which means that the design of the\n * corresponding declarations has open issues which may (or may not) lead to their changes in the future.\n * Roughly speaking, there is a chance that those declarations will be deprecated in the near future or\n * the semantics of their behavior may change in some way that may break some code.\n */\n@MustBeDocumented\n@Retention(value = AnnotationRetention.BINARY)\n@Target(\n    AnnotationTarget.CLASS,\n    AnnotationTarget.ANNOTATION_CLASS,\n    AnnotationTarget.PROPERTY,\n    AnnotationTarget.FIELD,\n    AnnotationTarget.LOCAL_VARIABLE,\n    AnnotationTarget.VALUE_PARAMETER,\n    AnnotationTarget.CONSTRUCTOR,\n    AnnotationTarget.FUNCTION,\n    AnnotationTarget.PROPERTY_GETTER,\n    AnnotationTarget.PROPERTY_SETTER,\n    AnnotationTarget.TYPEALIAS\n)\n@RequiresOptIn(level = RequiresOptIn.Level.WARNING)\npublic annotation class ExperimentalCoroutinesApi\n\n/**\n * Marks [Flow]-related API as a feature preview.\n *\n * Flow preview has **no** backward compatibility guarantees, including both binary and source compatibility.\n * Its API and semantics can and will be changed in next releases.\n *\n * Feature preview can be used to evaluate its real-world strengths and weaknesses, gather and provide feedback.\n * According to the feedback, [Flow] will be refined on its road to stabilization and promotion to a stable API.\n *\n * The best way to speed up preview feature promotion is providing the feedback on the feature.\n */\n@MustBeDocumented\n@Retention(value = AnnotationRetention.BINARY)\n@RequiresOptIn(\n    level = RequiresOptIn.Level.WARNING,\n    message = \"This declaration is in a preview state and can be changed in a backwards-incompatible manner with a best-effort migration. \" +\n            \"Its usage should be marked with '@kotlinx.coroutines.FlowPreview' or '@OptIn(kotlinx.coroutines.FlowPreview::class)' \" +\n            \"if you accept the drawback of relying on preview API\"\n)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.TYPEALIAS, AnnotationTarget.PROPERTY)\npublic annotation class FlowPreview\n\n/**\n * Marks declarations that are **obsolete** in coroutines API, which means that the design of the corresponding\n * declarations has serious known flaws and they will be redesigned in the future.\n * Roughly speaking, these declarations will be deprecated in the future but there is no replacement for them yet,\n * so they cannot be deprecated right away.\n */\n@MustBeDocumented\n@Retention(value = AnnotationRetention.BINARY)\n@RequiresOptIn(level = RequiresOptIn.Level.WARNING)\npublic annotation class ObsoleteCoroutinesApi\n\n/**\n * Marks declarations that are **internal** in coroutines API, which means that should not be used outside of\n * `kotlinx.coroutines`, because their signatures and semantics will change between future releases without any\n * warnings and without providing any migration aids.\n */\n@Retention(value = AnnotationRetention.BINARY)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.TYPEALIAS, AnnotationTarget.PROPERTY)\n@RequiresOptIn(\n    level = RequiresOptIn.Level.ERROR, message = \"This is an internal kotlinx.coroutines API that \" +\n            \"should not be used from outside of kotlinx.coroutines. No compatibility guarantees are provided. \" +\n            \"It is recommended to report your use-case of internal API to kotlinx.coroutines issue tracker, \" +\n            \"so stable API could be provided instead\"\n)\npublic annotation class InternalCoroutinesApi\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Await.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlin.coroutines.*\n\n/**\n * Awaits for completion of given deferred values without blocking a thread and resumes normally with the list of values\n * when all deferred computations are complete or resumes with the first thrown exception if any of computations\n * complete exceptionally including cancellation.\n *\n * This function is **not** equivalent to `deferreds.map { it.await() }` which fails only when it sequentially\n * gets to wait for the failing deferred, while this `awaitAll` fails immediately as soon as any of the deferreds fail.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n */\npublic suspend fun <T> awaitAll(vararg deferreds: Deferred<T>): List<T> =\n    if (deferreds.isEmpty()) emptyList() else AwaitAll(deferreds).await()\n\n/**\n * Awaits for completion of given deferred values without blocking a thread and resumes normally with the list of values\n * when all deferred computations are complete or resumes with the first thrown exception if any of computations\n * complete exceptionally including cancellation.\n *\n * This function is **not** equivalent to `this.map { it.await() }` which fails only when it sequentially\n * gets to wait for the failing deferred, while this `awaitAll` fails immediately as soon as any of the deferreds fail.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n */\npublic suspend fun <T> Collection<Deferred<T>>.awaitAll(): List<T> =\n    if (isEmpty()) emptyList() else AwaitAll(toTypedArray()).await()\n\n/**\n * Suspends current coroutine until all given jobs are complete.\n * This method is semantically equivalent to joining all given jobs one by one with `jobs.forEach { it.join() }`.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n */\npublic suspend fun joinAll(vararg jobs: Job): Unit = jobs.forEach { it.join() }\n\n/**\n * Suspends current coroutine until all given jobs are complete.\n * This method is semantically equivalent to joining all given jobs one by one with `forEach { it.join() }`.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n */\npublic suspend fun Collection<Job>.joinAll(): Unit = forEach { it.join() }\n\nprivate class AwaitAll<T>(private val deferreds: Array<out Deferred<T>>) {\n    private val notCompletedCount = atomic(deferreds.size)\n\n    suspend fun await(): List<T> = suspendCancellableCoroutine { cont ->\n        // Intricate dance here\n        // Step 1: Create nodes and install them as completion handlers, they may fire!\n        val nodes = Array(deferreds.size) { i ->\n            val deferred = deferreds[i]\n            deferred.start() // To properly await lazily started deferreds\n            AwaitAllNode(cont).apply {\n                handle = deferred.invokeOnCompletion(handler = this)\n            }\n        }\n        val disposer = DisposeHandlersOnCancel(nodes)\n        // Step 2: Set disposer to each node\n        nodes.forEach { it.disposer = disposer }\n        // Here we know that if any code the nodes complete, it will dispose the rest\n        // Step 3: Now we can check if continuation is complete\n        if (cont.isCompleted) {\n            // it is already complete while handlers were being installed -- dispose them all\n            disposer.disposeAll()\n        } else {\n            cont.invokeOnCancellation(handler = disposer)\n        }\n    }\n\n    private inner class DisposeHandlersOnCancel(private val nodes: Array<AwaitAllNode>) : CancelHandler {\n        fun disposeAll() {\n            nodes.forEach { it.handle.dispose() }\n        }\n\n        override fun invoke(cause: Throwable?) { disposeAll() }\n        override fun toString(): String = \"DisposeHandlersOnCancel[$nodes]\"\n    }\n\n    private inner class AwaitAllNode(private val continuation: CancellableContinuation<List<T>>) : JobNode() {\n        lateinit var handle: DisposableHandle\n\n        private val _disposer = atomic<DisposeHandlersOnCancel?>(null)\n        var disposer: DisposeHandlersOnCancel?\n            get() = _disposer.value\n            set(value) { _disposer.value = value }\n        \n        override fun invoke(cause: Throwable?) {\n            if (cause != null) {\n                val token = continuation.tryResumeWithException(cause)\n                if (token != null) {\n                    continuation.completeResume(token)\n                    // volatile read of disposer AFTER continuation is complete\n                    // and if disposer was already set (all handlers where already installed, then dispose them all)\n                    disposer?.disposeAll()\n                }\n            } else if (notCompletedCount.decrementAndGet() == 0) {\n                continuation.resume(deferreds.map { it.getCompleted() })\n                // Note that all deferreds are complete here, so we don't need to dispose their nodes\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Builders.common.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"BuildersKt\")\n@file:OptIn(ExperimentalContracts::class)\n\npackage kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.intrinsics.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.jvm.*\n\n// --------------- launch ---------------\n\n/**\n * Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a [Job].\n * The coroutine is cancelled when the resulting job is [cancelled][Job.cancel].\n *\n * The coroutine context is inherited from a [CoroutineScope]. Additional context elements can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * The parent job is inherited from a [CoroutineScope] as well, but it can also be overridden\n * with a corresponding [context] element.\n *\n * By default, the coroutine is immediately scheduled for execution.\n * Other start options can be specified via `start` parameter. See [CoroutineStart] for details.\n * An optional [start] parameter can be set to [CoroutineStart.LAZY] to start coroutine _lazily_. In this case,\n * the coroutine [Job] is created in _new_ state. It can be explicitly started with [start][Job.start] function\n * and will be started implicitly on the first invocation of [join][Job.join].\n *\n * Uncaught exceptions in this coroutine cancel the parent job in the context by default\n * (unless [CoroutineExceptionHandler] is explicitly specified), which means that when `launch` is used with\n * the context of another coroutine, then any uncaught exception leads to the cancellation of the parent coroutine.\n *\n * See [newCoroutineContext] for a description of debugging facilities that are available for a newly created coroutine.\n *\n * @param context additional to [CoroutineScope.coroutineContext] context of the coroutine.\n * @param start coroutine start option. The default value is [CoroutineStart.DEFAULT].\n * @param block the coroutine code which will be invoked in the context of the provided scope.\n **/\npublic fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -> Unit\n): Job {\n    val newContext = newCoroutineContext(context)\n    val coroutine = if (start.isLazy)\n        LazyStandaloneCoroutine(newContext, block) else\n        StandaloneCoroutine(newContext, active = true)\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n\n// --------------- async ---------------\n\n/**\n * Creates a coroutine and returns its future result as an implementation of [Deferred].\n * The running coroutine is cancelled when the resulting deferred is [cancelled][Job.cancel].\n * The resulting coroutine has a key difference compared with similar primitives in other languages\n * and frameworks: it cancels the parent job (or outer scope) on failure to enforce *structured concurrency* paradigm.\n * To change that behaviour, supervising parent ([SupervisorJob] or [supervisorScope]) can be used.\n *\n * Coroutine context is inherited from a [CoroutineScope], additional context elements can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * The parent job is inherited from a [CoroutineScope] as well, but it can also be overridden\n * with corresponding [context] element.\n *\n * By default, the coroutine is immediately scheduled for execution.\n * Other options can be specified via `start` parameter. See [CoroutineStart] for details.\n * An optional [start] parameter can be set to [CoroutineStart.LAZY] to start coroutine _lazily_. In this case,\n * the resulting [Deferred] is created in _new_ state. It can be explicitly started with [start][Job.start]\n * function and will be started implicitly on the first invocation of [join][Job.join], [await][Deferred.await] or [awaitAll].\n *\n * @param block the coroutine code.\n */\npublic fun <T> CoroutineScope.async(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -> T\n): Deferred<T> {\n    val newContext = newCoroutineContext(context)\n    val coroutine = if (start.isLazy)\n        LazyDeferredCoroutine(newContext, block) else\n        DeferredCoroutine<T>(newContext, active = true)\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n\n@Suppress(\"UNCHECKED_CAST\")\nprivate open class DeferredCoroutine<T>(\n    parentContext: CoroutineContext,\n    active: Boolean\n) : AbstractCoroutine<T>(parentContext, true, active = active), Deferred<T> {\n    override fun getCompleted(): T = getCompletedInternal() as T\n    override suspend fun await(): T = awaitInternal() as T\n    override val onAwait: SelectClause1<T> get() = onAwaitInternal as SelectClause1<T>\n}\n\nprivate class LazyDeferredCoroutine<T>(\n    parentContext: CoroutineContext,\n    block: suspend CoroutineScope.() -> T\n) : DeferredCoroutine<T>(parentContext, active = false) {\n    private val continuation = block.createCoroutineUnintercepted(this, this)\n\n    override fun onStart() {\n        continuation.startCoroutineCancellable(this)\n    }\n}\n\n// --------------- withContext ---------------\n\n/**\n * Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns\n * the result.\n *\n * The resulting context for the [block] is derived by merging the current [coroutineContext] with the\n * specified [context] using `coroutineContext + context` (see [CoroutineContext.plus]).\n * This suspending function is cancellable. It immediately checks for cancellation of\n * the resulting context and throws [CancellationException] if it is not [active][CoroutineContext.isActive].\n *\n * Calls to [withContext] whose [context] argument provides a [CoroutineDispatcher] that is\n * different from the current one, by necessity, perform additional dispatches: the [block]\n * can not be executed immediately and needs to be dispatched for execution on\n * the passed [CoroutineDispatcher], and then when the [block] completes, the execution\n * has to shift back to the original dispatcher.\n *\n * Note that the result of `withContext` invocation is dispatched into the original context in a cancellable way\n * with a **prompt cancellation guarantee**, which means that if the original [coroutineContext]\n * in which `withContext` was invoked is cancelled by the time its dispatcher starts to execute the code,\n * it discards the result of `withContext` and throws [CancellationException].\n *\n * The cancellation behaviour described above is enabled if and only if the dispatcher is being changed.\n * For example, when using `withContext(NonCancellable) { ... }` there is no change in dispatcher and\n * this call will not be cancelled neither on entry to the block inside `withContext` nor on exit from it.\n */\npublic suspend fun <T> withContext(\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> T\n): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return suspendCoroutineUninterceptedOrReturn sc@ { uCont ->\n        // compute new context\n        val oldContext = uCont.context\n        // Copy CopyableThreadContextElement if necessary\n        val newContext = oldContext.newCoroutineContext(context)\n        // always check for cancellation of new context\n        newContext.ensureActive()\n        // FAST PATH #1 -- new context is the same as the old one\n        if (newContext === oldContext) {\n            val coroutine = ScopeCoroutine(newContext, uCont)\n            return@sc coroutine.startUndispatchedOrReturn(coroutine, block)\n        }\n        // FAST PATH #2 -- the new dispatcher is the same as the old one (something else changed)\n        // `equals` is used by design (see equals implementation is wrapper context like ExecutorCoroutineDispatcher)\n        if (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) {\n            val coroutine = UndispatchedCoroutine(newContext, uCont)\n            // There are changes in the context, so this thread needs to be updated\n            withCoroutineContext(coroutine.context, null) {\n                return@sc coroutine.startUndispatchedOrReturn(coroutine, block)\n            }\n        }\n        // SLOW PATH -- use new dispatcher\n        val coroutine = DispatchedCoroutine(newContext, uCont)\n        block.startCoroutineCancellable(coroutine, coroutine)\n        coroutine.getResult()\n    }\n}\n\n/**\n * Calls the specified suspending block with the given [CoroutineDispatcher], suspends until it\n * completes, and returns the result.\n *\n * This inline function calls [withContext].\n */\npublic suspend inline operator fun <T> CoroutineDispatcher.invoke(\n    noinline block: suspend CoroutineScope.() -> T\n): T = withContext(this, block)\n\n// --------------- implementation ---------------\n\nprivate open class StandaloneCoroutine(\n    parentContext: CoroutineContext,\n    active: Boolean\n) : AbstractCoroutine<Unit>(parentContext, initParentJob = true, active = active) {\n    override fun handleJobException(exception: Throwable): Boolean {\n        handleCoroutineException(context, exception)\n        return true\n    }\n}\n\nprivate class LazyStandaloneCoroutine(\n    parentContext: CoroutineContext,\n    block: suspend CoroutineScope.() -> Unit\n) : StandaloneCoroutine(parentContext, active = false) {\n    private val continuation = block.createCoroutineUnintercepted(this, this)\n\n    override fun onStart() {\n        continuation.startCoroutineCancellable(this)\n    }\n}\n\n// Used by withContext when context changes, but dispatcher stays the same\ninternal expect class UndispatchedCoroutine<in T>(\n    context: CoroutineContext,\n    uCont: Continuation<T>\n) : ScopeCoroutine<T>\n\nprivate const val UNDECIDED = 0\nprivate const val SUSPENDED = 1\nprivate const val RESUMED = 2\n\n// Used by withContext when context dispatcher changes\n@PublishedApi\ninternal class DispatchedCoroutine<in T> internal constructor(\n    context: CoroutineContext,\n    uCont: Continuation<T>\n) : ScopeCoroutine<T>(context, uCont) {\n    // this is copy-and-paste of a decision state machine inside AbstractionContinuation\n    // todo: we may some-how abstract it via inline class\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @JvmField\n    public val _decision = atomic(UNDECIDED)\n\n    private fun trySuspend(): Boolean {\n        _decision.loop { decision ->\n            when (decision) {\n                UNDECIDED -> if (this._decision.compareAndSet(UNDECIDED, SUSPENDED)) return true\n                RESUMED -> return false\n                else -> error(\"Already suspended\")\n            }\n        }\n    }\n\n    private fun tryResume(): Boolean {\n        _decision.loop { decision ->\n            when (decision) {\n                UNDECIDED -> if (this._decision.compareAndSet(UNDECIDED, RESUMED)) return true\n                SUSPENDED -> return false\n                else -> error(\"Already resumed\")\n            }\n        }\n    }\n\n    override fun afterCompletion(state: Any?) {\n        // Call afterResume from afterCompletion and not vice-versa, because stack-size is more\n        // important for afterResume implementation\n        afterResume(state)\n    }\n\n    override fun afterResume(state: Any?) {\n        if (tryResume()) return // completed before getResult invocation -- bail out\n        // Resume in a cancellable way because we have to switch back to the original dispatcher\n        uCont.intercepted().resumeCancellableWith(recoverResult(state, uCont))\n    }\n\n    internal fun getResult(): Any? {\n        if (trySuspend()) return COROUTINE_SUSPENDED\n        // otherwise, onCompletionInternal was already invoked & invoked tryResume, and the result is in the state\n        val state = this.state.unboxState()\n        if (state is CompletedExceptionally) throw state.cause\n        @Suppress(\"UNCHECKED_CAST\")\n        return state as T\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CancellableContinuation.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n// --------------- cancellable continuations ---------------\n\n/**\n * Cancellable continuation. It is _completed_ when resumed or cancelled.\n * When the [cancel] function is explicitly invoked, this continuation immediately resumes with a [CancellationException] or\n * the specified cancel cause.\n *\n * An instance of `CancellableContinuation` is created by the [suspendCancellableCoroutine] function.\n *\n * Cancellable continuation has three states (as subset of [Job] states):\n *\n * | **State**                           | [isActive] | [isCompleted] | [isCancelled] |\n * | ----------------------------------- | ---------- | ------------- | ------------- |\n * | _Active_ (initial state)            | `true`     | `false`       | `false`       |\n * | _Resumed_ (final _completed_ state) | `false`    | `true`        | `false`       |\n * | _Canceled_ (final _completed_ state)| `false`    | `true`        | `true`        |\n *\n * Invocation of [cancel] transitions this continuation from _active_ to _cancelled_ state, while\n * invocation of [Continuation.resume] or [Continuation.resumeWithException] transitions it from _active_ to _resumed_ state.\n *\n * A [cancelled][isCancelled] continuation implies that it is [completed][isCompleted].\n *\n * Invocation of [Continuation.resume] or [Continuation.resumeWithException] in _resumed_ state produces an [IllegalStateException],\n * but is ignored in _cancelled_ state.\n *\n * ```\n *    +-----------+   resume    +---------+\n *    |  Active   | ----------> | Resumed |\n *    +-----------+             +---------+\n *          |\n *          | cancel\n *          V\n *    +-----------+\n *    | Cancelled |\n *    +-----------+\n * ```\n */\npublic interface CancellableContinuation<in T> : Continuation<T> {\n    /**\n     * Returns `true` when this continuation is active -- it has not completed or cancelled yet.\n     */\n    public val isActive: Boolean\n\n    /**\n     * Returns `true` when this continuation has completed for any reason. A cancelled continuation\n     * is also considered complete.\n     */\n    public val isCompleted: Boolean\n\n    /**\n     * Returns `true` if this continuation was [cancelled][cancel].\n     *\n     * It implies that [isActive] is `false` and [isCompleted] is `true`.\n     */\n    public val isCancelled: Boolean\n\n    /**\n     * Tries to resume this continuation with the specified [value] and returns a non-null object token if successful,\n     * or `null` otherwise (it was already resumed or cancelled). When a non-null object is returned,\n     * [completeResume] must be invoked with it.\n     *\n     * When [idempotent] is not `null`, this function performs an _idempotent_ operation, so that\n     * further invocations with the same non-null reference produce the same result.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    @InternalCoroutinesApi\n    public fun tryResume(value: T, idempotent: Any? = null): Any?\n\n    /**\n     * Same as [tryResume] but with [onCancellation] handler that called if and only if the value is not\n     * delivered to the caller because of the dispatch in the process, so that atomicity delivery\n     * guaranteed can be provided by having a cancellation fallback.\n     *\n     * Implementation note: current implementation always returns RESUME_TOKEN or `null`\n     *\n     * @suppress  **This is unstable API and it is subject to change.**\n     */\n    @InternalCoroutinesApi\n    public fun tryResume(value: T, idempotent: Any?, onCancellation: ((cause: Throwable) -> Unit)?): Any?\n\n    /**\n     * Tries to resume this continuation with the specified [exception] and returns a non-null object token if successful,\n     * or `null` otherwise (it was already resumed or cancelled). When a non-null object is returned,\n     * [completeResume] must be invoked with it.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    @InternalCoroutinesApi\n    public fun tryResumeWithException(exception: Throwable): Any?\n\n    /**\n     * Completes the execution of [tryResume] or [tryResumeWithException] on its non-null result.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    @InternalCoroutinesApi\n    public fun completeResume(token: Any)\n\n    /**\n     * Internal function that setups cancellation behavior in [suspendCancellableCoroutine].\n     * It's illegal to call this function in any non-`kotlinx.coroutines` code and\n     * such calls lead to undefined behaviour.\n     * Exposed in our ABI since 1.0.0 withing `suspendCancellableCoroutine` body.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    @InternalCoroutinesApi\n    public fun initCancellability()\n\n    /**\n     * Cancels this continuation with an optional cancellation `cause`. The result is `true` if this continuation was\n     * cancelled as a result of this invocation, and `false` otherwise.\n     */\n    public fun cancel(cause: Throwable? = null): Boolean\n\n    /**\n     * Registers a [handler] to be **synchronously** invoked on [cancellation][cancel] (regular or exceptional) of this continuation.\n     * When the continuation is already cancelled, the handler is immediately invoked with the cancellation exception.\n     * Otherwise, the handler will be invoked as soon as this continuation is cancelled.\n     *\n     * The installed [handler] should not throw any exceptions.\n     * If it does, they will get caught, wrapped into a [CompletionHandlerException] and\n     * processed as an uncaught exception in the context of the current coroutine\n     * (see [CoroutineExceptionHandler]).\n     *\n     * At most one [handler] can be installed on a continuation.\n     * Attempting to call `invokeOnCancellation` a second time produces an [IllegalStateException].\n     *\n     * This handler is also called when this continuation [resumes][Continuation.resume] normally (with a value) and then\n     * is cancelled while waiting to be dispatched. More generally speaking, this handler is called whenever\n     * the caller of [suspendCancellableCoroutine] is getting a [CancellationException].\n     *\n     * A typical example of `invokeOnCancellation` usage is given in\n     * the documentation for the [suspendCancellableCoroutine] function.\n     *\n     * **Note**: Implementations of [CompletionHandler] must be fast, non-blocking, and thread-safe.\n     * This [handler] can be invoked concurrently with the surrounding code.\n     * There is no guarantee on the execution context in which the [handler] will be invoked.\n     */\n    public fun invokeOnCancellation(handler: CompletionHandler)\n\n    /**\n     * Resumes this continuation with the specified [value] in the invoker thread without going through\n     * the [dispatch][CoroutineDispatcher.dispatch] function of the [CoroutineDispatcher] in the [context].\n     * This function is designed to only be used by [CoroutineDispatcher] implementations.\n     * **It should not be used in general code**.\n     *\n     * **Note: This function is experimental.** Its signature general code may be changed in the future.\n     */\n    @ExperimentalCoroutinesApi\n    public fun CoroutineDispatcher.resumeUndispatched(value: T)\n\n    /**\n     * Resumes this continuation with the specified [exception] in the invoker thread without going through\n     * the [dispatch][CoroutineDispatcher.dispatch] function of the [CoroutineDispatcher] in the [context].\n     * This function is designed to only be used by [CoroutineDispatcher] implementations.\n     * **It should not be used in general code**.\n     *\n     * **Note: This function is experimental.** Its signature general code may be changed in the future.\n     */\n    @ExperimentalCoroutinesApi\n    public fun CoroutineDispatcher.resumeUndispatchedWithException(exception: Throwable)\n\n    /**\n     * Resumes this continuation with the specified `value` and calls the specified `onCancellation`\n     * handler when either resumed too late (when continuation was already cancelled) or, although resumed\n     * successfully (before cancellation), the coroutine's job was cancelled before it had a\n     * chance to run in its dispatcher, so that the suspended function threw an exception\n     * instead of returning this value.\n     *\n     * The installed [onCancellation] handler should not throw any exceptions.\n     * If it does, they will get caught, wrapped into a [CompletionHandlerException] and\n     * processed as an uncaught exception in the context of the current coroutine\n     * (see [CoroutineExceptionHandler]).\n     *\n     * This function shall be used when resuming with a resource that must be closed by\n     * code that called the corresponding suspending function, for example:\n     *\n     * ```\n     * continuation.resume(resource) {\n     *     resource.close()\n     * }\n     * ```\n     *\n     * A more complete example and further details are given in\n     * the documentation for the [suspendCancellableCoroutine] function.\n     *\n     * **Note**: The [onCancellation] handler must be fast, non-blocking, and thread-safe.\n     * It can be invoked concurrently with the surrounding code.\n     * There is no guarantee on the execution context of its invocation.\n     */\n    @ExperimentalCoroutinesApi // since 1.2.0\n    public fun resume(value: T, onCancellation: ((cause: Throwable) -> Unit)?)\n}\n\n/**\n * A version of `invokeOnCancellation` that accepts a class as a handler instead of a lambda, but identical otherwise.\n * This allows providing a custom [toString] instance that will look better during debugging.\n */\ninternal fun <T> CancellableContinuation<T>.invokeOnCancellation(handler: CancelHandler) = when (this) {\n    is CancellableContinuationImpl -> invokeOnCancellationInternal(handler)\n    else -> throw UnsupportedOperationException(\"third-party implementation of CancellableContinuation is not supported\")\n}\n\n/**\n * Suspends the coroutine like [suspendCoroutine], but providing a [CancellableContinuation] to\n * the [block]. This function throws a [CancellationException] if the [Job] of the coroutine is\n * cancelled or completed while it is suspended.\n *\n * A typical use of this function is to suspend a coroutine while waiting for a result\n * from a single-shot callback API and to return the result to the caller.\n * For multi-shot callback APIs see [callbackFlow][kotlinx.coroutines.flow.callbackFlow].\n *\n * ```\n * suspend fun awaitCallback(): T = suspendCancellableCoroutine { continuation ->\n *     val callback = object : Callback { // Implementation of some callback interface\n *         override fun onCompleted(value: T) {\n *             // Resume coroutine with a value provided by the callback\n *             continuation.resume(value)\n *         }\n *         override fun onApiError(cause: Throwable) {\n *             // Resume coroutine with an exception provided by the callback\n *             continuation.resumeWithException(cause)\n *         }\n *     }\n *     // Register callback with an API\n *     api.register(callback)\n *     // Remove callback on cancellation\n *     continuation.invokeOnCancellation { api.unregister(callback) }\n *     // At this point the coroutine is suspended by suspendCancellableCoroutine until callback fires\n * }\n * ```\n *\n * > The callback `register`/`unregister` methods provided by an external API must be thread-safe, because\n * > `invokeOnCancellation` block can be called at any time due to asynchronous nature of cancellation, even\n * > concurrently with the call of the callback.\n *\n * ### Prompt cancellation guarantee\n *\n * This function provides **prompt cancellation guarantee**.\n * If the [Job] of the current coroutine was cancelled while this function was suspended it will not resume\n * successfully, even if [CancellableContinuation.resume] was already invoked.\n *\n * The cancellation of the coroutine's job is generally asynchronous with respect to the suspended coroutine.\n * The suspended coroutine is resumed with a call to its [Continuation.resumeWith] member function or to the\n * [resume][Continuation.resume] extension function.\n * However, when coroutine is resumed, it does not immediately start executing, but is passed to its\n * [CoroutineDispatcher] to schedule its execution when dispatcher's resources become available for execution.\n * The job's cancellation can happen before, after, and concurrently with the call to `resume`. In any\n * case, prompt cancellation guarantees that the coroutine will not resume its code successfully.\n *\n * If the coroutine was resumed with an exception (for example, using [Continuation.resumeWithException] extension\n * function) and cancelled, then the exception thrown by the `suspendCancellableCoroutine` function is determined\n * by what happened first: exceptional resume or cancellation.\n *\n * ### Returning resources from a suspended coroutine\n *\n * As a result of the prompt cancellation guarantee, when a closeable resource\n * (like open file or a handle to another native resource) is returned from a suspended coroutine as a value,\n * it can be lost when the coroutine is cancelled. To ensure that the resource can be properly closed\n * in this case, the [CancellableContinuation] interface provides two functions.\n *\n * - [invokeOnCancellation][CancellableContinuation.invokeOnCancellation] installs a handler that is called\n *   whenever a suspend coroutine is being cancelled. In addition to the example at the beginning, it can be\n *   used to ensure that a resource that was opened before the call to\n *   `suspendCancellableCoroutine` or in its body is closed in case of cancellation.\n *\n * ```\n * suspendCancellableCoroutine { continuation ->\n *    val resource = openResource() // Opens some resource\n *    continuation.invokeOnCancellation {\n *        resource.close() // Ensures the resource is closed on cancellation\n *    }\n *    // ...\n * }\n * ```\n *\n * - [resume(value) { ... }][CancellableContinuation.resume] method on a [CancellableContinuation] takes\n *   an optional `onCancellation` block. It can be used when resuming with a resource that must be closed by\n *   the code that called the corresponding suspending function.\n *\n * ```\n * suspendCancellableCoroutine { continuation ->\n *     val callback = object : Callback { // Implementation of some callback interface\n *         // A callback provides a reference to some closeable resource\n *         override fun onCompleted(resource: T) {\n *             // Resume coroutine with a value provided by the callback and ensure the resource is closed in case\n *             // when the coroutine is cancelled before the caller gets a reference to the resource.\n *             continuation.resume(resource) {\n *                 resource.close() // Close the resource on cancellation\n *             }\n *         }\n *     // ...\n * }\n * ```\n *\n * ### Implementation details and custom continuation interceptors\n *\n * The prompt cancellation guarantee is the result of a coordinated implementation inside `suspendCancellableCoroutine`\n * function and the [CoroutineDispatcher] class. The coroutine dispatcher checks for the status of the [Job] immediately\n * before continuing its normal execution and aborts this normal execution, calling all the corresponding\n * cancellation handlers, if the job was cancelled.\n *\n * If a custom implementation of [ContinuationInterceptor] is used in a coroutine's context that does not extend\n * [CoroutineDispatcher] class, then there is no prompt cancellation guarantee. A custom continuation interceptor\n * can resume execution of a previously suspended coroutine even if its job was already cancelled.\n */\npublic suspend inline fun <T> suspendCancellableCoroutine(\n    crossinline block: (CancellableContinuation<T>) -> Unit\n): T =\n    suspendCoroutineUninterceptedOrReturn { uCont ->\n        val cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)\n        /*\n         * For non-atomic cancellation we setup parent-child relationship immediately\n         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but\n         * properly supports cancellation.\n         */\n        cancellable.initCancellability()\n        block(cancellable)\n        cancellable.getResult()\n    }\n\n/**\n * Suspends the coroutine similar to [suspendCancellableCoroutine], but an instance of\n * [CancellableContinuationImpl] is reused.\n */\ninternal suspend inline fun <T> suspendCancellableCoroutineReusable(\n    crossinline block: (CancellableContinuationImpl<T>) -> Unit\n): T = suspendCoroutineUninterceptedOrReturn { uCont ->\n    val cancellable = getOrCreateCancellableContinuation(uCont.intercepted())\n    try {\n        block(cancellable)\n    } catch (e: Throwable) {\n        // Here we catch any unexpected exception from user-supplied block (e.g. invariant violation)\n        // and release claimed continuation in order to leave it in a reasonable state (see #3613)\n        cancellable.releaseClaimedReusableContinuation()\n        throw e\n    }\n    cancellable.getResult()\n}\n\ninternal fun <T> getOrCreateCancellableContinuation(delegate: Continuation<T>): CancellableContinuationImpl<T> {\n    // If used outside our dispatcher\n    if (delegate !is DispatchedContinuation<T>) {\n        return CancellableContinuationImpl(delegate, MODE_CANCELLABLE)\n    }\n    /*\n     * Attempt to claim reusable instance.\n     *\n     * suspendCancellableCoroutineReusable { // <- claimed\n     *     // Any asynchronous cancellation is \"postponed\" while this block\n     *     // is being executed\n     * } // postponed cancellation is checked here.\n     *\n     * Claim can fail for the following reasons:\n     * 1) Someone tried to make idempotent resume.\n     *    Idempotent resume is internal (used only by us) and is used only in `select`,\n     *    thus leaking CC instance for indefinite time.\n     * 2) Continuation was cancelled. Then we should prevent any further reuse and bail out.\n     */\n    return delegate.claimReusableCancellableContinuation()?.takeIf { it.resetStateReusable() }\n        ?: return CancellableContinuationImpl(delegate, MODE_CANCELLABLE_REUSABLE)\n}\n\n/**\n * Disposes the specified [handle] when this continuation is cancelled.\n *\n * This is a shortcut for the following code with slightly more efficient implementation (one fewer object created):\n * ```\n * invokeOnCancellation { handle.dispose() }\n * ```\n *\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic fun CancellableContinuation<*>.disposeOnCancellation(handle: DisposableHandle): Unit =\n    invokeOnCancellation(handler = DisposeOnCancel(handle))\n\nprivate class DisposeOnCancel(private val handle: DisposableHandle) : CancelHandler {\n    override fun invoke(cause: Throwable?) = handle.dispose()\n    override fun toString(): String = \"DisposeOnCancel[$handle]\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CancellableContinuationImpl.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.jvm.*\n\nprivate const val UNDECIDED = 0\nprivate const val SUSPENDED = 1\nprivate const val RESUMED = 2\n\nprivate const val DECISION_SHIFT = 29\nprivate const val INDEX_MASK = (1 shl DECISION_SHIFT) - 1\nprivate const val NO_INDEX = INDEX_MASK\n\nprivate inline val Int.decision get() = this shr DECISION_SHIFT\nprivate inline val Int.index get() = this and INDEX_MASK\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun decisionAndIndex(decision: Int, index: Int) = (decision shl DECISION_SHIFT) + index\n\n@JvmField\ninternal val RESUME_TOKEN = Symbol(\"RESUME_TOKEN\")\n\n/**\n * @suppress **This is unstable API and it is subject to change.**\n */\n@PublishedApi\ninternal open class CancellableContinuationImpl<in T>(\n    final override val delegate: Continuation<T>,\n    resumeMode: Int\n) : DispatchedTask<T>(resumeMode), CancellableContinuation<T>, CoroutineStackFrame, Waiter {\n    init {\n        assert { resumeMode != MODE_UNINITIALIZED } // invalid mode for CancellableContinuationImpl\n    }\n\n    public override val context: CoroutineContext = delegate.context\n\n    /*\n     * Implementation notes\n     *\n     * CancellableContinuationImpl is a subset of Job with following limitations:\n     * 1) It can have only cancellation listener (no \"on cancelling\")\n     * 2) It always invokes cancellation listener if it's cancelled (no 'invokeImmediately')\n     * 3) It can have at most one cancellation listener\n     * 4) Its cancellation listeners cannot be deregistered\n     * As a consequence it has much simpler state machine, more lightweight machinery and\n     * less dependencies.\n     */\n\n    /** decision state machine\n\n        +-----------+   trySuspend   +-----------+\n        | UNDECIDED | -------------> | SUSPENDED |\n        +-----------+                +-----------+\n              |\n              | tryResume\n              V\n        +-----------+\n        |  RESUMED  |\n        +-----------+\n\n        Note: both tryResume and trySuspend can be invoked at most once, first invocation wins.\n        If the cancellation handler is specified via a [Segment] instance and the index in it\n        (so [Segment.onCancellation] should be called), the [_decisionAndIndex] field may store\n        this index additionally to the \"decision\" value.\n     */\n    private val _decisionAndIndex = atomic(decisionAndIndex(UNDECIDED, NO_INDEX))\n\n    /*\n       === Internal states ===\n       name        state class          public state    description\n       ------      ------------         ------------    -----------\n       ACTIVE      Active               : Active        active, no listeners\n       SINGLE_A    CancelHandler        : Active        active, one cancellation listener\n       CANCELLED   CancelledContinuation: Cancelled     cancelled (final state)\n       COMPLETED   any                  : Completed     produced some result or threw an exception (final state)\n     */\n    private val _state = atomic<Any?>(Active)\n\n    /*\n     * This field has a concurrent rendezvous in the following scenario:\n     *\n     * - installParentHandle publishes this instance on T1\n     *\n     * T1 writes:\n     * - handle = installed; right after the installation\n     * - Shortly after: if (isComplete) handle = NonDisposableHandle\n     *\n     * Any other T writes if the parent job is cancelled in detachChild:\n     * - handle = NonDisposableHandle\n     *\n     * We want to preserve a strict invariant on parentHandle transition, allowing only three of them:\n     * null -> anyHandle\n     * anyHandle -> NonDisposableHandle\n     * null -> NonDisposableHandle\n     *\n     * With a guarantee that after disposal the only state handle may end up in is NonDisposableHandle\n     */\n    private val _parentHandle = atomic<DisposableHandle?>(null)\n    private val parentHandle: DisposableHandle?\n        get() = _parentHandle.value\n\n    internal val state: Any? get() = _state.value\n\n    public override val isActive: Boolean get() = state is NotCompleted\n\n    public override val isCompleted: Boolean get() = state !is NotCompleted\n\n    public override val isCancelled: Boolean get() = state is CancelledContinuation\n\n    // We cannot invoke `state.toString()` since it may cause a circular dependency\n    private val stateDebugRepresentation get() = when(state) {\n        is NotCompleted -> \"Active\"\n        is CancelledContinuation -> \"Cancelled\"\n        else -> \"Completed\"\n    }\n\n    public override fun initCancellability() {\n        /*\n        * Invariant: at the moment of invocation, `this` has not yet\n        * leaked to user code and no one is able to invoke `resume` or `cancel`\n        * on it yet. Also, this function is not invoked for reusable continuations.\n        */\n        val handle = installParentHandle()\n            ?: return // fast path -- don't do anything without parent\n        // now check our state _after_ registering, could have completed while we were registering,\n        // but only if parent was cancelled. Parent could be in a \"cancelling\" state for a while,\n        // so we are helping it and cleaning the node ourselves\n        if (isCompleted) {\n            // Can be invoked concurrently in 'parentCancelled', no problems here\n            handle.dispose()\n            _parentHandle.value = NonDisposableHandle\n        }\n    }\n\n    private fun isReusable(): Boolean = resumeMode.isReusableMode && (delegate as DispatchedContinuation<*>).isReusable()\n\n    /**\n     * Resets cancellability state in order to [suspendCancellableCoroutineReusable] to work.\n     * Invariant: used only by [suspendCancellableCoroutineReusable] in [REUSABLE_CLAIMED] state.\n     */\n    @JvmName(\"resetStateReusable\") // Prettier stack traces\n    internal fun resetStateReusable(): Boolean {\n        assert { resumeMode == MODE_CANCELLABLE_REUSABLE }\n        assert { parentHandle !== NonDisposableHandle }\n        val state = _state.value\n        assert { state !is NotCompleted }\n        if (state is CompletedContinuation && state.idempotentResume != null) {\n            // Cannot reuse continuation that was resumed with idempotent marker\n            detachChild()\n            return false\n        }\n        _decisionAndIndex.value = decisionAndIndex(UNDECIDED, NO_INDEX)\n        _state.value = Active\n        return true\n    }\n\n    public override val callerFrame: CoroutineStackFrame?\n        get() = delegate as? CoroutineStackFrame\n\n    public override fun getStackTraceElement(): StackTraceElement? = null\n\n    override fun takeState(): Any? = state\n\n    // Note: takeState does not clear the state so we don't use takenState\n    // and we use the actual current state where in CAS-loop\n    override fun cancelCompletedResult(takenState: Any?, cause: Throwable): Unit = _state.loop { state ->\n        when (state) {\n            is NotCompleted -> error(\"Not completed\")\n            is CompletedExceptionally -> return // already completed exception or cancelled, nothing to do\n            is CompletedContinuation -> {\n                check(!state.cancelled) { \"Must be called at most once\" }\n                val update = state.copy(cancelCause = cause)\n                if (_state.compareAndSet(state, update)) {\n                    state.invokeHandlers(this, cause)\n                    return // done\n                }\n            }\n            else -> {\n                // completed normally without marker class, promote to CompletedContinuation in case\n                // if invokeOnCancellation if called later\n                if (_state.compareAndSet(state, CompletedContinuation(state, cancelCause = cause))) {\n                    return // done\n                }\n            }\n        }\n    }\n\n    /*\n     * Attempt to postpone cancellation for reusable cancellable continuation\n     */\n    private fun cancelLater(cause: Throwable): Boolean {\n        // Ensure that we are postponing cancellation to the right reusable instance\n        if (!isReusable()) return false\n        val dispatched = delegate as DispatchedContinuation<*>\n        return dispatched.postponeCancellation(cause)\n    }\n\n    public override fun cancel(cause: Throwable?): Boolean {\n        _state.loop { state ->\n            if (state !is NotCompleted) return false // false if already complete or cancelling\n            // Active -- update to final state\n            val update = CancelledContinuation(this, cause, handled = state is CancelHandler || state is Segment<*>)\n            if (!_state.compareAndSet(state, update)) return@loop // retry on cas failure\n            // Invoke cancel handler if it was present\n            when (state) {\n                is CancelHandler -> callCancelHandler(state, cause)\n                is Segment<*> -> callSegmentOnCancellation(state, cause)\n            }\n            // Complete state update\n            detachChildIfNonResuable()\n            dispatchResume(resumeMode) // no need for additional cancellation checks\n            return true\n        }\n    }\n\n    internal fun parentCancelled(cause: Throwable) {\n        if (cancelLater(cause)) return\n        cancel(cause)\n        // Even if cancellation has failed, we should detach child to avoid potential leak\n        detachChildIfNonResuable()\n    }\n\n    private inline fun callCancelHandlerSafely(block: () -> Unit) {\n        try {\n            block()\n        } catch (ex: Throwable) {\n            // Handler should never fail, if it does -- it is an unhandled exception\n            handleCoroutineException(\n                context,\n                CompletionHandlerException(\"Exception in invokeOnCancellation handler for $this\", ex)\n            )\n        }\n    }\n\n    private fun callCancelHandler(handler: InternalCompletionHandler, cause: Throwable?) =\n        /*\n        * :KLUDGE: We have to invoke a handler in platform-specific way via `invokeIt` extension,\n        * because we play type tricks on Kotlin/JS and handler is not necessarily a function there\n        */\n        callCancelHandlerSafely { handler.invoke(cause) }\n\n    fun callCancelHandler(handler: CancelHandler, cause: Throwable?) =\n        callCancelHandlerSafely { handler.invoke(cause) }\n\n    private fun callSegmentOnCancellation(segment: Segment<*>, cause: Throwable?) {\n        val index = _decisionAndIndex.value.index\n        check(index != NO_INDEX) { \"The index for Segment.onCancellation(..) is broken\" }\n        callCancelHandlerSafely { segment.onCancellation(index, cause, context) }\n    }\n\n    fun callOnCancellation(onCancellation: (cause: Throwable) -> Unit, cause: Throwable) {\n        try {\n            onCancellation.invoke(cause)\n        } catch (ex: Throwable) {\n            // Handler should never fail, if it does -- it is an unhandled exception\n            handleCoroutineException(\n                context,\n                CompletionHandlerException(\"Exception in resume onCancellation handler for $this\", ex)\n            )\n        }\n    }\n\n    /**\n     * It is used when parent is cancelled to get the cancellation cause for this continuation.\n     */\n    open fun getContinuationCancellationCause(parent: Job): Throwable =\n        parent.getCancellationException()\n\n    private fun trySuspend(): Boolean {\n        _decisionAndIndex.loop { cur ->\n            when (cur.decision) {\n                UNDECIDED -> if (this._decisionAndIndex.compareAndSet(cur, decisionAndIndex(SUSPENDED, cur.index))) return true\n                RESUMED -> return false\n                else -> error(\"Already suspended\")\n            }\n        }\n    }\n\n    private fun tryResume(): Boolean {\n        _decisionAndIndex.loop { cur ->\n            when (cur.decision) {\n                UNDECIDED -> if (this._decisionAndIndex.compareAndSet(cur, decisionAndIndex(RESUMED, cur.index))) return true\n                SUSPENDED -> return false\n                else -> error(\"Already resumed\")\n            }\n        }\n    }\n\n    @PublishedApi\n    internal fun getResult(): Any? {\n        val isReusable = isReusable()\n        // trySuspend may fail either if 'block' has resumed/cancelled a continuation,\n        // or we got async cancellation from parent.\n        if (trySuspend()) {\n            /*\n             * Invariant: parentHandle is `null` *only* for reusable continuations.\n             * We were neither resumed nor cancelled, time to suspend.\n             * But first we have to install parent cancellation handle (if we didn't yet),\n             * so CC could be properly resumed on parent cancellation.\n             *\n             * This read has benign data-race with write of 'NonDisposableHandle'\n             * in 'detachChildIfNotReusable'.\n             */\n            if (parentHandle == null) {\n                installParentHandle()\n            }\n            /*\n             * Release the continuation after installing the handle (if needed).\n             * If we were successful, then do nothing, it's ok to reuse the instance now.\n             * Otherwise, dispose the handle by ourselves.\n            */\n            if (isReusable) {\n                releaseClaimedReusableContinuation()\n            }\n            return COROUTINE_SUSPENDED\n        }\n        // otherwise, onCompletionInternal was already invoked & invoked tryResume, and the result is in the state\n        if (isReusable) {\n            // release claimed reusable continuation for the future reuse\n            releaseClaimedReusableContinuation()\n        }\n        val state = this.state\n        if (state is CompletedExceptionally) throw recoverStackTrace(state.cause, this)\n        // if the parent job was already cancelled, then throw the corresponding cancellation exception\n        // otherwise, there is a race if suspendCancellableCoroutine { cont -> ... } does cont.resume(...)\n        // before the block returns. This getResult would return a result as opposed to cancellation\n        // exception that should have happened if the continuation is dispatched for execution later.\n        if (resumeMode.isCancellableMode) {\n            val job = context[Job]\n            if (job != null && !job.isActive) {\n                val cause = job.getCancellationException()\n                cancelCompletedResult(state, cause)\n                throw recoverStackTrace(cause, this)\n            }\n        }\n        return getSuccessfulResult(state)\n    }\n\n    private fun installParentHandle(): DisposableHandle? {\n        val parent = context[Job] ?: return null // don't do anything without a parent\n        // Install the handle\n        val handle = parent.invokeOnCompletion(\n            onCancelling = true,\n            handler = ChildContinuation(this)\n        )\n        _parentHandle.compareAndSet(null, handle)\n        return handle\n    }\n\n    /**\n     * Tries to release reusable continuation. It can fail is there was an asynchronous cancellation,\n     * in which case it detaches from the parent and cancels this continuation.\n     */\n    internal fun releaseClaimedReusableContinuation() {\n        // Cannot be cast if e.g. invoked from `installParentHandleReusable` for context without dispatchers, but with Job in it\n        val cancellationCause = (delegate as? DispatchedContinuation<*>)?.tryReleaseClaimedContinuation(this) ?: return\n        detachChild()\n        cancel(cancellationCause)\n    }\n\n    override fun resumeWith(result: Result<T>) =\n        resumeImpl(result.toState(this), resumeMode)\n\n    override fun resume(value: T, onCancellation: ((cause: Throwable) -> Unit)?) =\n        resumeImpl(value, resumeMode, onCancellation)\n\n    /**\n     * An optimized version for the code below that does not allocate\n     * a cancellation handler object and efficiently stores the specified\n     * [segment] and [index] in this [CancellableContinuationImpl].\n     *\n     * The only difference is that `segment.onCancellation(..)` is never\n     * called if this continuation is already completed;\n     *\n     * ```\n     * invokeOnCancellation { cause ->\n     *   segment.onCancellation(index, cause)\n     * }\n     * ```\n     */\n    override fun invokeOnCancellation(segment: Segment<*>, index: Int) {\n        _decisionAndIndex.update {\n            check(it.index == NO_INDEX) {\n                \"invokeOnCancellation should be called at most once\"\n            }\n            decisionAndIndex(it.decision, index)\n        }\n        invokeOnCancellationImpl(segment)\n    }\n\n    override fun invokeOnCancellation(handler: CompletionHandler) = invokeOnCancellation(CancelHandler.UserSupplied(handler))\n\n    internal fun invokeOnCancellationInternal(handler: CancelHandler) = invokeOnCancellationImpl(handler)\n\n    private fun invokeOnCancellationImpl(handler: Any) {\n        assert { handler is CancelHandler || handler is Segment<*> }\n        _state.loop { state ->\n            when (state) {\n                is Active -> {\n                    if (_state.compareAndSet(state, handler)) return // quit on cas success\n                }\n                is CancelHandler, is Segment<*> -> multipleHandlersError(handler, state)\n                is CompletedExceptionally -> {\n                    /*\n                     * Continuation was already cancelled or completed exceptionally.\n                     * NOTE: multiple invokeOnCancellation calls with different handlers are not allowed,\n                     * so we check to make sure handler was installed just once.\n                     */\n                    if (!state.makeHandled()) multipleHandlersError(handler, state)\n                    /*\n                     * Call the handler only if it was cancelled (not called when completed exceptionally).\n                     * :KLUDGE: We have to invoke a handler in platform-specific way via `invokeIt` extension,\n                     * because we play type tricks on Kotlin/JS and handler is not necessarily a function there\n                     */\n                    if (state is CancelledContinuation) {\n                        val cause: Throwable? = (state as? CompletedExceptionally)?.cause\n                        if (handler is CancelHandler) {\n                            callCancelHandler(handler, cause)\n                        } else {\n                            val segment = handler as Segment<*>\n                            callSegmentOnCancellation(segment, cause)\n                        }\n                    }\n                    return\n                }\n                is CompletedContinuation -> {\n                    /*\n                     * Continuation was already completed, and might already have cancel handler.\n                     */\n                    if (state.cancelHandler != null) multipleHandlersError(handler, state)\n                    // Segment.invokeOnCancellation(..) does NOT need to be called on completed continuation.\n                    if (handler is Segment<*>) return\n                    handler as CancelHandler\n                    if (state.cancelled) {\n                        // Was already cancelled while being dispatched -- invoke the handler directly\n                        callCancelHandler(handler, state.cancelCause)\n                        return\n                    }\n                    val update = state.copy(cancelHandler = handler)\n                    if (_state.compareAndSet(state, update)) return // quit on cas success\n                }\n                else -> {\n                    /*\n                     * Continuation was already completed normally, but might get cancelled while being dispatched.\n                     * Change its state to CompletedContinuation, unless we have Segment which\n                     * does not need to be called in this case.\n                     */\n                    if (handler is Segment<*>) return\n                    handler as CancelHandler\n                    val update = CompletedContinuation(state, cancelHandler = handler)\n                    if (_state.compareAndSet(state, update)) return // quit on cas success\n                }\n            }\n        }\n    }\n\n    private fun multipleHandlersError(handler: Any, state: Any?) {\n        error(\"It's prohibited to register multiple handlers, tried to register $handler, already has $state\")\n    }\n\n    private fun dispatchResume(mode: Int) {\n        if (tryResume()) return // completed before getResult invocation -- bail out\n        // otherwise, getResult has already commenced, i.e. completed later or in other thread\n        dispatch(mode)\n    }\n\n    private fun resumedState(\n        state: NotCompleted,\n        proposedUpdate: Any?,\n        resumeMode: Int,\n        onCancellation: ((cause: Throwable) -> Unit)?,\n        idempotent: Any?\n    ): Any? = when {\n        proposedUpdate is CompletedExceptionally -> {\n            assert { idempotent == null } // there are no idempotent exceptional resumes\n            assert { onCancellation == null } // only successful results can be cancelled\n            proposedUpdate\n        }\n        !resumeMode.isCancellableMode && idempotent == null -> proposedUpdate // cannot be cancelled in process, all is fine\n        onCancellation != null || state is CancelHandler || idempotent != null ->\n            // mark as CompletedContinuation if special cases are present:\n            // Cancellation handlers that shall be called after resume or idempotent resume\n            CompletedContinuation(proposedUpdate, state as? CancelHandler, onCancellation, idempotent)\n        else -> proposedUpdate // simple case -- use the value directly\n    }\n\n    private fun resumeImpl(\n        proposedUpdate: Any?,\n        resumeMode: Int,\n        onCancellation: ((cause: Throwable) -> Unit)? = null\n    ) {\n        _state.loop { state ->\n            when (state) {\n                is NotCompleted -> {\n                    val update = resumedState(state, proposedUpdate, resumeMode, onCancellation, idempotent = null)\n                    if (!_state.compareAndSet(state, update)) return@loop // retry on cas failure\n                    detachChildIfNonResuable()\n                    dispatchResume(resumeMode) // dispatch resume, but it might get cancelled in process\n                    return // done\n                }\n                is CancelledContinuation -> {\n                    /*\n                     * If continuation was cancelled, then resume attempt must be ignored,\n                     * because cancellation is asynchronous and may race with resume.\n                     * Racy exceptions will be lost, too.\n                     */\n                    if (state.makeResumed()) { // check if trying to resume one (otherwise error)\n                        // call onCancellation\n                        onCancellation?.let { callOnCancellation(it, state.cause) }\n                        return // done\n                    }\n                }\n            }\n            alreadyResumedError(proposedUpdate) // otherwise, an error (second resume attempt)\n        }\n    }\n\n    /**\n     * Similar to [tryResume], but does not actually completes resume (needs [completeResume] call).\n     * Returns [RESUME_TOKEN] when resumed, `null` when it was already resumed or cancelled.\n     */\n    private fun tryResumeImpl(\n        proposedUpdate: Any?,\n        idempotent: Any?,\n        onCancellation: ((cause: Throwable) -> Unit)?\n    ): Symbol? {\n        _state.loop { state ->\n            when (state) {\n                is NotCompleted -> {\n                    val update = resumedState(state, proposedUpdate, resumeMode, onCancellation, idempotent)\n                    if (!_state.compareAndSet(state, update)) return@loop // retry on cas failure\n                    detachChildIfNonResuable()\n                    return RESUME_TOKEN\n                }\n                is CompletedContinuation -> {\n                    return if (idempotent != null && state.idempotentResume === idempotent) {\n                        assert { state.result == proposedUpdate } // \"Non-idempotent resume\"\n                        RESUME_TOKEN // resumed with the same token -- ok\n                    } else {\n                        null // resumed with a different token or non-idempotent -- too late\n                    }\n                }\n                else -> return null // cannot resume -- not active anymore\n            }\n        }\n    }\n\n    private fun alreadyResumedError(proposedUpdate: Any?): Nothing {\n        error(\"Already resumed, but proposed with update $proposedUpdate\")\n    }\n\n    // Unregister from parent job\n    private fun detachChildIfNonResuable() {\n        // If instance is reusable, do not detach on every reuse, #releaseInterceptedContinuation will do it for us in the end\n        if (!isReusable()) detachChild()\n    }\n\n    /**\n     * Detaches from the parent.\n     */\n    internal fun detachChild() {\n        val handle = parentHandle ?: return\n        handle.dispose()\n        _parentHandle.value = NonDisposableHandle\n    }\n\n    // Note: Always returns RESUME_TOKEN | null\n    override fun tryResume(value: T, idempotent: Any?): Any? =\n        tryResumeImpl(value, idempotent, onCancellation = null)\n\n    override fun tryResume(value: T, idempotent: Any?, onCancellation: ((cause: Throwable) -> Unit)?): Any? =\n        tryResumeImpl(value, idempotent, onCancellation)\n\n    override fun tryResumeWithException(exception: Throwable): Any? =\n        tryResumeImpl(CompletedExceptionally(exception), idempotent = null, onCancellation = null)\n\n    // note: token is always RESUME_TOKEN\n    override fun completeResume(token: Any) {\n        assert { token === RESUME_TOKEN }\n        dispatchResume(resumeMode)\n    }\n\n    override fun CoroutineDispatcher.resumeUndispatched(value: T) {\n        val dc = delegate as? DispatchedContinuation\n        resumeImpl(value, if (dc?.dispatcher === this) MODE_UNDISPATCHED else resumeMode)\n    }\n\n    override fun CoroutineDispatcher.resumeUndispatchedWithException(exception: Throwable) {\n        val dc = delegate as? DispatchedContinuation\n        resumeImpl(CompletedExceptionally(exception), if (dc?.dispatcher === this) MODE_UNDISPATCHED else resumeMode)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T> getSuccessfulResult(state: Any?): T =\n        when (state) {\n            is CompletedContinuation -> state.result as T\n            else -> state as T\n        }\n\n    // The exceptional state in CancellableContinuationImpl is stored directly and it is not recovered yet.\n    // The stacktrace recovery is invoked here.\n    override fun getExceptionalResult(state: Any?): Throwable? =\n        super.getExceptionalResult(state)?.let { recoverStackTrace(it, delegate) }\n\n    // For nicer debugging\n    public override fun toString(): String =\n        \"${nameString()}(${delegate.toDebugString()}){$stateDebugRepresentation}@$hexAddress\"\n\n    protected open fun nameString(): String =\n        \"CancellableContinuation\"\n\n}\n\n// Marker for active continuation\ninternal interface NotCompleted\n\nprivate object Active : NotCompleted {\n    override fun toString(): String = \"Active\"\n}\n\n/**\n * Essentially the same as just a function from `Throwable?` to `Unit`.\n * The only thing implementors can do is call [invoke].\n * The reason this abstraction exists is to allow providing a readable [toString] in the list of completion handlers\n * as seen from the debugger.\n * Use [UserSupplied] to create an instance from a lambda.\n * We can't avoid defining a separate type, because on JS, you can't inherit from a function type.\n *\n * @see InternalCompletionHandler for a very similar interface, but used for handling completion and not cancellation.\n */\ninternal interface CancelHandler : NotCompleted {\n    /**\n     * Signals cancellation.\n     *\n     * This function:\n     * - Does not throw any exceptions.\n     *   Violating this rule in an implementation leads to [handleUncaughtCoroutineException] being called with a\n     *   [CompletionHandlerException] wrapping the thrown exception.\n     * - Is fast, non-blocking, and thread-safe.\n     * - Can be invoked concurrently with the surrounding code.\n     * - Can be invoked from any context.\n     *\n     * The meaning of `cause` that is passed to the handler is:\n     * - It is `null` if the continuation was cancelled directly via [CancellableContinuation.cancel] without a `cause`.\n     * - It is an instance of [CancellationException] if the continuation was _normally_ cancelled from the outside.\n     *   **It should not be treated as an error**. In particular, it should not be reported to error logs.\n     * - Otherwise, the continuation had cancelled with an _error_.\n     */\n    fun invoke(cause: Throwable?)\n\n    /**\n     * A lambda passed from outside the coroutine machinery.\n     *\n     * See the requirements for [CancelHandler.invoke] when implementing this function.\n     */\n    class UserSupplied(private val handler: (cause: Throwable?) -> Unit) : CancelHandler {\n        /** @suppress */\n        override fun invoke(cause: Throwable?) { handler(cause) }\n\n        override fun toString() = \"CancelHandler.UserSupplied[${handler.classSimpleName}@$hexAddress]\"\n    }\n}\n\n// Completed with additional metadata\nprivate data class CompletedContinuation(\n    @JvmField val result: Any?,\n    @JvmField val cancelHandler: CancelHandler? = null, // installed via invokeOnCancellation\n    @JvmField val onCancellation: ((cause: Throwable) -> Unit)? = null, // installed via resume block\n    @JvmField val idempotentResume: Any? = null,\n    @JvmField val cancelCause: Throwable? = null\n) {\n    val cancelled: Boolean get() = cancelCause != null\n\n    fun invokeHandlers(cont: CancellableContinuationImpl<*>, cause: Throwable) {\n        cancelHandler?.let { cont.callCancelHandler(it, cause) }\n        onCancellation?.let { cont.callOnCancellation(it, cause) }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CloseableCoroutineDispatcher.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * [CoroutineDispatcher] that provides a method to close it,\n * causing the rejection of any new tasks and cleanup of all underlying resources\n * associated with the current dispatcher.\n * Examples of closeable dispatchers are dispatchers backed by `java.lang.Executor` and\n * by `kotlin.native.Worker`.\n *\n * **The `CloseableCoroutineDispatcher` class is not stable for inheritance in 3rd party libraries**, as new methods\n * might be added to this interface in the future, but is stable for use.\n */\n@ExperimentalCoroutinesApi\npublic expect abstract class CloseableCoroutineDispatcher() : CoroutineDispatcher {\n\n    /**\n     * Initiate the closing sequence of the coroutine dispatcher.\n     * After a successful call to [close], no new tasks will be accepted to be [dispatched][dispatch].\n     * The previously-submitted tasks will still be run, but [close] is not guaranteed to wait for them to finish.\n     *\n     * Invocations of `close` are idempotent and thread-safe.\n     */\n    public abstract fun close()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CompletableDeferred.kt",
        "content": "@file:Suppress(\"DEPRECATION_ERROR\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.selects.*\n\n/**\n * A [Deferred] that can be completed via public functions [complete] or [cancel][Job.cancel].\n *\n * Note that the [complete] function returns `false` when this deferred value is already complete or completing,\n * while [cancel][Job.cancel] returns `true` as long as the deferred is still _cancelling_ and the corresponding\n * exception is incorporated into the final [completion exception][getCompletionExceptionOrNull].\n *\n * An instance of completable deferred can be created by `CompletableDeferred()` function in _active_ state.\n *\n * All functions on this interface are **thread-safe** and can\n * be safely invoked from concurrent coroutines without external synchronization.\n *\n * **The `CompletableDeferred` interface is not stable for inheritance in 3rd party libraries**,\n * as new methods might be added to this interface in the future, but is stable for use.\n */\npublic interface CompletableDeferred<T> : Deferred<T> {\n    /**\n     * Completes this deferred value with a given [value]. The result is `true` if this deferred was\n     * completed as a result of this invocation and `false` otherwise (if it was already completed).\n     *\n     * Subsequent invocations of this function have no effect and always produce `false`.\n     *\n     * This function transitions this deferred into _completed_ state if it was not completed or cancelled yet.\n     * However, if this deferred has children, then it transitions into _completing_ state and becomes _complete_\n     * once all its children are [complete][isCompleted]. See [Job] for details.\n     */\n    public fun complete(value: T): Boolean\n\n    /**\n     * Completes this deferred value exceptionally with a given [exception]. The result is `true` if this deferred was\n     * completed as a result of this invocation and `false` otherwise (if it was already completed).\n     *\n     * Subsequent invocations of this function have no effect and always produce `false`.\n     *\n     * This function transitions this deferred into _cancelled_ state if it was not completed or cancelled yet.\n     * However, that if this deferred has children, then it transitions into _cancelling_ state and becomes _cancelled_\n     * once all its children are [complete][isCompleted]. See [Job] for details.\n     */\n    public fun completeExceptionally(exception: Throwable): Boolean\n}\n\n/**\n * Completes this deferred value with the value or exception in the given [result]. Returns `true` if this deferred\n * was completed as a result of this invocation and `false` otherwise (if it was already completed).\n *\n * Subsequent invocations of this function have no effect and always produce `false`.\n *\n * This function transitions this deferred in the same ways described by [CompletableDeferred.complete] and\n * [CompletableDeferred.completeExceptionally].\n */\npublic fun <T> CompletableDeferred<T>.completeWith(result: Result<T>): Boolean =\n    result.fold({ complete(it) }, { completeExceptionally(it) })\n\n/**\n * Creates a [CompletableDeferred] in an _active_ state.\n * It is optionally a child of a [parent] job.\n */\n@Suppress(\"FunctionName\")\npublic fun <T> CompletableDeferred(parent: Job? = null): CompletableDeferred<T> = CompletableDeferredImpl(parent)\n\n/**\n * Creates an already _completed_ [CompletableDeferred] with a given [value].\n */\n@Suppress(\"FunctionName\")\npublic fun <T> CompletableDeferred(value: T): CompletableDeferred<T> = CompletableDeferredImpl<T>(null).apply { complete(value) }\n\n/**\n * Concrete implementation of [CompletableDeferred].\n */\n@Suppress(\"UNCHECKED_CAST\")\nprivate class CompletableDeferredImpl<T>(\n    parent: Job?\n) : JobSupport(true), CompletableDeferred<T> {\n    init { initParentJob(parent) }\n    override val onCancelComplete get() = true\n    override fun getCompleted(): T = getCompletedInternal() as T\n    override suspend fun await(): T = awaitInternal() as T\n    override val onAwait: SelectClause1<T> get() = onAwaitInternal as SelectClause1<T>\n\n    override fun complete(value: T): Boolean =\n        makeCompleting(value)\n    override fun completeExceptionally(exception: Throwable): Boolean =\n        makeCompleting(CompletedExceptionally(exception))\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CompletableJob.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * A job that can be completed using [complete()] function.\n * It is returned by [Job()][Job] and [SupervisorJob()][SupervisorJob] constructor functions.\n *\n * All functions on this interface are **thread-safe** and can\n * be safely invoked from concurrent coroutines without external synchronization.\n *\n * **The `CompletableJob` interface is not stable for inheritance in 3rd party libraries**,\n * as new methods might be added to this interface in the future, but is stable for use.\n */\npublic interface CompletableJob : Job {\n    /**\n     * Completes this job. The result is `true` if this job was completed as a result of this invocation and\n     * `false` otherwise (if it was already completed).\n     *\n     * Subsequent invocations of this function have no effect and always produce `false`.\n     *\n     * This function transitions this job into _completed_ state if it was not completed or cancelled yet.\n     * However, that if this job has children, then it transitions into _completing_ state and becomes _complete_\n     * once all its children are [complete][isCompleted]. See [Job] for details.\n     */\n    public fun complete(): Boolean\n\n    /**\n     * Completes this job exceptionally with a given [exception]. The result is `true` if this job was\n     * completed as a result of this invocation and `false` otherwise (if it was already completed).\n     * [exception] parameter is used as an additional debug information that is not handled by any exception handlers.\n     *\n     * Subsequent invocations of this function have no effect and always produce `false`.\n     *\n     * This function transitions this job into _cancelled_ state if it was not completed or cancelled yet.\n     * However, that if this job has children, then it transitions into _cancelling_ state and becomes _cancelled_\n     * once all its children are [complete][isCompleted]. See [Job] for details.\n     *\n     * Its responsibility of the caller to properly handle and report the given [exception], all job's children will receive\n     * a [CancellationException] with the [exception] as a cause for the sake of diagnostic.\n     */\n    public fun completeExceptionally(exception: Throwable): Boolean\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CompletionHandler.common.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * Handler for [Job.invokeOnCompletion] and [CancellableContinuation.invokeOnCancellation].\n *\n * The meaning of `cause` that is passed to the handler is:\n * - It is `null` if the job has completed normally or the continuation was cancelled without a `cause`.\n * - It is an instance of [CancellationException] if the job or the continuation was cancelled _normally_.\n *   **It should not be treated as an error**. In particular, it should not be reported to error logs.\n * - Otherwise, the job or the continuation had _failed_.\n *\n * A function used for this should not throw any exceptions.\n * If it does, they will get caught, wrapped into [CompletionHandlerException], and then either\n * - passed to [handleCoroutineException] for [CancellableContinuation.invokeOnCancellation]\n *   and, for [Job] instances that are coroutines, [Job.invokeOnCompletion], or\n * - for [Job] instances that are not coroutines, simply thrown, potentially crashing unrelated code.\n *\n * Functions used for this must be fast, non-blocking, and thread-safe.\n * This handler can be invoked concurrently with the surrounding code.\n * There is no guarantee on the execution context in which the function is invoked.\n *\n * **Note**: This type is a part of internal machinery that supports parent-child hierarchies\n * and allows for implementation of suspending functions that wait on the Job's state.\n * This type should not be used in general application code.\n */\n// TODO: deprecate. This doesn't seem better than a simple function type.\npublic typealias CompletionHandler = (cause: Throwable?) -> Unit\n\n/**\n * Essentially the same as just a function from `Throwable?` to `Unit`.\n * The only thing implementors can do is call [invoke].\n * The reason this abstraction exists is to allow providing a readable [toString] in the list of completion handlers\n * as seen from the debugger.\n * Use [UserSupplied] to create an instance from a lambda.\n * We can't avoid defining a separate type, because on JS, you can't inherit from a function type.\n *\n * @see CancelHandler for a very similar interface, but used for handling cancellation and not completion.\n */\ninternal interface InternalCompletionHandler {\n    /**\n     * Signals completion.\n     *\n     * This function:\n     * - Does not throw any exceptions.\n     *   For [Job] instances that are coroutines, exceptions thrown by this function will be caught, wrapped into\n     *   [CompletionHandlerException], and passed to [handleCoroutineException], but for those that are not coroutines,\n     *   they will just be rethrown, potentially crashing unrelated code.\n     * - Is fast, non-blocking, and thread-safe.\n     * - Can be invoked concurrently with the surrounding code.\n     * - Can be invoked from any context.\n     *\n     * The meaning of `cause` that is passed to the handler is:\n     * - It is `null` if the job has completed normally.\n     * - It is an instance of [CancellationException] if the job was cancelled _normally_.\n     *   **It should not be treated as an error**. In particular, it should not be reported to error logs.\n     * - Otherwise, the job had _failed_.\n     */\n    fun invoke(cause: Throwable?)\n\n    /**\n     * A lambda passed from outside the coroutine machinery.\n     *\n     * See the requirements for [InternalCompletionHandler.invoke] when implementing this function.\n     */\n    class UserSupplied(private val handler: (cause: Throwable?) -> Unit) : InternalCompletionHandler {\n        /** @suppress */\n        override fun invoke(cause: Throwable?) { handler(cause) }\n\n        override fun toString() = \"InternalCompletionHandler.UserSupplied[${handler.classSimpleName}@$hexAddress]\"\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CompletionState.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\ninternal fun <T> Result<T>.toState(\n    onCancellation: ((cause: Throwable) -> Unit)? = null\n): Any? = fold(\n    onSuccess = { if (onCancellation != null) CompletedWithCancellation(it, onCancellation) else it },\n    onFailure = { CompletedExceptionally(it) }\n)\n\ninternal fun <T> Result<T>.toState(caller: CancellableContinuation<*>): Any? = fold(\n    onSuccess = { it },\n    onFailure = { CompletedExceptionally(recoverStackTrace(it, caller)) }\n)\n\n@Suppress(\"RESULT_CLASS_IN_RETURN_TYPE\", \"UNCHECKED_CAST\")\ninternal fun <T> recoverResult(state: Any?, uCont: Continuation<T>): Result<T> =\n    if (state is CompletedExceptionally)\n        Result.failure(recoverStackTrace(state.cause, uCont))\n    else\n        Result.success(state as T)\n\ninternal data class CompletedWithCancellation(\n    @JvmField val result: Any?,\n    @JvmField val onCancellation: (cause: Throwable) -> Unit\n)\n\n/**\n * Class for an internal state of a job that was cancelled (completed exceptionally).\n *\n * @param cause the exceptional completion cause. It's either original exceptional cause\n *        or artificial [CancellationException] if no cause was provided\n */\ninternal open class CompletedExceptionally(\n    @JvmField val cause: Throwable,\n    handled: Boolean = false\n) {\n    private val _handled = atomic(handled)\n    val handled: Boolean get() = _handled.value\n    fun makeHandled(): Boolean = _handled.compareAndSet(false, true)\n    override fun toString(): String = \"$classSimpleName[$cause]\"\n}\n\n/**\n * A specific subclass of [CompletedExceptionally] for cancelled [AbstractContinuation].\n *\n * @param continuation the continuation that was cancelled.\n * @param cause the exceptional completion cause. If `cause` is null, then a [CancellationException]\n *        if created on first access to [exception] property.\n */\ninternal class CancelledContinuation(\n    continuation: Continuation<*>,\n    cause: Throwable?,\n    handled: Boolean\n) : CompletedExceptionally(cause ?: CancellationException(\"Continuation $continuation was cancelled normally\"), handled) {\n    private val _resumed = atomic(false)\n    fun makeResumed(): Boolean = _resumed.compareAndSet(false, true)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CoroutineContext.common.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\n\n/**\n * Creates a context for a new coroutine. It installs [Dispatchers.Default] when no other dispatcher or\n * [ContinuationInterceptor] is specified and adds optional support for debugging facilities (when turned on)\n * and copyable-thread-local facilities on JVM.\n */\npublic expect fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext\n\n/**\n * Creates a context for coroutine builder functions that do not launch a new coroutine, e.g. [withContext].\n * @suppress\n */\n@InternalCoroutinesApi\npublic expect fun CoroutineContext.newCoroutineContext(addedContext: CoroutineContext): CoroutineContext\n\n@PublishedApi // to have unmangled name when using from other modules via suppress\n@Suppress(\"PropertyName\")\ninternal expect val DefaultDelay: Delay\n\n// countOrElement -- pre-cached value for ThreadContext.kt\ninternal expect inline fun <T> withCoroutineContext(context: CoroutineContext, countOrElement: Any?, block: () -> T): T\ninternal expect inline fun <T> withContinuationContext(continuation: Continuation<*>, countOrElement: Any?, block: () -> T): T\ninternal expect fun Continuation<*>.toDebugString(): String\ninternal expect val CoroutineContext.coroutineName: String?\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n/**\n * Base class to be extended by all coroutine dispatcher implementations.\n *\n * The following standard implementations are provided by `kotlinx.coroutines` as properties on\n * the [Dispatchers] object:\n *\n * - [Dispatchers.Default] &mdash; is used by all standard builders if no dispatcher or any other [ContinuationInterceptor]\n *   is specified in their context. It uses a common pool of shared background threads.\n *   This is an appropriate choice for compute-intensive coroutines that consume CPU resources.\n * - [Dispatchers.IO] &mdash; uses a shared pool of on-demand created threads and is designed for offloading of IO-intensive _blocking_\n *   operations (like file I/O and blocking socket I/O).\n * - [Dispatchers.Unconfined] &mdash; starts coroutine execution in the current call-frame until the first suspension,\n *   whereupon the coroutine builder function returns.\n *   The coroutine will later resume in whatever thread used by the\n *   corresponding suspending function, without confining it to any specific thread or pool.\n *   **The `Unconfined` dispatcher should not normally be used in code**.\n * - Private thread pools can be created with [newSingleThreadContext] and [newFixedThreadPoolContext].\n * - An arbitrary [Executor][java.util.concurrent.Executor] can be converted to a dispatcher with the [asCoroutineDispatcher] extension function.\n *\n * This class ensures that debugging facilities in [newCoroutineContext] function work properly.\n */\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n\n    /** @suppress */\n    @ExperimentalStdlibApi\n    public companion object Key : AbstractCoroutineContextKey<ContinuationInterceptor, CoroutineDispatcher>(\n        ContinuationInterceptor,\n        { it as? CoroutineDispatcher })\n\n    /**\n     * Returns `true` if the execution of the coroutine should be performed with [dispatch] method.\n     * The default behavior for most dispatchers is to return `true`.\n     *\n     * If this method returns `false`, the coroutine is resumed immediately in the current thread,\n     * potentially forming an event-loop to prevent stack overflows.\n     * The event loop is an advanced topic and its implications can be found in [Dispatchers.Unconfined] documentation.\n     *\n     * The [context] parameter represents the context of the coroutine that is being dispatched,\n     * or [EmptyCoroutineContext] if a non-coroutine-specific [Runnable] is dispatched instead.\n     *\n     * A dispatcher can override this method to provide a performance optimization and avoid paying a cost of an unnecessary dispatch.\n     * E.g. [MainCoroutineDispatcher.immediate] checks whether we are already in the required UI thread in this method and avoids\n     * an additional dispatch when it is not required.\n     *\n     * While this approach can be more efficient, it is not chosen by default to provide a consistent dispatching behaviour\n     * so that users won't observe unexpected and non-consistent order of events by default.\n     *\n     * Coroutine builders like [launch][CoroutineScope.launch] and [async][CoroutineScope.async] accept an optional [CoroutineStart]\n     * parameter that allows one to optionally choose the [undispatched][CoroutineStart.UNDISPATCHED] behavior to start coroutine immediately,\n     * but to be resumed only in the provided dispatcher.\n     *\n     * This method should generally be exception-safe. An exception thrown from this method\n     * may leave the coroutines that use this dispatcher in the inconsistent and hard to debug state.\n     *\n     * @see dispatch\n     * @see Dispatchers.Unconfined\n     */\n    public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true\n\n    /**\n     * Creates a view of the current dispatcher that limits the parallelism to the given [value][parallelism].\n     * The resulting view uses the original dispatcher for execution, but with the guarantee that\n     * no more than [parallelism] coroutines are executed at the same time.\n     *\n     * This method does not impose restrictions on the number of views or the total sum of parallelism values,\n     * each view controls its own parallelism independently with the guarantee that the effective parallelism\n     * of all views cannot exceed the actual parallelism of the original dispatcher.\n     *\n     * ### Limitations\n     *\n     * The default implementation of `limitedParallelism` does not support direct dispatchers,\n     * such as executing the given runnable in place during [dispatch] calls.\n     * Any dispatcher that may return `false` from [isDispatchNeeded] is considered direct.\n     * For direct dispatchers, it is recommended to override this method\n     * and provide a domain-specific implementation or to throw an [UnsupportedOperationException].\n     *\n     * ### Example of usage\n     * ```\n     * private val backgroundDispatcher = newFixedThreadPoolContext(4, \"App Background\")\n     * // At most 2 threads will be processing images as it is really slow and CPU-intensive\n     * private val imageProcessingDispatcher = backgroundDispatcher.limitedParallelism(2)\n     * // At most 3 threads will be processing JSON to avoid image processing starvation\n     * private val jsonProcessingDispatcher = backgroundDispatcher.limitedParallelism(3)\n     * // At most 1 thread will be doing IO\n     * private val fileWriterDispatcher = backgroundDispatcher.limitedParallelism(1)\n     * ```\n     * Note how in this example the application has an executor with 4 threads, but the total sum of all limits\n     * is 6. Still, at most 4 coroutines can be executed simultaneously as each view limits only its own parallelism.\n     *\n     * Note that this example was structured in such a way that it illustrates the parallelism guarantees.\n     * In practice, it is usually better to use [Dispatchers.IO] or [Dispatchers.Default] instead of creating a\n     * `backgroundDispatcher`. It is both possible and advised to call `limitedParallelism` on them.\n     */\n    @ExperimentalCoroutinesApi\n    public open fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        parallelism.checkParallelism()\n        return LimitedDispatcher(this, parallelism)\n    }\n\n    /**\n     * Requests execution of a runnable [block].\n     * The dispatcher guarantees that [block] will eventually execute, typically by dispatching it to a thread pool,\n     * using a dedicated thread, or just executing the block in place.\n     * The [context] parameter represents the context of the coroutine that is being dispatched,\n     * or [EmptyCoroutineContext] if a non-coroutine-specific [Runnable] is dispatched instead.\n     * Implementations may use [context] for additional context-specific information,\n     * such as priority, whether the dispatched coroutine can be invoked in place,\n     * coroutine name, and additional diagnostic elements.\n     *\n     * This method should guarantee that the given [block] will be eventually invoked,\n     * otherwise the system may reach a deadlock state and never leave it.\n     * The cancellation mechanism is transparent for [CoroutineDispatcher] and is managed by [block] internals.\n     *\n     * This method should generally be exception-safe. An exception thrown from this method\n     * may leave the coroutines that use this dispatcher in an inconsistent and hard-to-debug state.\n     *\n     * This method must not immediately call [block]. Doing so may result in `StackOverflowError`\n     * when `dispatch` is invoked repeatedly, for example when [yield] is called in a loop.\n     * In order to execute a block in place, it is required to return `false` from [isDispatchNeeded]\n     * and delegate the `dispatch` implementation to `Dispatchers.Unconfined.dispatch` in such cases.\n     * To support this, the coroutines machinery ensures in-place execution and forms an event-loop to\n     * avoid unbound recursion.\n     *\n     * @see isDispatchNeeded\n     * @see Dispatchers.Unconfined\n     */\n    public abstract fun dispatch(context: CoroutineContext, block: Runnable)\n\n    /**\n     * Dispatches execution of a runnable `block` onto another thread in the given `context`\n     * with a hint for the dispatcher that the current dispatch is triggered by a [yield] call, so that the execution of this\n     * continuation may be delayed in favor of already dispatched coroutines.\n     *\n     * Though the `yield` marker may be passed as a part of [context], this\n     * is a separate method for performance reasons.\n     *\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @InternalCoroutinesApi\n    public open fun dispatchYield(context: CoroutineContext, block: Runnable): Unit = dispatch(context, block)\n\n    /**\n     * Returns a continuation that wraps the provided [continuation], thus intercepting all resumptions.\n     *\n     * This method should generally be exception-safe. An exception thrown from this method\n     * may leave the coroutines that use this dispatcher in the inconsistent and hard to debug state.\n     */\n    public final override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =\n        DispatchedContinuation(this, continuation)\n\n    public final override fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /*\n         * Unconditional cast is safe here: we only return DispatchedContinuation from `interceptContinuation`,\n         * any ClassCastException can only indicate compiler bug\n         */\n        val dispatched = continuation as DispatchedContinuation<*>\n        dispatched.release()\n    }\n\n    /**\n     * @suppress **Error**: Operator '+' on two CoroutineDispatcher objects is meaningless.\n     * CoroutineDispatcher is a coroutine context element and `+` is a set-sum operator for coroutine contexts.\n     * The dispatcher to the right of `+` just replaces the dispatcher to the left.\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\n        message = \"Operator '+' on two CoroutineDispatcher objects is meaningless. \" +\n            \"CoroutineDispatcher is a coroutine context element and `+` is a set-sum operator for coroutine contexts. \" +\n            \"The dispatcher to the right of `+` just replaces the dispatcher to the left.\",\n        level = DeprecationLevel.ERROR\n    )\n    public operator fun plus(other: CoroutineDispatcher): CoroutineDispatcher = other\n\n    /** @suppress for nicer debugging */\n    override fun toString(): String = \"$classSimpleName@$hexAddress\"\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CoroutineExceptionHandler.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n/**\n * Helper function for coroutine builder implementations to handle uncaught and unexpected exceptions in coroutines,\n * that could not be otherwise handled in a normal way through structured concurrency, saving them to a future, and\n * cannot be rethrown. This is a last resort handler to prevent lost exceptions.\n *\n * If there is [CoroutineExceptionHandler] in the context, then it is used. If it throws an exception during handling\n * or is absent, all instances of [CoroutineExceptionHandler] found via [ServiceLoader] and\n * [Thread.uncaughtExceptionHandler] are invoked.\n */\n@InternalCoroutinesApi\npublic fun handleCoroutineException(context: CoroutineContext, exception: Throwable) {\n    // Invoke an exception handler from the context if present\n    try {\n        context[CoroutineExceptionHandler]?.let {\n            it.handleException(context, exception)\n            return\n        }\n    } catch (t: Throwable) {\n        handleUncaughtCoroutineException(context, handlerException(exception, t))\n        return\n    }\n    // If a handler is not present in the context or an exception was thrown, fallback to the global handler\n    handleUncaughtCoroutineException(context, exception)\n}\n\ninternal fun handlerException(originalException: Throwable, thrownException: Throwable): Throwable {\n    if (originalException === thrownException) return originalException\n    return RuntimeException(\"Exception while trying to handle coroutine exception\", thrownException).apply {\n        addSuppressed(originalException)\n    }\n}\n\n/**\n * Creates a [CoroutineExceptionHandler] instance.\n * @param handler a function which handles exception thrown by a coroutine\n */\n@Suppress(\"FunctionName\")\npublic inline fun CoroutineExceptionHandler(crossinline handler: (CoroutineContext, Throwable) -> Unit): CoroutineExceptionHandler =\n    object : AbstractCoroutineContextElement(CoroutineExceptionHandler), CoroutineExceptionHandler {\n        override fun handleException(context: CoroutineContext, exception: Throwable) =\n            handler.invoke(context, exception)\n    }\n\n/**\n * An optional element in the coroutine context to handle **uncaught** exceptions.\n *\n * Normally, uncaught exceptions can only result from _root_ coroutines created using the [launch][CoroutineScope.launch] builder.\n * All _children_ coroutines (coroutines created in the context of another [Job]) delegate handling of their\n * exceptions to their parent coroutine, which also delegates to the parent, and so on until the root,\n * so the `CoroutineExceptionHandler` installed in their context is never used.\n * Coroutines running with [SupervisorJob] do not propagate exceptions to their parent and are treated like root coroutines.\n * A coroutine that was created using [async][CoroutineScope.async] always catches all its exceptions and represents them\n * in the resulting [Deferred] object, so it cannot result in uncaught exceptions.\n *\n * ### Handling coroutine exceptions\n *\n * `CoroutineExceptionHandler` is a last-resort mechanism for global \"catch all\" behavior.\n * You cannot recover from the exception in the `CoroutineExceptionHandler`. The coroutine had already completed\n * with the corresponding exception when the handler is called. Normally, the handler is used to\n * log the exception, show some kind of error message, terminate, and/or restart the application.\n *\n * If you need to handle exception in a specific part of the code, it is recommended to use `try`/`catch` around\n * the corresponding code inside your coroutine. This way you can prevent completion of the coroutine\n * with the exception (exception is now _caught_), retry the operation, and/or take other arbitrary actions:\n *\n * ```\n * scope.launch { // launch child coroutine in a scope\n *     try {\n *          // do something\n *     } catch (e: Throwable) {\n *          // handle exception\n *     }\n * }\n * ```\n *\n * ### Uncaught exceptions with no handler\n *\n * When no handler is installed, exception are handled in the following way:\n * - If exception is [CancellationException], it is ignored, as these exceptions are used to cancel coroutines.\n * - Otherwise, if there is a [Job] in the context, then [Job.cancel] is invoked.\n * - Otherwise, as a last resort, the exception is processed in a platform-specific manner:\n *   - On JVM, all instances of [CoroutineExceptionHandler] found via [ServiceLoader], as well as\n *     the current thread's [Thread.uncaughtExceptionHandler], are invoked.\n *   - On Native, the whole application crashes with the exception.\n *   - On JS, the exception is logged via the Console API.\n *\n * [CoroutineExceptionHandler] can be invoked from an arbitrary thread.\n */\npublic interface CoroutineExceptionHandler : CoroutineContext.Element {\n    /**\n     * Key for [CoroutineExceptionHandler] instance in the coroutine context.\n     */\n    public companion object Key : CoroutineContext.Key<CoroutineExceptionHandler>\n\n    /**\n     * Handles uncaught [exception] in the given [context]. It is invoked\n     * if coroutine has an uncaught exception.\n     */\n    public fun handleException(context: CoroutineContext, exception: Throwable)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CoroutineName.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.AbstractCoroutineContextElement\nimport kotlin.coroutines.CoroutineContext\n\n/**\n * User-specified name of coroutine. This name is used in debugging mode.\n * See [newCoroutineContext][CoroutineScope.newCoroutineContext] for the description of coroutine debugging facilities.\n */\npublic data class CoroutineName(\n    /**\n     * User-defined coroutine name.\n     */\n    val name: String\n) : AbstractCoroutineContextElement(CoroutineName) {\n    /**\n     * Key for [CoroutineName] instance in the coroutine context.\n     */\n    public companion object Key : CoroutineContext.Key<CoroutineName>\n\n    /**\n     * Returns a string representation of the object.\n     */\n    override fun toString(): String = \"CoroutineName($name)\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CoroutineScope.kt",
        "content": "@file:OptIn(ExperimentalContracts::class)\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.intrinsics.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n/**\n * Defines a scope for new coroutines. Every **coroutine builder** (like [launch], [async], etc.)\n * is an extension on [CoroutineScope] and inherits its [coroutineContext][CoroutineScope.coroutineContext]\n * to automatically propagate all its elements and cancellation.\n *\n * The best ways to obtain a standalone instance of the scope are [CoroutineScope()] and [MainScope()] factory functions,\n * taking care to cancel these coroutine scopes when they are no longer needed (see section on custom usage below for\n * explanation and example).\n *\n * Additional context elements can be appended to the scope using the [plus][CoroutineScope.plus] operator.\n *\n * ### Convention for structured concurrency\n *\n * Manual implementation of this interface is not recommended, implementation by delegation should be preferred instead.\n * By convention, the [context of a scope][CoroutineScope.coroutineContext] should contain an instance of a\n * [job][Job] to enforce the discipline of **structured concurrency** with propagation of cancellation.\n *\n * Every coroutine builder (like [launch], [async], and others)\n * and every scoping function (like [coroutineScope] and [withContext]) provides _its own_ scope\n * with its own [Job] instance into the inner block of code it runs.\n * By convention, they all wait for all the coroutines inside their block to complete before completing themselves,\n * thus enforcing the structured concurrency. See [Job] documentation for more details.\n *\n * ### Android usage\n *\n * Android has first-party support for coroutine scope in all entities with the lifecycle.\n * See [the corresponding documentation](https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope).\n *\n * ### Custom usage\n *\n * `CoroutineScope` should be declared as a property on entities with a well-defined lifecycle that are\n * responsible for launching child coroutines. The corresponding instance of `CoroutineScope` shall be created\n * with either `CoroutineScope()` or `MainScope()`:\n *\n * - `CoroutineScope()` uses the [context][CoroutineContext] provided to it as a parameter for its coroutines \n *   and adds a [Job] if one is not provided as part of the context.\n * - `MainScope()` uses [Dispatchers.Main] for its coroutines and has a [SupervisorJob].\n *\n * **The key part of custom usage of `CoroutineScope` is cancelling it at the end of the lifecycle.**\n * The [CoroutineScope.cancel] extension function shall be used when the entity that was launching coroutines\n * is no longer needed. It cancels all the coroutines that might still be running on behalf of it.\n *\n * For example:\n *\n * ```\n * class MyUIClass {\n *     val scope = MainScope() // the scope of MyUIClass, uses Dispatchers.Main\n *\n *     fun destroy() { // destroys an instance of MyUIClass\n *         scope.cancel() // cancels all coroutines launched in this scope\n *         // ... do the rest of cleanup here ...\n *     }\n *\n *     /*\n *      * Note: if this instance is destroyed or any of the launched coroutines\n *      * in this method throws an exception, then all nested coroutines are cancelled.\n *      */\n *     fun showSomeData() = scope.launch { // launched in the main thread\n *        // ... here we can use suspending functions or coroutine builders with other dispatchers\n *        draw(data) // draw in the main thread\n *     }\n * }\n * ```\n */\npublic interface CoroutineScope {\n    /**\n     * The context of this scope.\n     * Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope.\n     * Accessing this property in general code is not recommended for any purposes except accessing the [Job] instance for advanced usages.\n     *\n     * By convention, should contain an instance of a [job][Job] to enforce structured concurrency.\n     */\n    public val coroutineContext: CoroutineContext\n}\n\n/**\n * Adds the specified coroutine context to this scope, overriding existing elements in the current\n * scope's context with the corresponding keys.\n *\n * This is a shorthand for `CoroutineScope(thisScope.coroutineContext + context)`.\n */\npublic operator fun CoroutineScope.plus(context: CoroutineContext): CoroutineScope =\n    ContextScope(coroutineContext + context)\n\n/**\n * Creates the main [CoroutineScope] for UI components.\n *\n * Example of use:\n * ```\n * class MyAndroidActivity {\n *     private val scope = MainScope()\n *\n *     override fun onDestroy() {\n *         super.onDestroy()\n *         scope.cancel()\n *     }\n * }\n * ```\n *\n * The resulting scope has [SupervisorJob] and [Dispatchers.Main] context elements.\n * If you want to append additional elements to the main scope, use [CoroutineScope.plus] operator:\n * `val scope = MainScope() + CoroutineName(\"MyActivity\")`.\n */\n@Suppress(\"FunctionName\")\npublic fun MainScope(): CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)\n\n/**\n * Returns `true` when the current [Job] is still active (has not completed and was not cancelled yet).\n *\n * Check this property in long-running computation loops to support cancellation:\n * ```\n * while (isActive) {\n *     // do some computation\n * }\n * ```\n *\n * This property is a shortcut for `coroutineContext.isActive` in the scope when\n * [CoroutineScope] is available.\n * See [coroutineContext][kotlin.coroutines.coroutineContext],\n * [isActive][kotlinx.coroutines.isActive] and [Job.isActive].\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic val CoroutineScope.isActive: Boolean\n    get() = coroutineContext[Job]?.isActive ?: true\n\n/**\n * A global [CoroutineScope] not bound to any job.\n * Global scope is used to launch top-level coroutines which are operating on the whole application lifetime\n * and are not cancelled prematurely.\n *\n * Active coroutines launched in `GlobalScope` do not keep the process alive. They are like daemon threads.\n *\n * This is a **delicate** API. It is easy to accidentally create resource or memory leaks when\n * `GlobalScope` is used. A coroutine launched in `GlobalScope` is not subject to the principle of structured\n * concurrency, so if it hangs or gets delayed due to a problem (e.g. due to a slow network), it will stay working\n * and consuming resources. For example, consider the following code:\n *\n * ```\n * fun loadConfiguration() {\n *     GlobalScope.launch {\n *         val config = fetchConfigFromServer() // network request\n *         updateConfiguration(config)\n *     }\n * }\n * ```\n *\n * A call to `loadConfiguration` creates a coroutine in the `GlobalScope` that works in background without any\n * provision to cancel it or to wait for its completion. If a network is slow, it keeps waiting in background,\n * consuming resources. Repeated calls to `loadConfiguration` will consume more and more resources.\n *\n * ### Possible replacements\n *\n * In many cases uses of `GlobalScope` should be removed, marking the containing operation with `suspend`, for example:\n *\n * ```\n * suspend fun loadConfiguration() {\n *     val config = fetchConfigFromServer() // network request\n *     updateConfiguration(config)\n * }\n * ```\n *\n * In cases when `GlobalScope.launch` was used to launch multiple concurrent operations, the corresponding\n * operations shall be grouped with [coroutineScope] instead:\n *\n * ```\n * // concurrently load configuration and data\n * suspend fun loadConfigurationAndData() {\n *     coroutineScope {\n *         launch { loadConfiguration() }\n *         launch { loadData() }\n *     }\n * }\n * ```\n *\n * In top-level code, when launching a concurrent operation from a non-suspending context, an appropriately\n * confined instance of [CoroutineScope] shall be used instead of a `GlobalScope`. See docs on [CoroutineScope] for\n * details.\n *\n * ### GlobalScope vs custom scope\n *\n * Do not replace `GlobalScope.launch { ... }` with `CoroutineScope().launch { ... }` constructor function call.\n * The latter has the same pitfalls as `GlobalScope`. See [CoroutineScope] documentation on the intended usage of\n * `CoroutineScope()` constructor function.\n *\n * ### Legitimate use-cases\n *\n * There are limited circumstances under which `GlobalScope` can be legitimately and safely used, such as top-level background\n * processes that must stay active for the whole duration of the application's lifetime. Because of that, any use\n * of `GlobalScope` requires an explicit opt-in with `@OptIn(DelicateCoroutinesApi::class)`, like this:\n *\n * ```\n * // A global coroutine to log statistics every second, must be always active\n * @OptIn(DelicateCoroutinesApi::class)\n * val globalScopeReporter = GlobalScope.launch {\n *     while (true) {\n *         delay(1000)\n *         logStatistics()\n *     }\n * }\n * ```\n */\n@DelicateCoroutinesApi\npublic object GlobalScope : CoroutineScope {\n    /**\n     * Returns [EmptyCoroutineContext].\n     */\n    override val coroutineContext: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n\n/**\n * Creates a [CoroutineScope] and calls the specified suspend block with this scope.\n * The provided scope inherits its [coroutineContext][CoroutineScope.coroutineContext] from the outer scope, using the\n * [Job] from that context as the parent for a new [Job].\n *\n * This function is designed for _concurrent decomposition_ of work. When any child coroutine in this scope fails,\n * this scope fails, cancelling all the other children (for a different behavior, see [supervisorScope]).\n * This function returns as soon as the given block and all its child coroutines are completed.\n * A usage of a scope looks like this:\n *\n * ```\n * suspend fun showSomeData() = coroutineScope {\n *     val data = async(Dispatchers.IO) { // <- extension on current scope\n *      ... load some UI data for the Main thread ...\n *     }\n *\n *     withContext(Dispatchers.Main) {\n *         doSomeWork()\n *         val result = data.await()\n *         display(result)\n *     }\n * }\n * ```\n *\n * The scope in this example has the following semantics:\n * 1) `showSomeData` returns as soon as the data is loaded and displayed in the UI.\n * 2) If `doSomeWork` throws an exception, then the `async` task is cancelled and `showSomeData` rethrows that exception.\n * 3) If the outer scope of `showSomeData` is cancelled, both started `async` and `withContext` blocks are cancelled.\n * 4) If the `async` block fails, `withContext` will be cancelled.\n *\n * The method may throw a [CancellationException] if the current job was cancelled externally,\n * rethrow the exception thrown by [block], or throw an unhandled [Throwable] if there is one\n * (for example, from a crashed coroutine that was started with [launch][CoroutineScope.launch] in this scope).\n */\npublic suspend fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return suspendCoroutineUninterceptedOrReturn { uCont ->\n        val coroutine = ScopeCoroutine(uCont.context, uCont)\n        coroutine.startUndispatchedOrReturn(coroutine, block)\n    }\n}\n\n/**\n * Creates a [CoroutineScope] that wraps the given coroutine [context].\n *\n * If the given [context] does not contain a [Job] element, then a default `Job()` is created.\n * This way, failure of any child coroutine in this scope or [cancellation][CoroutineScope.cancel] of the scope itself\n * cancels all the scope's children, just like inside [coroutineScope] block.\n */\n@Suppress(\"FunctionName\")\npublic fun CoroutineScope(context: CoroutineContext): CoroutineScope =\n    ContextScope(if (context[Job] != null) context else context + Job())\n\n/**\n * Cancels this scope, including its job and all its children with an optional cancellation [cause].\n * A cause can be used to specify an error message or to provide other details on\n * a cancellation reason for debugging purposes.\n * Throws [IllegalStateException] if the scope does not have a job in it.\n */\npublic fun CoroutineScope.cancel(cause: CancellationException? = null) {\n    val job = coroutineContext[Job] ?: error(\"Scope cannot be cancelled because it does not have a job: $this\")\n    job.cancel(cause)\n}\n\n/**\n * Cancels this scope, including its job and all its children with a specified diagnostic error [message].\n * A [cause] can be specified to provide additional details on a cancellation reason for debugging purposes.\n * Throws [IllegalStateException] if the scope does not have a job in it.\n */\npublic fun CoroutineScope.cancel(message: String, cause: Throwable? = null): Unit = cancel(CancellationException(message, cause))\n\n/**\n * Ensures that current scope is [active][CoroutineScope.isActive].\n *\n * If the job is no longer active, throws [CancellationException].\n * If the job was cancelled, thrown exception contains the original cancellation cause.\n * This function does not do anything if there is no [Job] in the scope's [coroutineContext][CoroutineScope.coroutineContext].\n *\n * This method is a drop-in replacement for the following code, but with more precise exception:\n * ```\n * if (!isActive) {\n *     throw CancellationException()\n * }\n * ```\n *\n * @see CoroutineContext.ensureActive\n */\npublic fun CoroutineScope.ensureActive(): Unit = coroutineContext.ensureActive()\n\n\n/**\n * Returns the current [CoroutineContext] retrieved by using [kotlin.coroutines.coroutineContext].\n * This function is an alias to avoid name clash with [CoroutineScope.coroutineContext] in a receiver position:\n *\n * ```\n * launch { // this: CoroutineScope\n *     val flow = flow<Unit> {\n *         coroutineContext // Resolves into the context of outer launch, which is incorrect, see KT-38033\n *         currentCoroutineContext() // Retrieves actual context where the flow is collected\n *     }\n * }\n * ```\n */\npublic suspend inline fun currentCoroutineContext(): CoroutineContext = coroutineContext\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/CoroutineStart.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.CoroutineStart.*\nimport kotlinx.coroutines.intrinsics.*\nimport kotlin.coroutines.*\n\n/**\n * Defines start options for coroutines builders.\n * It is used in `start` parameter of [launch][CoroutineScope.launch], [async][CoroutineScope.async], and other coroutine builder functions.\n *\n * The summary of coroutine start options is:\n * - [DEFAULT] -- immediately schedules coroutine for execution according to its context;\n * - [LAZY] -- starts coroutine lazily, only when it is needed;\n * - [ATOMIC] -- atomically (in a non-cancellable way) schedules coroutine for execution according to its context;\n * - [UNDISPATCHED] -- immediately executes coroutine until its first suspension point _in the current thread_.\n */\npublic enum class CoroutineStart {\n    /**\n     * Default -- immediately schedules the coroutine for execution according to its context.\n     *\n     * If the [CoroutineDispatcher] of the coroutine context returns `true` from [CoroutineDispatcher.isDispatchNeeded]\n     * function as most dispatchers do, then the coroutine code is dispatched for execution later, while the code that\n     * invoked the coroutine builder continues execution.\n     *\n     * Note that [Dispatchers.Unconfined] always returns `false` from its [CoroutineDispatcher.isDispatchNeeded]\n     * function, so starting a coroutine with [Dispatchers.Unconfined] by [DEFAULT] is the same as using [UNDISPATCHED].\n     *\n     * If coroutine [Job] is cancelled before it even had a chance to start executing, then it will not start its\n     * execution at all, but will complete with an exception.\n     *\n     * Cancellability of a coroutine at suspension points depends on the particular implementation details of\n     * suspending functions. Use [suspendCancellableCoroutine] to implement cancellable suspending functions.\n     */\n    DEFAULT,\n\n    /**\n     * Starts the coroutine lazily, only when it is needed.\n     *\n     * See the documentation for the corresponding coroutine builders for details\n     * (like [launch][CoroutineScope.launch] and [async][CoroutineScope.async]).\n     *\n     * If coroutine [Job] is cancelled before it even had a chance to start executing, then it will not start its\n     * execution at all, but will complete with an exception.\n     */\n    LAZY,\n\n    /**\n     * Atomically (i.e., in a non-cancellable way) schedules the coroutine for execution according to its context.\n     * This is similar to [DEFAULT], but the coroutine cannot be cancelled before it starts executing.\n     *\n     * Cancellability of coroutine at suspension points depends on the particular implementation details of\n     * suspending functions as in [DEFAULT].\n     */\n    @ExperimentalCoroutinesApi // Since 1.0.0, no ETA on stability\n    ATOMIC,\n\n    /**\n     * Immediately executes the coroutine until its first suspension point _in the current thread_ similarly to\n     * the coroutine being started using [Dispatchers.Unconfined]. However, when the coroutine is resumed from suspension\n     * it is dispatched according to the [CoroutineDispatcher] in its context.\n     *\n     * This is similar to [ATOMIC] in the sense that coroutine starts executing even if it was already cancelled,\n     * but the difference is that it starts executing in the same thread.\n     *\n     * Cancellability of coroutine at suspension points depends on the particular implementation details of\n     * suspending functions as in [DEFAULT].\n     *\n     * ### Unconfined event loop\n     *\n     * Unlike [Dispatchers.Unconfined] and [MainCoroutineDispatcher.immediate], nested undispatched coroutines do not form\n     * an event loop that otherwise prevents potential stack overflow in case of unlimited nesting.\n     */\n    UNDISPATCHED;\n\n    /**\n     * Starts the corresponding block with receiver as a coroutine with this coroutine start strategy.\n     *\n     * - [DEFAULT] uses [startCoroutineCancellable].\n     * - [ATOMIC] uses [startCoroutine].\n     * - [UNDISPATCHED] uses [startCoroutineUndispatched].\n     * - [LAZY] does nothing.\n     *\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @InternalCoroutinesApi\n    public operator fun <R, T> invoke(block: suspend R.() -> T, receiver: R, completion: Continuation<T>): Unit =\n        when (this) {\n            DEFAULT -> block.startCoroutineCancellable(receiver, completion)\n            ATOMIC -> block.startCoroutine(receiver, completion)\n            UNDISPATCHED -> block.startCoroutineUndispatched(receiver, completion)\n            LAZY -> Unit // will start lazily\n        }\n\n    /**\n     * Returns `true` when [LAZY].\n     *\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @InternalCoroutinesApi\n    public val isLazy: Boolean get() = this === LAZY\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Debug.common.kt",
        "content": "package kotlinx.coroutines\n\ninternal expect val DEBUG: Boolean\ninternal expect val Any.hexAddress: String\ninternal expect val Any.classSimpleName: String\ninternal expect fun assert(value: () -> Boolean)\n\n/**\n * Throwable which can be cloned during stacktrace recovery in a class-specific way.\n * For additional information about stacktrace recovery see [STACKTRACE_RECOVERY_PROPERTY_NAME]\n *\n * Example of usage:\n * ```\n * class BadResponseCodeException(val responseCode: Int) : Exception(), CopyableThrowable<BadResponseCodeException> {\n *\n *  override fun createCopy(): BadResponseCodeException {\n *    val result = BadResponseCodeException(responseCode)\n *    result.initCause(this)\n *    return result\n *  }\n * ```\n *\n * Copy mechanism is used only on JVM, but it might be convenient to implement it in common exceptions,\n * so on JVM their stacktraces will be properly recovered.\n */\n@ExperimentalCoroutinesApi // Since 1.2.0, no ETA on stability\npublic interface CopyableThrowable<T> where T : Throwable, T : CopyableThrowable<T> {\n\n    /**\n     * Creates a copy of the current instance.\n     *\n     * For better debuggability, it is recommended to use original exception as [cause][Throwable.cause] of the resulting one.\n     * Stacktrace of copied exception will be overwritten by stacktrace recovery machinery by [Throwable.setStackTrace] call.\n     * An exception can opt-out of copying by returning `null` from this function.\n     * Suppressed exceptions of the original exception should not be copied in order to avoid circular exceptions.\n     *\n     * This function is allowed to create a copy with a modified [message][Throwable.message], but it should be noted\n     * that the copy can be later recovered as well and message modification code should handle this situation correctly\n     * (e.g. by also storing the original message and checking it) to produce a human-readable result.\n     */\n    public fun createCopy(): T?\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Deferred.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.selects.*\n\n/**\n * Deferred value is a non-blocking cancellable future &mdash; it is a [Job] with a result.\n *\n * It is created with the [async][CoroutineScope.async] coroutine builder or via the constructor of [CompletableDeferred] class.\n * It is in [active][isActive] state while the value is being computed.\n *\n * `Deferred` has the same state machine as the [Job] with additional convenience methods to retrieve\n * the successful or failed result of the computation that was carried out. The result of the deferred is\n * available when it is [completed][isCompleted] and can be retrieved by [await] method, which throws\n * an exception if the deferred had failed.\n * Note that a _cancelled_ deferred is also considered as completed.\n * The corresponding exception can be retrieved via [getCompletionExceptionOrNull] from a completed instance of deferred.\n *\n * Usually, a deferred value is created in _active_ state (it is created and started).\n * However, the [async][CoroutineScope.async] coroutine builder has an optional `start` parameter that creates a deferred value in _new_ state\n * when this parameter is set to [CoroutineStart.LAZY].\n * Such a deferred can be made _active_ by invoking [start], [join], or [await].\n *\n * A deferred value is a [Job]. A job in the\n * [coroutineContext](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/coroutine-context.html)\n * of [async][CoroutineScope.async] builder represents the coroutine itself.\n *\n * All functions on this interface and on all interfaces derived from it are **thread-safe** and can\n * be safely invoked from concurrent coroutines without external synchronization.\n *\n * **`Deferred` interface and all its derived interfaces are not stable for inheritance in 3rd party libraries**,\n * as new methods might be added to this interface in the future, but is stable for use.\n */\npublic interface Deferred<out T> : Job {\n\n    /**\n     * Awaits for completion of this value without blocking the thread and returns the resulting value or throws\n     * the exception if the deferred was cancelled.\n     *\n     * Unless the calling coroutine is cancelled, [await] will return the same result on each invocation:\n     * if the [Deferred] completed successfully, [await] will return the same value every time;\n     * if the [Deferred] completed exceptionally, [await] will rethrow the same exception.\n     *\n     * This suspending function is itself cancellable: if the [Job] of the current coroutine is cancelled or completed\n     * while this suspending function is waiting, this function immediately resumes with [CancellationException].\n     *\n     * This means that [await] can throw [CancellationException] in two cases:\n     * - if the coroutine in which [await] was called got cancelled,\n     * - or if the [Deferred] itself got completed with a [CancellationException].\n     *\n     * In both cases, the [CancellationException] will cancel the coroutine calling [await], unless it's caught.\n     * The following idiom may be helpful to avoid this:\n     * ```\n     * try {\n     *    deferred.await()\n     * } catch (e: CancellationException) {\n     *    currentCoroutineContext().ensureActive() // throws if the current coroutine was cancelled\n     *    processException(e) // if this line executes, the exception is the result of `await` itself\n     * }\n     * ```\n     *\n     * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n     * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n     *\n     * This function can be used in [select] invocations with an [onAwait] clause.\n     * Use [isCompleted] to check for completion of this deferred value without waiting, and\n     * [join] to wait for completion without returning the result.\n     */\n    public suspend fun await(): T\n\n    /**\n     * Clause using the [await] suspending function as a [select] clause.\n     * It selects with the deferred value when the [Deferred] completes.\n     * If [Deferred] completes with an exception, the whole the [select] invocation fails with the same exception.\n     * Note that, if [Deferred] completed with a [CancellationException], throwing it may have unintended\n     * consequences. See [await] for details.\n     */\n    public val onAwait: SelectClause1<T>\n\n    /**\n     * Returns *completed* result or throws [IllegalStateException] if this deferred value has not\n     * [completed][isCompleted] yet. It throws the corresponding exception if this deferred was [cancelled][isCancelled].\n     *\n     * This function is designed to be used from [invokeOnCompletion] handlers, when there is an absolute certainty that\n     * the value is already complete. See also [getCompletionExceptionOrNull].\n     *\n     * **Note: This is an experimental api.** This function may be removed or renamed in the future.\n     */\n    @ExperimentalCoroutinesApi\n    public fun getCompleted(): T\n\n    /**\n     * Returns *completion exception* result if this deferred was [cancelled][isCancelled] and has [completed][isCompleted],\n     * `null` if it had completed normally, or throws [IllegalStateException] if this deferred value has not\n     * [completed][isCompleted] yet.\n     *\n     * This function is designed to be used from [invokeOnCompletion] handlers, when there is an absolute certainty that\n     * the value is already complete. See also [getCompleted].\n     *\n     * **Note: This is an experimental api.** This function may be removed or renamed in the future.\n     */\n    @ExperimentalCoroutinesApi\n    public fun getCompletionExceptionOrNull(): Throwable?\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Delay.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.selects.*\nimport kotlin.coroutines.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.nanoseconds\n\n/**\n * This dispatcher _feature_ is implemented by [CoroutineDispatcher] implementations that natively support\n * scheduled execution of tasks.\n *\n * Implementation of this interface affects operation of\n * [delay][kotlinx.coroutines.delay] and [withTimeout] functions.\n *\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic interface Delay {\n\n    /** @suppress **/\n    @Deprecated(\n        message = \"Deprecated without replacement as an internal method never intended for public use\",\n        level = DeprecationLevel.ERROR\n    ) // Error since 1.6.0\n    public suspend fun delay(time: Long) {\n        if (time <= 0) return // don't delay\n        return suspendCancellableCoroutine { scheduleResumeAfterDelay(time, it) }\n    }\n\n    /**\n     * Schedules resume of a specified [continuation] after a specified delay [timeMillis].\n     *\n     * Continuation **must be scheduled** to resume even if it is already cancelled, because a cancellation is just\n     * an exception that the coroutine that used `delay` might wanted to catch and process. It might\n     * need to close some resources in its `finally` blocks, for example.\n     *\n     * This implementation is supposed to use dispatcher's native ability for scheduled execution in its thread(s).\n     * In order to avoid an extra delay of execution, the following code shall be used to resume this\n     * [continuation] when the code is already executing in the appropriate thread:\n     *\n     * ```kotlin\n     * with(continuation) { resumeUndispatchedWith(Unit) }\n     * ```\n     */\n    public fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>)\n\n    /**\n     * Schedules invocation of a specified [block] after a specified delay [timeMillis].\n     * The resulting [DisposableHandle] can be used to [dispose][DisposableHandle.dispose] of this invocation\n     * request if it is not needed anymore.\n     */\n    public fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle =\n        DefaultDelay.invokeOnTimeout(timeMillis, block, context)\n}\n\n/**\n * Enhanced [Delay] interface that provides additional diagnostics for [withTimeout].\n * Is going to be removed once there is proper JVM-default support.\n * Then we'll be able put this function into [Delay] without breaking binary compatibility.\n */\n@InternalCoroutinesApi\ninternal interface DelayWithTimeoutDiagnostics : Delay {\n    /**\n     * Returns a string that explains that the timeout has occurred, and explains what can be done about it.\n     */\n    fun timeoutMessage(timeout: Duration): String\n}\n\n/**\n * Suspends until cancellation, in which case it will throw a [CancellationException].\n *\n * This function returns [Nothing], so it can be used in any coroutine,\n * regardless of the required return type.\n *\n * Usage example in callback adapting code:\n *\n * ```kotlin\n * fun currentTemperature(): Flow<Temperature> = callbackFlow {\n *     val callback = SensorCallback { degreesCelsius: Double ->\n *         trySend(Temperature.celsius(degreesCelsius))\n *     }\n *     try {\n *         registerSensorCallback(callback)\n *         awaitCancellation() // Suspends to keep getting updates until cancellation.\n *     } finally {\n *         unregisterSensorCallback(callback)\n *     }\n * }\n * ```\n *\n * Usage example in (non declarative) UI code:\n *\n * ```kotlin\n * suspend fun showStuffUntilCancelled(content: Stuff): Nothing {\n *     someSubView.text = content.title\n *     anotherSubView.text = content.description\n *     someView.visibleInScope {\n *         awaitCancellation() // Suspends so the view stays visible.\n *     }\n * }\n * ```\n */\npublic suspend fun awaitCancellation(): Nothing = suspendCancellableCoroutine {}\n\n/**\n * Delays coroutine for at least the given time without blocking a thread and resumes it after a specified time.\n * If the given [timeMillis] is non-positive, this function returns immediately.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n *\n * If you want to delay forever (until cancellation), consider using [awaitCancellation] instead.\n *\n * Note that delay can be used in [select] invocation with [onTimeout][SelectBuilder.onTimeout] clause.\n *\n * Implementation note: how exactly time is tracked is an implementation detail of [CoroutineDispatcher] in the context.\n * @param timeMillis time in milliseconds.\n */\npublic suspend fun delay(timeMillis: Long) {\n    if (timeMillis <= 0) return // don't delay\n    return suspendCancellableCoroutine sc@ { cont: CancellableContinuation<Unit> ->\n        // if timeMillis == Long.MAX_VALUE then just wait forever like awaitCancellation, don't schedule.\n        if (timeMillis < Long.MAX_VALUE) {\n            cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)\n        }\n    }\n}\n\n/**\n * Delays coroutine for at least the given [duration] without blocking a thread and resumes it after the specified time.\n * If the given [duration] is non-positive, this function returns immediately.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n *\n * If you want to delay forever (until cancellation), consider using [awaitCancellation] instead.\n *\n * Note that delay can be used in [select] invocation with [onTimeout][SelectBuilder.onTimeout] clause.\n *\n * Implementation note: how exactly time is tracked is an implementation detail of [CoroutineDispatcher] in the context.\n */\npublic suspend fun delay(duration: Duration): Unit = delay(duration.toDelayMillis())\n\n/** Returns [Delay] implementation of the given context */\ninternal val CoroutineContext.delay: Delay get() = get(ContinuationInterceptor) as? Delay ?: DefaultDelay\n\n/**\n * Convert this duration to its millisecond value. Durations which have a nanosecond component less than\n * a single millisecond will be rounded up to the next largest millisecond.\n */\ninternal fun Duration.toDelayMillis(): Long = when (isPositive()) {\n    true -> plus(999_999L.nanoseconds).inWholeMilliseconds\n    false -> 0L\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Dispatchers.common.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\n\n/**\n * Groups various implementations of [CoroutineDispatcher].\n */\npublic expect object Dispatchers {\n    /**\n     * The default [CoroutineDispatcher] that is used by all standard builders like\n     * [launch][CoroutineScope.launch], [async][CoroutineScope.async], etc.\n     * if neither a dispatcher nor any other [ContinuationInterceptor] is specified in their context.\n     *\n     * It is backed by a shared pool of threads on JVM and Native. By default, the maximum number of threads used\n     * by this dispatcher is equal to the number of CPU cores, but is at least two.\n     */\n    public val Default: CoroutineDispatcher\n\n    /**\n     * A coroutine dispatcher that is confined to the Main thread operating with UI objects.\n     * Usually such dispatchers are single-threaded.\n     *\n     * Access to this property may throw an [IllegalStateException] if no main dispatchers are present in the classpath.\n     *\n     * Depending on platform and classpath, it can be mapped to different dispatchers:\n     * - On JVM it is either the Android main thread dispatcher, JavaFx, or Swing EDT dispatcher. It is chosen by the\n     *   [`ServiceLoader`](https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html).\n     * - On JS it is equivalent to the [Default] dispatcher with [immediate][MainCoroutineDispatcher.immediate] support.\n     * - On Native Darwin-based targets, it is a dispatcher backed by Darwin's main queue.\n     * - On other Native targets, it is not available.\n     * - `Dispatchers.setMain` from the `kotlinx-coroutines-test` artifact can replace the main dispatcher with a mock one for testing.\n     *\n     * In order to work with the `Main` dispatcher on the JVM, the following artifact should be added to the project runtime dependencies:\n     *  - `kotlinx-coroutines-android` &mdash; for Android Main thread dispatcher\n     *  - `kotlinx-coroutines-javafx` &mdash; for JavaFx Application thread dispatcher\n     *  - `kotlinx-coroutines-swing` &mdash; for Swing EDT dispatcher\n     */\n    public val Main: MainCoroutineDispatcher\n\n    /**\n     * A coroutine dispatcher that is not confined to any specific thread.\n     * It executes the initial continuation of a coroutine in the current call-frame\n     * and lets the coroutine resume in whatever thread that is used by the corresponding suspending function, without\n     * mandating any specific threading policy. Nested coroutines launched in this dispatcher form an event-loop to avoid\n     * stack overflows.\n     *\n     * ### Event loop\n     * Event loop semantics is a purely internal concept and has no guarantees on the order of execution\n     * except that all queued coroutines will be executed on the current thread in the lexical scope of the outermost\n     * unconfined coroutine.\n     *\n     * For example, the following code:\n     * ```\n     * withContext(Dispatchers.Unconfined) {\n     *    println(1)\n     *    launch(Dispatchers.Unconfined) { // Nested unconfined\n     *        println(2)\n     *    }\n     *    println(3)\n     * }\n     * println(\"Done\")\n     * ```\n     * Can print both \"1 2 3\" and \"1 3 2\". This is an implementation detail that can be changed.\n     * However, it is guaranteed that \"Done\" will only be printed once the code in both `withContext` and `launch` completes.\n     *\n     * If you need your coroutine to be confined to a particular thread or a thread-pool after resumption,\n     * but still want to execute it in the current call-frame until its first suspension, you can use\n     * an optional [CoroutineStart] parameter in coroutine builders like\n     * [launch][CoroutineScope.launch] and [async][CoroutineScope.async] setting it to\n     * the value of [CoroutineStart.UNDISPATCHED].\n     */\n    public val Unconfined: CoroutineDispatcher\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/EventLoop.common.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.concurrent.Volatile\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * Extended by [CoroutineDispatcher] implementations that have event loop inside and can\n * be asked to process next event from their event queue.\n *\n * It may optionally implement [Delay] interface and support time-scheduled tasks.\n * It is created or pigged back onto (see [ThreadLocalEventLoop])\n * by `runBlocking` and by [Dispatchers.Unconfined].\n *\n * @suppress **This an internal API and should not be used from general code.**\n */\ninternal abstract class EventLoop : CoroutineDispatcher() {\n    /**\n     * Counts the number of nested `runBlocking` and [Dispatchers.Unconfined] that use this event loop.\n     */\n    private var useCount = 0L\n\n    /**\n     * Set to true on any use by `runBlocking`, because it potentially leaks this loop to other threads, so\n     * this instance must be properly shutdown. We don't need to shutdown event loop that was used solely\n     * by [Dispatchers.Unconfined] -- it can be left as [ThreadLocalEventLoop] and reused next time.\n     */\n    private var shared = false\n\n    /**\n     * Queue used by [Dispatchers.Unconfined] tasks.\n     * These tasks are thread-local for performance and take precedence over the rest of the queue.\n     */\n    private var unconfinedQueue: ArrayDeque<DispatchedTask<*>>? = null\n\n    /**\n     * Processes next event in this event loop.\n     *\n     * The result of this function is to be interpreted like this:\n     * - `<= 0` -- there are potentially more events for immediate processing;\n     * - `> 0` -- a number of nanoseconds to wait for next scheduled event;\n     * - [Long.MAX_VALUE] -- no more events.\n     *\n     * **NOTE**: Must be invoked only from the event loop's thread\n     *          (no check for performance reasons, may be added in the future).\n     */\n    open fun processNextEvent(): Long {\n        if (!processUnconfinedEvent()) return Long.MAX_VALUE\n        return 0\n    }\n\n    protected open val isEmpty: Boolean get() = isUnconfinedQueueEmpty\n\n    protected open val nextTime: Long\n        get() {\n            val queue = unconfinedQueue ?: return Long.MAX_VALUE\n            return if (queue.isEmpty()) Long.MAX_VALUE else 0L\n        }\n\n    fun processUnconfinedEvent(): Boolean {\n        val queue = unconfinedQueue ?: return false\n        val task = queue.removeFirstOrNull() ?: return false\n        task.run()\n        return true\n    }\n    /**\n     * Returns `true` if the invoking `runBlocking(context) { ... }` that was passed this event loop in its context\n     * parameter should call [processNextEvent] for this event loop (otherwise, it will process thread-local one).\n     * By default, event loop implementation is thread-local and should not processed in the context\n     * (current thread's event loop should be processed instead).\n     */\n    open fun shouldBeProcessedFromContext(): Boolean = false\n\n    /**\n     * Dispatches task whose dispatcher returned `false` from [CoroutineDispatcher.isDispatchNeeded]\n     * into the current event loop.\n     */\n    fun dispatchUnconfined(task: DispatchedTask<*>) {\n        val queue = unconfinedQueue ?:\n            ArrayDeque<DispatchedTask<*>>().also { unconfinedQueue = it }\n        queue.addLast(task)\n    }\n\n    val isActive: Boolean\n        get() = useCount > 0\n\n    val isUnconfinedLoopActive: Boolean\n        get() = useCount >= delta(unconfined = true)\n\n    // May only be used from the event loop's thread\n    val isUnconfinedQueueEmpty: Boolean\n        get() = unconfinedQueue?.isEmpty() ?: true\n\n    private fun delta(unconfined: Boolean) =\n        if (unconfined) (1L shl 32) else 1L\n\n    fun incrementUseCount(unconfined: Boolean = false) {\n        useCount += delta(unconfined)\n        if (!unconfined) shared = true \n    }\n\n    fun decrementUseCount(unconfined: Boolean = false) {\n        useCount -= delta(unconfined)\n        if (useCount > 0) return\n        assert { useCount == 0L } // \"Extra decrementUseCount\"\n        if (shared) {\n            // shut it down and remove from ThreadLocalEventLoop\n            shutdown()\n        }\n    }\n\n    final override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        parallelism.checkParallelism()\n        return this\n    }\n\n    open fun shutdown() {}\n}\n\ninternal object ThreadLocalEventLoop {\n    private val ref = commonThreadLocal<EventLoop?>(Symbol(\"ThreadLocalEventLoop\"))\n\n    internal val eventLoop: EventLoop\n        get() = ref.get() ?: createEventLoop().also { ref.set(it) }\n\n    internal fun currentOrNull(): EventLoop? =\n        ref.get()\n\n    internal fun resetEventLoop() {\n        ref.set(null)\n    }\n\n    internal fun setEventLoop(eventLoop: EventLoop) {\n        ref.set(eventLoop)\n    }\n}\n\nprivate val DISPOSED_TASK = Symbol(\"REMOVED_TASK\")\n\n// results for scheduleImpl\nprivate const val SCHEDULE_OK = 0\nprivate const val SCHEDULE_COMPLETED = 1\nprivate const val SCHEDULE_DISPOSED = 2\n\nprivate const val MS_TO_NS = 1_000_000L\nprivate const val MAX_MS = Long.MAX_VALUE / MS_TO_NS\n\n/**\n * First-line overflow protection -- limit maximal delay.\n * Delays longer than this one (~146 years) are considered to be delayed \"forever\".\n */\nprivate const val MAX_DELAY_NS = Long.MAX_VALUE / 2\n\ninternal fun delayToNanos(timeMillis: Long): Long = when {\n    timeMillis <= 0 -> 0L\n    timeMillis >= MAX_MS -> Long.MAX_VALUE\n    else -> timeMillis * MS_TO_NS\n}\n\ninternal fun delayNanosToMillis(timeNanos: Long): Long =\n    timeNanos / MS_TO_NS\n\nprivate val CLOSED_EMPTY = Symbol(\"CLOSED_EMPTY\")\n\nprivate typealias Queue<T> = LockFreeTaskQueueCore<T>\n\ninternal expect abstract class EventLoopImplPlatform() : EventLoop {\n    // Called to unpark this event loop's thread\n    protected fun unpark()\n\n    // Called to reschedule to DefaultExecutor when this event loop is complete\n    protected fun reschedule(now: Long, delayedTask: EventLoopImplBase.DelayedTask)\n}\n\ninternal abstract class EventLoopImplBase: EventLoopImplPlatform(), Delay {\n    // null | CLOSED_EMPTY | task | Queue<Runnable>\n    private val _queue = atomic<Any?>(null)\n\n    // Allocated only only once\n    private val _delayed = atomic<DelayedTaskQueue?>(null)\n\n    private val _isCompleted = atomic(false)\n    private var isCompleted\n        get() = _isCompleted.value\n        set(value) { _isCompleted.value = value }\n\n    override val isEmpty: Boolean get() {\n        if (!isUnconfinedQueueEmpty) return false\n        val delayed = _delayed.value\n        if (delayed != null && !delayed.isEmpty) return false\n        return when (val queue = _queue.value) {\n            null -> true\n            is Queue<*> -> queue.isEmpty\n            else -> queue === CLOSED_EMPTY\n        }\n    }\n\n    override val nextTime: Long\n        get() {\n            if (super.nextTime == 0L) return 0L\n            val queue = _queue.value\n            when {\n                queue === null -> {} // empty queue -- proceed\n                queue is Queue<*> -> if (!queue.isEmpty) return 0 // non-empty queue\n                queue === CLOSED_EMPTY -> return Long.MAX_VALUE // no more events -- closed\n                else -> return 0 // non-empty queue\n            }\n            val nextDelayedTask = _delayed.value?.peek() ?: return Long.MAX_VALUE\n            return (nextDelayedTask.nanoTime - nanoTime()).coerceAtLeast(0)\n        }\n\n    override fun shutdown() {\n        // Clean up thread-local reference here -- this event loop is shutting down\n        ThreadLocalEventLoop.resetEventLoop()\n        // We should signal that this event loop should not accept any more tasks\n        // and process queued events (that could have been added after last processNextEvent)\n        isCompleted = true\n        closeQueue()\n        // complete processing of all queued tasks\n        while (processNextEvent() <= 0) { /* spin */ }\n        // reschedule the rest of delayed tasks\n        rescheduleAllDelayed()\n    }\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val timeNanos = delayToNanos(timeMillis)\n        if (timeNanos < MAX_DELAY_NS) {\n            val now = nanoTime()\n            DelayedResumeTask(now + timeNanos, continuation).also { task ->\n                /*\n                 * Order is important here: first we schedule the heap and only then\n                 * publish it to continuation. Otherwise, `DelayedResumeTask` would\n                 * have to know how to be disposed of even when it wasn't scheduled yet.\n                 */\n                schedule(now, task)\n                continuation.disposeOnCancellation(task)\n            }\n        }\n    }\n\n    protected fun scheduleInvokeOnTimeout(timeMillis: Long, block: Runnable): DisposableHandle {\n        val timeNanos = delayToNanos(timeMillis)\n        return if (timeNanos < MAX_DELAY_NS) {\n            val now = nanoTime()\n            DelayedRunnableTask(now + timeNanos, block).also { task ->\n                schedule(now, task)\n            }\n        } else {\n            NonDisposableHandle\n        }\n    }\n\n    override fun processNextEvent(): Long {\n        // unconfined events take priority\n        if (processUnconfinedEvent()) return 0\n        // queue all delayed tasks that are due to be executed\n        val delayed = _delayed.value\n        if (delayed != null && !delayed.isEmpty) {\n            val now = nanoTime()\n            while (true) {\n                // make sure that moving from delayed to queue removes from delayed only after it is added to queue\n                // to make sure that 'isEmpty' and `nextTime` that check both of them\n                // do not transiently report that both delayed and queue are empty during move\n                delayed.removeFirstIf {\n                    if (it.timeToExecute(now)) {\n                        enqueueImpl(it)\n                    } else\n                        false\n                } ?: break // quit loop when nothing more to remove or enqueueImpl returns false on \"isComplete\"\n            }\n        }\n        // then process one event from queue\n        val task = dequeue()\n        if (task != null) {\n            platformAutoreleasePool { task.run() }\n            return 0\n        }\n        return nextTime\n    }\n\n    final override fun dispatch(context: CoroutineContext, block: Runnable) = enqueue(block)\n\n    open fun enqueue(task: Runnable) {\n        if (enqueueImpl(task)) {\n            // todo: we should unpark only when this delayed task became first in the queue\n            unpark()\n        } else {\n            DefaultExecutor.enqueue(task)\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun enqueueImpl(task: Runnable): Boolean {\n        _queue.loop { queue ->\n            if (isCompleted) return false // fail fast if already completed, may still add, but queues will close\n            when (queue) {\n                null -> if (_queue.compareAndSet(null, task)) return true\n                is Queue<*> -> {\n                    when ((queue as Queue<Runnable>).addLast(task)) {\n                        Queue.ADD_SUCCESS -> return true\n                        Queue.ADD_CLOSED -> return false\n                        Queue.ADD_FROZEN -> _queue.compareAndSet(queue, queue.next())\n                    }\n                }\n                else -> when {\n                    queue === CLOSED_EMPTY -> return false\n                    else -> {\n                        // update to full-blown queue to add one more\n                        val newQueue = Queue<Runnable>(Queue.INITIAL_CAPACITY, singleConsumer = true)\n                        newQueue.addLast(queue as Runnable)\n                        newQueue.addLast(task)\n                        if (_queue.compareAndSet(queue, newQueue)) return true\n                    }\n                }\n            }\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun dequeue(): Runnable? {\n        _queue.loop { queue ->\n            when (queue) {\n                null -> return null\n                is Queue<*> -> {\n                    val result = (queue as Queue<Runnable>).removeFirstOrNull()\n                    if (result !== Queue.REMOVE_FROZEN) return result as Runnable?\n                    _queue.compareAndSet(queue, queue.next())\n                }\n                else -> when {\n                    queue === CLOSED_EMPTY -> return null\n                    else -> if (_queue.compareAndSet(queue, null)) return queue as Runnable\n                }\n            }\n        }\n    }\n\n    private fun closeQueue() {\n        assert { isCompleted }\n        _queue.loop { queue ->\n            when (queue) {\n                null -> if (_queue.compareAndSet(null, CLOSED_EMPTY)) return\n                is Queue<*> -> {\n                    queue.close()\n                    return\n                }\n                else -> when {\n                    queue === CLOSED_EMPTY -> return\n                    else -> {\n                        // update to full-blown queue to close\n                        val newQueue = Queue<Runnable>(Queue.INITIAL_CAPACITY, singleConsumer = true)\n                        newQueue.addLast(queue as Runnable)\n                        if (_queue.compareAndSet(queue, newQueue)) return\n                    }\n                }\n            }\n        }\n\n    }\n\n    fun schedule(now: Long, delayedTask: DelayedTask) {\n        when (scheduleImpl(now, delayedTask)) {\n            SCHEDULE_OK -> if (shouldUnpark(delayedTask)) unpark()\n            SCHEDULE_COMPLETED -> reschedule(now, delayedTask)\n            SCHEDULE_DISPOSED -> {} // do nothing -- task was already disposed\n            else -> error(\"unexpected result\")\n        }\n    }\n\n    private fun shouldUnpark(task: DelayedTask): Boolean = _delayed.value?.peek() === task\n\n    private fun scheduleImpl(now: Long, delayedTask: DelayedTask): Int {\n        if (isCompleted) return SCHEDULE_COMPLETED\n        val delayedQueue = _delayed.value ?: run {\n            _delayed.compareAndSet(null, DelayedTaskQueue(now))\n            _delayed.value!!\n        }\n        return delayedTask.scheduleTask(now, delayedQueue, this)\n    }\n\n    // It performs \"hard\" shutdown for test cleanup purposes\n    protected fun resetAll() {\n        _queue.value = null\n        _delayed.value = null\n    }\n\n    // This is a \"soft\" (normal) shutdown\n    private fun rescheduleAllDelayed() {\n        val now = nanoTime()\n        while (true) {\n            /*\n             * `removeFirstOrNull` below is the only operation on DelayedTask & ThreadSafeHeap that is not\n             * synchronized on DelayedTask itself. All other operation are synchronized both on\n             * DelayedTask & ThreadSafeHeap instances (in this order). It is still safe, because `dispose`\n             * first removes DelayedTask from the heap (under synchronization) then\n             * assign \"_heap = DISPOSED_TASK\", so there cannot be ever a race to _heap reference update.\n             */\n            val delayedTask = _delayed.value?.removeFirstOrNull() ?: break\n            reschedule(now, delayedTask)\n        }\n    }\n\n    internal abstract class DelayedTask(\n        /**\n         * This field can be only modified in [scheduleTask] before putting this DelayedTask\n         * into heap to avoid overflow and corruption of heap data structure.\n         */\n        @JvmField var nanoTime: Long\n    ) : Runnable, Comparable<DelayedTask>, DisposableHandle, ThreadSafeHeapNode, SynchronizedObject() {\n        @Volatile\n        private var _heap: Any? = null // null | ThreadSafeHeap | DISPOSED_TASK\n\n        override var heap: ThreadSafeHeap<*>?\n            get() = _heap as? ThreadSafeHeap<*>\n            set(value) {\n                require(_heap !== DISPOSED_TASK) // this can never happen, it is always checked before adding/removing\n                _heap = value\n            }\n\n        override var index: Int = -1\n\n        override fun compareTo(other: DelayedTask): Int {\n            val dTime = nanoTime - other.nanoTime\n            return when {\n                dTime > 0 -> 1\n                dTime < 0 -> -1\n                else -> 0\n            }\n        }\n\n        fun timeToExecute(now: Long): Boolean = now - nanoTime >= 0L\n\n        fun scheduleTask(now: Long, delayed: DelayedTaskQueue, eventLoop: EventLoopImplBase): Int = synchronized<Int>(this) {\n            if (_heap === DISPOSED_TASK) return SCHEDULE_DISPOSED // don't add -- was already disposed\n            delayed.addLastIf(this) { firstTask ->\n                if (eventLoop.isCompleted) return SCHEDULE_COMPLETED // non-local return from scheduleTask\n                /**\n                 * We are about to add new task and we have to make sure that [DelayedTaskQueue]\n                 * invariant is maintained. The code in this lambda is additionally executed under\n                 * the lock of [DelayedTaskQueue] and working with [DelayedTaskQueue.timeNow] here is thread-safe.\n                 */\n                if (firstTask == null) {\n                    /**\n                     * When adding the first delayed task we simply update queue's [DelayedTaskQueue.timeNow] to\n                     * the current now time even if that means \"going backwards in time\". This makes the structure\n                     * self-correcting in spite of wild jumps in `nanoTime()` measurements once all delayed tasks\n                     * are removed from the delayed queue for execution.\n                     */\n                    delayed.timeNow = now\n                } else {\n                    /**\n                     * Carefully update [DelayedTaskQueue.timeNow] so that it does not sweep past first's tasks time\n                     * and only goes forward in time. We cannot let it go backwards in time or invariant can be\n                     * violated for tasks that were already scheduled.\n                     */\n                    val firstTime = firstTask.nanoTime\n                    // compute min(now, firstTime) using a wrap-safe check\n                    val minTime = if (firstTime - now >= 0) now else firstTime\n                    // update timeNow only when going forward in time\n                    if (minTime - delayed.timeNow > 0) delayed.timeNow = minTime\n                }\n                /**\n                 * Here [DelayedTaskQueue.timeNow] was already modified and we have to double-check that newly added\n                 * task does not violate [DelayedTaskQueue] invariant because of that. Note also that this scheduleTask\n                 * function can be called to reschedule from one queue to another and this might be another reason\n                 * where new task's time might now violate invariant.\n                 * We correct invariant violation (if any) by simply changing this task's time to now.\n                 */\n                if (nanoTime - delayed.timeNow < 0) nanoTime = delayed.timeNow\n                true\n            }\n            return SCHEDULE_OK\n        }\n\n        final override fun dispose(): Unit = synchronized(this) {\n            val heap = _heap\n            if (heap === DISPOSED_TASK) return // already disposed\n            (heap as? DelayedTaskQueue)?.remove(this) // remove if it is in heap (first)\n            _heap = DISPOSED_TASK // never add again to any heap\n        }\n\n        override fun toString(): String = \"Delayed[nanos=$nanoTime]\"\n    }\n\n    private inner class DelayedResumeTask(\n        nanoTime: Long,\n        private val cont: CancellableContinuation<Unit>\n    ) : DelayedTask(nanoTime) {\n        override fun run() { with(cont) { resumeUndispatched(Unit) } }\n        override fun toString(): String = super.toString() + cont.toString()\n    }\n\n    private class DelayedRunnableTask(\n        nanoTime: Long,\n        private val block: Runnable\n    ) : DelayedTask(nanoTime) {\n        override fun run() { block.run() }\n        override fun toString(): String = super.toString() + block.toString()\n    }\n\n    /**\n     * Delayed task queue maintains stable time-comparision invariant despite potential wraparounds in\n     * long nano time measurements by maintaining last observed [timeNow]. It protects the integrity of the\n     * heap data structure in spite of potential non-monotonicity of `nanoTime()` source.\n     * The invariant is that for every scheduled [DelayedTask]:\n     *\n     * ```\n     * delayedTask.nanoTime - timeNow >= 0\n     * ```\n     *\n     * So the comparison of scheduled tasks via [DelayedTask.compareTo] is always stable as\n     * scheduled [DelayedTask.nanoTime] can be at most [Long.MAX_VALUE] apart. This invariant is maintained when\n     * new tasks are added by [DelayedTask.scheduleTask] function and it cannot be violated when tasks are removed\n     * (so there is nothing special to do there).\n     */\n    internal class DelayedTaskQueue(\n        @JvmField var timeNow: Long\n    ) : ThreadSafeHeap<DelayedTask>()\n}\n\ninternal expect fun createEventLoop(): EventLoop\n\ninternal expect fun nanoTime(): Long\n\ninternal expect object DefaultExecutor {\n    fun enqueue(task: Runnable)\n}\n\n/**\n * Used by Darwin targets to wrap a [Runnable.run] call in an Objective-C Autorelease Pool. It is a no-op on JVM, JS and\n * non-Darwin native targets.\n *\n * Coroutines on Darwin targets can call into the Objective-C world, where a callee may push a to-be-returned object to\n * the Autorelease Pool, so as to avoid a premature ARC release before it reaches the caller. This means the pool must\n * be eventually drained to avoid leaks. Since Kotlin Coroutines does not use [NSRunLoop], which provides automatic\n * pool management, it must manage the pool creation and pool drainage manually.\n */\ninternal expect inline fun platformAutoreleasePool(crossinline block: () -> Unit)\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Exceptions.common.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * This exception gets thrown if an exception is caught while processing [InternalCompletionHandler] invocation for [Job].\n *\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic class CompletionHandlerException(message: String, cause: Throwable) : RuntimeException(message, cause)\n\npublic expect open class CancellationException(message: String?) : IllegalStateException\n\npublic expect fun CancellationException(message: String?, cause: Throwable?) : CancellationException\n\ninternal expect class JobCancellationException(\n    message: String,\n    cause: Throwable?,\n    job: Job\n) : CancellationException {\n    internal val job: Job\n}\n\ninternal class CoroutinesInternalError(message: String, cause: Throwable) : Error(message, cause)\n\n// For use in tests\ninternal expect val RECOVER_STACK_TRACES: Boolean\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Job.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"JobKt\")\n@file:Suppress(\"DEPRECATION_ERROR\", \"RedundantUnitReturnType\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.selects.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n// --------------- core job interfaces ---------------\n\n/**\n * A background job. Conceptually, a job is a cancellable thing with a life-cycle that\n * culminates in its completion.\n *\n * Jobs can be arranged into parent-child hierarchies where cancellation\n * of a parent leads to immediate cancellation of all its [children] recursively.\n * Failure of a child with an exception other than [CancellationException] immediately cancels its parent and,\n * consequently, all its other children. This behavior can be customized using [SupervisorJob].\n *\n * The most basic instances of `Job` interface are created like this:\n *\n * - **Coroutine job** is created with [launch][CoroutineScope.launch] coroutine builder.\n *   It runs a specified block of code and completes on completion of this block.\n * - **[CompletableJob]** is created with a `Job()` factory function.\n *   It is completed by calling [CompletableJob.complete].\n *\n * Conceptually, an execution of a job does not produce a result value. Jobs are launched solely for their\n * side effects. See [Deferred] interface for a job that produces a result.\n *\n * ### Job states\n *\n * A job has the following states:\n *\n * | **State**                        | [isActive] | [isCompleted] | [isCancelled] |\n * | -------------------------------- | ---------- | ------------- | ------------- |\n * | _New_ (optional initial state)   | `false`    | `false`       | `false`       |\n * | _Active_ (default initial state) | `true`     | `false`       | `false`       |\n * | _Completing_ (transient state)   | `true`     | `false`       | `false`       |\n * | _Cancelling_ (transient state)   | `false`    | `false`       | `true`        |\n * | _Cancelled_ (final state)        | `false`    | `true`        | `true`        |\n * | _Completed_ (final state)        | `false`    | `true`        | `false`       |\n *\n * Usually, a job is created in the _active_ state (it is created and started). However, coroutine builders\n * that provide an optional `start` parameter create a coroutine in the _new_ state when this parameter is set to\n * [CoroutineStart.LAZY]. Such a job can be made _active_ by invoking [start] or [join].\n *\n * A job is _active_ while the coroutine is working or until [CompletableJob] is completed,\n * or until it fails or cancelled.\n *\n * Failure of an _active_ job with an exception makes it _cancelling_.\n * A job can be cancelled at any time with [cancel] function that forces it to transition to\n * the _cancelling_ state immediately. The job becomes _cancelled_  when it finishes executing its work and\n * all its children complete.\n *\n * Completion of an _active_ coroutine's body or a call to [CompletableJob.complete] transitions the job to\n * the _completing_ state. It waits in the _completing_ state for all its children to complete before\n * transitioning to the _completed_ state.\n * Note that _completing_ state is purely internal to the job. For an outside observer a _completing_ job is still\n * active, while internally it is waiting for its children.\n *\n * ```\n *                                       wait children\n * +-----+ start  +--------+ complete   +-------------+  finish  +-----------+\n * | New | -----> | Active | ---------> | Completing  | -------> | Completed |\n * +-----+        +--------+            +-------------+          +-----------+\n *                  |  cancel / fail       |\n *                  |     +----------------+\n *                  |     |\n *                  V     V\n *              +------------+                           finish  +-----------+\n *              | Cancelling | --------------------------------> | Cancelled |\n *              +------------+                                   +-----------+\n * ```\n *\n * A `Job` instance in the\n * [coroutineContext](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/coroutine-context.html)\n * represents the coroutine itself.\n *\n * ### Cancellation cause\n *\n * A coroutine job is said to _complete exceptionally_ when its body throws an exception;\n * a [CompletableJob] is completed exceptionally by calling [CompletableJob.completeExceptionally].\n * An exceptionally completed job is cancelled and the corresponding exception becomes the _cancellation cause_ of the job.\n *\n * Normal cancellation of a job is distinguished from its failure by the type of this exception that caused its cancellation.\n * A coroutine that threw [CancellationException] is considered to be _cancelled normally_.\n * If a cancellation cause is a different exception type, then the job is considered to have _failed_.\n * When a job has _failed_, then its parent gets cancelled with the exception of the same type,\n * thus ensuring transparency in delegating parts of the job to its children.\n *\n * Note, that [cancel] function on a job only accepts [CancellationException] as a cancellation cause, thus\n * calling [cancel] always results in a normal cancellation of a job, which does not lead to cancellation\n * of its parent. This way, a parent can [cancel] its own children (cancelling all their children recursively, too)\n * without cancelling itself.\n *\n * ### Concurrency and synchronization\n *\n * All functions on this interface and on all interfaces derived from it are **thread-safe** and can\n * be safely invoked from concurrent coroutines without external synchronization.\n *\n * ### Not stable for inheritance\n *\n * **`Job` interface and all its derived interfaces are not stable for inheritance in 3rd party libraries**,\n * as new methods might be added to this interface in the future, but is stable for use.\n */\npublic interface Job : CoroutineContext.Element {\n    /**\n     * Key for [Job] instance in the coroutine context.\n     */\n    public companion object Key : CoroutineContext.Key<Job>\n\n    // ------------ state query ------------\n\n    /**\n     * Returns the parent of the current job if the parent-child relationship\n     * is established or `null` if the job has no parent or was successfully completed.\n     *\n     * Accesses to this property are not idempotent, the property becomes `null` as soon\n     * as the job is transitioned to its final state, whether it is cancelled or completed,\n     * and all job children are completed.\n     *\n     * For a coroutine, its corresponding job completes as soon as the coroutine itself\n     * and all its children are complete.\n     *\n     * @see [Job] state transitions for additional details.\n     */\n    @ExperimentalCoroutinesApi\n    public val parent: Job?\n\n    /**\n     * Returns `true` when this job is active -- it was already started and has not completed nor was cancelled yet.\n     * The job that is waiting for its [children] to complete is still considered to be active if it\n     * was not cancelled nor failed.\n     *\n     * See [Job] documentation for more details on job states.\n     */\n    public val isActive: Boolean\n\n    /**\n     * Returns `true` when this job has completed for any reason. A job that was cancelled or failed\n     * and has finished its execution is also considered complete. Job becomes complete only after\n     * all its [children] complete.\n     *\n     * See [Job] documentation for more details on job states.\n     */\n    public val isCompleted: Boolean\n\n    /**\n     * Returns `true` if this job was cancelled for any reason, either by explicit invocation of [cancel] or\n     * because it had failed or its child or parent was cancelled.\n     * In the general case, it does not imply that the\n     * job has already [completed][isCompleted], because it may still be finishing whatever it was doing and\n     * waiting for its [children] to complete.\n     *\n     * See [Job] documentation for more details on cancellation and failures.\n     */\n    public val isCancelled: Boolean\n\n    /**\n     * Returns [CancellationException] that signals the completion of this job. This function is\n     * used by [cancellable][suspendCancellableCoroutine] suspending functions. They throw exception\n     * returned by this function when they suspend in the context of this job and this job becomes _complete_.\n     *\n     * This function returns the original [cancel] cause of this job if that `cause` was an instance of\n     * [CancellationException]. Otherwise (if this job was cancelled with a cause of a different type, or\n     * was cancelled without a cause, or had completed normally), an instance of [CancellationException] is\n     * returned. The [CancellationException.cause] of the resulting [CancellationException] references\n     * the original cancellation cause that was passed to [cancel] function.\n     *\n     * This function throws [IllegalStateException] when invoked on a job that is still active.\n     *\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @InternalCoroutinesApi\n    public fun getCancellationException(): CancellationException\n\n    // ------------ state update ------------\n\n    /**\n     * Starts coroutine related to this job (if any) if it was not started yet.\n     * The result is `true` if this invocation actually started coroutine or `false`\n     * if it was already started or completed.\n     */\n    public fun start(): Boolean\n\n\n    /**\n     * Cancels this job with an optional cancellation [cause].\n     * A cause can be used to specify an error message or to provide other details on\n     * the cancellation reason for debugging purposes.\n     * See [Job] documentation for full explanation of cancellation machinery.\n     */\n    public fun cancel(cause: CancellationException? = null)\n\n    /**\n     * @suppress This method implements old version of JVM ABI. Use [cancel].\n     */\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n    public fun cancel(): Unit = cancel(null)\n\n    /**\n     * @suppress This method has bad semantics when cause is not a [CancellationException]. Use [cancel].\n     */\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n    public fun cancel(cause: Throwable? = null): Boolean\n\n    // ------------ parent-child ------------\n\n    /**\n     * Returns a sequence of this job's children.\n     *\n     * A job becomes a child of this job when it is constructed with this job in its\n     * [CoroutineContext] or using an explicit `parent` parameter.\n     *\n     * A parent-child relation has the following effect:\n     *\n     * - Cancellation of parent with [cancel] or its exceptional completion (failure)\n     *   immediately cancels all its children.\n     * - Parent cannot complete until all its children are complete. Parent waits for all its children to\n     *   complete in _completing_ or _cancelling_ state.\n     * - Uncaught exception in a child, by default, cancels parent. This applies even to\n     *   children created with [async][CoroutineScope.async] and other future-like\n     *   coroutine builders, even though their exceptions are caught and are encapsulated in their result.\n     *   This default behavior can be overridden with [SupervisorJob].\n     */\n    public val children: Sequence<Job>\n\n    /**\n     * Attaches child job so that this job becomes its parent and\n     * returns a handle that should be used to detach it.\n     *\n     * A parent-child relation has the following effect:\n     * - Cancellation of parent with [cancel] or its exceptional completion (failure)\n     *   immediately cancels all its children.\n     * - Parent cannot complete until all its children are complete. Parent waits for all its children to\n     *   complete in _completing_ or _cancelling_ states.\n     *\n     * **A child must store the resulting [ChildHandle] and [dispose][DisposableHandle.dispose] the attachment\n     * to its parent on its own completion.**\n     *\n     * Coroutine builders and job factory functions that accept `parent` [CoroutineContext] parameter\n     * lookup a [Job] instance in the parent context and use this function to attach themselves as a child.\n     * They also store a reference to the resulting [ChildHandle] and dispose a handle when they complete.\n     *\n     * @suppress This is an internal API. This method is too error prone for public API.\n     */\n    // ChildJob and ChildHandle are made internal on purpose to further deter 3rd-party impl of Job\n    @InternalCoroutinesApi\n    public fun attachChild(child: ChildJob): ChildHandle\n\n    // ------------ state waiting ------------\n\n    /**\n     * Suspends the coroutine until this job is complete. This invocation resumes normally (without exception)\n     * when the job is complete for any reason and the [Job] of the invoking coroutine is still [active][isActive].\n     * This function also [starts][Job.start] the corresponding coroutine if the [Job] was still in _new_ state.\n     *\n     * Note that the job becomes complete only when all its children are complete.\n     *\n     * This suspending function is cancellable and **always** checks for a cancellation of the invoking coroutine's Job.\n     * If the [Job] of the invoking coroutine is cancelled or completed when this\n     * suspending function is invoked or while it is suspended, this function\n     * throws [CancellationException].\n     *\n     * In particular, it means that a parent coroutine invoking `join` on a child coroutine throws\n     * [CancellationException] if the child had failed, since a failure of a child coroutine cancels parent by default,\n     * unless the child was launched from within [supervisorScope].\n     *\n     * This function can be used in [select] invocation with [onJoin] clause.\n     * Use [isCompleted] to check for a completion of this job without waiting.\n     *\n     * There is [cancelAndJoin] function that combines an invocation of [cancel] and `join`.\n     */\n    public suspend fun join()\n\n    /**\n     * Clause for [select] expression of [join] suspending function that selects when the job is complete.\n     * This clause never fails, even if the job completes exceptionally.\n     */\n    public val onJoin: SelectClause0\n\n    // ------------ low-level state-notification ------------\n\n    /**\n     * Registers handler that is **synchronously** invoked once on completion of this job.\n     * When the job is already complete, then the handler is immediately invoked\n     * with the job's exception or cancellation cause or `null`. Otherwise, the handler will be invoked once when this\n     * job is complete.\n     *\n     * The meaning of `cause` that is passed to the handler:\n     * - Cause is `null` when the job has completed normally.\n     * - Cause is an instance of [CancellationException] when the job was cancelled _normally_.\n     *   **It should not be treated as an error**. In particular, it should not be reported to error logs.\n     * - Otherwise, the job had _failed_.\n     *\n     * The resulting [DisposableHandle] can be used to [dispose][DisposableHandle.dispose] the\n     * registration of this handler and release its memory if its invocation is no longer needed.\n     * There is no need to dispose the handler after completion of this job. The references to\n     * all the handlers are released when this job completes.\n     *\n     * Installed [handler] should not throw any exceptions. If it does, they will get caught,\n     * wrapped into [CompletionHandlerException], and rethrown, potentially causing crash of unrelated code.\n     *\n     * **Note**: Implementation of `CompletionHandler` must be fast, non-blocking, and thread-safe.\n     * This handler can be invoked concurrently with the surrounding code.\n     * There is no guarantee on the execution context in which the [handler] is invoked.\n     */\n    public fun invokeOnCompletion(handler: CompletionHandler): DisposableHandle\n\n    /**\n     * Kept for preserving compatibility. Shouldn't be used by anyone.\n     * @suppress\n     */\n    @InternalCoroutinesApi\n    public fun invokeOnCompletion(\n        onCancelling: Boolean = false,\n        invokeImmediately: Boolean = true,\n        handler: CompletionHandler): DisposableHandle\n\n    // ------------ unstable internal API ------------\n\n    /**\n     * @suppress **Error**: Operator '+' on two Job objects is meaningless.\n     * Job is a coroutine context element and `+` is a set-sum operator for coroutine contexts.\n     * The job to the right of `+` just replaces the job the left of `+`.\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(message = \"Operator '+' on two Job objects is meaningless. \" +\n        \"Job is a coroutine context element and `+` is a set-sum operator for coroutine contexts. \" +\n        \"The job to the right of `+` just replaces the job the left of `+`.\",\n        level = DeprecationLevel.ERROR)\n    public operator fun plus(other: Job): Job = other\n}\n\n/**\n * Registers a handler that is **synchronously** invoked once on cancellation or completion of this job.\n *\n * If the handler would have been invoked earlier if it was registered at that time, then it is invoked immediately,\n * unless [invokeImmediately] is set to `false`.\n *\n * The handler is scheduled to be invoked once the job is cancelled or is complete.\n * This behavior can be changed by setting the [onCancelling] parameter to `true`.\n * In this case, the handler is invoked as soon as the job becomes _cancelling_ instead.\n *\n * The meaning of `cause` that is passed to the handler is:\n * - It is `null` if the job has completed normally.\n * - It is an instance of [CancellationException] if the job was cancelled _normally_.\n *   **It should not be treated as an error**. In particular, it should not be reported to error logs.\n * - Otherwise, the job had _failed_.\n *\n * The resulting [DisposableHandle] can be used to [dispose][DisposableHandle.dispose] of the registration of this\n * handler and release its memory if its invocation is no longer needed.\n * There is no need to dispose of the handler after completion of this job. The references to\n * all the handlers are released when this job completes.\n */\ninternal fun Job.invokeOnCompletion(\n    onCancelling: Boolean = false,\n    invokeImmediately: Boolean = true,\n    handler: InternalCompletionHandler\n): DisposableHandle = when (this) {\n    is JobSupport -> invokeOnCompletionInternal(onCancelling, invokeImmediately, handler)\n    else -> invokeOnCompletion(onCancelling, invokeImmediately, handler::invoke)\n}\n\n/**\n * Creates a job object in an active state.\n * A failure of any child of this job immediately causes this job to fail, too, and cancels the rest of its children.\n *\n * To handle children failure independently of each other use [SupervisorJob].\n *\n * If [parent] job is specified, then this job becomes a child job of its parent and\n * is cancelled when its parent fails or is cancelled. All this job's children are cancelled in this case, too.\n *\n * Conceptually, the resulting job works in the same way as the job created by the `launch { body }` invocation\n * (see [launch]), but without any code in the body. It is active until cancelled or completed. Invocation of\n * [CompletableJob.complete] or [CompletableJob.completeExceptionally] corresponds to the successful or\n * failed completion of the body of the coroutine.\n *\n * @param parent an optional parent job.\n */\n@Suppress(\"FunctionName\")\npublic fun Job(parent: Job? = null): CompletableJob = JobImpl(parent)\n\n/** @suppress Binary compatibility only */\n@Suppress(\"FunctionName\")\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n@JvmName(\"Job\")\npublic fun Job0(parent: Job? = null): Job = Job(parent)\n\n/**\n * A handle to an allocated object that can be disposed to make it eligible for garbage collection.\n */\npublic fun interface DisposableHandle {\n    /**\n     * Disposes the corresponding object, making it eligible for garbage collection.\n     * Repeated invocation of this function has no effect.\n     */\n    public fun dispose()\n}\n\n// -------------------- Parent-child communication --------------------\n\n/**\n * A reference that parent receives from its child so that it can report its cancellation.\n *\n * @suppress **This is unstable API and it is subject to change.**\n */\n@InternalCoroutinesApi\n@Deprecated(level = DeprecationLevel.ERROR, message = \"This is internal API and may be removed in the future releases\")\npublic interface ChildJob : Job {\n    /**\n     * Parent is cancelling its child by invoking this method.\n     * Child finds the cancellation cause using [ParentJob.getChildJobCancellationCause].\n     * This method does nothing is the child is already being cancelled.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    @InternalCoroutinesApi\n    public fun parentCancelled(parentJob: ParentJob)\n}\n\n/**\n * A reference that child receives from its parent when it is being cancelled by the parent.\n *\n * @suppress **This is unstable API and it is subject to change.**\n */\n@InternalCoroutinesApi\n@Deprecated(level = DeprecationLevel.ERROR, message = \"This is internal API and may be removed in the future releases\")\npublic interface ParentJob : Job {\n    /**\n     * Child job is using this method to learn its cancellation cause when the parent cancels it with [ChildJob.parentCancelled].\n     * This method is invoked only if the child was not already being cancelled.\n     *\n     * Note that [CancellationException] is the method's return type: if child is cancelled by its parent,\n     * then the original exception is **already** handled by either the parent or the original source of failure.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    @InternalCoroutinesApi\n    public fun getChildJobCancellationCause(): CancellationException\n}\n\n/**\n * A handle that child keep onto its parent so that it is able to report its cancellation.\n *\n * @suppress **This is unstable API and it is subject to change.**\n */\n@InternalCoroutinesApi\n@Deprecated(level = DeprecationLevel.ERROR, message = \"This is internal API and may be removed in the future releases\")\npublic interface ChildHandle : DisposableHandle {\n\n    /**\n     * Returns the parent of the current parent-child relationship.\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    @InternalCoroutinesApi\n    public val parent: Job?\n\n    /**\n     * Child is cancelling its parent by invoking this method.\n     * This method is invoked by the child twice. The first time child report its root cause as soon as possible,\n     * so that all its siblings and the parent can start cancelling their work asap. The second time\n     * child invokes this method when it had aggregated and determined its final cancellation cause.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    @InternalCoroutinesApi\n    public fun childCancelled(cause: Throwable): Boolean\n}\n\n// -------------------- Job extensions --------------------\n\n/**\n * Disposes a specified [handle] when this job is complete.\n *\n * This is a shortcut for the following code with slightly more efficient implementation (one fewer object created).\n * ```\n * invokeOnCompletion { handle.dispose() }\n * ```\n */\ninternal fun Job.disposeOnCompletion(handle: DisposableHandle): DisposableHandle =\n    invokeOnCompletion(handler = DisposeOnCompletion(handle))\n\n/**\n * Cancels the job and suspends the invoking coroutine until the cancelled job is complete.\n *\n * This suspending function is cancellable and **always** checks for a cancellation of the invoking coroutine's Job.\n * If the [Job] of the invoking coroutine is cancelled or completed when this\n * suspending function is invoked or while it is suspended, this function\n * throws [CancellationException].\n *\n * In particular, it means that a parent coroutine invoking `cancelAndJoin` on a child coroutine throws\n * [CancellationException] if the child had failed, since a failure of a child coroutine cancels parent by default,\n * unless the child was launched from within [supervisorScope].\n *\n * This is a shortcut for the invocation of [cancel][Job.cancel] followed by [join][Job.join].\n */\npublic suspend fun Job.cancelAndJoin() {\n    cancel()\n    return join()\n}\n\n/**\n * Cancels all [children][Job.children] jobs of this coroutine using [Job.cancel] for all of them\n * with an optional cancellation [cause].\n * Unlike [Job.cancel] on this job as a whole, the state of this job itself is not affected.\n */\npublic fun Job.cancelChildren(cause: CancellationException? = null) {\n    children.forEach { it.cancel(cause) }\n}\n\n/**\n * @suppress This method implements old version of JVM ABI. Use [cancel].\n */\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\npublic fun Job.cancelChildren(): Unit = cancelChildren(null)\n\n/**\n * @suppress This method has bad semantics when cause is not a [CancellationException]. Use [Job.cancelChildren].\n */\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\npublic fun Job.cancelChildren(cause: Throwable? = null) {\n    children.forEach { (it as? JobSupport)?.cancelInternal(cause.orCancellation(this)) }\n}\n\n// -------------------- CoroutineContext extensions --------------------\n\n/**\n * Returns `true` when the [Job] of the coroutine in this context is still active\n * (has not completed and was not cancelled yet) or the context does not have a [Job] in it.\n *\n * Check this property in long-running computation loops to support cancellation\n * when [CoroutineScope.isActive] is not available:\n *\n * ```\n * while (coroutineContext.isActive) {\n *     // do some computation\n * }\n * ```\n *\n * The `coroutineContext.isActive` expression is a shortcut for `get(Job)?.isActive ?: true`.\n * See [Job.isActive].\n */\npublic val CoroutineContext.isActive: Boolean\n    get() = get(Job)?.isActive ?: true\n\n/**\n * Cancels [Job] of this context with an optional cancellation cause.\n * See [Job.cancel] for details.\n */\npublic fun CoroutineContext.cancel(cause: CancellationException? = null) {\n    this[Job]?.cancel(cause)\n}\n\n/**\n * @suppress This method implements old version of JVM ABI. Use [CoroutineContext.cancel].\n */\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\npublic fun CoroutineContext.cancel(): Unit = cancel(null)\n\n/**\n * Ensures that current job is [active][Job.isActive].\n * If the job is no longer active, throws [CancellationException].\n * If the job was cancelled, thrown exception contains the original cancellation cause.\n *\n * This method is a drop-in replacement for the following code, but with more precise exception:\n * ```\n * if (!job.isActive) {\n *     throw CancellationException()\n * }\n * ```\n */\npublic fun Job.ensureActive(): Unit {\n    if (!isActive) throw getCancellationException()\n}\n\n/**\n * Ensures that job in the current context is [active][Job.isActive].\n *\n * If the job is no longer active, throws [CancellationException].\n * If the job was cancelled, thrown exception contains the original cancellation cause.\n * This function does not do anything if there is no [Job] in the context, since such a coroutine cannot be cancelled.\n *\n * This method is a drop-in replacement for the following code, but with more precise exception:\n * ```\n * if (!isActive) {\n *     throw CancellationException()\n * }\n * ```\n */\npublic fun CoroutineContext.ensureActive() {\n    get(Job)?.ensureActive()\n}\n\n/**\n * Cancels current job, including all its children with a specified diagnostic error [message].\n * A [cause] can be specified to provide additional details on a cancellation reason for debugging purposes.\n */\npublic fun Job.cancel(message: String, cause: Throwable? = null): Unit = cancel(CancellationException(message, cause))\n\n/**\n * @suppress This method has bad semantics when cause is not a [CancellationException]. Use [CoroutineContext.cancel].\n */\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\npublic fun CoroutineContext.cancel(cause: Throwable? = null): Boolean {\n    val job = this[Job] as? JobSupport ?: return false\n    job.cancelInternal(cause.orCancellation(job))\n    return true\n}\n\n/**\n * Cancels all children of the [Job] in this context, without touching the state of this job itself\n * with an optional cancellation cause. See [Job.cancel].\n * It does not do anything if there is no job in the context or it has no children.\n */\npublic fun CoroutineContext.cancelChildren(cause: CancellationException? = null) {\n    this[Job]?.children?.forEach { it.cancel(cause) }\n}\n\n/**\n * @suppress This method implements old version of JVM ABI. Use [CoroutineContext.cancelChildren].\n */\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\npublic fun CoroutineContext.cancelChildren(): Unit = cancelChildren(null)\n\n/**\n * Retrieves the current [Job] instance from the given [CoroutineContext] or\n * throws [IllegalStateException] if no job is present in the context.\n *\n * This method is a short-cut for `coroutineContext[Job]!!` and should be used only when it is known in advance that\n * the context does have instance of the job in it.\n */\npublic val CoroutineContext.job: Job get() = get(Job) ?: error(\"Current context doesn't contain Job in it: $this\")\n\n/**\n * @suppress This method has bad semantics when cause is not a [CancellationException]. Use [CoroutineContext.cancelChildren].\n */\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\npublic fun CoroutineContext.cancelChildren(cause: Throwable? = null) {\n    val job = this[Job] ?: return\n    job.children.forEach { (it as? JobSupport)?.cancelInternal(cause.orCancellation(job)) }\n}\n\nprivate fun Throwable?.orCancellation(job: Job): Throwable = this ?: JobCancellationException(\"Job was cancelled\", null, job)\n\n/**\n * No-op implementation of [DisposableHandle].\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic object NonDisposableHandle : DisposableHandle, ChildHandle {\n\n    override val parent: Job? get() = null\n\n    /**\n     * Does not do anything.\n     * @suppress\n     */\n    override fun dispose() {}\n\n    /**\n     * Returns `false`.\n     * @suppress\n     */\n    override fun childCancelled(cause: Throwable): Boolean = false\n\n    /**\n     * Returns \"NonDisposableHandle\" string.\n     * @suppress\n     */\n    override fun toString(): String = \"NonDisposableHandle\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/JobSupport.kt",
        "content": "@file:Suppress(\"DEPRECATION_ERROR\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.js.*\nimport kotlin.jvm.*\n\n/**\n * A concrete implementation of [Job]. It is optionally a child to a parent job.\n *\n * This is an open class designed for extension by more specific classes that might augment the\n * state and mare store addition state information for completed jobs, like their result values.\n *\n * @param active when `true` the job is created in _active_ state, when `false` in _new_ state. See [Job] for details.\n * @suppress **This is unstable API and it is subject to change.**\n */\n@Deprecated(level = DeprecationLevel.ERROR, message = \"This is internal API and may be removed in the future releases\")\npublic open class JobSupport constructor(active: Boolean) : Job, ChildJob, ParentJob {\n    final override val key: CoroutineContext.Key<*> get() = Job\n\n    /*\n       === Internal states ===\n\n       name       state class              public state  description\n       ------     ------------             ------------  -----------\n       EMPTY_N    EmptyNew               : New           no listeners\n       EMPTY_A    EmptyActive            : Active        no listeners\n       SINGLE     JobNode                : Active        a single listener\n       SINGLE+    JobNode                : Active        a single listener + NodeList added as its next\n       LIST_N     InactiveNodeList       : New           a list of listeners (promoted once, does not got back to EmptyNew)\n       LIST_A     NodeList               : Active        a list of listeners (promoted once, does not got back to JobNode/EmptyActive)\n       COMPLETING Finishing              : Completing    has a list of listeners (promoted once from LIST_*)\n       CANCELLING Finishing              : Cancelling    -- \" --\n       FINAL_C    Cancelled              : Cancelled     Cancelled (final state)\n       FINAL_R    <any>                  : Completed     produced some result\n\n       === Transitions ===\n\n           New states      Active states       Inactive states\n\n          +---------+       +---------+                          }\n          | EMPTY_N | ----> | EMPTY_A | ----+                    } Empty states\n          +---------+       +---------+     |                    }\n               |  |           |     ^       |    +----------+\n               |  |           |     |       +--> |  FINAL_* |\n               |  |           V     |       |    +----------+\n               |  |         +---------+     |                    }\n               |  |         | SINGLE  | ----+                    } JobNode states\n               |  |         +---------+     |                    }\n               |  |              |          |                    }\n               |  |              V          |                    }\n               |  |         +---------+     |                    }\n               |  +-------> | SINGLE+ | ----+                    }\n               |            +---------+     |                    }\n               |                 |          |\n               V                 V          |\n          +---------+       +---------+     |                    }\n          | LIST_N  | ----> | LIST_A  | ----+                    } [Inactive]NodeList states\n          +---------+       +---------+     |                    }\n             |   |             |   |        |\n             |   |    +--------+   |        |\n             |   |    |            V        |\n             |   |    |    +------------+   |   +------------+   }\n             |   +-------> | COMPLETING | --+-- | CANCELLING |   } Finishing states\n             |        |    +------------+       +------------+   }\n             |        |         |                    ^\n             |        |         |                    |\n             +--------+---------+--------------------+\n\n\n       This state machine and its transition matrix are optimized for the common case when a job is created in active\n       state (EMPTY_A), at most one completion listener is added to it during its life-time, and it completes\n       successfully without children (in this case it directly goes from EMPTY_A or SINGLE state to FINAL_R\n       state without going to COMPLETING state)\n\n       Note that the actual `_state` variable can also be a reference to atomic operation descriptor `OpDescriptor`\n\n       ---------- TIMELINE of state changes and notification in Job lifecycle ----------\n\n       | The longest possible chain of events in shown, shorter versions cut-through intermediate states,\n       |  while still performing all the notifications in this order.\n\n         + Job object is created\n       ## NEW: state == EMPTY_NEW | is InactiveNodeList\n         + initParentJob / initParentJobInternal (invokes attachChild on its parent, initializes parentHandle)\n         ~ waits for start\n         >> start / join / await invoked\n       ## ACTIVE: state == EMPTY_ACTIVE | is JobNode | is NodeList\n         + onStart (lazy coroutine is started)\n         ~ active coroutine is working (or scheduled to execution)\n         >> childCancelled / cancelImpl invoked\n       ## CANCELLING: state is Finishing, state.rootCause != null\n        ------ cancelling listeners are not admitted anymore, invokeOnCompletion(onCancelling=true) returns NonDisposableHandle\n        ------ new children get immediately cancelled, but are still admitted to the list\n         + onCancelling\n         + notifyCancelling (invoke all cancelling listeners -- cancel all children, suspended functions resume with exception)\n         + cancelParent (rootCause of cancellation is communicated to the parent, parent is cancelled, too)\n         ~ waits for completion of coroutine body\n         >> makeCompleting / makeCompletingOnce invoked\n       ## COMPLETING: state is Finishing, state.isCompleting == true\n        ------ new children are not admitted anymore, attachChild returns NonDisposableHandle\n         ~ waits for children\n         >> last child completes\n         - computes the final exception\n       ## SEALED: state is Finishing, state.isSealed == true\n        ------ cancel/childCancelled returns false (cannot handle exceptions anymore)\n         + cancelParent (final exception is communicated to the parent, parent incorporates it)\n         + handleJobException (\"launch\" StandaloneCoroutine invokes CoroutineExceptionHandler)\n       ## COMPLETE: state !is Incomplete (CompletedExceptionally | Cancelled)\n        ------ completion listeners are not admitted anymore, invokeOnCompletion returns NonDisposableHandle\n         + parentHandle.dispose\n         + notifyCompletion (invoke all completion listeners)\n         + onCompletionInternal / onCompleted / onCancelled\n\n       ---------------------------------------------------------------------------------\n     */\n\n    // Note: use shared objects while we have no listeners\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    private val _state = atomic<Any?>(if (active) EMPTY_ACTIVE else EMPTY_NEW)\n\n    private val _parentHandle = atomic<ChildHandle?>(null)\n    internal var parentHandle: ChildHandle?\n        get() = _parentHandle.value\n        set(value) { _parentHandle.value = value }\n\n    override val parent: Job?\n        get() = parentHandle?.parent\n\n    // ------------ initialization ------------\n\n    /**\n     * Initializes parent job.\n     * It shall be invoked at most once after construction after all other initialization.\n     */\n    protected fun initParentJob(parent: Job?) {\n        assert { parentHandle == null }\n        if (parent == null) {\n            parentHandle = NonDisposableHandle\n            return\n        }\n        parent.start() // make sure the parent is started\n        @Suppress(\"DEPRECATION\")\n        val handle = parent.attachChild(this)\n        parentHandle = handle\n        // now check our state _after_ registering (see tryFinalizeSimpleState order of actions)\n        if (isCompleted) {\n            handle.dispose()\n            parentHandle = NonDisposableHandle // release it just in case, to aid GC\n        }\n    }\n\n    // ------------ state query ------------\n    /**\n     * Returns current state of this job.\n     * If final state of the job is [Incomplete], then it is boxed into [IncompleteStateBox]\n     * and should be [unboxed][unboxState] before returning to user code.\n     */\n    internal val state: Any? get() {\n        _state.loop { state -> // helper loop on state (complete in-progress atomic operations)\n            if (state !is OpDescriptor) return state\n            state.perform(this)\n        }\n    }\n\n    /**\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    private inline fun loopOnState(block: (Any?) -> Unit): Nothing {\n        while (true) {\n            block(state)\n        }\n    }\n\n    public override val isActive: Boolean get() {\n        val state = this.state\n        return state is Incomplete && state.isActive\n    }\n\n    public final override val isCompleted: Boolean get() = state !is Incomplete\n\n    public final override val isCancelled: Boolean get() {\n        val state = this.state\n        return state is CompletedExceptionally || (state is Finishing && state.isCancelling)\n    }\n\n    // ------------ state update ------------\n\n    // Finalizes Finishing -> Completed (terminal state) transition.\n    // ## IMPORTANT INVARIANT: Only one thread can be concurrently invoking this method.\n    // Returns final state that was created and updated to\n    private fun finalizeFinishingState(state: Finishing, proposedUpdate: Any?): Any? {\n        /*\n         * Note: proposed state can be Incomplete, e.g.\n         * async {\n         *     something.invokeOnCompletion {} // <- returns handle which implements Incomplete under the hood\n         * }\n         */\n        assert { this.state === state } // consistency check -- it cannot change\n        assert { !state.isSealed } // consistency check -- cannot be sealed yet\n        assert { state.isCompleting } // consistency check -- must be marked as completing\n        val proposedException = (proposedUpdate as? CompletedExceptionally)?.cause\n        // Create the final exception and seal the state so that no more exceptions can be added\n        val wasCancelling: Boolean\n        val finalException = synchronized(state) {\n            wasCancelling = state.isCancelling\n            val exceptions = state.sealLocked(proposedException)\n            val finalCause = getFinalRootCause(state, exceptions)\n            if (finalCause != null) addSuppressedExceptions(finalCause, exceptions)\n            finalCause\n        }\n        // Create the final state object\n        val finalState = when {\n            // was not cancelled (no exception) -> use proposed update value\n            finalException == null -> proposedUpdate\n            // small optimization when we can used proposeUpdate object as is on cancellation\n            finalException === proposedException -> proposedUpdate\n            // cancelled job final state\n            else -> CompletedExceptionally(finalException)\n        }\n        // Now handle the final exception\n        if (finalException != null) {\n            val handled = cancelParent(finalException) || handleJobException(finalException)\n            if (handled) (finalState as CompletedExceptionally).makeHandled()\n        }\n        // Process state updates for the final state before the state of the Job is actually set to the final state\n        // to avoid races where outside observer may see the job in the final state, yet exception is not handled yet.\n        if (!wasCancelling) onCancelling(finalException)\n        onCompletionInternal(finalState)\n        // Then CAS to completed state -> it must succeed\n        val casSuccess = _state.compareAndSet(state, finalState.boxIncomplete())\n        assert { casSuccess }\n        // And process all post-completion actions\n        completeStateFinalization(state, finalState)\n        return finalState\n    }\n\n    private fun getFinalRootCause(state: Finishing, exceptions: List<Throwable>): Throwable? {\n        // A case of no exceptions\n        if (exceptions.isEmpty()) {\n            // materialize cancellation exception if it was not materialized yet\n            if (state.isCancelling) return defaultCancellationException()\n            return null\n        }\n        /*\n         * 1) If we have non-CE, use it as root cause\n         * 2) If our original cause was TCE, use *non-original* TCE because of the special nature of TCE\n         *    - It is a CE, so it's not reported by children\n         *    - The first instance (cancellation cause) is created by timeout coroutine and has no meaningful stacktrace\n         *    - The potential second instance is thrown by withTimeout lexical block itself, then it has recovered stacktrace\n         * 3) Just return the very first CE\n         */\n        val firstNonCancellation = exceptions.firstOrNull { it !is CancellationException }\n        if (firstNonCancellation != null) return firstNonCancellation\n        val first = exceptions[0]\n        if (first is TimeoutCancellationException) {\n            val detailedTimeoutException = exceptions.firstOrNull { it !== first && it is TimeoutCancellationException }\n            if (detailedTimeoutException != null) return detailedTimeoutException\n        }\n        return first\n    }\n\n    private fun addSuppressedExceptions(rootCause: Throwable, exceptions: List<Throwable>) {\n        if (exceptions.size <= 1) return // nothing more to do here\n        val seenExceptions = identitySet<Throwable>(exceptions.size)\n        /*\n         * Note that root cause may be a recovered exception as well.\n         * To avoid cycles we unwrap the root cause and check for self-suppression against unwrapped cause,\n         * but add suppressed exceptions to the recovered root cause (as it is our final exception)\n         */\n        val unwrappedCause = unwrap(rootCause)\n        for (exception in exceptions) {\n            val unwrapped = unwrap(exception)\n            if (unwrapped !== rootCause && unwrapped !== unwrappedCause &&\n                unwrapped !is CancellationException && seenExceptions.add(unwrapped)) {\n                rootCause.addSuppressed(unwrapped)\n            }\n        }\n    }\n\n    // fast-path method to finalize normally completed coroutines without children\n    // returns true if complete, and afterCompletion(update) shall be called\n    private fun tryFinalizeSimpleState(state: Incomplete, update: Any?): Boolean {\n        assert { state is Empty || state is JobNode } // only simple state without lists where children can concurrently add\n        assert { update !is CompletedExceptionally } // only for normal completion\n        if (!_state.compareAndSet(state, update.boxIncomplete())) return false\n        onCancelling(null) // simple state is not a failure\n        onCompletionInternal(update)\n        completeStateFinalization(state, update)\n        return true\n    }\n\n    // suppressed == true when any exceptions were suppressed while building the final completion cause\n    private fun completeStateFinalization(state: Incomplete, update: Any?) {\n        /*\n         * Now the job in THE FINAL state. We need to properly handle the resulting state.\n         * Order of various invocations here is important.\n         *\n         * 1) Unregister from parent job.\n         */\n        parentHandle?.let {\n            it.dispose() // volatile read parentHandle _after_ state was updated\n            parentHandle = NonDisposableHandle // release it just in case, to aid GC\n        }\n        val cause = (update as? CompletedExceptionally)?.cause\n        /*\n         * 2) Invoke completion handlers: .join(), callbacks etc.\n         *    It's important to invoke them only AFTER exception handling and everything else, see #208\n         */\n        if (state is JobNode) { // SINGLE/SINGLE+ state -- one completion handler (common case)\n            try {\n                state.invoke(cause)\n            } catch (ex: Throwable) {\n                handleOnCompletionException(CompletionHandlerException(\"Exception in completion handler $state for $this\", ex))\n            }\n        } else {\n            state.list?.notifyCompletion(cause)\n        }\n    }\n\n    private fun notifyCancelling(list: NodeList, cause: Throwable) {\n        // first cancel our own children\n        onCancelling(cause)\n        notifyHandlers<JobCancellingNode>(list, cause)\n        // then cancel parent\n        cancelParent(cause) // tentative cancellation -- does not matter if there is no parent\n    }\n\n    /**\n     * The method that is invoked when the job is cancelled to possibly propagate cancellation to the parent.\n     * Returns `true` if the parent is responsible for handling the exception, `false` otherwise.\n     *\n     * Invariant: never returns `false` for instances of [CancellationException], otherwise such exception\n     * may leak to the [CoroutineExceptionHandler].\n     */\n    private fun cancelParent(cause: Throwable): Boolean {\n        // Is scoped coroutine -- don't propagate, will be rethrown\n        if (isScopedCoroutine) return true\n\n        /* CancellationException is considered \"normal\" and parent usually is not cancelled when child produces it.\n         * This allow parent to cancel its children (normally) without being cancelled itself, unless\n         * child crashes and produce some other exception during its completion.\n         */\n        val isCancellation = cause is CancellationException\n        val parent = parentHandle\n        // No parent -- ignore CE, report other exceptions.\n        if (parent === null || parent === NonDisposableHandle) {\n            return isCancellation\n        }\n\n        // Notify parent but don't forget to check cancellation\n        return parent.childCancelled(cause) || isCancellation\n    }\n\n    private fun NodeList.notifyCompletion(cause: Throwable?) =\n        notifyHandlers<JobNode>(this, cause)\n\n    private inline fun <reified T: JobNode> notifyHandlers(list: NodeList, cause: Throwable?) {\n        var exception: Throwable? = null\n        list.forEach<T> { node ->\n            try {\n                node.invoke(cause)\n            } catch (ex: Throwable) {\n                exception?.apply { addSuppressed(ex) } ?: run {\n                    exception =  CompletionHandlerException(\"Exception in completion handler $node for $this\", ex)\n                }\n            }\n        }\n        exception?.let { handleOnCompletionException(it) }\n    }\n\n    public final override fun start(): Boolean {\n        loopOnState { state ->\n            when (startInternal(state)) {\n                FALSE -> return false\n                TRUE -> return true\n            }\n        }\n    }\n\n    // returns: RETRY/FALSE/TRUE:\n    //   FALSE when not new,\n    //   TRUE  when started\n    //   RETRY when need to retry\n    private fun startInternal(state: Any?): Int {\n        when (state) {\n            is Empty -> { // EMPTY_X state -- no completion handlers\n                if (state.isActive) return FALSE // already active\n                if (!_state.compareAndSet(state, EMPTY_ACTIVE)) return RETRY\n                onStart()\n                return TRUE\n            }\n            is InactiveNodeList -> { // LIST state -- inactive with a list of completion handlers\n                if (!_state.compareAndSet(state, state.list)) return RETRY\n                onStart()\n                return TRUE\n            }\n            else -> return FALSE // not a new state\n        }\n    }\n\n    /**\n     * Override to provide the actual [start] action.\n     * This function is invoked exactly once when non-active coroutine is [started][start].\n     */\n    protected open fun onStart() {}\n\n    public final override fun getCancellationException(): CancellationException =\n        when (val state = this.state) {\n            is Finishing -> state.rootCause?.toCancellationException(\"$classSimpleName is cancelling\")\n                ?: error(\"Job is still new or active: $this\")\n            is Incomplete -> error(\"Job is still new or active: $this\")\n            is CompletedExceptionally -> state.cause.toCancellationException()\n            else -> JobCancellationException(\"$classSimpleName has completed normally\", null, this)\n        }\n\n    protected fun Throwable.toCancellationException(message: String? = null): CancellationException =\n        this as? CancellationException ?: defaultCancellationException(message, this)\n\n    /**\n     * Returns the cause that signals the completion of this job -- it returns the original\n     * [cancel] cause, [CancellationException] or **`null` if this job had completed normally**.\n     * This function throws [IllegalStateException] when invoked for an job that has not [completed][isCompleted] nor\n     * is being cancelled yet.\n     */\n    protected val completionCause: Throwable?\n        get() = when (val state = state) {\n            is Finishing -> state.rootCause\n                ?: error(\"Job is still new or active: $this\")\n            is Incomplete -> error(\"Job is still new or active: $this\")\n            is CompletedExceptionally -> state.cause\n            else -> null\n        }\n\n    /**\n     * Returns `true` when [completionCause] exception was handled by parent coroutine.\n     */\n    protected val completionCauseHandled: Boolean\n        get() = state.let { it is CompletedExceptionally && it.handled }\n\n    public final override fun invokeOnCompletion(handler: CompletionHandler): DisposableHandle =\n        invokeOnCompletionInternal(\n            onCancelling = false,\n            invokeImmediately = true,\n            handler = InternalCompletionHandler.UserSupplied(handler)\n        )\n\n    public final override fun invokeOnCompletion(onCancelling: Boolean, invokeImmediately: Boolean, handler: CompletionHandler): DisposableHandle =\n        invokeOnCompletionInternal(\n            onCancelling = onCancelling,\n            invokeImmediately = invokeImmediately,\n            handler = InternalCompletionHandler.UserSupplied(handler)\n        )\n\n    internal fun invokeOnCompletionInternal(\n        onCancelling: Boolean,\n        invokeImmediately: Boolean,\n        handler: InternalCompletionHandler\n    ): DisposableHandle {\n        // Create node upfront -- for common cases it just initializes JobNode.job field,\n        // for user-defined handlers it allocates a JobNode object that we might not need, but this is Ok.\n        val node: JobNode = makeNode(handler, onCancelling)\n        loopOnState { state ->\n            when (state) {\n                is Empty -> { // EMPTY_X state -- no completion handlers\n                    if (state.isActive) {\n                        // try move to SINGLE state\n                        if (_state.compareAndSet(state, node)) return node\n                    } else\n                        promoteEmptyToNodeList(state) // that way we can add listener for non-active coroutine\n                }\n                is Incomplete -> {\n                    val list = state.list\n                    if (list == null) { // SINGLE/SINGLE+\n                        promoteSingleToNodeList(state as JobNode)\n                    } else {\n                        var rootCause: Throwable? = null\n                        var handle: DisposableHandle = NonDisposableHandle\n                        if (onCancelling && state is Finishing) {\n                            synchronized(state) {\n                                // check if we are installing cancellation handler on job that is being cancelled\n                                rootCause = state.rootCause // != null if cancelling job\n                                // We add node to the list in two cases --- either the job is not being cancelled\n                                // or we are adding a child to a coroutine that is not completing yet\n                                if (rootCause == null || handler is ChildHandleNode && !state.isCompleting) {\n                                    // Note: add node the list while holding lock on state (make sure it cannot change)\n                                    if (!addLastAtomic(state, list, node)) return@loopOnState // retry\n                                    // just return node if we don't have to invoke handler (not cancelling yet)\n                                    if (rootCause == null) return node\n                                    // otherwise handler is invoked immediately out of the synchronized section & handle returned\n                                    handle = node\n                                }\n                            }\n                        }\n                        if (rootCause != null) {\n                            // Note: attachChild uses invokeImmediately, so it gets invoked when adding to cancelled job\n                            if (invokeImmediately) handler.invoke(rootCause)\n                            return handle\n                        } else {\n                            if (addLastAtomic(state, list, node)) return node\n                        }\n                    }\n                }\n                else -> { // is complete\n                    // :KLUDGE: We have to invoke a handler in platform-specific way via `invokeIt` extension,\n                    // because we play type tricks on Kotlin/JS and handler is not necessarily a function there\n                    if (invokeImmediately) handler.invoke((state as? CompletedExceptionally)?.cause)\n                    return NonDisposableHandle\n                }\n            }\n        }\n    }\n\n    private fun makeNode(handler: InternalCompletionHandler, onCancelling: Boolean): JobNode {\n        val node = if (onCancelling) {\n            (handler as? JobCancellingNode)\n                ?: InvokeOnCancelling(handler)\n        } else {\n            (handler as? JobNode)\n                ?.also { assert { it !is JobCancellingNode } }\n                ?: InvokeOnCompletion(handler)\n        }\n        node.job = this\n        return node\n    }\n\n    private fun addLastAtomic(expect: Any, list: NodeList, node: JobNode) =\n        list.addLastIf(node) { this.state === expect }\n\n    private fun promoteEmptyToNodeList(state: Empty) {\n        // try to promote it to LIST state with the corresponding state\n        val list = NodeList()\n        val update = if (state.isActive) list else InactiveNodeList(list)\n        _state.compareAndSet(state, update)\n    }\n\n    private fun promoteSingleToNodeList(state: JobNode) {\n        // try to promote it to list (SINGLE+ state)\n        state.addOneIfEmpty(NodeList())\n        // it must be in SINGLE+ state or state has changed (node could have need removed from state)\n        val list = state.nextNode // either our NodeList or somebody else won the race, updated state\n        // just attempt converting it to list if state is still the same, then we'll continue lock-free loop\n        _state.compareAndSet(state, list)\n    }\n\n    public final override suspend fun join() {\n        if (!joinInternal()) { // fast-path no wait\n            coroutineContext.ensureActive()\n            return // do not suspend\n        }\n        return joinSuspend() // slow-path wait\n    }\n\n    private fun joinInternal(): Boolean {\n        loopOnState { state ->\n            if (state !is Incomplete) return false // not active anymore (complete) -- no need to wait\n            if (startInternal(state) >= 0) return true // wait unless need to retry\n        }\n    }\n\n    private suspend fun joinSuspend() = suspendCancellableCoroutine<Unit> { cont ->\n        // We have to invoke join() handler only on cancellation, on completion we will be resumed regularly without handlers\n        cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(cont)))\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    public final override val onJoin: SelectClause0\n        get() = SelectClause0Impl(\n            clauseObject = this@JobSupport,\n            regFunc = JobSupport::registerSelectForOnJoin as RegistrationFunction\n        )\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun registerSelectForOnJoin(select: SelectInstance<*>, ignoredParam: Any?) {\n        if (!joinInternal()) {\n            select.selectInRegistrationPhase(Unit)\n            return\n        }\n        val disposableHandle = invokeOnCompletion(handler = SelectOnJoinCompletionHandler(select))\n        select.disposeOnCompletion(disposableHandle)\n    }\n\n    private inner class SelectOnJoinCompletionHandler(\n        private val select: SelectInstance<*>\n    ) : JobNode() {\n        override fun invoke(cause: Throwable?) {\n            select.trySelect(this@JobSupport, Unit)\n        }\n    }\n\n    /**\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    internal fun removeNode(node: JobNode) {\n        // remove logic depends on the state of the job\n        loopOnState { state ->\n            when (state) {\n                is JobNode -> { // SINGE/SINGLE+ state -- one completion handler\n                    if (state !== node) return // a different job node --> we were already removed\n                    // try remove and revert back to empty state\n                    if (_state.compareAndSet(state, EMPTY_ACTIVE)) return\n                }\n                is Incomplete -> { // may have a list of completion handlers\n                    // remove node from the list if there is a list\n                    if (state.list != null) node.remove()\n                    return\n                }\n                else -> return // it is complete and does not have any completion handlers\n            }\n        }\n    }\n\n    /**\n     * Returns `true` for job that do not have \"body block\" to complete and should immediately go into\n     * completing state and start waiting for children.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    internal open val onCancelComplete: Boolean get() = false\n\n    // external cancel with cause, never invoked implicitly from internal machinery\n    public override fun cancel(cause: CancellationException?) {\n        cancelInternal(cause ?: defaultCancellationException())\n    }\n\n    protected open fun cancellationExceptionMessage(): String = \"Job was cancelled\"\n\n    // HIDDEN in Job interface. Invoked only by legacy compiled code.\n    // external cancel with (optional) cause, never invoked implicitly from internal machinery\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Added since 1.2.0 for binary compatibility with versions <= 1.1.x\")\n    public override fun cancel(cause: Throwable?): Boolean {\n        cancelInternal(cause?.toCancellationException() ?: defaultCancellationException())\n        return true\n    }\n\n    // It is overridden in channel-linked implementation\n    public open fun cancelInternal(cause: Throwable) {\n        cancelImpl(cause)\n    }\n\n    // Parent is cancelling child\n    public final override fun parentCancelled(parentJob: ParentJob) {\n        cancelImpl(parentJob)\n    }\n\n    /**\n     * Child was cancelled with a cause.\n     * In this method parent decides whether it cancels itself (e.g. on a critical failure) and whether it handles the exception of the child.\n     * It is overridden in supervisor implementations to completely ignore any child cancellation.\n     * Returns `true` if exception is handled, `false` otherwise (then caller is responsible for handling an exception)\n     *\n     * Invariant: never returns `false` for instances of [CancellationException], otherwise such exception\n     * may leak to the [CoroutineExceptionHandler].\n     */\n    public open fun childCancelled(cause: Throwable): Boolean {\n        if (cause is CancellationException) return true\n        return cancelImpl(cause) && handlesException\n    }\n\n    /**\n     * Makes this [Job] cancelled with a specified [cause].\n     * It is used in [AbstractCoroutine]-derived classes when there is an internal failure.\n     */\n    public fun cancelCoroutine(cause: Throwable?): Boolean = cancelImpl(cause)\n\n    // cause is Throwable or ParentJob when cancelChild was invoked\n    // returns true is exception was handled, false otherwise\n    internal fun cancelImpl(cause: Any?): Boolean {\n        var finalState: Any? = COMPLETING_ALREADY\n        if (onCancelComplete) {\n            // make sure it is completing, if cancelMakeCompleting returns state it means it had make it\n            // completing and had recorded exception\n            finalState = cancelMakeCompleting(cause)\n            if (finalState === COMPLETING_WAITING_CHILDREN) return true\n        }\n        if (finalState === COMPLETING_ALREADY) {\n            finalState = makeCancelling(cause)\n        }\n        return when {\n            finalState === COMPLETING_ALREADY -> true\n            finalState === COMPLETING_WAITING_CHILDREN -> true\n            finalState === TOO_LATE_TO_CANCEL -> false\n            else -> {\n                afterCompletion(finalState)\n                true\n            }\n        }\n    }\n\n    // cause is Throwable or ParentJob when cancelChild was invoked\n    // It contains a loop and never returns COMPLETING_RETRY, can return\n    // COMPLETING_ALREADY -- if already completed/completing\n    // COMPLETING_WAITING_CHILDREN -- if started waiting for children\n    // final state -- when completed, for call to afterCompletion\n    private fun cancelMakeCompleting(cause: Any?): Any? {\n        loopOnState { state ->\n            if (state !is Incomplete || state is Finishing && state.isCompleting) {\n                // already completed/completing, do not even create exception to propose update\n                return COMPLETING_ALREADY\n            }\n            val proposedUpdate = CompletedExceptionally(createCauseException(cause))\n            val finalState = tryMakeCompleting(state, proposedUpdate)\n            if (finalState !== COMPLETING_RETRY) return finalState\n        }\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\") // Save a stack frame\n    internal inline fun defaultCancellationException(message: String? = null, cause: Throwable? = null) =\n        JobCancellationException(message ?: cancellationExceptionMessage(), cause, this)\n\n    override fun getChildJobCancellationCause(): CancellationException {\n        // determine root cancellation cause of this job (why is it cancelling its children?)\n        val state = this.state\n        val rootCause = when (state) {\n            is Finishing -> state.rootCause\n            is CompletedExceptionally -> state.cause\n            is Incomplete -> error(\"Cannot be cancelling child in this state: $state\")\n            else -> null // create exception with the below code on normal completion\n        }\n        return (rootCause as? CancellationException) ?: JobCancellationException(\"Parent job is ${stateString(state)}\", rootCause, this)\n    }\n\n    // cause is Throwable or ParentJob when cancelChild was invoked\n    private fun createCauseException(cause: Any?): Throwable = when (cause) {\n        is Throwable? -> cause ?: defaultCancellationException()\n        else -> (cause as ParentJob).getChildJobCancellationCause()\n    }\n\n    // transitions to Cancelling state\n    // cause is Throwable or ParentJob when cancelChild was invoked\n    // It contains a loop and never returns COMPLETING_RETRY, can return\n    // COMPLETING_ALREADY -- if already completing or successfully made cancelling, added exception\n    // COMPLETING_WAITING_CHILDREN -- if started waiting for children, added exception\n    // TOO_LATE_TO_CANCEL -- too late to cancel, did not add exception\n    // final state -- when completed, for call to afterCompletion\n    private fun makeCancelling(cause: Any?): Any? {\n        var causeExceptionCache: Throwable? = null // lazily init result of createCauseException(cause)\n        loopOnState { state ->\n            when (state) {\n                is Finishing -> { // already finishing -- collect exceptions\n                    val notifyRootCause = synchronized(state) {\n                        if (state.isSealed) return TOO_LATE_TO_CANCEL // already sealed -- cannot add exception nor mark cancelled\n                        // add exception, do nothing is parent is cancelling child that is already being cancelled\n                        val wasCancelling = state.isCancelling // will notify if was not cancelling\n                        // Materialize missing exception if it is the first exception (otherwise -- don't)\n                        if (cause != null || !wasCancelling) {\n                            val causeException = causeExceptionCache ?: createCauseException(cause).also { causeExceptionCache = it }\n                            state.addExceptionLocked(causeException)\n                        }\n                        // take cause for notification if was not in cancelling state before\n                        state.rootCause.takeIf { !wasCancelling }\n                    }\n                    notifyRootCause?.let { notifyCancelling(state.list, it) }\n                    return COMPLETING_ALREADY\n                }\n                is Incomplete -> {\n                    // Not yet finishing -- try to make it cancelling\n                    val causeException = causeExceptionCache ?: createCauseException(cause).also { causeExceptionCache = it }\n                    if (state.isActive) {\n                        // active state becomes cancelling\n                        if (tryMakeCancelling(state, causeException)) return COMPLETING_ALREADY\n                    } else {\n                        // non active state starts completing\n                        val finalState = tryMakeCompleting(state, CompletedExceptionally(causeException))\n                        when {\n                            finalState === COMPLETING_ALREADY -> error(\"Cannot happen in $state\")\n                            finalState === COMPLETING_RETRY -> return@loopOnState\n                            else -> return finalState\n                        }\n                    }\n                }\n                else -> return TOO_LATE_TO_CANCEL // already complete\n            }\n        }\n    }\n\n    // Performs promotion of incomplete coroutine state to NodeList for the purpose of\n    // converting coroutine state to Cancelling, returns null when need to retry\n    private fun getOrPromoteCancellingList(state: Incomplete): NodeList? = state.list ?:\n        when (state) {\n            is Empty -> NodeList() // we can allocate new empty list that'll get integrated into Cancelling state\n            is JobNode -> {\n                // SINGLE/SINGLE+ must be promoted to NodeList first, because otherwise we cannot\n                // correctly capture a reference to it\n                promoteSingleToNodeList(state)\n                null // retry\n            }\n            else -> error(\"State should have list: $state\")\n        }\n\n    // try make new Cancelling state on the condition that we're still in the expected state\n    private fun tryMakeCancelling(state: Incomplete, rootCause: Throwable): Boolean {\n        assert { state !is Finishing } // only for non-finishing states\n        assert { state.isActive } // only for active states\n        // get state's list or else promote to list to correctly operate on child lists\n        val list = getOrPromoteCancellingList(state) ?: return false\n        // Create cancelling state (with rootCause!)\n        val cancelling = Finishing(list, false, rootCause)\n        if (!_state.compareAndSet(state, cancelling)) return false\n        // Notify listeners\n        notifyCancelling(list, rootCause)\n        return true\n    }\n\n    /**\n     * Completes this job. Used by [CompletableDeferred.complete] (and exceptionally)\n     * and by [JobImpl.cancel]. It returns `false` on repeated invocation\n     * (when this job is already completing).\n     */\n    internal fun makeCompleting(proposedUpdate: Any?): Boolean {\n        loopOnState { state ->\n            val finalState = tryMakeCompleting(state, proposedUpdate)\n            when {\n                finalState === COMPLETING_ALREADY -> return false\n                finalState === COMPLETING_WAITING_CHILDREN -> return true\n                finalState === COMPLETING_RETRY -> return@loopOnState\n                else -> {\n                    afterCompletion(finalState)\n                    return true\n                }\n            }\n        }\n    } \n\n    /**\n     * Completes this job. Used by [AbstractCoroutine.resume].\n     * It throws [IllegalStateException] on repeated invocation (when this job is already completing).\n     * Returns:\n     * - [COMPLETING_WAITING_CHILDREN] if started waiting for children.\n     * - Final state otherwise (caller should do [afterCompletion])\n     */\n    internal fun makeCompletingOnce(proposedUpdate: Any?): Any? {\n        loopOnState { state ->\n            val finalState = tryMakeCompleting(state, proposedUpdate)\n            when {\n                finalState === COMPLETING_ALREADY ->\n                    throw IllegalStateException(\n                        \"Job $this is already complete or completing, \" +\n                            \"but is being completed with $proposedUpdate\", proposedUpdate.exceptionOrNull\n                    )\n                finalState === COMPLETING_RETRY -> return@loopOnState\n                else -> return finalState // COMPLETING_WAITING_CHILDREN or final state\n            }\n        }\n    }\n\n    // Returns one of COMPLETING symbols or final state:\n    // COMPLETING_ALREADY -- when already complete or completing\n    // COMPLETING_RETRY -- when need to retry due to interference\n    // COMPLETING_WAITING_CHILDREN -- when made completing and is waiting for children\n    // final state -- when completed, for call to afterCompletion\n    private fun tryMakeCompleting(state: Any?, proposedUpdate: Any?): Any? {\n        if (state !is Incomplete)\n            return COMPLETING_ALREADY\n        /*\n         * FAST PATH -- no children to wait for && simple state (no list) && not cancelling => can complete immediately\n         * Cancellation (failures) always have to go through Finishing state to serialize exception handling.\n         * Otherwise, there can be a race between (completed state -> handled exception and newly attached child/join)\n         * which may miss unhandled exception.\n         */\n        if ((state is Empty || state is JobNode) && state !is ChildHandleNode && proposedUpdate !is CompletedExceptionally) {\n            if (tryFinalizeSimpleState(state, proposedUpdate)) {\n                // Completed successfully on fast path -- return updated state\n                return proposedUpdate\n            }\n            return COMPLETING_RETRY\n        }\n        // The separate slow-path function to simplify profiling\n        return tryMakeCompletingSlowPath(state, proposedUpdate)\n    }\n\n    // Returns one of COMPLETING symbols or final state:\n    // COMPLETING_ALREADY -- when already complete or completing\n    // COMPLETING_RETRY -- when need to retry due to interference\n    // COMPLETING_WAITING_CHILDREN -- when made completing and is waiting for children\n    // final state -- when completed, for call to afterCompletion\n    private fun tryMakeCompletingSlowPath(state: Incomplete, proposedUpdate: Any?): Any? {\n        // get state's list or else promote to list to correctly operate on child lists\n        val list = getOrPromoteCancellingList(state) ?: return COMPLETING_RETRY\n        // promote to Finishing state if we are not in it yet\n        // This promotion has to be atomic w.r.t to state change, so that a coroutine that is not active yet\n        // atomically transition to finishing & completing state\n        val finishing = state as? Finishing ?: Finishing(list, false, null)\n        // must synchronize updates to finishing state\n        var notifyRootCause: Throwable? = null\n        synchronized(finishing) {\n            // check if this state is already completing\n            if (finishing.isCompleting) return COMPLETING_ALREADY\n            // mark as completing\n            finishing.isCompleting = true\n            // if we need to promote to finishing then atomically do it here.\n            // We do it as early is possible while still holding the lock. This ensures that we cancelImpl asap\n            // (if somebody else is faster) and we synchronize all the threads on this finishing lock asap.\n            if (finishing !== state) {\n                if (!_state.compareAndSet(state, finishing)) return COMPLETING_RETRY\n            }\n            // ## IMPORTANT INVARIANT: Only one thread (that had set isCompleting) can go past this point\n            assert { !finishing.isSealed } // cannot be sealed\n            // add new proposed exception to the finishing state\n            val wasCancelling = finishing.isCancelling\n            (proposedUpdate as? CompletedExceptionally)?.let { finishing.addExceptionLocked(it.cause) }\n            // If it just becomes cancelling --> must process cancelling notifications\n            notifyRootCause = finishing.rootCause.takeIf { !wasCancelling }\n        }\n        // process cancelling notification here -- it cancels all the children _before_ we start to to wait them (sic!!!)\n        notifyRootCause?.let { notifyCancelling(list, it) }\n        // now wait for children\n        val child = firstChild(state)\n        if (child != null && tryWaitForChild(finishing, child, proposedUpdate))\n            return COMPLETING_WAITING_CHILDREN\n        // otherwise -- we have not children left (all were already cancelled?)\n        return finalizeFinishingState(finishing, proposedUpdate)\n    }\n\n    private val Any?.exceptionOrNull: Throwable?\n        get() = (this as? CompletedExceptionally)?.cause\n\n    private fun firstChild(state: Incomplete) =\n        state as? ChildHandleNode ?: state.list?.nextChild()\n\n    // return false when there is no more incomplete children to wait\n    // ## IMPORTANT INVARIANT: Only one thread can be concurrently invoking this method.\n    private tailrec fun tryWaitForChild(state: Finishing, child: ChildHandleNode, proposedUpdate: Any?): Boolean {\n        val handle = child.childJob.invokeOnCompletion(\n            invokeImmediately = false,\n            handler = ChildCompletion(this, state, child, proposedUpdate)\n        )\n        if (handle !== NonDisposableHandle) return true // child is not complete and we've started waiting for it\n        val nextChild = child.nextChild() ?: return false\n        return tryWaitForChild(state, nextChild, proposedUpdate)\n    }\n\n    // ## IMPORTANT INVARIANT: Only one thread can be concurrently invoking this method.\n    private fun continueCompleting(state: Finishing, lastChild: ChildHandleNode, proposedUpdate: Any?) {\n        assert { this.state === state } // consistency check -- it cannot change while we are waiting for children\n        // figure out if we need to wait for next child\n        val waitChild = lastChild.nextChild()\n        // try wait for next child\n        if (waitChild != null && tryWaitForChild(state, waitChild, proposedUpdate)) return // waiting for next child\n        // no more children to wait -- try update state\n        val finalState = finalizeFinishingState(state, proposedUpdate)\n        afterCompletion(finalState)\n    }\n\n    private fun LockFreeLinkedListNode.nextChild(): ChildHandleNode? {\n        var cur = this\n        while (cur.isRemoved) cur = cur.prevNode // rollback to prev non-removed (or list head)\n        while (true) {\n            cur = cur.nextNode\n            if (cur.isRemoved) continue\n            if (cur is ChildHandleNode) return cur\n            if (cur is NodeList) return null // checked all -- no more children\n        }\n    }\n\n    public final override val children: Sequence<Job> get() = sequence {\n        when (val state = this@JobSupport.state) {\n            is ChildHandleNode -> yield(state.childJob)\n            is Incomplete -> state.list?.let { list ->\n                list.forEach<ChildHandleNode> { yield(it.childJob) }\n            }\n        }\n    }\n\n    @Suppress(\"OverridingDeprecatedMember\")\n    public final override fun attachChild(child: ChildJob): ChildHandle {\n        /*\n         * Note: This function attaches a special ChildHandleNode node object. This node object\n         * is handled in a special way on completion on the coroutine (we wait for all of them) and\n         * is handled specially by invokeOnCompletion itself -- it adds this node to the list even\n         * if the job is already cancelling. For cancelling state child is attached under state lock.\n         * It's required to properly wait all children before completion and provide linearizable hierarchy view:\n         * If child is attached when the job is already being cancelled, such child will receive immediate notification on\n         * cancellation, but parent *will* wait for that child before completion and will handle its exception.\n         */\n        return invokeOnCompletion(onCancelling = true, handler = ChildHandleNode(child)) as ChildHandle\n    }\n\n    /**\n     * Override to process any exceptions that were encountered while invoking completion handlers\n     * installed via [invokeOnCompletion].\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    internal open fun handleOnCompletionException(exception: Throwable) {\n        throw exception\n    }\n\n    /**\n     * This function is invoked once as soon as this job is being cancelled for any reason or completes,\n     * similarly to [invokeOnCompletion] with `onCancelling` set to `true`.\n     *\n     * The meaning of [cause] parameter:\n     * - Cause is `null` when the job has completed normally.\n     * - Cause is an instance of [CancellationException] when the job was cancelled _normally_.\n     *   **It should not be treated as an error**. In particular, it should not be reported to error logs.\n     * - Otherwise, the job had been cancelled or failed with exception.\n     *\n     * The specified [cause] is not the final cancellation cause of this job.\n     * A job may produce other exceptions while it is failing and the final cause might be different.\n     *\n     * @suppress **This is unstable API and it is subject to change.*\n     */\n    protected open fun onCancelling(cause: Throwable?) {}\n\n    /**\n     * Returns `true` for scoped coroutines.\n     * Scoped coroutine is a coroutine that is executed sequentially within the enclosing scope without any concurrency.\n     * Scoped coroutines always handle any exception happened within -- they just rethrow it to the enclosing scope.\n     * Examples of scoped coroutines are `coroutineScope`, `withTimeout` and `runBlocking`.\n     */\n    protected open val isScopedCoroutine: Boolean get() = false\n\n    /**\n     * Returns `true` for jobs that handle their exceptions or integrate them into the job's result via [onCompletionInternal].\n     * A valid implementation of this getter should recursively check parent as well before returning `false`.\n     *\n     * The only instance of the [Job] that does not handle its exceptions is [JobImpl] and its subclass [SupervisorJobImpl].\n     * @suppress **This is unstable API and it is subject to change.*\n     */\n    internal open val handlesException: Boolean get() = true\n\n    /**\n     * Handles the final job [exception] that was not handled by the parent coroutine.\n     * Returns `true` if it handles exception (so handling at later stages is not needed).\n     * It is designed to be overridden by launch-like coroutines\n     * (`StandaloneCoroutine` and `ActorCoroutine`) that don't have a result type\n     * that can represent exceptions.\n     *\n     * This method is invoked **exactly once** when the final exception of the job is determined\n     * and before it becomes complete. At the moment of invocation the job and all its children are complete.\n     */\n    protected open fun handleJobException(exception: Throwable): Boolean = false\n\n    /**\n     * Override for completion actions that need to update some external object depending on job's state,\n     * right before all the waiters for coroutine's completion are notified.\n     *\n     * @param state the final state.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    protected open fun onCompletionInternal(state: Any?) {}\n\n    /**\n     * Override for the very last action on job's completion to resume the rest of the code in\n     * scoped coroutines. It is called when this job is externally completed in an unknown\n     * context and thus should resume with a default mode.\n     *\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    protected open fun afterCompletion(state: Any?) {}\n\n    // for nicer debugging\n    public override fun toString(): String =\n        \"${toDebugString()}@$hexAddress\"\n\n    @InternalCoroutinesApi\n    public fun toDebugString(): String = \"${nameString()}{${stateString(state)}}\"\n\n    /**\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    internal open fun nameString(): String = classSimpleName\n\n    private fun stateString(state: Any?): String = when (state) {\n        is Finishing -> when {\n            state.isCancelling -> \"Cancelling\"\n            state.isCompleting -> \"Completing\"\n            else -> \"Active\"\n        }\n        is Incomplete -> if (state.isActive) \"Active\" else \"New\"\n        is CompletedExceptionally -> \"Cancelled\"\n        else -> \"Completed\"\n    }\n\n    // Completing & Cancelling states,\n    // All updates are guarded by synchronized(this), reads are volatile\n    @Suppress(\"UNCHECKED_CAST\")\n    private class Finishing(\n        override val list: NodeList,\n        isCompleting: Boolean,\n        rootCause: Throwable?\n    ) : SynchronizedObject(), Incomplete {\n        private val _isCompleting = atomic(isCompleting)\n        var isCompleting: Boolean\n            get() = _isCompleting.value\n            set(value) { _isCompleting.value = value }\n\n        private val _rootCause = atomic(rootCause)\n        var rootCause: Throwable? // NOTE: rootCause is kept even when SEALED\n            get() = _rootCause.value\n            set(value) { _rootCause.value = value }\n\n        private val _exceptionsHolder = atomic<Any?>(null)\n        private var exceptionsHolder: Any? // Contains null | Throwable | ArrayList | SEALED\n            get() = _exceptionsHolder.value\n            set(value) { _exceptionsHolder.value = value }\n\n        // Note: cannot be modified when sealed\n        val isSealed: Boolean get() = exceptionsHolder === SEALED\n        val isCancelling: Boolean get() = rootCause != null\n        override val isActive: Boolean get() = rootCause == null // !isCancelling\n\n        // Seals current state and returns list of exceptions\n        // guarded by `synchronized(this)`\n        fun sealLocked(proposedException: Throwable?): List<Throwable> {\n            val list = when(val eh = exceptionsHolder) { // volatile read\n                null -> allocateList()\n                is Throwable -> allocateList().also { it.add(eh) }\n                is ArrayList<*> -> eh as ArrayList<Throwable>\n                else -> error(\"State is $eh\") // already sealed -- cannot happen\n            }\n            val rootCause = this.rootCause // volatile read\n            rootCause?.let { list.add(0, it) } // note -- rootCause goes to the beginning\n            if (proposedException != null && proposedException != rootCause) list.add(proposedException)\n            exceptionsHolder = SEALED\n            return list\n        }\n\n        // guarded by `synchronized(this)`\n        fun addExceptionLocked(exception: Throwable) {\n            val rootCause = this.rootCause // volatile read\n            if (rootCause == null) {\n                this.rootCause = exception\n                return\n            }\n            if (exception === rootCause) return // nothing to do\n            when (val eh = exceptionsHolder) { // volatile read\n                null -> exceptionsHolder = exception\n                is Throwable -> {\n                    if (exception === eh) return // nothing to do\n                    exceptionsHolder = allocateList().apply {\n                        add(eh)\n                        add(exception)\n\n                    }\n                }\n                is ArrayList<*> -> (eh as ArrayList<Throwable>).add(exception)\n                else -> error(\"State is $eh\") // already sealed -- cannot happen\n            }\n        }\n\n        private fun allocateList() = ArrayList<Throwable>(4)\n\n        override fun toString(): String =\n            \"Finishing[cancelling=$isCancelling, completing=$isCompleting, rootCause=$rootCause, exceptions=$exceptionsHolder, list=$list]\"\n    }\n\n    private val Incomplete.isCancelling: Boolean\n        get() = this is Finishing && isCancelling\n\n    // Used by parent that is waiting for child completion\n    private class ChildCompletion(\n        private val parent: JobSupport,\n        private val state: Finishing,\n        private val child: ChildHandleNode,\n        private val proposedUpdate: Any?\n    ) : JobNode() {\n        override fun invoke(cause: Throwable?) {\n            parent.continueCompleting(state, child, proposedUpdate)\n        }\n    }\n\n    private class AwaitContinuation<T>(\n        delegate: Continuation<T>,\n        private val job: JobSupport\n    ) : CancellableContinuationImpl<T>(delegate, MODE_CANCELLABLE) {\n        override fun getContinuationCancellationCause(parent: Job): Throwable {\n            val state = job.state\n            /*\n             * When the job we are waiting for had already completely completed exceptionally or\n             * is failing, we shall use its root/completion cause for await's result.\n             */\n            if (state is Finishing) state.rootCause?.let { return it }\n            if (state is CompletedExceptionally) return state.cause\n            return parent.getCancellationException()\n        }\n\n        protected override fun nameString(): String =\n            \"AwaitContinuation\"\n    }\n\n    /*\n     * =================================================================================================\n     * This is ready-to-use implementation for Deferred interface.\n     * However, it is not type-safe. Conceptually it just exposes the value of the underlying\n     * completed state as `Any?`\n     * =================================================================================================\n     */\n\n    public val isCompletedExceptionally: Boolean get() = state is CompletedExceptionally\n\n    public fun getCompletionExceptionOrNull(): Throwable? {\n        val state = this.state\n        check(state !is Incomplete) { \"This job has not completed yet\" }\n        return state.exceptionOrNull\n    }\n\n    /**\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    internal fun getCompletedInternal(): Any? {\n        val state = this.state\n        check(state !is Incomplete) { \"This job has not completed yet\" }\n        if (state is CompletedExceptionally) throw state.cause\n        return state.unboxState()\n    }\n\n    /**\n     * @suppress **This is unstable API and it is subject to change.**\n     */\n    protected suspend fun awaitInternal(): Any? {\n        // fast-path -- check state (avoid extra object creation)\n        while (true) { // lock-free loop on state\n            val state = this.state\n            if (state !is Incomplete) {\n                // already complete -- just return result\n                if (state is CompletedExceptionally) { // Slow path to recover stacktrace\n                    recoverAndThrow(state.cause)\n                }\n                return state.unboxState()\n\n            }\n            if (startInternal(state) >= 0) break // break unless needs to retry\n        }\n        return awaitSuspend() // slow-path\n    }\n\n    private suspend fun awaitSuspend(): Any? = suspendCoroutineUninterceptedOrReturn { uCont ->\n        /*\n         * Custom code here, so that parent coroutine that is using await\n         * on its child deferred (async) coroutine would throw the exception that this child had\n         * thrown and not a JobCancellationException.\n         */\n        val cont = AwaitContinuation(uCont.intercepted(), this)\n        // we are mimicking suspendCancellableCoroutine here and call initCancellability, too.\n        cont.initCancellability()\n        cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeAwaitOnCompletion(cont)))\n        cont.getResult()\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    protected val onAwaitInternal: SelectClause1<*> get() = SelectClause1Impl<Any?>(\n        clauseObject = this@JobSupport,\n        regFunc = JobSupport::onAwaitInternalRegFunc as RegistrationFunction,\n        processResFunc = JobSupport::onAwaitInternalProcessResFunc as ProcessResultFunction\n    )\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun onAwaitInternalRegFunc(select: SelectInstance<*>, ignoredParam: Any?) {\n        while (true) {\n            val state = this.state\n            if (state !is Incomplete) {\n                val result = if (state is CompletedExceptionally) state else state.unboxState()\n                select.selectInRegistrationPhase(result)\n                return\n            }\n            if (startInternal(state) >= 0) break // break unless needs to retry\n        }\n        val disposableHandle = invokeOnCompletion(handler = SelectOnAwaitCompletionHandler(select))\n        select.disposeOnCompletion(disposableHandle)\n    }\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun onAwaitInternalProcessResFunc(ignoredParam: Any?, result: Any?): Any? {\n        if (result is CompletedExceptionally) throw result.cause\n        return result\n    }\n\n    private inner class SelectOnAwaitCompletionHandler(\n        private val select: SelectInstance<*>\n    ) : JobNode() {\n        override fun invoke(cause: Throwable?) {\n            val state = this@JobSupport.state\n            val result = if (state is CompletedExceptionally) state else state.unboxState()\n            select.trySelect(this@JobSupport, result)\n        }\n    }\n}\n\n/*\n * Class to represent object as the final state of the Job\n */\nprivate class IncompleteStateBox(@JvmField val state: Incomplete)\ninternal fun Any?.boxIncomplete(): Any? = if (this is Incomplete) IncompleteStateBox(this) else this\ninternal fun Any?.unboxState(): Any? = (this as? IncompleteStateBox)?.state ?: this\n\n// --------------- helper classes & constants for job implementation\n\nprivate val COMPLETING_ALREADY = Symbol(\"COMPLETING_ALREADY\")\n@JvmField\ninternal val COMPLETING_WAITING_CHILDREN = Symbol(\"COMPLETING_WAITING_CHILDREN\")\nprivate val COMPLETING_RETRY = Symbol(\"COMPLETING_RETRY\")\nprivate val TOO_LATE_TO_CANCEL = Symbol(\"TOO_LATE_TO_CANCEL\")\n\nprivate const val RETRY = -1\nprivate const val FALSE = 0\nprivate const val TRUE = 1\n\nprivate val SEALED = Symbol(\"SEALED\")\nprivate val EMPTY_NEW = Empty(false)\nprivate val EMPTY_ACTIVE = Empty(true)\n\nprivate class Empty(override val isActive: Boolean) : Incomplete {\n    override val list: NodeList? get() = null\n    override fun toString(): String = \"Empty{${if (isActive) \"Active\" else \"New\" }}\"\n}\n\n@PublishedApi // for a custom job in the test module\ninternal open class JobImpl(parent: Job?) : JobSupport(true), CompletableJob {\n    init { initParentJob(parent) }\n    override val onCancelComplete get() = true\n    /*\n     * Check whether parent is able to handle exceptions as well.\n     * With this check, an exception in that pattern will be handled once:\n     * ```\n     * launch {\n     *     val child = Job(coroutineContext[Job])\n     *     launch(child) { throw ... }\n     * }\n     * ```\n     */\n    override val handlesException: Boolean = handlesException()\n    override fun complete() = makeCompleting(Unit)\n    override fun completeExceptionally(exception: Throwable): Boolean =\n        makeCompleting(CompletedExceptionally(exception))\n\n    @JsName(\"handlesExceptionF\")\n    private fun handlesException(): Boolean {\n        var parentJob = (parentHandle as? ChildHandleNode)?.job ?: return false\n        while (true) {\n            if (parentJob.handlesException) return true\n            parentJob = (parentJob.parentHandle as? ChildHandleNode)?.job ?: return false\n        }\n    }\n}\n\n// -------- invokeOnCompletion nodes\n\ninternal interface Incomplete {\n    val isActive: Boolean\n    val list: NodeList? // is null only for Empty and JobNode incomplete state objects\n}\n\ninternal abstract class JobNode : LockFreeLinkedListNode(), InternalCompletionHandler, DisposableHandle, Incomplete {\n    /**\n     * Initialized by [JobSupport.makeNode].\n     */\n    lateinit var job: JobSupport\n    override val isActive: Boolean get() = true\n    override val list: NodeList? get() = null\n    override fun dispose() = job.removeNode(this)\n    override fun toString() = \"$classSimpleName@$hexAddress[job@${job.hexAddress}]\"\n}\n\ninternal class NodeList : LockFreeLinkedListHead(), Incomplete {\n    override val isActive: Boolean get() = true\n    override val list: NodeList get() = this\n\n    fun getString(state: String) = buildString {\n        append(\"List{\")\n        append(state)\n        append(\"}[\")\n        var first = true\n        this@NodeList.forEach<JobNode> { node ->\n            if (first) first = false else append(\", \")\n            append(node)\n        }\n        append(\"]\")\n    }\n\n    override fun toString(): String =\n        if (DEBUG) getString(\"Active\") else super.toString()\n}\n\ninternal class InactiveNodeList(\n    override val list: NodeList\n) : Incomplete {\n    override val isActive: Boolean get() = false\n    override fun toString(): String = if (DEBUG) list.getString(\"New\") else super.toString()\n}\n\nprivate class InvokeOnCompletion(\n    private val handler: InternalCompletionHandler\n) : JobNode()  {\n    override fun invoke(cause: Throwable?) = handler.invoke(cause)\n}\n\nprivate class ResumeOnCompletion(\n    private val continuation: Continuation<Unit>\n) : JobNode() {\n    override fun invoke(cause: Throwable?) = continuation.resume(Unit)\n}\n\nprivate class ResumeAwaitOnCompletion<T>(\n    private val continuation: CancellableContinuationImpl<T>\n) : JobNode() {\n    override fun invoke(cause: Throwable?) {\n        val state = job.state\n        assert { state !is Incomplete }\n        if (state is CompletedExceptionally) {\n            // Resume with with the corresponding exception to preserve it\n            continuation.resumeWithException(state.cause)\n        } else {\n            // Resuming with value in a cancellable way (AwaitContinuation is configured for this mode).\n            @Suppress(\"UNCHECKED_CAST\")\n            continuation.resume(state.unboxState() as T)\n        }\n    }\n}\n\ninternal class DisposeOnCompletion(\n    private val handle: DisposableHandle\n) : JobNode() {\n    override fun invoke(cause: Throwable?) = handle.dispose()\n}\n\n// -------- invokeOnCancellation nodes\n\n/**\n * Marker for node that shall be invoked on in _cancelling_ state.\n * **Note: may be invoked multiple times.**\n */\ninternal abstract class JobCancellingNode : JobNode()\n\nprivate class InvokeOnCancelling(\n    private val handler: InternalCompletionHandler\n) : JobCancellingNode()  {\n    // delegate handler shall be invoked at most once, so here is an additional flag\n    private val _invoked = atomic(0) // todo: replace with atomic boolean after migration to recent atomicFu\n    override fun invoke(cause: Throwable?) {\n        if (_invoked.compareAndSet(0, 1)) handler.invoke(cause)\n    }\n}\n\ninternal class ChildHandleNode(\n    @JvmField val childJob: ChildJob\n) : JobCancellingNode(), ChildHandle {\n    override val parent: Job get() = job\n    override fun invoke(cause: Throwable?) = childJob.parentCancelled(job)\n    override fun childCancelled(cause: Throwable): Boolean = job.childCancelled(cause)\n}\n\n// Same as ChildHandleNode, but for cancellable continuation\n@PublishedApi\ninternal class ChildContinuation(\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @JvmField val child: CancellableContinuationImpl<*>\n) : JobCancellingNode() {\n    override fun invoke(cause: Throwable?) {\n        child.parentCancelled(child.getContinuationCancellationCause(job))\n    }\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/MainCoroutineDispatcher.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\n\n/**\n * Base class for special [CoroutineDispatcher] which is confined to application \"Main\" or \"UI\" thread\n * and used for any UI-based activities. Instance of `MainDispatcher` can be obtained by [Dispatchers.Main].\n *\n * Platform may or may not provide instance of `MainDispatcher`, see documentation to [Dispatchers.Main]\n */\npublic abstract class MainCoroutineDispatcher : CoroutineDispatcher() {\n\n    /**\n     * Returns dispatcher that executes coroutines immediately when it is already in the right context\n     * (e.g. current looper is the same as this handler's looper) without an additional [re-dispatch][CoroutineDispatcher.dispatch].\n     *\n     * Immediate dispatcher is safe from stack overflows and in case of nested invocations forms event-loop similar to [Dispatchers.Unconfined].\n     * The event loop is an advanced topic and its implications can be found in [Dispatchers.Unconfined] documentation.\n     * The formed event-loop is shared with [Dispatchers.Unconfined] and other immediate dispatchers, potentially overlapping tasks between them.\n     *\n     * Example of usage:\n     * ```\n     * suspend fun updateUiElement(val text: String) {\n     *   /*\n     *    * If it is known that updateUiElement can be invoked both from the Main thread and from other threads,\n     *    * `immediate` dispatcher is used as a performance optimization to avoid unnecessary dispatch.\n     *    *\n     *    * In that case, when `updateUiElement` is invoked from the Main thread, `uiElement.text` will be\n     *    * invoked immediately without any dispatching, otherwise, the `Dispatchers.Main` dispatch cycle will be triggered.\n     *    */\n     *   withContext(Dispatchers.Main.immediate) {\n     *     uiElement.text = text\n     *   }\n     *   // Do context-independent logic such as logging\n     * }\n     * ```\n     *\n     * Method may throw [UnsupportedOperationException] if immediate dispatching is not supported by current dispatcher,\n     * please refer to specific dispatcher documentation.\n     *\n     * [Dispatchers.Main] supports immediate execution for Android, JavaFx and Swing platforms.\n     */\n    public abstract val immediate: MainCoroutineDispatcher\n\n    /**\n     * Returns a name of this main dispatcher for debugging purposes. This implementation returns\n     * `Dispatchers.Main` or `Dispatchers.Main.immediate` if it is the same as the corresponding\n     * reference in [Dispatchers] or a short class-name representation with address otherwise.\n     */\n    override fun toString(): String = toStringInternalImpl() ?: \"$classSimpleName@$hexAddress\"\n\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        parallelism.checkParallelism()\n        // MainCoroutineDispatcher is single-threaded -- short-circuit any attempts to limit it\n        return this\n    }\n\n    /**\n     * Internal method for more specific [toString] implementations. It returns non-null\n     * string if this dispatcher is set in the platform as the main one.\n     * @suppress\n     */\n    @InternalCoroutinesApi\n    protected fun toStringInternalImpl(): String? {\n        val main = Dispatchers.Main\n        if (this === main) return \"Dispatchers.Main\"\n        val immediate =\n            try { main.immediate }\n            catch (e: UnsupportedOperationException) { null }\n        if (this === immediate) return \"Dispatchers.Main.immediate\"\n        return null\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/NonCancellable.kt",
        "content": "@file:Suppress(\"DEPRECATION_ERROR\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.selects.*\nimport kotlin.coroutines.*\n\n/**\n * A non-cancelable job that is always [active][Job.isActive]. It is designed for [withContext] function\n * to prevent cancellation of code blocks that need to be executed without cancellation.\n *\n * Use it like this:\n * ```\n * withContext(NonCancellable) {\n *     // this code will not be cancelled\n * }\n * ```\n *\n * **WARNING**: This object is not designed to be used with [launch], [async], and other coroutine builders.\n * if you write `launch(NonCancellable) { ... }` then not only the newly launched job will not be cancelled\n * when the parent is cancelled, the whole parent-child relation between parent and child is severed.\n * The parent will not wait for the child's completion, nor will be cancelled when the child crashed.\n */\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\npublic object NonCancellable : AbstractCoroutineContextElement(Job), Job {\n\n    private const val message = \"NonCancellable can be used only as an argument for 'withContext', direct usages of its API are prohibited\"\n\n    /**\n     * Always returns `null`.\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override val parent: Job?\n        get() = null\n\n    /**\n     * Always returns `true`.\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override val isActive: Boolean\n        get() = true\n\n    /**\n     * Always returns `false`.\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override val isCompleted: Boolean get() = false\n\n    /**\n     * Always returns `false`.\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override val isCancelled: Boolean get() = false\n\n    /**\n     * Always returns `false`.\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override fun start(): Boolean = false\n\n    /**\n     * Always throws [UnsupportedOperationException].\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override suspend fun join() {\n        throw UnsupportedOperationException(\"This job is always active\")\n    }\n\n    /**\n     * Always throws [UnsupportedOperationException].\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override val onJoin: SelectClause0\n        get() = throw UnsupportedOperationException(\"This job is always active\")\n\n    /**\n     * Always throws [IllegalStateException].\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override fun getCancellationException(): CancellationException = throw IllegalStateException(\"This job is always active\")\n\n    /**\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override fun invokeOnCompletion(handler: CompletionHandler): DisposableHandle =\n        NonDisposableHandle\n\n    /**\n     * Always returns no-op handle.\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override fun invokeOnCompletion(onCancelling: Boolean, invokeImmediately: Boolean, handler: CompletionHandler): DisposableHandle =\n        NonDisposableHandle\n\n    /**\n     * Does nothing.\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override fun cancel(cause: CancellationException?) {}\n\n    /**\n     * Always returns `false`.\n     * @suppress This method has bad semantics when cause is not a [CancellationException]. Use [cancel].\n     */\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n    override fun cancel(cause: Throwable?): Boolean = false // never handles exceptions\n\n    /**\n     * Always returns [emptySequence].\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override val children: Sequence<Job>\n        get() = emptySequence()\n\n    /**\n     * Always returns [NonDisposableHandle] and does not do anything.\n     * @suppress **This an internal API and should not be used from general code.**\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = message)\n    override fun attachChild(child: ChildJob): ChildHandle = NonDisposableHandle\n\n    /** @suppress */\n    override fun toString(): String {\n        return \"NonCancellable\"\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Runnable.common.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * A runnable task for [CoroutineDispatcher.dispatch].\n */\npublic expect interface Runnable {\n    /**\n     * @suppress\n     */\n    public fun run()\n}\n\n/**\n * Creates [Runnable] task instance.\n */\n@Suppress(\"FunctionName\")\npublic expect inline fun Runnable(crossinline block: () -> Unit): Runnable\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/SchedulerTask.common.kt",
        "content": "package kotlinx.coroutines\n\ninternal expect abstract class SchedulerTask internal constructor() : Runnable\n\ninternal expect interface SchedulerTaskContext\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\ninternal expect val SchedulerTask.taskContext: SchedulerTaskContext\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\ninternal expect inline fun SchedulerTaskContext.afterTask()\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Supervisor.kt",
        "content": "@file:OptIn(ExperimentalContracts::class)\n@file:Suppress(\"DEPRECATION_ERROR\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.intrinsics.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.jvm.*\n\n/**\n * Creates a _supervisor_ job object in an active state.\n * Children of a supervisor job can fail independently of each other.\n * \n * A failure or cancellation of a child does not cause the supervisor job to fail and does not affect its other children,\n * so a supervisor can implement a custom policy for handling failures of its children:\n *\n * - A failure of a child job that was created using [launch][CoroutineScope.launch] can be handled via [CoroutineExceptionHandler] in the context.\n * - A failure of a child job that was created using [async][CoroutineScope.async] can be handled via [Deferred.await] on the resulting deferred value.\n *\n * If a [parent] job is specified, then this supervisor job becomes a child job of [parent] and is cancelled when the\n * parent fails or is cancelled. All this supervisor's children are cancelled in this case, too.\n */\n@Suppress(\"FunctionName\")\npublic fun SupervisorJob(parent: Job? = null) : CompletableJob = SupervisorJobImpl(parent)\n\n/** @suppress Binary compatibility only */\n@Suppress(\"FunctionName\")\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n@JvmName(\"SupervisorJob\")\npublic fun SupervisorJob0(parent: Job? = null) : Job = SupervisorJob(parent)\n\n/**\n * Creates a [CoroutineScope] with [SupervisorJob] and calls the specified suspend [block] with this scope.\n * The provided scope inherits its [coroutineContext][CoroutineScope.coroutineContext] from the outer scope, using the\n * [Job] from that context as the parent for the new [SupervisorJob].\n * This function returns as soon as the given block and all its child coroutines are completed.\n *\n * Unlike [coroutineScope], a failure of a child does not cause this scope to fail and does not affect its other children,\n * so a custom policy for handling failures of its children can be implemented. See [SupervisorJob] for additional details.\n *\n * If an exception happened in [block], then the supervisor job is failed and all its children are cancelled.\n * If the current coroutine was cancelled, then both the supervisor job itself and all its children are cancelled.\n *\n * The method may throw a [CancellationException] if the current job was cancelled externally,\n * or rethrow an exception thrown by the given [block].\n */\npublic suspend fun <R> supervisorScope(block: suspend CoroutineScope.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return suspendCoroutineUninterceptedOrReturn { uCont ->\n        val coroutine = SupervisorCoroutine(uCont.context, uCont)\n        coroutine.startUndispatchedOrReturn(coroutine, block)\n    }\n}\n\nprivate class SupervisorJobImpl(parent: Job?) : JobImpl(parent) {\n    override fun childCancelled(cause: Throwable): Boolean = false\n}\n\nprivate class SupervisorCoroutine<in T>(\n    context: CoroutineContext,\n    uCont: Continuation<T>\n) : ScopeCoroutine<T>(context, uCont) {\n    override fun childCancelled(cause: Throwable): Boolean = false\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Timeout.kt",
        "content": "@file:OptIn(ExperimentalContracts::class)\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.intrinsics.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.jvm.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\n\n/**\n * Runs a given suspending [block] of code inside a coroutine with a specified [timeout][timeMillis] and throws\n * a [TimeoutCancellationException] if the timeout was exceeded.\n * If the given [timeMillis] is non-positive, [TimeoutCancellationException] is thrown immediately.\n *\n * The code that is executing inside the [block] is cancelled on timeout and the active or next invocation of\n * the cancellable suspending function inside the block throws a [TimeoutCancellationException].\n *\n * The sibling function that does not throw an exception on timeout is [withTimeoutOrNull].\n * Note that the timeout action can be specified for a [select] invocation with [onTimeout][SelectBuilder.onTimeout] clause.\n *\n * **The timeout event is asynchronous with respect to the code running in the block** and may happen at any time,\n * even right before the return from inside the timeout [block]. Keep this in mind if you open or acquire some\n * resource inside the [block] that needs closing or release outside the block.\n * See the\n * [Asynchronous timeout and resources][https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html#asynchronous-timeout-and-resources]\n * section of the coroutines guide for details.\n *\n * > Implementation note: how the time is tracked exactly is an implementation detail of the context's [CoroutineDispatcher].\n *\n * @param timeMillis timeout time in milliseconds.\n */\npublic suspend fun <T> withTimeout(timeMillis: Long, block: suspend CoroutineScope.() -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    if (timeMillis <= 0L) throw TimeoutCancellationException(\"Timed out immediately\")\n    return suspendCoroutineUninterceptedOrReturn { uCont ->\n        setupTimeout(TimeoutCoroutine(timeMillis, uCont), block)\n    }\n}\n\n/**\n * Runs a given suspending [block] of code inside a coroutine with the specified [timeout] and throws\n * a [TimeoutCancellationException] if the timeout was exceeded.\n * If the given [timeout] is non-positive, [TimeoutCancellationException] is thrown immediately.\n *\n * The code that is executing inside the [block] is cancelled on timeout and the active or next invocation of\n * the cancellable suspending function inside the block throws a [TimeoutCancellationException].\n *\n * The sibling function that does not throw an exception on timeout is [withTimeoutOrNull].\n * Note that the timeout action can be specified for a [select] invocation with [onTimeout][SelectBuilder.onTimeout] clause.\n *\n * **The timeout event is asynchronous with respect to the code running in the block** and may happen at any time,\n * even right before the return from inside the timeout [block]. Keep this in mind if you open or acquire some\n * resource inside the [block] that needs closing or release outside the block.\n * See the\n * [Asynchronous timeout and resources][https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html#asynchronous-timeout-and-resources]\n * section of the coroutines guide for details.\n *\n * > Implementation note: how the time is tracked exactly is an implementation detail of the context's [CoroutineDispatcher].\n */\npublic suspend fun <T> withTimeout(timeout: Duration, block: suspend CoroutineScope.() -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return withTimeout(timeout.toDelayMillis(), block)\n}\n\n/**\n * Runs a given suspending block of code inside a coroutine with a specified [timeout][timeMillis] and returns\n * `null` if this timeout was exceeded.\n * If the given [timeMillis] is non-positive, `null` is returned immediately.\n *\n * The code that is executing inside the [block] is cancelled on timeout and the active or next invocation of\n * cancellable suspending function inside the block throws a [TimeoutCancellationException].\n *\n * The sibling function that throws an exception on timeout is [withTimeout].\n * Note that the timeout action can be specified for a [select] invocation with [onTimeout][SelectBuilder.onTimeout] clause.\n *\n * **The timeout event is asynchronous with respect to the code running in the block** and may happen at any time,\n * even right before the return from inside the timeout [block]. Keep this in mind if you open or acquire some\n * resource inside the [block] that needs closing or release outside the block.\n * See the\n * [Asynchronous timeout and resources][https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html#asynchronous-timeout-and-resources]\n * section of the coroutines guide for details.\n *\n * > Implementation note: how the time is tracked exactly is an implementation detail of the context's [CoroutineDispatcher].\n *\n * @param timeMillis timeout time in milliseconds.\n */\npublic suspend fun <T> withTimeoutOrNull(timeMillis: Long, block: suspend CoroutineScope.() -> T): T? {\n    if (timeMillis <= 0L) return null\n\n    var coroutine: TimeoutCoroutine<T?, T?>? = null\n    try {\n        return suspendCoroutineUninterceptedOrReturn { uCont ->\n            val timeoutCoroutine = TimeoutCoroutine(timeMillis, uCont)\n            coroutine = timeoutCoroutine\n            setupTimeout<T?, T?>(timeoutCoroutine, block)\n        }\n    } catch (e: TimeoutCancellationException) {\n        // Return null if it's our exception, otherwise propagate it upstream (e.g. in case of nested withTimeouts)\n        if (e.coroutine === coroutine) {\n            return null\n        }\n        throw e\n    }\n}\n\n/**\n * Runs a given suspending block of code inside a coroutine with the specified [timeout] and returns\n * `null` if this timeout was exceeded.\n * If the given [timeout] is non-positive, `null` is returned immediately.\n *\n * The code that is executing inside the [block] is cancelled on timeout and the active or next invocation of\n * cancellable suspending function inside the block throws a [TimeoutCancellationException].\n *\n * The sibling function that throws an exception on timeout is [withTimeout].\n * Note that the timeout action can be specified for a [select] invocation with [onTimeout][SelectBuilder.onTimeout] clause.\n *\n * **The timeout event is asynchronous with respect to the code running in the block** and may happen at any time,\n * even right before the return from inside the timeout [block]. Keep this in mind if you open or acquire some\n * resource inside the [block] that needs closing or release outside the block.\n * See the\n * [Asynchronous timeout and resources][https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html#asynchronous-timeout-and-resources]\n * section of the coroutines guide for details.\n *\n * > Implementation note: how the time is tracked exactly is an implementation detail of the context's [CoroutineDispatcher].\n */\npublic suspend fun <T> withTimeoutOrNull(timeout: Duration, block: suspend CoroutineScope.() -> T): T? =\n    withTimeoutOrNull(timeout.toDelayMillis(), block)\n\nprivate fun <U, T : U> setupTimeout(\n    coroutine: TimeoutCoroutine<U, T>,\n    block: suspend CoroutineScope.() -> T\n): Any? {\n    // schedule cancellation of this coroutine on time\n    val cont = coroutine.uCont\n    val context = cont.context\n    coroutine.disposeOnCompletion(context.delay.invokeOnTimeout(coroutine.time, coroutine, coroutine.context))\n    // restart the block using a new coroutine with a new job,\n    // however, start it undispatched, because we already are in the proper context\n    return coroutine.startUndispatchedOrReturnIgnoreTimeout(coroutine, block)\n}\n\nprivate class TimeoutCoroutine<U, in T : U>(\n    @JvmField val time: Long,\n    uCont: Continuation<U> // unintercepted continuation\n) : ScopeCoroutine<T>(uCont.context, uCont), Runnable {\n    override fun run() {\n        cancelCoroutine(TimeoutCancellationException(time, context.delay, this))\n    }\n\n    override fun nameString(): String =\n        \"${super.nameString()}(timeMillis=$time)\"\n}\n\n/**\n * This exception is thrown by [withTimeout] to indicate timeout.\n */\npublic class TimeoutCancellationException internal constructor(\n    message: String,\n    @JvmField @Transient internal val coroutine: Job?\n) : CancellationException(message), CopyableThrowable<TimeoutCancellationException> {\n    /**\n     * Creates a timeout exception with the given message.\n     * This constructor is needed for exception stack-traces recovery.\n     */\n    internal constructor(message: String) : this(message, null)\n\n    // message is never null in fact\n    override fun createCopy(): TimeoutCancellationException =\n        TimeoutCancellationException(message ?: \"\", coroutine).also { it.initCause(this) }\n}\n\ninternal fun TimeoutCancellationException(\n    time: Long,\n    delay: Delay,\n    coroutine: Job\n) : TimeoutCancellationException {\n    val message = (delay as? DelayWithTimeoutDiagnostics)?.timeoutMessage(time.milliseconds)\n        ?: \"Timed out waiting for $time ms\"\n    return TimeoutCancellationException(message, coroutine)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Unconfined.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * A coroutine dispatcher that is not confined to any specific thread.\n */\ninternal object Unconfined : CoroutineDispatcher() {\n\n    @ExperimentalCoroutinesApi\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        throw UnsupportedOperationException(\"limitedParallelism is not supported for Dispatchers.Unconfined\")\n    }\n\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        /** It can only be called by the [yield] function. See also code of [yield] function. */\n        val yieldContext = context[YieldContext]\n        if (yieldContext != null) {\n            // report to \"yield\" that it is an unconfined dispatcher and don't call \"block.run()\"\n            yieldContext.dispatcherWasUnconfined = true\n            return\n        }\n        throw UnsupportedOperationException(\"Dispatchers.Unconfined.dispatch function can only be used by the yield function. \" +\n            \"If you wrap Unconfined dispatcher in your code, make sure you properly delegate \" +\n            \"isDispatchNeeded and dispatch calls.\")\n    }\n    \n    override fun toString(): String = \"Dispatchers.Unconfined\"\n}\n\n/**\n * Used to detect calls to [Unconfined.dispatch] from [yield] function.\n */\n@PublishedApi\ninternal class YieldContext : AbstractCoroutineContextElement(Key) {\n    companion object Key : CoroutineContext.Key<YieldContext>\n\n    @JvmField\n    var dispatcherWasUnconfined = false\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Waiter.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.Segment\nimport kotlinx.coroutines.selects.*\n\n/**\n * All waiters (such as [CancellableContinuationImpl] and [SelectInstance]) in synchronization and\n * communication primitives, should implement this interface to make the code faster and easier to read.\n */\ninternal interface Waiter {\n    /**\n     * When this waiter is cancelled, [Segment.onCancellation] with\n     * the specified [segment] and [index] should be called.\n     * This function installs the corresponding cancellation handler.\n     */\n    fun invokeOnCancellation(segment: Segment<*>, index: Int)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/Yield.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.intrinsics.*\n\n/**\n * Yields the thread (or thread pool) of the current coroutine dispatcher\n * to other coroutines on the same dispatcher to run if possible.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while\n * [yield] is invoked or while waiting for dispatch, it immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n *\n * **Note**: This function always [checks for cancellation][ensureActive] even when it does not suspend.\n *\n * ### Implementation details\n *\n * If the coroutine dispatcher is [Unconfined][Dispatchers.Unconfined], this\n * functions suspends only when there are other unconfined coroutines working and forming an event-loop.\n * For other dispatchers, this function calls [CoroutineDispatcher.dispatch] and\n * always suspends to be resumed later regardless of the result of [CoroutineDispatcher.isDispatchNeeded].\n * If there is no [CoroutineDispatcher] in the context, it does not suspend.\n */\npublic suspend fun yield(): Unit = suspendCoroutineUninterceptedOrReturn sc@ { uCont ->\n    val context = uCont.context\n    context.ensureActive()\n    val cont = uCont.intercepted() as? DispatchedContinuation<Unit> ?: return@sc Unit\n    if (cont.dispatcher.isDispatchNeeded(context)) {\n        // this is a regular dispatcher -- do simple dispatchYield\n        cont.dispatchYield(context, Unit)\n    } else {\n        // This is either an \"immediate\" dispatcher or the Unconfined dispatcher\n        // This code detects the Unconfined dispatcher even if it was wrapped into another dispatcher\n        val yieldContext = YieldContext()\n        cont.dispatchYield(context + yieldContext, Unit)\n        // Special case for the unconfined dispatcher that can yield only in existing unconfined loop\n        if (yieldContext.dispatcherWasUnconfined) {\n            // Means that the Unconfined dispatcher got the call, but did not do anything.\n            // See also code of \"Unconfined.dispatch\" function.\n            return@sc if (cont.yieldUndispatched()) COROUTINE_SUSPENDED else Unit\n        }\n        // Otherwise, it was some other dispatcher that successfully dispatched the coroutine\n    }\n    COROUTINE_SUSPENDED\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/Broadcast.kt",
        "content": "@file:Suppress(\"DEPRECATION\")\n\npackage kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.Channel.Factory.CONFLATED\nimport kotlinx.coroutines.channels.Channel.Factory.UNLIMITED\nimport kotlinx.coroutines.intrinsics.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n/**\n * Broadcasts all elements of the channel.\n * This function [consumes][ReceiveChannel.consume] all elements of the original [ReceiveChannel].\n *\n * The kind of the resulting channel depends on the specified [capacity] parameter:\n * when `capacity` is positive (1 by default), but less than [UNLIMITED] -- uses [BroadcastChannel] with a buffer of given capacity,\n * when `capacity` is [CONFLATED] -- uses [ConflatedBroadcastChannel] that conflates back-to-back sends;\n *   Note that resulting channel behaves like [ConflatedBroadcastChannel] but is not an instance of [ConflatedBroadcastChannel].\n *   otherwise -- throws [IllegalArgumentException].\n *\n * ### Cancelling broadcast\n *\n * **To stop broadcasting from the underlying channel call [cancel][BroadcastChannel.cancel] on the result.**\n *\n * Do not use [close][BroadcastChannel.close] on the resulting channel.\n * It causes eventual failure of the broadcast coroutine and cancellation of the underlying channel, too,\n * but it is not as prompt.\n *\n * ### Future replacement\n *\n * This function has an inappropriate result type of [BroadcastChannel] which provides\n * [send][BroadcastChannel.send] and [close][BroadcastChannel.close] operations that interfere with\n * the broadcasting coroutine in hard-to-specify ways.\n *\n * **Note: This API is obsolete since 1.5.0.** It is deprecated with warning in 1.7.0.\n * It is replaced with [Flow.shareIn][kotlinx.coroutines.flow.shareIn] operator.\n *\n * @param start coroutine start option. The default value is [CoroutineStart.LAZY].\n */\n@ObsoleteCoroutinesApi\n@Deprecated(level = DeprecationLevel.WARNING, message = \"BroadcastChannel is deprecated in the favour of SharedFlow and is no longer supported\")\npublic fun <E> ReceiveChannel<E>.broadcast(\n    capacity: Int = 1,\n    start: CoroutineStart = CoroutineStart.LAZY\n): BroadcastChannel<E> {\n    val scope = GlobalScope + Dispatchers.Unconfined + CoroutineExceptionHandler { _, _ -> }\n    val channel = this\n    // We can run this coroutine in the context that ignores all exceptions, because of `onCompletion = consume()`\n    // which passes all exceptions upstream to the source ReceiveChannel\n    return scope.broadcast(capacity = capacity, start = start, onCompletion = { cancelConsumed(it) }) {\n        for (e in channel) {\n            send(e)\n        }\n    }\n}\n\n/**\n * Launches new coroutine to produce a stream of values by sending them to a broadcast channel\n * and returns a reference to the coroutine as a [BroadcastChannel]. The resulting\n * object can be used to [subscribe][BroadcastChannel.openSubscription] to elements produced by this coroutine.\n *\n * The scope of the coroutine contains [ProducerScope] interface, which implements\n * both [CoroutineScope] and [SendChannel], so that coroutine can invoke\n * [send][SendChannel.send] directly. The channel is [closed][SendChannel.close]\n * when the coroutine completes.\n *\n * Coroutine context is inherited from a [CoroutineScope], additional context elements can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * The parent job is inherited from a [CoroutineScope] as well, but it can also be overridden\n * with corresponding [context] element.\n *\n * Uncaught exceptions in this coroutine close the channel with this exception as a cause and\n * the resulting channel becomes _failed_, so that any attempt to receive from such a channel throws exception.\n *\n * The kind of the resulting channel depends on the specified [capacity] parameter:\n * - when `capacity` is positive (1 by default), but less than [UNLIMITED] -- uses [BroadcastChannel] with a buffer of given capacity,\n * - when `capacity` is [CONFLATED] -- uses [ConflatedBroadcastChannel] that conflates back-to-back sends;\n *   Note that resulting channel behaves like [ConflatedBroadcastChannel] but is not an instance of [ConflatedBroadcastChannel].\n * - otherwise -- throws [IllegalArgumentException].\n *\n * **Note:** By default, the coroutine does not start until the first subscriber appears via [BroadcastChannel.openSubscription]\n * as [start] parameter has a value of [CoroutineStart.LAZY] by default.\n * This ensures that the first subscriber does not miss any sent elements.\n * However, later subscribers may miss elements.\n *\n * See [newCoroutineContext] for a description of debugging facilities that are available for newly created coroutine.\n *\n * ### Cancelling broadcast\n *\n * **To stop broadcasting from the underlying channel call [cancel][BroadcastChannel.cancel] on the result.**\n *\n * Do not use [close][BroadcastChannel.close] on the resulting channel.\n * It causes  failure of the `send` operation in broadcast coroutine and would not cancel it if the\n * coroutine is doing something else.\n *\n * ### Future replacement\n *\n * This API is obsolete since 1.5.0 and deprecated with warning since 1.7.0.\n * This function has an inappropriate result type of [BroadcastChannel] which provides\n * [send][BroadcastChannel.send] and [close][BroadcastChannel.close] operations that interfere with\n * the broadcasting coroutine in hard-to-specify ways.\n * It is replaced with [Flow.shareIn][kotlinx.coroutines.flow.shareIn] operator.\n *\n * @param context additional to [CoroutineScope.coroutineContext] context of the coroutine.\n * @param capacity capacity of the channel's buffer (1 by default).\n * @param start coroutine start option. The default value is [CoroutineStart.LAZY].\n * @param onCompletion optional completion handler for the producer coroutine (see [Job.invokeOnCompletion]).\n * @param block the coroutine code.\n */\n@ObsoleteCoroutinesApi\n@Deprecated(level = DeprecationLevel.WARNING, message = \"BroadcastChannel is deprecated in the favour of SharedFlow and is no longer supported\")\npublic fun <E> CoroutineScope.broadcast(\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = 1,\n    start: CoroutineStart = CoroutineStart.LAZY,\n    onCompletion: CompletionHandler? = null,\n    @BuilderInference block: suspend ProducerScope<E>.() -> Unit\n): BroadcastChannel<E> {\n    val newContext = newCoroutineContext(context)\n    val channel = BroadcastChannel<E>(capacity)\n    val coroutine = if (start.isLazy)\n        LazyBroadcastCoroutine(newContext, channel, block) else\n        BroadcastCoroutine(newContext, channel, active = true)\n    if (onCompletion != null) coroutine.invokeOnCompletion(handler = onCompletion)\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n\nprivate open class BroadcastCoroutine<E>(\n    parentContext: CoroutineContext,\n    protected val _channel: BroadcastChannel<E>,\n    active: Boolean\n) : AbstractCoroutine<Unit>(parentContext, initParentJob = false, active = active),\n    ProducerScope<E>, BroadcastChannel<E> by _channel {\n\n    init {\n        initParentJob(parentContext[Job])\n    }\n\n    override val isActive: Boolean get() = super.isActive\n\n    override val channel: SendChannel<E>\n        get() = this\n\n    @Suppress(\"MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_DEPRECATION_WARNING\") // do not remove the MULTIPLE_DEFAULTS suppression: required in K2\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n    final override fun cancel(cause: Throwable?): Boolean {\n        cancelInternal(cause ?: defaultCancellationException())\n        return true\n    }\n\n    @Suppress(\"MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_DEPRECATION_WARNING\") // do not remove the MULTIPLE_DEFAULTS suppression: required in K2\n    final override fun cancel(cause: CancellationException?) {\n        cancelInternal(cause ?: defaultCancellationException())\n    }\n\n    override fun cancelInternal(cause: Throwable) {\n        val exception = cause.toCancellationException()\n        _channel.cancel(exception) // cancel the channel\n        cancelCoroutine(exception) // cancel the job\n    }\n\n    override fun onCompleted(value: Unit) {\n        _channel.close()\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        val processed = _channel.close(cause)\n        if (!processed && !handled) handleCoroutineException(context, cause)\n    }\n\n    // The BroadcastChannel could be also closed\n    override fun close(cause: Throwable?): Boolean {\n        val result = _channel.close(cause)\n        start() // start coroutine if it was not started yet\n        return result\n    }\n}\n\nprivate class LazyBroadcastCoroutine<E>(\n    parentContext: CoroutineContext,\n    channel: BroadcastChannel<E>,\n    block: suspend ProducerScope<E>.() -> Unit\n) : BroadcastCoroutine<E>(parentContext, channel, active = false) {\n    private val continuation = block.createCoroutineUnintercepted(this, this)\n\n    override fun openSubscription(): ReceiveChannel<E> {\n        // open subscription _first_\n        val subscription = _channel.openSubscription()\n        // then start coroutine\n        start()\n        return subscription\n    }\n\n    override fun onStart() {\n        continuation.startCoroutineCancellable(this)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/BroadcastChannel.kt",
        "content": "@file:Suppress(\"FunctionName\", \"DEPRECATION\")\n\npackage kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.BufferOverflow.*\nimport kotlinx.coroutines.channels.Channel.Factory.BUFFERED\nimport kotlinx.coroutines.channels.Channel.Factory.CHANNEL_DEFAULT_CAPACITY\nimport kotlinx.coroutines.channels.Channel.Factory.CONFLATED\nimport kotlinx.coroutines.channels.Channel.Factory.UNLIMITED\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.native.concurrent.*\n\n/**\n * Broadcast channel is a non-blocking primitive for communication between the sender and multiple receivers\n * that subscribe for the elements using [openSubscription] function and unsubscribe using [ReceiveChannel.cancel]\n * function.\n *\n * See `BroadcastChannel()` factory function for the description of available\n * broadcast channel implementations.\n *\n * **Note: This API is obsolete since 1.5.0 and deprecated for removal since 1.7.0**\n * It is replaced with [SharedFlow][kotlinx.coroutines.flow.SharedFlow].\n */\n@ObsoleteCoroutinesApi\n@Deprecated(level = DeprecationLevel.WARNING, message = \"BroadcastChannel is deprecated in the favour of SharedFlow and is no longer supported\")\npublic interface BroadcastChannel<E> : SendChannel<E> {\n    /**\n     * Subscribes to this [BroadcastChannel] and returns a channel to receive elements from it.\n     * The resulting channel shall be [cancelled][ReceiveChannel.cancel] to unsubscribe from this\n     * broadcast channel.\n     */\n    public fun openSubscription(): ReceiveChannel<E>\n\n    /**\n     * Cancels reception of remaining elements from this channel with an optional cause.\n     * This function closes the channel with\n     * the specified cause (unless it was already closed), removes all buffered sent elements from it,\n     * and [cancels][ReceiveChannel.cancel] all open subscriptions.\n     * A cause can be used to specify an error message or to provide other details on\n     * a cancellation reason for debugging purposes.\n     */\n    public fun cancel(cause: CancellationException? = null)\n\n    /**\n     * @suppress This method has bad semantics when cause is not a [CancellationException]. Use [cancel].\n     */\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Binary compatibility only\")\n    public fun cancel(cause: Throwable? = null): Boolean\n}\n\n/**\n * Creates a broadcast channel with the specified buffer capacity.\n *\n * The resulting channel type depends on the specified [capacity] parameter:\n *\n * - when `capacity` positive, but less than [UNLIMITED] -- creates `ArrayBroadcastChannel` with a buffer of given capacity.\n *   **Note:** this channel looses all items that have been sent to it until the first subscriber appears;\n * - when `capacity` is [CONFLATED] -- creates [ConflatedBroadcastChannel] that conflates back-to-back sends;\n * - when `capacity` is [BUFFERED] -- creates `ArrayBroadcastChannel` with a default capacity.\n * - otherwise -- throws [IllegalArgumentException].\n *\n * **Note: This API is obsolete since 1.5.0 and deprecated for removal since 1.7.0**\n * It is replaced with [SharedFlow][kotlinx.coroutines.flow.SharedFlow] and [StateFlow][kotlinx.coroutines.flow.StateFlow].\n */\n@ObsoleteCoroutinesApi\n@Deprecated(level = DeprecationLevel.WARNING, message = \"BroadcastChannel is deprecated in the favour of SharedFlow and StateFlow, and is no longer supported\")\npublic fun <E> BroadcastChannel(capacity: Int): BroadcastChannel<E> =\n    when (capacity) {\n        0 -> throw IllegalArgumentException(\"Unsupported 0 capacity for BroadcastChannel\")\n        UNLIMITED -> throw IllegalArgumentException(\"Unsupported UNLIMITED capacity for BroadcastChannel\")\n        CONFLATED -> ConflatedBroadcastChannel()\n        BUFFERED -> BroadcastChannelImpl(CHANNEL_DEFAULT_CAPACITY)\n        else -> BroadcastChannelImpl(capacity)\n    }\n\n/**\n * Broadcasts the most recently sent element (aka [value]) to all [openSubscription] subscribers.\n *\n * Back-to-send sent elements are _conflated_ -- only the most recently sent value is received,\n * while previously sent elements **are lost**.\n * Every subscriber immediately receives the most recently sent element.\n * Sender to this broadcast channel never suspends and [trySend] always succeeds.\n *\n * A secondary constructor can be used to create an instance of this class that already holds a value.\n * This channel is also created by `BroadcastChannel(Channel.CONFLATED)` factory function invocation.\n *\n * In this implementation, [opening][openSubscription] and [closing][ReceiveChannel.cancel] subscription\n * takes linear time in the number of subscribers.\n *\n * **Note: This API is obsolete since 1.5.0 and deprecated for removal since 1.7.0**\n * It is replaced with [SharedFlow][kotlinx.coroutines.flow.StateFlow].\n */\n@ObsoleteCoroutinesApi\n@Deprecated(level = DeprecationLevel.WARNING, message = \"ConflatedBroadcastChannel is deprecated in the favour of SharedFlow and is no longer supported\")\npublic class ConflatedBroadcastChannel<E> private constructor(\n    private val broadcast: BroadcastChannelImpl<E>\n) : BroadcastChannel<E> by broadcast {\n    public constructor(): this(BroadcastChannelImpl<E>(capacity = CONFLATED))\n    /**\n     * Creates an instance of this class that already holds a value.\n     *\n     * It is as a shortcut to creating an instance with a default constructor and\n     * immediately sending an element: `ConflatedBroadcastChannel().apply { offer(value) }`.\n     */\n    public constructor(value: E) : this() {\n        trySend(value)\n    }\n\n    /**\n     * The most recently sent element to this channel.\n     *\n     * Access to this property throws [IllegalStateException] when this class is constructed without\n     * initial value and no value was sent yet or if it was [closed][close] without a cause.\n     * It throws the original [close][SendChannel.close] cause exception if the channel has _failed_.\n     */\n    public val value: E get() = broadcast.value\n    /**\n     * The most recently sent element to this channel or `null` when this class is constructed without\n     * initial value and no value was sent yet or if it was [closed][close].\n     */\n    public val valueOrNull: E? get() = broadcast.valueOrNull\n}\n\n/**\n * A common implementation for both the broadcast channel with a buffer of fixed [capacity]\n * and the conflated broadcast channel (see [ConflatedBroadcastChannel]).\n *\n * **Note**, that elements that are sent to this channel while there are no\n * [openSubscription] subscribers are immediately lost.\n *\n * This channel is created by `BroadcastChannel(capacity)` factory function invocation.\n */\n@Suppress(\"MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_DEPRECATION_WARNING\", \"MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE_DEPRECATION_WARNING\") // do not remove the MULTIPLE_DEFAULTS suppression: required in K2\ninternal class BroadcastChannelImpl<E>(\n    /**\n     * Buffer capacity; [Channel.CONFLATED] when this broadcast is conflated.\n     */\n    val capacity: Int\n) : BufferedChannel<E>(capacity = Channel.RENDEZVOUS, onUndeliveredElement = null), BroadcastChannel<E> {\n    init {\n        require(capacity >= 1 || capacity == CONFLATED) {\n            \"BroadcastChannel capacity must be positive or Channel.CONFLATED, but $capacity was specified\"\n        }\n    }\n\n    // This implementation uses coarse-grained synchronization,\n    // as, reputedly, it is the simplest synchronization scheme.\n    // All operations are protected by this lock.\n    private val lock = ReentrantLock()\n    // The list of subscribers; all accesses should be protected by lock.\n    // Each change must create a new list instance to avoid `ConcurrentModificationException`.\n    private var subscribers: List<BufferedChannel<E>> = emptyList()\n    // When this broadcast is conflated, this field stores the last sent element.\n    // If this channel is empty or not conflated, it stores a special `NO_ELEMENT` marker.\n    private var lastConflatedElement: Any? = NO_ELEMENT // NO_ELEMENT or E\n\n    // ###########################\n    // # Subscription Management #\n    // ###########################\n\n    override fun openSubscription(): ReceiveChannel<E> = lock.withLock { // protected by lock\n        // Is this broadcast conflated or buffered?\n        // Create the corresponding subscription channel.\n        val s = if (capacity == CONFLATED) SubscriberConflated() else SubscriberBuffered()\n        // If this broadcast is already closed or cancelled,\n        // and the last sent element is not available in case\n        // this broadcast is conflated, close the created\n        // subscriber immediately and return it.\n        if (isClosedForSend && lastConflatedElement === NO_ELEMENT) {\n            s.close(closeCause)\n            return s\n        }\n        // Is this broadcast conflated? If so, send\n        // the last sent element to the subscriber.\n        if (lastConflatedElement !== NO_ELEMENT) {\n            s.trySend(value)\n        }\n        // Add the subscriber to the list and return it.\n        subscribers += s\n        s\n    }\n\n    private fun removeSubscriber(s: ReceiveChannel<E>) = lock.withLock { // protected by lock\n        subscribers = subscribers.filter { it !== s }\n    }\n\n    // #############################\n    // # The `send(..)` Operations #\n    // #############################\n\n    /**\n     * Sends the specified element to all subscribers.\n     *\n     * **!!! THIS IMPLEMENTATION IS NOT LINEARIZABLE !!!**\n     *\n     * As the operation should send the element to multiple\n     * subscribers simultaneously, it is non-trivial to\n     * implement it in an atomic way. Specifically, this\n     * would require a special implementation that does\n     * not transfer the element until all parties are able\n     * to resume it (this `send(..)` can be cancelled\n     * or the broadcast can become closed in the meantime).\n     * As broadcasts are obsolete, we keep this implementation\n     * as simple as possible, allowing non-linearizability\n     * in corner cases.\n     */\n    override suspend fun send(element: E) {\n        val subs = lock.withLock { // protected by lock\n            // Is this channel closed for send?\n            if (isClosedForSend) throw sendException\n            // Update the last sent element if this broadcast is conflated.\n            if (capacity == CONFLATED) lastConflatedElement = element\n            // Get a reference to the list of subscribers under the lock.\n            subscribers\n        }\n        // The lock has been released. Send the element to the\n        // subscribers one-by-one, and finish immediately\n        // when this broadcast discovered in the closed state.\n        // Note that this implementation is non-linearizable;\n        // see this method documentation for details.\n        subs.forEach {\n            // We use special function to send the element,\n            // which returns `true` on success and `false`\n            // if the subscriber is closed.\n            val success = it.sendBroadcast(element)\n            // The sending attempt has failed.\n            // Check whether the broadcast is closed.\n            if (!success && isClosedForSend) throw sendException\n        }\n    }\n\n    override fun trySend(element: E): ChannelResult<Unit> = lock.withLock { // protected by lock\n        // Is this channel closed for send?\n        if (isClosedForSend) return super.trySend(element)\n        // Check whether the plain `send(..)` operation\n        // should suspend and fail in this case.\n        val shouldSuspend = subscribers.any { it.shouldSendSuspend() }\n        if (shouldSuspend) return ChannelResult.failure()\n        // Update the last sent element if this broadcast is conflated.\n        if (capacity == CONFLATED) lastConflatedElement = element\n        // Send the element to all subscribers.\n        // It is guaranteed that the attempt cannot fail,\n        // as both the broadcast closing and subscription\n        // cancellation are guarded by lock, which is held\n        // by the current operation.\n        subscribers.forEach { it.trySend(element) }\n        // Finish with success.\n        return ChannelResult.success(Unit)\n    }\n\n    // ###########################################\n    // # The `select` Expression: onSend { ... } #\n    // ###########################################\n\n    override fun registerSelectForSend(select: SelectInstance<*>, element: Any?) {\n        // It is extremely complicated to support sending via `select` for broadcasts,\n        // as the operation should wait on multiple subscribers simultaneously.\n        // At the same time, broadcasts are obsolete, so we need a simple implementation\n        // that works somehow. Here is a tricky work-around. First, we launch a new\n        // coroutine that performs plain `send(..)` operation and tries to complete\n        // this `select` via `trySelect`, independently on whether it is in the\n        // registration or in the waiting phase. On success, the operation finishes.\n        // On failure, if another clause is already selected or the `select` operation\n        // has been cancelled, we observe non-linearizable behaviour, as this `onSend`\n        // clause is completed as well. However, we believe that such a non-linearizability\n        // is fine for obsolete API. The last case is when the `select` operation is still\n        // in the registration case, so this `onSend` clause should be re-registered.\n        // The idea is that we keep information that this `onSend` clause is already selected\n        // and finish immediately.\n        @Suppress(\"UNCHECKED_CAST\")\n        element as E\n        // First, check whether this `onSend` clause is already\n        // selected, finishing immediately in this case.\n        lock.withLock {\n            val result = onSendInternalResult.remove(select)\n            if (result != null) { // already selected!\n                // `result` is either `Unit` ot `CHANNEL_CLOSED`.\n                select.selectInRegistrationPhase(result)\n                return\n            }\n        }\n        // Start a new coroutine that performs plain `send(..)`\n        // and tries to select this `onSend` clause at the end.\n        CoroutineScope(select.context).launch(start = CoroutineStart.UNDISPATCHED) {\n            val success: Boolean = try {\n                send(element)\n                // The element has been successfully sent!\n                true\n            } catch (t: Throwable) {\n                // This broadcast must be closed. However, it is possible that\n                // an unrelated exception, such as `OutOfMemoryError` has been thrown.\n                // This implementation checks that the channel is actually closed,\n                // re-throwing the caught exception otherwise.\n                if (isClosedForSend && (t is ClosedSendChannelException || sendException === t)) false\n                else throw t\n            }\n            // Mark this `onSend` clause as selected and\n            // try to complete the `select` operation.\n            lock.withLock {\n                // Status of this `onSend` clause should not be presented yet.\n                assert { onSendInternalResult[select] == null }\n                // Success or fail? Put the corresponding result.\n                onSendInternalResult[select] = if (success) Unit else CHANNEL_CLOSED\n                // Try to select this `onSend` clause.\n                select as SelectImplementation<*>\n                val trySelectResult = select.trySelectDetailed(this@BroadcastChannelImpl,  Unit)\n                if (trySelectResult !== TrySelectDetailedResult.REREGISTER) {\n                    // In case of re-registration (this `select` was still\n                    // in the registration phase), the algorithm will invoke\n                    // `registerSelectForSend`. As we stored an information that\n                    // this `onSend` clause is already selected (in `onSendInternalResult`),\n                    // the algorithm, will complete immediately. Otherwise, to avoid memory\n                    // leaks, we must remove this information from the hashmap.\n                    onSendInternalResult.remove(select)\n                }\n            }\n\n        }\n    }\n    private val onSendInternalResult = HashMap<SelectInstance<*>, Any?>() // select -> Unit or CHANNEL_CLOSED\n\n    // ############################\n    // # Closing and Cancellation #\n    // ############################\n\n    override fun close(cause: Throwable?): Boolean = lock.withLock { // protected by lock\n        // Close all subscriptions first.\n        subscribers.forEach { it.close(cause) }\n        // Remove all subscriptions that do not contain\n        // buffered elements or waiting send-s to avoid\n        // memory leaks. We must keep other subscriptions\n        // in case `broadcast.cancel(..)` is called.\n        subscribers = subscribers.filter { it.hasElements() }\n        // Delegate to the parent implementation.\n        super.close(cause)\n    }\n\n    override fun cancelImpl(cause: Throwable?): Boolean = lock.withLock { // protected by lock\n        // Cancel all subscriptions. As part of cancellation procedure,\n        // subscriptions automatically remove themselves from this broadcast.\n        subscribers.forEach { it.cancelImpl(cause) }\n        // For the conflated implementation, clear the last sent element.\n        lastConflatedElement = NO_ELEMENT\n        // Finally, delegate to the parent implementation.\n        super.cancelImpl(cause)\n    }\n\n    override val isClosedForSend: Boolean\n        // Protect by lock to synchronize with `close(..)` / `cancel(..)`.\n        get() = lock.withLock { super.isClosedForSend }\n\n    // ##############################\n    // # Subscriber Implementations #\n    // ##############################\n\n    private inner class SubscriberBuffered : BufferedChannel<E>(capacity = capacity) {\n        public override fun cancelImpl(cause: Throwable?): Boolean = lock.withLock {\n            // Remove this subscriber from the broadcast on cancellation.\n            removeSubscriber(this@SubscriberBuffered )\n            super.cancelImpl(cause)\n        }\n    }\n\n    private inner class SubscriberConflated : ConflatedBufferedChannel<E>(capacity = 1, onBufferOverflow = DROP_OLDEST) {\n        public override fun cancelImpl(cause: Throwable?): Boolean {\n            // Remove this subscriber from the broadcast on cancellation.\n            removeSubscriber(this@SubscriberConflated )\n            return super.cancelImpl(cause)\n        }\n    }\n\n    // ########################################\n    // # ConflatedBroadcastChannel Operations #\n    // ########################################\n\n    @Suppress(\"UNCHECKED_CAST\")\n    val value: E get() = lock.withLock {\n        // Is this channel closed for sending?\n        if (isClosedForSend) {\n            throw closeCause ?: IllegalStateException(\"This broadcast channel is closed\")\n        }\n        // Is there sent element?\n        if (lastConflatedElement === NO_ELEMENT) error(\"No value\")\n        // Return the last sent element.\n        lastConflatedElement as E\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    val valueOrNull: E? get() = lock.withLock {\n        // Is this channel closed for sending?\n        if (isClosedForReceive) null\n        // Is there sent element?\n        else if (lastConflatedElement === NO_ELEMENT) null\n        // Return the last sent element.\n        else lastConflatedElement as E\n    }\n\n    // #################\n    // # For Debugging #\n    // #################\n\n    override fun toString() =\n        (if (lastConflatedElement !== NO_ELEMENT) \"CONFLATED_ELEMENT=$lastConflatedElement; \" else \"\") +\n            \"BROADCAST=<${super.toString()}>; \" +\n            \"SUBSCRIBERS=${subscribers.joinToString(separator = \";\", prefix = \"<\", postfix = \">\")}\"\n}\n\nprivate val NO_ELEMENT = Symbol(\"NO_ELEMENT\")\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/BufferOverflow.kt",
        "content": "package kotlinx.coroutines.channels\n\n/**\n * A strategy for buffer overflow handling in [channels][Channel] and [flows][kotlinx.coroutines.flow.Flow] that\n * controls what is going to be sacrificed on buffer overflow:\n *\n * - [SUSPEND] &mdash; the upstream that is [sending][SendChannel.send] or\n *   is [emitting][kotlinx.coroutines.flow.FlowCollector.emit] a value is **suspended** while the buffer is full.\n * - [DROP_OLDEST] &mdash; drop **the oldest** value in the buffer on overflow, add the new value to the buffer, do not suspend.\n * - [DROP_LATEST] &mdash; drop **the latest** value that is being added to the buffer right now on buffer overflow\n *   (so that buffer contents stay the same), do not suspend.\n */\npublic enum class BufferOverflow {\n    /**\n     * Suspend on buffer overflow.\n     */\n    SUSPEND,\n\n    /**\n     * Drop **the oldest** value in the buffer on overflow, add the new value to the buffer, do not suspend.\n     */\n    DROP_OLDEST,\n\n    /**\n     * Drop **the latest** value that is being added to the buffer right now on buffer overflow\n     * (so that buffer contents stay the same), do not suspend.\n     */\n    DROP_LATEST\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/BufferedChannel.kt",
        "content": "@file:Suppress(\"PrivatePropertyName\")\n\npackage kotlinx.coroutines.channels\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.ChannelResult.Companion.closed\nimport kotlinx.coroutines.channels.ChannelResult.Companion.failure\nimport kotlinx.coroutines.channels.ChannelResult.Companion.success\nimport kotlinx.coroutines.flow.internal.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlinx.coroutines.selects.TrySelectDetailedResult.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.js.*\nimport kotlin.jvm.*\nimport kotlin.math.*\nimport kotlin.random.*\nimport kotlin.reflect.*\n\n/**\n * The buffered channel implementation, which also serves as a rendezvous channel when the capacity is zero.\n * The high-level structure bases on a conceptually infinite array for storing elements and waiting requests,\n * separate counters of [send] and [receive] invocations that were ever performed, and an additional counter\n * that indicates the end of the logical buffer by counting the number of array cells it ever contained.\n * The key idea is that both [send] and [receive] start by incrementing their counters, assigning the array cell\n * referenced by the counter. In case of rendezvous channels, the operation either suspends and stores its continuation\n * in the cell or makes a rendezvous with the opposite request. Each cell can be processed by exactly one [send] and\n * one [receive]. As for buffered channels, [send]-s can also add elements without suspension if the logical buffer\n * contains the cell, while the [receive] operation updates the end of the buffer when its synchronization finishes.\n *\n * Please see the [\"Fast and Scalable Channels in Kotlin Coroutines\"](https://arxiv.org/abs/2211.04986)\n * paper by Nikita Koval, Roman Elizarov, and Dan Alistarh for the detailed algorithm description.\n */\ninternal open class BufferedChannel<E>(\n    /**\n     * Channel capacity; `Channel.RENDEZVOUS` for rendezvous channel\n     * and `Channel.UNLIMITED` for unlimited capacity.\n     */\n    private val capacity: Int,\n    @JvmField\n    internal val onUndeliveredElement: OnUndeliveredElement<E>? = null\n) : Channel<E> {\n    init {\n        require(capacity >= 0) { \"Invalid channel capacity: $capacity, should be >=0\" }\n        // This implementation has second `init`.\n    }\n\n    // Maintenance note: use `Buffered1ChannelLincheckTest` to check hypotheses.\n\n    /*\n      The counters indicate the total numbers of send, receive, and buffer expansion calls\n      ever performed. The counters are incremented in the beginning of the corresponding\n      operation; thus, acquiring a unique (for the operation type) cell to process.\n      The segments reference to the last working one for each operation type.\n\n      Notably, the counter for send is combined with the channel closing status\n      for synchronization simplicity and performance reasons.\n\n      The logical end of the buffer is initialized with the channel capacity.\n      If the channel is rendezvous or unlimited, the counter equals `BUFFER_END_RENDEZVOUS`\n      or `BUFFER_END_RENDEZVOUS`, respectively, and never updates. The `bufferEndSegment`\n      point to a special `NULL_SEGMENT` in this case.\n     */\n    private val sendersAndCloseStatus = atomic(0L)\n    private val receivers = atomic(0L)\n    private val bufferEnd = atomic(initialBufferEnd(capacity))\n\n    internal val sendersCounter: Long get() = sendersAndCloseStatus.value.sendersCounter\n    internal val receiversCounter: Long get() = receivers.value\n    private val bufferEndCounter: Long get() = bufferEnd.value\n\n    /*\n      Additionally to the counters above, we need an extra one that\n      tracks the number of cells processed by `expandBuffer()`.\n      When a receiver aborts, the corresponding cell might be\n      physically removed from the data structure to avoid memory\n      leaks, while it still can be unprocessed by `expandBuffer()`.\n      In this case, `expandBuffer()` cannot know whether the\n      removed cell contained sender or receiver and, therefore,\n      cannot proceed. To solve the race, we ensure that cells\n      correspond to cancelled receivers cannot be physically\n      removed until the cell is processed.\n      This additional counter enables the synchronization,\n     */\n    private val completedExpandBuffersAndPauseFlag = atomic(bufferEndCounter)\n\n    private val isRendezvousOrUnlimited\n        get() = bufferEndCounter.let { it == BUFFER_END_RENDEZVOUS || it == BUFFER_END_UNLIMITED }\n\n    private val sendSegment: AtomicRef<ChannelSegment<E>>\n    private val receiveSegment: AtomicRef<ChannelSegment<E>>\n    private val bufferEndSegment: AtomicRef<ChannelSegment<E>>\n\n    init {\n        @Suppress(\"LeakingThis\")\n        val firstSegment = ChannelSegment(id = 0, prev = null, channel = this, pointers = 3)\n        sendSegment = atomic(firstSegment)\n        receiveSegment = atomic(firstSegment)\n        // If this channel is rendezvous or has unlimited capacity, the algorithm never\n        // invokes the buffer expansion procedure, and the corresponding segment reference\n        // points to a special `NULL_SEGMENT` one and never updates.\n        @Suppress(\"UNCHECKED_CAST\")\n        bufferEndSegment = atomic(if (isRendezvousOrUnlimited) (NULL_SEGMENT as ChannelSegment<E>) else firstSegment)\n    }\n\n    // #########################\n    // ## The send operations ##\n    // #########################\n\n    override suspend fun send(element: E): Unit =\n        sendImpl( // <-- this is an inline function\n            element = element,\n            // Do not create a continuation until it is required;\n            // it is created later via [onNoWaiterSuspend], if needed.\n            waiter = null,\n            // Finish immediately if a rendezvous happens\n            // or the element has been buffered.\n            onRendezvousOrBuffered = {},\n            // As no waiter is provided, suspension is impossible.\n            onSuspend = { _, _ -> assert { false } },\n            // According to the `send(e)` contract, we need to call\n            // `onUndeliveredElement(..)` handler and throw an exception\n            // if the channel is already closed.\n            onClosed = { onClosedSend(element) },\n            // When `send(e)` decides to suspend, the corresponding\n            // `onNoWaiterSuspend` function that creates a continuation\n            // is called. The tail-call optimization is applied here.\n            onNoWaiterSuspend = { segm, i, elem, s -> sendOnNoWaiterSuspend(segm, i, elem, s) }\n        )\n\n    // NB: return type could've been Nothing, but it breaks TCO\n    private suspend fun onClosedSend(element: E): Unit = suspendCancellableCoroutine { continuation ->\n        onUndeliveredElement?.callUndeliveredElementCatchingException(element)?.let {\n            // If it crashes, add send exception as suppressed for better diagnostics\n            it.addSuppressed(sendException)\n            continuation.resumeWithStackTrace(it)\n            return@suspendCancellableCoroutine\n        }\n        continuation.resumeWithStackTrace(sendException)\n    }\n\n    private suspend fun sendOnNoWaiterSuspend(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /** The element to be inserted. */\n        element: E,\n        /** The global index of the cell. */\n        s: Long\n    ) = suspendCancellableCoroutineReusable sc@{ cont ->\n        sendImplOnNoWaiter( // <-- this is an inline function\n            segment = segment, index = index, element = element, s = s,\n            // Store the created continuation as a waiter.\n            waiter = cont,\n            // If a rendezvous happens or the element has been buffered,\n            // resume the continuation and finish. In case of prompt\n            // cancellation, it is guaranteed that the element\n            // has been already buffered or passed to receiver.\n            onRendezvousOrBuffered = { cont.resume(Unit) },\n            // If the channel is closed, call `onUndeliveredElement(..)` and complete the\n            // continuation with the corresponding exception.\n            onClosed = { onClosedSendOnNoWaiterSuspend(element, cont) },\n        )\n    }\n\n    private fun Waiter.prepareSenderForSuspension(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int\n    ) {\n        // To distinguish cancelled senders and receivers,\n        // senders equip the index value with an additional marker,\n        // adding `SEGMENT_SIZE` to the value.\n        invokeOnCancellation(segment, index + SEGMENT_SIZE)\n    }\n\n    private fun onClosedSendOnNoWaiterSuspend(element: E, cont: CancellableContinuation<Unit>) {\n        onUndeliveredElement?.callUndeliveredElement(element, cont.context)\n        cont.resumeWithException(recoverStackTrace(sendException, cont))\n    }\n\n    override fun trySend(element: E): ChannelResult<Unit> {\n        // Do not try to send the element if the plain `send(e)` operation would suspend.\n        if (shouldSendSuspend(sendersAndCloseStatus.value)) return failure()\n        // This channel either has waiting receivers or is closed.\n        // Let's try to send the element!\n        // The logic is similar to the plain `send(e)` operation, with\n        // the only difference that we install `INTERRUPTED_SEND` in case\n        // the operation decides to suspend.\n        return sendImpl( // <-- this is an inline function\n            element = element,\n            // Store an already interrupted sender in case of suspension.\n            waiter = INTERRUPTED_SEND,\n            // Finish successfully when a rendezvous happens\n            // or the element has been buffered.\n            onRendezvousOrBuffered = { success(Unit) },\n            // On suspension, the `INTERRUPTED_SEND` token has been installed,\n            // and this `trySend(e)` must fail. According to the contract,\n            // we do not need to call the [onUndeliveredElement] handler.\n            onSuspend = { segm, _ ->\n                segm.onSlotCleaned()\n                failure()\n            },\n            // If the channel is closed, return the corresponding result.\n            onClosed = { closed(sendException) }\n        )\n    }\n\n    /**\n     * This is a special `send(e)` implementation that returns `true` if the element\n     * has been successfully sent, and `false` if the channel is closed.\n     *\n     * In case of coroutine cancellation, the element may be undelivered --\n     * the [onUndeliveredElement] feature is unsupported in this implementation.\n     *\n     */\n    internal open suspend fun sendBroadcast(element: E): Boolean = suspendCancellableCoroutine { cont ->\n        check(onUndeliveredElement == null) {\n            \"the `onUndeliveredElement` feature is unsupported for `sendBroadcast(e)`\"\n        }\n        sendImpl(\n            element = element,\n            waiter = SendBroadcast(cont),\n            onRendezvousOrBuffered = { cont.resume(true) },\n            onSuspend = { _, _ -> },\n            onClosed = { cont.resume(false) }\n        )\n    }\n\n    /**\n     * Specifies waiting [sendBroadcast] operation.\n     */\n    private class SendBroadcast(\n        val cont: CancellableContinuation<Boolean>\n    ) : Waiter by cont as CancellableContinuationImpl<Boolean>\n\n    /**\n     * Abstract send implementation.\n     */\n    private inline fun <R> sendImpl(\n        /* The element to be sent. */\n        element: E,\n        /* The waiter to be stored in case of suspension,\n        or `null` if the waiter is not created yet.\n        In the latter case, when the algorithm decides\n        to suspend, [onNoWaiterSuspend] is called. */\n        waiter: Any?,\n        /* This lambda is invoked when the element has been\n        buffered or a rendezvous with a receiver happens. */\n        onRendezvousOrBuffered: () -> R,\n        /* This lambda is called when the operation suspends in the\n        cell specified by the segment and the index in it. */\n        onSuspend: (segm: ChannelSegment<E>, i: Int) -> R,\n        /* This lambda is called when the channel\n        is observed in the closed state. */\n        onClosed: () -> R,\n        /* This lambda is called when the operation decides\n        to suspend, but the waiter is not provided (equals `null`).\n        It should create a waiter and delegate to `sendImplOnNoWaiter`. */\n        onNoWaiterSuspend: (\n            segm: ChannelSegment<E>,\n            i: Int,\n            element: E,\n            s: Long\n        ) -> R = { _, _, _, _ -> error(\"unexpected\") }\n    ): R {\n        // Read the segment reference before the counter increment;\n        // it is crucial to be able to find the required segment later.\n        var segment = sendSegment.value\n        while (true) {\n            // Atomically increment the `senders` counter and obtain the\n            // value right before the increment along with the close status.\n            val sendersAndCloseStatusCur = sendersAndCloseStatus.getAndIncrement()\n            val s = sendersAndCloseStatusCur.sendersCounter\n            // Is this channel already closed? Keep the information.\n            val closed = sendersAndCloseStatusCur.isClosedForSend0\n            // Count the required segment id and the cell index in it.\n            val id = s / SEGMENT_SIZE\n            val i = (s % SEGMENT_SIZE).toInt()\n            // Try to find the required segment if the initially obtained\n            // one (in the beginning of this function) has lower id.\n            if (segment.id != id) {\n                // Find the required segment.\n                segment = findSegmentSend(id, segment) ?:\n                    // The required segment has not been found.\n                    // Finish immediately if this channel is closed,\n                    // restarting the operation otherwise.\n                    // In the latter case, the required segment was full\n                    // of interrupted waiters and, therefore, removed\n                    // physically to avoid memory leaks.\n                    if (closed) {\n                        return onClosed()\n                    } else {\n                        continue\n                    }\n            }\n            // Update the cell according to the algorithm. Importantly, when\n            // the channel is already closed, storing a waiter is illegal, so\n            // the algorithm stores the `INTERRUPTED_SEND` token in this case.\n            when (updateCellSend(segment, i, element, s, waiter, closed)) {\n                RESULT_RENDEZVOUS -> {\n                    // A rendezvous with a receiver has happened.\n                    // The previous segments are no longer needed\n                    // for the upcoming requests, so the algorithm\n                    // resets the link to the previous segment.\n                    segment.cleanPrev()\n                    return onRendezvousOrBuffered()\n                }\n                RESULT_BUFFERED -> {\n                    // The element has been buffered.\n                    return onRendezvousOrBuffered()\n                }\n                RESULT_SUSPEND -> {\n                    // The operation has decided to suspend and installed the\n                    // specified waiter. If the channel was already closed,\n                    // and the `INTERRUPTED_SEND` token has been installed as a waiter,\n                    // this request finishes with the `onClosed()` action.\n                    if (closed) {\n                        segment.onSlotCleaned()\n                        return onClosed()\n                    }\n                    (waiter as? Waiter)?.prepareSenderForSuspension(segment, i)\n                    return onSuspend(segment, i)\n                }\n                RESULT_CLOSED -> {\n                    // This channel is closed.\n                    // In case this segment is already or going to be\n                    // processed by a receiver, ensure that all the\n                    // previous segments are unreachable.\n                    if (s < receiversCounter) segment.cleanPrev()\n                    return onClosed()\n                }\n                RESULT_FAILED -> {\n                    // Either the cell stores an interrupted receiver,\n                    // or it was poisoned by a concurrent receiver.\n                    // In both cases, all the previous segments are already processed,\n                    segment.cleanPrev()\n                    continue\n                }\n                RESULT_SUSPEND_NO_WAITER -> {\n                    // The operation has decided to suspend,\n                    // but no waiter has been provided.\n                    return onNoWaiterSuspend(segment, i, element, s)\n                }\n            }\n        }\n    }\n\n    // Note: this function is temporarily moved from ConflatedBufferedChannel to BufferedChannel class, because of this issue: KT-65554. \n    // For now, an inline function, which invokes atomic operations, may only be called within a parent class.\n    protected fun trySendDropOldest(element: E): ChannelResult<Unit> =\n        sendImpl( // <-- this is an inline function\n            element = element,\n            // Put the element into the logical buffer even\n            // if this channel is already full, the `onSuspend`\n            // callback below extract the first (oldest) element.\n            waiter = BUFFERED,\n            // Finish successfully when a rendezvous has happened\n            // or the element has been buffered.\n            onRendezvousOrBuffered = { return success(Unit) },\n            // In case the algorithm decided to suspend, the element\n            // was added to the buffer. However, as the buffer is now\n            // overflowed, the first (oldest) element has to be extracted.\n            onSuspend = { segm, i ->\n                dropFirstElementUntilTheSpecifiedCellIsInTheBuffer(segm.id * SEGMENT_SIZE + i)\n                return success(Unit)\n            },\n            // If the channel is closed, return the corresponding result.\n            onClosed = { return closed(sendException) }\n        )\n\n    private inline fun sendImplOnNoWaiter(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /* The element to be sent. */\n        element: E,\n        /* The global index of the cell. */\n        s: Long,\n        /* The waiter to be stored in case of suspension. */\n        waiter: Waiter,\n        /* This lambda is invoked when the element has been\n        buffered or a rendezvous with a receiver happens.*/\n        onRendezvousOrBuffered: () -> Unit,\n        /* This lambda is called when the channel\n        is observed in the closed state. */\n        onClosed: () -> Unit,\n    ) {\n        // Update the cell again, now with the non-null waiter,\n        // restarting the operation from the beginning on failure.\n        // Check the `sendImpl(..)` function for the comments.\n        when (updateCellSend(segment, index, element, s, waiter, false)) {\n            RESULT_RENDEZVOUS -> {\n                segment.cleanPrev()\n                onRendezvousOrBuffered()\n            }\n            RESULT_BUFFERED -> {\n                onRendezvousOrBuffered()\n            }\n            RESULT_SUSPEND -> {\n                waiter.prepareSenderForSuspension(segment, index)\n            }\n            RESULT_CLOSED -> {\n                if (s < receiversCounter) segment.cleanPrev()\n                onClosed()\n            }\n            RESULT_FAILED -> {\n                segment.cleanPrev()\n                sendImpl(\n                    element = element,\n                    waiter = waiter,\n                    onRendezvousOrBuffered = onRendezvousOrBuffered,\n                    onSuspend = { _, _ -> },\n                    onClosed = onClosed,\n                )\n            }\n            else -> error(\"unexpected\")\n        }\n    }\n\n    private fun updateCellSend(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /* The element to be sent. */\n        element: E,\n        /* The global index of the cell. */\n        s: Long,\n        /* The waiter to be stored in case of suspension. */\n        waiter: Any?,\n        closed: Boolean\n    ): Int {\n        // This is a fast-path of `updateCellSendSlow(..)`.\n        //\n        // First, the algorithm stores the element,\n        // performing the synchronization after that.\n        // This way, receivers safely retrieve the\n        // element, following the safe publication pattern.\n        segment.storeElement(index, element)\n        if (closed) return updateCellSendSlow(segment, index, element, s, waiter, closed)\n        // Read the current cell state.\n        val state = segment.getState(index)\n        when {\n            // The cell is empty.\n            state === null -> {\n                // If the element should be buffered, or a rendezvous should happen\n                // while the receiver is still coming, try to buffer the element.\n                // Otherwise, try to store the specified waiter in the cell.\n                if (bufferOrRendezvousSend(s)) {\n                    // Move the cell state to `BUFFERED`.\n                    if (segment.casState(index, null, BUFFERED)) {\n                        // The element has been successfully buffered, finish.\n                        return RESULT_BUFFERED\n                    }\n                } else {\n                    // This `send(e)` operation should suspend.\n                    // However, in case the channel has already\n                    // been observed closed, `INTERRUPTED_SEND`\n                    // is installed instead.\n                    if (waiter == null) {\n                        // The waiter is not specified; return the corresponding result.\n                        return RESULT_SUSPEND_NO_WAITER\n                    } else {\n                        // Try to install the waiter.\n                        if (segment.casState(index, null, waiter)) return RESULT_SUSPEND\n                    }\n                }\n            }\n            // A waiting receiver is stored in the cell.\n            state is Waiter -> {\n                // As the element will be passed directly to the waiter,\n                // the algorithm cleans the element slot in the cell.\n                segment.cleanElement(index)\n                // Try to make a rendezvous with the suspended receiver.\n                return if (state.tryResumeReceiver(element)) {\n                    // Rendezvous! Move the cell state to `DONE_RCV` and finish.\n                    segment.setState(index, DONE_RCV)\n                    onReceiveDequeued()\n                    RESULT_RENDEZVOUS\n                } else {\n                    // The resumption has failed. Update the cell state correspondingly\n                    // and clean the element field. It is also possible for a concurrent\n                    // cancellation handler to update the cell state; we can safely\n                    // ignore these updates.\n                    if (segment.getAndSetState(index, INTERRUPTED_RCV) !== INTERRUPTED_RCV) {\n                        segment.onCancelledRequest(index, true)\n                    }\n                    RESULT_FAILED\n                }\n            }\n        }\n        return updateCellSendSlow(segment, index, element, s, waiter, closed)\n    }\n\n    /**\n     * Updates the working cell of an abstract send operation.\n     */\n    private fun updateCellSendSlow(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /* The element to be sent. */\n        element: E,\n        /* The global index of the cell. */\n        s: Long,\n        /* The waiter to be stored in case of suspension. */\n        waiter: Any?,\n        closed: Boolean\n    ): Int {\n        // Then, the cell state should be updated according to\n        // its state machine; see the paper mentioned in the very\n        // beginning for the cell life-cycle and the algorithm details.\n        while (true) {\n            // Read the current cell state.\n            val state = segment.getState(index)\n            when {\n                // The cell is empty.\n                state === null -> {\n                    // If the element should be buffered, or a rendezvous should happen\n                    // while the receiver is still coming, try to buffer the element.\n                    // Otherwise, try to store the specified waiter in the cell.\n                    if (bufferOrRendezvousSend(s) && !closed) {\n                        // Move the cell state to `BUFFERED`.\n                        if (segment.casState(index, null, BUFFERED)) {\n                            // The element has been successfully buffered, finish.\n                            return RESULT_BUFFERED\n                        }\n                    } else {\n                        // This `send(e)` operation should suspend.\n                        // However, in case the channel has already\n                        // been observed closed, `INTERRUPTED_SEND`\n                        // is installed instead.\n                        when {\n                            // The channel is closed\n                            closed -> if (segment.casState(index, null, INTERRUPTED_SEND)) {\n                                segment.onCancelledRequest(index, false)\n                                return RESULT_CLOSED\n                            }\n                            // The waiter is not specified; return the corresponding result.\n                            waiter == null -> return RESULT_SUSPEND_NO_WAITER\n                            // Try to install the waiter.\n                            else -> if (segment.casState(index, null, waiter)) return RESULT_SUSPEND\n                        }\n                    }\n                }\n                // This cell is in the logical buffer.\n                state === IN_BUFFER -> {\n                    // Try to buffer the element.\n                    if (segment.casState(index, state, BUFFERED)) {\n                        // The element has been successfully buffered, finish.\n                        return RESULT_BUFFERED\n                    }\n                }\n                // The cell stores a cancelled receiver.\n                state === INTERRUPTED_RCV -> {\n                    // Clean the element slot to avoid memory leaks and finish.\n                    segment.cleanElement(index)\n                    return RESULT_FAILED\n                }\n                // The cell is poisoned by a concurrent receive.\n                state === POISONED -> {\n                    // Clean the element slot to avoid memory leaks and finish.\n                    segment.cleanElement(index)\n                    return RESULT_FAILED\n                }\n                // The channel is already closed.\n                state === CHANNEL_CLOSED -> {\n                    // Clean the element slot to avoid memory leaks,\n                    // ensure that the closing/cancellation procedure\n                    // has been completed, and finish.\n                    segment.cleanElement(index)\n                    completeCloseOrCancel()\n                    return RESULT_CLOSED\n                }\n                // A waiting receiver is stored in the cell.\n                else -> {\n                    assert { state is Waiter || state is WaiterEB }\n                    // As the element will be passed directly to the waiter,\n                    // the algorithm cleans the element slot in the cell.\n                    segment.cleanElement(index)\n                    // Unwrap the waiting receiver from `WaiterEB` if needed.\n                    // As a receiver is stored in the cell, the buffer expansion\n                    // procedure would finish, so senders simply ignore the \"EB\" marker.\n                    val receiver = if (state is WaiterEB) state.waiter else state\n                    // Try to make a rendezvous with the suspended receiver.\n                    return if (receiver.tryResumeReceiver(element)) {\n                        // Rendezvous! Move the cell state to `DONE_RCV` and finish.\n                        segment.setState(index, DONE_RCV)\n                        onReceiveDequeued()\n                        RESULT_RENDEZVOUS\n                    } else {\n                        // The resumption has failed. Update the cell state correspondingly\n                        // and clean the element field. It is also possible for a concurrent\n                        // `expandBuffer()` or the cancellation handler to update the cell state;\n                        // we can safely ignore these updates as senders do not help `expandBuffer()`.\n                        if (segment.getAndSetState(index, INTERRUPTED_RCV) !== INTERRUPTED_RCV) {\n                            segment.onCancelledRequest(index, true)\n                        }\n                        RESULT_FAILED\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks whether a [send] invocation is bound to suspend if it is called\n     * with the specified [sendersAndCloseStatus], [receivers], and [bufferEnd]\n     * values. When this channel is already closed, the function returns `false`.\n     *\n     * Specifically, [send] suspends if the channel is not unlimited,\n     * the number of receivers is greater than then index of the working cell of the\n     * potential [send] invocation, and the buffer does not cover this cell\n     * in case of buffered channel.\n     * When the channel is already closed, [send] does not suspend.\n     */\n    @JsName(\"shouldSendSuspend0\")\n    private fun shouldSendSuspend(curSendersAndCloseStatus: Long): Boolean {\n        // Does not suspend if the channel is already closed.\n        if (curSendersAndCloseStatus.isClosedForSend0) return false\n        // Does not suspend if a rendezvous may happen or the buffer is not full.\n        return !bufferOrRendezvousSend(curSendersAndCloseStatus.sendersCounter)\n    }\n\n    /**\n     * Returns `true` when the specified [send] should place\n     * its element to the working cell without suspension.\n     */\n    private fun bufferOrRendezvousSend(curSenders: Long): Boolean =\n        curSenders < bufferEndCounter || curSenders < receiversCounter + capacity\n\n    /**\n     * Checks whether a [send] invocation is bound to suspend if it is called\n     * with the current counter and close status values. See [shouldSendSuspend] for details.\n     *\n     * Note that this implementation is _false positive_ in case of rendezvous channels,\n     * so it can return `false` when a [send] invocation is bound to suspend. Specifically,\n     * the counter of `receive()` operations may indicate that there is a waiting receiver,\n     * while it has already been cancelled, so the potential rendezvous is bound to fail.\n     */\n    internal open fun shouldSendSuspend(): Boolean = shouldSendSuspend(sendersAndCloseStatus.value)\n\n    /**\n     * Tries to resume this receiver with the specified [element] as a result.\n     * Returns `true` on success and `false` otherwise.\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun Any.tryResumeReceiver(element: E): Boolean = when(this) {\n        is SelectInstance<*> -> { // `onReceiveXXX` select clause\n            trySelect(this@BufferedChannel, element)\n        }\n        is ReceiveCatching<*> -> {\n            this as ReceiveCatching<E>\n            cont.tryResume0(success(element), onUndeliveredElement?.bindCancellationFun(element, cont.context))\n        }\n        is BufferedChannel<*>.BufferedChannelIterator -> {\n            this as BufferedChannel<E>.BufferedChannelIterator\n            tryResumeHasNext(element)\n        }\n        is CancellableContinuation<*> -> { // `receive()`\n            this as CancellableContinuation<E>\n            tryResume0(element, onUndeliveredElement?.bindCancellationFun(element, context))\n        }\n        else -> error(\"Unexpected receiver type: $this\")\n    }\n\n    // ##########################\n    // # The receive operations #\n    // ##########################\n\n    /**\n     * This function is invoked when a receiver is added as a waiter in this channel.\n     */\n    protected open fun onReceiveEnqueued() {}\n\n    /**\n     * This function is invoked when a waiting receiver is no longer stored in this channel;\n     * independently on whether it is caused by rendezvous, cancellation, or channel closing.\n     */\n    protected open fun onReceiveDequeued() {}\n\n    override suspend fun receive(): E =\n        receiveImpl( // <-- this is an inline function\n            // Do not create a continuation until it is required;\n            // it is created later via [onNoWaiterSuspend], if needed.\n            waiter = null,\n            // Return the received element on successful retrieval from\n            // the buffer or rendezvous with a suspended sender.\n            // Also, inform `BufferedChannel` extensions that\n            // synchronization of this receive operation is completed.\n            onElementRetrieved = { element ->\n                return element\n            },\n            // As no waiter is provided, suspension is impossible.\n            onSuspend = { _, _, _ -> error(\"unexpected\") },\n            // Throw an exception if the channel is already closed.\n            onClosed = { throw recoverStackTrace(receiveException) },\n            // If `receive()` decides to suspend, the corresponding\n            // `suspend` function that creates a continuation is called.\n            // The tail-call optimization is applied here.\n            onNoWaiterSuspend = { segm, i, r -> receiveOnNoWaiterSuspend(segm, i, r) }\n        )\n\n    private suspend fun receiveOnNoWaiterSuspend(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /* The global index of the cell. */\n        r: Long\n    ) = suspendCancellableCoroutineReusable { cont ->\n        receiveImplOnNoWaiter( // <-- this is an inline function\n            segment = segment, index = index, r = r,\n            // Store the created continuation as a waiter.\n            waiter = cont,\n            // In case of successful element retrieval, resume\n            // the continuation with the element and inform the\n            // `BufferedChannel` extensions that the synchronization\n            // is completed. Importantly, the receiver coroutine\n            // may be cancelled after it is successfully resumed but\n            // not dispatched yet. In case `onUndeliveredElement` is\n            // specified, we need to invoke it in the latter case.\n            onElementRetrieved = { element ->\n                val onCancellation = onUndeliveredElement?.bindCancellationFun(element, cont.context)\n                cont.resume(element, onCancellation)\n            },\n            onClosed = { onClosedReceiveOnNoWaiterSuspend(cont) },\n        )\n    }\n\n    private fun Waiter.prepareReceiverForSuspension(segment: ChannelSegment<E>, index: Int) {\n        onReceiveEnqueued()\n        invokeOnCancellation(segment, index)\n    }\n\n    private fun onClosedReceiveOnNoWaiterSuspend(cont: CancellableContinuation<E>) {\n        cont.resumeWithException(receiveException)\n    }\n\n    /*\n    The implementation is exactly the same as of `receive()`,\n    with the only difference that this function returns a `ChannelResult`\n    instance and does not throw exception explicitly in case the channel\n    is already closed for receiving. Please refer the plain `receive()`\n    implementation for the comments.\n    */\n    override suspend fun receiveCatching(): ChannelResult<E> =\n        receiveImpl( // <-- this is an inline function\n            waiter = null,\n            onElementRetrieved = { element ->\n                success(element)\n            },\n            onSuspend = { _, _, _ -> error(\"unexpected\") },\n            onClosed = { closed(closeCause) },\n            onNoWaiterSuspend = { segm, i, r -> receiveCatchingOnNoWaiterSuspend(segm, i, r) }\n        )\n\n    private suspend fun receiveCatchingOnNoWaiterSuspend(\n        segment: ChannelSegment<E>,\n        index: Int,\n        r: Long\n    ) = suspendCancellableCoroutineReusable { cont ->\n        val waiter = ReceiveCatching(cont as CancellableContinuationImpl<ChannelResult<E>>)\n        receiveImplOnNoWaiter(\n            segment, index, r,\n            waiter = waiter,\n            onElementRetrieved = { element ->\n                cont.resume(success(element), onUndeliveredElement?.bindCancellationFun(element, cont.context))\n            },\n            onClosed = { onClosedReceiveCatchingOnNoWaiterSuspend(cont) }\n        )\n    }\n\n    private fun onClosedReceiveCatchingOnNoWaiterSuspend(cont: CancellableContinuation<ChannelResult<E>>) {\n        cont.resume(closed(closeCause))\n    }\n\n    override fun tryReceive(): ChannelResult<E> {\n        // Read the `receivers` counter first.\n        val r = receivers.value\n        val sendersAndCloseStatusCur = sendersAndCloseStatus.value\n        // Is this channel closed for receive?\n        if (sendersAndCloseStatusCur.isClosedForReceive0) {\n            return closed(closeCause)\n        }\n        // Do not try to receive an element if the plain `receive()` operation would suspend.\n        val s = sendersAndCloseStatusCur.sendersCounter\n        if (r >= s) return failure()\n        // Let's try to retrieve an element!\n        // The logic is similar to the plain `receive()` operation, with\n        // the only difference that we store `INTERRUPTED_RCV` in case\n        // the operation decides to suspend. This way, we can leverage\n        // the unconditional `Fetch-and-Add` instruction.\n        // One may consider storing `INTERRUPTED_RCV` instead of an actual waiter\n        // on suspension (a.k.a. \"no elements to retrieve\") as a short-cut of\n        // \"suspending and cancelling immediately\".\n        return receiveImpl( // <-- this is an inline function\n            // Store an already interrupted receiver in case of suspension.\n            waiter = INTERRUPTED_RCV,\n            // Finish when an element is successfully retrieved.\n            onElementRetrieved = { element -> success(element) },\n            // On suspension, the `INTERRUPTED_RCV` token has been\n            // installed, and this `tryReceive()` must fail.\n            onSuspend = { segm, _, globalIndex ->\n                // Emulate \"cancelled\" receive, thus invoking 'waitExpandBufferCompletion' manually,\n                // because effectively there were no cancellation\n                waitExpandBufferCompletion(globalIndex)\n                segm.onSlotCleaned()\n                failure()\n            },\n            // If the channel is closed, return the corresponding result.\n            onClosed = { closed(closeCause) }\n        )\n    }\n\n    /**\n     * Extracts the first element from this channel until the cell with the specified\n     * index is moved to the logical buffer. This is a key procedure for the _conflated_\n     * channel implementation, see [ConflatedBufferedChannel] with the [BufferOverflow.DROP_OLDEST]\n     * strategy on buffer overflowing.\n     */\n    protected fun dropFirstElementUntilTheSpecifiedCellIsInTheBuffer(globalCellIndex: Long) {\n        assert { isConflatedDropOldest }\n        // Read the segment reference before the counter increment;\n        // it is crucial to be able to find the required segment later.\n        var segment = receiveSegment.value\n        while (true) {\n            // Read the receivers counter to check whether the specified cell is already in the buffer\n            // or should be moved to the buffer in a short time, due to the already started `receive()`.\n            val r = this.receivers.value\n            if (globalCellIndex < max(r + capacity, bufferEndCounter)) return\n            // The cell is outside the buffer. Try to extract the first element\n            // if the `receivers` counter has not been changed.\n            if (!this.receivers.compareAndSet(r, r + 1)) continue\n            // Count the required segment id and the cell index in it.\n            val id = r / SEGMENT_SIZE\n            val i = (r % SEGMENT_SIZE).toInt()\n            // Try to find the required segment if the initially obtained\n            // segment (in the beginning of this function) has lower id.\n            if (segment.id != id) {\n                // Find the required segment, restarting the operation if it has not been found.\n                segment = findSegmentReceive(id, segment) ?:\n                    // The required segment has not been found. It is possible that the channel is already\n                    // closed for receiving, so the linked list of segments is closed as well.\n                    // In the latter case, the operation will finish eventually after incrementing\n                    // the `receivers` counter sufficient times. Note that it is impossible to check\n                    // whether this channel is closed for receiving (we do this in `receive`),\n                    // as it may call this function when helping to complete closing the channel.\n                    continue\n            }\n            // Update the cell according to the cell life-cycle.\n            val updCellResult = updateCellReceive(segment, i, r, null)\n            when {\n                updCellResult === FAILED -> {\n                    // The cell is poisoned; restart from the beginning.\n                    // To avoid memory leaks, we also need to reset\n                    // the `prev` pointer of the working segment.\n                    if (r < sendersCounter) segment.cleanPrev()\n                }\n                else -> { // element\n                    // A buffered element was retrieved from the cell.\n                    // Clean the reference to the previous segment.\n                    segment.cleanPrev()\n                    @Suppress(\"UNCHECKED_CAST\")\n                    onUndeliveredElement?.callUndeliveredElementCatchingException(updCellResult as E)?.let { throw it }\n                }\n            }\n        }\n    }\n\n    /**\n     * Abstract receive implementation.\n     */\n    private inline fun <R> receiveImpl(\n        /* The waiter to be stored in case of suspension,\n        or `null` if the waiter is not created yet.\n        In the latter case, if the algorithm decides\n        to suspend, [onNoWaiterSuspend] is called. */\n        waiter: Any?,\n        /* This lambda is invoked when an element has been\n        successfully retrieved, either from the buffer or\n        by making a rendezvous with a suspended sender. */\n        onElementRetrieved: (element: E) -> R,\n        /* This lambda is called when the operation suspends in the cell\n        specified by the segment and its global and in-segment indices. */\n        onSuspend: (segm: ChannelSegment<E>, i: Int, r: Long) -> R,\n        /* This lambda is called when the channel is observed\n        in the closed state and no waiting sender is found,\n        which means that it is closed for receiving. */\n        onClosed: () -> R,\n        /* This lambda is called when the operation decides\n        to suspend, but the waiter is not provided (equals `null`).\n        It should create a waiter and delegate to `sendImplOnNoWaiter`. */\n        onNoWaiterSuspend: (\n            segm: ChannelSegment<E>,\n            i: Int,\n            r: Long\n        ) -> R = { _, _, _ -> error(\"unexpected\") }\n    ): R {\n        // Read the segment reference before the counter increment;\n        // it is crucial to be able to find the required segment later.\n        var segment = receiveSegment.value\n        while (true) {\n            // Similar to the `send(e)` operation, `receive()` first checks\n            // whether the channel is already closed for receiving.\n            if (isClosedForReceive) return onClosed()\n            // Atomically increments the `receivers` counter\n            // and obtain the value right before the increment.\n            val r = this.receivers.getAndIncrement()\n            // Count the required segment id and the cell index in it.\n            val id = r / SEGMENT_SIZE\n            val i = (r % SEGMENT_SIZE).toInt()\n            // Try to find the required segment if the initially obtained\n            // segment (in the beginning of this function) has lower id.\n            if (segment.id != id) {\n                // Find the required segment, restarting the operation if it has not been found.\n                segment = findSegmentReceive(id, segment) ?:\n                    // The required segment is not found. It is possible that the channel is already\n                    // closed for receiving, so the linked list of segments is closed as well.\n                    // In the latter case, the operation fails with the corresponding check at the beginning.\n                    continue\n            }\n            // Update the cell according to the cell life-cycle.\n            val updCellResult = updateCellReceive(segment, i, r, waiter)\n            return when {\n                updCellResult === SUSPEND -> {\n                    // The operation has decided to suspend and\n                    // stored the specified waiter in the cell.\n                    (waiter as? Waiter)?.prepareReceiverForSuspension(segment, i)\n                    onSuspend(segment, i, r)\n                }\n                updCellResult === FAILED -> {\n                    // The operation has tried to make a rendezvous\n                    // but failed: either the opposite request has\n                    // already been cancelled or the cell is poisoned.\n                    // Restart from the beginning in this case.\n                    // To avoid memory leaks, we also need to reset\n                    // the `prev` pointer of the working segment.\n                    if (r < sendersCounter) segment.cleanPrev()\n                    continue\n                }\n                updCellResult === SUSPEND_NO_WAITER -> {\n                    // The operation has decided to suspend,\n                    // but no waiter has been provided.\n                    onNoWaiterSuspend(segment, i, r)\n                }\n                else -> { // element\n                    // Either a buffered element was retrieved from the cell\n                    // or a rendezvous with a waiting sender has happened.\n                    // Clean the reference to the previous segment before finishing.\n                    segment.cleanPrev()\n                    @Suppress(\"UNCHECKED_CAST\")\n                    onElementRetrieved(updCellResult as E)\n                }\n            }\n        }\n    }\n\n    private inline fun receiveImplOnNoWaiter(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /* The global index of the cell. */\n        r: Long,\n        /* The waiter to be stored in case of suspension. */\n        waiter: Waiter,\n        /* This lambda is invoked when an element has been\n        successfully retrieved, either from the buffer or\n        by making a rendezvous with a suspended sender. */\n        onElementRetrieved: (element: E) -> Unit,\n        /* This lambda is called when the channel is observed\n        in the closed state and no waiting senders is found,\n        which means that it is closed for receiving. */\n        onClosed: () -> Unit\n    ) {\n        // Update the cell with the non-null waiter,\n        // restarting from the beginning on failure.\n        // Check the `receiveImpl(..)` function for the comments.\n        val updCellResult = updateCellReceive(segment, index, r, waiter)\n        when {\n            updCellResult === SUSPEND -> {\n                waiter.prepareReceiverForSuspension(segment, index)\n            }\n            updCellResult === FAILED -> {\n                if (r < sendersCounter) segment.cleanPrev()\n                receiveImpl(\n                    waiter = waiter,\n                    onElementRetrieved = onElementRetrieved,\n                    onSuspend = { _, _, _ -> },\n                    onClosed = onClosed\n                )\n            }\n            else -> {\n                segment.cleanPrev()\n                @Suppress(\"UNCHECKED_CAST\")\n                onElementRetrieved(updCellResult as E)\n            }\n        }\n    }\n\n    private fun updateCellReceive(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /* The global index of the cell. */\n        r: Long,\n        /* The waiter to be stored in case of suspension. */\n        waiter: Any?,\n    ): Any? {\n        // This is a fast-path of `updateCellReceiveSlow(..)`.\n        //\n        // Read the current cell state.\n        val state = segment.getState(index)\n        when {\n            // The cell is empty.\n            state === null -> {\n                // If a rendezvous must happen, the operation does not wait\n                // until the cell stores a buffered element or a suspended\n                // sender, poisoning the cell and restarting instead.\n                // Otherwise, try to store the specified waiter in the cell.\n                val senders = sendersAndCloseStatus.value.sendersCounter\n                if (r >= senders) {\n                    // This `receive()` operation should suspend.\n                    if (waiter === null) {\n                        // The waiter is not specified;\n                        // return the corresponding result.\n                        return SUSPEND_NO_WAITER\n                    }\n                    // Try to install the waiter.\n                    if (segment.casState(index, state, waiter)) {\n                        // The waiter has been successfully installed.\n                        // Invoke the `expandBuffer()` procedure and finish.\n                        expandBuffer()\n                        return SUSPEND\n                    }\n                }\n            }\n            // The cell stores a buffered element.\n            state === BUFFERED -> if (segment.casState(index, state, DONE_RCV)) {\n                // Retrieve the element and expand the buffer.\n                expandBuffer()\n                return segment.retrieveElement(index)\n            }\n        }\n        return updateCellReceiveSlow(segment, index, r, waiter)\n    }\n\n    private fun updateCellReceiveSlow(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /* The global index of the cell. */\n        r: Long,\n        /* The waiter to be stored in case of suspension. */\n        waiter: Any?,\n    ): Any? {\n        // The cell state should be updated according to  its state machine;\n        // see the paper mentioned in the very beginning for the algorithm details.\n        while (true) {\n            // Read the current cell state.\n            val state = segment.getState(index)\n            when {\n                // The cell is empty.\n                state === null || state === IN_BUFFER -> {\n                    // If a rendezvous must happen, the operation does not wait\n                    // until the cell stores a buffered element or a suspended\n                    // sender, poisoning the cell and restarting instead.\n                    // Otherwise, try to store the specified waiter in the cell.\n                    val senders = sendersAndCloseStatus.value.sendersCounter\n                    if (r < senders) {\n                        // The cell is already covered by sender,\n                        // so a rendezvous must happen. Unfortunately,\n                        // the cell is empty, so the operation poisons it.\n                        if (segment.casState(index, state, POISONED)) {\n                            // When the cell becomes poisoned, it is essentially\n                            // the same as storing an already cancelled receiver.\n                            // Thus, the `expandBuffer()` procedure should be invoked.\n                            expandBuffer()\n                            return FAILED\n                        }\n                    } else {\n                        // This `receive()` operation should suspend.\n                        if (waiter === null) {\n                            // The waiter is not specified;\n                            // return the corresponding result.\n                            return SUSPEND_NO_WAITER\n                        }\n                        // Try to install the waiter.\n                        if (segment.casState(index, state, waiter)) {\n                            // The waiter has been successfully installed.\n                            // Invoke the `expandBuffer()` procedure and finish.\n                            expandBuffer()\n                            return SUSPEND\n                        }\n                    }\n                }\n                // The cell stores a buffered element.\n                state === BUFFERED -> if (segment.casState(index, state, DONE_RCV)) {\n                    // Retrieve the element and expand the buffer.\n                    expandBuffer()\n                    return segment.retrieveElement(index)\n                }\n                // The cell stores an interrupted sender.\n                state === INTERRUPTED_SEND -> return FAILED\n                // The cell is already poisoned by a concurrent\n                // `hasElements` call. Restart in this case.\n                state === POISONED -> return FAILED\n                // This channel is already closed.\n                state === CHANNEL_CLOSED -> {\n                    // Although the channel is closed, it is still required\n                    // to call the `expandBuffer()` procedure to keep\n                    // `waitForExpandBufferCompletion()` correct.\n                    expandBuffer()\n                    return FAILED\n                }\n                // A concurrent `expandBuffer()` is resuming a\n                // suspended sender. Wait in a spin-loop until\n                // the resumption attempt completes: the cell\n                // state must change to either `BUFFERED` or\n                // `INTERRUPTED_SEND`.\n                state === RESUMING_BY_EB -> continue\n                // The cell stores a suspended sender; try to resume it.\n                else -> {\n                    // To synchronize with expandBuffer(), the algorithm\n                    // first moves the cell to an intermediate `S_RESUMING_BY_RCV`\n                    // state, updating it to either `BUFFERED` (on success) or\n                    // `INTERRUPTED_SEND` (on failure).\n                    if (segment.casState(index, state, RESUMING_BY_RCV)) {\n                        // Has a concurrent `expandBuffer()` delegated its completion?\n                        val helpExpandBuffer = state is WaiterEB\n                        // Extract the sender if needed and try to resume it.\n                        val sender = if (state is WaiterEB) state.waiter else state\n                        return if (sender.tryResumeSender(segment, index)) {\n                            // The sender has been resumed successfully!\n                            // Update the cell state correspondingly,\n                            // expand the buffer, and return the element\n                            // stored in the cell.\n                            // In case a concurrent `expandBuffer()` has delegated\n                            // its completion, the procedure should finish, as the\n                            // sender is resumed. Thus, no further action is required.\n                            segment.setState(index, DONE_RCV)\n                            expandBuffer()\n                            segment.retrieveElement(index)\n                        } else {\n                            // The resumption has failed. Update the cell correspondingly.\n                            // In case a concurrent `expandBuffer()` has delegated\n                            // its completion, the procedure should skip this cell, so\n                            // `expandBuffer()` should be called once again.\n                            segment.setState(index, INTERRUPTED_SEND)\n                            segment.onCancelledRequest(index, false)\n                            if (helpExpandBuffer) expandBuffer()\n                            FAILED\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private fun Any.tryResumeSender(segment: ChannelSegment<E>, index: Int): Boolean = when (this) {\n        is CancellableContinuation<*> -> { // suspended `send(e)` operation\n            @Suppress(\"UNCHECKED_CAST\")\n            this as CancellableContinuation<Unit>\n            tryResume0(Unit)\n        }\n        is SelectInstance<*> -> {\n            this as SelectImplementation<*>\n            val trySelectResult = trySelectDetailed(clauseObject = this@BufferedChannel, result = Unit)\n            // Clean the element slot to avoid memory leaks\n            // if this `select` clause should be re-registered.\n            if (trySelectResult === REREGISTER) segment.cleanElement(index)\n            // Was the resumption successful?\n            trySelectResult === SUCCESSFUL\n        }\n        is SendBroadcast -> cont.tryResume0(true) // // suspended `sendBroadcast(e)` operation\n        else -> error(\"Unexpected waiter: $this\")\n    }\n\n    // ################################\n    // # The expandBuffer() procedure #\n    // ################################\n\n    private fun expandBuffer() {\n        // Do not need to take any action if\n        // this channel is rendezvous or unlimited.\n        if (isRendezvousOrUnlimited) return\n        // Read the current segment of\n        // the `expandBuffer()` procedure.\n        var segment = bufferEndSegment.value\n        // Try to expand the buffer until succeed.\n        try_again@ while (true) {\n            // Increment the logical end of the buffer.\n            // The `b`-th cell is going to be added to the buffer.\n            val b = bufferEnd.getAndIncrement()\n            val id = b / SEGMENT_SIZE\n            // After that, read the current `senders` counter.\n            // In case its value is lower than `b`, the `send(e)`\n            // invocation that will work with this `b`-th cell\n            // will detect that the cell is already a part of the\n            // buffer when comparing with the `bufferEnd` counter.\n            // However, `bufferEndSegment` may reference an outdated\n            // segment, which should be updated to avoid memory leaks.\n            val s = sendersCounter\n            if (s <= b) {\n                // Should `bufferEndSegment` be moved forward to avoid memory leaks?\n                if (segment.id < id && segment.next != null)\n                    moveSegmentBufferEndToSpecifiedOrLast(id, segment)\n                // Increment the number of completed `expandBuffer()`-s and finish.\n                incCompletedExpandBufferAttempts()\n                return\n            }\n            // Is `bufferEndSegment` outdated or is the segment with the required id already removed?\n            // Find the required segment, creating new ones if needed.\n            if (segment.id != id) {\n                segment = findSegmentBufferEnd(id, segment, b)\n                    // Restart if the required segment is removed, or\n                    // the linked list of segments is already closed,\n                    // and the required one will never be created.\n                    // Please note that `findSegmentBuffer(..)` updates\n                    // the number of completed `expandBuffer()` attempt\n                    // in this case.\n                    ?: continue@try_again\n            }\n            // Try to add the cell to the logical buffer,\n            // updating the cell state according to the state-machine.\n            val i = (b % SEGMENT_SIZE).toInt()\n            if (updateCellExpandBuffer(segment, i, b)) {\n                // The cell has been added to the logical buffer!\n                // Increment the number of completed `expandBuffer()`-s and finish.\n                //\n                // Note that it is possible to increment the number of\n                // completed `expandBuffer()` attempts earlier, right\n                // after the segment is obtained. We find this change\n                // counter-intuitive and prefer to avoid it.\n                incCompletedExpandBufferAttempts()\n                return\n            } else {\n                // The cell has not been added to the buffer.\n                // Increment the number of completed `expandBuffer()`\n                // attempts and restart.\n                incCompletedExpandBufferAttempts()\n                continue@try_again\n            }\n        }\n    }\n\n    private fun updateCellExpandBuffer(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /* The global index of the cell. */\n        b: Long\n    ): Boolean {\n        // This is a fast-path of `updateCellExpandBufferSlow(..)`.\n        //\n        // Read the current cell state.\n        val state = segment.getState(index)\n        if (state is Waiter) {\n            // Usually, a sender is stored in the cell.\n            // However, it is possible for a concurrent\n            // receiver to be already suspended there.\n            // Try to distinguish whether the waiter is a\n            // sender by comparing the global cell index with\n            // the `receivers` counter. In case the cell is not\n            // covered by a receiver, a sender is stored in the cell.\n            if (b >= receivers.value) {\n                // The cell stores a suspended sender. Try to resume it.\n                // To synchronize with a concurrent `receive()`, the algorithm\n                // first moves the cell state to an intermediate `RESUMING_BY_EB`\n                // state, updating it to either `BUFFERED` (on successful resumption)\n                // or `INTERRUPTED_SEND` (on failure).\n                if (segment.casState(index, state, RESUMING_BY_EB)) {\n                    return if (state.tryResumeSender(segment, index)) {\n                        // The sender has been resumed successfully!\n                        // Move the cell to the logical buffer and finish.\n                        segment.setState(index, BUFFERED)\n                        true\n                    } else {\n                        // The resumption has failed.\n                        segment.setState(index, INTERRUPTED_SEND)\n                        segment.onCancelledRequest(index, false)\n                        false\n                    }\n                }\n            }\n        }\n        return updateCellExpandBufferSlow(segment, index, b)\n    }\n\n    private fun updateCellExpandBufferSlow(\n        /* The working cell is specified by\n        the segment and the index in it. */\n        segment: ChannelSegment<E>,\n        index: Int,\n        /* The global index of the cell. */\n        b: Long\n    ): Boolean {\n        // Update the cell state according to its state machine.\n        // See the paper mentioned in the very beginning for\n        // the cell life-cycle and the algorithm details.\n        while (true) {\n            // Read the current cell state.\n            val state = segment.getState(index)\n            when {\n                // A suspended waiter, sender or receiver.\n                state is Waiter -> {\n                    // Usually, a sender is stored in the cell.\n                    // However, it is possible for a concurrent\n                    // receiver to be already suspended there.\n                    // Try to distinguish whether the waiter is a\n                    // sender by comparing the global cell index with\n                    // the `receivers` counter. In case the cell is not\n                    // covered by a receiver, a sender is stored in the cell.\n                    if (b < receivers.value) {\n                        // The algorithm cannot distinguish whether the\n                        // suspended in the cell operation is sender or receiver.\n                        // To make progress, `expandBuffer()` delegates its completion\n                        // to an upcoming pairwise request, atomically wrapping\n                        // the waiter in `WaiterEB`. In case a sender is stored\n                        // in the cell, the upcoming receiver will call `expandBuffer()`\n                        // if the sender resumption fails; thus, effectively, skipping\n                        // this cell. Otherwise, if a receiver is stored in the cell,\n                        // this `expandBuffer()` procedure must finish; therefore,\n                        // sender ignore the `WaiterEB` wrapper.\n                        if (segment.casState(index, state, WaiterEB(waiter = state)))\n                            return true\n                    } else {\n                        // The cell stores a suspended sender. Try to resume it.\n                        // To synchronize with a concurrent `receive()`, the algorithm\n                        // first moves the cell state to an intermediate `RESUMING_BY_EB`\n                        // state, updating it to either `BUFFERED` (on successful resumption)\n                        // or `INTERRUPTED_SEND` (on failure).\n                        if (segment.casState(index, state, RESUMING_BY_EB)) {\n                            return if (state.tryResumeSender(segment, index)) {\n                                // The sender has been resumed successfully!\n                                // Move the cell to the logical buffer and finish.\n                                segment.setState(index, BUFFERED)\n                                true\n                            } else {\n                                // The resumption has failed.\n                                segment.setState(index, INTERRUPTED_SEND)\n                                segment.onCancelledRequest(index, false)\n                                false\n                            }\n                        }\n                    }\n                }\n                // The cell stores an interrupted sender, skip it.\n                state === INTERRUPTED_SEND -> return false\n                // The cell is empty, a concurrent sender is coming.\n                state === null -> {\n                    // To inform a concurrent sender that this cell is\n                    // already a part of the buffer, the algorithm moves\n                    // it to a special `IN_BUFFER` state.\n                    if (segment.casState(index, state, IN_BUFFER)) return true\n                }\n                // The cell is already a part of the buffer, finish.\n                state === BUFFERED -> return true\n                // The cell is already processed by a receiver, no further action is required.\n                state === POISONED || state === DONE_RCV || state === INTERRUPTED_RCV -> return true\n                // The channel is closed, all the following\n                // cells are already in the same state, finish.\n                state === CHANNEL_CLOSED -> return true\n                // A concurrent receiver is resuming the suspended sender.\n                // Wait in a spin-loop until it changes the cell state\n                // to either `DONE_RCV` or `INTERRUPTED_SEND`.\n                state === RESUMING_BY_RCV -> continue // spin wait\n                else -> error(\"Unexpected cell state: $state\")\n            }\n        }\n    }\n\n    /**\n     * Increments the counter of completed [expandBuffer] invocations.\n     * To guarantee starvation-freedom for [waitExpandBufferCompletion],\n     * which waits until the counters of started and completed [expandBuffer] calls\n     * coincide and become greater or equal to the specified value,\n     * [waitExpandBufferCompletion] may set a flag that pauses further progress.\n     */\n    private fun incCompletedExpandBufferAttempts(nAttempts: Long = 1) {\n        // Increment the number of completed `expandBuffer()` calls.\n        completedExpandBuffersAndPauseFlag.addAndGet(nAttempts).also {\n            // Should further `expandBuffer()`-s be paused?\n            // If so, this thread should wait in a spin-loop\n            // until the flag is unset.\n            if (it.ebPauseExpandBuffers) {\n                @Suppress(\"ControlFlowWithEmptyBody\")\n                while (completedExpandBuffersAndPauseFlag.value.ebPauseExpandBuffers) {}\n            }\n        }\n    }\n\n    /**\n     * Waits in a spin-loop until the [expandBuffer] call that\n     * should process the [globalIndex]-th cell is completed.\n     * Essentially, it waits until the numbers of started ([bufferEnd])\n     * and completed ([completedExpandBuffersAndPauseFlag]) [expandBuffer]\n     * attempts coincide and become equal or greater than [globalIndex].\n     * To avoid starvation, this function may set a flag\n     * that pauses further progress.\n     */\n    internal fun waitExpandBufferCompletion(globalIndex: Long) {\n        // Do nothing if this channel is rendezvous or unlimited;\n        // `expandBuffer()` is not used in these cases.\n        if (isRendezvousOrUnlimited) return\n        // Wait in an infinite loop until the number of started\n        // buffer expansion calls become not lower than the cell index.\n        @Suppress(\"ControlFlowWithEmptyBody\")\n        while (bufferEndCounter <= globalIndex) {}\n        // Now it is guaranteed that the `expandBuffer()` call that\n        // should process the required cell has been started.\n        // Wait in a fixed-size spin-loop until the numbers of\n        // started and completed buffer expansion calls coincide.\n        repeat(EXPAND_BUFFER_COMPLETION_WAIT_ITERATIONS) {\n            // Read the number of started buffer expansion calls.\n            val b = bufferEndCounter\n            // Read the number of completed buffer expansion calls.\n            val ebCompleted = completedExpandBuffersAndPauseFlag.value.ebCompletedCounter\n            // Do the numbers of started and completed calls coincide?\n            // Note that we need to re-read the number of started `expandBuffer()`\n            // calls to obtain a correct snapshot.\n            // Here we wait to a precise match in order to ensure that **our matching expandBuffer()**\n            // completed. The only way to ensure that is to check that number of started expands == number of finished expands\n            if (b == ebCompleted && b == bufferEndCounter) return\n        }\n        // To avoid starvation, pause further `expandBuffer()` calls.\n        completedExpandBuffersAndPauseFlag.update {\n            constructEBCompletedAndPauseFlag(it.ebCompletedCounter, true)\n        }\n        // Now wait in an infinite spin-loop until the counters coincide.\n        while (true) {\n            // Read the number of started buffer expansion calls.\n            val b = bufferEndCounter\n            // Read the number of completed buffer expansion calls\n            // along with the flag that pauses further progress.\n            val ebCompletedAndBit = completedExpandBuffersAndPauseFlag.value\n            val ebCompleted = ebCompletedAndBit.ebCompletedCounter\n            val pauseExpandBuffers = ebCompletedAndBit.ebPauseExpandBuffers\n            // Do the numbers of started and completed calls coincide?\n            // Note that we need to re-read the number of started `expandBuffer()`\n            // calls to obtain a correct snapshot.\n            if (b == ebCompleted && b == bufferEndCounter) {\n                // Unset the flag, which pauses progress, and finish.\n                completedExpandBuffersAndPauseFlag.update {\n                    constructEBCompletedAndPauseFlag(it.ebCompletedCounter, false)\n                }\n                return\n            }\n            // It is possible that a concurrent caller of this function\n            // has unset the flag, which pauses further progress to avoid\n            // starvation. In this case, set the flag back.\n            if (!pauseExpandBuffers) {\n                completedExpandBuffersAndPauseFlag.compareAndSet(\n                    ebCompletedAndBit,\n                    constructEBCompletedAndPauseFlag(ebCompleted, true)\n                )\n            }\n        }\n    }\n\n\n    // #######################\n    // ## Select Expression ##\n    // #######################\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override val onSend: SelectClause2<E, BufferedChannel<E>>\n        get() = SelectClause2Impl(\n            clauseObject = this@BufferedChannel,\n            regFunc = BufferedChannel<*>::registerSelectForSend as RegistrationFunction,\n            processResFunc = BufferedChannel<*>::processResultSelectSend as ProcessResultFunction\n        )\n\n    @Suppress(\"UNCHECKED_CAST\")\n    protected open fun registerSelectForSend(select: SelectInstance<*>, element: Any?) =\n        sendImpl( // <-- this is an inline function\n            element = element as E,\n            waiter = select,\n            onRendezvousOrBuffered = { select.selectInRegistrationPhase(Unit) },\n            onSuspend = { _, _ -> },\n            onClosed = { onClosedSelectOnSend(element, select) }\n        )\n\n\n    private fun onClosedSelectOnSend(element: E, select: SelectInstance<*>) {\n        onUndeliveredElement?.callUndeliveredElement(element, select.context)\n        select.selectInRegistrationPhase(CHANNEL_CLOSED)\n    }\n\n    @Suppress(\"UNUSED_PARAMETER\", \"RedundantNullableReturnType\")\n    private fun processResultSelectSend(ignoredParam: Any?, selectResult: Any?): Any? =\n        if (selectResult === CHANNEL_CLOSED) throw sendException\n        else this\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override val onReceive: SelectClause1<E>\n        get() = SelectClause1Impl(\n            clauseObject = this@BufferedChannel,\n            regFunc = BufferedChannel<*>::registerSelectForReceive as RegistrationFunction,\n            processResFunc = BufferedChannel<*>::processResultSelectReceive as ProcessResultFunction,\n            onCancellationConstructor = onUndeliveredElementReceiveCancellationConstructor\n        )\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override val onReceiveCatching: SelectClause1<ChannelResult<E>>\n        get() = SelectClause1Impl(\n            clauseObject = this@BufferedChannel,\n            regFunc = BufferedChannel<*>::registerSelectForReceive as RegistrationFunction,\n            processResFunc = BufferedChannel<*>::processResultSelectReceiveCatching as ProcessResultFunction,\n            onCancellationConstructor = onUndeliveredElementReceiveCancellationConstructor\n        )\n\n    @Suppress(\"OVERRIDE_DEPRECATION\", \"UNCHECKED_CAST\")\n    override val onReceiveOrNull: SelectClause1<E?>\n        get() = SelectClause1Impl(\n            clauseObject = this@BufferedChannel,\n            regFunc = BufferedChannel<*>::registerSelectForReceive as RegistrationFunction,\n            processResFunc = BufferedChannel<*>::processResultSelectReceiveOrNull as ProcessResultFunction,\n            onCancellationConstructor = onUndeliveredElementReceiveCancellationConstructor\n        )\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun registerSelectForReceive(select: SelectInstance<*>, ignoredParam: Any?) =\n        receiveImpl( // <-- this is an inline function\n            waiter = select,\n            onElementRetrieved = { elem -> select.selectInRegistrationPhase(elem) },\n            onSuspend = { _, _, _ -> },\n            onClosed = { onClosedSelectOnReceive(select) }\n        )\n\n    private fun onClosedSelectOnReceive(select: SelectInstance<*>) {\n        select.selectInRegistrationPhase(CHANNEL_CLOSED)\n    }\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun processResultSelectReceive(ignoredParam: Any?, selectResult: Any?): Any? =\n        if (selectResult === CHANNEL_CLOSED) throw receiveException\n        else selectResult\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun processResultSelectReceiveOrNull(ignoredParam: Any?, selectResult: Any?): Any? =\n        if (selectResult === CHANNEL_CLOSED) {\n            if (closeCause == null) null\n            else throw receiveException\n        } else selectResult\n\n    @Suppress(\"UNCHECKED_CAST\", \"UNUSED_PARAMETER\", \"RedundantNullableReturnType\")\n    private fun processResultSelectReceiveCatching(ignoredParam: Any?, selectResult: Any?): Any? =\n        if (selectResult === CHANNEL_CLOSED) closed(closeCause)\n        else success(selectResult as E)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private val onUndeliveredElementReceiveCancellationConstructor: OnCancellationConstructor? = onUndeliveredElement?.let {\n        { select: SelectInstance<*>, _: Any?, element: Any? ->\n            { if (element !== CHANNEL_CLOSED) onUndeliveredElement.callUndeliveredElement(element as E, select.context) }\n        }\n    }\n\n    // ######################\n    // ## Iterator Support ##\n    // ######################\n\n    override fun iterator(): ChannelIterator<E> = BufferedChannelIterator()\n\n    /**\n     * The key idea is that an iterator is a special receiver type,\n     * which should be resumed differently to [receive] and [onReceive]\n     * operations, but can be served as a waiter in a way similar to\n     * [CancellableContinuation] and [SelectInstance].\n     *\n     * Roughly, [hasNext] is a [receive] sibling, while [next] simply\n     * returns the already retrieved element. From the implementation\n     * side, [receiveResult] stores the element retrieved by [hasNext]\n     * (or a special [CHANNEL_CLOSED] token if the channel is closed).\n     *\n     * The [invoke] function is a [CancelHandler] implementation,\n     * which requires knowing the [segment] and the [index] in it\n     * that specify the location of the stored iterator.\n     *\n     * To resume the suspended [hasNext] call, a special [tryResumeHasNext]\n     * function should be used in a way similar to [CancellableContinuation.tryResume]\n     * and [SelectInstance.trySelect]. When the channel becomes closed,\n     * [tryResumeHasNextOnClosedChannel] should be used instead.\n     */\n    private inner class BufferedChannelIterator : ChannelIterator<E>, Waiter {\n        /**\n         * Stores the element retrieved by [hasNext] or\n         * a special [CHANNEL_CLOSED] token if this channel is closed.\n         * If [hasNext] has not been invoked yet, [NO_RECEIVE_RESULT] is stored.\n         */\n        private var receiveResult: Any? = NO_RECEIVE_RESULT\n\n        /**\n         * When [hasNext] suspends, this field stores the corresponding\n         * continuation. The [tryResumeHasNext] and [tryResumeHasNextOnClosedChannel]\n         * function resume this continuation when the [hasNext] invocation should complete.\n         *\n         * This property is the subject to bening data race:\n         * It is nulled-out on both completion and cancellation paths that\n         * could happen concurrently.\n         */\n        @BenignDataRace\n        private var continuation: CancellableContinuationImpl<Boolean>? = null\n\n        // `hasNext()` is just a special receive operation.\n        override suspend fun hasNext(): Boolean =\n            receiveImpl( // <-- this is an inline function\n                // Do not create a continuation until it is required;\n                // it is created later via [onNoWaiterSuspend], if needed.\n                waiter = null,\n                // Store the received element in `receiveResult` on successful\n                // retrieval from the buffer or rendezvous with a suspended sender.\n                // Also, inform the `BufferedChannel` extensions that\n                // the synchronization of this receive operation is completed.\n                onElementRetrieved = { element ->\n                    this.receiveResult = element\n                    true\n                },\n                // As no waiter is provided, suspension is impossible.\n                onSuspend = { _, _, _ -> error(\"unreachable\") },\n                // Return `false` or throw an exception if the channel is already closed.\n                onClosed = { onClosedHasNext() },\n                // If `hasNext()` decides to suspend, the corresponding\n                // `suspend` function that creates a continuation is called.\n                // The tail-call optimization is applied here.\n                onNoWaiterSuspend = { segm, i, r -> return hasNextOnNoWaiterSuspend(segm, i, r) }\n            )\n\n        private fun onClosedHasNext(): Boolean {\n            this.receiveResult = CHANNEL_CLOSED\n            val cause = closeCause ?: return false\n            throw recoverStackTrace(cause)\n        }\n\n        private suspend fun hasNextOnNoWaiterSuspend(\n            /* The working cell is specified by\n            the segment and the index in it. */\n            segment: ChannelSegment<E>,\n            index: Int,\n            /* The global index of the cell. */\n            r: Long\n        ): Boolean = suspendCancellableCoroutineReusable { cont ->\n            this.continuation = cont\n            receiveImplOnNoWaiter( // <-- this is an inline function\n                segment = segment, index = index, r = r,\n                waiter = this, // store this iterator as a waiter\n                // In case of successful element retrieval, store\n                // it in `receiveResult` and resume the continuation.\n                // Importantly, the receiver coroutine may be cancelled\n                // after it is successfully resumed but not dispatched yet.\n                // In case `onUndeliveredElement` is present, we must\n                // invoke it in the latter case.\n                onElementRetrieved = { element ->\n                    this.receiveResult = element\n                    this.continuation = null\n                    cont.resume(true, onUndeliveredElement?.bindCancellationFun(element, cont.context))\n                },\n                onClosed = { onClosedHasNextNoWaiterSuspend() }\n            )\n        }\n\n        override fun invokeOnCancellation(segment: Segment<*>, index: Int) {\n            this.continuation?.invokeOnCancellation(segment, index)\n        }\n\n        private fun onClosedHasNextNoWaiterSuspend() {\n            // Read the current continuation and clean\n            // the corresponding field to avoid memory leaks.\n            val cont = this.continuation!!\n            this.continuation = null\n            // Update the `hasNext()` internal result.\n            this.receiveResult = CHANNEL_CLOSED\n            // If this channel was closed without exception,\n            // `hasNext()` should return `false`; otherwise,\n            // it throws the closing exception.\n            val cause = closeCause\n            if (cause == null) {\n                cont.resume(false)\n            } else {\n                cont.resumeWithException(recoverStackTrace(cause, cont))\n            }\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun next(): E {\n            // Read the already received result, or [NO_RECEIVE_RESULT] if [hasNext] has not been invoked yet.\n            val result = receiveResult\n            check(result !== NO_RECEIVE_RESULT) { \"`hasNext()` has not been invoked\" }\n            receiveResult = NO_RECEIVE_RESULT\n            // Is this channel closed?\n            if (result === CHANNEL_CLOSED) throw recoverStackTrace(receiveException)\n            // Return the element.\n            return result as E\n        }\n\n        fun tryResumeHasNext(element: E): Boolean {\n            // Read the current continuation and clean\n            // the corresponding field to avoid memory leaks.\n            val cont = this.continuation!!\n            this.continuation = null\n            // Store the retrieved element in `receiveResult`.\n            this.receiveResult = element\n            // Try to resume this `hasNext()`. Importantly, the receiver coroutine\n            // may be cancelled after it is successfully resumed but not dispatched yet.\n            // In case `onUndeliveredElement` is specified, we need to invoke it in the latter case.\n            return cont.tryResume0(true, onUndeliveredElement?.bindCancellationFun(element, cont.context))\n        }\n\n        fun tryResumeHasNextOnClosedChannel() {\n            /*\n             * Read the current continuation of the suspended `hasNext()` call and clean the corresponding field to avoid memory leaks.\n             * While this nulling out is unnecessary, it eliminates memory leaks (through the continuation)\n             * if the channel iterator accidentally remains GC-reachable after the channel is closed.\n             */\n            val cont = this.continuation!!\n            this.continuation = null\n            // Update the `hasNext()` internal result and inform\n            // `BufferedChannel` extensions that synchronization\n            // of this receive operation is completed.\n            this.receiveResult = CHANNEL_CLOSED\n            // If this channel was closed without exception,\n            // `hasNext()` should return `false`; otherwise,\n            // it throws the closing exception.\n            val cause = closeCause\n            if (cause == null) {\n                cont.resume(false)\n            } else {\n                cont.resumeWithException(recoverStackTrace(cause, cont))\n            }\n        }\n    }\n\n    // ##############################\n    // ## Closing and Cancellation ##\n    // ##############################\n\n    /**\n     * Store the cause of closing this channel, either via [close] or [cancel] call.\n     * The closing cause can be set only once.\n     */\n    private val _closeCause = atomic<Any?>(NO_CLOSE_CAUSE)\n    // Should be called only if this channel is closed or cancelled.\n    protected val closeCause get() = _closeCause.value as Throwable?\n\n    /** Returns the closing cause if it is non-null, or [ClosedSendChannelException] otherwise. */\n    protected val sendException get() = closeCause ?: ClosedSendChannelException(DEFAULT_CLOSE_MESSAGE)\n\n    /** Returns the closing cause if it is non-null, or [ClosedReceiveChannelException] otherwise. */\n    private val receiveException get() = closeCause ?: ClosedReceiveChannelException(DEFAULT_CLOSE_MESSAGE)\n\n    /**\n      Stores the closed handler installed by [invokeOnClose].\n      To synchronize [invokeOnClose] and [close], two additional\n      marker states, [CLOSE_HANDLER_INVOKED] and [CLOSE_HANDLER_CLOSED]\n      are used. The resulting state diagram is presented below.\n\n      +------+  install handler  +---------+  close(..)  +---------+\n      | null |------------------>| handler |------------>| INVOKED |\n      +------+                   +---------+             +---------+\n         |\n         | close(..)  +--------+\n         +----------->| CLOSED |\n                      +--------+\n     */\n    private val closeHandler = atomic<Any?>(null)\n\n    /**\n     * Invoked when channel is closed as the last action of [close] invocation.\n     * This method should be idempotent and can be called multiple times.\n     */\n    protected open fun onClosedIdempotent() {}\n\n    override fun close(cause: Throwable?): Boolean =\n        closeOrCancelImpl(cause, cancel = false)\n\n    @Suppress(\"OVERRIDE_DEPRECATION\")\n    final override fun cancel(cause: Throwable?): Boolean = cancelImpl(cause)\n\n    @Suppress(\"OVERRIDE_DEPRECATION\")\n    final override fun cancel() { cancelImpl(null) }\n\n    final override fun cancel(cause: CancellationException?) { cancelImpl(cause) }\n\n    internal open fun cancelImpl(cause: Throwable?): Boolean =\n        closeOrCancelImpl(cause ?: CancellationException(\"Channel was cancelled\"), cancel = true)\n\n    /**\n     * This is a common implementation for [close] and [cancel]. It first tries\n     * to install the specified cause; the invocation that successfully installs\n     * the cause returns `true` as a results of this function, while all further\n     * [close] and [cancel] calls return `false`.\n     *\n     * After the closing/cancellation cause is installed, the channel should be marked\n     * as closed or cancelled, which bounds further `send(e)`-s to fails.\n     *\n     * Then, [completeCloseOrCancel] is called, which cancels waiting `receive()`\n     * requests ([cancelSuspendedReceiveRequests]) and removes unprocessed elements\n     * ([removeUnprocessedElements]) in case this channel is cancelled.\n     *\n     * Finally, if this [closeOrCancelImpl] has installed the cause, therefore,\n     * has closed the channel, [closeHandler] and [onClosedIdempotent] should be invoked.\n     */\n    protected open fun closeOrCancelImpl(cause: Throwable?, cancel: Boolean): Boolean {\n        // If this is a `cancel(..)` invocation, set a bit that the cancellation\n        // has been started. This is crucial for ensuring linearizability,\n        // when concurrent `close(..)` and `isClosedFor[Send,Receive]` operations\n        // help this `cancel(..)`.\n        if (cancel) markCancellationStarted()\n        // Try to install the specified cause. On success, this invocation will\n        // return `true` as a result; otherwise, it will complete with `false`.\n        val closedByThisOperation = _closeCause.compareAndSet(NO_CLOSE_CAUSE, cause)\n        // Mark this channel as closed or cancelled, depending on this operation type.\n        if (cancel) markCancelled() else markClosed()\n        // Complete the closing or cancellation procedure.\n        completeCloseOrCancel()\n        // Finally, if this operation has installed the cause,\n        // it should invoke the close handlers.\n        return closedByThisOperation.also {\n            onClosedIdempotent()\n            if (it) invokeCloseHandler()\n        }\n    }\n\n    /**\n     * Invokes the installed close handler,\n     * updating the [closeHandler] state correspondingly.\n     */\n    private fun invokeCloseHandler() {\n        val closeHandler = closeHandler.getAndUpdate {\n            if (it === null) {\n                // Inform concurrent `invokeOnClose`\n                // that this channel is already closed.\n                CLOSE_HANDLER_CLOSED\n            } else {\n                // Replace the handler with a special\n                // `INVOKED` marker to avoid memory leaks.\n                CLOSE_HANDLER_INVOKED\n            }\n        } ?: return // no handler was installed, finish.\n        // Invoke the handler.\n        @Suppress(\"UNCHECKED_CAST\")\n        closeHandler as (cause: Throwable?) -> Unit\n        closeHandler(closeCause)\n    }\n\n    override fun invokeOnClose(handler: (cause: Throwable?) -> Unit) {\n        // Try to install the handler, finishing on success.\n        if (closeHandler.compareAndSet(null, handler)) {\n            // Handler has been successfully set, finish the operation.\n            return\n        }\n        // Either another handler is already set, or this channel is closed.\n        // In the latter case, the current handler should be invoked.\n        // However, the implementation must ensure that at most one\n        // handler is called, throwing an `IllegalStateException`\n        // if another close handler has been invoked.\n        closeHandler.loop { cur ->\n            when {\n                cur === CLOSE_HANDLER_CLOSED -> {\n                    // Try to update the state from `CLOSED` to `INVOKED`.\n                    // This is crucial to guarantee that at most one handler can be called.\n                    // On success, invoke the handler and finish.\n                    if (closeHandler.compareAndSet(CLOSE_HANDLER_CLOSED, CLOSE_HANDLER_INVOKED)) {\n                        handler(closeCause)\n                        return\n                    }\n                }\n                cur === CLOSE_HANDLER_INVOKED -> error(\"Another handler was already registered and successfully invoked\")\n                else -> error(\"Another handler is already registered: $cur\")\n            }\n        }\n    }\n\n    /**\n     * Marks this channel as closed.\n     * In case [cancelImpl] has already been invoked,\n     * and this channel is marked with [CLOSE_STATUS_CANCELLATION_STARTED],\n     * this function marks the channel as cancelled.\n     *\n     * All operation that notice this channel in the closed state,\n     * must help to complete the closing via [completeCloseOrCancel].\n     */\n    private fun markClosed(): Unit =\n        sendersAndCloseStatus.update { cur ->\n            when (cur.sendersCloseStatus) {\n                CLOSE_STATUS_ACTIVE -> // the channel is neither closed nor cancelled\n                    constructSendersAndCloseStatus(cur.sendersCounter, CLOSE_STATUS_CLOSED)\n                CLOSE_STATUS_CANCELLATION_STARTED -> // the channel is going to be cancelled\n                    constructSendersAndCloseStatus(cur.sendersCounter, CLOSE_STATUS_CANCELLED)\n                else -> return // the channel is already marked as closed or cancelled.\n            }\n        }\n\n    /**\n     * Marks this channel as cancelled.\n     *\n     * All operation that notice this channel in the cancelled state,\n     * must help to complete the cancellation via [completeCloseOrCancel].\n     */\n    private fun markCancelled(): Unit =\n        sendersAndCloseStatus.update { cur ->\n            constructSendersAndCloseStatus(cur.sendersCounter, CLOSE_STATUS_CANCELLED)\n        }\n\n    /**\n     * When the cancellation procedure starts, it is critical\n     * to mark the closing status correspondingly. Thus, other\n     * operations, which may help to complete the cancellation,\n     * always correctly update the status to `CANCELLED`.\n     */\n    private fun markCancellationStarted(): Unit =\n        sendersAndCloseStatus.update { cur ->\n            if (cur.sendersCloseStatus == CLOSE_STATUS_ACTIVE)\n                constructSendersAndCloseStatus(cur.sendersCounter, CLOSE_STATUS_CANCELLATION_STARTED)\n            else return // this channel is already closed or cancelled\n        }\n\n    /**\n     * Completes the started [close] or [cancel] procedure.\n     */\n    private fun completeCloseOrCancel() {\n        isClosedForSend // must finish the started close/cancel if one is detected.\n    }\n\n    protected open val isConflatedDropOldest get() = false\n\n    /**\n     * Completes the channel closing procedure.\n     */\n    private fun completeClose(sendersCur: Long): ChannelSegment<E> {\n        // Close the linked list for further segment addition,\n        // obtaining the last segment in the data structure.\n        val lastSegment = closeLinkedList()\n        // In the conflated channel implementation (with the DROP_OLDEST\n        // elements conflation strategy), it is critical to mark all empty\n        // cells as closed to prevent in-progress `send(e)`-s, which have not\n        // put their elements yet, completions after this channel is closed.\n        // Otherwise, it is possible for a `send(e)` to put an element when\n        // the buffer is already full, while a concurrent receiver may extract\n        // the oldest element. When the channel is not closed, we can linearize\n        // this `receive()` before the `send(e)`, but after the channel is closed,\n        // `send(e)` must fails. Marking all unprocessed cells as `CLOSED` solves the issue.\n        if (isConflatedDropOldest) {\n            val lastBufferedCellGlobalIndex = markAllEmptyCellsAsClosed(lastSegment)\n            if (lastBufferedCellGlobalIndex != -1L)\n                dropFirstElementUntilTheSpecifiedCellIsInTheBuffer(lastBufferedCellGlobalIndex)\n        }\n        // Resume waiting `receive()` requests,\n        // informing them that the channel is closed.\n        cancelSuspendedReceiveRequests(lastSegment, sendersCur)\n        // Return the last segment in the linked list as a result\n        // of this function; we need it in `completeCancel(..)`.\n        return lastSegment\n    }\n\n    /**\n     * Completes the channel cancellation procedure.\n     */\n    private fun completeCancel(sendersCur: Long) {\n        // First, ensure that this channel is closed,\n        // obtaining the last segment in the linked list.\n        val lastSegment = completeClose(sendersCur)\n        // Cancel suspended `send(e)` requests and\n        // remove buffered elements in the reverse order.\n        removeUnprocessedElements(lastSegment)\n    }\n\n    /**\n     * Closes the underlying linked list of segments for further segment addition.\n     */\n    private fun closeLinkedList(): ChannelSegment<E> {\n        // Choose the last segment.\n        var lastSegment = bufferEndSegment.value\n        sendSegment.value.let { if (it.id > lastSegment.id) lastSegment = it }\n        receiveSegment.value.let { if (it.id > lastSegment.id) lastSegment = it }\n        // Close the linked list of segment for new segment addition\n        // and return the last segment in the linked list.\n        return lastSegment.close()\n    }\n\n    /**\n     * This function marks all empty cells, in the `null` and [IN_BUFFER] state,\n     * as closed. Notably, it processes the cells from right to left, and finishes\n     * immediately when the processing cell is already covered by `receive()` or\n     * contains a buffered elements ([BUFFERED] state).\n     *\n     * This function returns the global index of the last buffered element,\n     * or `-1` if this channel does not contain buffered elements.\n     */\n    private fun markAllEmptyCellsAsClosed(lastSegment: ChannelSegment<E>): Long {\n        // Process the cells in reverse order, from right to left.\n        var segment = lastSegment\n        while (true) {\n            for (index in SEGMENT_SIZE - 1 downTo 0) {\n                // Is this cell already covered by `receive()`?\n                val globalIndex = segment.id * SEGMENT_SIZE + index\n                if (globalIndex < receiversCounter) return -1\n                // Process the cell `segment[index]`.\n                cell_update@ while (true) {\n                    val state = segment.getState(index)\n                    when {\n                        // The cell is empty.\n                        state === null || state === IN_BUFFER -> {\n                            // Inform a possibly upcoming sender that this channel is already closed.\n                            if (segment.casState(index, state, CHANNEL_CLOSED)) {\n                                segment.onSlotCleaned()\n                                break@cell_update\n                            }\n                        }\n                        // The cell stores a buffered element.\n                        state === BUFFERED -> return globalIndex\n                        // Skip this cell if it is not empty and does not store a buffered element.\n                        else -> break@cell_update\n                    }\n                }\n            }\n            // Process the next segment, finishing if the linked list ends.\n            segment = segment.prev ?: return -1\n        }\n    }\n\n    /**\n     * Cancels suspended `send(e)` requests and removes buffered elements\n     * starting from the last cell in the specified [lastSegment] (it must\n     * be the physical tail of the underlying linked list) and updating\n     * the cells in reverse order.\n     */\n    private fun removeUnprocessedElements(lastSegment: ChannelSegment<E>) {\n        // Read the `onUndeliveredElement` lambda at once. In case it\n        // throws an exception, this exception is handled and stored in\n        // the variable below. If multiple exceptions are thrown, the first\n        // one is stored in the variable, while the others are suppressed.\n        val onUndeliveredElement = onUndeliveredElement\n        var undeliveredElementException: UndeliveredElementException? = null // first cancel exception, others suppressed\n        // To perform synchronization correctly, it is critical to\n        // process the cells in reverse order, from right to left.\n        // However, according to the API, suspended senders should\n        // be cancelled in the order of their suspension. Therefore,\n        // we need to collect all of them and cancel in the reverse\n        // order after that.\n        var suspendedSenders = InlineList<Waiter>()\n        var segment = lastSegment\n        process_segments@ while (true) {\n            for (index in SEGMENT_SIZE - 1 downTo 0) {\n                // Process the cell `segment[index]`.\n                val globalIndex = segment.id * SEGMENT_SIZE + index\n                // Update the cell state.\n                update_cell@ while (true) {\n                    // Read the current state of the cell.\n                    val state = segment.getState(index)\n                    when {\n                        // The cell is already processed by a receiver.\n                        state === DONE_RCV -> break@process_segments\n                        // The cell stores a buffered element.\n                        state === BUFFERED -> {\n                            // Is the cell already covered by a receiver?\n                            if (globalIndex < receiversCounter) break@process_segments\n                            // Update the cell state to `CHANNEL_CLOSED`.\n                            if (segment.casState(index, state, CHANNEL_CLOSED)) {\n                                // If `onUndeliveredElement` lambda is non-null, call it.\n                                if (onUndeliveredElement != null) {\n                                    val element = segment.getElement(index)\n                                    undeliveredElementException = onUndeliveredElement.callUndeliveredElementCatchingException(element, undeliveredElementException)\n                                }\n                                // Clean the element field and inform the segment\n                                // that the slot is cleaned to avoid memory leaks.\n                                segment.cleanElement(index)\n                                segment.onSlotCleaned()\n                                break@update_cell\n                            }\n                        }\n                        // The cell is empty.\n                        state === IN_BUFFER || state === null -> {\n                            // Update the cell state to `CHANNEL_CLOSED`.\n                            if (segment.casState(index, state, CHANNEL_CLOSED)) {\n                                // Inform the segment that the slot is cleaned to avoid memory leaks.\n                                segment.onSlotCleaned()\n                                break@update_cell\n                            }\n                        }\n                        // The cell stores a suspended waiter.\n                        state is Waiter || state is WaiterEB -> {\n                            // Is the cell already covered by a receiver?\n                            if (globalIndex < receiversCounter) break@process_segments\n                            // Obtain the sender.\n                            val sender: Waiter = if (state is WaiterEB) state.waiter\n                                                 else state as Waiter\n                            // Update the cell state to `CHANNEL_CLOSED`.\n                            if (segment.casState(index, state, CHANNEL_CLOSED)) {\n                                // If `onUndeliveredElement` lambda is non-null, call it.\n                                if (onUndeliveredElement != null) {\n                                    val element = segment.getElement(index)\n                                    undeliveredElementException = onUndeliveredElement.callUndeliveredElementCatchingException(element, undeliveredElementException)\n                                }\n                                // Save the sender for further cancellation.\n                                suspendedSenders += sender\n                                // Clean the element field and inform the segment\n                                // that the slot is cleaned to avoid memory leaks.\n                                segment.cleanElement(index)\n                                segment.onSlotCleaned()\n                                break@update_cell\n                            }\n                        }\n                        // A concurrent receiver is resuming a suspended sender.\n                        // As the cell is covered by a receiver, finish immediately.\n                        state === RESUMING_BY_EB || state === RESUMING_BY_RCV -> break@process_segments\n                        // A concurrent `expandBuffer()` is resuming a suspended sender.\n                        // Wait in a spin-loop until the cell state changes.\n                        state === RESUMING_BY_EB -> continue@update_cell\n                        else -> break@update_cell\n                    }\n                }\n            }\n            // Process the previous segment.\n            segment = segment.prev ?: break\n        }\n        // Cancel suspended senders in their order of addition to this channel.\n        suspendedSenders.forEachReversed { it.resumeSenderOnCancelledChannel() }\n        // Throw `UndeliveredElementException` at the end if there was one.\n        undeliveredElementException?.let { throw it }\n    }\n\n    /**\n     * Cancels suspended `receive` requests from the end to the beginning,\n     * also moving empty cells to the `CHANNEL_CLOSED` state.\n     */\n    private fun cancelSuspendedReceiveRequests(lastSegment: ChannelSegment<E>, sendersCounter: Long) {\n        // To perform synchronization correctly, it is critical to\n        // extract suspended requests in the reverse order,\n        // from the end to the beginning.\n        // However, according to the API, they should be cancelled\n        // in the order of their suspension. Therefore, we need to\n        // collect the suspended requests first, cancelling them\n        // in the reverse order after that.\n        var suspendedReceivers = InlineList<Waiter>()\n        var segment: ChannelSegment<E>? = lastSegment\n        process_segments@ while (segment != null) {\n            for (index in SEGMENT_SIZE - 1 downTo 0) {\n                // Is the cell already covered by a sender? Finish immediately in this case.\n                if (segment.id * SEGMENT_SIZE + index < sendersCounter) break@process_segments\n                // Try to move the cell state to `CHANNEL_CLOSED`.\n                cell_update@ while (true) {\n                    val state = segment.getState(index)\n                    when {\n                        state === null || state === IN_BUFFER -> {\n                            if (segment.casState(index, state, CHANNEL_CLOSED)) {\n                                segment.onSlotCleaned()\n                                break@cell_update\n                            }\n                        }\n                        state is WaiterEB -> {\n                            if (segment.casState(index, state, CHANNEL_CLOSED)) {\n                                suspendedReceivers += state.waiter // save for cancellation.\n                                segment.onCancelledRequest(index = index, receiver = true)\n                                break@cell_update\n                            }\n                        }\n                        state is Waiter -> {\n                            if (segment.casState(index, state, CHANNEL_CLOSED)) {\n                                suspendedReceivers += state // save for cancellation.\n                                segment.onCancelledRequest(index = index, receiver = true)\n                                break@cell_update\n                            }\n                        }\n                        else -> break@cell_update // nothing to cancel.\n                    }\n                }\n            }\n            // Process the previous segment.\n            segment = segment.prev\n        }\n        // Cancel the suspended requests in their order of addition to this channel.\n        suspendedReceivers.forEachReversed { it.resumeReceiverOnClosedChannel() }\n    }\n\n    /**\n     * Resumes this receiver because this channel is closed.\n     * This function does not take any effect if the operation has already been resumed or cancelled.\n     */\n    private fun Waiter.resumeReceiverOnClosedChannel() = resumeWaiterOnClosedChannel(receiver = true)\n\n    /**\n     * Resumes this sender because this channel is cancelled.\n     * This function does not take any effect if the operation has already been resumed or cancelled.\n     */\n    private fun Waiter.resumeSenderOnCancelledChannel() = resumeWaiterOnClosedChannel(receiver = false)\n\n    private fun Waiter.resumeWaiterOnClosedChannel(receiver: Boolean) {\n        when (this) {\n            is SendBroadcast -> cont.resume(false)\n            is CancellableContinuation<*> -> resumeWithException(if (receiver) receiveException else sendException)\n            is ReceiveCatching<*> -> cont.resume(closed(closeCause))\n            is BufferedChannel<*>.BufferedChannelIterator -> tryResumeHasNextOnClosedChannel()\n            is SelectInstance<*> -> trySelect(this@BufferedChannel, CHANNEL_CLOSED)\n            else -> error(\"Unexpected waiter: $this\")\n        }\n    }\n\n    @ExperimentalCoroutinesApi\n    override val isClosedForSend: Boolean\n        get() = sendersAndCloseStatus.value.isClosedForSend0\n\n    private val Long.isClosedForSend0 get() =\n        isClosed(this, isClosedForReceive = false)\n\n    @ExperimentalCoroutinesApi\n    override val isClosedForReceive: Boolean\n        get() = sendersAndCloseStatus.value.isClosedForReceive0\n\n    private val Long.isClosedForReceive0 get() =\n        isClosed(this, isClosedForReceive = true)\n\n    private fun isClosed(\n        sendersAndCloseStatusCur: Long,\n        isClosedForReceive: Boolean\n    ) = when (sendersAndCloseStatusCur.sendersCloseStatus) {\n        // This channel is active and has not been closed.\n        CLOSE_STATUS_ACTIVE -> false\n        // The cancellation procedure has been started but\n        // not linearized yet, so this channel should be\n        // considered as active.\n        CLOSE_STATUS_CANCELLATION_STARTED -> false\n        // This channel has been successfully closed.\n        // Help to complete the closing procedure to\n        // guarantee linearizability, and return `true`\n        // for senders or the flag whether there still\n        // exist elements to retrieve for receivers.\n        CLOSE_STATUS_CLOSED -> {\n            completeClose(sendersAndCloseStatusCur.sendersCounter)\n            // When `isClosedForReceive` is `false`, always return `true`.\n            // Otherwise, it is possible that the channel is closed but\n            // still has elements to retrieve.\n            if (isClosedForReceive) !hasElements() else true\n        }\n        // This channel has been successfully cancelled.\n        // Help to complete the cancellation procedure to\n        // guarantee linearizability and return `true`.\n        CLOSE_STATUS_CANCELLED -> {\n            completeCancel(sendersAndCloseStatusCur.sendersCounter)\n            true\n        }\n        else -> error(\"unexpected close status: ${sendersAndCloseStatusCur.sendersCloseStatus}\")\n    }\n\n    @ExperimentalCoroutinesApi\n    override val isEmpty: Boolean get() {\n        // This function should return `false` if\n        // this channel is closed for `receive`.\n        if (isClosedForReceive) return false\n        // Does this channel has elements to retrieve?\n        if (hasElements()) return false\n        // This channel does not have elements to retrieve;\n        // Check that it is still not closed for `receive`.\n        return !isClosedForReceive\n    }\n\n    /**\n     * Checks whether this channel contains elements to retrieve.\n     * Unfortunately, simply comparing the counters is insufficient,\n     * as some cells can be in the `INTERRUPTED` state due to cancellation.\n     * This function tries to find the first \"alive\" element,\n     * updating the `receivers` counter to skip empty cells.\n     *\n     * The implementation is similar to `receive()`.\n     */\n    internal fun hasElements(): Boolean {\n        while (true) {\n            // Read the segment before obtaining the `receivers` counter value.\n            var segment = receiveSegment.value\n            // Obtains the `receivers` and `senders` counter values.\n            val r = receiversCounter\n            val s = sendersCounter\n            // Is there a chance that this channel has elements?\n            if (s <= r) return false // no elements\n            // The `r`-th cell is covered by a sender; check whether it contains an element.\n            // First, try to find the required segment if the initially\n            // obtained segment (in the beginning of this function) has lower id.\n            val id = r / SEGMENT_SIZE\n            if (segment.id != id) {\n                // Try to find the required segment.\n                segment = findSegmentReceive(id, segment) ?:\n                    // The required segment has not been found. Either it has already\n                    // been removed, or the underlying linked list is already closed\n                    // for segment additions. In the latter case, the channel is closed\n                    // and does not contain elements, so this operation returns `false`.\n                    // Otherwise, if the required segment is removed, the operation restarts.\n                    if (receiveSegment.value.id < id) return false else continue\n            }\n            segment.cleanPrev() // all the previous segments are no longer needed.\n            // Does the `r`-th cell contain waiting sender or buffered element?\n            val i = (r % SEGMENT_SIZE).toInt()\n            if (isCellNonEmpty(segment, i, r)) return true\n            // The cell is empty. Update `receivers` counter and try again.\n            receivers.compareAndSet(r, r + 1) // if this CAS fails, the counter has already been updated.\n        }\n    }\n\n    /**\n     * Checks whether this cell contains a buffered element or a waiting sender,\n     * returning `true` in this case. Otherwise, if this cell is empty\n     * (due to waiter cancellation, cell poisoning, or channel closing),\n     * this function returns `false`.\n     *\n     * Notably, this function must be called only if the cell is covered by a sender.\n     */\n    private fun isCellNonEmpty(\n        segment: ChannelSegment<E>,\n        index: Int,\n        globalIndex: Long\n    ): Boolean {\n        // The logic is similar to `updateCellReceive` with the only difference\n        // that this function neither changes the cell state nor retrieves the element.\n        while (true) {\n            // Read the current cell state.\n            val state = segment.getState(index)\n            when {\n                // The cell is empty but a sender is coming.\n                state === null || state === IN_BUFFER -> {\n                    // Poison the cell to ensure correctness.\n                    if (segment.casState(index, state, POISONED)) {\n                        // When the cell becomes poisoned, it is essentially\n                        // the same as storing an already cancelled receiver.\n                        // Thus, the `expandBuffer()` procedure should be invoked.\n                        expandBuffer()\n                        return false\n                    }\n                }\n                // The cell stores a buffered element.\n                state === BUFFERED -> return true\n                // The cell stores an interrupted sender.\n                state === INTERRUPTED_SEND -> return false\n                // This channel is already closed.\n                state === CHANNEL_CLOSED -> return false\n                // The cell is already processed\n                // by a concurrent receiver.\n                state === DONE_RCV -> return false\n                // The cell is already poisoned\n                // by a concurrent receiver.\n                state === POISONED -> return false\n                // A concurrent `expandBuffer()` is resuming\n                // a suspended sender. This function is eligible\n                // to linearize before the buffer expansion procedure.\n                state === RESUMING_BY_EB -> return true\n                // A concurrent receiver is resuming\n                // a suspended sender. The element\n                // is no longer available for retrieval.\n                state === RESUMING_BY_RCV -> return false\n                // The cell stores a suspended request.\n                // However, it is possible that this request\n                // is receiver if the cell is covered by both\n                // send and receive operations.\n                // In case the cell is already covered by\n                // a receiver, the element is no longer\n                // available for retrieval, and this function\n                // return `false`. Otherwise, it is guaranteed\n                // that the suspended request is sender, so\n                // this function returns `true`.\n                else -> return globalIndex == receiversCounter\n            }\n        }\n    }\n\n    // #######################\n    // # Segments Management #\n    // #######################\n\n    /**\n     * Finds the segment with the specified [id] starting by the [startFrom]\n     * segment and following the [ChannelSegment.next] references. In case\n     * the required segment has not been created yet, this function attempts\n     * to add it to the underlying linked list. Finally, it updates [sendSegment]\n     * to the found segment if its [ChannelSegment.id] is greater than the one\n     * of the already stored segment.\n     *\n     * In case the requested segment is already removed, or if it should be allocated\n     * but the linked list structure is closed for new segments addition, this function\n     * returns `null`. The implementation also efficiently skips a sequence of removed\n     * segments, updating the counter value in [sendersAndCloseStatus] correspondingly.\n     */\n    private fun findSegmentSend(id: Long, startFrom: ChannelSegment<E>): ChannelSegment<E>? {\n        return sendSegment.findSegmentAndMoveForward(id, startFrom, createSegmentFunction()).let {\n            if (it.isClosed) {\n                // The required segment has not been found and new segments\n                // cannot be added, as the linked listed in already added.\n                // This channel is already closed or cancelled; help to complete\n                // the closing or cancellation procedure.\n                completeCloseOrCancel()\n                // Clean the `prev` reference of the provided segment\n                // if all the previous cells are already covered by senders.\n                // It is important to clean the `prev` reference only in\n                // this case, as the closing/cancellation procedure may\n                // need correct value to traverse the linked list from right to left.\n                if (startFrom.id * SEGMENT_SIZE <  receiversCounter) startFrom.cleanPrev()\n                // As the required segment is not found and cannot be allocated, return `null`.\n                null\n            } else {\n                // Get the found segment.\n                val segment = it.segment\n                // Is the required segment removed?\n                if (segment.id > id) {\n                    // The required segment has been removed; `segment` is the first\n                    // segment with `id` not lower than the required one.\n                    // Skip the sequence of removed cells in O(1).\n                    updateSendersCounterIfLower(segment.id * SEGMENT_SIZE)\n                    // Clean the `prev` reference of the provided segment\n                    // if all the previous cells are already covered by senders.\n                    // It is important to clean the `prev` reference only in\n                    // this case, as the closing/cancellation procedure may\n                    // need correct value to traverse the linked list from right to left.\n                    if (segment.id * SEGMENT_SIZE <  receiversCounter) segment.cleanPrev()\n                    // As the required segment is not found and cannot be allocated, return `null`.\n                    null\n                } else {\n                    assert { segment.id == id }\n                    // The required segment has been found; return it!\n                    segment\n                }\n            }\n        }\n    }\n\n    /**\n     * Finds the segment with the specified [id] starting by the [startFrom]\n     * segment and following the [ChannelSegment.next] references. In case\n     * the required segment has not been created yet, this function attempts\n     * to add it to the underlying linked list. Finally, it updates [receiveSegment]\n     * to the found segment if its [ChannelSegment.id] is greater than the one\n     * of the already stored segment.\n     *\n     * In case the requested segment is already removed, or if it should be allocated\n     * but the linked list structure is closed for new segments addition, this function\n     * returns `null`. The implementation also efficiently skips a sequence of removed\n     * segments, updating the [receivers] counter correspondingly.\n     */\n    private fun findSegmentReceive(id: Long, startFrom: ChannelSegment<E>): ChannelSegment<E>? =\n        receiveSegment.findSegmentAndMoveForward(id, startFrom, createSegmentFunction()).let {\n            if (it.isClosed) {\n                // The required segment has not been found and new segments\n                // cannot be added, as the linked listed in already added.\n                // This channel is already closed or cancelled; help to complete\n                // the closing or cancellation procedure.\n                completeCloseOrCancel()\n                // Clean the `prev` reference of the provided segment\n                // if all the previous cells are already covered by senders.\n                // It is important to clean the `prev` reference only in\n                // this case, as the closing/cancellation procedure may\n                // need correct value to traverse the linked list from right to left.\n                if (startFrom.id * SEGMENT_SIZE < sendersCounter) startFrom.cleanPrev()\n                // As the required segment is not found and cannot be allocated, return `null`.\n                null\n            } else {\n                // Get the found segment.\n                val segment = it.segment\n                // Advance the `bufferEnd` segment if required.\n                if (!isRendezvousOrUnlimited && id <= bufferEndCounter / SEGMENT_SIZE) {\n                    bufferEndSegment.moveForward(segment)\n                }\n                // Is the required segment removed?\n                if (segment.id > id) {\n                    // The required segment has been removed; `segment` is the first\n                    // segment with `id` not lower than the required one.\n                    // Skip the sequence of removed cells in O(1).\n                    updateReceiversCounterIfLower(segment.id * SEGMENT_SIZE)\n                    // Clean the `prev` reference of the provided segment\n                    // if all the previous cells are already covered by senders.\n                    // It is important to clean the `prev` reference only in\n                    // this case, as the closing/cancellation procedure may\n                    // need correct value to traverse the linked list from right to left.\n                    if (segment.id * SEGMENT_SIZE < sendersCounter) segment.cleanPrev()\n                    // As the required segment is already removed, return `null`.\n                    null\n                } else {\n                    assert { segment.id == id }\n                    // The required segment has been found; return it!\n                    segment\n                }\n            }\n        }\n\n    /**\n     * Importantly, when this function does not find the requested segment,\n     * it always updates the number of completed `expandBuffer()` attempts.\n     */\n    private fun findSegmentBufferEnd(id: Long, startFrom: ChannelSegment<E>, currentBufferEndCounter: Long): ChannelSegment<E>? =\n        bufferEndSegment.findSegmentAndMoveForward(id, startFrom, createSegmentFunction()).let {\n            if (it.isClosed) {\n                // The required segment has not been found and new segments\n                // cannot be added, as the linked listed in already added.\n                // This channel is already closed or cancelled; help to complete\n                // the closing or cancellation procedure.\n                completeCloseOrCancel()\n                // Update `bufferEndSegment` to the last segment\n                // in the linked list to avoid memory leaks.\n                moveSegmentBufferEndToSpecifiedOrLast(id, startFrom)\n                // When this function does not find the requested segment,\n                // it should update the number of completed `expandBuffer()` attempts.\n                incCompletedExpandBufferAttempts()\n                null\n            } else {\n                // Get the found segment.\n                val segment = it.segment\n                // Is the required segment removed?\n                if (segment.id > id) {\n                    // The required segment has been removed; `segment` is the first segment\n                    // with `id` not lower than the required one.\n                    // Try to skip the sequence of removed cells in O(1) by increasing the `bufferEnd` counter.\n                    // Importantly, when this function does not find the requested segment,\n                    // it should update the number of completed `expandBuffer()` attempts.\n                    if (bufferEnd.compareAndSet(currentBufferEndCounter + 1, segment.id * SEGMENT_SIZE)) {\n                        incCompletedExpandBufferAttempts(segment.id * SEGMENT_SIZE - currentBufferEndCounter)\n                    } else {\n                        incCompletedExpandBufferAttempts()\n                    }\n                    // As the required segment is already removed, return `null`.\n                    null\n                } else {\n                    assert { segment.id == id }\n                    // The required segment has been found; return it!\n                    segment\n                }\n            }\n        }\n\n    /**\n     * Updates [bufferEndSegment] to the one with the specified [id] or\n     * to the last existing segment, if the required segment is not yet created.\n     *\n     * Unlike [findSegmentBufferEnd], this function does not allocate new segments.\n     */\n    private fun moveSegmentBufferEndToSpecifiedOrLast(id: Long, startFrom: ChannelSegment<E>) {\n        // Start searching the required segment from the specified one.\n        var segment: ChannelSegment<E> = startFrom\n        while (segment.id < id) {\n            segment = segment.next ?: break\n        }\n        // Skip all removed segments and try to update `bufferEndSegment`\n        // to the first non-removed one. This part should succeed eventually,\n        // as the tail segment is never removed.\n        while (true) {\n            while (segment.isRemoved) {\n                segment = segment.next ?: break\n            }\n            // Try to update `bufferEndSegment`. On failure,\n            // the found segment is already removed, so it\n            // should be skipped.\n            if (bufferEndSegment.moveForward(segment)) return\n        }\n    }\n\n    /**\n     * Updates the `senders` counter if its value\n     * is lower that the specified one.\n     *\n     * Senders use this function to efficiently skip\n     * a sequence of cancelled receivers.\n     */\n    private fun updateSendersCounterIfLower(value: Long): Unit =\n        sendersAndCloseStatus.loop { cur ->\n            val curCounter = cur.sendersCounter\n            if (curCounter >= value) return\n            val update = constructSendersAndCloseStatus(curCounter, cur.sendersCloseStatus)\n            if (sendersAndCloseStatus.compareAndSet(cur, update)) return\n        }\n\n    /**\n     * Updates the `receivers` counter if its value\n     * is lower that the specified one.\n     *\n     * Receivers use this function to efficiently skip\n     * a sequence of cancelled senders.\n     */\n    private fun updateReceiversCounterIfLower(value: Long): Unit =\n        receivers.loop { cur ->\n            if (cur >= value) return\n            if (receivers.compareAndSet(cur, value)) return\n        }\n\n    // ###################\n    // # Debug Functions #\n    // ###################\n\n    @Suppress(\"ConvertTwoComparisonsToRangeCheck\")\n    override fun toString(): String {\n        val sb = StringBuilder()\n        // Append the close status\n        when (sendersAndCloseStatus.value.sendersCloseStatus) {\n            CLOSE_STATUS_CLOSED -> sb.append(\"closed,\")\n            CLOSE_STATUS_CANCELLED -> sb.append(\"cancelled,\")\n        }\n        // Append the buffer capacity\n        sb.append(\"capacity=$capacity,\")\n        // Append the data\n        sb.append(\"data=[\")\n        val firstSegment = listOf(receiveSegment.value, sendSegment.value, bufferEndSegment.value)\n            .filter { it !== NULL_SEGMENT }\n            .minBy { it.id }\n        val r = receiversCounter\n        val s = sendersCounter\n        var segment = firstSegment\n        append_elements@ while (true) {\n            process_cell@ for (i in 0 until SEGMENT_SIZE) {\n                val globalCellIndex = segment.id * SEGMENT_SIZE + i\n                if (globalCellIndex >= s && globalCellIndex >= r) break@append_elements\n                val cellState = segment.getState(i)\n                val element = segment.getElement(i)\n                val cellStateString = when (cellState) {\n                    is CancellableContinuation<*> -> {\n                        when {\n                            globalCellIndex < r && globalCellIndex >= s -> \"receive\"\n                            globalCellIndex < s && globalCellIndex >= r -> \"send\"\n                            else -> \"cont\"\n                        }\n                    }\n                    is SelectInstance<*> -> {\n                        when {\n                            globalCellIndex < r && globalCellIndex >= s -> \"onReceive\"\n                            globalCellIndex < s && globalCellIndex >= r -> \"onSend\"\n                            else -> \"select\"\n                        }\n                    }\n                    is ReceiveCatching<*> -> \"receiveCatching\"\n                    is SendBroadcast -> \"sendBroadcast\"\n                    is WaiterEB -> \"EB($cellState)\"\n                    RESUMING_BY_RCV, RESUMING_BY_EB -> \"resuming_sender\"\n                    null, IN_BUFFER, DONE_RCV, POISONED, INTERRUPTED_RCV, INTERRUPTED_SEND, CHANNEL_CLOSED -> continue@process_cell\n                    else -> cellState.toString() // leave it just in case something is missed.\n                }\n                if (element != null) {\n                    sb.append(\"($cellStateString,$element),\")\n                } else {\n                    sb.append(\"$cellStateString,\")\n                }\n            }\n            // Process the next segment if exists.\n            segment = segment.next ?: break\n        }\n        if (sb.last() == ',') sb.deleteAt(sb.length - 1)\n        sb.append(\"]\")\n        // The string representation is constructed.\n        return sb.toString()\n    }\n\n    // Returns a debug representation of this channel,\n    // which is actively used in Lincheck tests.\n    internal fun toStringDebug(): String {\n        val sb = StringBuilder()\n        // Append the counter values and the close status\n        sb.append(\"S=${sendersCounter},R=${receiversCounter},B=${bufferEndCounter},B'=${completedExpandBuffersAndPauseFlag.value},C=${sendersAndCloseStatus.value.sendersCloseStatus},\")\n        when (sendersAndCloseStatus.value.sendersCloseStatus) {\n            CLOSE_STATUS_CANCELLATION_STARTED -> sb.append(\"CANCELLATION_STARTED,\")\n            CLOSE_STATUS_CLOSED -> sb.append(\"CLOSED,\")\n            CLOSE_STATUS_CANCELLED -> sb.append(\"CANCELLED,\")\n        }\n        // Append the segment references\n        sb.append(\"SEND_SEGM=${sendSegment.value.hexAddress},RCV_SEGM=${receiveSegment.value.hexAddress}\")\n        if (!isRendezvousOrUnlimited) sb.append(\",EB_SEGM=${bufferEndSegment.value.hexAddress}\")\n        sb.append(\"  \") // add some space\n        // Append the linked list of segments.\n        val firstSegment = listOf(receiveSegment.value, sendSegment.value, bufferEndSegment.value)\n            .filter { it !== NULL_SEGMENT }\n            .minBy { it.id }\n        var segment = firstSegment\n        while (true) {\n            sb.append(\"${segment.hexAddress}=[${if (segment.isRemoved) \"*\" else \"\"}${segment.id},prev=${segment.prev?.hexAddress},\")\n            repeat(SEGMENT_SIZE) { i ->\n                val cellState = segment.getState(i)\n                val element = segment.getElement(i)\n                val cellStateString = when (cellState) {\n                    is CancellableContinuation<*> -> \"cont\"\n                    is SelectInstance<*> -> \"select\"\n                    is ReceiveCatching<*> -> \"receiveCatching\"\n                    is SendBroadcast -> \"send(broadcast)\"\n                    is WaiterEB -> \"EB($cellState)\"\n                    else -> cellState.toString()\n                }\n                sb.append(\"[$i]=($cellStateString,$element),\")\n            }\n            sb.append(\"next=${segment.next?.hexAddress}]  \")\n            // Process the next segment if exists.\n            segment = segment.next ?: break\n        }\n        // The string representation of this channel is now constructed!\n        return sb.toString()\n    }\n\n\n    // This is an internal methods for tests.\n    fun checkSegmentStructureInvariants() {\n        if (isRendezvousOrUnlimited) {\n            check(bufferEndSegment.value === NULL_SEGMENT) {\n                \"bufferEndSegment must be NULL_SEGMENT for rendezvous and unlimited channels; they do not manipulate it.\\n\" +\n                    \"Channel state: $this\"\n            }\n        } else {\n            check(receiveSegment.value.id <= bufferEndSegment.value.id) {\n                \"bufferEndSegment should not have lower id than receiveSegment.\\n\" +\n                    \"Channel state: $this\"\n            }\n        }\n        val firstSegment = listOf(receiveSegment.value, sendSegment.value, bufferEndSegment.value)\n            .filter { it !== NULL_SEGMENT }\n            .minBy { it.id }\n        check(firstSegment.prev == null) {\n            \"All processed segments should be unreachable from the data structure, but the `prev` link of the leftmost segment is non-null.\\n\" +\n                \"Channel state: $this\"\n        }\n        // Check that the doubly-linked list of segments does not\n        // contain full-of-cancelled-cells segments.\n        var segment = firstSegment\n        while (segment.next != null) {\n            // Note that the `prev` reference can be `null` if this channel is closed.\n            check(segment.next!!.prev == null || segment.next!!.prev === segment) {\n                \"The `segment.next.prev === segment` invariant is violated.\\n\" +\n                    \"Channel state: $this\"\n            }\n            // Count the number of closed/interrupted cells\n            // and check that all cells are in expected states.\n            var interruptedOrClosedCells = 0\n            for (i in 0 until SEGMENT_SIZE) {\n                when (val state = segment.getState(i)) {\n                    BUFFERED -> {} // The cell stores a buffered element.\n                    is Waiter -> {} // The cell stores a suspended request.\n                    INTERRUPTED_RCV, INTERRUPTED_SEND, CHANNEL_CLOSED -> {\n                        // The cell stored an interrupted request or indicates\n                        // that this channel is already closed.\n                        // Check that the element slot is cleaned and increment\n                        // the number of cells in closed/interrupted state.\n                        check(segment.getElement(i) == null)\n                        interruptedOrClosedCells++\n                    }\n                    POISONED, DONE_RCV -> {\n                        // The cell is successfully processed or poisoned.\n                        // Check that the element slot is cleaned.\n                        check(segment.getElement(i) == null)\n                    }\n                    // Other states are illegal after all running operations finish.\n                    else -> error(\"Unexpected segment cell state: $state.\\nChannel state: $this\")\n                }\n            }\n            // Is this segment full of cancelled/closed cells?\n            // If so, this segment should be removed from the\n            // linked list if nether `receiveSegment`, nor\n            // `sendSegment`, nor `bufferEndSegment` reference it.\n            if (interruptedOrClosedCells == SEGMENT_SIZE) {\n                check(segment === receiveSegment.value || segment === sendSegment.value || segment === bufferEndSegment.value) {\n                    \"Logically removed segment is reachable.\\nChannel state: $this\"\n                }\n            }\n            // Process the next segment.\n            segment = segment.next!!\n        }\n    }\n}\n\n/**\n * The channel is represented as a list of segments, which simulates an infinite array.\n * Each segment has its own [id], which increase from the beginning. These [id]s help\n * to update [BufferedChannel.sendSegment], [BufferedChannel.receiveSegment],\n * and [BufferedChannel.bufferEndSegment] correctly.\n */\ninternal class ChannelSegment<E>(id: Long, prev: ChannelSegment<E>?, channel: BufferedChannel<E>?, pointers: Int) : Segment<ChannelSegment<E>>(id, prev, pointers) {\n    private val _channel: BufferedChannel<E>? = channel\n    val channel get() = _channel!! // always non-null except for `NULL_SEGMENT`\n\n    private val data = atomicArrayOfNulls<Any?>(SEGMENT_SIZE * 2) // 2 registers per slot: state + element\n    override val numberOfSlots: Int get() = SEGMENT_SIZE\n\n    // ########################################\n    // # Manipulation with the Element Fields #\n    // ########################################\n\n    internal fun storeElement(index: Int, element: E) {\n        setElementLazy(index, element)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    internal fun getElement(index: Int) = data[index * 2].value as E\n\n    internal fun retrieveElement(index: Int): E = getElement(index).also { cleanElement(index) }\n\n    internal fun cleanElement(index: Int) {\n        setElementLazy(index, null)\n    }\n\n    private fun setElementLazy(index: Int, value: Any?) {\n        data[index * 2].lazySet(value)\n    }\n\n    // ######################################\n    // # Manipulation with the State Fields #\n    // ######################################\n\n    internal fun getState(index: Int): Any? = data[index * 2 + 1].value\n\n    internal fun setState(index: Int, value: Any?) {\n        data[index * 2 + 1].value = value\n    }\n\n    internal fun casState(index: Int, from: Any?, to: Any?) = data[index * 2 + 1].compareAndSet(from, to)\n\n    internal fun getAndSetState(index: Int, update: Any?) = data[index * 2 + 1].getAndSet(update)\n\n\n    // ########################\n    // # Cancellation Support #\n    // ########################\n\n    override fun onCancellation(index: Int, cause: Throwable?, context: CoroutineContext) {\n        // To distinguish cancelled senders and receivers, senders equip the index value with\n        // an additional marker, adding `SEGMENT_SIZE` to the value.\n        val isSender = index >= SEGMENT_SIZE\n        // Unwrap the index.\n        @Suppress(\"NAME_SHADOWING\") val index = if (isSender) index - SEGMENT_SIZE else index\n        // Read the element, which may be needed further to call `onUndeliveredElement`.\n        val element = getElement(index)\n        // Update the cell state.\n        while (true) {\n            // CAS-loop\n            // Read the current state of the cell.\n            val cur = getState(index)\n            when {\n                // The cell stores a waiter.\n                cur is Waiter || cur is WaiterEB -> {\n                    // The cancelled request is either send or receive.\n                    // Update the cell state correspondingly.\n                    val update = if (isSender) INTERRUPTED_SEND else INTERRUPTED_RCV\n                    if (casState(index, cur, update)) {\n                        // The waiter has been successfully cancelled.\n                        // Clean the element slot and invoke `onSlotCleaned()`,\n                        // which may cause deleting the whole segment from the linked list.\n                        // In case the cancelled request is receiver, it is critical to ensure\n                        // that the `expandBuffer()` attempt that processes this cell is completed,\n                        // so `onCancelledRequest(..)` waits for its completion before invoking `onSlotCleaned()`.\n                        cleanElement(index)\n                        onCancelledRequest(index, !isSender)\n                        // Call `onUndeliveredElement` if needed.\n                        if (isSender) {\n                            channel.onUndeliveredElement?.callUndeliveredElement(element, context)\n                        }\n                        return\n                    }\n                }\n                // The cell already indicates that the operation is cancelled.\n                cur === INTERRUPTED_SEND || cur === INTERRUPTED_RCV -> {\n                    // Clean the element slot to avoid memory leaks,\n                    // invoke `onUndeliveredElement` if needed, and finish\n                    cleanElement(index)\n                    // Call `onUndeliveredElement` if needed.\n                    if (isSender) {\n                        channel.onUndeliveredElement?.callUndeliveredElement(element, context)\n                    }\n                    return\n                }\n                // An opposite operation is resuming this request;\n                // wait until the cell state updates.\n                // It is possible that an opposite operation has already\n                // resumed this request, which will result in updating\n                // the cell state to `DONE_RCV` or `BUFFERED`, while the\n                // current cancellation is caused by prompt cancellation.\n                cur === RESUMING_BY_EB || cur === RESUMING_BY_RCV -> continue\n                // This request was successfully resumed, so this cancellation\n                // is caused by the prompt cancellation feature and should be ignored.\n                cur === DONE_RCV || cur === BUFFERED -> return\n                // The cell state indicates that the channel is closed;\n                // this cancellation should be ignored.\n                cur === CHANNEL_CLOSED -> return\n                else -> error(\"unexpected state: $cur\")\n            }\n        }\n    }\n\n    /**\n     * Invokes `onSlotCleaned()` preceded by a `waitExpandBufferCompletion(..)` call\n     * in case the cancelled request is receiver.\n     */\n    fun onCancelledRequest(index: Int, receiver: Boolean) {\n        if (receiver) channel.waitExpandBufferCompletion(id * SEGMENT_SIZE + index)\n        onSlotCleaned()\n    }\n}\n\n// WA for atomicfu + JVM_IR compiler bug that lead to SMAP-related compiler crashes: KT-55983\ninternal fun <E> createSegmentFunction(): KFunction2<Long, ChannelSegment<E>, ChannelSegment<E>> = ::createSegment\n\nprivate fun <E> createSegment(id: Long, prev: ChannelSegment<E>) = ChannelSegment(\n    id = id,\n    prev = prev,\n    channel = prev.channel,\n    pointers = 0\n)\nprivate val NULL_SEGMENT = ChannelSegment<Any?>(id = -1, prev = null, channel = null, pointers = 0)\n\n/**\n * Number of cells in each segment.\n */\n@JvmField\ninternal val SEGMENT_SIZE = systemProp(\"kotlinx.coroutines.bufferedChannel.segmentSize\", 32)\n\n/**\n * Number of iterations to wait in [BufferedChannel.waitExpandBufferCompletion] until the numbers of started and completed\n * [BufferedChannel.expandBuffer] calls coincide. When the limit is reached, [BufferedChannel.waitExpandBufferCompletion]\n * blocks further [BufferedChannel.expandBuffer]-s to avoid starvation.\n */\nprivate val EXPAND_BUFFER_COMPLETION_WAIT_ITERATIONS = systemProp(\"kotlinx.coroutines.bufferedChannel.expandBufferCompletionWaitIterations\", 10_000)\n\n/**\n * Tries to resume this continuation with the specified\n * value. Returns `true` on success and `false` on failure.\n */\nprivate fun <T> CancellableContinuation<T>.tryResume0(\n    value: T,\n    onCancellation: ((cause: Throwable) -> Unit)? = null\n): Boolean =\n    tryResume(value, null, onCancellation).let { token ->\n        if (token != null) {\n            completeResume(token)\n            true\n        } else false\n    }\n\n/*\n  If the channel is rendezvous or unlimited, the `bufferEnd` counter\n  should be initialized with the corresponding value below and never change.\n  In this case, the `expandBuffer(..)` operation does nothing.\n */\nprivate const val BUFFER_END_RENDEZVOUS = 0L // no buffer\nprivate const val BUFFER_END_UNLIMITED = Long.MAX_VALUE // infinite buffer\nprivate fun initialBufferEnd(capacity: Int): Long = when (capacity) {\n    Channel.RENDEZVOUS -> BUFFER_END_RENDEZVOUS\n    Channel.UNLIMITED -> BUFFER_END_UNLIMITED\n    else -> capacity.toLong()\n}\n\n/*\n  Cell states. The initial \"empty\" state is represented with `null`,\n  and suspended operations are represented with [Waiter] instances.\n */\n\n// The cell stores a buffered element.\n@JvmField\ninternal val BUFFERED = Symbol(\"BUFFERED\")\n// Concurrent `expandBuffer(..)` can inform the\n// upcoming sender that it should buffer the element.\nprivate val IN_BUFFER = Symbol(\"SHOULD_BUFFER\")\n// Indicates that a receiver (RCV suffix) is resuming\n// the suspended sender; after that, it should update\n// the state to either `DONE_RCV` (on success) or\n// `INTERRUPTED_SEND` (on failure).\nprivate val RESUMING_BY_RCV = Symbol(\"S_RESUMING_BY_RCV\")\n// Indicates that `expandBuffer(..)` (RCV suffix) is resuming\n// the suspended sender; after that, it should update\n// the state to either `BUFFERED` (on success) or\n// `INTERRUPTED_SEND` (on failure).\nprivate val RESUMING_BY_EB = Symbol(\"RESUMING_BY_EB\")\n// When a receiver comes to the cell already covered by\n// a sender (according to the counters), but the cell\n// is still in `EMPTY` or `IN_BUFFER` state, it breaks\n// the cell by changing its state to `POISONED`.\nprivate val POISONED = Symbol(\"POISONED\")\n// When the element is successfully transferred\n// to a receiver, the cell changes to `DONE_RCV`.\nprivate val DONE_RCV = Symbol(\"DONE_RCV\")\n// Cancelled sender.\nprivate val INTERRUPTED_SEND = Symbol(\"INTERRUPTED_SEND\")\n// Cancelled receiver.\nprivate val INTERRUPTED_RCV = Symbol(\"INTERRUPTED_RCV\")\n// Indicates that the channel is closed.\ninternal val CHANNEL_CLOSED = Symbol(\"CHANNEL_CLOSED\")\n// When the cell is already covered by both sender and\n// receiver (`sender` and `receivers` counters are greater\n// than the cell number), the `expandBuffer(..)` procedure\n// cannot distinguish which kind of operation is stored\n// in the cell. Thus, it wraps the waiter with this descriptor,\n// informing the possibly upcoming receiver that it should\n// complete the `expandBuffer(..)` procedure if the waiter stored\n// in the cell is sender. In turn, senders ignore this information.\nprivate class WaiterEB(@JvmField val waiter: Waiter) {\n    override fun toString() = \"WaiterEB($waiter)\"\n}\n\n\n\n/**\n * To distinguish suspended [BufferedChannel.receive] and\n * [BufferedChannel.receiveCatching] operations, the latter\n * uses this wrapper for its continuation.\n */\nprivate class ReceiveCatching<E>(\n    @JvmField val cont: CancellableContinuationImpl<ChannelResult<E>>\n) : Waiter by cont\n\n/*\n  Internal results for [BufferedChannel.updateCellReceive].\n  On successful rendezvous with waiting sender or\n  buffered element retrieval, the corresponding element\n  is returned as result of [BufferedChannel.updateCellReceive].\n */\nprivate val SUSPEND = Symbol(\"SUSPEND\")\nprivate val SUSPEND_NO_WAITER = Symbol(\"SUSPEND_NO_WAITER\")\nprivate val FAILED = Symbol(\"FAILED\")\n\n/*\n  Internal results for [BufferedChannel.updateCellSend]\n */\nprivate const val RESULT_RENDEZVOUS = 0\nprivate const val RESULT_BUFFERED = 1\nprivate const val RESULT_SUSPEND = 2\nprivate const val RESULT_SUSPEND_NO_WAITER = 3\nprivate const val RESULT_CLOSED = 4\nprivate const val RESULT_FAILED = 5\n\n/**\n * Special value for [BufferedChannel.BufferedChannelIterator.receiveResult]\n * that indicates the absence of pre-received result.\n */\nprivate val NO_RECEIVE_RESULT = Symbol(\"NO_RECEIVE_RESULT\")\n\n/*\n  As [BufferedChannel.invokeOnClose] can be invoked concurrently\n  with channel closing, we have to synchronize them. These two\n  markers help with the synchronization.\n */\nprivate val CLOSE_HANDLER_CLOSED = Symbol(\"CLOSE_HANDLER_CLOSED\")\nprivate val CLOSE_HANDLER_INVOKED = Symbol(\"CLOSE_HANDLER_INVOKED\")\n\n/**\n * Specifies the absence of closing cause, stored in [BufferedChannel._closeCause].\n * When the channel is closed or cancelled without exception, this [NO_CLOSE_CAUSE]\n * marker should be replaced with `null`.\n */\nprivate val NO_CLOSE_CAUSE = Symbol(\"NO_CLOSE_CAUSE\")\n\n/*\n  The channel close statuses. The transition scheme is the following:\n    +--------+   +----------------------+   +-----------+\n    | ACTIVE |-->| CANCELLATION_STARTED |-->| CANCELLED |\n    +--------+   +----------------------+   +-----------+\n        |                                         ^\n        |             +--------+                  |\n        +------------>| CLOSED |------------------+\n                      +--------+\n  We need `CANCELLATION_STARTED` to synchronize\n  concurrent closing and cancellation.\n */\nprivate const val CLOSE_STATUS_ACTIVE = 0\nprivate const val CLOSE_STATUS_CANCELLATION_STARTED = 1\nprivate const val CLOSE_STATUS_CLOSED = 2\nprivate const val CLOSE_STATUS_CANCELLED = 3\n\n/*\n  The `senders` counter and the channel close status\n  are stored in a single 64-bit register to save the space\n  and reduce the number of reads in sending operations.\n  The code below encapsulates the required bit arithmetics.\n */\nprivate const val SENDERS_CLOSE_STATUS_SHIFT = 60\nprivate const val SENDERS_COUNTER_MASK = (1L shl SENDERS_CLOSE_STATUS_SHIFT) - 1\nprivate inline val Long.sendersCounter get() = this and SENDERS_COUNTER_MASK\nprivate inline val Long.sendersCloseStatus: Int get() = (this shr SENDERS_CLOSE_STATUS_SHIFT).toInt()\nprivate fun constructSendersAndCloseStatus(counter: Long, closeStatus: Int): Long =\n    (closeStatus.toLong() shl SENDERS_CLOSE_STATUS_SHIFT) + counter\n\n/*\n  The `completedExpandBuffersAndPauseFlag` 64-bit counter contains\n  the number of completed `expandBuffer()` attempts along with a special\n  flag that pauses progress to avoid starvation in `waitExpandBufferCompletion(..)`.\n  The code below encapsulates the required bit arithmetics.\n */\nprivate const val EB_COMPLETED_PAUSE_EXPAND_BUFFERS_BIT = 1L shl 62\nprivate const val EB_COMPLETED_COUNTER_MASK = EB_COMPLETED_PAUSE_EXPAND_BUFFERS_BIT - 1\nprivate inline val Long.ebCompletedCounter get() = this and EB_COMPLETED_COUNTER_MASK\nprivate inline val Long.ebPauseExpandBuffers: Boolean get() = (this and EB_COMPLETED_PAUSE_EXPAND_BUFFERS_BIT) != 0L\nprivate fun constructEBCompletedAndPauseFlag(counter: Long, pauseEB: Boolean): Long =\n    (if (pauseEB) EB_COMPLETED_PAUSE_EXPAND_BUFFERS_BIT else 0) + counter\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/Channel.kt",
        "content": "@file:Suppress(\"FunctionName\")\n\npackage kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.Channel.Factory.BUFFERED\nimport kotlinx.coroutines.channels.Channel.Factory.CHANNEL_DEFAULT_CAPACITY\nimport kotlinx.coroutines.channels.Channel.Factory.CONFLATED\nimport kotlinx.coroutines.channels.Channel.Factory.RENDEZVOUS\nimport kotlinx.coroutines.channels.Channel.Factory.UNLIMITED\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.contracts.*\nimport kotlin.internal.*\nimport kotlin.jvm.*\n\n/**\n * Sender's interface to [Channel].\n */\npublic interface SendChannel<in E> {\n    /**\n     * Returns `true` if this channel was closed by an invocation of [close] or its receiving side was [cancelled][ReceiveChannel.cancel].\n     * This means that calling [send] will result in an exception.\n     *\n     * Note that if this property returns `false`, it does not guarantee that consecutive call to [send] will succeed, as the\n     * channel can be concurrently closed right after the check. For such scenarios, it is recommended to use [trySend] instead.\n     *\n     * @see SendChannel.trySend\n     * @see SendChannel.close\n     * @see ReceiveChannel.cancel\n     */\n    @DelicateCoroutinesApi\n    public val isClosedForSend: Boolean\n\n    /**\n     * Sends the specified [element] to this channel, suspending the caller while the buffer of this channel is full\n     * or if it does not exist, or throws an exception if the channel [is closed for `send`][isClosedForSend] (see [close] for details).\n     *\n     * [Closing][close] a channel _after_ this function has suspended does not cause this suspended [send] invocation\n     * to abort, because closing a channel is conceptually like sending a special \"close token\" over this channel.\n     * All elements sent over the channel are delivered in first-in first-out order. The sent element\n     * will be delivered to receivers before the close token.\n     *\n     * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n     * suspending function is waiting, this function immediately resumes with [CancellationException].\n     * There is a **prompt cancellation guarantee**: even if [send] managed to send the element, but was cancelled\n     * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n     *\n     * Because of the prompt cancellation guarantee, an exception does not always mean a failure to deliver the element.\n     * See \"Undelivered elements\" section in [Channel] documentation for details on handling undelivered elements.\n     *\n     * Note that this function does not check for cancellation when it is not suspended.\n     * Use [yield] or [CoroutineScope.isActive] to periodically check for cancellation in tight loops if needed.\n     *\n     * This function can be used in [select] invocations with the [onSend] clause.\n     * Use [trySend] to try sending to this channel without waiting.\n     */\n    public suspend fun send(element: E)\n\n    /**\n     * Clause for the [select] expression of the [send] suspending function that selects when the element that is specified\n     * as the parameter is sent to the channel. When the clause is selected, the reference to this channel\n     * is passed into the corresponding block.\n     *\n     * The [select] invocation fails with an exception if the channel [is closed for `send`][isClosedForSend] (see [close] for details).\n     */\n    public val onSend: SelectClause2<E, SendChannel<E>>\n\n    /**\n     * Immediately adds the specified [element] to this channel, if this doesn't violate its capacity restrictions,\n     * and returns the successful result. Otherwise, returns failed or closed result.\n     * This is synchronous variant of [send], which backs off in situations when `send` suspends or throws.\n     *\n     * When `trySend` call returns a non-successful result, it guarantees that the element was not delivered to the consumer, and\n     * it does not call `onUndeliveredElement` that was installed for this channel.\n     * See \"Undelivered elements\" section in [Channel] documentation for details on handling undelivered elements.\n     */\n    public fun trySend(element: E): ChannelResult<Unit>\n\n    /**\n     * Closes this channel.\n     * This is an idempotent operation &mdash; subsequent invocations of this function have no effect and return `false`.\n     * Conceptually, it sends a special \"close token\" over this channel.\n     *\n     * Immediately after invocation of this function,\n     * [isClosedForSend] starts returning `true`. However, [isClosedForReceive][ReceiveChannel.isClosedForReceive]\n     * on the side of [ReceiveChannel] starts returning `true` only after all previously sent elements\n     * are received.\n     *\n     * A channel that was closed without a [cause] throws a [ClosedSendChannelException] on attempts to [send]\n     * and [ClosedReceiveChannelException] on attempts to [receive][ReceiveChannel.receive].\n     * A channel that was closed with non-null [cause] is called a _failed_ channel. Attempts to send or\n     * receive on a failed channel throw the specified [cause] exception.\n     */\n    public fun close(cause: Throwable? = null): Boolean\n\n    /**\n     * Registers a [handler] which is synchronously invoked once the channel is [closed][close]\n     * or the receiving side of this channel is [cancelled][ReceiveChannel.cancel].\n     * Only one handler can be attached to a channel during its lifetime.\n     * The `handler` is invoked when [isClosedForSend] starts to return `true`.\n     * If the channel is closed already, the handler is invoked immediately.\n     *\n     * The meaning of `cause` that is passed to the handler:\n     * - `null` if the channel was closed normally without the corresponding argument.\n     * - Instance of [CancellationException] if the channel was cancelled normally without the corresponding argument.\n     * - The cause of `close` or `cancel` otherwise.\n     *\n     * ### Execution context and exception safety\n     *\n     * The [handler] is executed as part of the closing or cancelling operation, and only after the channel reaches its final state.\n     * This means that if the handler throws an exception or hangs, the channel will still be successfully closed or cancelled.\n     * Unhandled exceptions from [handler] are propagated to the closing or cancelling operation's caller.\n     *\n     * Example of usage:\n     * ```\n     * val events = Channel<Event>(UNLIMITED)\n     * callbackBasedApi.registerCallback { event ->\n     *   events.trySend(event)\n     *       .onClosed { /* channel is already closed, but the callback hasn't stopped yet */ }\n     * }\n     *\n     * val uiUpdater = uiScope.launch(Dispatchers.Main) {\n     *    events.consume { /* handle events */ }\n     * }\n     * // Stop the callback after the channel is closed or cancelled\n     * events.invokeOnClose { callbackBasedApi.stop() }\n     * ```\n     *\n     * **Stability note.** This function constitutes a stable API surface, with the only exception being\n     * that an [IllegalStateException] is thrown when multiple handlers are registered.\n     * This restriction could be lifted in the future.\n     *\n     * @throws UnsupportedOperationException if the underlying channel does not support [invokeOnClose].\n     * Implementation note: currently, [invokeOnClose] is unsupported only by Rx-like integrations\n     *\n     * @throws IllegalStateException if another handler was already registered\n     */\n    public fun invokeOnClose(handler: (cause: Throwable?) -> Unit)\n\n    /**\n     * **Deprecated** offer method.\n     *\n     * This method was deprecated in the favour of [trySend].\n     * It has proven itself as the most error-prone method in Channel API:\n     *\n     * - `Boolean` return type creates the false sense of security, implying that `false`\n     *    is returned instead of throwing an exception.\n     * - It was used mostly from non-suspending APIs where CancellationException triggered\n     *   internal failures in the application (the most common source of bugs).\n     * - Due to signature and explicit `if (ch.offer(...))` checks it was easy to\n     *   oversee such error during code review.\n     * - Its name was not aligned with the rest of the API and tried to mimic Java's queue instead.\n     *\n     * **NB** Automatic migration provides best-effort for the user experience, but requires removal\n     * or adjusting of the code that relied on the exception handling.\n     * The complete replacement has a more verbose form:\n     * ```\n     * channel.trySend(element)\n     *     .onClosed { throw it ?: ClosedSendChannelException(\"Channel was closed normally\") }\n     *     .isSuccess\n     * ```\n     *\n     * See https://github.com/Kotlin/kotlinx.coroutines/issues/974 for more context.\n     *\n     * @suppress **Deprecated**.\n     */\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message = \"Deprecated in the favour of 'trySend' method\",\n        replaceWith = ReplaceWith(\"trySend(element).isSuccess\")\n    ) // Warning since 1.5.0, error since 1.6.0, not hidden until 1.8+ because API is quite widespread\n    public fun offer(element: E): Boolean {\n        val result = trySend(element)\n        if (result.isSuccess) return true\n        throw recoverStackTrace(result.exceptionOrNull() ?: return false)\n    }\n}\n\n/**\n * Receiver's interface to [Channel].\n */\npublic interface ReceiveChannel<out E> {\n    /**\n     * Returns `true` if this channel was closed by invocation of [close][SendChannel.close] on the [SendChannel]\n     * side and all previously sent items were already received, or if the receiving side was [cancelled][ReceiveChannel.cancel].\n     *\n     * This means that calling [receive] will result in a [ClosedReceiveChannelException] or a corresponding cancellation cause.\n     * If the channel was closed because of an exception, it is considered closed, too, but is called a _failed_ channel.\n     * All suspending attempts to receive an element from a failed channel throw the original [close][SendChannel.close] cause exception.\n     *\n     * Note that if this property returns `false`, it does not guarantee that consecutive call to [receive] will succeed, as the\n     * channel can be concurrently closed right after the check. For such scenarios, it is recommended to use [receiveCatching] instead.\n     *\n     * @see ReceiveChannel.receiveCatching\n     * @see ReceiveChannel.cancel\n     * @see SendChannel.close\n     */\n    @DelicateCoroutinesApi\n    public val isClosedForReceive: Boolean\n\n    /**\n     * Returns `true` if the channel is empty (contains no elements), which means that an attempt to [receive] will suspend.\n     * This function returns `false` if the channel [is closed for `receive`][isClosedForReceive].\n     */\n    @ExperimentalCoroutinesApi\n    public val isEmpty: Boolean\n\n    /**\n     * Retrieves and removes an element from this channel if it's not empty, or suspends the caller while the channel is empty,\n     * or throws a [ClosedReceiveChannelException] if the channel [is closed for `receive`][isClosedForReceive].\n     * If the channel was closed because of an exception, it is called a _failed_ channel and this function\n     * will throw the original [close][SendChannel.close] cause exception.\n     *\n     * This suspending function is cancellable. If the [Job] of the current coroutine is cancelled while this\n     * function is suspended, this function immediately resumes with a [CancellationException].\n     * There is a **prompt cancellation guarantee**. If the job was cancelled while this function was\n     * suspended, it will not resume successfully. The `receive` call can retrieve the element from the channel,\n     * but then throw [CancellationException], thus failing to deliver the element.\n     * See \"Undelivered elements\" section in [Channel] documentation for details on handling undelivered elements.\n     *\n     * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n     * suspending function is waiting, this function immediately resumes with [CancellationException].\n     * There is a **prompt cancellation guarantee**: even if [receive] managed to retrieve the element from the channel,\n     * but was cancelled while suspended, [CancellationException] will be thrown.\n     * See [suspendCancellableCoroutine] for low-level details.\n     *\n     * Because of the prompt cancellation guarantee, some values retrieved from the channel can become lost.\n     * See \"Undelivered elements\" section in [Channel] documentation for details on handling undelivered elements.\n     *\n     * Note that this function does not check for cancellation when it is not suspended.\n     * Use [yield] or [CoroutineScope.isActive] to periodically check for cancellation in tight loops if needed.\n     *\n     * This function can be used in [select] invocations with the [onReceive] clause.\n     * Use [tryReceive] to try receiving from this channel without waiting.\n     */\n    public suspend fun receive(): E\n\n    /**\n     * Clause for the [select] expression of the [receive] suspending function that selects with the element\n     * received from the channel.\n     * The [select] invocation fails with an exception if the channel\n     * [is closed for `receive`][isClosedForReceive] (see [close][SendChannel.close] for details).\n     */\n    public val onReceive: SelectClause1<E>\n\n    /**\n     * Retrieves and removes an element from this channel if it's not empty, or suspends the caller while this channel is empty.\n     * This method returns [ChannelResult] with the value of an element successfully retrieved from the channel\n     * or the close cause if the channel was closed. Closed cause may be `null` if the channel was closed normally.\n     * The result cannot be [failed][ChannelResult.isFailure] without being [closed][ChannelResult.isClosed].\n     *\n     * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n     * suspending function is waiting, this function immediately resumes with [CancellationException].\n     * There is a **prompt cancellation guarantee**: even if [receiveCatching] managed to retrieve the element from the\n     * channel, but was cancelled while suspended, [CancellationException] will be thrown.\n     * See [suspendCancellableCoroutine] for low-level details.\n     *\n     * Because of the prompt cancellation guarantee, some values retrieved from the channel can become lost.\n     * See \"Undelivered elements\" section in [Channel] documentation for details on handling undelivered elements.\n     *\n     * Note that this function does not check for cancellation when it is not suspended.\n     * Use [yield] or [CoroutineScope.isActive] to periodically check for cancellation in tight loops if needed.\n     *\n     * This function can be used in [select] invocations with the [onReceiveCatching] clause.\n     * Use [tryReceive] to try receiving from this channel without waiting.\n     */\n    public suspend fun receiveCatching(): ChannelResult<E>\n\n    /**\n     * Clause for the [select] expression of the [onReceiveCatching] suspending function that selects with the [ChannelResult] with a value\n     * that is received from the channel or with a close cause if the channel\n     * [is closed for `receive`][isClosedForReceive].\n     */\n    public val onReceiveCatching: SelectClause1<ChannelResult<E>>\n\n    /**\n     * Retrieves and removes an element from this channel if it's not empty, returning a [successful][ChannelResult.success]\n     * result, returns [failed][ChannelResult.failed] result if the channel is empty, and [closed][ChannelResult.closed]\n     * result if the channel is closed.\n     */\n    public fun tryReceive(): ChannelResult<E>\n\n    /**\n     * Returns a new iterator to receive elements from this channel using a `for` loop.\n     * Iteration completes normally when the channel [is closed for `receive`][isClosedForReceive] without a cause and\n     * throws the original [close][SendChannel.close] cause exception if the channel has _failed_.\n     */\n    public operator fun iterator(): ChannelIterator<E>\n\n    /**\n     * Cancels reception of remaining elements from this channel with an optional [cause].\n     * This function closes the channel and removes all buffered sent elements from it.\n     *\n     * A cause can be used to specify an error message or to provide other details on\n     * the cancellation reason for debugging purposes.\n     * If the cause is not specified, then an instance of [CancellationException] with a\n     * default message is created to [close][SendChannel.close] the channel.\n     *\n     * Immediately after invocation of this function [isClosedForReceive] and\n     * [isClosedForSend][SendChannel.isClosedForSend]\n     * on the side of [SendChannel] start returning `true`. Any attempt to send to or receive from this channel\n     * will lead to a [CancellationException].\n     */\n    public fun cancel(cause: CancellationException? = null)\n\n    /**\n     * @suppress This method implements old version of JVM ABI. Use [cancel].\n     */\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n    public fun cancel(): Unit = cancel(null)\n\n    /**\n     * @suppress This method has bad semantics when cause is not a [CancellationException]. Use [cancel].\n     */\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n    public fun cancel(cause: Throwable? = null): Boolean\n\n    /**\n     * **Deprecated** poll method.\n     *\n     * This method was deprecated in the favour of [tryReceive].\n     * It has proven itself as error-prone method in Channel API:\n     *\n     * - Nullable return type creates the false sense of security, implying that `null`\n     *    is returned instead of throwing an exception.\n     * - It was used mostly from non-suspending APIs where CancellationException triggered\n     *   internal failures in the application (the most common source of bugs).\n     * - Its name was not aligned with the rest of the API and tried to mimic Java's queue instead.\n     *\n     * See https://github.com/Kotlin/kotlinx.coroutines/issues/974 for more context.\n     *\n     * ### Replacement note\n     *\n     * The replacement `tryReceive().getOrNull()` is a default that ignores all close exceptions and\n     * proceeds with `null`, while `poll` throws an exception if the channel was closed with an exception.\n     * Replacement with the very same 'poll' semantics is `tryReceive().onClosed { if (it != null) throw it }.getOrNull()`\n     *\n     * @suppress **Deprecated**.\n     */\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message = \"Deprecated in the favour of 'tryReceive'. \" +\n            \"Please note that the provided replacement does not rethrow channel's close cause as 'poll' did, \" +\n            \"for the precise replacement please refer to the 'poll' documentation\",\n        replaceWith = ReplaceWith(\"tryReceive().getOrNull()\")\n    ) // Warning since 1.5.0, error since 1.6.0, not hidden until 1.8+ because API is quite widespread\n    public fun poll(): E? {\n        val result = tryReceive()\n        if (result.isSuccess) return result.getOrThrow()\n        throw recoverStackTrace(result.exceptionOrNull() ?: return null)\n    }\n\n    /**\n     * This function was deprecated since 1.3.0 and is no longer recommended to use\n     * or to implement in subclasses.\n     *\n     * It had the following pitfalls:\n     * - Didn't allow to distinguish 'null' as \"closed channel\" from \"null as a value\"\n     * - Was throwing if the channel has failed even though its signature may suggest it returns 'null'\n     * - It didn't really belong to core channel API and can be exposed as an extension instead.\n     *\n     * ### Replacement note\n     *\n     * The replacement `receiveCatching().getOrNull()` is a safe default that ignores all close exceptions and\n     * proceeds with `null`, while `receiveOrNull` throws an exception if the channel was closed with an exception.\n     * Replacement with the very same `receiveOrNull` semantics is `receiveCatching().onClosed { if (it != null) throw it }.getOrNull()`.\n     *\n     * @suppress **Deprecated**\n     */\n    @Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n    @LowPriorityInOverloadResolution\n    @Deprecated(\n        message = \"Deprecated in favor of 'receiveCatching'. \" +\n            \"Please note that the provided replacement does not rethrow channel's close cause as 'receiveOrNull' did, \" +\n            \"for the detailed replacement please refer to the 'receiveOrNull' documentation\",\n        level = DeprecationLevel.ERROR,\n        replaceWith = ReplaceWith(\"receiveCatching().getOrNull()\")\n    ) // Warning since 1.3.0, error in 1.5.0, cannot be hidden due to deprecated extensions\n    public suspend fun receiveOrNull(): E? = receiveCatching().getOrNull()\n\n    /**\n     * This function was deprecated since 1.3.0 and is no longer recommended to use\n     * or to implement in subclasses.\n     * See [receiveOrNull] documentation.\n     *\n     * @suppress **Deprecated**: in favor of onReceiveCatching extension.\n     */\n    @Suppress(\"DEPRECATION_ERROR\")\n    @Deprecated(\n        message = \"Deprecated in favor of onReceiveCatching extension\",\n        level = DeprecationLevel.ERROR,\n        replaceWith = ReplaceWith(\"onReceiveCatching\")\n    ) // Warning since 1.3.0, error in 1.5.0, will be hidden or removed in 1.7.0\n    public val onReceiveOrNull: SelectClause1<E?> get() = (this as BufferedChannel<E>).onReceiveOrNull\n}\n\n/**\n * A discriminated union of channel operation result.\n * It encapsulates the successful or failed result of a channel operation or a failed operation to a closed channel with\n * an optional cause.\n *\n * The successful result represents a successful operation with a value of type [T], for example,\n * the result of [Channel.receiveCatching] operation or a successfully sent element as a result of [Channel.trySend].\n *\n * The failed result represents a failed operation attempt to a channel, but it doesn't necessarily indicate that the channel is failed.\n * E.g. when the channel is full, [Channel.trySend] returns failed result, but the channel itself is not in the failed state.\n *\n * The closed result represents an operation attempt to a closed channel and also implies that the operation has failed.\n * It is guaranteed that if the result is _closed_, then the target channel is either [closed for send][Channel.isClosedForSend]\n * or is [closed for receive][Channel.isClosedForReceive] depending on whether the failed operation was sending or receiving.\n */\n@JvmInline\npublic value class ChannelResult<out T>\n@PublishedApi internal constructor(@PublishedApi internal val holder: Any?) {\n    /**\n     * Returns `true` if this instance represents a successful\n     * operation outcome.\n     *\n     * In this case [isFailure] and [isClosed] return `false`.\n     */\n    public val isSuccess: Boolean get() = holder !is Failed\n\n    /**\n     * Returns `true` if this instance represents unsuccessful operation.\n     *\n     * In this case [isSuccess] returns false, but it does not imply\n     * that the channel is failed or closed.\n     *\n     * Example of a failed operation without an exception and channel being closed\n     * is [Channel.trySend] attempt to a channel that is full.\n     */\n    public val isFailure: Boolean get() = holder is Failed\n\n    /**\n     * Returns `true` if this instance represents unsuccessful operation\n     * to a closed or cancelled channel.\n     *\n     * In this case [isSuccess] returns `false`, [isFailure] returns `true`, but it does not imply\n     * that [exceptionOrNull] returns non-null value.\n     *\n     * It can happen if the channel was [closed][Channel.close] normally without an exception.\n     */\n    public val isClosed: Boolean get() = holder is Closed\n\n    /**\n     * Returns the encapsulated value if this instance represents success or `null` if it represents failed result.\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    public fun getOrNull(): T? = if (holder !is Failed) holder as T else null\n\n    /**\n     *  Returns the encapsulated value if this instance represents success or throws an exception if it is closed or failed.\n     */\n    public fun getOrThrow(): T {\n        @Suppress(\"UNCHECKED_CAST\")\n        if (holder !is Failed) return holder as T\n        if (holder is Closed && holder.cause != null) throw holder.cause\n        error(\"Trying to call 'getOrThrow' on a failed channel result: $holder\")\n    }\n\n    /**\n     * Returns the encapsulated exception if this instance represents failure or `null` if it is success\n     * or unsuccessful operation to closed channel.\n     */\n    public fun exceptionOrNull(): Throwable? = (holder as? Closed)?.cause\n\n    internal open class Failed {\n        override fun toString(): String = \"Failed\"\n    }\n\n    internal class Closed(@JvmField val cause: Throwable?): Failed() {\n        override fun equals(other: Any?): Boolean = other is Closed && cause == other.cause\n        override fun hashCode(): Int = cause.hashCode()\n        override fun toString(): String = \"Closed($cause)\"\n    }\n\n    @InternalCoroutinesApi\n    public companion object {\n        private val failed = Failed()\n\n        @InternalCoroutinesApi\n        public fun <E> success(value: E): ChannelResult<E> =\n            ChannelResult(value)\n\n        @InternalCoroutinesApi\n        public fun <E> failure(): ChannelResult<E> =\n            ChannelResult(failed)\n\n        @InternalCoroutinesApi\n        public fun <E> closed(cause: Throwable?): ChannelResult<E> =\n            ChannelResult(Closed(cause))\n    }\n\n    public override fun toString(): String =\n        when (holder) {\n            is Closed -> holder.toString()\n            else -> \"Value($holder)\"\n        }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][ChannelResult.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is failed or closed\n * result.\n */\n@OptIn(ExperimentalContracts::class)\npublic inline fun <T> ChannelResult<T>.getOrElse(onFailure: (exception: Throwable?) -> T): T {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (holder is ChannelResult.Failed) onFailure(exceptionOrNull()) else holder as T\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][ChannelResult.isSuccess].\n * Returns the original `ChannelResult` unchanged.\n */\n@OptIn(ExperimentalContracts::class)\npublic inline fun <T> ChannelResult<T>.onSuccess(action: (value: T) -> Unit): ChannelResult<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    if (holder !is ChannelResult.Failed) action(holder as T)\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][ChannelResult.isFailure].\n * The result of [ChannelResult.exceptionOrNull] is passed to the [action] parameter.\n *\n * Returns the original `ChannelResult` unchanged.\n */\n@OptIn(ExperimentalContracts::class)\npublic inline fun <T> ChannelResult<T>.onFailure(action: (exception: Throwable?) -> Unit): ChannelResult<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (holder is ChannelResult.Failed) action(exceptionOrNull())\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][ChannelResult.isFailure]\n * due to channel being [closed][Channel.close].\n * The result of [ChannelResult.exceptionOrNull] is passed to the [action] parameter.\n * It is guaranteed that if action is invoked, then the channel is either [closed for send][Channel.isClosedForSend]\n * or is [closed for receive][Channel.isClosedForReceive] depending on the failed operation.\n *\n * Returns the original `ChannelResult` unchanged.\n */\n@OptIn(ExperimentalContracts::class)\npublic inline fun <T> ChannelResult<T>.onClosed(action: (exception: Throwable?) -> Unit): ChannelResult<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (holder is ChannelResult.Closed) action(exceptionOrNull())\n    return this\n}\n\n/**\n * Iterator for [ReceiveChannel]. Instances of this interface are *not thread-safe* and shall not be used\n * from concurrent coroutines.\n */\npublic interface ChannelIterator<out E> {\n    /**\n     * Returns `true` if the channel has more elements, suspending the caller while this channel is empty,\n     * or returns `false` if the channel [is closed for `receive`][ReceiveChannel.isClosedForReceive] without a cause.\n     * It throws the original [close][SendChannel.close] cause exception if the channel has _failed_.\n     *\n     * This function retrieves and removes an element from this channel for the subsequent invocation\n     * of [next].\n     *\n     * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n     * suspending function is waiting, this function immediately resumes with [CancellationException].\n     * There is a **prompt cancellation guarantee**: even if [hasNext] retrieves the element from the channel during\n     * its operation, but was cancelled while suspended, [CancellationException] will be thrown.\n     * See [suspendCancellableCoroutine] for low-level details.\n     *\n     * Because of the prompt cancellation guarantee, some values retrieved from the channel can become lost.\n     * See \"Undelivered elements\" section in [Channel] documentation for details on handling undelivered elements.\n     *\n     * Note that this function does not check for cancellation when it is not suspended.\n     * Use [yield] or [CoroutineScope.isActive] to periodically check for cancellation in tight loops if needed.\n     */\n    public suspend operator fun hasNext(): Boolean\n\n    @Deprecated(message = \"Since 1.3.0, binary compatibility with versions <= 1.2.x\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"INAPPLICABLE_JVM_NAME\")\n    @JvmName(\"next\")\n    public suspend fun next0(): E {\n        /*\n         * Before 1.3.0 the \"next()\" could have been used without invoking \"hasNext\" first and there were code samples\n         * demonstrating this behavior, so we preserve this logic for full binary backwards compatibility with previously\n         * compiled code.\n         */\n        if (!hasNext()) throw ClosedReceiveChannelException(DEFAULT_CLOSE_MESSAGE)\n        return next()\n    }\n\n    /**\n     * Retrieves the element removed from the channel by a preceding call to [hasNext], or\n     * throws an [IllegalStateException] if [hasNext] was not invoked.\n     * This method should only be used in pair with [hasNext]:\n     * ```\n     * while (iterator.hasNext()) {\n     *     val element = iterator.next()\n     *     // ... handle element ...\n     * }\n     * ```\n     *\n     * This method throws a [ClosedReceiveChannelException] if the channel [is closed for `receive`][ReceiveChannel.isClosedForReceive] without a cause.\n     * It throws the original [close][SendChannel.close] cause exception if the channel has _failed_.\n     */\n    public operator fun next(): E\n}\n\n/**\n * Channel is a non-blocking primitive for communication between a sender (via [SendChannel]) and a receiver (via [ReceiveChannel]).\n * Conceptually, a channel is similar to Java's [BlockingQueue][java.util.concurrent.BlockingQueue],\n * but it has suspending operations instead of blocking ones and can be [closed][SendChannel.close].\n *\n * ### Creating channels\n *\n * The `Channel(capacity)` factory function is used to create channels of different kinds depending on\n * the value of the `capacity` integer:\n *\n * - When `capacity` is 0 &mdash; it creates a _rendezvous_ channel.\n *   This channel does not have any buffer at all. An element is transferred from the sender\n *   to the receiver only when [send] and [receive] invocations meet in time (rendezvous), so [send] suspends\n *   until another coroutine invokes [receive], and [receive] suspends until another coroutine invokes [send].\n *\n * - When `capacity` is [Channel.UNLIMITED] &mdash; it creates a channel with effectively unlimited buffer.\n *   This channel has a linked-list buffer of unlimited capacity (limited only by available memory).\n *   [Sending][send] to this channel never suspends, and [trySend] always succeeds.\n *\n * - When `capacity` is [Channel.CONFLATED] &mdash; it creates a _conflated_ channel\n *   This channel buffers at most one element and conflates all subsequent `send` and `trySend` invocations,\n *   so that the receiver always gets the last element sent.\n *   Back-to-back sent elements are conflated &mdash; only the last sent element is received,\n *   while previously sent elements **are lost**.\n *   [Sending][send] to this channel never suspends, and [trySend] always succeeds.\n *\n * - When `capacity` is positive but less than [UNLIMITED] &mdash; it creates an array-based channel with the specified capacity.\n *   This channel has an array buffer of a fixed `capacity`.\n *   [Sending][send] suspends only when the buffer is full, and [receiving][receive] suspends only when the buffer is empty.\n *\n * Buffered channels can be configured with an additional [`onBufferOverflow`][BufferOverflow] parameter. It controls the behaviour\n * of the channel's [send][Channel.send] function on buffer overflow:\n *\n * - [SUSPEND][BufferOverflow.SUSPEND] &mdash; the default, suspend `send` on buffer overflow until there is\n *   free space in the buffer.\n * - [DROP_OLDEST][BufferOverflow.DROP_OLDEST] &mdash; do not suspend the `send`, add the latest value to the buffer,\n *   drop the oldest one from the buffer.\n *   A channel with `capacity = 1` and `onBufferOverflow = DROP_OLDEST` is a _conflated_ channel.\n * - [DROP_LATEST][BufferOverflow.DROP_LATEST] &mdash; do not suspend the `send`, drop the value that is being sent,\n *   keep the buffer contents intact.\n *\n * A non-default `onBufferOverflow` implicitly creates a channel with at least one buffered element and\n * is ignored for a channel with unlimited buffer. It cannot be specified for `capacity = CONFLATED`, which\n * is a shortcut by itself.\n *\n * ### Prompt cancellation guarantee\n *\n * All suspending functions with channels provide **prompt cancellation guarantee**.\n * If the job was cancelled while send or receive function was suspended, it will not resume successfully, even if it\n * already changed the channel's state, but throws a [CancellationException].\n * With a single-threaded [dispatcher][CoroutineDispatcher] like [Dispatchers.Main], this gives a\n * guarantee that the coroutine promptly reacts to the cancellation of its [Job] and does not resume its execution.\n *\n * > **Prompt cancellation guarantee** for channel operations was added since `kotlinx.coroutines` version `1.4.0`\n * > and had replaced a channel-specific atomic-cancellation that was not consistent with other suspending functions.\n * > The low-level mechanics of prompt cancellation are explained in [suspendCancellableCoroutine] function.\n *\n * ### Undelivered elements\n *\n * As a result of the prompt cancellation guarantee, when a closeable resource\n * (like open file or a handle to another native resource) is transferred via a channel from one coroutine to another,\n * it can fail to be delivered and will be lost if the receiving operation is cancelled in transit.\n *\n * A `Channel()` constructor function has an `onUndeliveredElement` optional parameter.\n * When `onUndeliveredElement` parameter is set, the corresponding function is called once for each element\n * that was sent to the channel with the call to the [send][SendChannel.send] function but failed to be delivered,\n * which can happen in the following cases:\n *\n * - When [send][SendChannel.send] operation throws an exception because it was cancelled before it had a chance to actually\n *   send the element or because the channel was [closed][SendChannel.close] or [cancelled][ReceiveChannel.cancel].\n * - When [receive][ReceiveChannel.receive], [receiveOrNull][ReceiveChannel.receiveOrNull], or [hasNext][ChannelIterator.hasNext]\n *   operation throws an exception when it had retrieved the element from the\n *   channel but was cancelled before the code following the receive call resumed.\n * - The channel was [cancelled][ReceiveChannel.cancel], in which case `onUndeliveredElement` is called on every\n *   remaining element in the channel's buffer.\n *\n * Note, that `onUndeliveredElement` function is called synchronously in an arbitrary context. It should be fast, non-blocking,\n * and should not throw exceptions. Any exception thrown by `onUndeliveredElement` is wrapped into an internal runtime\n * exception which is either rethrown from the caller method or handed off to the exception handler in the current context\n * (see [CoroutineExceptionHandler]) when one is available.\n *\n * A typical usage for `onUndeliveredElement` is to close a resource that is being transferred via the channel. The\n * following code pattern guarantees that opened resources are closed even if producer, consumer, and/or channel\n * are cancelled. Resources are never lost.\n *\n * ```\n * // Create the channel with onUndeliveredElement block that closes a resource\n * val channel = Channel<Resource>(capacity) { resource -> resource.close() }\n *\n * // Producer code\n * val resourceToSend = openResource()\n * channel.send(resourceToSend)\n *\n * // Consumer code\n * val resourceReceived = channel.receive()\n * try {\n *     // work with received resource\n * } finally {\n *     resourceReceived.close()\n * }\n * ```\n *\n * > Note, that if you do any kind of work in between `openResource()` and `channel.send(...)`, then you should\n * > ensure that resource gets closed in case this additional code fails.\n */\npublic interface Channel<E> : SendChannel<E>, ReceiveChannel<E> {\n    /**\n     * Constants for the channel factory function `Channel()`.\n     */\n    public companion object Factory {\n        /**\n         * Requests a channel with an unlimited capacity buffer in the `Channel(...)` factory function.\n         */\n        public const val UNLIMITED: Int = Int.MAX_VALUE\n\n        /**\n         * Requests a rendezvous channel in the `Channel(...)` factory function &mdash; a channel that does not have a buffer.\n         */\n        public const val RENDEZVOUS: Int = 0\n\n        /**\n         * Requests a conflated channel in the `Channel(...)` factory function. This is a shortcut to creating\n         * a channel with [`onBufferOverflow = DROP_OLDEST`][BufferOverflow.DROP_OLDEST].\n         */\n        public const val CONFLATED: Int = -1\n\n        /**\n         * Requests a buffered channel with the default buffer capacity in the `Channel(...)` factory function.\n         * The default capacity for a channel that [suspends][BufferOverflow.SUSPEND] on overflow\n         * is 64 and can be overridden by setting [DEFAULT_BUFFER_PROPERTY_NAME] on JVM.\n         * For non-suspending channels, a buffer of capacity 1 is used.\n         */\n        public const val BUFFERED: Int = -2\n\n        // only for internal use, cannot be used with Channel(...)\n        internal const val OPTIONAL_CHANNEL = -3\n\n        /**\n         * Name of the property that defines the default channel capacity when\n         * [BUFFERED] is used as parameter in `Channel(...)` factory function.\n         */\n        public const val DEFAULT_BUFFER_PROPERTY_NAME: String = \"kotlinx.coroutines.channels.defaultBuffer\"\n\n        internal val CHANNEL_DEFAULT_CAPACITY = systemProp(DEFAULT_BUFFER_PROPERTY_NAME,\n            64, 1, UNLIMITED - 1\n        )\n    }\n}\n\n/**\n * Creates a channel with the specified buffer capacity (or without a buffer by default).\n * See [Channel] interface documentation for details.\n *\n * @param capacity either a positive channel capacity or one of the constants defined in [Channel.Factory].\n * @param onBufferOverflow configures an action on buffer overflow (optional, defaults to\n *   a [suspending][BufferOverflow.SUSPEND] attempt to [send][Channel.send] a value,\n *   supported only when `capacity >= 0` or `capacity == Channel.BUFFERED`,\n *   implicitly creates a channel with at least one buffered element).\n * @param onUndeliveredElement an optional function that is called when element was sent but was not delivered to the consumer.\n *   See \"Undelivered elements\" section in [Channel] documentation.\n * @throws IllegalArgumentException when [capacity] < -2\n */\npublic fun <E> Channel(\n    capacity: Int = RENDEZVOUS,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND,\n    onUndeliveredElement: ((E) -> Unit)? = null\n): Channel<E> =\n    when (capacity) {\n        RENDEZVOUS -> {\n            if (onBufferOverflow == BufferOverflow.SUSPEND)\n                BufferedChannel(RENDEZVOUS, onUndeliveredElement) // an efficient implementation of rendezvous channel\n            else\n                ConflatedBufferedChannel(1, onBufferOverflow, onUndeliveredElement) // support buffer overflow with buffered channel\n        }\n        CONFLATED -> {\n            require(onBufferOverflow == BufferOverflow.SUSPEND) {\n                \"CONFLATED capacity cannot be used with non-default onBufferOverflow\"\n            }\n            ConflatedBufferedChannel(1, BufferOverflow.DROP_OLDEST, onUndeliveredElement)\n        }\n        UNLIMITED -> BufferedChannel(UNLIMITED, onUndeliveredElement) // ignores onBufferOverflow: it has buffer, but it never overflows\n        BUFFERED -> { // uses default capacity with SUSPEND\n            if (onBufferOverflow == BufferOverflow.SUSPEND) BufferedChannel(CHANNEL_DEFAULT_CAPACITY, onUndeliveredElement)\n            else ConflatedBufferedChannel(1, onBufferOverflow, onUndeliveredElement)\n        }\n        else -> {\n            if (onBufferOverflow === BufferOverflow.SUSPEND) BufferedChannel(capacity, onUndeliveredElement)\n            else ConflatedBufferedChannel(capacity, onBufferOverflow, onUndeliveredElement)\n        }\n    }\n\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.4.0, binary compatibility with earlier versions\")\npublic fun <E> Channel(capacity: Int = RENDEZVOUS): Channel<E> = Channel(capacity)\n\n/**\n * Indicates an attempt to [send][SendChannel.send] to a [isClosedForSend][SendChannel.isClosedForSend] channel\n * that was closed without a cause. A _failed_ channel rethrows the original [close][SendChannel.close] cause\n * exception on send attempts.\n *\n * This exception is a subclass of [IllegalStateException], because, conceptually, it is the sender's responsibility\n * to close the channel and not try to send anything thereafter. Attempts to\n * send to a closed channel indicate a logical error in the sender's code.\n */\npublic class ClosedSendChannelException(message: String?) : IllegalStateException(message)\n\n/**\n * Indicates an attempt to [receive][ReceiveChannel.receive] from a [isClosedForReceive][ReceiveChannel.isClosedForReceive]\n * channel that was closed without a cause. A _failed_ channel rethrows the original [close][SendChannel.close] cause\n * exception on receive attempts.\n *\n * This exception is a subclass of [NoSuchElementException] to be consistent with plain collections.\n */\npublic class ClosedReceiveChannelException(message: String?) : NoSuchElementException(message)\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/ChannelCoroutine.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\ninternal open class ChannelCoroutine<E>(\n    parentContext: CoroutineContext,\n    protected val _channel: Channel<E>,\n    initParentJob: Boolean,\n    active: Boolean\n) : AbstractCoroutine<Unit>(parentContext, initParentJob, active), Channel<E> by _channel {\n\n    val channel: Channel<E> get() = this\n\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n    override fun cancel() {\n        cancelInternal(defaultCancellationException())\n    }\n\n    @Suppress(\"MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_DEPRECATION_WARNING\") // do not remove the MULTIPLE_DEFAULTS suppression: required in K2\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n    final override fun cancel(cause: Throwable?): Boolean {\n        cancelInternal(defaultCancellationException())\n        return true\n    }\n\n    @Suppress(\"MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_DEPRECATION_WARNING\") // do not remove the MULTIPLE_DEFAULTS suppression: required in K2\n    final override fun cancel(cause: CancellationException?) {\n        if (isCancelled) return // Do not create an exception if the coroutine (-> the channel) is already cancelled\n        cancelInternal(cause ?: defaultCancellationException())\n    }\n\n    override fun cancelInternal(cause: Throwable) {\n        val exception = cause.toCancellationException()\n        _channel.cancel(exception) // cancel the channel\n        cancelCoroutine(exception) // cancel the job\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/Channels.common.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"ChannelsKt\")\n@file:OptIn(ExperimentalContracts::class)\n\npackage kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.contracts.*\nimport kotlin.jvm.*\n\ninternal const val DEFAULT_CLOSE_MESSAGE = \"Channel was closed\"\n\n\n// -------- Operations on BroadcastChannel --------\n\n/**\n * This function is deprecated in the favour of [ReceiveChannel.receiveCatching].\n *\n * This function is considered error-prone for the following reasons;\n * - Is throwing if the channel has failed even though its signature may suggest it returns 'null'\n * - It is easy to forget that exception handling still have to be explicit\n * - During code reviews and code reading, intentions of the code are frequently unclear:\n *   are potential exceptions ignored deliberately or not?\n *\n * @suppress doc\n */\n@Deprecated(\n    \"Deprecated in the favour of 'receiveCatching'\",\n    ReplaceWith(\"receiveCatching().getOrNull()\"),\n    DeprecationLevel.HIDDEN\n) // Warning since 1.5.0, ERROR in 1.6.0, HIDDEN in 1.7.0\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION_ERROR\")\npublic suspend fun <E : Any> ReceiveChannel<E>.receiveOrNull(): E? {\n    @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n    return (this as ReceiveChannel<E?>).receiveOrNull()\n}\n\n/**\n * This function is deprecated in the favour of [ReceiveChannel.onReceiveCatching]\n */\n@Deprecated(\n    \"Deprecated in the favour of 'onReceiveCatching'\",\n    level = DeprecationLevel.HIDDEN\n)  // Warning since 1.5.0, ERROR in 1.6.0, HIDDEN in 1.7.0\n@Suppress(\"DEPRECATION_ERROR\")\npublic fun <E : Any> ReceiveChannel<E>.onReceiveOrNull(): SelectClause1<E?> {\n    return (this as ReceiveChannel<E?>).onReceiveOrNull\n}\n\n/**\n * Makes sure that the given [block] consumes all elements from the given channel\n * by always invoking [cancel][ReceiveChannel.cancel] after the execution of the block.\n *\n * The operation is _terminal_.\n */\npublic inline fun <E, R> ReceiveChannel<E>.consume(block: ReceiveChannel<E>.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    var cause: Throwable? = null\n    try {\n        return block()\n    } catch (e: Throwable) {\n        cause = e\n        throw e\n    } finally {\n        cancelConsumed(cause)\n    }\n}\n\n/**\n * Performs the given [action] for each received element and [cancels][ReceiveChannel.cancel]\n * the channel after the execution of the block.\n * If you need to iterate over the channel without consuming it, a regular `for` loop should be used instead.\n *\n * The operation is _terminal_.\n * This function [consumes][ReceiveChannel.consume] all elements of the original [ReceiveChannel].\n */\npublic suspend inline fun <E> ReceiveChannel<E>.consumeEach(action: (E) -> Unit): Unit =\n    consume {\n        for (e in this) action(e)\n    }\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n * This function [consumes][ReceiveChannel.consume] all elements of the original [ReceiveChannel].\n */\npublic suspend fun <E> ReceiveChannel<E>.toList(): List<E> = buildList {\n    consumeEach {\n        add(it)\n    }\n}\n\n@PublishedApi\ninternal fun ReceiveChannel<*>.cancelConsumed(cause: Throwable?) {\n    cancel(cause?.let {\n        it as? CancellationException ?: CancellationException(\"Channel was consumed, consumer had failed\", it)\n    })\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/ConflatedBufferedChannel.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.channels.BufferOverflow.*\nimport kotlinx.coroutines.channels.ChannelResult.Companion.closed\nimport kotlinx.coroutines.channels.ChannelResult.Companion.success\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.internal.OnUndeliveredElement\nimport kotlinx.coroutines.selects.*\nimport kotlin.coroutines.*\n\n/**\n * This is a special [BufferedChannel] extension that supports [DROP_OLDEST] and [DROP_LATEST]\n * strategies for buffer overflowing. This implementation ensures that `send(e)` never suspends,\n * either extracting the first element ([DROP_OLDEST]) or dropping the sending one ([DROP_LATEST])\n * when the channel capacity exceeds.\n */\ninternal open class ConflatedBufferedChannel<E>(\n    private val capacity: Int,\n    private val onBufferOverflow: BufferOverflow,\n    onUndeliveredElement: OnUndeliveredElement<E>? = null\n) : BufferedChannel<E>(capacity = capacity, onUndeliveredElement = onUndeliveredElement) {\n    init {\n        require(onBufferOverflow !== SUSPEND) {\n            \"This implementation does not support suspension for senders, use ${BufferedChannel::class.simpleName} instead\"\n        }\n        require(capacity >= 1) {\n            \"Buffered channel capacity must be at least 1, but $capacity was specified\"\n        }\n    }\n\n    override val isConflatedDropOldest: Boolean\n        get() = onBufferOverflow == DROP_OLDEST\n\n    override suspend fun send(element: E) {\n        // Should never suspend, implement via `trySend(..)`.\n        trySendImpl(element, isSendOp = true).onClosed { // fails only when this channel is closed.\n            onUndeliveredElement?.callUndeliveredElementCatchingException(element)?.let {\n                it.addSuppressed(sendException)\n                throw it\n            }\n            throw sendException\n        }\n    }\n\n    override suspend fun sendBroadcast(element: E): Boolean {\n        // Should never suspend, implement via `trySend(..)`.\n        trySendImpl(element, isSendOp = true) // fails only when this channel is closed.\n            .onSuccess { return true }\n        return false\n    }\n\n    override fun trySend(element: E): ChannelResult<Unit> = trySendImpl(element, isSendOp = false)\n\n    private fun trySendImpl(element: E, isSendOp: Boolean) =\n        if (onBufferOverflow === DROP_LATEST) trySendDropLatest(element, isSendOp)\n        else trySendDropOldest(element)\n\n    private fun trySendDropLatest(element: E, isSendOp: Boolean): ChannelResult<Unit> {\n        // Try to send the element without suspension.\n        val result = super.trySend(element)\n        // Complete on success or if this channel is closed.\n        if (result.isSuccess || result.isClosed) return result\n        // This channel is full. Drop the sending element.\n        // Call the `onUndeliveredElement` lambda ONLY for 'send()' invocations,\n        // for 'trySend()' it is responsibility of the caller\n        if (isSendOp) {\n            onUndeliveredElement?.callUndeliveredElementCatchingException(element)?.let {\n                throw it\n            }\n        }\n        return success(Unit)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun registerSelectForSend(select: SelectInstance<*>, element: Any?) {\n        // The plain `send(..)` operation never suspends. Thus, either this\n        // attempt to send the element succeeds or the channel is closed.\n        // In any case, complete this `select` in the registration phase.\n        trySend(element as E).let {\n            it.onSuccess {\n                select.selectInRegistrationPhase(Unit)\n                return\n            }.onClosed {\n                select.selectInRegistrationPhase(CHANNEL_CLOSED)\n                return\n            }\n        }\n        error(\"unreachable\")\n    }\n\n    override fun shouldSendSuspend() = false // never suspends.\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/Deprecated.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"ChannelsKt\")\n@file:Suppress(\"unused\")\n\npackage kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * Opens subscription to this [BroadcastChannel] and makes sure that the given [block] consumes all elements\n * from it by always invoking [cancel][ReceiveChannel.cancel] after the execution of the block.\n *\n * **Note: This API is obsolete since 1.5.0 and deprecated for removal since 1.7.0**\n * It is replaced with [SharedFlow][kotlinx.coroutines.flow.SharedFlow].\n *\n * Safe to remove in 1.9.0 as was inline before.\n */\n@ObsoleteCoroutinesApi\n@Suppress(\"DEPRECATION\")\n@Deprecated(level = DeprecationLevel.ERROR, message = \"BroadcastChannel is deprecated in the favour of SharedFlow and is no longer supported\")\npublic inline fun <E, R> BroadcastChannel<E>.consume(block: ReceiveChannel<E>.() -> R): R {\n    val channel = openSubscription()\n    try {\n        return channel.block()\n    } finally {\n        channel.cancel()\n    }\n}\n\n/**\n * Subscribes to this [BroadcastChannel] and performs the specified action for each received element.\n *\n * **Note: This API is obsolete since 1.5.0 and deprecated for removal since 1.7.0**\n */\n@Deprecated(level = DeprecationLevel.ERROR, message = \"BroadcastChannel is deprecated in the favour of SharedFlow and is no longer supported\")\n@Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npublic suspend inline fun <E> BroadcastChannel<E>.consumeEach(action: (E) -> Unit): Unit =\n    consume {\n        for (element in this) action(element)\n    }\n\n/** @suppress **/\n@PublishedApi // Binary compatibility\ninternal fun consumesAll(vararg channels: ReceiveChannel<*>): CompletionHandler =\n    { cause: Throwable? ->\n        var exception: Throwable? = null\n        for (channel in channels)\n            try {\n                channel.cancelConsumed(cause)\n            } catch (e: Throwable) {\n                if (exception == null) {\n                    exception = e\n                } else {\n                    exception.addSuppressed(e)\n                }\n            }\n        exception?.let { throw it }\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.elementAt(index: Int): E = consume {\n    if (index < 0)\n        throw IndexOutOfBoundsException(\"ReceiveChannel doesn't contain element at index $index.\")\n    var count = 0\n    for (element in this) {\n        @Suppress(\"UNUSED_CHANGED_VALUE\") // KT-47628\n        if (index == count++)\n            return element\n    }\n    throw IndexOutOfBoundsException(\"ReceiveChannel doesn't contain element at index $index.\")\n}\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.elementAtOrNull(index: Int): E? =\n    consume {\n        if (index < 0)\n            return null\n        var count = 0\n        for (element in this) {\n            if (index == count++)\n                return element\n        }\n        return null\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.first(): E =\n    consume {\n        val iterator = iterator()\n        if (!iterator.hasNext())\n            throw NoSuchElementException(\"ReceiveChannel is empty.\")\n        return iterator.next()\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.firstOrNull(): E? =\n    consume {\n        val iterator = iterator()\n        if (!iterator.hasNext())\n            return null\n        return iterator.next()\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.indexOf(element: E): Int {\n    var index = 0\n    consumeEach {\n        if (element == it)\n            return index\n        index++\n    }\n    return -1\n}\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.last(): E =\n    consume {\n        val iterator = iterator()\n        if (!iterator.hasNext())\n            throw NoSuchElementException(\"ReceiveChannel is empty.\")\n        var last = iterator.next()\n        while (iterator.hasNext())\n            last = iterator.next()\n        return last\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.lastIndexOf(element: E): Int {\n    var lastIndex = -1\n    var index = 0\n    consumeEach {\n        if (element == it)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.lastOrNull(): E? =\n    consume {\n        val iterator = iterator()\n        if (!iterator.hasNext())\n            return null\n        var last = iterator.next()\n        while (iterator.hasNext())\n            last = iterator.next()\n        return last\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.single(): E =\n    consume {\n        val iterator = iterator()\n        if (!iterator.hasNext())\n            throw NoSuchElementException(\"ReceiveChannel is empty.\")\n        val single = iterator.next()\n        if (iterator.hasNext())\n            throw IllegalArgumentException(\"ReceiveChannel has more than one element.\")\n        return single\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.singleOrNull(): E? =\n    consume {\n        val iterator = iterator()\n        if (!iterator.hasNext())\n            return null\n        val single = iterator.next()\n        if (iterator.hasNext())\n            return null\n        return single\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E> ReceiveChannel<E>.drop(n: Int, context: CoroutineContext = Dispatchers.Unconfined): ReceiveChannel<E> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        require(n >= 0) { \"Requested element count $n is less than zero.\" }\n        var remaining: Int = n\n        if (remaining > 0)\n            for (e in this@drop) {\n                remaining--\n                if (remaining == 0)\n                    break\n            }\n        for (e in this@drop) {\n            send(e)\n        }\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E> ReceiveChannel<E>.dropWhile(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    predicate: suspend (E) -> Boolean\n): ReceiveChannel<E> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        for (e in this@dropWhile) {\n            if (!predicate(e)) {\n                send(e)\n                break\n            }\n        }\n        for (e in this@dropWhile) {\n            send(e)\n        }\n    }\n\n@PublishedApi\ninternal fun <E> ReceiveChannel<E>.filter(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    predicate: suspend (E) -> Boolean\n): ReceiveChannel<E> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        for (e in this@filter) {\n            if (predicate(e)) send(e)\n        }\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E> ReceiveChannel<E>.filterIndexed(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    predicate: suspend (index: Int, E) -> Boolean\n): ReceiveChannel<E> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        var index = 0\n        for (e in this@filterIndexed) {\n            if (predicate(index++, e)) send(e)\n        }\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E> ReceiveChannel<E>.filterNot(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    predicate: suspend (E) -> Boolean\n): ReceiveChannel<E> =\n    filter(context) { !predicate(it) }\n\n@PublishedApi\n@Suppress(\"UNCHECKED_CAST\")\ninternal fun <E : Any> ReceiveChannel<E?>.filterNotNull(): ReceiveChannel<E> =\n    filter { it != null } as ReceiveChannel<E>\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E : Any, C : MutableCollection<in E>> ReceiveChannel<E?>.filterNotNullTo(destination: C): C {\n    consumeEach {\n        if (it != null) destination.add(it)\n    }\n    return destination\n}\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E : Any, C : SendChannel<E>> ReceiveChannel<E?>.filterNotNullTo(destination: C): C {\n    consumeEach {\n        if (it != null) destination.send(it)\n    }\n    return destination\n}\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E> ReceiveChannel<E>.take(n: Int, context: CoroutineContext = Dispatchers.Unconfined): ReceiveChannel<E> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        if (n == 0) return@produce\n        require(n >= 0) { \"Requested element count $n is less than zero.\" }\n        var remaining: Int = n\n        for (e in this@take) {\n            send(e)\n            remaining--\n            if (remaining == 0)\n                return@produce\n        }\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E> ReceiveChannel<E>.takeWhile(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    predicate: suspend (E) -> Boolean\n): ReceiveChannel<E> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        for (e in this@takeWhile) {\n            if (!predicate(e)) return@produce\n            send(e)\n        }\n    }\n\n@PublishedApi\ninternal suspend fun <E, C : SendChannel<E>> ReceiveChannel<E>.toChannel(destination: C): C {\n    consumeEach {\n        destination.send(it)\n    }\n    return destination\n}\n\n@PublishedApi\ninternal suspend fun <E, C : MutableCollection<in E>> ReceiveChannel<E>.toCollection(destination: C): C {\n    consumeEach {\n        destination.add(it)\n    }\n    return destination\n}\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <K, V> ReceiveChannel<Pair<K, V>>.toMap(): Map<K, V> =\n    toMap(LinkedHashMap())\n\n@PublishedApi\ninternal suspend fun <K, V, M : MutableMap<in K, in V>> ReceiveChannel<Pair<K, V>>.toMap(destination: M): M {\n    consumeEach {\n        destination += it\n    }\n    return destination\n}\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.toMutableList(): MutableList<E> =\n    toCollection(ArrayList())\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.toSet(): Set<E> =\n    this.toMutableSet()\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E, R> ReceiveChannel<E>.flatMap(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    transform: suspend (E) -> ReceiveChannel<R>\n): ReceiveChannel<R> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        for (e in this@flatMap) {\n            transform(e).toChannel(this)\n        }\n    }\n\n@PublishedApi\ninternal fun <E, R> ReceiveChannel<E>.map(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    transform: suspend (E) -> R\n): ReceiveChannel<R> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        consumeEach {\n            send(transform(it))\n        }\n    }\n\n@PublishedApi\ninternal fun <E, R> ReceiveChannel<E>.mapIndexed(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    transform: suspend (index: Int, E) -> R\n): ReceiveChannel<R> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        var index = 0\n        for (e in this@mapIndexed) {\n            send(transform(index++, e))\n        }\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E, R : Any> ReceiveChannel<E>.mapIndexedNotNull(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    transform: suspend (index: Int, E) -> R?\n): ReceiveChannel<R> =\n    mapIndexed(context, transform).filterNotNull()\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E, R : Any> ReceiveChannel<E>.mapNotNull(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    transform: suspend (E) -> R?\n): ReceiveChannel<R> =\n    map(context, transform).filterNotNull()\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E> ReceiveChannel<E>.withIndex(context: CoroutineContext = Dispatchers.Unconfined): ReceiveChannel<IndexedValue<E>> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        var index = 0\n        for (e in this@withIndex) {\n            send(IndexedValue(index++, e))\n        }\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E> ReceiveChannel<E>.distinct(): ReceiveChannel<E> =\n    this.distinctBy { it }\n\n@PublishedApi\ninternal fun <E, K> ReceiveChannel<E>.distinctBy(\n    context: CoroutineContext = Dispatchers.Unconfined,\n    selector: suspend (E) -> K\n): ReceiveChannel<E> =\n    GlobalScope.produce(context, onCompletion = consumes()) {\n        val keys = HashSet<K>()\n        for (e in this@distinctBy) {\n            val k = selector(e)\n            if (k !in keys) {\n                send(e)\n                keys += k\n            }\n        }\n    }\n\n@PublishedApi\ninternal suspend fun <E> ReceiveChannel<E>.toMutableSet(): MutableSet<E> =\n    toCollection(LinkedHashSet())\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.any(): Boolean =\n    consume {\n        return iterator().hasNext()\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.count(): Int {\n    var count = 0\n    consumeEach { count++ }\n    return count\n}\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.maxWith(comparator: Comparator<in E>): E? =\n    consume {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return null\n        var max = iterator.next()\n        while (iterator.hasNext()) {\n            val e = iterator.next()\n            if (comparator.compare(max, e) < 0) max = e\n        }\n        return max\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.minWith(comparator: Comparator<in E>): E? =\n    consume {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return null\n        var min = iterator.next()\n        while (iterator.hasNext()) {\n            val e = iterator.next()\n            if (comparator.compare(min, e) > 0) min = e\n        }\n        return min\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic suspend fun <E> ReceiveChannel<E>.none(): Boolean =\n    consume {\n        return !iterator().hasNext()\n    }\n\n/** @suppress **/\n@Deprecated(message = \"Left for binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun <E : Any> ReceiveChannel<E?>.requireNoNulls(): ReceiveChannel<E> =\n    map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n\n/** @suppress **/\n@Deprecated(message = \"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic infix fun <E, R> ReceiveChannel<E>.zip(other: ReceiveChannel<R>): ReceiveChannel<Pair<E, R>> =\n    zip(other) { t1, t2 -> t1 to t2 }\n\n@PublishedApi // Binary compatibility\ninternal fun <E, R, V> ReceiveChannel<E>.zip(\n    other: ReceiveChannel<R>,\n    context: CoroutineContext = Dispatchers.Unconfined,\n    transform: (a: E, b: R) -> V\n): ReceiveChannel<V> =\n    GlobalScope.produce(context, onCompletion = consumesAll(this, other)) {\n        val otherIterator = other.iterator()\n        this@zip.consumeEach { element1 ->\n            if (!otherIterator.hasNext()) return@consumeEach\n            val element2 = otherIterator.next()\n            send(transform(element1, element2))\n        }\n    }\n\n@PublishedApi // Binary compatibility\ninternal fun ReceiveChannel<*>.consumes(): CompletionHandler = { cause: Throwable? ->\n    cancelConsumed(cause)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/channels/Produce.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n/**\n * Scope for the [produce][CoroutineScope.produce], [callbackFlow] and [channelFlow] builders.\n */\npublic interface ProducerScope<in E> : CoroutineScope, SendChannel<E> {\n    /**\n     * A reference to the channel this coroutine [sends][send] elements to.\n     * It is provided for convenience, so that the code in the coroutine can refer\n     * to the channel as `channel` as opposed to `this`.\n     * All the [SendChannel] functions on this interface delegate to\n     * the channel instance returned by this property.\n     */\n    public val channel: SendChannel<E>\n}\n\n/**\n * Suspends the current coroutine until the channel is either [closed][SendChannel.close] or [cancelled][ReceiveChannel.cancel]\n * and invokes the given [block] before resuming the coroutine.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n *\n * Note that when the producer channel is cancelled, this function resumes with a cancellation exception.\n * Therefore, in case of cancellation, no code after the call to this function will be executed.\n * That's why this function takes a lambda parameter.\n *\n * Example of usage:\n * ```\n * val callbackEventsStream = produce {\n *     val disposable = registerChannelInCallback(channel)\n *     awaitClose { disposable.dispose() }\n * }\n * ```\n */\npublic suspend fun ProducerScope<*>.awaitClose(block: () -> Unit = {}) {\n    check(kotlin.coroutines.coroutineContext[Job] === this) { \"awaitClose() can only be invoked from the producer context\" }\n    try {\n        suspendCancellableCoroutine<Unit> { cont ->\n            invokeOnClose {\n                cont.resume(Unit)\n            }\n        }\n    } finally {\n        block()\n    }\n}\n\n/**\n * Launches a new coroutine to produce a stream of values by sending them to a channel\n * and returns a reference to the coroutine as a [ReceiveChannel]. This resulting\n * object can be used to [receive][ReceiveChannel.receive] elements produced by this coroutine.\n *\n * The scope of the coroutine contains the [ProducerScope] interface, which implements\n * both [CoroutineScope] and [SendChannel], so that the coroutine can invoke\n * [send][SendChannel.send] directly. The channel is [closed][SendChannel.close]\n * when the coroutine completes.\n * The running coroutine is cancelled when its receive channel is [cancelled][ReceiveChannel.cancel].\n *\n * The coroutine context is inherited from this [CoroutineScope]. Additional context elements can be specified with the [context] argument.\n * If the context does not have any dispatcher or other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * The parent job is inherited from the [CoroutineScope] as well, but it can also be overridden\n * with a corresponding [context] element.\n *\n * Any uncaught exception in this coroutine will close the channel with this exception as the cause and\n * the resulting channel will become _failed_, so that any attempt to receive from it thereafter will throw an exception.\n *\n * The kind of the resulting channel depends on the specified [capacity] parameter.\n * See the [Channel] interface documentation for details.\n *\n * See [newCoroutineContext] for a description of debugging facilities available for newly created coroutines.\n *\n * **Note: This is an experimental api.** Behaviour of producers that work as children in a parent scope with respect\n *        to cancellation and error handling may change in the future.\n *\n * @param context additional to [CoroutineScope.coroutineContext] context of the coroutine.\n * @param capacity capacity of the channel's buffer (no buffer by default).\n * @param block the coroutine code.\n */\n@ExperimentalCoroutinesApi\npublic fun <E> CoroutineScope.produce(\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = 0,\n    @BuilderInference block: suspend ProducerScope<E>.() -> Unit\n): ReceiveChannel<E> =\n    produce(context, capacity, BufferOverflow.SUSPEND, CoroutineStart.DEFAULT, onCompletion = null, block = block)\n\n/**\n * **This is an internal API and should not be used from general code.**\n * The `onCompletion` parameter will be redesigned.\n * If you have to use the `onCompletion` operator, please report to https://github.com/Kotlin/kotlinx.coroutines/issues/.\n * As a temporary solution, [invokeOnCompletion][Job.invokeOnCompletion] can be used instead:\n * ```\n * fun <E> ReceiveChannel<E>.myOperator(): ReceiveChannel<E> = GlobalScope.produce(Dispatchers.Unconfined) {\n *     coroutineContext[Job]?.invokeOnCompletion { consumes() }\n * }\n * ```\n * @suppress\n */\n@InternalCoroutinesApi\npublic fun <E> CoroutineScope.produce(\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = 0,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    onCompletion: CompletionHandler? = null,\n    @BuilderInference block: suspend ProducerScope<E>.() -> Unit\n): ReceiveChannel<E> =\n    produce(context, capacity, BufferOverflow.SUSPEND, start, onCompletion, block)\n\n// Internal version of produce that is maximally flexible, but is not exposed through public API (too many params)\ninternal fun <E> CoroutineScope.produce(\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = 0,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    onCompletion: CompletionHandler? = null,\n    @BuilderInference block: suspend ProducerScope<E>.() -> Unit\n): ReceiveChannel<E> {\n    val channel = Channel<E>(capacity, onBufferOverflow)\n    val newContext = newCoroutineContext(context)\n    val coroutine = ProducerCoroutine(newContext, channel)\n    if (onCompletion != null) coroutine.invokeOnCompletion(handler = onCompletion)\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n\nprivate class ProducerCoroutine<E>(\n    parentContext: CoroutineContext, channel: Channel<E>\n) : ChannelCoroutine<E>(parentContext, channel, true, active = true), ProducerScope<E> {\n    override val isActive: Boolean\n        get() = super.isActive\n\n    override fun onCompleted(value: Unit) {\n        _channel.close()\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        val processed = _channel.close(cause)\n        if (!processed && !handled) handleCoroutineException(context, cause)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/Builders.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.channels.Channel.Factory.BUFFERED\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\nimport kotlinx.coroutines.flow.internal.unsafeFlow as flow\n\n/**\n * Creates a _cold_ flow from the given suspendable [block].\n * The flow being _cold_ means that the [block] is called every time a terminal operator is applied to the resulting flow.\n *\n * Example of usage:\n *\n * ```\n * fun fibonacci(): Flow<BigInteger> = flow {\n *     var x = BigInteger.ZERO\n *     var y = BigInteger.ONE\n *     while (true) {\n *         emit(x)\n *         x = y.also {\n *             y += x\n *         }\n *     }\n * }\n *\n * fibonacci().take(100).collect { println(it) }\n * ```\n *\n * Emissions from [flow] builder are [cancellable] by default &mdash; each call to [emit][FlowCollector.emit]\n * also calls [ensureActive][CoroutineContext.ensureActive].\n *\n * `emit` should happen strictly in the dispatchers of the [block] in order to preserve the flow context.\n * For example, the following code will result in an [IllegalStateException]:\n *\n * ```\n * flow {\n *     emit(1) // Ok\n *     withContext(Dispatcher.IO) {\n *         emit(2) // Will fail with ISE\n *     }\n * }\n * ```\n *\n * If you want to switch the context of execution of a flow, use the [flowOn] operator.\n */\npublic fun <T> flow(@BuilderInference block: suspend FlowCollector<T>.() -> Unit): Flow<T> = SafeFlow(block)\n\n// Named anonymous object\nprivate class SafeFlow<T>(private val block: suspend FlowCollector<T>.() -> Unit) : AbstractFlow<T>() {\n    override suspend fun collectSafely(collector: FlowCollector<T>) {\n        collector.block()\n    }\n}\n\n/**\n * Creates a _cold_ flow that produces a single value from the given functional type.\n */\npublic fun <T> (() -> T).asFlow(): Flow<T> = flow {\n    emit(invoke())\n}\n\n/**\n * Creates a _cold_ flow that produces a single value from the given functional type.\n *\n * Example of usage:\n *\n * ```\n * suspend fun remoteCall(): R = ...\n * fun remoteCallFlow(): Flow<R> = ::remoteCall.asFlow()\n * ```\n */\npublic fun <T> (suspend () -> T).asFlow(): Flow<T> = flow {\n    emit(invoke())\n}\n\n/**\n * Creates a _cold_ flow that produces values from the given iterable.\n */\npublic fun <T> Iterable<T>.asFlow(): Flow<T> = flow {\n    forEach { value ->\n        emit(value)\n    }\n}\n\n/**\n * Creates a _cold_ flow that produces values from the given iterator.\n */\npublic fun <T> Iterator<T>.asFlow(): Flow<T> = flow {\n    forEach { value ->\n        emit(value)\n    }\n}\n\n/**\n * Creates a _cold_ flow that produces values from the given sequence.\n */\npublic fun <T> Sequence<T>.asFlow(): Flow<T> = flow {\n    forEach { value ->\n        emit(value)\n    }\n}\n\n/**\n * Creates a flow that produces values from the specified `vararg`-arguments.\n *\n * Example of usage:\n *\n * ```\n * flowOf(1, 2, 3)\n * ```\n */\npublic fun <T> flowOf(vararg elements: T): Flow<T> = flow {\n    for (element in elements) {\n        emit(element)\n    }\n}\n\n/**\n * Creates a flow that produces the given [value].\n */\npublic fun <T> flowOf(value: T): Flow<T> = flow {\n    /*\n     * Implementation note: this is just an \"optimized\" overload of flowOf(vararg)\n     * which significantly reduces the footprint of widespread single-value flows.\n     */\n    emit(value)\n}\n\n/**\n * Returns an empty flow.\n */\npublic fun <T> emptyFlow(): Flow<T> = EmptyFlow\n\nprivate object EmptyFlow : Flow<Nothing> {\n    override suspend fun collect(collector: FlowCollector<Nothing>) = Unit\n}\n\n/**\n * Creates a _cold_ flow that produces values from the given array.\n * The flow being _cold_ means that the array components are read every time a terminal operator is applied\n * to the resulting flow.\n */\npublic fun <T> Array<T>.asFlow(): Flow<T> = flow {\n    forEach { value ->\n        emit(value)\n    }\n}\n\n/**\n * Creates a _cold_ flow that produces values from the array.\n * The flow being _cold_ means that the array components are read every time a terminal operator is applied\n * to the resulting flow.\n */\npublic fun IntArray.asFlow(): Flow<Int> = flow {\n    forEach { value ->\n        emit(value)\n    }\n}\n\n/**\n * Creates a _cold_ flow that produces values from the given array.\n * The flow being _cold_ means that the array components are read every time a terminal operator is applied\n * to the resulting flow.\n */\npublic fun LongArray.asFlow(): Flow<Long> = flow {\n    forEach { value ->\n        emit(value)\n    }\n}\n\n/**\n * Creates a flow that produces values from the range.\n */\npublic fun IntRange.asFlow(): Flow<Int> = flow {\n    forEach { value ->\n        emit(value)\n    }\n}\n\n/**\n * Creates a flow that produces values from the range.\n */\npublic fun LongRange.asFlow(): Flow<Long> = flow {\n    forEach { value ->\n        emit(value)\n    }\n}\n\n/**\n * Creates an instance of a _cold_ [Flow] with elements that are sent to a [SendChannel]\n * provided to the builder's [block] of code via [ProducerScope]. It allows elements to be\n * produced by code that is running in a different context or concurrently.\n * The resulting flow is _cold_, which means that [block] is called every time a terminal operator\n * is applied to the resulting flow.\n *\n * This builder ensures thread-safety and context preservation, thus the provided [ProducerScope] can be used\n * concurrently from different contexts.\n * The resulting flow completes as soon as the code in the [block] and all its children completes.\n * Use [awaitClose] as the last statement to keep it running.\n * A more detailed example is provided in the documentation of [callbackFlow].\n *\n * A channel with the [default][Channel.BUFFERED] buffer size is used. Use the [buffer] operator on the\n * resulting flow to specify a user-defined value and to control what happens when data is produced faster\n * than consumed, i.e. to control the back-pressure behavior.\n *\n * Adjacent applications of [channelFlow], [flowOn], [buffer], and [produceIn] are\n * always fused so that only one properly configured channel is used for execution.\n *\n * Examples of usage:\n *\n * ```\n * fun <T> Flow<T>.merge(other: Flow<T>): Flow<T> = channelFlow {\n *     // collect from one coroutine and send it\n *     launch {\n *         collect { send(it) }\n *     }\n *     // collect and send from this coroutine, too, concurrently\n *     other.collect { send(it) }\n * }\n *\n * fun <T> contextualFlow(): Flow<T> = channelFlow {\n *     // send from one coroutine\n *     launch(Dispatchers.IO) {\n *         send(computeIoValue())\n *     }\n *     // send from another coroutine, concurrently\n *     launch(Dispatchers.Default) {\n *         send(computeCpuValue())\n *     }\n * }\n * ```\n */\npublic fun <T> channelFlow(@BuilderInference block: suspend ProducerScope<T>.() -> Unit): Flow<T> =\n    ChannelFlowBuilder(block)\n\n/**\n * Creates an instance of a _cold_ [Flow] with elements that are sent to a [SendChannel]\n * provided to the builder's [block] of code via [ProducerScope]. It allows elements to be\n * produced by code that is running in a different context or concurrently.\n *\n * The resulting flow is _cold_, which means that [block] is called every time a terminal operator\n * is applied to the resulting flow.\n *\n * This builder ensures thread-safety and context preservation, thus the provided [ProducerScope] can be used\n * from any context, e.g. from a callback-based API.\n * The resulting flow completes as soon as the code in the [block] completes.\n * [awaitClose] should be used to keep the flow running, otherwise the channel will be closed immediately\n * when block completes.\n * [awaitClose] argument is called either when a flow consumer cancels the flow collection\n * or when a callback-based API invokes [SendChannel.close] manually and is typically used\n * to cleanup the resources after the completion, e.g. unregister a callback.\n * Using [awaitClose] is mandatory in order to prevent memory leaks when the flow collection is cancelled,\n * otherwise the callback may keep running even when the flow collector is already completed.\n * To avoid such leaks, this method throws [IllegalStateException] if block returns, but the channel\n * is not closed yet.\n *\n * A channel with the [default][Channel.BUFFERED] buffer size is used. Use the [buffer] operator on the\n * resulting flow to specify a user-defined value and to control what happens when data is produced faster\n * than consumed, i.e. to control the back-pressure behavior.\n *\n * Adjacent applications of [callbackFlow], [flowOn], [buffer], and [produceIn] are\n * always fused so that only one properly configured channel is used for execution.\n *\n * Example of usage that converts a multi-shot callback API to a flow.\n * For single-shot callbacks use [suspendCancellableCoroutine].\n *\n * ```\n * fun flowFrom(api: CallbackBasedApi): Flow<T> = callbackFlow {\n *     val callback = object : Callback { // Implementation of some callback interface\n *         override fun onNextValue(value: T) {\n *             // To avoid blocking you can configure channel capacity using\n *             // either buffer(Channel.CONFLATED) or buffer(Channel.UNLIMITED) to avoid overfill\n *             trySendBlocking(value)\n *                 .onFailure { throwable ->\n *                     // Downstream has been cancelled or failed, can log here\n *                 }\n *         }\n *         override fun onApiError(cause: Throwable) {\n *             cancel(CancellationException(\"API Error\", cause))\n *         }\n *         override fun onCompleted() = channel.close()\n *     }\n *     api.register(callback)\n *     /*\n *      * Suspends until either 'onCompleted'/'onApiError' from the callback is invoked\n *      * or flow collector is cancelled (e.g. by 'take(1)' or because a collector's coroutine was cancelled).\n *      * In both cases, callback will be properly unregistered.\n *      */\n *     awaitClose { api.unregister(callback) }\n * }\n * ```\n *\n * > The callback `register`/`unregister` methods provided by an external API must be thread-safe, because\n * > `awaitClose` block can be called at any time due to asynchronous nature of cancellation, even\n * > concurrently with the call of the callback.\n */\npublic fun <T> callbackFlow(@BuilderInference block: suspend ProducerScope<T>.() -> Unit): Flow<T> = CallbackFlowBuilder(block)\n\n// ChannelFlow implementation that is the first in the chain of flow operations and introduces (builds) a flow\nprivate open class ChannelFlowBuilder<T>(\n    private val block: suspend ProducerScope<T>.() -> Unit,\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = BUFFERED,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n) : ChannelFlow<T>(context, capacity, onBufferOverflow) {\n    override fun create(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): ChannelFlow<T> =\n        ChannelFlowBuilder(block, context, capacity, onBufferOverflow)\n\n    override suspend fun collectTo(scope: ProducerScope<T>) =\n        block(scope)\n\n    override fun toString(): String =\n        \"block[$block] -> ${super.toString()}\"\n}\n\nprivate class CallbackFlowBuilder<T>(\n    private val block: suspend ProducerScope<T>.() -> Unit,\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = BUFFERED,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n) : ChannelFlowBuilder<T>(block, context, capacity, onBufferOverflow) {\n\n    override suspend fun collectTo(scope: ProducerScope<T>) {\n        super.collectTo(scope)\n        /*\n         * We expect user either call `awaitClose` from within a block (then the channel is closed at this moment)\n         * or being closed/cancelled externally/manually. Otherwise \"user forgot to call\n         * awaitClose and receives unhelpful ClosedSendChannelException exceptions\" situation is detected.\n         */\n        if (!scope.isClosedForSend) {\n            throw IllegalStateException(\n                \"\"\"\n                    'awaitClose { yourCallbackOrListener.cancel() }' should be used in the end of callbackFlow block.\n                    Otherwise, a callback/listener may leak in case of external cancellation.\n                    See callbackFlow API documentation for the details.\n                \"\"\".trimIndent()\n            )\n        }\n    }\n\n    override fun create(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): ChannelFlow<T> =\n        CallbackFlowBuilder(block, context, capacity, onBufferOverflow)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/Channels.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\nimport kotlinx.coroutines.flow.internal.unsafeFlow as flow\n\n/**\n * Emits all elements from the given [channel] to this flow collector and [cancels][cancel] (consumes)\n * the channel afterwards. If you need to iterate over the channel without consuming it,\n * a regular `for` loop should be used instead.\n *\n * Note, that emitting values from a channel into a flow is not atomic. A value that was received from the\n * channel many not reach the flow collector if it was cancelled and will be lost.\n *\n * This function provides a more efficient shorthand for `channel.consumeEach { value -> emit(value) }`.\n * See [consumeEach][ReceiveChannel.consumeEach].\n */\npublic suspend fun <T> FlowCollector<T>.emitAll(channel: ReceiveChannel<T>): Unit =\n    emitAllImpl(channel, consume = true)\n\nprivate suspend fun <T> FlowCollector<T>.emitAllImpl(channel: ReceiveChannel<T>, consume: Boolean) {\n    ensureActive()\n    var cause: Throwable? = null\n    try {\n        for (element in channel) {\n            emit(element)\n        }\n    } catch (e: Throwable) {\n        cause = e\n        throw e\n    } finally {\n        if (consume) channel.cancelConsumed(cause)\n    }\n}\n\n/**\n * Represents the given receive channel as a hot flow and [receives][ReceiveChannel.receive] from the channel\n * in fan-out fashion every time this flow is collected. One element will be emitted to one collector only.\n *\n * See also [consumeAsFlow] which ensures that the resulting flow is collected just once.\n *\n * ### Cancellation semantics\n *\n * - Flow collectors are cancelled when the original channel is [closed][SendChannel.close] with an exception.\n * - Flow collectors complete normally when the original channel is [closed][SendChannel.close] normally.\n * - Failure or cancellation of the flow collector does not affect the channel.\n *\n * ### Operator fusion\n *\n * Adjacent applications of [flowOn], [buffer], [conflate], and [produceIn] to the result of `receiveAsFlow` are fused.\n * In particular, [produceIn] returns the original channel.\n * Calls to [flowOn] have generally no effect, unless [buffer] is used to explicitly request buffering.\n */\npublic fun <T> ReceiveChannel<T>.receiveAsFlow(): Flow<T> = ChannelAsFlow(this, consume = false)\n\n/**\n * Represents the given receive channel as a hot flow and [consumes][ReceiveChannel.consume] the channel\n * on the first collection from this flow. The resulting flow can be collected just once and throws\n * [IllegalStateException] when trying to collect it more than once.\n *\n * See also [receiveAsFlow] which supports multiple collectors of the resulting flow.\n *\n * ### Cancellation semantics\n *\n * - Flow collector is cancelled when the original channel is [closed][SendChannel.close] with an exception.\n * - Flow collector completes normally when the original channel is [closed][SendChannel.close] normally.\n * - If the flow collector fails with an exception, the source channel is [cancelled][ReceiveChannel.cancel].\n *\n * ### Operator fusion\n *\n * Adjacent applications of [flowOn], [buffer], [conflate], and [produceIn] to the result of `consumeAsFlow` are fused.\n * In particular, [produceIn] returns the original channel (but throws [IllegalStateException] on repeated calls).\n * Calls to [flowOn] have generally no effect, unless [buffer] is used to explicitly request buffering.\n */\npublic fun <T> ReceiveChannel<T>.consumeAsFlow(): Flow<T> = ChannelAsFlow(this, consume = true)\n\n/**\n * Represents an existing [channel] as [ChannelFlow] implementation.\n * It fuses with subsequent [flowOn] operators, but for the most part ignores the specified context.\n * However, additional [buffer] calls cause a separate buffering channel to be created and that is where\n * the context might play a role, because it is used by the producing coroutine.\n */\nprivate class ChannelAsFlow<T>(\n    private val channel: ReceiveChannel<T>,\n    private val consume: Boolean,\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = Channel.OPTIONAL_CHANNEL,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n) : ChannelFlow<T>(context, capacity, onBufferOverflow) {\n    private val consumed = atomic(false)\n\n    private fun markConsumed() {\n        if (consume) {\n            check(!consumed.getAndSet(true)) { \"ReceiveChannel.consumeAsFlow can be collected just once\" }\n        }\n    }\n    \n    override fun create(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): ChannelFlow<T> =\n        ChannelAsFlow(channel, consume, context, capacity, onBufferOverflow)\n\n    override fun dropChannelOperators(): Flow<T> =\n        ChannelAsFlow(channel, consume)\n\n    override suspend fun collectTo(scope: ProducerScope<T>) =\n        SendingCollector(scope).emitAllImpl(channel, consume) // use efficient channel receiving code from emitAll\n\n    override fun produceImpl(scope: CoroutineScope): ReceiveChannel<T> {\n        markConsumed() // fail fast on repeated attempt to collect it\n        return if (capacity == Channel.OPTIONAL_CHANNEL) {\n            channel // direct\n        } else\n            super.produceImpl(scope) // extra buffering channel\n    }\n\n    override suspend fun collect(collector: FlowCollector<T>) {\n        if (capacity == Channel.OPTIONAL_CHANNEL) {\n            markConsumed()\n            collector.emitAllImpl(channel, consume) // direct\n        } else {\n            super.collect(collector) // extra buffering channel, produceImpl will mark it as consumed\n        }\n    }\n\n    override fun additionalToStringProps(): String = \"channel=$channel\"\n}\n\n/**\n * Represents the given broadcast channel as a hot flow.\n * Every flow collector will trigger a new broadcast channel subscription.\n *\n * ### Cancellation semantics\n * 1) Flow consumer is cancelled when the original channel is cancelled.\n * 2) Flow consumer completes normally when the original channel completes (~is closed) normally.\n * 3) If the flow consumer fails with an exception, subscription is cancelled.\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"'BroadcastChannel' is obsolete and all corresponding operators are deprecated \" +\n        \"in the favour of StateFlow and SharedFlow\"\n) // Since 1.5.0, ERROR since 1.7.0, was @FlowPreview, safe to remove in 1.8.0\npublic fun <T> BroadcastChannel<T>.asFlow(): Flow<T> = flow {\n    emitAll(openSubscription())\n}\n\n/**\n * Creates a [produce] coroutine that collects the given flow.\n *\n * This transformation is **stateful**, it launches a [produce] coroutine\n * that collects the given flow, and has the same behavior:\n *\n * - if collecting the flow throws, the channel will be closed with that exception\n * - if the [ReceiveChannel] is cancelled, the collection of the flow will be cancelled\n * - if collecting the flow completes normally, the [ReceiveChannel] will be closed normally\n *\n * A channel with [default][Channel.Factory.BUFFERED] buffer size is created.\n * Use [buffer] operator on the flow before calling `produceIn` to specify a value other than\n * default and to control what happens when data is produced faster than it is consumed,\n * that is to control backpressure behavior.\n */\npublic fun <T> Flow<T>.produceIn(\n    scope: CoroutineScope\n): ReceiveChannel<T> =\n    asChannelFlow().produceImpl(scope)\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/Flow.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.coroutines.*\n\n/**\n * An asynchronous data stream that sequentially emits values and completes normally or with an exception.\n *\n * _Intermediate operators_ on the flow such as [map], [filter], [take], [zip], etc are functions that are\n * applied to the _upstream_ flow or flows and return a _downstream_ flow where further operators can be applied to.\n * Intermediate operations do not execute any code in the flow and are not suspending functions themselves.\n * They only set up a chain of operations for future execution and quickly return.\n * This is known as a _cold flow_ property.\n *\n * _Terminal operators_ on the flow are either suspending functions such as [collect], [single], [reduce], [toList], etc.\n * or [launchIn] operator that starts collection of the flow in the given scope.\n * They are applied to the upstream flow and trigger execution of all operations.\n * Execution of the flow is also called _collecting the flow_  and is always performed in a suspending manner\n * without actual blocking. Terminal operators complete normally or exceptionally depending on successful or failed\n * execution of all the flow operations in the upstream. The most basic terminal operator is [collect], for example:\n *\n * ```\n * try {\n *     flow.collect { value ->\n *         println(\"Received $value\")\n *     }\n * } catch (e: Exception) {\n *     println(\"The flow has thrown an exception: $e\")\n * }\n * ```\n *\n * By default, flows are _sequential_ and all flow operations are executed sequentially in the same coroutine,\n * with an exception for a few operations specifically designed to introduce concurrency into flow\n * execution such as [buffer] and [flatMapMerge]. See their documentation for details.\n *\n * The `Flow` interface does not carry information whether a flow is a _cold_ stream that can be collected repeatedly and\n * triggers execution of the same code every time it is collected, or if it is a _hot_ stream that emits different\n * values from the same running source on each collection. Usually flows represent _cold_ streams, but\n * there is a [SharedFlow] subtype that represents _hot_ streams. In addition to that, any flow can be turned\n * into a _hot_ one by the [stateIn] and [shareIn] operators, or by converting the flow into a hot channel\n * via the [produceIn] operator.\n *\n * ### Flow builders\n *\n * There are the following basic ways to create a flow:\n *\n * - [flowOf(...)][flowOf] functions to create a flow from a fixed set of values.\n * - [asFlow()][asFlow] extension functions on various types to convert them into flows.\n * - [flow { ... }][flow] builder function to construct arbitrary flows from\n *   sequential calls to [emit][FlowCollector.emit] function.\n * - [channelFlow { ... }][channelFlow] builder function to construct arbitrary flows from\n *   potentially concurrent calls to the [send][kotlinx.coroutines.channels.SendChannel.send] function.\n * - [MutableStateFlow] and [MutableSharedFlow] define the corresponding constructor functions to create\n *   a _hot_ flow that can be directly updated.\n *\n * ### Flow constraints\n *\n * All implementations of the `Flow` interface must adhere to two key properties described in detail below:\n *\n * - Context preservation.\n * - Exception transparency.\n *\n * These properties ensure the ability to perform local reasoning about the code with flows and modularize the code\n * in such a way that upstream flow emitters can be developed separately from downstream flow collectors.\n * A user of a flow does not need to be aware of implementation details of the upstream flows it uses.\n *\n * ### Context preservation\n *\n * The flow has a context preservation property: it encapsulates its own execution context and never propagates or leaks\n * it downstream, thus making reasoning about the execution context of particular transformations or terminal\n * operations trivial.\n *\n * There is only one way to change the context of a flow: the [flowOn][Flow.flowOn] operator\n * that changes the upstream context (\"everything above the `flowOn` operator\").\n * For additional information refer to its documentation.\n *\n * This reasoning can be demonstrated in practice:\n *\n * ```\n * val flowA = flowOf(1, 2, 3)\n *     .map { it + 1 } // Will be executed in ctxA\n *     .flowOn(ctxA) // Changes the upstream context: flowOf and map\n *\n * // Now we have a context-preserving flow: it is executed somewhere but this information is encapsulated in the flow itself\n *\n * val filtered = flowA // ctxA is encapsulated in flowA\n *    .filter { it == 3 } // Pure operator without a context yet\n *\n * withContext(Dispatchers.Main) {\n *     // All non-encapsulated operators will be executed in Main: filter and single\n *     val result = filtered.single()\n *     myUi.text = result\n * }\n * ```\n *\n * From the implementation point of view, it means that all flow implementations should\n * only emit from the same coroutine.\n * This constraint is efficiently enforced by the default [flow] builder.\n * The [flow] builder should be used if the flow implementation does not start any coroutines.\n * Its implementation prevents most of the development mistakes:\n *\n * ```\n * val myFlow = flow {\n *    // GlobalScope.launch { // is prohibited\n *    // launch(Dispatchers.IO) { // is prohibited\n *    // withContext(CoroutineName(\"myFlow\")) { // is prohibited\n *    emit(1) // OK\n *    coroutineScope {\n *        emit(2) // OK -- still the same coroutine\n *    }\n * }\n * ```\n *\n * Use [channelFlow] if the collection and emission of a flow are to be separated into multiple coroutines.\n * It encapsulates all the context preservation work and allows you to focus on your\n * domain-specific problem, rather than invariant implementation details.\n * It is possible to use any combination of coroutine builders from within [channelFlow].\n *\n * If you are looking for performance and are sure that no concurrent emits and context jumps will happen,\n * the [flow] builder can be used alongside a [coroutineScope] or [supervisorScope] instead:\n *  - Scoped primitive should be used to provide a [CoroutineScope].\n *  - Changing the context of emission is prohibited, no matter whether it is `withContext(ctx)` or\n *    a builder argument (e.g. `launch(ctx)`).\n *  - Collecting another flow from a separate context is allowed, but it has the same effect as\n *    applying the [flowOn] operator to that flow, which is more efficient.\n *\n * ### Exception transparency\n *\n * When `emit` or `emitAll` throws, the Flow implementations must immediately stop emitting new values and finish with an exception.\n * For diagnostics or application-specific purposes, the exception may be different from the one thrown by the emit operation,\n * suppressing the original exception as discussed below.\n * If there is a need to emit values after the downstream failed, please use the [catch][Flow.catch] operator.\n *\n * The [catch][Flow.catch] operator only catches upstream exceptions, but passes\n * all downstream exceptions. Similarly, terminal operators like [collect][Flow.collect]\n * throw any unhandled exceptions that occur in their code or in upstream flows, for example:\n *\n * ```\n * flow { emitData() }\n *     .map { computeOne(it) }\n *     .catch { ... } // catches exceptions in emitData and computeOne\n *     .map { computeTwo(it) }\n *     .collect { process(it) } // throws exceptions from process and computeTwo\n * ```\n * The same reasoning can be applied to the [onCompletion] operator that is a declarative replacement for the `finally` block.\n *\n * All exception-handling Flow operators follow the principle of exception suppression:\n *\n * If the upstream flow throws an exception during its completion when the downstream exception has been thrown,\n * the downstream exception becomes superseded and suppressed by the upstream exception, being a semantic\n * equivalent of throwing from `finally` block. However, this doesn't affect the operation of the exception-handling operators,\n * which consider the downstream exception to be the root cause and behave as if the upstream didn't throw anything.\n *\n * Failure to adhere to the exception transparency requirement can lead to strange behaviors which make\n * it hard to reason about the code because an exception in the `collect { ... }` could be somehow \"caught\"\n * by an upstream flow, limiting the ability of local reasoning about the code.\n *\n * Flow machinery enforces exception transparency at runtime and throws [IllegalStateException] on any attempt to emit a value,\n * if an exception has been thrown on previous attempt.\n *\n * ### Reactive streams\n *\n * Flow is [Reactive Streams](http://www.reactive-streams.org/) compliant, you can safely interop it with\n * reactive streams using [Flow.asPublisher] and [Publisher.asFlow] from `kotlinx-coroutines-reactive` module.\n *\n * ### Not stable for inheritance\n *\n * **The `Flow` interface is not stable for inheritance in 3rd party libraries**, as new methods\n * might be added to this interface in the future, but is stable for use.\n *\n * Use the `flow { ... }` builder function to create an implementation, or extend [AbstractFlow].\n * These implementations ensure that the context preservation property is not violated, and prevent most\n * of the developer mistakes related to concurrency, inconsistent flow dispatchers, and cancellation.\n */\npublic interface Flow<out T> {\n\n    /**\n     * Accepts the given [collector] and [emits][FlowCollector.emit] values into it.\n     *\n     * This method can be used along with SAM-conversion of [FlowCollector]:\n     * ```\n     * myFlow.collect { value -> println(\"Collected $value\") }\n     * ```\n     *\n     * ### Method inheritance\n     *\n     * To ensure the context preservation property, it is not recommended implementing this method directly.\n     * Instead, [AbstractFlow] can be used as the base type to properly ensure flow's properties.\n     *\n     * All default flow implementations ensure context preservation and exception transparency properties on a best-effort basis\n     * and throw [IllegalStateException] if a violation was detected.\n     */\n    public suspend fun collect(collector: FlowCollector<T>)\n}\n\n/**\n * Base class for stateful implementations of `Flow`.\n * It tracks all the properties required for context preservation and throws an [IllegalStateException]\n * if any of the properties are violated.\n * \n * Example of the implementation:\n *\n * ```\n * // list.asFlow() + collect counter\n * class CountingListFlow(private val values: List<Int>) : AbstractFlow<Int>() {\n *     private val collectedCounter = AtomicInteger(0)\n *\n *     override suspend fun collectSafely(collector: FlowCollector<Int>) {\n *         collectedCounter.incrementAndGet() // Increment collected counter\n *         values.forEach { // Emit all the values\n *             collector.emit(it)\n *         }\n *     }\n *\n *     fun toDiagnosticString(): String = \"Flow with values $values was collected ${collectedCounter.value} times\"\n * }\n * ```\n */\n@ExperimentalCoroutinesApi\npublic abstract class AbstractFlow<T> : Flow<T>, CancellableFlow<T> {\n\n    public final override suspend fun collect(collector: FlowCollector<T>) {\n        val safeCollector = SafeCollector(collector, coroutineContext)\n        try {\n            collectSafely(safeCollector)\n        } finally {\n            safeCollector.releaseIntercepted()\n        }\n    }\n\n    /**\n     * Accepts the given [collector] and [emits][FlowCollector.emit] values into it.\n     *\n     * A valid implementation of this method has the following constraints:\n     * 1) It should not change the coroutine context (e.g. with `withContext(Dispatchers.IO)`) when emitting values.\n     *    The emission should happen in the context of the [collect] call.\n     *    Please refer to the top-level [Flow] documentation for more details.\n     * 2) It should serialize calls to [emit][FlowCollector.emit] as [FlowCollector] implementations are not\n     *    thread-safe by default.\n     *    To automatically serialize emissions [channelFlow] builder can be used instead of [flow]\n     *\n     * @throws IllegalStateException if any of the invariants are violated.\n     */\n    public abstract suspend fun collectSafely(collector: FlowCollector<T>)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/FlowCollector.kt",
        "content": "package kotlinx.coroutines.flow\n\n/**\n * [FlowCollector] is used as an intermediate or a terminal collector of the flow and represents\n * an entity that accepts values emitted by the [Flow].\n *\n * This interface should usually not be implemented directly, but rather used as a receiver in a [flow] builder when implementing a custom operator,\n * or with SAM-conversion.\n * Implementations of this interface are not thread-safe.\n *\n * Example of usage:\n *\n * ```\n * val flow = getMyEvents()\n * try {\n *     flow.collect { value ->\n *         println(\"Received $value\")\n *     }\n *     println(\"My events are consumed successfully\")\n * } catch (e: Throwable) {\n *     println(\"Exception from the flow: $e\")\n * }\n * ```\n */\npublic fun interface FlowCollector<in T> {\n\n    /**\n     * Collects the value emitted by the upstream.\n     * This method is not thread-safe and should not be invoked concurrently.\n     */\n    public suspend fun emit(value: T)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/Migration.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n@file:Suppress(\"unused\", \"DeprecatedCallableAddReplaceWith\", \"UNUSED_PARAMETER\", \"NO_EXPLICIT_RETURN_TYPE_IN_API_MODE\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * **GENERAL NOTE**\n *\n * These deprecations are added to improve user experience when they will start to\n * search for their favourite operators and/or patterns that are missing or renamed in Flow.\n * Deprecated functions also are moved here when they renamed. The difference is that they have\n * a body with their implementation while pure stubs have [noImpl].\n */\ninternal fun noImpl(): Nothing =\n    throw UnsupportedOperationException(\"Not implemented, should not be called\")\n\n/**\n * `observeOn` has no direct match in [Flow] API because all terminal flow operators are suspending and\n * thus use the context of the caller.\n *\n * For example, the following code:\n * ```\n * flowable\n *     .observeOn(Schedulers.io())\n *     .doOnEach { value -> println(\"Received $value\") }\n *     .subscribe()\n * ```\n *\n *  has the following Flow equivalent:\n * ```\n * withContext(Dispatchers.IO) {\n *     flow.collect { value -> println(\"Received $value\") }\n * }\n *\n * ```\n * @suppress\n */\n@Deprecated(message = \"Collect flow in the desired context instead\", level = DeprecationLevel.ERROR)\npublic fun <T> Flow<T>.observeOn(context: CoroutineContext): Flow<T> = noImpl()\n\n/**\n * `publishOn` has no direct match in [Flow] API because all terminal flow operators are suspending and\n * thus use the context of the caller.\n *\n * For example, the following code:\n * ```\n * flux\n *     .publishOn(Schedulers.io())\n *     .doOnEach { value -> println(\"Received $value\") }\n *     .subscribe()\n * ```\n *\n *  has the following Flow equivalent:\n * ```\n * withContext(Dispatchers.IO) {\n *     flow.collect { value -> println(\"Received $value\") }\n * }\n *\n * ```\n * @suppress\n */\n@Deprecated(message = \"Collect flow in the desired context instead\", level = DeprecationLevel.ERROR)\npublic fun <T> Flow<T>.publishOn(context: CoroutineContext): Flow<T> = noImpl()\n\n/**\n * `subscribeOn` has no direct match in [Flow] API because [Flow] preserves its context and does not leak it.\n *\n * For example, the following code:\n * ```\n * flowable\n *     .map { value -> println(\"Doing map in IO\"); value }\n *     .subscribeOn(Schedulers.io())\n *     .observeOn(Schedulers.computation())\n *     .doOnEach { value -> println(\"Processing $value in computation\")\n *     .subscribe()\n * ```\n * has the following Flow equivalent:\n * ```\n * withContext(Dispatchers.Default) {\n *     flow\n *        .map { value -> println(\"Doing map in IO\"); value }\n *        .flowOn(Dispatchers.IO) // Works upstream, doesn't change downstream\n *        .collect { value ->\n *             println(\"Processing $value in computation\")\n *        }\n * }\n * ```\n * Opposed to subscribeOn, it it **possible** to use multiple `flowOn` operators in the one flow\n * @suppress\n */\n@Deprecated(message = \"Use 'flowOn' instead\", level = DeprecationLevel.ERROR)\npublic fun <T> Flow<T>.subscribeOn(context: CoroutineContext): Flow<T> = noImpl()\n\n/**\n * Flow analogue of `onErrorXxx` is [catch].\n * Use `catch { emitAll(fallback) }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'onErrorXxx' is 'catch'. Use 'catch { emitAll(fallback) }'\",\n    replaceWith = ReplaceWith(\"catch { emitAll(fallback) }\")\n)\npublic fun <T> Flow<T>.onErrorResume(fallback: Flow<T>): Flow<T> = noImpl()\n\n/**\n * Flow analogue of `onErrorXxx` is [catch].\n * Use `catch { emitAll(fallback) }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'onErrorXxx' is 'catch'. Use 'catch { emitAll(fallback) }'\",\n    replaceWith = ReplaceWith(\"catch { emitAll(fallback) }\")\n)\npublic fun <T> Flow<T>.onErrorResumeNext(fallback: Flow<T>): Flow<T> = noImpl()\n\n/**\n * `subscribe` is Rx-specific API that has no direct match in flows.\n * One can use [launchIn] instead, for example the following:\n * ```\n * flowable\n *     .observeOn(Schedulers.io())\n *     .subscribe({ println(\"Received $it\") }, { println(\"Exception $it happened\") }, { println(\"Flowable is completed successfully\") }\n * ```\n *\n * has the following Flow equivalent:\n * ```\n * flow\n *     .onEach { value -> println(\"Received $value\") }\n *     .onCompletion { cause -> if (cause == null) println(\"Flow is completed successfully\") }\n *     .catch { cause -> println(\"Exception $cause happened\") }\n *     .flowOn(Dispatchers.IO)\n *     .launchIn(myScope)\n * ```\n *\n * Note that resulting value of [launchIn] is not used because the provided scope takes care of cancellation.\n *\n * Or terminal operators like [single] can be used from suspend functions.\n * @suppress\n */\n@Deprecated(\n    message = \"Use 'launchIn' with 'onEach', 'onCompletion' and 'catch' instead\",\n    level = DeprecationLevel.ERROR\n)\npublic fun <T> Flow<T>.subscribe(): Unit = noImpl()\n\n/**\n * Use [launchIn] with [onEach], [onCompletion] and [catch] operators instead.\n * @suppress\n */\n@Deprecated(\n    message = \"Use 'launchIn' with 'onEach', 'onCompletion' and 'catch' instead\",\n    level = DeprecationLevel.ERROR\n)public fun <T> Flow<T>.subscribe(onEach: suspend (T) -> Unit): Unit = noImpl()\n\n/**\n * Use [launchIn] with [onEach], [onCompletion] and [catch] operators instead.\n * @suppress\n */\n@Deprecated(\n    message = \"Use 'launchIn' with 'onEach', 'onCompletion' and 'catch' instead\",\n    level = DeprecationLevel.ERROR\n)public fun <T> Flow<T>.subscribe(onEach: suspend (T) -> Unit, onError: suspend (Throwable) -> Unit): Unit = noImpl()\n\n/**\n * Note that this replacement is sequential (`concat`) by default.\n * For concurrent flatMap [flatMapMerge] can be used instead.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue is 'flatMapConcat'\",\n    replaceWith = ReplaceWith(\"flatMapConcat(mapper)\")\n)\npublic fun <T, R> Flow<T>.flatMap(mapper: suspend (T) -> Flow<R>): Flow<R> = noImpl()\n\n/**\n * Flow analogue of `concatMap` is [flatMapConcat].\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'concatMap' is 'flatMapConcat'\",\n    replaceWith = ReplaceWith(\"flatMapConcat(mapper)\")\n)\npublic fun <T, R> Flow<T>.concatMap(mapper: (T) -> Flow<R>): Flow<R> = noImpl()\n\n/**\n * Note that this replacement is sequential (`concat`) by default.\n * For concurrent flatMap [flattenMerge] can be used instead.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'merge' is 'flattenConcat'\",\n    replaceWith = ReplaceWith(\"flattenConcat()\")\n)\npublic fun <T> Flow<Flow<T>>.merge(): Flow<T> = noImpl()\n\n/**\n * Flow analogue of `flatten` is [flattenConcat].\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'flatten' is 'flattenConcat'\",\n    replaceWith = ReplaceWith(\"flattenConcat()\")\n)\npublic fun <T> Flow<Flow<T>>.flatten(): Flow<T> = noImpl()\n\n/**\n * Kotlin has a built-in generic mechanism for making chained calls.\n * If you wish to write something like\n * ```\n * myFlow.compose(MyFlowExtensions.ignoreErrors()).collect { ... }\n * ```\n * you can replace it with\n *\n * ```\n * myFlow.let(MyFlowExtensions.ignoreErrors()).collect { ... }\n * ```\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'compose' is 'let'\",\n    replaceWith = ReplaceWith(\"let(transformer)\")\n)\npublic fun <T, R> Flow<T>.compose(transformer: Flow<T>.() -> Flow<R>): Flow<R> = noImpl()\n\n/**\n * Flow analogue of `skip` is [drop].\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'skip' is 'drop'\",\n    replaceWith = ReplaceWith(\"drop(count)\")\n)\npublic fun <T> Flow<T>.skip(count: Int): Flow<T> = noImpl()\n\n/**\n * Flow extension to iterate over elements is [collect].\n * Foreach wasn't introduced deliberately to avoid confusion.\n * Flow is not a collection, iteration over it may be not idempotent\n * and can *launch* computations with side-effects.\n * This behaviour is not reflected in [forEach] name.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'forEach' is 'collect'\",\n    replaceWith = ReplaceWith(\"collect(action)\")\n)\npublic fun <T> Flow<T>.forEach(action: suspend (value: T) -> Unit): Unit = noImpl()\n\n/**\n * Flow has less verbose [scan] shortcut.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow has less verbose 'scan' shortcut\",\n    replaceWith = ReplaceWith(\"scan(initial, operation)\")\n)\npublic fun <T, R> Flow<T>.scanFold(initial: R, @BuilderInference operation: suspend (accumulator: R, value: T) -> R): Flow<R> =\n    noImpl()\n\n/**\n * Flow analogue of `onErrorXxx` is [catch].\n * Use `catch { emit(fallback) }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'onErrorXxx' is 'catch'. Use 'catch { emit(fallback) }'\",\n    replaceWith = ReplaceWith(\"catch { emit(fallback) }\")\n)\n// Note: this version without predicate gives better \"replaceWith\" action\npublic fun <T> Flow<T>.onErrorReturn(fallback: T): Flow<T> = noImpl()\n\n/**\n * Flow analogue of `onErrorXxx` is [catch].\n * Use `catch { e -> if (predicate(e)) emit(fallback) else throw e }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'onErrorXxx' is 'catch'. Use 'catch { e -> if (predicate(e)) emit(fallback) else throw e }'\",\n    replaceWith = ReplaceWith(\"catch { e -> if (predicate(e)) emit(fallback) else throw e }\")\n)\npublic fun <T> Flow<T>.onErrorReturn(fallback: T, predicate: (Throwable) -> Boolean = { true }): Flow<T> =\n    catch { e ->\n        // Note: default value is for binary compatibility with preview version, that is why it has body\n        if (!predicate(e)) throw e\n        emit(fallback)\n    }\n\n/**\n * Flow analogue of `startWith` is [onStart].\n * Use `onStart { emit(value) }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'startWith' is 'onStart'. Use 'onStart { emit(value) }'\",\n    replaceWith = ReplaceWith(\"onStart { emit(value) }\")\n)\npublic fun <T> Flow<T>.startWith(value: T): Flow<T> = noImpl()\n\n/**\n * Flow analogue of `startWith` is [onStart].\n * Use `onStart { emitAll(other) }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'startWith' is 'onStart'. Use 'onStart { emitAll(other) }'\",\n    replaceWith = ReplaceWith(\"onStart { emitAll(other) }\")\n)\npublic fun <T> Flow<T>.startWith(other: Flow<T>): Flow<T> = noImpl()\n\n/**\n * Flow analogue of `concatWith` is [onCompletion].\n * Use `onCompletion { emit(value) }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'concatWith' is 'onCompletion'. Use 'onCompletion { emit(value) }'\",\n    replaceWith = ReplaceWith(\"onCompletion { emit(value) }\")\n)\npublic fun <T> Flow<T>.concatWith(value: T): Flow<T> = noImpl()\n\n/**\n * Flow analogue of `concatWith` is [onCompletion].\n * Use `onCompletion { if (it == null) emitAll(other) }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'concatWith' is 'onCompletion'. Use 'onCompletion { if (it == null) emitAll(other) }'\",\n    replaceWith = ReplaceWith(\"onCompletion { if (it == null) emitAll(other) }\")\n)\npublic fun <T> Flow<T>.concatWith(other: Flow<T>): Flow<T> = noImpl()\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'combineLatest' is 'combine'\",\n    replaceWith = ReplaceWith(\"this.combine(other, transform)\")\n)\npublic fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> =\n    combine(this, other, transform)\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'combineLatest' is 'combine'\",\n    replaceWith = ReplaceWith(\"combine(this, other, other2, transform)\")\n)\npublic fun <T1, T2, T3, R> Flow<T1>.combineLatest(\n    other: Flow<T2>,\n    other2: Flow<T3>,\n    transform: suspend (T1, T2, T3) -> R\n) = combine(this, other, other2, transform)\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'combineLatest' is 'combine'\",\n    replaceWith = ReplaceWith(\"combine(this, other, other2, other3, transform)\")\n)\npublic fun <T1, T2, T3, T4, R> Flow<T1>.combineLatest(\n    other: Flow<T2>,\n    other2: Flow<T3>,\n    other3: Flow<T4>,\n    transform: suspend (T1, T2, T3, T4) -> R\n) = combine(this, other, other2, other3, transform)\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'combineLatest' is 'combine'\",\n    replaceWith = ReplaceWith(\"combine(this, other, other2, other3, transform)\")\n)\npublic fun <T1, T2, T3, T4, T5, R> Flow<T1>.combineLatest(\n    other: Flow<T2>,\n    other2: Flow<T3>,\n    other3: Flow<T4>,\n    other4: Flow<T5>,\n    transform: suspend (T1, T2, T3, T4, T5) -> R\n): Flow<R> = combine(this, other, other2, other3, other4, transform)\n\n/**\n * Delays the emission of values from this flow for the given [timeMillis].\n * Use `onStart { delay(timeMillis) }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR, // since 1.3.0, error in 1.5.0\n    message = \"Use 'onStart { delay(timeMillis) }'\",\n    replaceWith = ReplaceWith(\"onStart { delay(timeMillis) }\")\n)\npublic fun <T> Flow<T>.delayFlow(timeMillis: Long): Flow<T> = onStart { delay(timeMillis) }\n\n/**\n * Delays each element emitted by the given flow for the given [timeMillis].\n * Use `onEach { delay(timeMillis) }`.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR, // since 1.3.0, error in 1.5.0\n    message = \"Use 'onEach { delay(timeMillis) }'\",\n    replaceWith = ReplaceWith(\"onEach { delay(timeMillis) }\")\n)\npublic fun <T> Flow<T>.delayEach(timeMillis: Long): Flow<T> = onEach { delay(timeMillis) }\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogues of 'switchMap' are 'transformLatest', 'flatMapLatest' and 'mapLatest'\",\n    replaceWith = ReplaceWith(\"this.flatMapLatest(transform)\")\n)\npublic fun <T, R> Flow<T>.switchMap(transform: suspend (value: T) -> Flow<R>): Flow<R> = flatMapLatest(transform)\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR, // Warning since 1.3.8, was experimental when deprecated, ERROR since 1.5.0\n    message = \"'scanReduce' was renamed to 'runningReduce' to be consistent with Kotlin standard library\",\n    replaceWith = ReplaceWith(\"runningReduce(operation)\")\n)\npublic fun <T> Flow<T>.scanReduce(operation: suspend (accumulator: T, value: T) -> T): Flow<T> = runningReduce(operation)\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'publish()' is 'shareIn'. \\n\" +\n        \"publish().connect() is the default strategy (no extra call is needed), \\n\" +\n        \"publish().autoConnect() translates to 'started = SharingStared.Lazily' argument, \\n\" +\n        \"publish().refCount() translates to 'started = SharingStared.WhileSubscribed()' argument.\",\n    replaceWith = ReplaceWith(\"this.shareIn(scope, 0)\")\n)\npublic fun <T> Flow<T>.publish(): Flow<T> = noImpl()\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'publish(bufferSize)' is 'buffer' followed by 'shareIn'. \\n\" +\n        \"publish().connect() is the default strategy (no extra call is needed), \\n\" +\n        \"publish().autoConnect() translates to 'started = SharingStared.Lazily' argument, \\n\" +\n        \"publish().refCount() translates to 'started = SharingStared.WhileSubscribed()' argument.\",\n    replaceWith = ReplaceWith(\"this.buffer(bufferSize).shareIn(scope, 0)\")\n)\npublic fun <T> Flow<T>.publish(bufferSize: Int): Flow<T> = noImpl()\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'replay()' is 'shareIn' with unlimited replay. \\n\" +\n        \"replay().connect() is the default strategy (no extra call is needed), \\n\" +\n        \"replay().autoConnect() translates to 'started = SharingStared.Lazily' argument, \\n\" +\n        \"replay().refCount() translates to 'started = SharingStared.WhileSubscribed()' argument.\",\n    replaceWith = ReplaceWith(\"this.shareIn(scope, Int.MAX_VALUE)\")\n)\npublic fun <T> Flow<T>.replay(): Flow<T> = noImpl()\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'replay(bufferSize)' is 'shareIn' with the specified replay parameter. \\n\" +\n        \"replay().connect() is the default strategy (no extra call is needed), \\n\" +\n        \"replay().autoConnect() translates to 'started = SharingStared.Lazily' argument, \\n\" +\n        \"replay().refCount() translates to 'started = SharingStared.WhileSubscribed()' argument.\",\n    replaceWith = ReplaceWith(\"this.shareIn(scope, bufferSize)\")\n)\npublic fun <T> Flow<T>.replay(bufferSize: Int): Flow<T> = noImpl()\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Flow analogue of 'cache()' is 'shareIn' with unlimited replay and 'started = SharingStared.Lazily' argument'\",\n    replaceWith = ReplaceWith(\"this.shareIn(scope, Int.MAX_VALUE, started = SharingStared.Lazily)\")\n)\npublic fun <T> Flow<T>.cache(): Flow<T> = noImpl()\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/SharedFlow.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * A _hot_ [Flow] that shares emitted values among all its collectors in a broadcast fashion, so that all collectors\n * get all emitted values. A shared flow is called _hot_ because its active instance exists independently of the\n * presence of collectors. This is opposed to a regular [Flow], such as defined by the [`flow { ... }`][flow] function,\n * which is _cold_ and is started separately for each collector.\n *\n * **Shared flow never completes**. A call to [Flow.collect] on a shared flow never completes normally, and\n * neither does a coroutine started by the [Flow.launchIn] function. An active collector of a shared flow is called a _subscriber_.\n *\n * A subscriber of a shared flow can be cancelled. This usually happens when the scope in which the coroutine is running\n * is cancelled. A subscriber to a shared flow is always [cancellable][Flow.cancellable], and checks for\n * cancellation before each emission. Note that most terminal operators like [Flow.toList] would also not complete,\n * when applied to a shared flow, but flow-truncating operators like [Flow.take] and [Flow.takeWhile] can be used on a\n * shared flow to turn it into a completing one.\n *\n * A [mutable shared flow][MutableSharedFlow] is created using the [MutableSharedFlow(...)] constructor function.\n * Its state can be updated by [emitting][MutableSharedFlow.emit] values to it and performing other operations.\n * See the [MutableSharedFlow] documentation for details.\n *\n * [SharedFlow] is useful for broadcasting events that happen inside an application to subscribers that can come and go.\n * For example, the following class encapsulates an event bus that distributes events to all subscribers\n * in a _rendezvous_ manner, suspending until all subscribers receive emitted event:\n *\n * ```\n * class EventBus {\n *     private val _events = MutableSharedFlow<Event>() // private mutable shared flow\n *     val events = _events.asSharedFlow() // publicly exposed as read-only shared flow\n *\n *     suspend fun produceEvent(event: Event) {\n *         _events.emit(event) // suspends until all subscribers receive it\n *     }\n * }\n * ```\n *\n * As an alternative to the above usage with the `MutableSharedFlow(...)` constructor function,\n * any _cold_ [Flow] can be converted to a shared flow using the [shareIn] operator.\n *\n * There is a specialized implementation of shared flow for the case where the most recent state value needs\n * to be shared. See [StateFlow] for details.\n *\n * ### Replay cache and buffer\n *\n * A shared flow keeps a specific number of the most recent values in its _replay cache_. Every new subscriber first\n * gets the values from the replay cache and then gets new emitted values. The maximum size of the replay cache is\n * specified when the shared flow is created by the `replay` parameter. A snapshot of the current replay cache\n * is available via the [replayCache] property and it can be reset with the [MutableSharedFlow.resetReplayCache] function.\n *\n * A replay cache also provides buffer for emissions to the shared flow, allowing slow subscribers to\n * get values from the buffer without suspending emitters. The buffer space determines how much slow subscribers\n * can lag from the fast ones. When creating a shared flow, additional buffer capacity beyond replay can be reserved\n * using the `extraBufferCapacity` parameter.\n * \n * A shared flow with a buffer can be configured to avoid suspension of emitters on buffer overflow using\n * the `onBufferOverflow` parameter, which is equal to one of the entries of the [BufferOverflow] enum. When a strategy other\n * than [SUSPENDED][BufferOverflow.SUSPEND] is configured, emissions to the shared flow never suspend.\n *\n * **Buffer overflow condition can happen only when there is at least one subscriber that is not ready to accept\n * the new value.**  In the absence of subscribers only the most recent `replay` values are stored and the buffer\n * overflow behavior is never triggered and has no effect. In particular, in the absence of subscribers emitter never\n * suspends despite [BufferOverflow.SUSPEND] option and [BufferOverflow.DROP_LATEST] option does not have effect either.\n * Essentially, the behavior in the absence of subscribers is always similar to [BufferOverflow.DROP_OLDEST],\n * but the buffer is just of `replay` size (without any `extraBufferCapacity`).\n *\n * ### Unbuffered shared flow\n *\n * A default implementation of a shared flow that is created with `MutableSharedFlow()` constructor function\n * without parameters has no replay cache nor additional buffer.\n * [emit][MutableSharedFlow.emit] call to such a shared flow suspends until all subscribers receive the emitted value\n * and returns immediately if there are no subscribers.\n * Thus, [tryEmit][MutableSharedFlow.tryEmit] call succeeds and returns `true` only if\n * there are no subscribers (in which case the emitted value is immediately lost).\n *\n * ### SharedFlow vs BroadcastChannel\n *\n * Conceptually shared flow is similar to [BroadcastChannel][BroadcastChannel]\n * and is designed to completely replace it.\n * It has the following important differences:\n *\n * - `SharedFlow` is simpler, because it does not have to implement all the [Channel] APIs, which allows\n *    for faster and simpler implementation.\n * - `SharedFlow` supports configurable replay and buffer overflow strategy.\n * - `SharedFlow` has a clear separation into a read-only `SharedFlow` interface and a [MutableSharedFlow].\n * - `SharedFlow` cannot be closed like `BroadcastChannel` and can never represent a failure.\n *    All errors and completion signals should be explicitly _materialized_ if needed.\n *\n * To migrate [BroadcastChannel] usage to [SharedFlow], start by replacing usages of the `BroadcastChannel(capacity)`\n * constructor with `MutableSharedFlow(0, extraBufferCapacity=capacity)` (broadcast channel does not replay\n * values to new subscribers). Replace [send][BroadcastChannel.send] and [trySend][BroadcastChannel.trySend] calls\n * with [emit][MutableStateFlow.emit] and [tryEmit][MutableStateFlow.tryEmit], and convert subscribers' code to flow operators.\n *\n * ### Concurrency\n *\n * All methods of shared flow are **thread-safe** and can be safely invoked from concurrent coroutines without\n * external synchronization.\n *\n * ### Operator fusion\n *\n * Application of [flowOn][Flow.flowOn], [buffer] with [RENDEZVOUS][Channel.RENDEZVOUS] capacity,\n * or [cancellable] operators to a shared flow has no effect.\n *\n * ### Implementation notes\n *\n * Shared flow implementation uses a lock to ensure thread-safety, but suspending collector and emitter coroutines are\n * resumed outside of this lock to avoid deadlocks when using unconfined coroutines. Adding new subscribers\n * has `O(1)` amortized cost, but emitting has `O(N)` cost, where `N` is the number of subscribers.\n *\n * ### Not stable for inheritance\n *\n * **The `SharedFlow` interface is not stable for inheritance in 3rd party libraries**, as new methods\n * might be added to this interface in the future, but is stable for use.\n * Use the `MutableSharedFlow(replay, ...)` constructor function to create an implementation.\n */\npublic interface SharedFlow<out T> : Flow<T> {\n    /**\n     * A snapshot of the replay cache.\n     */\n    public val replayCache: List<T>\n\n    /**\n     * Accepts the given [collector] and [emits][FlowCollector.emit] values into it.\n     * To emit values from a shared flow into a specific collector, either `collector.emitAll(flow)` or `collect { ... }`\n     * SAM-conversion can be used.\n     *\n     * **A shared flow never completes**. A call to [Flow.collect] or any other terminal operator\n     * on a shared flow never completes normally.\n     *\n     * It is guaranteed that, by the time the first suspension happens, [collect] has already subscribed to the\n     * [SharedFlow] and is eligible for receiving emissions. In particular, the following code will always print `1`:\n     * ```\n     * val flow = MutableSharedFlow<Int>()\n     * launch(start = CoroutineStart.UNDISPATCHED) {\n     *   flow.collect { println(1) }\n     * }\n     * flow.emit(1)\n     * ```\n     *\n     * @see [Flow.collect] for implementation and inheritance details.\n     */\n    override suspend fun collect(collector: FlowCollector<T>): Nothing\n}\n\n/**\n * A mutable [SharedFlow] that provides functions to [emit] values to the flow.\n * An instance of `MutableSharedFlow` with the given configuration parameters can be created using `MutableSharedFlow(...)`\n * constructor function.\n *\n * See the [SharedFlow] documentation for details on shared flows.\n *\n * `MutableSharedFlow` is a [SharedFlow] that also provides the abilities to [emit] a value,\n * to [tryEmit] without suspension if possible, to track the [subscriptionCount],\n * and to [resetReplayCache].\n *\n * ### Concurrency\n *\n * All methods of shared flow are **thread-safe** and can be safely invoked from concurrent coroutines without\n * external synchronization.\n *\n * ### Not stable for inheritance\n *\n * **The `MutableSharedFlow` interface is not stable for inheritance in 3rd party libraries**, as new methods\n * might be added to this interface in the future, but is stable for use.\n * Use the `MutableSharedFlow(...)` constructor function to create an implementation.\n */\npublic interface MutableSharedFlow<T> : SharedFlow<T>, FlowCollector<T> {\n    /**\n     * Emits a [value] to this shared flow, suspending on buffer overflow.\n     *\n     * This call can suspend only when the [BufferOverflow] strategy is\n     * [SUSPEND][BufferOverflow.SUSPEND] **and** there are subscribers collecting this shared flow.\n     *\n     * If there are no subscribers, the buffer is not used.\n     * Instead, the most recently emitted value is simply stored into\n     * the replay cache if one was configured, displacing the older elements there,\n     * or dropped if no replay cache was configured.\n     *\n     * See [tryEmit] for a non-suspending variant of this function.\n     *\n     * This method is **thread-safe** and can be safely invoked from concurrent coroutines without\n     * external synchronization.\n     */\n    override suspend fun emit(value: T)\n\n    /**\n     * Tries to emit a [value] to this shared flow without suspending. It returns `true` if the value was\n     * emitted successfully (see below). When this function returns `false`, it means that a call to a plain [emit]\n     * function would suspend until there is buffer space available.\n     *\n     * This call can return `false` only when the [BufferOverflow] strategy is\n     * [SUSPEND][BufferOverflow.SUSPEND] **and** there are subscribers collecting this shared flow.\n     *\n     * If there are no subscribers, the buffer is not used.\n     * Instead, the most recently emitted value is simply stored into\n     * the replay cache if one was configured, displacing the older elements there,\n     * or dropped if no replay cache was configured. In any case, `tryEmit` returns `true`.\n     *\n     * This method is **thread-safe** and can be safely invoked from concurrent coroutines without\n     * external synchronization.\n     */\n    public fun tryEmit(value: T): Boolean\n\n    /**\n     * The number of subscribers (active collectors) to this shared flow.\n     *\n     * The integer in the resulting [StateFlow] is not negative and starts with zero for a freshly created\n     * shared flow.\n     *\n     * This state can be used to react to changes in the number of subscriptions to this shared flow.\n     * For example, if you need to call `onActive` when the first subscriber appears and `onInactive`\n     * when the last one disappears, you can set it up like this:\n     *\n     * ```\n     * sharedFlow.subscriptionCount\n     *     .map { count -> count > 0 } // map count into active/inactive flag\n     *     .distinctUntilChanged() // only react to true<->false changes\n     *     .onEach { isActive -> // configure an action\n     *         if (isActive) onActive() else onInactive()\n     *     }\n     *     .launchIn(scope) // launch it\n     * ```\n     *\n     * Usually, [StateFlow] conflates values, but [subscriptionCount] is not conflated.\n     * This is done so that any subscribers that need to be notified when subscribers appear do\n     * reliably observe it. With conflation, if a single subscriber appeared and immediately left, those\n     * collecting [subscriptionCount] could fail to notice it due to `0` immediately conflating the\n     * subscription count.\n     */\n    public val subscriptionCount: StateFlow<Int>\n\n    /**\n     * Resets the [replayCache] of this shared flow to an empty state.\n     * New subscribers will be receiving only the values that were emitted after this call,\n     * while old subscribers will still be receiving previously buffered values.\n     * To reset a shared flow to an initial value, emit the value after this call.\n     *\n     * On a [MutableStateFlow], which always contains a single value, this function is not\n     * supported, and throws an [UnsupportedOperationException]. To reset a [MutableStateFlow]\n     * to an initial value, just update its [value][MutableStateFlow.value].\n     *\n     * This method is **thread-safe** and can be safely invoked from concurrent coroutines without\n     * external synchronization.\n     *\n     * **Note: This is an experimental api.** This function may be removed or renamed in the future.\n     */\n    @ExperimentalCoroutinesApi\n    public fun resetReplayCache()\n}\n\n/**\n * Creates a [MutableSharedFlow] with the given configuration parameters.\n *\n * This function throws [IllegalArgumentException] on unsupported values of parameters or combinations thereof.\n *\n * @param replay the number of values replayed to new subscribers (cannot be negative, defaults to zero).\n * @param extraBufferCapacity the number of values buffered in addition to `replay`.\n *   [emit][MutableSharedFlow.emit] does not suspend while there is a buffer space remaining (optional, cannot be negative, defaults to zero).\n * @param onBufferOverflow configures an [emit][MutableSharedFlow.emit] action on buffer overflow. Optional, defaults to\n *   [suspending][BufferOverflow.SUSPEND] attempts to emit a value.\n *   Values other than [BufferOverflow.SUSPEND] are supported only when `replay > 0` or `extraBufferCapacity > 0`.\n *   **Buffer overflow can happen only when there is at least one subscriber that is not ready to accept\n *   the new value.** In the absence of subscribers only the most recent [replay] values are stored and\n *   the buffer overflow behavior is never triggered and has no effect.\n */\n@Suppress(\"FunctionName\", \"UNCHECKED_CAST\")\npublic fun <T> MutableSharedFlow(\n    replay: Int = 0,\n    extraBufferCapacity: Int = 0,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n): MutableSharedFlow<T> {\n    require(replay >= 0) { \"replay cannot be negative, but was $replay\" }\n    require(extraBufferCapacity >= 0) { \"extraBufferCapacity cannot be negative, but was $extraBufferCapacity\" }\n    require(replay > 0 || extraBufferCapacity > 0 || onBufferOverflow == BufferOverflow.SUSPEND) {\n        \"replay or extraBufferCapacity must be positive with non-default onBufferOverflow strategy $onBufferOverflow\"\n    }\n    val bufferCapacity0 = replay + extraBufferCapacity\n    val bufferCapacity = if (bufferCapacity0 < 0) Int.MAX_VALUE else bufferCapacity0 // coerce to MAX_VALUE on overflow\n    return SharedFlowImpl(replay, bufferCapacity, onBufferOverflow)\n}\n\n// ------------------------------------ Implementation ------------------------------------\n\ninternal class SharedFlowSlot : AbstractSharedFlowSlot<SharedFlowImpl<*>>() {\n    @JvmField\n    var index = -1L // current \"to-be-emitted\" index, -1 means the slot is free now\n\n    @JvmField\n    var cont: Continuation<Unit>? = null // collector waiting for new value\n\n    override fun allocateLocked(flow: SharedFlowImpl<*>): Boolean {\n        if (index >= 0) return false // not free\n        index = flow.updateNewCollectorIndexLocked()\n        return true\n    }\n\n    override fun freeLocked(flow: SharedFlowImpl<*>): Array<Continuation<Unit>?> {\n        assert { index >= 0 }\n        val oldIndex = index\n        index = -1L\n        cont = null // cleanup continuation reference\n        return flow.updateCollectorIndexLocked(oldIndex)\n    }\n}\n\ninternal open class SharedFlowImpl<T>(\n    private val replay: Int,\n    private val bufferCapacity: Int,\n    private val onBufferOverflow: BufferOverflow\n) : AbstractSharedFlow<SharedFlowSlot>(), MutableSharedFlow<T>, CancellableFlow<T>, FusibleFlow<T> {\n    /*\n        Logical structure of the buffer\n\n                  buffered values\n             /-----------------------\\\n                          replayCache      queued emitters\n                          /----------\\/----------------------\\\n         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n         |   | 1 | 2 | 3 | 4 | 5 | 6 | E | E | E | E | E | E |   |   |   |\n         +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n               ^           ^           ^                      ^\n               |           |           |                      |\n              head         |      head + bufferSize     head + totalSize\n               |           |           |\n     index of the slowest  |    index of the fastest\n      possible collector   |     possible collector\n               |           |\n               |     replayIndex == new collector's index\n               \\---------------------- /\n          range of possible minCollectorIndex\n\n          head == minOf(minCollectorIndex, replayIndex) // by definition\n          totalSize == bufferSize + queueSize // by definition\n\n       INVARIANTS:\n          minCollectorIndex = activeSlots.minOf { it.index } ?: (head + bufferSize)\n          replayIndex <= head + bufferSize\n     */\n\n    // Stored state\n    private var buffer: Array<Any?>? = null // allocated when needed, allocated size always power of two\n    private var replayIndex = 0L // minimal index from which new collector gets values\n    private var minCollectorIndex = 0L // minimal index of active collectors, equal to replayIndex if there are none\n    private var bufferSize = 0 // number of buffered values\n    private var queueSize = 0 // number of queued emitters\n\n    // Computed state\n    private val head: Long get() = minOf(minCollectorIndex, replayIndex)\n    private val replaySize: Int get() = (head + bufferSize - replayIndex).toInt()\n    private val totalSize: Int get() = bufferSize + queueSize\n    private val bufferEndIndex: Long get() = head + bufferSize\n    private val queueEndIndex: Long get() = head + bufferSize + queueSize\n\n    override val replayCache: List<T>\n        get() = synchronized(this) {\n            val replaySize = this.replaySize\n            if (replaySize == 0) return emptyList()\n            val result = ArrayList<T>(replaySize)\n            val buffer = buffer!! // must be allocated, because replaySize > 0\n            @Suppress(\"UNCHECKED_CAST\")\n            for (i in 0 until replaySize) result += buffer.getBufferAt(replayIndex + i) as T\n            result\n        }\n\n    /*\n     * A tweak for SubscriptionCountStateFlow to get the latest value.\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    protected val lastReplayedLocked: T\n        get() = buffer!!.getBufferAt(replayIndex + replaySize - 1) as T\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override suspend fun collect(collector: FlowCollector<T>): Nothing {\n        val slot = allocateSlot()\n        try {\n            if (collector is SubscribedFlowCollector) collector.onSubscription()\n            val collectorJob = currentCoroutineContext()[Job]\n            while (true) {\n                var newValue: Any?\n                while (true) {\n                    newValue = tryTakeValue(slot) // attempt no-suspend fast path first\n                    if (newValue !== NO_VALUE) break\n                    awaitValue(slot) // await signal that the new value is available\n                }\n                collectorJob?.ensureActive()\n                collector.emit(newValue as T)\n            }\n        } finally {\n            freeSlot(slot)\n        }\n    }\n\n    override fun tryEmit(value: T): Boolean {\n        var resumes: Array<Continuation<Unit>?> = EMPTY_RESUMES\n        val emitted = synchronized(this) {\n            if (tryEmitLocked(value)) {\n                resumes = findSlotsToResumeLocked(resumes)\n                true\n            } else {\n                false\n            }\n        }\n        for (cont in resumes) cont?.resume(Unit)\n        return emitted\n    }\n\n    override suspend fun emit(value: T) {\n        if (tryEmit(value)) return // fast-path\n        emitSuspend(value)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun tryEmitLocked(value: T): Boolean {\n        // Fast path without collectors -> no buffering\n        if (nCollectors == 0) return tryEmitNoCollectorsLocked(value) // always returns true\n        // With collectors we'll have to buffer\n        // cannot emit now if buffer is full & blocked by slow collectors\n        if (bufferSize >= bufferCapacity && minCollectorIndex <= replayIndex) {\n            when (onBufferOverflow) {\n                BufferOverflow.SUSPEND -> return false // will suspend\n                BufferOverflow.DROP_LATEST -> return true // just drop incoming\n                BufferOverflow.DROP_OLDEST -> {} // force enqueue & drop oldest instead\n            }\n        }\n        enqueueLocked(value)\n        bufferSize++ // value was added to buffer\n        // drop oldest from the buffer if it became more than bufferCapacity\n        if (bufferSize > bufferCapacity) dropOldestLocked()\n        // keep replaySize not larger that needed\n        if (replaySize > replay) { // increment replayIndex by one\n            updateBufferLocked(replayIndex + 1, minCollectorIndex, bufferEndIndex, queueEndIndex)\n        }\n        return true\n    }\n\n    private fun tryEmitNoCollectorsLocked(value: T): Boolean {\n        assert { nCollectors == 0 }\n        if (replay == 0) return true // no need to replay, just forget it now\n        enqueueLocked(value) // enqueue to replayCache\n        bufferSize++ // value was added to buffer\n        // drop oldest from the buffer if it became more than replay\n        if (bufferSize > replay) dropOldestLocked()\n        minCollectorIndex = head + bufferSize // a default value (max allowed)\n        return true\n    }\n\n    private fun dropOldestLocked() {\n        buffer!!.setBufferAt(head, null)\n        bufferSize--\n        val newHead = head + 1\n        if (replayIndex < newHead) replayIndex = newHead\n        if (minCollectorIndex < newHead) correctCollectorIndexesOnDropOldest(newHead)\n        assert { head == newHead } // since head = minOf(minCollectorIndex, replayIndex) it should have updated\n    }\n\n    private fun correctCollectorIndexesOnDropOldest(newHead: Long) {\n        forEachSlotLocked { slot ->\n            @Suppress(\"ConvertTwoComparisonsToRangeCheck\") // Bug in JS backend\n            if (slot.index >= 0 && slot.index < newHead) {\n                slot.index = newHead // force move it up (this collector was too slow and missed the value at its index)\n            }\n        }\n        minCollectorIndex = newHead\n    }\n\n    // enqueues item to buffer array, caller shall increment either bufferSize or queueSize\n    private fun enqueueLocked(item: Any?) {\n        val curSize = totalSize\n        val buffer = when (val curBuffer = buffer) {\n            null -> growBuffer(null, 0, 2)\n            else -> if (curSize >= curBuffer.size) growBuffer(curBuffer, curSize,curBuffer.size * 2) else curBuffer\n        }\n        buffer.setBufferAt(head + curSize, item)\n    }\n\n    private fun growBuffer(curBuffer: Array<Any?>?, curSize: Int, newSize: Int): Array<Any?> {\n        check(newSize > 0) { \"Buffer size overflow\" }\n        val newBuffer = arrayOfNulls<Any?>(newSize).also { buffer = it }\n        if (curBuffer == null) return newBuffer\n        val head = head\n        for (i in 0 until curSize) {\n            newBuffer.setBufferAt(head + i, curBuffer.getBufferAt(head + i))\n        }\n        return newBuffer\n    }\n\n    private suspend fun emitSuspend(value: T) = suspendCancellableCoroutine<Unit> sc@{ cont ->\n        var resumes: Array<Continuation<Unit>?> = EMPTY_RESUMES\n        val emitter = synchronized(this) lock@{\n            // recheck buffer under lock again (make sure it is really full)\n            if (tryEmitLocked(value)) {\n                cont.resume(Unit)\n                resumes = findSlotsToResumeLocked(resumes)\n                return@lock null\n            }\n            // add suspended emitter to the buffer\n            Emitter(this, head + totalSize, value, cont).also {\n                enqueueLocked(it)\n                queueSize++ // added to queue of waiting emitters\n                // synchronous shared flow might rendezvous with waiting emitter\n                if (bufferCapacity == 0) resumes = findSlotsToResumeLocked(resumes)\n            }\n        }\n        // outside of the lock: register dispose on cancellation\n        emitter?.let { cont.disposeOnCancellation(it) }\n        // outside of the lock: resume slots if needed\n        for (r in resumes) r?.resume(Unit)\n    }\n\n    private fun cancelEmitter(emitter: Emitter) = synchronized(this) {\n        if (emitter.index < head) return // already skipped past this index\n        val buffer = buffer!!\n        if (buffer.getBufferAt(emitter.index) !== emitter) return // already resumed\n        buffer.setBufferAt(emitter.index, NO_VALUE)\n        cleanupTailLocked()\n    }\n\n    internal fun updateNewCollectorIndexLocked(): Long {\n        val index = replayIndex\n        if (index < minCollectorIndex) minCollectorIndex = index\n        return index\n    }\n\n    // Is called when a collector disappears or changes index, returns a list of continuations to resume after lock\n    internal fun updateCollectorIndexLocked(oldIndex: Long): Array<Continuation<Unit>?> {\n        assert { oldIndex >= minCollectorIndex }\n        if (oldIndex > minCollectorIndex) return EMPTY_RESUMES // nothing changes, it was not min\n        // start computing new minimal index of active collectors\n        val head = head\n        var newMinCollectorIndex = head + bufferSize\n        // take into account a special case of sync shared flow that can go past 1st queued emitter\n        if (bufferCapacity == 0 && queueSize > 0) newMinCollectorIndex++\n        forEachSlotLocked { slot ->\n            @Suppress(\"ConvertTwoComparisonsToRangeCheck\") // Bug in JS backend\n            if (slot.index >= 0 && slot.index < newMinCollectorIndex) newMinCollectorIndex = slot.index\n        }\n        assert { newMinCollectorIndex >= minCollectorIndex } // can only grow\n        if (newMinCollectorIndex <= minCollectorIndex) return EMPTY_RESUMES // nothing changes\n        // Compute new buffer size if we drop items we no longer need and no emitter is resumed:\n        // We must keep all the items from newMinIndex to the end of buffer\n        var newBufferEndIndex = bufferEndIndex // var to grow when waiters are resumed\n        val maxResumeCount = if (nCollectors > 0) {\n            // If we have collectors we can resume up to maxResumeCount waiting emitters\n            // a) queueSize -> that's how many waiting emitters we have\n            // b) bufferCapacity - newBufferSize0 -> that's how many we can afford to resume to add w/o exceeding bufferCapacity\n            val newBufferSize0 = (newBufferEndIndex - newMinCollectorIndex).toInt()\n            minOf(queueSize, bufferCapacity - newBufferSize0)\n        } else {\n            // If we don't have collectors anymore we must resume all waiting emitters\n            queueSize // that's how many waiting emitters we have (at most)\n        }\n        var resumes: Array<Continuation<Unit>?> = EMPTY_RESUMES\n        val newQueueEndIndex = newBufferEndIndex + queueSize\n        if (maxResumeCount > 0) { // collect emitters to resume if we have them\n            resumes = arrayOfNulls(maxResumeCount)\n            var resumeCount = 0\n            val buffer = buffer!!\n            for (curEmitterIndex in newBufferEndIndex until newQueueEndIndex) {\n                val emitter = buffer.getBufferAt(curEmitterIndex)\n                if (emitter !== NO_VALUE) {\n                    emitter as Emitter // must have Emitter class\n                    resumes[resumeCount++] = emitter.cont\n                    buffer.setBufferAt(curEmitterIndex, NO_VALUE) // make as canceled if we moved ahead\n                    buffer.setBufferAt(newBufferEndIndex, emitter.value)\n                    newBufferEndIndex++\n                    if (resumeCount >= maxResumeCount) break // enough resumed, done\n                }\n            }\n        }\n        // Compute new buffer size -> how many values we now actually have after resume\n        val newBufferSize1 = (newBufferEndIndex - head).toInt()\n        // Note: When nCollectors == 0 we resume ALL queued emitters and we might have resumed more than bufferCapacity,\n        // and newMinCollectorIndex might pointing the wrong place because of that. The easiest way to fix it is by\n        // forcing newMinCollectorIndex = newBufferEndIndex. We do not needed to update newBufferSize1 (which could be\n        // too big), because the only use of newBufferSize1 in the below code is in the minOf(replay, newBufferSize1)\n        // expression, which coerces values that are too big anyway.\n        if (nCollectors == 0) newMinCollectorIndex = newBufferEndIndex\n        // Compute new replay size -> limit to replay the number of items we need, take into account that it can only grow\n        var newReplayIndex = maxOf(replayIndex, newBufferEndIndex - minOf(replay, newBufferSize1))\n        // adjustment for synchronous case with cancelled emitter (NO_VALUE)\n        if (bufferCapacity == 0 && newReplayIndex < newQueueEndIndex && buffer!!.getBufferAt(newReplayIndex) == NO_VALUE) {\n            newBufferEndIndex++\n            newReplayIndex++\n        }\n        // Update buffer state\n        updateBufferLocked(newReplayIndex, newMinCollectorIndex, newBufferEndIndex, newQueueEndIndex)\n        // just in case we've moved all buffered emitters and have NO_VALUE's at the tail now\n        cleanupTailLocked()\n        // We need to waken up suspended collectors if any emitters were resumed here\n        if (resumes.isNotEmpty()) resumes = findSlotsToResumeLocked(resumes)\n        return resumes\n    }\n\n    private fun updateBufferLocked(\n        newReplayIndex: Long,\n        newMinCollectorIndex: Long,\n        newBufferEndIndex: Long,\n        newQueueEndIndex: Long\n    ) {\n        // Compute new head value\n        val newHead = minOf(newMinCollectorIndex, newReplayIndex)\n        assert { newHead >= head }\n        // cleanup items we don't have to buffer anymore (because head is about to move)\n        for (index in head until newHead) buffer!!.setBufferAt(index, null)\n        // update all state variables to newly computed values\n        replayIndex = newReplayIndex\n        minCollectorIndex = newMinCollectorIndex\n        bufferSize = (newBufferEndIndex - newHead).toInt()\n        queueSize = (newQueueEndIndex - newBufferEndIndex).toInt()\n        // check our key invariants (just in case)\n        assert { bufferSize >= 0 }\n        assert { queueSize >= 0 }\n        assert { replayIndex <= this.head + bufferSize }\n    }\n\n    // Removes all the NO_VALUE items from the end of the queue and reduces its size\n    private fun cleanupTailLocked() {\n        // If we have synchronous case, then keep one emitter queued\n        if (bufferCapacity == 0 && queueSize <= 1) return // return, don't clear it\n        val buffer = buffer!!\n        while (queueSize > 0 && buffer.getBufferAt(head + totalSize - 1) === NO_VALUE) {\n            queueSize--\n            buffer.setBufferAt(head + totalSize, null)\n        }\n    }\n\n    // returns NO_VALUE if cannot take value without suspension\n    private fun tryTakeValue(slot: SharedFlowSlot): Any? {\n        var resumes: Array<Continuation<Unit>?> = EMPTY_RESUMES\n        val value = synchronized(this) {\n            val index = tryPeekLocked(slot)\n            if (index < 0) {\n                NO_VALUE\n            } else {\n                val oldIndex = slot.index\n                val newValue = getPeekedValueLockedAt(index)\n                slot.index = index + 1 // points to the next index after peeked one\n                resumes = updateCollectorIndexLocked(oldIndex)\n                newValue\n            }\n        }\n        for (resume in resumes) resume?.resume(Unit)\n        return value\n    }\n\n    // returns -1 if cannot peek value without suspension\n    private fun tryPeekLocked(slot: SharedFlowSlot): Long {\n        // return buffered value if possible\n        val index = slot.index\n        if (index < bufferEndIndex) return index\n        if (bufferCapacity > 0) return -1L // if there's a buffer, never try to rendezvous with emitters\n        // Synchronous shared flow (bufferCapacity == 0) tries to rendezvous\n        if (index > head) return -1L // ... but only with the first emitter (never look forward)\n        if (queueSize == 0) return -1L // nothing there to rendezvous with\n        return index // rendezvous with the first emitter\n    }\n\n    private fun getPeekedValueLockedAt(index: Long): Any? =\n        when (val item = buffer!!.getBufferAt(index)) {\n            is Emitter -> item.value\n            else -> item\n        }\n\n    private suspend fun awaitValue(slot: SharedFlowSlot): Unit = suspendCancellableCoroutine { cont ->\n        synchronized(this) lock@{\n            val index = tryPeekLocked(slot) // recheck under this lock\n            if (index < 0) {\n                slot.cont = cont // Ok -- suspending\n            } else {\n                cont.resume(Unit) // has value, no need to suspend\n                return@lock\n            }\n            slot.cont = cont // suspend, waiting\n        }\n    }\n\n    private fun findSlotsToResumeLocked(resumesIn: Array<Continuation<Unit>?>): Array<Continuation<Unit>?> {\n        var resumes: Array<Continuation<Unit>?> = resumesIn\n        var resumeCount = resumesIn.size\n        forEachSlotLocked loop@{ slot ->\n            val cont = slot.cont ?: return@loop // only waiting slots\n            if (tryPeekLocked(slot) < 0) return@loop // only slots that can peek a value\n            if (resumeCount >= resumes.size) resumes = resumes.copyOf(maxOf(2, 2 * resumes.size))\n            resumes[resumeCount++] = cont\n            slot.cont = null // not waiting anymore\n        }\n        return resumes\n    }\n\n    override fun createSlot() = SharedFlowSlot()\n    override fun createSlotArray(size: Int): Array<SharedFlowSlot?> = arrayOfNulls(size)\n\n    override fun resetReplayCache() = synchronized(this) {\n        // Update buffer state\n        updateBufferLocked(\n            newReplayIndex = bufferEndIndex,\n            newMinCollectorIndex = minCollectorIndex,\n            newBufferEndIndex = bufferEndIndex,\n            newQueueEndIndex = queueEndIndex\n        )\n    }\n\n    override fun fuse(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow) =\n        fuseSharedFlow(context, capacity, onBufferOverflow)\n    \n    private class Emitter(\n        @JvmField val flow: SharedFlowImpl<*>,\n        @JvmField var index: Long,\n        @JvmField val value: Any?,\n        @JvmField val cont: Continuation<Unit>\n    ) : DisposableHandle {\n        override fun dispose() = flow.cancelEmitter(this)\n    }\n}\n\n@JvmField\ninternal val NO_VALUE = Symbol(\"NO_VALUE\")\n\nprivate fun Array<Any?>.getBufferAt(index: Long) = get(index.toInt() and (size - 1))\nprivate fun Array<Any?>.setBufferAt(index: Long, item: Any?) = set(index.toInt() and (size - 1), item)\n\ninternal fun <T> SharedFlow<T>.fuseSharedFlow(\n    context: CoroutineContext,\n    capacity: Int,\n    onBufferOverflow: BufferOverflow\n): Flow<T> {\n    // context is irrelevant for shared flow and making additional rendezvous is meaningless\n    // however, additional non-trivial buffering after shared flow could make sense for very slow subscribers\n    if ((capacity == Channel.RENDEZVOUS || capacity == Channel.OPTIONAL_CHANNEL) && onBufferOverflow == BufferOverflow.SUSPEND) {\n        return this\n    }\n    // Apply channel flow operator as usual\n    return ChannelFlowOperatorImpl(this, context, capacity, onBufferOverflow)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/SharingStarted.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.IgnoreJreRequirement\nimport kotlin.time.*\n\n/**\n * A command emitted by [SharingStarted] implementations to control the sharing coroutine in\n * the [shareIn] and [stateIn] operators.\n */\npublic enum class SharingCommand {\n    /**\n     * Starts sharing, launching collection of the upstream flow.\n     *\n     * Emitting this command again does not do anything. Emit [STOP] and then [START] to restart an\n     * upstream flow.\n     */\n    START,\n\n    /**\n     * Stops sharing, cancelling collection of the upstream flow.\n     */\n    STOP,\n\n    /**\n     * Stops sharing, cancelling collection of the upstream flow, and resets the [SharedFlow.replayCache]\n     * to its initial state.\n     * The [shareIn] operator calls [MutableSharedFlow.resetReplayCache];\n     * the [stateIn] operator resets the value to its original `initialValue`.\n     */\n    STOP_AND_RESET_REPLAY_CACHE\n}\n\n/**\n * A strategy for starting and stopping the sharing coroutine in [shareIn] and [stateIn] operators.\n *\n * This functional interface provides a set of built-in strategies: [Eagerly], [Lazily], [WhileSubscribed], and\n * supports custom strategies by implementing this interface's [command] function.\n *\n * For example, it is possible to define a custom strategy that starts the upstream only when the number\n * of subscribers exceeds the given `threshold` and make it an extension on [SharingStarted.Companion] so\n * that it looks like a built-in strategy on the use-site:\n *\n * ```\n * fun SharingStarted.Companion.WhileSubscribedAtLeast(threshold: Int) =\n *     SharingStarted { subscriptionCount: StateFlow<Int> ->\n *         subscriptionCount.map { if (it >= threshold) SharingCommand.START else SharingCommand.STOP }\n *     }\n * ```\n *\n * ### Commands\n *\n * The `SharingStarted` strategy works by emitting [commands][SharingCommand] that control upstream flow from its\n * [`command`][command] flow implementation function. Back-to-back emissions of the same command have no effect.\n * Only emission of a different command has effect:\n *\n * - [START][SharingCommand.START] &mdash; the upstream flow is started.\n * - [STOP][SharingCommand.STOP] &mdash; the upstream flow is stopped.\n * - [STOP_AND_RESET_REPLAY_CACHE][SharingCommand.STOP_AND_RESET_REPLAY_CACHE] &mdash;\n *   the upstream flow is stopped and the [SharedFlow.replayCache] is reset to its initial state.\n *   The [shareIn] operator calls [MutableSharedFlow.resetReplayCache];\n *   the [stateIn] operator resets the value to its original `initialValue`.\n *   \n * Initially, the upstream flow is stopped and is in the initial state, so the emission of additional\n * [STOP][SharingCommand.STOP] and [STOP_AND_RESET_REPLAY_CACHE][SharingCommand.STOP_AND_RESET_REPLAY_CACHE] commands will\n * have no effect.\n *\n * The completion of the `command` flow normally has no effect (the upstream flow keeps running if it was running).\n * The failure of the `command` flow cancels the sharing coroutine and the upstream flow.\n */\npublic fun interface SharingStarted {\n    public companion object {\n        /**\n         * Sharing is started immediately and never stops.\n         */\n        public val Eagerly: SharingStarted = StartedEagerly()\n\n        /**\n         * Sharing is started when the first subscriber appears and never stops.\n         */\n        public val Lazily: SharingStarted = StartedLazily()\n\n        /**\n         * Sharing is started when the first subscriber appears, immediately stops when the last\n         * subscriber disappears (by default), keeping the replay cache forever (by default).\n         *\n         * It has the following optional parameters:\n         *\n         * - [stopTimeoutMillis] &mdash; configures a delay (in milliseconds) between the disappearance of the last\n         *   subscriber and the stopping of the sharing coroutine. It defaults to zero (stop immediately).\n         * - [replayExpirationMillis] &mdash; configures a delay (in milliseconds) between the stopping of\n         *   the sharing coroutine and the resetting of the replay cache (which makes the cache empty for the [shareIn] operator\n         *   and resets the cached value to the original `initialValue` for the [stateIn] operator).\n         *   It defaults to `Long.MAX_VALUE` (keep replay cache forever, never reset buffer).\n         *   Use zero value to expire the cache immediately.\n         *\n         * This function throws [IllegalArgumentException] when either [stopTimeoutMillis] or [replayExpirationMillis]\n         * are negative.\n         */\n        @Suppress(\"FunctionName\")\n        public fun WhileSubscribed(\n            stopTimeoutMillis: Long = 0,\n            replayExpirationMillis: Long = Long.MAX_VALUE\n        ): SharingStarted =\n            StartedWhileSubscribed(stopTimeoutMillis, replayExpirationMillis)\n    }\n\n    /**\n     * Transforms the [subscriptionCount][MutableSharedFlow.subscriptionCount] state of the shared flow into the\n     * flow of [commands][SharingCommand] that control the sharing coroutine. See the [SharingStarted] interface\n     * documentation for details.\n     */\n    public fun command(subscriptionCount: StateFlow<Int>): Flow<SharingCommand>\n}\n\n/**\n * Sharing is started when the first subscriber appears, immediately stops when the last\n * subscriber disappears (by default), keeping the replay cache forever (by default).\n *\n * It has the following optional parameters:\n *\n * - [stopTimeout] &mdash; configures a delay between the disappearance of the last\n *   subscriber and the stopping of the sharing coroutine. It defaults to zero (stop immediately).\n * - [replayExpiration] &mdash; configures a delay between the stopping of\n *   the sharing coroutine and the resetting of the replay cache (which makes the cache empty for the [shareIn] operator\n *   and resets the cached value to the original `initialValue` for the [stateIn] operator).\n *   It defaults to [Duration.INFINITE] (keep replay cache forever, never reset buffer).\n *   Use [Duration.ZERO] value to expire the cache immediately.\n *\n * This function throws [IllegalArgumentException] when either [stopTimeout] or [replayExpiration]\n * are negative.\n */\n@Suppress(\"FunctionName\")\npublic fun SharingStarted.Companion.WhileSubscribed(\n    stopTimeout: Duration = Duration.ZERO,\n    replayExpiration: Duration = Duration.INFINITE\n): SharingStarted =\n    StartedWhileSubscribed(stopTimeout.inWholeMilliseconds, replayExpiration.inWholeMilliseconds)\n\n// -------------------------------- implementation --------------------------------\n\nprivate class StartedEagerly : SharingStarted {\n    override fun command(subscriptionCount: StateFlow<Int>): Flow<SharingCommand> =\n        flowOf(SharingCommand.START)\n    override fun toString(): String = \"SharingStarted.Eagerly\"\n}\n\nprivate class StartedLazily : SharingStarted {\n    override fun command(subscriptionCount: StateFlow<Int>): Flow<SharingCommand> = flow {\n        var started = false\n        subscriptionCount.collect { count ->\n            if (count > 0 && !started) {\n                started = true\n                emit(SharingCommand.START)\n            }\n        }\n    }\n\n    override fun toString(): String = \"SharingStarted.Lazily\"\n}\n\nprivate class StartedWhileSubscribed(\n    private val stopTimeout: Long,\n    private val replayExpiration: Long\n) : SharingStarted {\n    init {\n        require(stopTimeout >= 0) { \"stopTimeout($stopTimeout ms) cannot be negative\" }\n        require(replayExpiration >= 0) { \"replayExpiration($replayExpiration ms) cannot be negative\" }\n    }\n\n    override fun command(subscriptionCount: StateFlow<Int>): Flow<SharingCommand> = subscriptionCount\n        .transformLatest { count ->\n            if (count > 0) {\n                emit(SharingCommand.START)\n            } else {\n                delay(stopTimeout)\n                if (replayExpiration > 0) {\n                    emit(SharingCommand.STOP)\n                    delay(replayExpiration)\n                }\n                emit(SharingCommand.STOP_AND_RESET_REPLAY_CACHE)\n            }\n        }\n        .dropWhile { it != SharingCommand.START } // don't emit any STOP/RESET_BUFFER to start with, only START\n        .distinctUntilChanged() // just in case somebody forgets it, don't leak our multiple sending of START\n\n    @OptIn(ExperimentalStdlibApi::class)\n    override fun toString(): String {\n        val params = buildList(2) {\n            if (stopTimeout > 0) add(\"stopTimeout=${stopTimeout}ms\")\n            if (replayExpiration < Long.MAX_VALUE) add(\"replayExpiration=${replayExpiration}ms\")\n        }\n        return \"SharingStarted.WhileSubscribed(${params.joinToString()})\"\n    }\n\n    // equals & hashcode to facilitate testing, not documented in public contract\n    override fun equals(other: Any?): Boolean =\n        other is StartedWhileSubscribed &&\n            stopTimeout == other.stopTimeout &&\n            replayExpiration == other.replayExpiration\n\n    @IgnoreJreRequirement // desugared hashcode implementation\n    override fun hashCode(): Int = stopTimeout.hashCode() * 31 + replayExpiration.hashCode()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/StateFlow.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n/**\n * A [SharedFlow] that represents a read-only state with a single updatable data [value] that emits updates\n * to the value to its collectors. A state flow is a _hot_ flow because its active instance exists independently\n * of the presence of collectors. Its current value can be retrieved via the [value] property.\n *\n * **State flow never completes**. A call to [Flow.collect] on a state flow never completes normally, and\n * neither does a coroutine started by the [Flow.launchIn] function. An active collector of a state flow is called a _subscriber_.\n *\n * A [mutable state flow][MutableStateFlow] is created using `MutableStateFlow(value)` constructor function with\n * the initial value. The value of mutable state flow can be updated by setting its [value] property.\n * Updates to the [value] are always [conflated][Flow.conflate]. So a slow collector skips fast updates,\n * but always collects the most recently emitted value.\n *\n * [StateFlow] is useful as a data-model class to represent any kind of state.\n * Derived values can be defined using various operators on the flows, with [combine] operator being especially\n * useful to combine values from multiple state flows using arbitrary functions.\n *\n * For example, the following class encapsulates an integer state and increments its value on each call to `inc`:\n *\n * ```\n * class CounterModel {\n *     private val _counter = MutableStateFlow(0) // private mutable state flow\n *     val counter = _counter.asStateFlow() // publicly exposed as read-only state flow\n *\n *     fun inc() {\n *         _counter.update { count -> count + 1 } // atomic, safe for concurrent use\n *     }\n * }\n * ```\n *\n * Having two instances of the above `CounterModel` class one can define the sum of their counters like this:\n *\n * ```\n * val aModel = CounterModel()\n * val bModel = CounterModel()\n * val sumFlow: Flow<Int> = aModel.counter.combine(bModel.counter) { a, b -> a + b }\n * ```\n *\n * As an alternative to the above usage with the `MutableStateFlow(...)` constructor function,\n * any _cold_ [Flow] can be converted to a state flow using the [stateIn] operator.\n *\n * ### Strong equality-based conflation\n *\n * Values in state flow are conflated using [Any.equals] comparison in a similar way to\n * [distinctUntilChanged] operator. It is used to conflate incoming updates\n * to [value][MutableStateFlow.value] in [MutableStateFlow] and to suppress emission of the values to collectors\n * when new value is equal to the previously emitted one. State flow behavior with classes that violate\n * the contract for [Any.equals] is unspecified.\n *\n * ### State flow is a shared flow\n *\n * State flow is a special-purpose, high-performance, and efficient implementation of [SharedFlow] for the narrow,\n * but widely used case of sharing a state. See the [SharedFlow] documentation for the basic rules,\n * constraints, and operators that are applicable to all shared flows.\n *\n * State flow always has an initial value, replays one most recent value to new subscribers, does not buffer any\n * more values, but keeps the last emitted one, and does not support [resetReplayCache][MutableSharedFlow.resetReplayCache].\n * A state flow behaves identically to a shared flow when it is created\n * with the following parameters and the [distinctUntilChanged] operator is applied to it:\n *\n * ```\n * // MutableStateFlow(initialValue) is a shared flow with the following parameters:\n * val shared = MutableSharedFlow(\n *     replay = 1,\n *     onBufferOverflow = BufferOverflow.DROP_OLDEST\n * )\n * shared.tryEmit(initialValue) // emit the initial value\n * val state = shared.distinctUntilChanged() // get StateFlow-like behavior\n * ```\n *\n * Use [SharedFlow] when you need a [StateFlow] with tweaks in its behavior such as extra buffering, replaying more\n * values, or omitting the initial value.\n * \n * ### StateFlow vs ConflatedBroadcastChannel\n *\n * Conceptually, state flow is similar to [ConflatedBroadcastChannel]\n * and is designed to completely replace it.\n * It has the following important differences:\n *\n * - `StateFlow` is simpler, because it does not have to implement all the [Channel] APIs, which allows\n *   for faster, garbage-free implementation, unlike `ConflatedBroadcastChannel` implementation that\n *   allocates objects on each emitted value.\n * - `StateFlow` always has a value which can be safely read at any time via [value] property.\n *    Unlike `ConflatedBroadcastChannel`, there is no way to create a state flow without a value.\n * - `StateFlow` has a clear separation into a read-only `StateFlow` interface and a [MutableStateFlow].\n * - `StateFlow` conflation is based on equality like [distinctUntilChanged] operator,\n *    unlike conflation in `ConflatedBroadcastChannel` that is based on reference identity.\n * - `StateFlow` cannot be closed like `ConflatedBroadcastChannel` and can never represent a failure.\n *    All errors and completion signals should be explicitly _materialized_ if needed.\n *\n * `StateFlow` is designed to better cover typical use-cases of keeping track of state changes in time, taking\n * more pragmatic design choices for the sake of convenience.\n *\n * To migrate [ConflatedBroadcastChannel] usage to [StateFlow], start by replacing usages of the `ConflatedBroadcastChannel()`\n * constructor with `MutableStateFlow(initialValue)`, using `null` as an initial value if you don't have one.\n * Replace [send][ConflatedBroadcastChannel.send] and [trySend][ConflatedBroadcastChannel.trySend] calls\n * with updates to the state flow's [MutableStateFlow.value], and convert subscribers' code to flow operators.\n * You can use the [filterNotNull] operator to mimic behavior of a `ConflatedBroadcastChannel` without initial value.\n *\n * ### Concurrency\n *\n * All methods of state flow are **thread-safe** and can be safely invoked from concurrent coroutines without\n * external synchronization.\n *\n * ### Operator fusion\n *\n * Application of [flowOn][Flow.flowOn], [conflate][Flow.conflate],\n * [buffer] with [CONFLATED][Channel.CONFLATED] or [RENDEZVOUS][Channel.RENDEZVOUS] capacity,\n * [distinctUntilChanged][Flow.distinctUntilChanged], or [cancellable] operators to a state flow has no effect.\n * \n * ### Implementation notes\n *\n * State flow implementation is optimized for memory consumption and allocation-freedom. It uses a lock to ensure\n * thread-safety, but suspending collector coroutines are resumed outside of this lock to avoid dead-locks when\n * using unconfined coroutines. Adding new subscribers has `O(1)` amortized cost, but updating a [value] has `O(N)`\n * cost, where `N` is the number of active subscribers.\n *\n * ### Not stable for inheritance\n *\n * **`The StateFlow` interface is not stable for inheritance in 3rd party libraries**, as new methods\n * might be added to this interface in the future, but is stable for use.\n * Use the `MutableStateFlow(value)` constructor function to create an implementation.\n */\npublic interface StateFlow<out T> : SharedFlow<T> {\n    /**\n     * The current value of this state flow.\n     */\n    public val value: T\n}\n\n/**\n * A mutable [StateFlow] that provides a setter for [value].\n * An instance of `MutableStateFlow` with the given initial `value` can be created using\n * `MutableStateFlow(value)` constructor function.\n\n * See the [StateFlow] documentation for details on state flows.\n * Note that all emission-related operators, such as [value]'s setter, [emit], and [tryEmit], are conflated using [Any.equals].\n *\n * ### Not stable for inheritance\n *\n * **The `MutableStateFlow` interface is not stable for inheritance in 3rd party libraries**, as new methods\n * might be added to this interface in the future, but is stable for use.\n * Use the `MutableStateFlow()` constructor function to create an implementation.\n */\npublic interface MutableStateFlow<T> : StateFlow<T>, MutableSharedFlow<T> {\n    /**\n     * The current value of this state flow.\n     *\n     * Setting a value that is [equal][Any.equals] to the previous one does nothing.\n     *\n     * This property is **thread-safe** and can be safely updated from concurrent coroutines without\n     * external synchronization.\n     */\n    public override var value: T\n\n    /**\n     * Atomically compares the current [value] with [expect] and sets it to [update] if it is equal to [expect].\n     * The result is `true` if the [value] was set to [update] and `false` otherwise.\n     *\n     * This function use a regular comparison using [Any.equals]. If both [expect] and [update] are equal to the\n     * current [value], this function returns `true`, but it does not actually change the reference that is\n     * stored in the [value].\n     *\n     * This method is **thread-safe** and can be safely invoked from concurrent coroutines without\n     * external synchronization.\n     */\n    public fun compareAndSet(expect: T, update: T): Boolean\n}\n\n/**\n * Creates a [MutableStateFlow] with the given initial [value].\n */\n@Suppress(\"FunctionName\")\npublic fun <T> MutableStateFlow(value: T): MutableStateFlow<T> = StateFlowImpl(value ?: NULL)\n\n// ------------------------------------ Update methods ------------------------------------\n\n/**\n * Updates the [MutableStateFlow.value] atomically using the specified [function] of its value, and returns the new\n * value.\n *\n * [function] may be evaluated multiple times, if [value] is being concurrently updated.\n */\npublic inline fun <T> MutableStateFlow<T>.updateAndGet(function: (T) -> T): T {\n    while (true) {\n        val prevValue = value\n        val nextValue = function(prevValue)\n        if (compareAndSet(prevValue, nextValue)) {\n            return nextValue\n        }\n    }\n}\n\n/**\n * Updates the [MutableStateFlow.value] atomically using the specified [function] of its value, and returns its\n * prior value.\n *\n * [function] may be evaluated multiple times, if [value] is being concurrently updated.\n */\npublic inline fun <T> MutableStateFlow<T>.getAndUpdate(function: (T) -> T): T {\n    while (true) {\n        val prevValue = value\n        val nextValue = function(prevValue)\n        if (compareAndSet(prevValue, nextValue)) {\n            return prevValue\n        }\n    }\n}\n\n\n/**\n * Updates the [MutableStateFlow.value] atomically using the specified [function] of its value.\n *\n * [function] may be evaluated multiple times, if [value] is being concurrently updated.\n */\npublic inline fun <T> MutableStateFlow<T>.update(function: (T) -> T) {\n    while (true) {\n        val prevValue = value\n        val nextValue = function(prevValue)\n        if (compareAndSet(prevValue, nextValue)) {\n            return\n        }\n    }\n}\n\n// ------------------------------------ Implementation ------------------------------------\n\nprivate val NONE = Symbol(\"NONE\")\n\nprivate val PENDING = Symbol(\"PENDING\")\n\n// StateFlow slots are allocated for its collectors\nprivate class StateFlowSlot : AbstractSharedFlowSlot<StateFlowImpl<*>>() {\n    /**\n     * Each slot can have one of the following states:\n     *\n     * - `null` -- it is not used right now. Can [allocateLocked] to new collector.\n     * - `NONE` -- used by a collector, but neither suspended nor has pending value.\n     * - `PENDING` -- pending to process new value.\n     * - `CancellableContinuationImpl<Unit>` -- suspended waiting for new value.\n     *\n     * It is important that default `null` value is used, because there can be a race between allocation\n     * of a new slot and trying to do [makePending] on this slot.\n     *\n     * ===\n     * This should be `atomic<Any?>(null)` instead of the atomic reference, but because of #3820\n     * it is used as a **temporary** solution starting from 1.8.1 version.\n     * Depending on the fix rollout on Android, it will be removed in 1.9.0 or 2.0.0.\n     * See https://issuetracker.google.com/issues/325123736\n     */\n    private val _state = WorkaroundAtomicReference<Any?>(null)\n\n    override fun allocateLocked(flow: StateFlowImpl<*>): Boolean {\n        // No need for atomic check & update here, since allocated happens under StateFlow lock\n        if (_state.value != null) return false // not free\n        _state.value = NONE // allocated\n        return true\n    }\n\n    override fun freeLocked(flow: StateFlowImpl<*>): Array<Continuation<Unit>?> {\n        _state.value = null // free now\n        return EMPTY_RESUMES // nothing more to do\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun makePending() {\n        _state.loop { state ->\n            when {\n                state == null -> return // this slot is free - skip it\n                state === PENDING -> return // already pending, nothing to do\n                state === NONE -> { // mark as pending\n                    if (_state.compareAndSet(state, PENDING)) return\n                }\n                else -> { // must be a suspend continuation state\n                    // we must still use CAS here since continuation may get cancelled and free the slot at any time\n                    if (_state.compareAndSet(state, NONE)) {\n                        (state as CancellableContinuationImpl<Unit>).resume(Unit)\n                        return\n                    }\n                }\n            }\n        }\n    }\n\n    fun takePending(): Boolean = _state.getAndSet(NONE)!!.let { state ->\n        assert { state !is CancellableContinuationImpl<*> }\n        return state === PENDING\n    }\n\n    suspend fun awaitPending(): Unit = suspendCancellableCoroutine sc@ { cont ->\n        assert { _state.value !is CancellableContinuationImpl<*> } // can be NONE or PENDING\n        if (_state.compareAndSet(NONE, cont)) return@sc // installed continuation, waiting for pending\n        // CAS failed -- the only possible reason is that it is already in pending state now\n        assert { _state.value === PENDING }\n        cont.resume(Unit)\n    }\n}\n\nprivate class StateFlowImpl<T>(\n    initialState: Any // T | NULL\n) : AbstractSharedFlow<StateFlowSlot>(), MutableStateFlow<T>, CancellableFlow<T>, FusibleFlow<T> {\n    private val _state = atomic(initialState) // T | NULL\n    private var sequence = 0 // serializes updates, value update is in process when sequence is odd\n\n    public override var value: T\n        get() = NULL.unbox(_state.value)\n        set(value) { updateState(null, value ?: NULL) }\n\n    override fun compareAndSet(expect: T, update: T): Boolean =\n        updateState(expect ?: NULL, update ?: NULL)\n\n    private fun updateState(expectedState: Any?, newState: Any): Boolean {\n        var curSequence: Int\n        var curSlots: Array<StateFlowSlot?>? // benign race, we will not use it\n        synchronized(this) {\n            val oldState = _state.value\n            if (expectedState != null && oldState != expectedState) return false // CAS support\n            if (oldState == newState) return true // Don't do anything if value is not changing, but CAS -> true\n            _state.value = newState\n            curSequence = sequence\n            if (curSequence and 1 == 0) { // even sequence means quiescent state flow (no ongoing update)\n                curSequence++ // make it odd\n                sequence = curSequence\n            } else {\n                // update is already in process, notify it, and return\n                sequence = curSequence + 2 // change sequence to notify, keep it odd\n                return true // updated\n            }\n            curSlots = slots // read current reference to collectors under lock\n        }\n        /*\n           Fire value updates outside of the lock to avoid deadlocks with unconfined coroutines.\n           Loop until we're done firing all the changes. This is a sort of simple flat combining that\n           ensures sequential firing of concurrent updates and avoids the storm of collector resumes\n           when updates happen concurrently from many threads.\n         */\n        while (true) {\n            // Benign race on element read from array\n            curSlots?.forEach {\n                it?.makePending()\n            }\n            // check if the value was updated again while we were updating the old one\n            synchronized(this) {\n                if (sequence == curSequence) { // nothing changed, we are done\n                    sequence = curSequence + 1 // make sequence even again\n                    return true // done, updated\n                }\n                // reread everything for the next loop under the lock\n                curSequence = sequence\n                curSlots = slots\n            }\n        }\n    }\n\n    override val replayCache: List<T>\n        get() = listOf(value)\n\n    override fun tryEmit(value: T): Boolean {\n        this.value = value\n        return true\n    }\n\n    override suspend fun emit(value: T) {\n        this.value = value\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun resetReplayCache() {\n        throw UnsupportedOperationException(\"MutableStateFlow.resetReplayCache is not supported\")\n    }\n\n    override suspend fun collect(collector: FlowCollector<T>): Nothing {\n        val slot = allocateSlot()\n        try {\n            if (collector is SubscribedFlowCollector) collector.onSubscription()\n            val collectorJob = currentCoroutineContext()[Job]\n            var oldState: Any? = null // previously emitted T!! | NULL (null -- nothing emitted yet)\n            // The loop is arranged so that it starts delivering current value without waiting first\n            while (true) {\n                // Here the coroutine could have waited for a while to be dispatched,\n                // so we use the most recent state here to ensure the best possible conflation of stale values\n                val newState = _state.value\n                // always check for cancellation\n                collectorJob?.ensureActive()\n                // Conflate value emissions using equality\n                if (oldState == null || oldState != newState) {\n                    collector.emit(NULL.unbox(newState))\n                    oldState = newState\n                }\n                // Note: if awaitPending is cancelled, then it bails out of this loop and calls freeSlot\n                if (!slot.takePending()) { // try fast-path without suspending first\n                    slot.awaitPending() // only suspend for new values when needed\n                }\n            }\n        } finally {\n            freeSlot(slot)\n        }\n    }\n\n    override fun createSlot() = StateFlowSlot()\n    override fun createSlotArray(size: Int): Array<StateFlowSlot?> = arrayOfNulls(size)\n\n    override fun fuse(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow) =\n        fuseStateFlow(context, capacity, onBufferOverflow)\n}\n\ninternal fun <T> StateFlow<T>.fuseStateFlow(\n    context: CoroutineContext,\n    capacity: Int,\n    onBufferOverflow: BufferOverflow\n): Flow<T> {\n    // state flow is always conflated so additional conflation does not have any effect\n    assert { capacity != Channel.CONFLATED } // should be desugared by callers\n    if ((capacity in 0..1 || capacity == Channel.BUFFERED) && onBufferOverflow == BufferOverflow.DROP_OLDEST) {\n        return this\n    }\n    return fuseSharedFlow(context, capacity, onBufferOverflow)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/AbstractSharedFlow.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n@JvmField\ninternal val EMPTY_RESUMES = arrayOfNulls<Continuation<Unit>?>(0)\n\ninternal abstract class AbstractSharedFlowSlot<F> {\n    abstract fun allocateLocked(flow: F): Boolean\n    abstract fun freeLocked(flow: F): Array<Continuation<Unit>?> // returns continuations to resume after lock\n}\n\ninternal abstract class AbstractSharedFlow<S : AbstractSharedFlowSlot<*>> : SynchronizedObject() {\n    protected var slots: Array<S?>? = null // allocated when needed\n        private set\n    protected var nCollectors = 0 // number of allocated (!free) slots\n        private set\n    private var nextIndex = 0 // oracle for the next free slot index\n    private var _subscriptionCount: SubscriptionCountStateFlow? = null // init on first need\n\n    val subscriptionCount: StateFlow<Int>\n        get() = synchronized(this) {\n            // allocate under lock in sync with nCollectors variable\n            _subscriptionCount ?: SubscriptionCountStateFlow(nCollectors).also {\n                _subscriptionCount = it\n            }\n        }\n\n    protected abstract fun createSlot(): S\n\n    protected abstract fun createSlotArray(size: Int): Array<S?>\n\n    @Suppress(\"UNCHECKED_CAST\")\n    protected fun allocateSlot(): S {\n        // Actually create slot under lock\n        val subscriptionCount: SubscriptionCountStateFlow?\n        val slot = synchronized(this) {\n            val slots = when (val curSlots = slots) {\n                null -> createSlotArray(2).also { slots = it }\n                else -> if (nCollectors >= curSlots.size) {\n                    curSlots.copyOf(2 * curSlots.size).also { slots = it }\n                } else {\n                    curSlots\n                }\n            }\n            var index = nextIndex\n            var slot: S\n            while (true) {\n                slot = slots[index] ?: createSlot().also { slots[index] = it }\n                index++\n                if (index >= slots.size) index = 0\n                if ((slot as AbstractSharedFlowSlot<Any>).allocateLocked(this)) break // break when found and allocated free slot\n            }\n            nextIndex = index\n            nCollectors++\n            subscriptionCount = _subscriptionCount // retrieve under lock if initialized\n            slot\n        }\n        // increments subscription count\n        subscriptionCount?.increment(1)\n        return slot\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    protected fun freeSlot(slot: S) {\n        // Release slot under lock\n        val subscriptionCount: SubscriptionCountStateFlow?\n        val resumes = synchronized(this) {\n            nCollectors--\n            subscriptionCount = _subscriptionCount // retrieve under lock if initialized\n            // Reset next index oracle if we have no more active collectors for more predictable behavior next time\n            if (nCollectors == 0) nextIndex = 0\n            (slot as AbstractSharedFlowSlot<Any>).freeLocked(this)\n        }\n        /*\n         * Resume suspended coroutines.\n         * This can happen when the subscriber that was freed was a slow one and was holding up buffer.\n         * When this subscriber was freed, previously queued emitted can now wake up and are resumed here.\n         */\n        for (cont in resumes) cont?.resume(Unit)\n        // decrement subscription count\n        subscriptionCount?.increment(-1)\n    }\n\n    protected inline fun forEachSlotLocked(block: (S) -> Unit) {\n        if (nCollectors == 0) return\n        slots?.forEach { slot ->\n            if (slot != null) block(slot)\n        }\n    }\n}\n\n/**\n * [StateFlow] that represents the number of subscriptions.\n *\n * It is exposed as a regular [StateFlow] in our public API, but it is implemented as [SharedFlow] undercover to\n * avoid conflations of consecutive updates because the subscription count is very sensitive to it.\n *\n * The importance of non-conflating can be demonstrated with the following example:\n * ```\n * val shared = flowOf(239).stateIn(this, SharingStarted.Lazily, 42) // stateIn for the sake of the initial value\n * println(shared.first())\n * yield()\n * println(shared.first())\n * ```\n * If the flow is shared within the same dispatcher (e.g. Main) or with a slow/throttled one,\n * the `SharingStarted.Lazily` will never be able to start the source: `first` sees the initial value and immediately\n * unsubscribes, leaving the asynchronous `SharingStarted` with conflated zero.\n *\n * To avoid that (especially in a more complex scenarios), we do not conflate subscription updates.\n */\nprivate class SubscriptionCountStateFlow(initialValue: Int) : StateFlow<Int>,\n    SharedFlowImpl<Int>(1, Int.MAX_VALUE, BufferOverflow.DROP_OLDEST)\n{\n    init { tryEmit(initialValue) }\n\n    override val value: Int\n        get() = synchronized(this) { lastReplayedLocked }\n\n    fun increment(delta: Int) = synchronized(this) {\n        tryEmit(lastReplayedLocked + delta)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/ChannelFlow.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.jvm.*\n\ninternal fun <T> Flow<T>.asChannelFlow(): ChannelFlow<T> =\n    this as? ChannelFlow ?: ChannelFlowOperatorImpl(this)\n\n/**\n * Operators that can fuse with **downstream** [buffer] and [flowOn] operators implement this interface.\n *\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic interface FusibleFlow<T> : Flow<T> {\n    /**\n     * This function is called by [flowOn] (with context) and [buffer] (with capacity) operators\n     * that are applied to this flow. Should not be used with [capacity] of [Channel.CONFLATED]\n     * (it shall be desugared to `capacity = 0, onBufferOverflow = DROP_OLDEST`).\n     */\n    public fun fuse(\n        context: CoroutineContext = EmptyCoroutineContext,\n        capacity: Int = Channel.OPTIONAL_CHANNEL,\n        onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n    ): Flow<T>\n}\n\n/**\n * Operators that use channels as their \"output\" extend this `ChannelFlow` and are always fused with each other.\n * This class servers as a skeleton implementation of [FusibleFlow] and provides other cross-cutting\n * methods like ability to [produceIn] the corresponding flow, thus making it\n * possible to directly use the backing channel if it exists (hence the `ChannelFlow` name).\n *\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic abstract class ChannelFlow<T>(\n    // upstream context\n    @JvmField public val context: CoroutineContext,\n    // buffer capacity between upstream and downstream context\n    @JvmField public val capacity: Int,\n    // buffer overflow strategy\n    @JvmField public val onBufferOverflow: BufferOverflow\n) : FusibleFlow<T> {\n    init {\n        assert { capacity != Channel.CONFLATED } // CONFLATED must be desugared to 0, DROP_OLDEST by callers\n    }\n\n    // shared code to create a suspend lambda from collectTo function in one place\n    internal val collectToFun: suspend (ProducerScope<T>) -> Unit\n        get() = { collectTo(it) }\n\n    internal val produceCapacity: Int\n        get() = if (capacity == Channel.OPTIONAL_CHANNEL) Channel.BUFFERED else capacity\n\n    /**\n     * When this [ChannelFlow] implementation can work without a channel (supports [Channel.OPTIONAL_CHANNEL]),\n     * then it should return a non-null value from this function, so that a caller can use it without the effect of\n     * additional [flowOn] and [buffer] operators, by incorporating its\n     * [context], [capacity], and [onBufferOverflow] into its own implementation.\n     */\n    public open fun dropChannelOperators(): Flow<T>? = null\n\n    public override fun fuse(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): Flow<T> {\n        assert { capacity != Channel.CONFLATED } // CONFLATED must be desugared to (0, DROP_OLDEST) by callers\n        // note: previous upstream context (specified before) takes precedence\n        val newContext = context + this.context\n        val newCapacity: Int\n        val newOverflow: BufferOverflow\n        if (onBufferOverflow != BufferOverflow.SUSPEND) {\n            // this additional buffer never suspends => overwrite preceding buffering configuration\n            newCapacity = capacity\n            newOverflow = onBufferOverflow\n        } else {\n            // combine capacities, keep previous overflow strategy\n            newCapacity = when {\n                this.capacity == Channel.OPTIONAL_CHANNEL -> capacity\n                capacity == Channel.OPTIONAL_CHANNEL -> this.capacity\n                this.capacity == Channel.BUFFERED -> capacity\n                capacity == Channel.BUFFERED -> this.capacity\n                else -> {\n                    // sanity checks\n                    assert { this.capacity >= 0 }\n                    assert { capacity >= 0 }\n                    // combine capacities clamping to UNLIMITED on overflow\n                    val sum = this.capacity + capacity\n                    if (sum >= 0) sum else Channel.UNLIMITED // unlimited on int overflow\n                }\n            }\n            newOverflow = this.onBufferOverflow\n        }\n        if (newContext == this.context && newCapacity == this.capacity && newOverflow == this.onBufferOverflow)\n            return this\n        return create(newContext, newCapacity, newOverflow)\n    }\n\n    protected abstract fun create(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): ChannelFlow<T>\n\n    protected abstract suspend fun collectTo(scope: ProducerScope<T>)\n\n    /**\n     * Here we use ATOMIC start for a reason (#1825).\n     * NB: [produceImpl] is used for [flowOn].\n     * For non-atomic start it is possible to observe the situation,\n     * where the pipeline after the [flowOn] call successfully executes (mostly, its `onCompletion`)\n     * handlers, while the pipeline before does not, because it was cancelled during its dispatch.\n     * Thus `onCompletion` and `finally` blocks won't be executed and it may lead to a different kinds of memory leaks.\n     */\n    public open fun produceImpl(scope: CoroutineScope): ReceiveChannel<T> =\n        scope.produce(context, produceCapacity, onBufferOverflow, start = CoroutineStart.ATOMIC, block = collectToFun)\n\n    override suspend fun collect(collector: FlowCollector<T>): Unit =\n        coroutineScope {\n            collector.emitAll(produceImpl(this))\n        }\n\n    protected open fun additionalToStringProps(): String? = null\n\n    // debug toString\n    override fun toString(): String {\n        val props = ArrayList<String>(4)\n        additionalToStringProps()?.let { props.add(it) }\n        if (context !== EmptyCoroutineContext) props.add(\"context=$context\")\n        if (capacity != Channel.OPTIONAL_CHANNEL) props.add(\"capacity=$capacity\")\n        if (onBufferOverflow != BufferOverflow.SUSPEND) props.add(\"onBufferOverflow=$onBufferOverflow\")\n        return \"$classSimpleName[${props.joinToString(\", \")}]\"\n    }\n}\n\n// ChannelFlow implementation that operates on another flow before it\ninternal abstract class ChannelFlowOperator<S, T>(\n    @JvmField protected val flow: Flow<S>,\n    context: CoroutineContext,\n    capacity: Int,\n    onBufferOverflow: BufferOverflow\n) : ChannelFlow<T>(context, capacity, onBufferOverflow) {\n    protected abstract suspend fun flowCollect(collector: FlowCollector<T>)\n\n    // Changes collecting context upstream to the specified newContext, while collecting in the original context\n    private suspend fun collectWithContextUndispatched(collector: FlowCollector<T>, newContext: CoroutineContext) {\n        val originalContextCollector = collector.withUndispatchedContextCollector(coroutineContext)\n        // invoke flowCollect(originalContextCollector) in the newContext\n        return withContextUndispatched(newContext, block = { flowCollect(it) }, value = originalContextCollector)\n    }\n\n    // Slow path when output channel is required\n    protected override suspend fun collectTo(scope: ProducerScope<T>) =\n        flowCollect(SendingCollector(scope))\n\n    // Optimizations for fast-path when channel creation is optional\n    override suspend fun collect(collector: FlowCollector<T>) {\n        // Fast-path: When channel creation is optional (flowOn/flowWith operators without buffer)\n        if (capacity == Channel.OPTIONAL_CHANNEL) {\n            val collectContext = coroutineContext\n            val newContext = collectContext.newCoroutineContext(context) // compute resulting collect context\n            // #1: If the resulting context happens to be the same as it was -- fallback to plain collect\n            if (newContext == collectContext)\n                return flowCollect(collector)\n            // #2: If we don't need to change the dispatcher we can go without channels\n            if (newContext[ContinuationInterceptor] == collectContext[ContinuationInterceptor])\n                return collectWithContextUndispatched(collector, newContext)\n        }\n        // Slow-path: create the actual channel\n        super.collect(collector)\n    }\n\n    // debug toString\n    override fun toString(): String = \"$flow -> ${super.toString()}\"\n}\n\n/**\n * Simple channel flow operator: [flowOn], [buffer], or their fused combination.\n */\ninternal class ChannelFlowOperatorImpl<T>(\n    flow: Flow<T>,\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = Channel.OPTIONAL_CHANNEL,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n) : ChannelFlowOperator<T, T>(flow, context, capacity, onBufferOverflow) {\n    override fun create(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): ChannelFlow<T> =\n        ChannelFlowOperatorImpl(flow, context, capacity, onBufferOverflow)\n\n    override fun dropChannelOperators(): Flow<T> = flow\n\n    override suspend fun flowCollect(collector: FlowCollector<T>) =\n        flow.collect(collector)\n}\n\n// Now if the underlying collector was accepting concurrent emits, then this one is too\n// todo: we might need to generalize this pattern for \"thread-safe\" operators that can fuse with channels\nprivate fun <T> FlowCollector<T>.withUndispatchedContextCollector(emitContext: CoroutineContext): FlowCollector<T> = when (this) {\n    // SendingCollector & NopCollector do not care about the context at all and can be used as is\n    is SendingCollector, is NopCollector -> this\n    // Otherwise just wrap into UndispatchedContextCollector interface implementation\n    else -> UndispatchedContextCollector(this, emitContext)\n}\n\nprivate class UndispatchedContextCollector<T>(\n    downstream: FlowCollector<T>,\n    private val emitContext: CoroutineContext\n) : FlowCollector<T> {\n    private val countOrElement = threadContextElements(emitContext) // precompute for fast withContextUndispatched\n    private val emitRef: suspend (T) -> Unit = { downstream.emit(it) } // allocate suspend function ref once on creation\n\n    override suspend fun emit(value: T): Unit =\n        withContextUndispatched(emitContext, value, countOrElement, emitRef)\n}\n\n// Efficiently computes block(value) in the newContext\ninternal suspend fun <T, V> withContextUndispatched(\n    newContext: CoroutineContext,\n    value: V,\n    countOrElement: Any = threadContextElements(newContext), // can be precomputed for speed\n    block: suspend (V) -> T\n): T =\n    suspendCoroutineUninterceptedOrReturn { uCont ->\n        withCoroutineContext(newContext, countOrElement) {\n            block.startCoroutineUninterceptedOrReturn(value, StackFrameContinuation(uCont, newContext))\n        }\n    }\n\n// Continuation that links the caller with uCont with walkable CoroutineStackFrame\nprivate class StackFrameContinuation<T>(\n    private val uCont: Continuation<T>, override val context: CoroutineContext\n) : Continuation<T>, CoroutineStackFrame {\n\n    override val callerFrame: CoroutineStackFrame?\n        get() = uCont as? CoroutineStackFrame\n\n    override fun resumeWith(result: Result<T>) {\n        uCont.resumeWith(result)\n    }\n\n    override fun getStackTraceElement(): StackTraceElement? = null\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/Combine.kt",
        "content": "@file:Suppress(\"UNCHECKED_CAST\") // KT-32203\n\npackage kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.internal.*\nprivate typealias Update = IndexedValue<Any?>\n\n@PublishedApi\ninternal suspend fun <R, T> FlowCollector<R>.combineInternal(\n    flows: Array<out Flow<T>>,\n    arrayFactory: () -> Array<T?>?, // Array factory is required to workaround array typing on JVM\n    transform: suspend FlowCollector<R>.(Array<T>) -> Unit\n): Unit = flowScope { // flow scope so any cancellation within the source flow will cancel the whole scope\n    val size = flows.size\n    if (size == 0) return@flowScope // bail-out for empty input\n    val latestValues = arrayOfNulls<Any?>(size)\n    latestValues.fill(UNINITIALIZED) // Smaller bytecode & faster than Array(size) { UNINITIALIZED }\n    val resultChannel = Channel<Update>(size)\n    val nonClosed = LocalAtomicInt(size)\n    var remainingAbsentValues = size\n    for (i in 0 until size) {\n        // Coroutine per flow that keeps track of its value and sends result to downstream\n        launch {\n            try {\n                flows[i].collect { value ->\n                    resultChannel.send(Update(i, value))\n                    yield() // Emulate fairness, giving each flow chance to emit\n                }\n            } finally {\n                // Close the channel when there is no more flows\n                if (nonClosed.decrementAndGet() == 0) {\n                    resultChannel.close()\n                }\n            }\n        }\n    }\n\n    /*\n     * Batch-receive optimization: read updates in batches, but bail-out\n     * as soon as we encountered two values from the same source\n     */\n    val lastReceivedEpoch = ByteArray(size)\n    var currentEpoch: Byte = 0\n    while (true) {\n        ++currentEpoch\n        // Start batch\n        // The very first receive in epoch should be suspending\n        var element = resultChannel.receiveCatching().getOrNull() ?: break // Channel is closed, nothing to do here\n        while (true) {\n            val index = element.index\n            // Update values\n            val previous = latestValues[index]\n            latestValues[index] = element.value\n            if (previous === UNINITIALIZED) --remainingAbsentValues\n            // Check epoch\n            // Received the second value from the same flow in the same epoch -- bail out\n            if (lastReceivedEpoch[index] == currentEpoch) break\n            lastReceivedEpoch[index] = currentEpoch\n            element = resultChannel.tryReceive().getOrNull() ?: break\n        }\n\n        // Process batch result if there is enough data\n        if (remainingAbsentValues == 0) {\n            /*\n             * If arrayFactory returns null, then we can avoid array copy because\n             * it's our own safe transformer that immediately deconstructs the array\n             */\n            val results = arrayFactory()\n            if (results == null) {\n                transform(latestValues as Array<T>)\n            } else {\n                (latestValues as Array<T?>).copyInto(results)\n                transform(results as Array<T>)\n            }\n        }\n    }\n}\n\ninternal fun <T1, T2, R> zipImpl(flow: Flow<T1>, flow2: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> =\n    unsafeFlow {\n        coroutineScope {\n            val second = produce<Any> {\n                flow2.collect { value ->\n                    return@collect channel.send(value ?: NULL)\n                }\n            }\n\n            /*\n             * This approach only works with rendezvous channel and is required to enforce correctness\n             * in the following scenario:\n             * ```\n             * val f1 = flow { emit(1); delay(Long.MAX_VALUE) }\n             * val f2 = flowOf(1)\n             * f1.zip(f2) { ... }\n             * ```\n             *\n             * Invariant: this clause is invoked only when all elements from the channel were processed (=> rendezvous restriction).\n             */\n            val collectJob = Job()\n            (second as SendChannel<*>).invokeOnClose {\n                // Optimization to avoid AFE allocation when the other flow is done\n                if (collectJob.isActive) collectJob.cancel(AbortFlowException(collectJob))\n            }\n\n            try {\n                /*\n                 * Non-trivial undispatched (because we are in the right context and there is no structured concurrency)\n                 * hierarchy:\n                 * -Outer coroutineScope that owns the whole zip process\n                 * - First flow is collected by the child of coroutineScope, collectJob.\n                 *    So it can be safely cancelled as soon as the second flow is done\n                 * - **But** the downstream MUST NOT be cancelled when the second flow is done,\n                 *    so we emit to downstream from coroutineScope job.\n                 * Typically, such hierarchy requires coroutine for collector that communicates\n                 * with coroutines scope via a channel, but it's way too expensive, so\n                 * we are using this trick instead.\n                 */\n                val scopeContext = coroutineContext\n                val cnt = threadContextElements(scopeContext)\n                withContextUndispatched(coroutineContext + collectJob, Unit) {\n                    flow.collect { value ->\n                        withContextUndispatched(scopeContext, Unit, cnt) {\n                            val otherValue = second.receiveCatching().getOrElse {\n                                throw it ?: AbortFlowException(collectJob)\n                            }\n                            emit(transform(value, NULL.unbox(otherValue)))\n                        }\n                    }\n                }\n            } catch (e: AbortFlowException) {\n                e.checkOwnership(owner = collectJob)\n            } finally {\n                second.cancel()\n            }\n        }\n    }\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/FlowCoroutine.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.intrinsics.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlinx.coroutines.flow.internal.unsafeFlow as flow\n\n/**\n * Creates a [CoroutineScope] and calls the specified suspend block with this scope.\n * This builder is similar to [coroutineScope] with the only exception that it *ties* lifecycle of children\n * and itself regarding the cancellation, thus being cancelled when one of the children becomes cancelled.\n *\n * For example:\n * ```\n * flowScope {\n *     launch {\n *         throw CancellationException()\n *     }\n * } // <- CE will be rethrown here\n * ```\n */\ninternal suspend fun <R> flowScope(@BuilderInference block: suspend CoroutineScope.() -> R): R =\n    suspendCoroutineUninterceptedOrReturn { uCont ->\n        val coroutine = FlowCoroutine(uCont.context, uCont)\n        coroutine.startUndispatchedOrReturn(coroutine, block)\n    }\n\n/**\n * Creates a flow that also provides a [CoroutineScope] for each collector\n * Shorthand for:\n * ```\n * flow {\n *     flowScope {\n *         ...\n *     }\n * }\n * ```\n * with additional constraint on cancellation.\n * To cancel child without cancelling itself, `cancel(ChildCancelledException())` should be used.\n */\ninternal fun <R> scopedFlow(@BuilderInference block: suspend CoroutineScope.(FlowCollector<R>) -> Unit): Flow<R> =\n    flow {\n        flowScope { block(this@flow) }\n    }\n\nprivate class FlowCoroutine<T>(\n    context: CoroutineContext,\n    uCont: Continuation<T>\n) : ScopeCoroutine<T>(context, uCont) {\n    override fun childCancelled(cause: Throwable): Boolean {\n        if (cause is ChildCancelledException) return true\n        return cancelImpl(cause)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/FlowExceptions.common.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n/**\n * This exception is thrown when an operator needs no more elements from the flow.\n * The operator should never allow this exception to be thrown past its own boundary.\n * This exception can be safely ignored by non-terminal flow operator if and only if it was caught by its owner\n * (see usages of [checkOwnership]).\n * Therefore, the [owner] parameter must be unique for every invocation of every operator.\n */\ninternal expect class AbortFlowException(owner: Any) : CancellationException {\n    val owner: Any\n}\n\ninternal fun AbortFlowException.checkOwnership(owner: Any) {\n    if (this.owner !== owner) throw this\n}\n\n/**\n * Exception used to cancel child of [scopedFlow] without cancelling the whole scope.\n */\ninternal expect class ChildCancelledException() : CancellationException\n\n@Suppress(\"NOTHING_TO_INLINE\")\n@PublishedApi\ninternal inline fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throw ArithmeticException(\"Index overflow has happened\")\n    }\n    return index\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/Merge.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.coroutines.*\n\ninternal class ChannelFlowTransformLatest<T, R>(\n    private val transform: suspend FlowCollector<R>.(value: T) -> Unit,\n    flow: Flow<T>,\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = Channel.BUFFERED,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n) : ChannelFlowOperator<T, R>(flow, context, capacity, onBufferOverflow) {\n    override fun create(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): ChannelFlow<R> =\n        ChannelFlowTransformLatest(transform, flow, context, capacity, onBufferOverflow)\n\n    override suspend fun flowCollect(collector: FlowCollector<R>) {\n        assert { collector is SendingCollector } // So cancellation behaviour is not leaking into the downstream\n        coroutineScope {\n            var previousFlow: Job? = null\n            flow.collect { value ->\n                previousFlow?.apply {\n                    cancel(ChildCancelledException())\n                    join()\n                }\n                // Do not pay for dispatch here, it's never necessary\n                previousFlow = launch(start = CoroutineStart.UNDISPATCHED) {\n                    collector.transform(value)\n                }\n            }\n        }\n    }\n}\n\ninternal class ChannelFlowMerge<T>(\n    private val flow: Flow<Flow<T>>,\n    private val concurrency: Int,\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = Channel.BUFFERED,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n) : ChannelFlow<T>(context, capacity, onBufferOverflow) {\n    override fun create(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): ChannelFlow<T> =\n        ChannelFlowMerge(flow, concurrency, context, capacity, onBufferOverflow)\n\n    override fun produceImpl(scope: CoroutineScope): ReceiveChannel<T> {\n        return scope.produce(context, capacity, block = collectToFun)\n    }\n\n    override suspend fun collectTo(scope: ProducerScope<T>) {\n        val semaphore = Semaphore(concurrency)\n        val collector = SendingCollector(scope)\n        val job: Job? = coroutineContext[Job]\n        flow.collect { inner ->\n            /*\n             * We launch a coroutine on each emitted element and the only potential\n             * suspension point in this collector is `semaphore.acquire` that rarely suspends,\n             * so we manually check for cancellation to propagate it to the upstream in time.\n             */\n            job?.ensureActive()\n            semaphore.acquire()\n            scope.launch {\n                try {\n                    inner.collect(collector)\n                } finally {\n                    semaphore.release() // Release concurrency permit\n                }\n            }\n        }\n    }\n\n    override fun additionalToStringProps(): String = \"concurrency=$concurrency\"\n}\n\ninternal class ChannelLimitedFlowMerge<T>(\n    private val flows: Iterable<Flow<T>>,\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = Channel.BUFFERED,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n) : ChannelFlow<T>(context, capacity, onBufferOverflow) {\n    override fun create(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): ChannelFlow<T> =\n        ChannelLimitedFlowMerge(flows, context, capacity, onBufferOverflow)\n\n    override fun produceImpl(scope: CoroutineScope): ReceiveChannel<T> {\n        return scope.produce(context, capacity, block = collectToFun)\n    }\n\n    override suspend fun collectTo(scope: ProducerScope<T>) {\n        val collector = SendingCollector(scope)\n        flows.forEach { flow ->\n            scope.launch { flow.collect(collector) }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/NopCollector.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.flow.*\n\ninternal object NopCollector : FlowCollector<Any?> {\n    override suspend fun emit(value: Any?) {\n        // does nothing\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/NullSurrogate.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.jvm.*\n\n/**\n * This value is used a a surrogate `null` value when needed.\n * It should never leak to the outside world.\n * Its usage typically are paired with [Symbol.unbox] usages.\n */\n@JvmField\ninternal val NULL = Symbol(\"NULL\")\n\n/**\n * Symbol to indicate that the value is not yet initialized.\n * It should never leak to the outside world.\n */\n@JvmField\ninternal val UNINITIALIZED = Symbol(\"UNINITIALIZED\")\n\n/*\n * Symbol used to indicate that the flow is complete.\n * It should never leak to the outside world.\n */\n@JvmField\ninternal val DONE = Symbol(\"DONE\")\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/SafeCollector.common.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.internal.ScopeCoroutine\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n// Collector that ensures exception transparency and context preservation on a best-effort basis.\n// See an explanation in SafeCollector JVM actualization.\ninternal expect class SafeCollector<T>(\n    collector: FlowCollector<T>,\n    collectContext: CoroutineContext\n) : FlowCollector<T> {\n    internal val collector: FlowCollector<T>\n    internal val collectContext: CoroutineContext\n    internal val collectContextSize: Int\n    public fun releaseIntercepted()\n    public override suspend fun emit(value: T)\n}\n\n@JvmName(\"checkContext\") // For prettier stack traces\ninternal fun SafeCollector<*>.checkContext(currentContext: CoroutineContext) {\n    val result = currentContext.fold(0) fold@{ count, element ->\n        val key = element.key\n        val collectElement = collectContext[key]\n        if (key !== Job) {\n            return@fold if (element !== collectElement) Int.MIN_VALUE\n            else count + 1\n        }\n\n        val collectJob = collectElement as Job?\n        val emissionParentJob = (element as Job).transitiveCoroutineParent(collectJob)\n        /*\n         * Code like\n         * ```\n         * coroutineScope {\n         *     launch {\n         *         emit(1)\n         *     }\n         *\n         *     launch {\n         *         emit(2)\n         *     }\n         * }\n         * ```\n         * is prohibited because 'emit' is not thread-safe by default. Use 'channelFlow' instead if you need concurrent emission\n         * or want to switch context dynamically (e.g. with `withContext`).\n         *\n         * Note that collecting from another coroutine is allowed, e.g.:\n         * ```\n         * coroutineScope {\n         *     val channel = produce {\n         *         collect { value ->\n         *             send(value)\n         *         }\n         *     }\n         *     channel.consumeEach { value ->\n         *         emit(value)\n         *     }\n         * }\n         * ```\n         * is a completely valid.\n         */\n        if (emissionParentJob !== collectJob) {\n            error(\n                \"Flow invariant is violated:\\n\" +\n                        \"\\t\\tEmission from another coroutine is detected.\\n\" +\n                        \"\\t\\tChild of $emissionParentJob, expected child of $collectJob.\\n\" +\n                        \"\\t\\tFlowCollector is not thread-safe and concurrent emissions are prohibited.\\n\" +\n                        \"\\t\\tTo mitigate this restriction please use 'channelFlow' builder instead of 'flow'\"\n            )\n        }\n\n        /*\n         * If collect job is null (-> EmptyCoroutineContext, probably run from `suspend fun main`), then invariant is maintained\n         * (common transitive parent is \"null\"), but count check will fail, so just do not count job context element when\n         * flow is collected from EmptyCoroutineContext\n         */\n        if (collectJob == null) count else count + 1\n    }\n    if (result != collectContextSize) {\n        error(\n            \"Flow invariant is violated:\\n\" +\n                    \"\\t\\tFlow was collected in $collectContext,\\n\" +\n                    \"\\t\\tbut emission happened in $currentContext.\\n\" +\n                    \"\\t\\tPlease refer to 'flow' documentation or use 'flowOn' instead\"\n        )\n    }\n}\n\ninternal tailrec fun Job?.transitiveCoroutineParent(collectJob: Job?): Job? {\n    if (this === null) return null\n    if (this === collectJob) return this\n    if (this !is ScopeCoroutine<*>) return this\n    return parent.transitiveCoroutineParent(collectJob)\n}\n\n/**\n * An analogue of the [flow] builder that does not check the context of execution of the resulting flow.\n * Used in our own operators where we trust the context of invocations.\n */\n@PublishedApi\ninternal inline fun <T> unsafeFlow(@BuilderInference crossinline block: suspend FlowCollector<T>.() -> Unit): Flow<T> {\n    return object : Flow<T> {\n        override suspend fun collect(collector: FlowCollector<T>) {\n            collector.block()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/internal/SendingCollector.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\n\n/**\n * Collection that sends to channel\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic class SendingCollector<T>(\n    private val channel: SendChannel<T>\n) : FlowCollector<T> {\n    override suspend fun emit(value: T): Unit = channel.send(value)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Context.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.channels.Channel.Factory.BUFFERED\nimport kotlinx.coroutines.channels.Channel.Factory.CONFLATED\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * Buffers flow emissions via channel of a specified capacity and runs collector in a separate coroutine.\n *\n * Normally, [flows][Flow] are _sequential_. It means that the code of all operators is executed in the\n * same coroutine. For example, consider the following code using [onEach] and [collect] operators:\n *\n * ```\n * flowOf(\"A\", \"B\", \"C\")\n *     .onEach  { println(\"1$it\") }\n *     .collect { println(\"2$it\") }\n * ```\n *\n * It is going to be executed in the following order by the coroutine `Q` that calls this code:\n *\n * ```\n * Q : -->-- [1A] -- [2A] -- [1B] -- [2B] -- [1C] -- [2C] -->--\n * ```\n *\n * So if the operator's code takes considerable time to execute, then the total execution time is going to be\n * the sum of execution times for all operators.\n *\n * The `buffer` operator creates a separate coroutine during execution for the flow it applies to.\n * Consider the following code:\n *\n * ```\n * flowOf(\"A\", \"B\", \"C\")\n *     .onEach  { println(\"1$it\") }\n *     .buffer()  // <--------------- buffer between onEach and collect\n *     .collect { println(\"2$it\") }\n * ```\n *\n * It will use two coroutines for execution of the code. A coroutine `Q` that calls this code is\n * going to execute `collect`, and the code before `buffer` will be executed in a separate\n * new coroutine `P` concurrently with `Q`:\n *\n * ```\n * P : -->-- [1A] -- [1B] -- [1C] ---------->--  // flowOf(...).onEach { ... }\n *\n *                       |\n *                       | channel               // buffer()\n *                       V\n *\n * Q : -->---------- [2A] -- [2B] -- [2C] -->--  // collect\n * ```\n *\n * When the operator's code takes some time to execute, this decreases the total execution time of the flow.\n * A [channel][Channel] is used between the coroutines to send elements emitted by the coroutine `P` to\n * the coroutine `Q`. If the code before `buffer` operator (in the coroutine `P`) is faster than the code after\n * `buffer` operator (in the coroutine `Q`), then this channel will become full at some point and will suspend\n * the producer coroutine `P` until the consumer coroutine `Q` catches up.\n * The [capacity] parameter defines the size of this buffer.\n *\n * ### Buffer overflow\n *\n * By default, the emitter is suspended when the buffer overflows, to let collector catch up. This strategy can be\n * overridden with an optional [onBufferOverflow] parameter so that the emitter is never suspended. In this\n * case, on buffer overflow either the oldest value in the buffer is dropped with the [DROP_OLDEST][BufferOverflow.DROP_OLDEST]\n * strategy and the latest emitted value is added to the buffer,\n * or the latest value that is being emitted is dropped with the [DROP_LATEST][BufferOverflow.DROP_LATEST] strategy,\n * keeping the buffer intact.\n * To implement either of the custom strategies, a buffer of at least one element is used.\n *\n * ### Operator fusion\n *\n * Adjacent applications of [channelFlow], [flowOn], [buffer], and [produceIn] are\n * always fused so that only one properly configured channel is used for execution.\n *\n * Explicitly specified buffer capacity takes precedence over `buffer()` or `buffer(Channel.BUFFERED)` calls,\n * which effectively requests a buffer of any size. Multiple requests with a specified buffer\n * size produce a buffer with the sum of the requested buffer sizes.\n *\n * A `buffer` call with a non-default value of the [onBufferOverflow] parameter overrides all immediately preceding\n * buffering operators, because it never suspends its upstream, and thus no upstream buffer would ever be used.\n *\n * ### Conceptual implementation\n *\n * The actual implementation of `buffer` is not trivial due to the fusing, but conceptually its basic\n * implementation is equivalent to the following code that can be written using [produce]\n * coroutine builder to produce a channel and [consumeEach][ReceiveChannel.consumeEach] extension to consume it:\n *\n * ```\n * fun <T> Flow<T>.buffer(capacity: Int = DEFAULT): Flow<T> = flow {\n *     coroutineScope { // limit the scope of concurrent producer coroutine\n *         val channel = produce(capacity = capacity) {\n *             collect { send(it) } // send all to channel\n *         }\n *         // emit all received values\n *         channel.consumeEach { emit(it) }\n *     }\n * }\n * ```\n *\n * ### Conflation\n *\n * Usage of this function with [capacity] of [Channel.CONFLATED][Channel.CONFLATED] is a shortcut to\n * `buffer(onBufferOverflow = `[`BufferOverflow.DROP_OLDEST`][BufferOverflow.DROP_OLDEST]`)`, and is available via\n * a separate [conflate] operator. See its documentation for details.\n *\n * @param capacity type/capacity of the buffer between coroutines. Allowed values are the same as in `Channel(...)`\n *   factory function: [BUFFERED][Channel.BUFFERED] (by default), [CONFLATED][Channel.CONFLATED],\n *   [RENDEZVOUS][Channel.RENDEZVOUS], [UNLIMITED][Channel.UNLIMITED] or a non-negative value indicating\n *   an explicitly requested size.\n * @param onBufferOverflow configures an action on buffer overflow (optional, defaults to\n *   [SUSPEND][BufferOverflow.SUSPEND], supported only when `capacity >= 0` or `capacity == Channel.BUFFERED`,\n *   implicitly creates a channel with at least one buffered element).\n */\n@Suppress(\"NAME_SHADOWING\")\npublic fun <T> Flow<T>.buffer(capacity: Int = BUFFERED, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): Flow<T> {\n    require(capacity >= 0 || capacity == BUFFERED || capacity == CONFLATED) {\n        \"Buffer size should be non-negative, BUFFERED, or CONFLATED, but was $capacity\"\n    }\n    require(capacity != CONFLATED || onBufferOverflow == BufferOverflow.SUSPEND) {\n        \"CONFLATED capacity cannot be used with non-default onBufferOverflow\"\n    }\n    // desugar CONFLATED capacity to (0, DROP_OLDEST)\n    var capacity = capacity\n    var onBufferOverflow = onBufferOverflow\n    if (capacity == CONFLATED) {\n        capacity = 0\n        onBufferOverflow = BufferOverflow.DROP_OLDEST\n    }\n    // create a flow\n    return when (this) {\n        is FusibleFlow -> fuse(capacity = capacity, onBufferOverflow = onBufferOverflow)\n        else -> ChannelFlowOperatorImpl(this, capacity = capacity, onBufferOverflow = onBufferOverflow)\n    }\n}\n\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.4.0, binary compatibility with earlier versions\")\npublic fun <T> Flow<T>.buffer(capacity: Int = BUFFERED): Flow<T> = buffer(capacity)\n\n/**\n * Conflates flow emissions via conflated channel and runs collector in a separate coroutine.\n * The effect of this is that emitter is never suspended due to a slow collector, but collector\n * always gets the most recent value emitted.\n *\n * For example, consider the flow that emits integers from 1 to 30 with 100 ms delay between them:\n *\n * ```\n * val flow = flow {\n *     for (i in 1..30) {\n *         delay(100)\n *         emit(i)\n *     }\n * }\n * ```\n *\n * Applying `conflate()` operator to it allows a collector that delays 1 second on each element to get\n * integers 1, 10, 20, 30:\n *\n * ```\n * val result = flow.conflate().onEach { delay(1000) }.toList()\n * assertEquals(listOf(1, 10, 20, 30), result)\n * ```\n *\n * Note that `conflate` operator is a shortcut for [buffer] with `capacity` of [Channel.CONFLATED][Channel.CONFLATED],\n * which is, in turn, a shortcut to a buffer that only keeps the latest element as\n * created by `buffer(onBufferOverflow = `[`BufferOverflow.DROP_OLDEST`][BufferOverflow.DROP_OLDEST]`)`.\n *\n * ### Operator fusion\n *\n * Adjacent applications of `conflate`/[buffer], [channelFlow], [flowOn] and [produceIn] are\n * always fused so that only one properly configured channel is used for execution.\n * **Conflation takes precedence over `buffer()` calls with any other capacity.**\n *\n * Note that any instance of [StateFlow] already behaves as if `conflate` operator is\n * applied to it, so applying `conflate` to a `StateFlow` has no effect.\n * See [StateFlow] documentation on Operator Fusion.\n */\npublic fun <T> Flow<T>.conflate(): Flow<T> = buffer(CONFLATED)\n\n/**\n * Changes the context where this flow is executed to the given [context].\n * This operator is composable and affects only preceding operators that do not have its own context.\n * This operator is context preserving: [context] **does not** leak into the downstream flow.\n *\n * For example:\n *\n * ```\n * withContext(Dispatchers.Main) {\n *     val singleValue = intFlow // will be executed on IO if context wasn't specified before\n *         .map { ... } // Will be executed in IO\n *         .flowOn(Dispatchers.IO)\n *         .filter { ... } // Will be executed in Default\n *         .flowOn(Dispatchers.Default)\n *         .single() // Will be executed in the Main\n * }\n * ```\n *\n * For more explanation of context preservation please refer to [Flow] documentation.\n *\n * This operator retains a _sequential_ nature of flow if changing the context does not call for changing\n * the [dispatcher][CoroutineDispatcher]. Otherwise, if changing dispatcher is required, it collects\n * flow emissions in one coroutine that is run using a specified [context] and emits them from another coroutines\n * with the original collector's context using a channel with a [default][Channel.BUFFERED] buffer size\n * between two coroutines similarly to [buffer] operator, unless [buffer] operator is explicitly called\n * before or after `flowOn`, which requests buffering behavior and specifies channel size.\n *\n * Note, that flows operating across different dispatchers might lose some in-flight elements when cancelled.\n * In particular, this operator ensures that downstream flow does not resume on cancellation even if the element\n * was already emitted by the upstream flow.\n *\n * ### Operator fusion\n *\n * Adjacent applications of [channelFlow], [flowOn], [buffer], and [produceIn] are\n * always fused so that only one properly configured channel is used for execution.\n *\n * Multiple `flowOn` operators fuse to a single `flowOn` with a combined context. The elements of the context of\n * the first `flowOn` operator naturally take precedence over the elements of the second `flowOn` operator\n * when they have the same context keys, for example:\n *\n * ```\n * flow.map { ... } // Will be executed in IO\n *     .flowOn(Dispatchers.IO) // This one takes precedence\n *     .flowOn(Dispatchers.Default)\n * ```\n *\n * Note that an instance of [SharedFlow] does not have an execution context by itself,\n * so applying `flowOn` to a `SharedFlow` has not effect. See the [SharedFlow] documentation on Operator Fusion.\n *\n * @throws [IllegalArgumentException] if provided context contains [Job] instance.\n */\npublic fun <T> Flow<T>.flowOn(context: CoroutineContext): Flow<T> {\n    checkFlowContext(context)\n    return when {\n        context == EmptyCoroutineContext -> this\n        this is FusibleFlow -> fuse(context = context)\n        else -> ChannelFlowOperatorImpl(this, context = context)\n    }\n}\n\n/**\n * Returns a flow which checks cancellation status on each emission and throws\n * the corresponding cancellation cause if flow collector was cancelled.\n * Note that [flow] builder and all implementations of [SharedFlow] are [cancellable] by default.\n *\n * This operator provides a shortcut for `.onEach { currentCoroutineContext().ensureActive() }`.\n * See [ensureActive][CoroutineContext.ensureActive] for details.\n */\npublic fun <T> Flow<T>.cancellable(): Flow<T> =\n    when (this) {\n        is CancellableFlow<*> -> this // Fast-path, already cancellable\n        else -> CancellableFlowImpl(this)\n    }\n\n/**\n * Internal marker for flows that are [cancellable].\n */\ninternal interface CancellableFlow<out T> : Flow<T>\n\n/**\n * Named implementation class for a flow that is defined by the [cancellable] function.\n */\nprivate class CancellableFlowImpl<T>(private val flow: Flow<T>) : CancellableFlow<T> {\n    override suspend fun collect(collector: FlowCollector<T>) {\n        flow.collect {\n            currentCoroutineContext().ensureActive()\n            collector.emit(it)\n        }\n    }\n}\n\nprivate fun checkFlowContext(context: CoroutineContext) {\n    require(context[Job] == null) {\n        \"Flow context cannot contain job in it. Had $context\"\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Delay.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.jvm.*\nimport kotlin.time.*\n\n/* Scaffolding for Knit code examples\n<!--- TEST_NAME FlowDelayTest -->\n<!--- PREFIX .*-duration-.*\n----- INCLUDE .*-duration-.*\n----- INCLUDE .*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nfun main() = runBlocking {\n----- SUFFIX .*\n.toList().joinToString().let { println(it) } }\n-->\n*/\n\n/**\n * Returns a flow that mirrors the original flow, but filters out values\n * that are followed by the newer values within the given [timeout][timeoutMillis].\n * The latest value is always emitted.\n *\n * Example:\n *\n * ```kotlin\n * flow {\n *     emit(1)\n *     delay(90)\n *     emit(2)\n *     delay(90)\n *     emit(3)\n *     delay(1010)\n *     emit(4)\n *     delay(1010)\n *     emit(5)\n * }.debounce(1000)\n * ```\n * <!--- KNIT example-delay-01.kt -->\n *\n * produces the following emissions\n *\n * ```text\n * 3, 4, 5\n * ```\n * <!--- TEST -->\n *\n * Note that the resulting flow does not emit anything as long as the original flow emits\n * items faster than every [timeoutMillis] milliseconds.\n */\n@FlowPreview\npublic fun <T> Flow<T>.debounce(timeoutMillis: Long): Flow<T> {\n    require(timeoutMillis >= 0L) { \"Debounce timeout should not be negative\" }\n    if (timeoutMillis == 0L) return this\n    return debounceInternal { timeoutMillis }\n}\n\n/**\n * Returns a flow that mirrors the original flow, but filters out values\n * that are followed by the newer values within the given [timeout][timeoutMillis].\n * The latest value is always emitted.\n *\n * A variation of [debounce] that allows specifying the timeout value dynamically.\n *\n * Example:\n *\n * ```kotlin\n * flow {\n *     emit(1)\n *     delay(90)\n *     emit(2)\n *     delay(90)\n *     emit(3)\n *     delay(1010)\n *     emit(4)\n *     delay(1010)\n *     emit(5)\n * }.debounce {\n *     if (it == 1) {\n *         0L\n *     } else {\n *         1000L\n *     }\n * }\n * ```\n * <!--- KNIT example-delay-02.kt -->\n *\n * produces the following emissions\n *\n * ```text\n * 1, 3, 4, 5\n * ```\n * <!--- TEST -->\n *\n * Note that the resulting flow does not emit anything as long as the original flow emits\n * items faster than every [timeoutMillis] milliseconds.\n *\n * @param timeoutMillis [T] is the emitted value and the return value is timeout in milliseconds.\n */\n@FlowPreview\n@OverloadResolutionByLambdaReturnType\npublic fun <T> Flow<T>.debounce(timeoutMillis: (T) -> Long): Flow<T> =\n    debounceInternal(timeoutMillis)\n\n/**\n * Returns a flow that mirrors the original flow, but filters out values\n * that are followed by the newer values within the given [timeout].\n * The latest value is always emitted.\n *\n * Example:\n *\n * ```kotlin\n * flow {\n *     emit(1)\n *     delay(90.milliseconds)\n *     emit(2)\n *     delay(90.milliseconds)\n *     emit(3)\n *     delay(1010.milliseconds)\n *     emit(4)\n *     delay(1010.milliseconds)\n *     emit(5)\n * }.debounce(1000.milliseconds)\n * ```\n * <!--- KNIT example-delay-duration-01.kt -->\n *\n * produces the following emissions\n *\n * ```text\n * 3, 4, 5\n * ```\n * <!--- TEST -->\n *\n * Note that the resulting flow does not emit anything as long as the original flow emits\n * items faster than every [timeout] milliseconds.\n */\n@FlowPreview\npublic fun <T> Flow<T>.debounce(timeout: Duration): Flow<T> =\n    debounce(timeout.toDelayMillis())\n\n/**\n * Returns a flow that mirrors the original flow, but filters out values\n * that are followed by the newer values within the given [timeout].\n * The latest value is always emitted.\n *\n * A variation of [debounce] that allows specifying the timeout value dynamically.\n *\n * Example:\n *\n * ```kotlin\n * flow {\n *     emit(1)\n *     delay(90.milliseconds)\n *     emit(2)\n *     delay(90.milliseconds)\n *     emit(3)\n *     delay(1010.milliseconds)\n *     emit(4)\n *     delay(1010.milliseconds)\n *     emit(5)\n * }.debounce {\n *     if (it == 1) {\n *         0.milliseconds\n *     } else {\n *         1000.milliseconds\n *     }\n * }\n * ```\n * <!--- KNIT example-delay-duration-02.kt -->\n *\n * produces the following emissions\n *\n * ```text\n * 1, 3, 4, 5\n * ```\n * <!--- TEST -->\n *\n * Note that the resulting flow does not emit anything as long as the original flow emits\n * items faster than every [timeout] unit.\n *\n * @param timeout [T] is the emitted value and the return value is timeout in [Duration].\n */\n@FlowPreview\n@JvmName(\"debounceDuration\")\n@OverloadResolutionByLambdaReturnType\npublic fun <T> Flow<T>.debounce(timeout: (T) -> Duration): Flow<T> =\n    debounceInternal { emittedItem ->\n        timeout(emittedItem).toDelayMillis()\n    }\n\nprivate fun <T> Flow<T>.debounceInternal(timeoutMillisSelector: (T) -> Long): Flow<T> =\n    scopedFlow { downstream ->\n        // Produce the values using the default (rendezvous) channel\n        val values = produce {\n            collect { value -> send(value ?: NULL) }\n        }\n        // Now consume the values\n        var lastValue: Any? = null\n        while (lastValue !== DONE) {\n            var timeoutMillis = 0L // will be always computed when lastValue != null\n            // Compute timeout for this value\n            if (lastValue != null) {\n                timeoutMillis = timeoutMillisSelector(NULL.unbox(lastValue))\n                require(timeoutMillis >= 0L) { \"Debounce timeout should not be negative\" }\n                if (timeoutMillis == 0L) {\n                    downstream.emit(NULL.unbox(lastValue))\n                    lastValue = null // Consume the value\n                }\n            }\n            // assert invariant: lastValue != null implies timeoutMillis > 0\n            assert { lastValue == null || timeoutMillis > 0 }\n            // wait for the next value with timeout\n            select<Unit> {\n                // Set timeout when lastValue exists and is not consumed yet\n                if (lastValue != null) {\n                    onTimeout(timeoutMillis) {\n                        downstream.emit(NULL.unbox(lastValue))\n                        lastValue = null // Consume the value\n                    }\n                }\n                values.onReceiveCatching { value ->\n                    value\n                        .onSuccess { lastValue = it }\n                        .onFailure {\n                            it?.let { throw it }\n                            // If closed normally, emit the latest value\n                            if (lastValue != null) downstream.emit(NULL.unbox(lastValue))\n                            lastValue = DONE\n                        }\n                }\n            }\n        }\n    }\n\n/**\n * Returns a flow that emits only the latest value emitted by the original flow during the given sampling [period][periodMillis].\n *\n * Example:\n *\n * ```kotlin\n * flow {\n *     repeat(10) {\n *         emit(it)\n *         delay(110)\n *     }\n * }.sample(200)\n * ```\n * <!--- KNIT example-delay-03.kt -->\n *\n * produces the following emissions\n *\n * ```text\n * 1, 3, 5, 7, 9\n * ```\n * <!--- TEST -->\n *\n * Note that the latest element is not emitted if it does not fit into the sampling window.\n */\n@FlowPreview\npublic fun <T> Flow<T>.sample(periodMillis: Long): Flow<T> {\n    require(periodMillis > 0) { \"Sample period should be positive\" }\n    return scopedFlow { downstream ->\n        val values = produce(capacity = Channel.CONFLATED) {\n            collect { value -> send(value ?: NULL) }\n        }\n        var lastValue: Any? = null\n        val ticker = fixedPeriodTicker(periodMillis)\n        while (lastValue !== DONE) {\n            select<Unit> {\n                values.onReceiveCatching { result ->\n                    result\n                        .onSuccess { lastValue = it }\n                        .onFailure {\n                            it?.let { throw it }\n                            ticker.cancel(ChildCancelledException())\n                            lastValue = DONE\n                        }\n                }\n\n                // todo: shall be start sampling only when an element arrives or sample aways as here?\n                ticker.onReceive {\n                    val value = lastValue ?: return@onReceive\n                    lastValue = null // Consume the value\n                    downstream.emit(NULL.unbox(value))\n                }\n            }\n        }\n    }\n}\n\n/*\n * TODO this design (and design of the corresponding operator) depends on #540\n */\ninternal fun CoroutineScope.fixedPeriodTicker(\n    delayMillis: Long,\n): ReceiveChannel<Unit> {\n    return produce(capacity = 0) {\n        delay(delayMillis)\n        while (true) {\n            channel.send(Unit)\n            delay(delayMillis)\n        }\n    }\n}\n\n/**\n * Returns a flow that emits only the latest value emitted by the original flow during the given sampling [period].\n *\n * Example:\n *\n * ```kotlin\n * flow {\n *     repeat(10) {\n *         emit(it)\n *         delay(110.milliseconds)\n *     }\n * }.sample(200.milliseconds)\n * ```\n * <!--- KNIT example-delay-duration-03.kt -->\n *\n * produces the following emissions\n *\n * ```text\n * 1, 3, 5, 7, 9\n * ```\n * <!--- TEST -->\n *\n * Note that the latest element is not emitted if it does not fit into the sampling window.\n */\n@FlowPreview\npublic fun <T> Flow<T>.sample(period: Duration): Flow<T> = sample(period.toDelayMillis())\n\n/**\n * Returns a flow that will emit a [TimeoutCancellationException] if the upstream doesn't emit an item within the given time.\n *\n * Example:\n *\n * ```kotlin\n * flow {\n *     emit(1)\n *     delay(100)\n *     emit(2)\n *     delay(100)\n *     emit(3)\n *     delay(1000)\n *     emit(4)\n * }.timeout(100.milliseconds).catch { exception ->\n *     if (exception is TimeoutCancellationException) {\n *         // Catch the TimeoutCancellationException emitted above.\n *         // Emit desired item on timeout.\n *         emit(-1)\n *     } else {\n *         // Throw other exceptions.\n *         throw exception\n *     }\n * }.onEach {\n *     delay(300) // This will not cause a timeout\n * }\n * ```\n * <!--- KNIT example-timeout-duration-01.kt -->\n *\n * produces the following emissions\n *\n * ```text\n * 1, 2, 3, -1\n * ```\n * <!--- TEST -->\n *\n * Note that delaying on the downstream doesn't trigger the timeout.\n *\n * @param timeout Timeout duration. If non-positive, the flow is timed out immediately\n */\n@FlowPreview\npublic fun <T> Flow<T>.timeout(\n    timeout: Duration\n): Flow<T> = timeoutInternal(timeout)\n\nprivate fun <T> Flow<T>.timeoutInternal(\n    timeout: Duration\n): Flow<T> = scopedFlow { downStream ->\n    if (timeout <= Duration.ZERO) throw TimeoutCancellationException(\"Timed out immediately\")\n    val values = buffer(Channel.RENDEZVOUS).produceIn(this)\n    whileSelect {\n        values.onReceiveCatching { value ->\n            value.onSuccess {\n                downStream.emit(it)\n            }.onClosed {\n                it?.let { throw it }\n                return@onReceiveCatching false\n            }\n            return@onReceiveCatching true\n        }\n        onTimeout(timeout) {\n            throw TimeoutCancellationException(\"Timed out waiting for $timeout\")\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Distinct.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.jvm.*\n\n/**\n * Returns flow where all subsequent repetitions of the same value are filtered out.\n *\n * Note that any instance of [StateFlow] already behaves as if `distinctUntilChanged` operator is\n * applied to it, so applying `distinctUntilChanged` to a `StateFlow` has no effect.\n * See [StateFlow] documentation on Operator Fusion.\n * Also, repeated application of `distinctUntilChanged` operator on any flow has no effect.\n */\npublic fun <T> Flow<T>.distinctUntilChanged(): Flow<T> =\n    when (this) {\n        is StateFlow<*> -> this // state flows are always distinct\n        else -> distinctUntilChangedBy(keySelector = defaultKeySelector, areEquivalent = defaultAreEquivalent)\n    }\n\n/**\n * Returns flow where all subsequent repetitions of the same value are filtered out, when compared\n * with each other via the provided [areEquivalent] function.\n *\n * Note that repeated application of `distinctUntilChanged` operator with the same parameter has no effect.\n */\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> Flow<T>.distinctUntilChanged(areEquivalent: (old: T, new: T) -> Boolean): Flow<T> =\n    distinctUntilChangedBy(keySelector = defaultKeySelector, areEquivalent = areEquivalent as (Any?, Any?) -> Boolean)\n\n/**\n * Returns flow where all subsequent repetitions of the same key are filtered out, where\n * key is extracted with [keySelector] function.\n *\n * Note that repeated application of `distinctUntilChanged` operator with the same parameter has no effect.\n */\npublic fun <T, K> Flow<T>.distinctUntilChangedBy(keySelector: (T) -> K): Flow<T> =\n    distinctUntilChangedBy(keySelector = keySelector, areEquivalent = defaultAreEquivalent)\n\nprivate val defaultKeySelector: (Any?) -> Any? = { it }\n\nprivate val defaultAreEquivalent: (Any?, Any?) -> Boolean = { old, new -> old == new }\n\n/**\n * Returns flow where all subsequent repetitions of the same key are filtered out, where\n * keys are extracted with [keySelector] function and compared with each other via the\n * provided [areEquivalent] function.\n *\n * NOTE: It is non-inline to share a single implementing class.\n */\nprivate fun <T> Flow<T>.distinctUntilChangedBy(\n    keySelector: (T) -> Any?,\n    areEquivalent: (old: Any?, new: Any?) -> Boolean\n): Flow<T> = when {\n    this is DistinctFlowImpl<*> && this.keySelector === keySelector && this.areEquivalent === areEquivalent -> this // same\n    else -> DistinctFlowImpl(this, keySelector, areEquivalent)\n}\n\nprivate class DistinctFlowImpl<T>(\n    private val upstream: Flow<T>,\n    @JvmField val keySelector: (T) -> Any?,\n    @JvmField val areEquivalent: (old: Any?, new: Any?) -> Boolean\n): Flow<T> {\n    override suspend fun collect(collector: FlowCollector<T>) {\n        var previousKey: Any? = NULL\n        upstream.collect { value ->\n            val key = keySelector(value)\n            @Suppress(\"UNCHECKED_CAST\")\n            if (previousKey === NULL || !areEquivalent(previousKey, key)) {\n                previousKey = key\n                collector.emit(value)\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Emitters.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n@file:Suppress(\"UNCHECKED_CAST\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.jvm.*\n\n// ------------------ WARNING ------------------\n//   These emitting operators must use safe flow builder, because they allow\n//   user code to directly emit to the underlying FlowCollector.\n\n/**\n * Applies [transform] function to each value of the given flow.\n *\n * The receiver of the `transform` is [FlowCollector] and thus `transform` is a\n * flexible function that may transform emitted element, skip it or emit it multiple times.\n *\n * This operator generalizes [filter] and [map] operators and\n * can be used as a building block for other operators, for example:\n *\n * ```\n * fun Flow<Int>.skipOddAndDuplicateEven(): Flow<Int> = transform { value ->\n *     if (value % 2 == 0) { // Emit only even values, but twice\n *         emit(value)\n *         emit(value)\n *     } // Do nothing if odd\n * }\n * ```\n */\npublic inline fun <T, R> Flow<T>.transform(\n    @BuilderInference crossinline transform: suspend FlowCollector<R>.(value: T) -> Unit\n): Flow<R> = flow { // Note: safe flow is used here, because collector is exposed to transform on each operation\n    collect { value ->\n        // kludge, without it Unit will be returned and TCE won't kick in, KT-28938\n        return@collect transform(value)\n    }\n}\n\n// For internal operator implementation\n@PublishedApi\ninternal inline fun <T, R> Flow<T>.unsafeTransform(\n    @BuilderInference crossinline transform: suspend FlowCollector<R>.(value: T) -> Unit\n): Flow<R> = unsafeFlow { // Note: unsafe flow is used here, because unsafeTransform is only for internal use\n    collect { value ->\n        // kludge, without it Unit will be returned and TCE won't kick in, KT-28938\n        return@collect transform(value)\n    }\n}\n\n/**\n * Returns a flow that invokes the given [action] **before** this flow starts to be collected.\n *\n * The [action] is called before the upstream flow is started, so if it is used with a [SharedFlow]\n * there is **no guarantee** that emissions from the upstream flow that happen inside or immediately\n * after this `onStart` action will be collected\n * (see [onSubscription] for an alternative operator on shared flows).\n *\n * The receiver of the [action] is [FlowCollector], so `onStart` can emit additional elements.\n * For example:\n *\n * ```\n * flowOf(\"a\", \"b\", \"c\")\n *     .onStart { emit(\"Begin\") }\n *     .collect { println(it) } // prints Begin, a, b, c\n * ```\n */\npublic fun <T> Flow<T>.onStart(\n    action: suspend FlowCollector<T>.() -> Unit\n): Flow<T> = unsafeFlow { // Note: unsafe flow is used here, but safe collector is used to invoke start action\n    val safeCollector = SafeCollector<T>(this, currentCoroutineContext())\n    try {\n        safeCollector.action()\n    } finally {\n        safeCollector.releaseIntercepted()\n    }\n    collect(this) // directly delegate\n}\n\n/**\n * Returns a flow that invokes the given [action] **after** the flow is completed or cancelled, passing\n * the cancellation exception or failure as cause parameter of [action].\n *\n * Conceptually, `onCompletion` is similar to wrapping the flow collection into a `finally` block,\n * for example the following imperative snippet:\n *\n * ```\n * try {\n *     myFlow.collect { value ->\n *         println(value)\n *     }\n * } finally {\n *     println(\"Done\")\n * }\n * ```\n *\n * can be replaced with a declarative one using `onCompletion`:\n *\n * ```\n * myFlow\n *     .onEach { println(it) }\n *     .onCompletion { println(\"Done\") }\n *     .collect()\n * ```\n *\n * Unlike [catch], this operator reports exception that occur both upstream and downstream\n * and observe exceptions that are thrown to cancel the flow. Exception is empty if and only if\n * the flow had fully completed successfully. Conceptually, the following code:\n *\n * ```\n * myFlow.collect { value ->\n *     println(value)\n * }\n * println(\"Completed successfully\")\n * ```\n *\n * can be replaced with:\n *\n * ```\n * myFlow\n *     .onEach { println(it) }\n *     .onCompletion { if (it == null) println(\"Completed successfully\") }\n *     .collect()\n * ```\n *\n * The receiver of the [action] is [FlowCollector] and this operator can be used to emit additional\n * elements at the end **if it completed successfully**. For example:\n *\n * ```\n * flowOf(\"a\", \"b\", \"c\")\n *     .onCompletion { emit(\"Done\") }\n *     .collect { println(it) } // prints a, b, c, Done\n * ```\n *\n * In case of failure or cancellation, any attempt to emit additional elements throws the corresponding exception.\n * Use [catch] if you need to suppress failure and replace it with emission of elements.\n */\npublic fun <T> Flow<T>.onCompletion(\n    action: suspend FlowCollector<T>.(cause: Throwable?) -> Unit\n): Flow<T> = unsafeFlow { // Note: unsafe flow is used here, but safe collector is used to invoke completion action\n    try {\n        collect(this)\n    } catch (e: Throwable) {\n        /*\n         * Use throwing collector to prevent any emissions from the\n         * completion sequence when downstream has failed, otherwise it may\n         * lead to a non-sequential behaviour impossible with `finally`\n         */\n        ThrowingCollector(e).invokeSafely(action, e)\n        throw e\n    }\n    // Normal completion\n    val sc = SafeCollector(this, currentCoroutineContext())\n    try {\n        sc.action(null)\n    } finally {\n        sc.releaseIntercepted()\n    }\n}\n\n/**\n * Invokes the given [action] when this flow completes without emitting any elements.\n * The receiver of the [action] is [FlowCollector], so `onEmpty` can emit additional elements.\n * For example:\n *\n * ```\n * emptyFlow<Int>().onEmpty {\n *     emit(1)\n *     emit(2)\n * }.collect { println(it) } // prints 1, 2\n * ```\n */\npublic fun <T> Flow<T>.onEmpty(\n    action: suspend FlowCollector<T>.() -> Unit\n): Flow<T> = unsafeFlow {\n    var isEmpty = true\n    collect {\n        isEmpty = false\n        emit(it)\n    }\n    if (isEmpty) {\n        val collector = SafeCollector(this, currentCoroutineContext())\n        try {\n            collector.action()\n        } finally {\n            collector.releaseIntercepted()\n        }\n    }\n}\n\n/*\n * 'emitAll' methods call this to fail-fast before starting to collect\n * their sources (that may not have any elements for a long time).\n */\ninternal fun FlowCollector<*>.ensureActive() {\n    if (this is ThrowingCollector) throw e\n}\n\ninternal class ThrowingCollector(@JvmField val e: Throwable) : FlowCollector<Any?> {\n    override suspend fun emit(value: Any?) {\n        throw e\n    }\n}\n\nprivate suspend fun <T> FlowCollector<T>.invokeSafely(\n    action: suspend FlowCollector<T>.(cause: Throwable?) -> Unit,\n    cause: Throwable?\n) {\n    try {\n        action(cause)\n    } catch (e: Throwable) {\n        if (cause !== null && cause !== e) e.addSuppressed(cause)\n        throw e\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Errors.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\nimport kotlinx.coroutines.flow.internal.unsafeFlow as flow\n\n/**\n * Catches exceptions in the flow completion and calls a specified [action] with\n * the caught exception. This operator is *transparent* to exceptions that occur\n * in downstream flow and does not catch exceptions that are thrown to cancel the flow.\n *\n * For example:\n *\n * ```\n * flow { emitData() }\n *     .map { computeOne(it) }\n *     .catch { ... } // catches exceptions in emitData and computeOne\n *     .map { computeTwo(it) }\n *     .collect { process(it) } // throws exceptions from process and computeTwo\n * ```\n *\n * Conceptually, the action of `catch` operator is similar to wrapping the code of upstream flows with\n * `try { ... } catch (e: Throwable) { action(e) }`.\n *\n * Any exception in the [action] code itself proceeds downstream where it can be\n * caught by further `catch` operators if needed. If a particular exception does not need to be\n * caught it can be rethrown from the action of `catch` operator. For example:\n *\n * ```\n * flow.catch { e ->\n *     if (e !is IOException) throw e // rethrow all but IOException\n *     // e is IOException here\n *     ...\n * }\n * ```\n *\n * The [action] code has [FlowCollector] as a receiver and can [emit][FlowCollector.emit] values downstream.\n * For example, caught exception can be replaced with some wrapper value for errors:\n *\n * ```\n * flow.catch { e -> emit(ErrorWrapperValue(e)) }\n * ```\n *\n * The [action] can also use [emitAll] to fallback on some other flow in case of an error. However, to\n * retry an original flow use [retryWhen] operator that can retry the flow multiple times without\n * introducing ever-growing stack of suspending calls.\n */\npublic fun <T> Flow<T>.catch(action: suspend FlowCollector<T>.(cause: Throwable) -> Unit): Flow<T> =\n    flow {\n        val exception = catchImpl(this)\n        if (exception != null) action(exception)\n    }\n\n/**\n * Retries collection of the given flow up to [retries] times when an exception that matches the\n * given [predicate] occurs in the upstream flow. This operator is *transparent* to exceptions that occur\n * in downstream flow and does not retry on exceptions that are thrown to cancel the flow.\n *\n * See [catch] for details on how exceptions are caught in flows.\n *\n * The default value of [retries] parameter is [Long.MAX_VALUE]. This value effectively means to retry forever.\n * This operator is a shorthand for the following code (see [retryWhen]). Note that `attempt` is checked first\n * and [predicate] is not called when it reaches the given number of [retries]:\n *\n * ```\n * retryWhen { cause, attempt -> attempt < retries && predicate(cause) }\n * ```\n *\n * The [predicate] parameter is always true by default. The [predicate] is a suspending function,\n * so it can be also used to introduce delay before retry, for example:\n *\n * ```\n * flow.retry(3) { e ->\n *     // retry on any IOException but also introduce delay if retrying\n *     (e is IOException).also { if (it) delay(1000) }\n * }\n * ```\n *\n * @throws IllegalArgumentException when [retries] is not positive.\n */\npublic fun <T> Flow<T>.retry(\n    retries: Long = Long.MAX_VALUE,\n    predicate: suspend (cause: Throwable) -> Boolean = { true }\n): Flow<T> {\n    require(retries > 0) { \"Expected positive amount of retries, but had $retries\" }\n    return retryWhen { cause, attempt -> attempt < retries && predicate(cause) }\n}\n\n/**\n * Retries collection of the given flow when an exception occurs in the upstream flow and the\n * [predicate] returns true. The predicate also receives an `attempt` number as parameter,\n * starting from zero on the initial call. This operator is *transparent* to exceptions that occur\n * in downstream flow and does not retry on exceptions that are thrown to cancel the flow.\n *\n * For example, the following call retries the flow forever if the error is caused by `IOException`, but\n * stops after 3 retries on any other exception:\n *\n * ```\n * flow.retryWhen { cause, attempt -> cause is IOException || attempt < 3 }\n * ```\n *\n * To implement a simple retry logic with a limit on the number of retries use [retry] operator.\n *\n * Similarly to [catch] operator, the [predicate] code has [FlowCollector] as a receiver and can\n * [emit][FlowCollector.emit] values downstream.\n * The [predicate] is a suspending function, so it can be used to introduce delay before retry, for example:\n *\n * ```\n * flow.retryWhen { cause, attempt ->\n *     if (cause is IOException) {    // retry on IOException\n *         emit(RetryWrapperValue(e))\n *         delay(1000)                // delay for one second before retry\n *         true\n *     } else {                       // do not retry otherwise\n *         false\n *     }\n * }\n * ```\n *\n * See [catch] for more details.\n */\npublic fun <T> Flow<T>.retryWhen(predicate: suspend FlowCollector<T>.(cause: Throwable, attempt: Long) -> Boolean): Flow<T> =\n    flow {\n        var attempt = 0L\n        var shallRetry: Boolean\n        do {\n            shallRetry = false\n            val cause = catchImpl(this)\n            if (cause != null) {\n                if (predicate(cause, attempt)) {\n                    shallRetry = true\n                    attempt++\n                } else {\n                    throw cause\n                }\n            }\n        } while (shallRetry)\n    }\n\n// Return exception from upstream or null\n@Suppress(\"NAME_SHADOWING\")\ninternal suspend fun <T> Flow<T>.catchImpl(\n    collector: FlowCollector<T>\n): Throwable? {\n    var fromDownstream: Throwable? = null\n    try {\n        collect {\n            try {\n                collector.emit(it)\n            } catch (e: Throwable) {\n                fromDownstream = e\n                throw e\n            }\n        }\n    } catch (e: Throwable) {\n        // Otherwise, smartcast is impossible\n        val fromDownstream = fromDownstream\n        /*\n         * First check ensures that we catch an original exception, not one rethrown by an operator.\n         * Seconds check ignores cancellation causes, they cannot be caught.\n         */\n        if (e.isSameExceptionAs(fromDownstream) || e.isCancellationCause(coroutineContext)) {\n            throw e // Rethrow exceptions from downstream and cancellation causes\n        } else {\n            /*\n             * The exception came from the upstream [semi-] independently.\n             * For pure failures, when the downstream functions normally, we handle the exception as intended.\n             * But if the downstream has failed prior to or concurrently\n             * with the upstream, we forcefully rethrow it, preserving the contextual information and ensuring  that it's not lost.\n             */\n            if (fromDownstream == null) {\n                return e\n            }\n            /*\n             * We consider the upstream exception as the superseding one when both upstream and downstream\n             * fail, suppressing the downstream exception, and operating similarly to `finally` block with\n             * the useful addition of adding the original downstream exception to suppressed ones.\n             *\n             * That's important for the following scenarios:\n             * ```\n             * flow {\n             *     val resource = ...\n             *     try {\n             *         ... emit as well ...\n             *     } finally {\n             *          resource.close() // Throws in the shutdown sequence when 'collect' already has thrown an exception\n             *     }\n             * }.catch { } // or retry\n             * .collect { ... }\n             * ```\n             * when *the downstream* throws.\n             */\n            if (e is CancellationException) {\n                fromDownstream.addSuppressed(e)\n                throw fromDownstream\n            } else {\n                e.addSuppressed(fromDownstream)\n                throw e\n            }\n        }\n    }\n    return null\n}\n\nprivate fun Throwable.isCancellationCause(coroutineContext: CoroutineContext): Boolean {\n    val job = coroutineContext[Job]\n    if (job == null || !job.isCancelled) return false\n    return isSameExceptionAs(job.getCancellationException())\n}\n\nprivate fun Throwable.isSameExceptionAs(other: Throwable?): Boolean =\n    other != null && unwrap(other) == unwrap(this)\n\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Limit.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.jvm.*\nimport kotlinx.coroutines.flow.flow as safeFlow\nimport kotlinx.coroutines.flow.internal.unsafeFlow as flow\n\n/**\n * Returns a flow that ignores first [count] elements.\n * Throws [IllegalArgumentException] if [count] is negative.\n */\npublic fun <T> Flow<T>.drop(count: Int): Flow<T> {\n    require(count >= 0) { \"Drop count should be non-negative, but had $count\" }\n    return flow {\n        var skipped = 0\n        collect { value ->\n            if (skipped >= count) emit(value) else ++skipped\n        }\n    }\n}\n\n/**\n * Returns a flow containing all elements except first elements that satisfy the given predicate.\n */\npublic fun <T> Flow<T>.dropWhile(predicate: suspend (T) -> Boolean): Flow<T> = flow {\n    var matched = false\n    collect { value ->\n        if (matched) {\n            emit(value)\n        } else if (!predicate(value)) {\n            matched = true\n            emit(value)\n        }\n    }\n}\n\n/**\n * Returns a flow that contains first [count] elements.\n * When [count] elements are consumed, the original flow is cancelled.\n * Throws [IllegalArgumentException] if [count] is not positive.\n */\npublic fun <T> Flow<T>.take(count: Int): Flow<T> {\n    require(count > 0) { \"Requested element count $count should be positive\" }\n    return flow {\n        val ownershipMarker = Any()\n        var consumed = 0\n        try {\n            collect { value ->\n                // Note: this for take is not written via collectWhile on purpose.\n                // It checks condition first and then makes a tail-call to either emit or emitAbort.\n                // This way normal execution does not require a state machine, only a termination (emitAbort).\n                // See \"TakeBenchmark\" for comparision of different approaches.\n                if (++consumed < count) {\n                    return@collect emit(value)\n                } else {\n                    return@collect emitAbort(value, ownershipMarker)\n                }\n            }\n        } catch (e: AbortFlowException) {\n            e.checkOwnership(owner = ownershipMarker)\n        }\n    }\n}\n\nprivate suspend fun <T> FlowCollector<T>.emitAbort(value: T, ownershipMarker: Any) {\n    emit(value)\n    throw AbortFlowException(ownershipMarker)\n}\n\n/**\n * Returns a flow that contains first elements satisfying the given [predicate].\n *\n * Note, that the resulting flow does not contain the element on which the [predicate] returned `false`.\n * See [transformWhile] for a more flexible operator.\n */\npublic fun <T> Flow<T>.takeWhile(predicate: suspend (T) -> Boolean): Flow<T> = flow {\n    // This return is needed to work around a bug in JS BE: KT-39227\n    return@flow collectWhile { value ->\n        if (predicate(value)) {\n            emit(value)\n            true\n        } else {\n            false\n        }\n    }\n}\n\n/**\n * Applies [transform] function to each value of the given flow while this\n * function returns `true`.\n *\n * The receiver of the `transformWhile` is [FlowCollector] and thus `transformWhile` is a\n * flexible function that may transform emitted element, skip it or emit it multiple times.\n *\n * This operator generalizes [takeWhile] and can be used as a building block for other operators.\n * For example, a flow of download progress messages can be completed when the\n * download is done but emit this last message (unlike `takeWhile`):\n *\n * ```\n * fun Flow<DownloadProgress>.completeWhenDone(): Flow<DownloadProgress> =\n *     transformWhile { progress ->\n *         emit(progress) // always emit progress\n *         !progress.isDone() // continue while download is not done\n *     }\n * ```\n */\npublic fun <T, R> Flow<T>.transformWhile(\n    @BuilderInference transform: suspend FlowCollector<R>.(value: T) -> Boolean\n): Flow<R> =\n    safeFlow { // Note: safe flow is used here, because collector is exposed to transform on each operation\n        // This return is needed to work around a bug in JS BE: KT-39227\n        return@safeFlow collectWhile { value ->\n            transform(value)\n        }\n    }\n\n// Internal building block for non-tailcalling flow-truncating operators\ninternal suspend inline fun <T> Flow<T>.collectWhile(crossinline predicate: suspend (value: T) -> Boolean) {\n    val collector = object : FlowCollector<T> {\n        override suspend fun emit(value: T) {\n            // Note: we are checking predicate first, then throw. If the predicate does suspend (calls emit, for example)\n            // the the resulting code is never tail-suspending and produces a state-machine\n            if (!predicate(value)) {\n                throw AbortFlowException(this)\n            }\n        }\n    }\n    try {\n        collect(collector)\n    } catch (e: AbortFlowException) {\n        e.checkOwnership(collector)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Lint.kt",
        "content": "@file:Suppress(\"unused\", \"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\", \"UNUSED_PARAMETER\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Applying [cancellable][Flow.cancellable] to a [SharedFlow] has no effect.\n * See the [SharedFlow] documentation on Operator Fusion.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Applying 'cancellable' to a SharedFlow has no effect. See the SharedFlow documentation on Operator Fusion.\",\n    replaceWith = ReplaceWith(\"this\")\n)\npublic fun <T> SharedFlow<T>.cancellable(): Flow<T> = noImpl()\n\n/**\n * Applying [flowOn][Flow.flowOn] to [SharedFlow] has no effect.\n * See the [SharedFlow] documentation on Operator Fusion.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Applying 'flowOn' to SharedFlow has no effect. See the SharedFlow documentation on Operator Fusion.\",\n    replaceWith = ReplaceWith(\"this\")\n)\npublic fun <T> SharedFlow<T>.flowOn(context: CoroutineContext): Flow<T> = noImpl()\n\n/**\n * Applying [conflate][Flow.conflate] to [StateFlow] has no effect.\n * See the [StateFlow] documentation on Operator Fusion.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Applying 'conflate' to StateFlow has no effect. See the StateFlow documentation on Operator Fusion.\",\n    replaceWith = ReplaceWith(\"this\")\n)\npublic fun <T> StateFlow<T>.conflate(): Flow<T> = noImpl()\n\n/**\n * Applying [distinctUntilChanged][Flow.distinctUntilChanged] to [StateFlow] has no effect.\n * See the [StateFlow] documentation on Operator Fusion.\n * @suppress\n */\n@Deprecated(\n    level = DeprecationLevel.ERROR,\n    message = \"Applying 'distinctUntilChanged' to StateFlow has no effect. See the StateFlow documentation on Operator Fusion.\",\n    replaceWith = ReplaceWith(\"this\")\n)\npublic fun <T> StateFlow<T>.distinctUntilChanged(): Flow<T> = noImpl()\n\n/**\n * @suppress\n */\n@Deprecated(\n    message = \"isActive is resolved into the extension of outer CoroutineScope which is likely to be an error.\" +\n        \"Use currentCoroutineContext().isActive or cancellable() operator instead \" +\n        \"or specify the receiver of isActive explicitly. \" +\n        \"Additionally, flow {} builder emissions are cancellable by default.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"currentCoroutineContext().isActive\")\n)\npublic val FlowCollector<*>.isActive: Boolean\n    get() = noImpl()\n\n/**\n * @suppress\n */\n@Deprecated(\n    message = \"cancel() is resolved into the extension of outer CoroutineScope which is likely to be an error.\" +\n        \"Use currentCoroutineContext().cancel() instead or specify the receiver of cancel() explicitly\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"currentCoroutineContext().cancel(cause)\")\n)\npublic fun FlowCollector<*>.cancel(cause: CancellationException? = null): Unit = noImpl()\n\n/**\n * @suppress\n */\n@Deprecated(\n    message = \"coroutineContext is resolved into the property of outer CoroutineScope which is likely to be an error.\" +\n        \"Use currentCoroutineContext() instead or specify the receiver of coroutineContext explicitly\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"currentCoroutineContext()\")\n)\npublic val FlowCollector<*>.coroutineContext: CoroutineContext\n    get() = noImpl()\n\n/**\n * @suppress\n */\n@Deprecated(\n    message = \"SharedFlow never completes, so this operator typically has not effect, it can only \" +\n        \"catch exceptions from 'onSubscribe' operator\",\n    level = DeprecationLevel.WARNING,\n    replaceWith = ReplaceWith(\"this\")\n)\n@InlineOnly\npublic inline fun <T> SharedFlow<T>.catch(noinline action: suspend FlowCollector<T>.(cause: Throwable) -> Unit): Flow<T> =\n    (this as Flow<T>).catch(action)\n\n/**\n * @suppress\n */\n@Deprecated(\n    message = \"SharedFlow never completes, so this operator has no effect.\",\n    level = DeprecationLevel.WARNING,\n    replaceWith = ReplaceWith(\"this\")\n)\n@InlineOnly\npublic inline fun <T> SharedFlow<T>.retry(\n    retries: Long = Long.MAX_VALUE,\n    noinline predicate: suspend (cause: Throwable) -> Boolean = { true }\n): Flow<T> =\n    (this as Flow<T>).retry(retries, predicate)\n\n/**\n * @suppress\n */\n@Deprecated(\n    message = \"SharedFlow never completes, so this operator has no effect.\",\n    level = DeprecationLevel.WARNING,\n    replaceWith = ReplaceWith(\"this\")\n)\n@InlineOnly\npublic inline fun <T> SharedFlow<T>.retryWhen(noinline predicate: suspend FlowCollector<T>.(cause: Throwable, attempt: Long) -> Boolean): Flow<T> =\n    (this as Flow<T>).retryWhen(predicate)\n\n/**\n * @suppress\n */\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\n    message = \"SharedFlow never completes, so this terminal operation never completes.\",\n    level = DeprecationLevel.WARNING\n)\n@InlineOnly\npublic suspend inline fun <T> SharedFlow<T>.toList(): List<T> =\n    (this as Flow<T>).toList()\n\n/**\n * A specialized version of [Flow.toList] that returns [Nothing]\n * to indicate that [SharedFlow] collection never completes.\n */\n@InlineOnly\npublic suspend inline fun <T> SharedFlow<T>.toList(destination: MutableList<T>): Nothing {\n    (this as Flow<T>).toList(destination)\n    throw IllegalStateException(\"this code is supposed to be unreachable\")\n}\n\n/**\n * @suppress\n */\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\n    message = \"SharedFlow never completes, so this terminal operation never completes.\",\n    level = DeprecationLevel.WARNING\n)\n@InlineOnly\npublic suspend inline fun <T> SharedFlow<T>.toSet(): Set<T> =\n    (this as Flow<T>).toSet()\n\n/**\n * A specialized version of [Flow.toSet] that returns [Nothing]\n * to indicate that [SharedFlow] collection never completes.\n */\n@InlineOnly\npublic suspend inline fun <T> SharedFlow<T>.toSet(destination: MutableSet<T>): Nothing {\n    (this as Flow<T>).toSet(destination)\n    throw IllegalStateException(\"this code is supposed to be unreachable\")\n}\n\n/**\n * @suppress\n */\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\n    message = \"SharedFlow never completes, so this terminal operation never completes.\",\n    level = DeprecationLevel.WARNING\n)\n@InlineOnly\npublic suspend inline fun <T> SharedFlow<T>.count(): Int =\n    (this as Flow<T>).count()\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Merge.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n@file:Suppress(\"unused\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.jvm.*\nimport kotlinx.coroutines.flow.internal.unsafeFlow as flow\n\n/**\n * Name of the property that defines the value of [DEFAULT_CONCURRENCY].\n * This is a preview API and can be changed in a backwards-incompatible manner within a single release.\n */\n@FlowPreview\npublic const val DEFAULT_CONCURRENCY_PROPERTY_NAME: String = \"kotlinx.coroutines.flow.defaultConcurrency\"\n\n/**\n * Default concurrency limit that is used by [flattenMerge] and [flatMapMerge] operators.\n * It is 16 by default and can be changed on JVM using [DEFAULT_CONCURRENCY_PROPERTY_NAME] property.\n * This is a preview API and can be changed in a backwards-incompatible manner within a single release.\n */\n@FlowPreview\npublic val DEFAULT_CONCURRENCY: Int = systemProp(\n    DEFAULT_CONCURRENCY_PROPERTY_NAME,\n    16, 1, Int.MAX_VALUE\n)\n\n/**\n * Transforms elements emitted by the original flow by applying [transform], that returns another flow,\n * and then concatenating and flattening these flows.\n *\n * This method is a shortcut for `map(transform).flattenConcat()`. See [flattenConcat].\n *\n * Note that even though this operator looks very familiar, we discourage its usage in a regular application-specific flows.\n * Most likely, suspending operation in [map] operator will be sufficient and linear transformations are much easier to reason about.\n */\n@ExperimentalCoroutinesApi\npublic fun <T, R> Flow<T>.flatMapConcat(transform: suspend (value: T) -> Flow<R>): Flow<R> =\n    map(transform).flattenConcat()\n\n/**\n * Transforms elements emitted by the original flow by applying [transform], that returns another flow,\n * and then merging and flattening these flows.\n *\n * This operator calls [transform] *sequentially* and then merges the resulting flows with a [concurrency]\n * limit on the number of concurrently collected flows.\n * It is a shortcut for `map(transform).flattenMerge(concurrency)`.\n * See [flattenMerge] for details.\n *\n * Note that even though this operator looks very familiar, we discourage its usage in a regular application-specific flows.\n * Most likely, suspending operation in [map] operator will be sufficient and linear transformations are much easier to reason about.\n *\n * ### Operator fusion\n *\n * Applications of [flowOn], [buffer], and [produceIn] _after_ this operator are fused with\n * its concurrent merging so that only one properly configured channel is used for execution of merging logic.\n *\n * @param concurrency controls the number of in-flight flows, at most [concurrency] flows are collected\n * at the same time. By default, it is equal to [DEFAULT_CONCURRENCY].\n */\n@ExperimentalCoroutinesApi\npublic fun <T, R> Flow<T>.flatMapMerge(\n    concurrency: Int = DEFAULT_CONCURRENCY,\n    transform: suspend (value: T) -> Flow<R>\n): Flow<R> =\n    map(transform).flattenMerge(concurrency)\n\n/**\n * Flattens the given flow of flows into a single flow in a sequential manner, without interleaving nested flows.\n *\n * Inner flows are collected by this operator *sequentially*.\n */\n@ExperimentalCoroutinesApi\npublic fun <T> Flow<Flow<T>>.flattenConcat(): Flow<T> = flow {\n    collect { value -> emitAll(value) }\n}\n\n/**\n * Merges the given flows into a single flow without preserving an order of elements.\n * All flows are merged concurrently, without limit on the number of simultaneously collected flows.\n *\n * ### Operator fusion\n *\n * Applications of [flowOn], [buffer], and [produceIn] _after_ this operator are fused with\n * its concurrent merging so that only one properly configured channel is used for execution of merging logic.\n */\npublic fun <T> Iterable<Flow<T>>.merge(): Flow<T> {\n    /*\n     * This is a fuseable implementation of the following operator:\n     * channelFlow {\n     *    forEach { flow ->\n     *        launch {\n     *            flow.collect { send(it) }\n     *        }\n     *    }\n     * }\n     */\n    return ChannelLimitedFlowMerge(this)\n}\n\n/**\n * Merges the given flows into a single flow without preserving an order of elements.\n * All flows are merged concurrently, without limit on the number of simultaneously collected flows.\n *\n * ### Operator fusion\n *\n * Applications of [flowOn], [buffer], and [produceIn] _after_ this operator are fused with\n * its concurrent merging so that only one properly configured channel is used for execution of merging logic.\n */\npublic fun <T> merge(vararg flows: Flow<T>): Flow<T> = flows.asIterable().merge()\n\n/**\n * Flattens the given flow of flows into a single flow with a [concurrency] limit on the number of\n * concurrently collected flows.\n *\n * If [concurrency] is more than 1, then inner flows are collected by this operator *concurrently*.\n * With `concurrency == 1` this operator is identical to [flattenConcat].\n *\n * ### Operator fusion\n *\n * Applications of [flowOn], [buffer], and [produceIn] _after_ this operator are fused with\n * its concurrent merging so that only one properly configured channel is used for execution of merging logic.\n *\n * When [concurrency] is greater than 1, this operator is [buffered][buffer] by default\n * and size of its output buffer can be changed by applying subsequent [buffer] operator.\n *\n * @param concurrency controls the number of in-flight flows, at most [concurrency] flows are collected\n * at the same time. By default, it is equal to [DEFAULT_CONCURRENCY].\n */\n@ExperimentalCoroutinesApi\npublic fun <T> Flow<Flow<T>>.flattenMerge(concurrency: Int = DEFAULT_CONCURRENCY): Flow<T> {\n    require(concurrency > 0) { \"Expected positive concurrency level, but had $concurrency\" }\n    return if (concurrency == 1) flattenConcat() else ChannelFlowMerge(this, concurrency)\n}\n\n/**\n * Returns a flow that produces element by [transform] function every time the original flow emits a value.\n * When the original flow emits a new value, the previous `transform` block is cancelled, thus the name `transformLatest`.\n *\n * For example, the following flow:\n * ```\n * flow {\n *     emit(\"a\")\n *     delay(100)\n *     emit(\"b\")\n * }.transformLatest { value ->\n *     emit(value)\n *     delay(200)\n *     emit(value + \"_last\")\n * }\n * ```\n * produces `a b b_last`.\n *\n * This operator is [buffered][buffer] by default\n * and size of its output buffer can be changed by applying subsequent [buffer] operator.\n */\n@ExperimentalCoroutinesApi\npublic fun <T, R> Flow<T>.transformLatest(@BuilderInference transform: suspend FlowCollector<R>.(value: T) -> Unit): Flow<R> =\n    ChannelFlowTransformLatest(transform, this)\n\n/**\n * Returns a flow that switches to a new flow produced by [transform] function every time the original flow emits a value.\n * When the original flow emits a new value, the previous flow produced by `transform` block is cancelled.\n *\n * For example, the following flow:\n * ```\n * flow {\n *     emit(\"a\")\n *     delay(100)\n *     emit(\"b\")\n * }.flatMapLatest { value ->\n *     flow {\n *         emit(value)\n *         delay(200)\n *         emit(value + \"_last\")\n *     }\n * }\n * ```\n * produces `a b b_last`\n *\n * This operator is [buffered][buffer] by default and size of its output buffer can be changed by applying subsequent [buffer] operator.\n */\n@ExperimentalCoroutinesApi\npublic inline fun <T, R> Flow<T>.flatMapLatest(@BuilderInference crossinline transform: suspend (value: T) -> Flow<R>): Flow<R> =\n    transformLatest { emitAll(transform(it)) }\n\n/**\n * Returns a flow that emits elements from the original flow transformed by [transform] function.\n * When the original flow emits a new value, computation of the [transform] block for previous value is cancelled.\n *\n * For example, the following flow:\n * ```\n * flow {\n *     emit(\"a\")\n *     delay(100)\n *     emit(\"b\")\n * }.mapLatest { value ->\n *     println(\"Started computing $value\")\n *     delay(200)\n *     \"Computed $value\"\n * }\n * ```\n * will print \"Started computing a\" and \"Started computing b\", but the resulting flow will contain only \"Computed b\" value.\n *\n * This operator is [buffered][buffer] by default and size of its output buffer can be changed by applying subsequent [buffer] operator.\n */\n@ExperimentalCoroutinesApi\npublic fun <T, R> Flow<T>.mapLatest(@BuilderInference transform: suspend (value: T) -> R): Flow<R> =\n    transformLatest { emit(transform(it)) }\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Share.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n// -------------------------------- shareIn --------------------------------\n\n/**\n * Converts a _cold_ [Flow] into a _hot_ [SharedFlow] that is started in the given coroutine [scope],\n * sharing emissions from a single running instance of the upstream flow with multiple downstream subscribers,\n * and replaying a specified number of [replay] values to new subscribers. See the [SharedFlow] documentation\n * for the general concepts of shared flows.\n *\n * The starting of the sharing coroutine is controlled by the [started] parameter. The following options\n * are supported.\n *\n * - [Eagerly][SharingStarted.Eagerly] &mdash; the upstream flow is started even before the first subscriber appears. Note\n *   that in this case all values emitted by the upstream beyond the most recent values as specified by\n *   [replay] parameter **will be immediately discarded**.\n * - [Lazily][SharingStarted.Lazily] &mdash; starts the upstream flow after the first subscriber appears, which guarantees\n *   that this first subscriber gets all the emitted values, while subsequent subscribers are only guaranteed to\n *   get the most recent [replay] values. The upstream flow continues to be active even when all subscribers\n *   disappear, but only the most recent [replay] values are cached without subscribers.\n * - [WhileSubscribed()][SharingStarted.WhileSubscribed] &mdash; starts the upstream flow when the first subscriber\n *   appears, immediately stops when the last subscriber disappears, keeping the replay cache forever.\n *   It has additional optional configuration parameters as explained in its documentation.\n * - A custom strategy can be supplied by implementing the [SharingStarted] interface.\n *\n * The `shareIn` operator is useful in situations when there is a _cold_ flow that is expensive to create and/or\n * to maintain, but there are multiple subscribers that need to collect its values. For example, consider a\n * flow of messages coming from a backend over the expensive network connection, taking a lot of\n * time to establish. Conceptually, it might be implemented like this:\n *\n * ```\n * val backendMessages: Flow<Message> = flow {\n *     connectToBackend() // takes a lot of time\n *     try {\n *       while (true) {\n *           emit(receiveMessageFromBackend())\n *       }\n *     } finally {\n *         disconnectFromBackend()\n *     }\n * }\n * ```\n *\n * If this flow is directly used in the application, then every time it is collected a fresh connection is\n * established, and it will take a while before messages start flowing. However, we can share a single connection\n * and establish it eagerly like this:\n *\n * ```\n * val messages: SharedFlow<Message> = backendMessages.shareIn(scope, SharingStarted.Eagerly)\n * ```\n *\n * Now a single connection is shared between all collectors from `messages`, and there is a chance that the connection\n * is already established by the time it is needed.\n *\n * ### Upstream completion and error handling\n *\n * **Normal completion of the upstream flow has no effect on subscribers**, and the sharing coroutine continues to run. If a\n * strategy like [SharingStarted.WhileSubscribed] is used, then the upstream can get restarted again. If a special\n * action on upstream completion is needed, then an [onCompletion] operator can be used before the\n * `shareIn` operator to emit a special value in this case, like this:\n *\n * ```\n * backendMessages\n *     .onCompletion { cause -> if (cause == null) emit(UpstreamHasCompletedMessage) }\n *     .shareIn(scope, SharingStarted.Eagerly)\n * ```\n *\n * Any exception in the upstream flow terminates the sharing coroutine without affecting any of the subscribers,\n * and will be handled by the [scope] in which the sharing coroutine is launched. Custom exception handling\n * can be configured by using the [catch] or [retry] operators before the `shareIn` operator.\n * For example, to retry connection on any `IOException` with 1 second delay between attempts, use:\n *\n * ```\n * val messages = backendMessages\n *     .retry { e ->\n *         val shallRetry = e is IOException // other exception are bugs - handle them\n *         if (shallRetry) delay(1000)\n *         shallRetry\n *     }\n *     .shareIn(scope, SharingStarted.Eagerly)\n * ```\n *\n * ### Initial value\n *\n * When a special initial value is needed to signal to subscribers that the upstream is still loading the data,\n * use the [onStart] operator on the upstream flow. For example:\n *\n * ```\n * backendMessages\n *     .onStart { emit(UpstreamIsStartingMessage) }\n *     .shareIn(scope, SharingStarted.Eagerly, 1) // replay one most recent message\n * ```\n *\n * ### Buffering and conflation\n *\n * The `shareIn` operator runs the upstream flow in a separate coroutine, and buffers emissions from upstream as explained\n * in the [buffer] operator's description, using a buffer of [replay] size or the default (whichever is larger).\n * This default buffering can be overridden with an explicit buffer configuration by preceding the `shareIn` call\n * with [buffer] or [conflate], for example:\n *\n * - `buffer(0).shareIn(scope, started, 0)` &mdash; overrides the default buffer size and creates a [SharedFlow] without a buffer.\n *   Effectively, it configures sequential processing between the upstream emitter and subscribers,\n *   as the emitter is suspended until all subscribers process the value. Note, that the value is still immediately\n *   discarded when there are no subscribers.\n * - `buffer(b).shareIn(scope, started, r)` &mdash; creates a [SharedFlow] with `replay = r` and `extraBufferCapacity = b`.\n * - `conflate().shareIn(scope, started, r)` &mdash; creates a [SharedFlow] with `replay = r`, `onBufferOverflow = DROP_OLDEST`,\n *   and `extraBufferCapacity = 1` when `replay == 0` to support this strategy.\n *\n * ### Operator fusion\n *\n * Application of [flowOn][Flow.flowOn], [buffer] with [RENDEZVOUS][Channel.RENDEZVOUS] capacity,\n * or [cancellable] operators to the resulting shared flow has no effect.\n *\n * ### Exceptions\n *\n * This function throws [IllegalArgumentException] on unsupported values of parameters or combinations thereof.\n *\n * @param scope the coroutine scope in which sharing is started.\n * @param started the strategy that controls when sharing is started and stopped.\n * @param replay the number of values replayed to new subscribers (cannot be negative, defaults to zero).\n */\npublic fun <T> Flow<T>.shareIn(\n    scope: CoroutineScope,\n    started: SharingStarted,\n    replay: Int = 0\n): SharedFlow<T> {\n    val config = configureSharing(replay)\n    val shared = MutableSharedFlow<T>(\n        replay = replay,\n        extraBufferCapacity = config.extraBufferCapacity,\n        onBufferOverflow = config.onBufferOverflow\n    )\n    @Suppress(\"UNCHECKED_CAST\")\n    val job = scope.launchSharing(config.context, config.upstream, shared, started, NO_VALUE as T)\n    return ReadonlySharedFlow(shared, job)\n}\n\nprivate class SharingConfig<T>(\n    @JvmField val upstream: Flow<T>,\n    @JvmField val extraBufferCapacity: Int,\n    @JvmField val onBufferOverflow: BufferOverflow,\n    @JvmField val context: CoroutineContext\n)\n\n// Decomposes upstream flow to fuse with it when possible\nprivate fun <T> Flow<T>.configureSharing(replay: Int): SharingConfig<T> {\n    assert { replay >= 0 }\n    val defaultExtraCapacity = replay.coerceAtLeast(Channel.CHANNEL_DEFAULT_CAPACITY) - replay\n    // Combine with preceding buffer/flowOn and channel-using operators\n    if (this is ChannelFlow) {\n        // Check if this ChannelFlow can operate without a channel\n        val upstream = dropChannelOperators()\n        if (upstream != null) { // Yes, it can => eliminate the intermediate channel\n            return SharingConfig(\n                upstream = upstream,\n                extraBufferCapacity = when (capacity) {\n                    Channel.OPTIONAL_CHANNEL, Channel.BUFFERED, 0 -> // handle special capacities\n                        when {\n                            onBufferOverflow == BufferOverflow.SUSPEND -> // buffer was configured with suspension\n                                if (capacity == 0) 0 else defaultExtraCapacity // keep explicitly configured 0 or use default\n                            replay == 0 -> 1 // no suspension => need at least buffer of one\n                            else -> 0 // replay > 0 => no need for extra buffer beyond replay because we don't suspend\n                        }\n                    else -> capacity // otherwise just use the specified capacity as extra capacity\n                },\n                onBufferOverflow = onBufferOverflow,\n                context = context\n            )\n        }\n    }\n    // Add sharing operator on top with a default buffer\n    return SharingConfig(\n        upstream = this,\n        extraBufferCapacity = defaultExtraCapacity,\n        onBufferOverflow = BufferOverflow.SUSPEND,\n        context = EmptyCoroutineContext\n    )\n}\n\n// Launches sharing coroutine\nprivate fun <T> CoroutineScope.launchSharing(\n    context: CoroutineContext,\n    upstream: Flow<T>,\n    shared: MutableSharedFlow<T>,\n    started: SharingStarted,\n    initialValue: T\n): Job {\n    /*\n     * Conditional start: in the case when sharing and subscribing happens in the same dispatcher, we want to\n     * have the following invariants preserved:\n     * - Delayed sharing strategies have a chance to immediately observe consecutive subscriptions.\n     *   E.g. in the cases like `flow.shareIn(...); flow.take(1)` we want sharing strategy to see the initial subscription\n     * - Eager sharing does not start immediately, so the subscribers have actual chance to subscribe _prior_ to sharing.\n     */\n    val start = if (started == SharingStarted.Eagerly) CoroutineStart.DEFAULT else CoroutineStart.UNDISPATCHED\n    return launch(context, start = start) { // the single coroutine to rule the sharing\n        // Optimize common built-in started strategies\n        when {\n            started === SharingStarted.Eagerly -> {\n                // collect immediately & forever\n                upstream.collect(shared)\n            }\n            started === SharingStarted.Lazily -> {\n                // start collecting on the first subscriber - wait for it first\n                shared.subscriptionCount.first { it > 0 }\n                upstream.collect(shared)\n            }\n            else -> {\n                // other & custom strategies\n                started.command(shared.subscriptionCount)\n                    .distinctUntilChanged() // only changes in command have effect\n                    .collectLatest { // cancels block on new emission\n                        when (it) {\n                            SharingCommand.START -> upstream.collect(shared) // can be cancelled\n                            SharingCommand.STOP -> { /* just cancel and do nothing else */ }\n                            SharingCommand.STOP_AND_RESET_REPLAY_CACHE -> {\n                                if (initialValue === NO_VALUE) {\n                                    shared.resetReplayCache() // regular shared flow -> reset cache\n                                } else {\n                                    shared.tryEmit(initialValue) // state flow -> reset to initial value\n                                }\n                            }\n                        }\n                    }\n            }\n        }\n    }\n}\n\n// -------------------------------- stateIn --------------------------------\n\n/**\n * Converts a _cold_ [Flow] into a _hot_ [StateFlow] that is started in the given coroutine [scope],\n * sharing the most recently emitted value from a single running instance of the upstream flow with multiple\n * downstream subscribers. See the [StateFlow] documentation for the general concepts of state flows.\n *\n * The starting of the sharing coroutine is controlled by the [started] parameter, as explained in the\n * documentation for [shareIn] operator.\n *\n * The `stateIn` operator is useful in situations when there is a _cold_ flow that provides updates to the\n * value of some state and is expensive to create and/or to maintain, but there are multiple subscribers\n * that need to collect the most recent state value. For example, consider a\n * flow of state updates coming from a backend over the expensive network connection, taking a lot of\n * time to establish. Conceptually it might be implemented like this:\n *\n * ```\n * val backendState: Flow<State> = flow {\n *     connectToBackend() // takes a lot of time\n *     try {\n *       while (true) {\n *           emit(receiveStateUpdateFromBackend())\n *       }\n *     } finally {\n *         disconnectFromBackend()\n *     }\n * }\n * ```\n *\n * If this flow is directly used in the application, then every time it is collected a fresh connection is\n * established, and it will take a while before state updates start flowing. However, we can share a single connection\n * and establish it eagerly like this:\n *\n * ```\n * val state: StateFlow<State> = backendMessages.stateIn(scope, SharingStarted.Eagerly, State.LOADING)\n * ```\n *\n * Now, a single connection is shared between all collectors from `state`, and there is a chance that the connection\n * is already established by the time it is needed.\n *\n * ### Upstream completion and error handling\n *\n * **Normal completion of the upstream flow has no effect on subscribers**, and the sharing coroutine continues to run. If a\n * a strategy like [SharingStarted.WhileSubscribed] is used, then the upstream can get restarted again. If a special\n * action on upstream completion is needed, then an [onCompletion] operator can be used before\n * the `stateIn` operator to emit a special value in this case. See the [shareIn] operator's documentation for an example.\n *\n * Any exception in the upstream flow terminates the sharing coroutine without affecting any of the subscribers,\n * and will be handled by the [scope] in which the sharing coroutine is launched. Custom exception handling\n * can be configured by using the [catch] or [retry] operators before the `stateIn` operator, similarly to\n * the [shareIn] operator.\n *\n * ### Operator fusion\n *\n * Application of [flowOn][Flow.flowOn], [conflate][Flow.conflate],\n * [buffer] with [CONFLATED][Channel.CONFLATED] or [RENDEZVOUS][Channel.RENDEZVOUS] capacity,\n * [distinctUntilChanged][Flow.distinctUntilChanged], or [cancellable] operators to a state flow has no effect.\n *\n * @param scope the coroutine scope in which sharing is started.\n * @param started the strategy that controls when sharing is started and stopped.\n * @param initialValue the initial value of the state flow.\n *   This value is also used when the state flow is reset using the [SharingStarted.WhileSubscribed] strategy\n *   with the `replayExpirationMillis` parameter.\n */\npublic fun <T> Flow<T>.stateIn(\n    scope: CoroutineScope,\n    started: SharingStarted,\n    initialValue: T\n): StateFlow<T> {\n    val config = configureSharing(1)\n    val state = MutableStateFlow(initialValue)\n    val job = scope.launchSharing(config.context, config.upstream, state, started, initialValue)\n    return ReadonlyStateFlow(state, job)\n}\n\n/**\n * Starts the upstream flow in a given [scope], suspends until the first value is emitted, and returns a _hot_\n * [StateFlow] of future emissions, sharing the most recently emitted value from this running instance of the upstream flow\n * with multiple downstream subscribers. See the [StateFlow] documentation for the general concepts of state flows.\n *\n * @param scope the coroutine scope in which sharing is started.\n */\npublic suspend fun <T> Flow<T>.stateIn(scope: CoroutineScope): StateFlow<T> {\n    val config = configureSharing(1)\n    val result = CompletableDeferred<StateFlow<T>>()\n    scope.launchSharingDeferred(config.context, config.upstream, result)\n    return result.await()\n}\n\nprivate fun <T> CoroutineScope.launchSharingDeferred(\n    context: CoroutineContext,\n    upstream: Flow<T>,\n    result: CompletableDeferred<StateFlow<T>>\n) {\n    launch(context) {\n        try {\n            var state: MutableStateFlow<T>? = null\n            upstream.collect { value ->\n                state?.let { it.value = value } ?: run {\n                    state = MutableStateFlow(value).also {\n                        result.complete(ReadonlyStateFlow(it, coroutineContext.job))\n                    }\n                }\n            }\n        } catch (e: Throwable) {\n            // Notify the waiter that the flow has failed\n            result.completeExceptionally(e)\n            // But still cancel the scope where state was (not) produced\n            throw e\n        }\n    }\n}\n\n// -------------------------------- asSharedFlow/asStateFlow --------------------------------\n\n/**\n * Represents this mutable shared flow as a read-only shared flow.\n */\npublic fun <T> MutableSharedFlow<T>.asSharedFlow(): SharedFlow<T> =\n    ReadonlySharedFlow(this, null)\n\n/**\n * Represents this mutable state flow as a read-only state flow.\n */\npublic fun <T> MutableStateFlow<T>.asStateFlow(): StateFlow<T> =\n    ReadonlyStateFlow(this, null)\n\nprivate class ReadonlySharedFlow<T>(\n    flow: SharedFlow<T>,\n    @Suppress(\"unused\")\n    private val job: Job? // keeps a strong reference to the job (if present)\n) : SharedFlow<T> by flow, CancellableFlow<T>, FusibleFlow<T> {\n    override fun fuse(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow) =\n        fuseSharedFlow(context, capacity, onBufferOverflow)\n}\n\nprivate class ReadonlyStateFlow<T>(\n    flow: StateFlow<T>,\n    @Suppress(\"unused\")\n    private val job: Job? // keeps a strong reference to the job (if present)\n) : StateFlow<T> by flow, CancellableFlow<T>, FusibleFlow<T> {\n    override fun fuse(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow) =\n        fuseStateFlow(context, capacity, onBufferOverflow)\n}\n\n// -------------------------------- onSubscription --------------------------------\n\n/**\n * Returns a flow that invokes the given [action] **after** this shared flow starts to be collected\n * (after the subscription is registered).\n *\n * The [action] is called before any value is emitted from the upstream\n * flow to this subscription but after the subscription is established. It is guaranteed that all emissions to\n * the upstream flow that happen inside or immediately after this `onSubscription` action will be\n * collected by this subscription.\n *\n * The receiver of the [action] is [FlowCollector], so `onSubscription` can emit additional elements.\n */\npublic fun <T> SharedFlow<T>.onSubscription(action: suspend FlowCollector<T>.() -> Unit): SharedFlow<T> =\n    SubscribedSharedFlow(this, action)\n\nprivate class SubscribedSharedFlow<T>(\n    private val sharedFlow: SharedFlow<T>,\n    private val action: suspend FlowCollector<T>.() -> Unit\n) : SharedFlow<T> by sharedFlow {\n    override suspend fun collect(collector: FlowCollector<T>) =\n        sharedFlow.collect(SubscribedFlowCollector(collector, action))\n}\n\ninternal class SubscribedFlowCollector<T>(\n    private val collector: FlowCollector<T>,\n    private val action: suspend FlowCollector<T>.() -> Unit\n) : FlowCollector<T> by collector {\n    suspend fun onSubscription() {\n        val safeCollector = SafeCollector(collector, currentCoroutineContext())\n        try {\n            safeCollector.action()\n        } finally {\n            safeCollector.releaseIntercepted()\n        }\n        if (collector is SubscribedFlowCollector) collector.onSubscription()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Transform.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n@file:Suppress(\"UNCHECKED_CAST\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.jvm.*\nimport kotlin.reflect.*\nimport kotlinx.coroutines.flow.internal.unsafeFlow as flow\nimport kotlinx.coroutines.flow.unsafeTransform as transform\n\n/**\n * Returns a flow containing only values of the original flow that match the given [predicate].\n */\npublic inline fun <T> Flow<T>.filter(crossinline predicate: suspend (T) -> Boolean): Flow<T> = transform { value ->\n    if (predicate(value)) return@transform emit(value)\n}\n\n/**\n * Returns a flow containing only values of the original flow that do not match the given [predicate].\n */\npublic inline fun <T> Flow<T>.filterNot(crossinline predicate: suspend (T) -> Boolean): Flow<T> = transform { value ->\n    if (!predicate(value)) return@transform emit(value)\n}\n\n/**\n * Returns a flow containing only values that are instances of specified type [R].\n */\n@Suppress(\"UNCHECKED_CAST\")\npublic inline fun <reified R> Flow<*>.filterIsInstance(): Flow<R> = filter { it is R } as Flow<R>\n\n/**\n * Returns a flow containing only values that are instances of the given [klass].\n */\npublic fun <R : Any> Flow<*>.filterIsInstance(klass: KClass<R>): Flow<R> = filter { klass.isInstance(it) } as Flow<R>\n\n/**\n * Returns a flow containing only values of the original flow that are not null.\n */\npublic fun <T: Any> Flow<T?>.filterNotNull(): Flow<T> = transform<T?, T> { value ->\n    if (value != null) return@transform emit(value)\n}\n\n/**\n * Returns a flow containing the results of applying the given [transform] function to each value of the original flow.\n */\npublic inline fun <T, R> Flow<T>.map(crossinline transform: suspend (value: T) -> R): Flow<R> = transform { value ->\n    return@transform emit(transform(value))\n}\n\n/**\n * Returns a flow that contains only non-null results of applying the given [transform] function to each value of the original flow.\n */\npublic inline fun <T, R: Any> Flow<T>.mapNotNull(crossinline transform: suspend (value: T) -> R?): Flow<R> = transform { value ->\n    val transformed = transform(value) ?: return@transform\n    return@transform emit(transformed)\n}\n\n/**\n * Returns a flow that wraps each element into [IndexedValue], containing value and its index (starting from zero).\n */\npublic fun <T> Flow<T>.withIndex(): Flow<IndexedValue<T>> = flow {\n    var index = 0\n    collect { value ->\n        emit(IndexedValue(checkIndexOverflow(index++), value))\n    }\n}\n\n/**\n * Returns a flow that invokes the given [action] **before** each value of the upstream flow is emitted downstream.\n */\npublic fun <T> Flow<T>.onEach(action: suspend (T) -> Unit): Flow<T> = transform { value ->\n    action(value)\n    return@transform emit(value)\n}\n\n/**\n * Folds the given flow with [operation], emitting every intermediate result, including [initial] value.\n * Note that initial value should be immutable (or should not be mutated) as it is shared between different collectors.\n * For example:\n * ```\n * flowOf(1, 2, 3).scan(emptyList<Int>()) { acc, value -> acc + value }.toList()\n * ```\n * will produce `[[], [1], [1, 2], [1, 2, 3]]`.\n *\n * This function is an alias to [runningFold] operator.\n */\npublic fun <T, R> Flow<T>.scan(initial: R, @BuilderInference operation: suspend (accumulator: R, value: T) -> R): Flow<R> = runningFold(initial, operation)\n\n/**\n * Folds the given flow with [operation], emitting every intermediate result, including [initial] value.\n * Note that initial value should be immutable (or should not be mutated) as it is shared between different collectors.\n * For example:\n * ```\n * flowOf(1, 2, 3).runningFold(emptyList<Int>()) { acc, value -> acc + value }.toList()\n * ```\n * will produce `[[], [1], [1, 2], [1, 2, 3]]`.\n */\npublic fun <T, R> Flow<T>.runningFold(initial: R, @BuilderInference operation: suspend (accumulator: R, value: T) -> R): Flow<R> = flow {\n    var accumulator: R = initial\n    emit(accumulator)\n    collect { value ->\n        accumulator = operation(accumulator, value)\n        emit(accumulator)\n    }\n}\n\n/**\n * Reduces the given flow with [operation], emitting every intermediate result, including initial value.\n * The first element is taken as initial value for operation accumulator.\n * This operator has a sibling with initial value -- [scan].\n *\n * For example:\n * ```\n * flowOf(1, 2, 3, 4).runningReduce { acc, value -> acc + value }.toList()\n * ```\n * will produce `[1, 3, 6, 10]`\n */\npublic fun <T> Flow<T>.runningReduce(operation: suspend (accumulator: T, value: T) -> T): Flow<T> = flow {\n    var accumulator: Any? = NULL\n    collect { value ->\n        accumulator = if (accumulator === NULL) {\n            value\n        } else {\n            operation(accumulator as T, value)\n        }\n        emit(accumulator as T)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/operators/Zip.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n@file:Suppress(\"UNCHECKED_CAST\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.jvm.*\nimport kotlinx.coroutines.flow.flow as safeFlow\nimport kotlinx.coroutines.flow.internal.unsafeFlow as flow\n\n/**\n * Returns a [Flow] whose values are generated with [transform] function by combining\n * the most recently emitted values by each flow.\n *\n * It can be demonstrated with the following example:\n * ```\n * val flow = flowOf(1, 2).onEach { delay(10) }\n * val flow2 = flowOf(\"a\", \"b\", \"c\").onEach { delay(15) }\n * flow.combine(flow2) { i, s -> i.toString() + s }.collect {\n *     println(it) // Will print \"1a 2a 2b 2c\"\n * }\n * ```\n *\n * This function is a shorthand for `flow.combineTransform(flow2) { a, b -> emit(transform(a, b)) }\n */\n@JvmName(\"flowCombine\")\npublic fun <T1, T2, R> Flow<T1>.combine(flow: Flow<T2>, transform: suspend (a: T1, b: T2) -> R): Flow<R> = flow {\n    combineInternal(arrayOf(this@combine, flow), nullArrayFactory(), { emit(transform(it[0] as T1, it[1] as T2)) })\n}\n\n/**\n * Returns a [Flow] whose values are generated with [transform] function by combining\n * the most recently emitted values by each flow.\n *\n * It can be demonstrated with the following example:\n * ```\n * val flow = flowOf(1, 2).onEach { delay(10) }\n * val flow2 = flowOf(\"a\", \"b\", \"c\").onEach { delay(15) }\n * combine(flow, flow2) { i, s -> i.toString() + s }.collect {\n *     println(it) // Will print \"1a 2a 2b 2c\"\n * }\n * ```\n *\n * This function is a shorthand for `combineTransform(flow, flow2) { a, b -> emit(transform(a, b)) }\n */\npublic fun <T1, T2, R> combine(flow: Flow<T1>, flow2: Flow<T2>, transform: suspend (a: T1, b: T2) -> R): Flow<R> =\n    flow.combine(flow2, transform)\n\n/**\n * Returns a [Flow] whose values are generated by [transform] function that process the most recently emitted values by each flow.\n *\n * The receiver of the [transform] is [FlowCollector] and thus `transform` is a\n * generic function that may transform emitted element, skip it or emit it multiple times.\n *\n * Its usage can be demonstrated with the following example:\n * ```\n * val flow = requestFlow()\n * val flow2 = searchEngineFlow()\n * flow.combineTransform(flow2) { request, searchEngine ->\n *     emit(\"Downloading in progress\")\n *     val result = download(request, searchEngine)\n *     emit(result)\n * }\n * ```\n */\n@JvmName(\"flowCombineTransform\")\npublic fun <T1, T2, R> Flow<T1>.combineTransform(\n    flow: Flow<T2>,\n    @BuilderInference transform: suspend FlowCollector<R>.(a: T1, b: T2) -> Unit\n): Flow<R> = combineTransformUnsafe(this, flow) { args: Array<*> ->\n    transform(\n        args[0] as T1,\n        args[1] as T2\n    )\n}\n\n/**\n * Returns a [Flow] whose values are generated by [transform] function that process the most recently emitted values by each flow.\n *\n * The receiver of the [transform] is [FlowCollector] and thus `transform` is a\n * generic function that may transform emitted element, skip it or emit it multiple times.\n *\n * Its usage can be demonstrated with the following example:\n * ```\n * val flow = requestFlow()\n * val flow2 = searchEngineFlow()\n * combineTransform(flow, flow2) { request, searchEngine ->\n *     emit(\"Downloading in progress\")\n *     val result = download(request, searchEngine)\n *     emit(result)\n * }\n * ```\n */\npublic fun <T1, T2, R> combineTransform(\n    flow: Flow<T1>,\n    flow2: Flow<T2>,\n    @BuilderInference transform: suspend FlowCollector<R>.(a: T1, b: T2) -> Unit\n): Flow<R> = combineTransformUnsafe(flow, flow2) { args: Array<*> ->\n    transform(\n        args[0] as T1,\n        args[1] as T2\n    )\n}\n\n/**\n * Returns a [Flow] whose values are generated with [transform] function by combining\n * the most recently emitted values by each flow.\n */\npublic fun <T1, T2, T3, R> combine(\n    flow: Flow<T1>,\n    flow2: Flow<T2>,\n    flow3: Flow<T3>,\n    @BuilderInference transform: suspend (T1, T2, T3) -> R\n): Flow<R> = combineUnsafe(flow, flow2, flow3) { args: Array<*> ->\n    transform(\n        args[0] as T1,\n        args[1] as T2,\n        args[2] as T3\n    )\n}\n\n/**\n * Returns a [Flow] whose values are generated by [transform] function that process the most recently emitted values by each flow.\n *\n * The receiver of the [transform] is [FlowCollector] and thus `transform` is a\n * generic function that may transform emitted element, skip it or emit it multiple times.\n */\npublic fun <T1, T2, T3, R> combineTransform(\n    flow: Flow<T1>,\n    flow2: Flow<T2>,\n    flow3: Flow<T3>,\n    @BuilderInference transform: suspend FlowCollector<R>.(T1, T2, T3) -> Unit\n): Flow<R> = combineTransformUnsafe(flow, flow2, flow3) { args: Array<*> ->\n    transform(\n        args[0] as T1,\n        args[1] as T2,\n        args[2] as T3\n    )\n}\n\n/**\n * Returns a [Flow] whose values are generated with [transform] function by combining\n * the most recently emitted values by each flow.\n */\npublic fun <T1, T2, T3, T4, R> combine(\n    flow: Flow<T1>,\n    flow2: Flow<T2>,\n    flow3: Flow<T3>,\n    flow4: Flow<T4>,\n    transform: suspend (T1, T2, T3, T4) -> R\n): Flow<R> = combineUnsafe(flow, flow2, flow3, flow4) { args: Array<*> ->\n    transform(\n        args[0] as T1,\n        args[1] as T2,\n        args[2] as T3,\n        args[3] as T4\n    )\n}\n\n/**\n * Returns a [Flow] whose values are generated by [transform] function that process the most recently emitted values by each flow.\n *\n * The receiver of the [transform] is [FlowCollector] and thus `transform` is a\n * generic function that may transform emitted element, skip it or emit it multiple times.\n */\npublic fun <T1, T2, T3, T4, R> combineTransform(\n    flow: Flow<T1>,\n    flow2: Flow<T2>,\n    flow3: Flow<T3>,\n    flow4: Flow<T4>,\n    @BuilderInference transform: suspend FlowCollector<R>.(T1, T2, T3, T4) -> Unit\n): Flow<R> = combineTransformUnsafe(flow, flow2, flow3, flow4) { args: Array<*> ->\n    transform(\n        args[0] as T1,\n        args[1] as T2,\n        args[2] as T3,\n        args[3] as T4\n    )\n}\n\n/**\n * Returns a [Flow] whose values are generated with [transform] function by combining\n * the most recently emitted values by each flow.\n */\npublic fun <T1, T2, T3, T4, T5, R> combine(\n    flow: Flow<T1>,\n    flow2: Flow<T2>,\n    flow3: Flow<T3>,\n    flow4: Flow<T4>,\n    flow5: Flow<T5>,\n    transform: suspend (T1, T2, T3, T4, T5) -> R\n): Flow<R> = combineUnsafe(flow, flow2, flow3, flow4, flow5) { args: Array<*> ->\n    transform(\n        args[0] as T1,\n        args[1] as T2,\n        args[2] as T3,\n        args[3] as T4,\n        args[4] as T5\n    )\n}\n\n/**\n * Returns a [Flow] whose values are generated by [transform] function that process the most recently emitted values by each flow.\n *\n * The receiver of the [transform] is [FlowCollector] and thus `transform` is a\n * generic function that may transform emitted element, skip it or emit it multiple times.\n */\npublic fun <T1, T2, T3, T4, T5, R> combineTransform(\n    flow: Flow<T1>,\n    flow2: Flow<T2>,\n    flow3: Flow<T3>,\n    flow4: Flow<T4>,\n    flow5: Flow<T5>,\n    @BuilderInference transform: suspend FlowCollector<R>.(T1, T2, T3, T4, T5) -> Unit\n): Flow<R> = combineTransformUnsafe(flow, flow2, flow3, flow4, flow5) { args: Array<*> ->\n    transform(\n        args[0] as T1,\n        args[1] as T2,\n        args[2] as T3,\n        args[3] as T4,\n        args[4] as T5\n    )\n}\n\n/**\n * Returns a [Flow] whose values are generated with [transform] function by combining\n * the most recently emitted values by each flow.\n */\npublic inline fun <reified T, R> combine(\n    vararg flows: Flow<T>,\n    crossinline transform: suspend (Array<T>) -> R\n): Flow<R> = flow {\n    combineInternal(flows, { arrayOfNulls(flows.size) }, { emit(transform(it)) })\n}\n\n/**\n * Returns a [Flow] whose values are generated by [transform] function that process the most recently emitted values by each flow.\n *\n * The receiver of the [transform] is [FlowCollector] and thus `transform` is a\n * generic function that may transform emitted element, skip it or emit it multiple times.\n */\npublic inline fun <reified T, R> combineTransform(\n    vararg flows: Flow<T>,\n    @BuilderInference crossinline transform: suspend FlowCollector<R>.(Array<T>) -> Unit\n): Flow<R> = safeFlow {\n    combineInternal(flows, { arrayOfNulls(flows.size) }, { transform(it) })\n}\n\n/*\n * Same as combine, but does not copy array each time, deconstructing existing\n * array each time. Used in overloads that accept FunctionN instead of Function<Array<R>>\n */\nprivate inline fun <reified T, R> combineUnsafe(\n    vararg flows: Flow<T>,\n    crossinline transform: suspend (Array<T>) -> R\n): Flow<R> = flow {\n    combineInternal(flows, nullArrayFactory(), { emit(transform(it)) })\n}\n\n/*\n * Same as combineTransform, but does not copy array each time, deconstructing existing\n * array each time. Used in overloads that accept FunctionN instead of Function<Array<R>>\n */\nprivate inline fun <reified T, R> combineTransformUnsafe(\n    vararg flows: Flow<T>,\n    @BuilderInference crossinline transform: suspend FlowCollector<R>.(Array<T>) -> Unit\n): Flow<R> = safeFlow {\n    combineInternal(flows, nullArrayFactory(), { transform(it) })\n}\n\n// Saves bunch of anonymous classes\nprivate fun <T> nullArrayFactory(): () -> Array<T>? = { null }\n\n/**\n * Returns a [Flow] whose values are generated with [transform] function by combining\n * the most recently emitted values by each flow.\n */\npublic inline fun <reified T, R> combine(\n    flows: Iterable<Flow<T>>,\n    crossinline transform: suspend (Array<T>) -> R\n): Flow<R> {\n    val flowArray = flows.toList().toTypedArray()\n    return flow {\n        combineInternal(\n            flowArray,\n            arrayFactory = { arrayOfNulls(flowArray.size) },\n            transform = { emit(transform(it)) })\n    }\n}\n\n/**\n * Returns a [Flow] whose values are generated by [transform] function that process the most recently emitted values by each flow.\n *\n * The receiver of the [transform] is [FlowCollector] and thus `transform` is a\n * generic function that may transform emitted element, skip it or emit it multiple times.\n */\npublic inline fun <reified T, R> combineTransform(\n    flows: Iterable<Flow<T>>,\n    @BuilderInference crossinline transform: suspend FlowCollector<R>.(Array<T>) -> Unit\n): Flow<R> {\n    val flowArray = flows.toList().toTypedArray()\n    return safeFlow {\n        combineInternal(flowArray, { arrayOfNulls(flowArray.size) }, { transform(it) })\n    }\n}\n\n/**\n * Zips values from the current flow (`this`) with [other] flow using provided [transform] function applied to each pair of values.\n * The resulting flow completes as soon as one of the flows completes and cancel is called on the remaining flow.\n *\n * It can be demonstrated with the following example:\n * ```\n * val flow = flowOf(1, 2, 3).onEach { delay(10) }\n * val flow2 = flowOf(\"a\", \"b\", \"c\", \"d\").onEach { delay(15) }\n * flow.zip(flow2) { i, s -> i.toString() + s }.collect {\n *     println(it) // Will print \"1a 2b 3c\"\n * }\n * ```\n *\n * ### Buffering\n *\n * The upstream flow is collected sequentially in the same coroutine without any buffering, while the\n * [other] flow is collected concurrently as if `buffer(0)` is used. See documentation in the [buffer] operator\n * for explanation. You can use additional calls to the [buffer] operator as needed for more concurrency.\n */\npublic fun <T1, T2, R> Flow<T1>.zip(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> = zipImpl(this, other, transform)\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/terminal/Collect.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.jvm.*\n\n/**\n * Terminal flow operator that collects the given flow but ignores all emitted values.\n * If any exception occurs during collect or in the provided flow, this exception is rethrown from this method.\n *\n * It is a shorthand for `collect {}`.\n *\n * This operator is usually used with [onEach], [onCompletion] and [catch] operators to process all emitted values and\n * handle an exception that might occur in the upstream flow or during processing, for example:\n *\n * ```\n * flow\n *     .onEach { value -> process(value) }\n *     .catch { e -> handleException(e) }\n *     .collect() // trigger collection of the flow\n * ```\n */\npublic suspend fun Flow<*>.collect(): Unit = collect(NopCollector)\n\n/**\n * Terminal flow operator that [launches][launch] the [collection][collect] of the given flow in the [scope].\n * It is a shorthand for `scope.launch { flow.collect() }`.\n *\n * This operator is usually used with [onEach], [onCompletion] and [catch] operators to process all emitted values\n * handle an exception that might occur in the upstream flow or during processing, for example:\n *\n * ```\n * flow\n *     .onEach { value -> updateUi(value) }\n *     .onCompletion { cause -> updateUi(if (cause == null) \"Done\" else \"Failed\") }\n *     .catch { cause -> LOG.error(\"Exception: $cause\") }\n *     .launchIn(uiScope)\n * ```\n *\n * Note that the resulting value of [launchIn] is not used and the provided scope takes care of cancellation.\n */\npublic fun <T> Flow<T>.launchIn(scope: CoroutineScope): Job = scope.launch {\n    collect() // tail-call\n}\n\n/**\n * Terminal flow operator that collects the given flow with a provided [action] that takes the index of an element (zero-based) and the element.\n * If any exception occurs during collect or in the provided flow, this exception is rethrown from this method.\n *\n * See also [collect] and [withIndex].\n */\npublic suspend inline fun <T> Flow<T>.collectIndexed(crossinline action: suspend (index: Int, value: T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        private var index = 0\n        override suspend fun emit(value: T) = action(checkIndexOverflow(index++), value)\n    })\n\n/**\n * Terminal flow operator that collects the given flow with a provided [action].\n * The crucial difference from [collect] is that when the original flow emits a new value\n * then the [action] block for the previous value is cancelled.\n *\n * It can be demonstrated by the following example:\n *\n * ```\n * flow {\n *     emit(1)\n *     delay(50)\n *     emit(2)\n * }.collectLatest { value ->\n *     println(\"Collecting $value\")\n *     delay(100) // Emulate work\n *     println(\"$value collected\")\n * }\n * ```\n *\n * prints \"Collecting 1, Collecting 2, 2 collected\"\n */\npublic suspend fun <T> Flow<T>.collectLatest(action: suspend (value: T) -> Unit) {\n    /*\n     * Implementation note:\n     * buffer(0) is inserted here to fulfil user's expectations in sequential usages, e.g.:\n     * ```\n     * flowOf(1, 2, 3).collectLatest {\n     *     delay(1)\n     *     println(it) // Expect only 3 to be printed\n     * }\n     * ```\n     *\n     * It's not the case for intermediate operators which users mostly use for interactive UI,\n     * where performance of dispatch is more important.\n     */\n    mapLatest(action).buffer(0).collect()\n}\n\n/**\n * Collects all the values from the given [flow] and emits them to the collector.\n * It is a shorthand for `flow.collect { value -> emit(value) }`.\n */\npublic suspend fun <T> FlowCollector<T>.emitAll(flow: Flow<T>) {\n    ensureActive()\n    flow.collect(this)\n}\n\n/** @suppress */\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Backwards compatibility with JS and K/N\")\npublic suspend inline fun <T> Flow<T>.collect(crossinline action: suspend (value: T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        override suspend fun emit(value: T) = action(value)\n    })\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/terminal/Collection.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlin.jvm.*\n\n/**\n * Collects given flow into a [destination]\n */\npublic suspend fun <T> Flow<T>.toList(destination: MutableList<T> = ArrayList()): List<T> = toCollection(destination)\n\n/**\n * Collects given flow into a [destination]\n */\npublic suspend fun <T> Flow<T>.toSet(destination: MutableSet<T> = LinkedHashSet()): Set<T> = toCollection(destination)\n\n/**\n * Collects given flow into a [destination]\n */\npublic suspend fun <T, C : MutableCollection<in T>> Flow<T>.toCollection(destination: C): C {\n    collect { value ->\n        destination.add(value)\n    }\n    return destination\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/terminal/Count.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlin.jvm.*\n\n/**\n * Returns the number of elements in this flow.\n */\npublic suspend fun <T> Flow<T>.count(): Int  {\n    var i = 0\n    collect {\n        ++i\n    }\n\n    return i\n}\n\n/**\n * Returns the number of elements matching the given predicate.\n */\npublic suspend fun <T> Flow<T>.count(predicate: suspend (T) -> Boolean): Int {\n    var i = 0\n    collect { value ->\n        if (predicate(value)) {\n            ++i\n        }\n    }\n\n    return i\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/flow/terminal/Reduce.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n@file:Suppress(\"UNCHECKED_CAST\")\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.flow.internal.*\nimport kotlinx.coroutines.internal.Symbol\nimport kotlin.jvm.*\n\n/**\n * Accumulates value starting with the first element and applying [operation] to current accumulator value and each element.\n * Throws [NoSuchElementException] if flow was empty.\n */\npublic suspend fun <S, T : S> Flow<T>.reduce(operation: suspend (accumulator: S, value: T) -> S): S {\n    var accumulator: Any? = NULL\n\n    collect { value ->\n        accumulator = if (accumulator !== NULL) {\n            @Suppress(\"UNCHECKED_CAST\")\n            operation(accumulator as S, value)\n        } else {\n            value\n        }\n    }\n\n    if (accumulator === NULL) throw NoSuchElementException(\"Empty flow can't be reduced\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return accumulator as S\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] current accumulator value and each element\n */\npublic suspend inline fun <T, R> Flow<T>.fold(\n    initial: R,\n    crossinline operation: suspend (acc: R, value: T) -> R\n): R {\n    var accumulator = initial\n    collect { value ->\n        accumulator = operation(accumulator, value)\n    }\n    return accumulator\n}\n\n/**\n * The terminal operator that awaits for one and only one value to be emitted.\n * Throws [NoSuchElementException] for empty flow and [IllegalArgumentException] for flow\n * that contains more than one element.\n */\npublic suspend fun <T> Flow<T>.single(): T {\n    var result: Any? = NULL\n    collect { value ->\n        require(result === NULL) { \"Flow has more than one element\" }\n        result = value\n    }\n\n    if (result === NULL) throw NoSuchElementException(\"Flow is empty\")\n    return result as T\n}\n\n/**\n * The terminal operator that awaits for one and only one value to be emitted.\n * Returns the single value or `null`, if the flow was empty or emitted more than one value.\n */\npublic suspend fun <T> Flow<T>.singleOrNull(): T? {\n    var result: Any? = NULL\n    collectWhile {\n        // No values yet, update result\n        if (result === NULL) {\n            result = it\n            true\n        } else {\n            // Second value, reset result and bail out\n            result = NULL\n            false\n        }\n    }\n    return if (result === NULL) null else result as T\n}\n\n/**\n * The terminal operator that returns the first element emitted by the flow and then cancels flow's collection.\n * Throws [NoSuchElementException] if the flow was empty.\n */\npublic suspend fun <T> Flow<T>.first(): T {\n    var result: Any? = NULL\n    collectWhile {\n        result = it\n        false\n    }\n    if (result === NULL) throw NoSuchElementException(\"Expected at least one element\")\n    return result as T\n}\n\n/**\n * The terminal operator that returns the first element emitted by the flow matching the given [predicate] and then cancels flow's collection.\n * Throws [NoSuchElementException] if the flow has not contained elements matching the [predicate].\n */\npublic suspend fun <T> Flow<T>.first(predicate: suspend (T) -> Boolean): T {\n    var result: Any? = NULL\n    collectWhile {\n        if (predicate(it)) {\n            result = it\n            false\n        } else {\n            true\n        }\n    }\n    if (result === NULL) throw NoSuchElementException(\"Expected at least one element matching the predicate $predicate\")\n    return result as T\n}\n\n/**\n * The terminal operator that returns the first element emitted by the flow and then cancels flow's collection.\n * Returns `null` if the flow was empty.\n */\npublic suspend fun <T> Flow<T>.firstOrNull(): T? {\n    var result: T? = null\n    collectWhile {\n        result = it\n        false\n    }\n    return result\n}\n\n/**\n * The terminal operator that returns the first element emitted by the flow matching the given [predicate] and then cancels flow's collection.\n * Returns `null` if the flow did not contain an element matching the [predicate].\n */\npublic suspend fun <T> Flow<T>.firstOrNull(predicate: suspend (T) -> Boolean): T? {\n    var result: T? = null\n    collectWhile {\n        if (predicate(it)) {\n            result = it\n            false\n        } else {\n            true\n        }\n    }\n    return result\n}\n\n/**\n * The terminal operator that returns the last element emitted by the flow.\n *\n * Throws [NoSuchElementException] if the flow was empty.\n */\npublic suspend fun <T> Flow<T>.last(): T {\n    var result: Any? = NULL\n    collect {\n        result = it\n    }\n    if (result === NULL) throw NoSuchElementException(\"Expected at least one element\")\n    return result as T\n}\n\n/**\n * The terminal operator that returns the last element emitted by the flow or `null` if the flow was empty.\n */\npublic suspend fun <T> Flow<T>.lastOrNull(): T? {\n    var result: T? = null\n    collect {\n        result = it\n    }\n    return result\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/Atomic.kt",
        "content": "@file:Suppress(\"NO_EXPLICIT_VISIBILITY_IN_API_MODE\")\n\npackage kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.atomic\nimport kotlinx.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * The most abstract operation that can be in process. Other threads observing an instance of this\n * class in the fields of their object shall invoke [perform] to help.\n *\n * @suppress **This is unstable API and it is subject to change.**\n */\npublic abstract class OpDescriptor {\n    /**\n     * Returns `null` is operation was performed successfully or some other\n     * object that indicates the failure reason.\n     */\n    abstract fun perform(affected: Any?): Any?\n\n    /**\n     * Returns reference to atomic operation that this descriptor is a part of or `null`\n     * if not a part of any [AtomicOp].\n     */\n    abstract val atomicOp: AtomicOp<*>?\n\n    override fun toString(): String = \"$classSimpleName@$hexAddress\" // debug\n}\n\n@JvmField\ninternal val NO_DECISION: Any = Symbol(\"NO_DECISION\")\n\n/**\n * Descriptor for multi-word atomic operation.\n * Based on paper\n * [\"A Practical Multi-Word Compare-and-Swap Operation\"](https://www.cl.cam.ac.uk/research/srg/netos/papers/2002-casn.pdf)\n * by Timothy L. Harris, Keir Fraser and Ian A. Pratt.\n *\n * Note: parts of atomic operation must be globally ordered. Otherwise, this implementation will produce\n * `StackOverflowError`.\n *\n * @suppress **This is unstable API and it is subject to change.**\n */\n@InternalCoroutinesApi\npublic abstract class AtomicOp<in T> : OpDescriptor() {\n    private val _consensus = atomic<Any?>(NO_DECISION)\n\n    override val atomicOp: AtomicOp<*> get() = this\n\n    private fun decide(decision: Any?): Any? {\n        assert { decision !== NO_DECISION }\n        val current = _consensus.value\n        if (current !== NO_DECISION) return current\n        if (_consensus.compareAndSet(NO_DECISION, decision)) return decision\n        return _consensus.value\n    }\n\n    abstract fun prepare(affected: T): Any? // `null` if Ok, or failure reason\n\n    abstract fun complete(affected: T, failure: Any?) // failure != null if failed to prepare op\n\n    // returns `null` on success\n    @Suppress(\"UNCHECKED_CAST\")\n    final override fun perform(affected: Any?): Any? {\n        // make decision on status\n        var decision = this._consensus.value\n        if (decision === NO_DECISION) {\n            decision = decide(prepare(affected as T))\n        }\n        // complete operation\n        complete(affected as T, decision)\n        return decision\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/Concurrent.common.kt",
        "content": "package kotlinx.coroutines.internal\n\ninternal expect class ReentrantLock() {\n    fun tryLock(): Boolean\n    fun unlock()\n}\n\ninternal expect inline fun <T> ReentrantLock.withLock(action: () -> T): T\n\ninternal expect fun <E> identitySet(expectedSize: Int): MutableSet<E>\n\n/**\n * Annotation indicating that the marked property is the subject of benign data race.\n * LLVM does not support this notion, so on K/N platforms we alias it into `@Volatile` to prevent potential OoTA.\n *\n * The purpose of this annotation is not to save an extra-volatile on JVM platform, but rather to explicitly emphasize\n * that data-race is benign.\n */\n@OptionalExpectation\n@Target(AnnotationTarget.FIELD)\ninternal expect annotation class BenignDataRace()\n\n// Used **only** as a workaround for #3820 in StateFlow. Do not use anywhere else\ninternal expect class WorkaroundAtomicReference<T>(value: T) {\n    public fun get(): T\n    public fun set(value: T)\n    public fun getAndSet(value: T): T\n    public fun compareAndSet(expected: T, value: T): Boolean\n}\n\n@Suppress(\"UNUSED_PARAMETER\", \"EXTENSION_SHADOWED_BY_MEMBER\")\ninternal var <T> WorkaroundAtomicReference<T>.value: T\n    get() = this.get()\n    set(value) = this.set(value)\n\ninternal inline fun <T> WorkaroundAtomicReference<T>.loop(action: WorkaroundAtomicReference<T>.(value: T) -> Unit) {\n    while (true) {\n        action(value)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/ConcurrentLinkedList.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * Returns the first segment `s` with `s.id >= id` or `CLOSED`\n * if all the segments in this linked list have lower `id`, and the list is closed for further segment additions.\n */\ninternal fun <S : Segment<S>> S.findSegmentInternal(\n    id: Long,\n    createNewSegment: (id: Long, prev: S) -> S\n): SegmentOrClosed<S> {\n    /*\n       Go through `next` references and add new segments if needed, similarly to the `push` in the Michael-Scott\n       queue algorithm. The only difference is that \"CAS failure\" means that the required segment has already been\n       added, so the algorithm just uses it. This way, only one segment with each id can be added.\n     */\n    var cur: S = this\n    while (cur.id < id || cur.isRemoved) {\n        val next = cur.nextOrIfClosed { return SegmentOrClosed(CLOSED) }\n        if (next != null) { // there is a next node -- move there\n            cur = next\n            continue\n        }\n        val newTail = createNewSegment(cur.id + 1, cur)\n        if (cur.trySetNext(newTail)) { // successfully added new node -- move there\n            if (cur.isRemoved) cur.remove()\n            cur = newTail\n        }\n    }\n    return SegmentOrClosed(cur)\n}\n\n/**\n * Returns `false` if the segment `to` is logically removed, `true` on a successful update.\n */\n@Suppress(\"NOTHING_TO_INLINE\", \"RedundantNullableReturnType\") // Must be inline because it is an AtomicRef extension\ninternal inline fun <S : Segment<S>> AtomicRef<S>.moveForward(to: S): Boolean = loop { cur ->\n    if (cur.id >= to.id) return true\n    if (!to.tryIncPointers()) return false\n    if (compareAndSet(cur, to)) { // the segment is moved\n        if (cur.decPointers()) cur.remove()\n        return true\n    }\n    if (to.decPointers()) to.remove() // undo tryIncPointers\n}\n\n/**\n * Tries to find a segment with the specified [id] following by next references from the\n * [startFrom] segment and creating new ones if needed. The typical use-case is reading this `AtomicRef` values,\n * doing some synchronization, and invoking this function to find the required segment and update the pointer.\n * At the same time, [Segment.cleanPrev] should also be invoked if the previous segments are no longer needed\n * (e.g., queues should use it in dequeue operations).\n *\n * Since segments can be removed from the list, or it can be closed for further segment additions.\n * Returns the segment `s` with `s.id >= id` or `CLOSED` if all the segments in this linked list have lower `id`,\n * and the list is closed.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun <S : Segment<S>> AtomicRef<S>.findSegmentAndMoveForward(\n    id: Long,\n    startFrom: S,\n    noinline createNewSegment: (id: Long, prev: S) -> S\n): SegmentOrClosed<S> {\n    while (true) {\n        val s = startFrom.findSegmentInternal(id, createNewSegment)\n        if (s.isClosed || moveForward(s.segment)) return s\n    }\n}\n\n/**\n * Closes this linked list of nodes by forbidding adding new ones,\n * returns the last node in the list.\n */\ninternal fun <N : ConcurrentLinkedListNode<N>> N.close(): N {\n    var cur: N = this\n    while (true) {\n        val next = cur.nextOrIfClosed { return cur }\n        if (next === null) {\n            if (cur.markAsClosed()) return cur\n        } else {\n            cur = next\n        }\n    }\n}\n\ninternal abstract class ConcurrentLinkedListNode<N : ConcurrentLinkedListNode<N>>(prev: N?) {\n    // Pointer to the next node, updates similarly to the Michael-Scott queue algorithm.\n    private val _next = atomic<Any?>(null)\n    // Pointer to the previous node, updates in [remove] function.\n    private val _prev = atomic(prev)\n\n    private val nextOrClosed get() = _next.value\n\n    /**\n     * Returns the next segment or `null` of the one does not exist,\n     * and invokes [onClosedAction] if this segment is marked as closed.\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    inline fun nextOrIfClosed(onClosedAction: () -> Nothing): N? = nextOrClosed.let {\n        if (it === CLOSED) {\n            onClosedAction()\n        } else {\n            it as N?\n        }\n    }\n\n    val next: N? get() = nextOrIfClosed { return null }\n\n    /**\n     * Tries to set the next segment if it is not specified and this segment is not marked as closed.\n     */\n    fun trySetNext(value: N): Boolean = _next.compareAndSet(null, value)\n\n    /**\n     * Checks whether this node is the physical tail of the current linked list.\n     */\n    val isTail: Boolean get() = next == null\n\n    val prev: N? get() = _prev.value\n\n    /**\n     * Cleans the pointer to the previous node.\n     */\n    fun cleanPrev() { _prev.lazySet(null) }\n\n    /**\n     * Tries to mark the linked list as closed by forbidding adding new nodes after this one.\n     */\n    fun markAsClosed() = _next.compareAndSet(null, CLOSED)\n\n    /**\n     * This property indicates whether the current node is logically removed.\n     * The expected use-case is removing the node logically (so that [isRemoved] becomes true),\n     * and invoking [remove] after that. Note that this implementation relies on the contract\n     * that the physical tail cannot be logically removed. Please, do not break this contract;\n     * otherwise, memory leaks and unexpected behavior can occur.\n     */\n    abstract val isRemoved: Boolean\n\n    /**\n     * Removes this node physically from this linked list. The node should be\n     * logically removed (so [isRemoved] returns `true`) at the point of invocation.\n     */\n    fun remove() {\n        assert { isRemoved || isTail } // The node should be logically removed at first.\n        // The physical tail cannot be removed. Instead, we remove it when\n        // a new segment is added and this segment is not the tail one anymore.\n        if (isTail) return\n        while (true) {\n            // Read `next` and `prev` pointers ignoring logically removed nodes.\n            val prev = aliveSegmentLeft\n            val next = aliveSegmentRight\n            // Link `next` and `prev`.\n            next._prev.update { if (it === null) null else prev }\n            if (prev !== null) prev._next.value = next\n            // Checks that prev and next are still alive.\n            if (next.isRemoved && !next.isTail) continue\n            if (prev !== null && prev.isRemoved) continue\n            // This node is removed.\n            return\n        }\n    }\n\n    private val aliveSegmentLeft: N? get() {\n        var cur = prev\n        while (cur !== null && cur.isRemoved)\n            cur = cur._prev.value\n        return cur\n    }\n\n    private val aliveSegmentRight: N get() {\n        assert { !isTail } // Should not be invoked on the tail node\n        var cur = next!!\n        while (cur.isRemoved)\n            cur = cur.next ?: return cur\n        return cur\n    }\n}\n\n/**\n * Each segment in the list has a unique id and is created by the provided to [findSegmentAndMoveForward] method.\n * Essentially, this is a node in the Michael-Scott queue algorithm,\n * but with maintaining [prev] pointer for efficient [remove] implementation.\n *\n * NB: this class cannot be public or leak into user's code as public type as [CancellableContinuationImpl]\n * instance-check it and uses a separate code-path for that.\n */\ninternal abstract class Segment<S : Segment<S>>(\n    @JvmField val id: Long, prev: S?, pointers: Int\n) : ConcurrentLinkedListNode<S>(prev),\n    // Segments typically store waiting continuations. Thus, on cancellation, the corresponding\n    // slot should be cleaned and the segment should be removed if it becomes full of cancelled cells.\n    // To install such a handler efficiently, without creating an extra object, we allow storing\n    // segments as cancellation handlers in [CancellableContinuationImpl] state, putting the slot\n    // index in another field. The details are here: https://github.com/Kotlin/kotlinx.coroutines/pull/3084.\n    // For that, we need segments to implement this internal marker interface.\n    NotCompleted\n{\n    /**\n     * This property should return the number of slots in this segment,\n     * it is used to define whether the segment is logically removed.\n     */\n    abstract val numberOfSlots: Int\n\n    /**\n     * Numbers of cleaned slots (the lowest bits) and AtomicRef pointers to this segment (the highest bits)\n     */\n    private val cleanedAndPointers = atomic(pointers shl POINTERS_SHIFT)\n\n    /**\n     * The segment is considered as removed if all the slots are cleaned\n     * and there are no pointers to this segment from outside.\n     */\n    override val isRemoved get() = cleanedAndPointers.value == numberOfSlots && !isTail\n\n    // increments the number of pointers if this segment is not logically removed.\n    internal fun tryIncPointers() = cleanedAndPointers.addConditionally(1 shl POINTERS_SHIFT) { it != numberOfSlots || isTail }\n\n    // returns `true` if this segment is logically removed after the decrement.\n    internal fun decPointers() = cleanedAndPointers.addAndGet(-(1 shl POINTERS_SHIFT)) == numberOfSlots && !isTail\n\n    /**\n     * This function is invoked on continuation cancellation when this segment\n     * with the specified [index] are installed as cancellation handler via\n     * `SegmentDisposable.disposeOnCancellation(Segment, Int)`.\n     *\n     * @param index the index under which the sement registered itself in the continuation.\n     *        Indicies are opaque and arithmetics or numeric intepretation is not allowed on them,\n     *        as they may encode additional metadata.\n     * @param cause the cause of the cancellation, with the same semantics as [CancellableContinuation.invokeOnCancellation]\n     * @param context the context of the cancellable continuation the segment was registered in\n     */\n    abstract fun onCancellation(index: Int, cause: Throwable?, context: CoroutineContext)\n\n    /**\n     * Invoked on each slot clean-up; should not be invoked twice for the same slot.\n     */\n    fun onSlotCleaned() {\n        if (cleanedAndPointers.incrementAndGet() == numberOfSlots) remove()\n    }\n}\n\nprivate inline fun AtomicInt.addConditionally(delta: Int, condition: (cur: Int) -> Boolean): Boolean {\n    while (true) {\n        val cur = this.value\n        if (!condition(cur)) return false\n        if (this.compareAndSet(cur, cur + delta)) return true\n    }\n}\n\n@JvmInline\ninternal value class SegmentOrClosed<S : Segment<S>>(private val value: Any?) {\n    val isClosed: Boolean get() = value === CLOSED\n    @Suppress(\"UNCHECKED_CAST\")\n    val segment: S get() = if (value === CLOSED) error(\"Does not contain segment\") else value as S\n}\n\nprivate const val POINTERS_SHIFT = 16\n\nprivate val CLOSED = Symbol(\"CLOSED\")\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/CoroutineExceptionHandlerImpl.common.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * The list of globally installed [CoroutineExceptionHandler] instances that will be notified of any exceptions that\n * were not processed in any other manner.\n */\ninternal expect val platformExceptionHandlers: Collection<CoroutineExceptionHandler>\n\n/**\n * Ensures that the given [callback] is present in the [platformExceptionHandlers] list.\n */\ninternal expect fun ensurePlatformExceptionHandlerLoaded(callback: CoroutineExceptionHandler)\n\n/**\n * The platform-dependent global exception handler, used so that the exception is logged at least *somewhere*.\n */\ninternal expect fun propagateExceptionFinalResort(exception: Throwable)\n\n/**\n * Deal with exceptions that happened in coroutines and weren't programmatically dealt with.\n *\n * First, it notifies every [CoroutineExceptionHandler] in the [platformExceptionHandlers] list.\n * If one of them throws [ExceptionSuccessfullyProcessed], it means that that handler believes that the exception was\n * dealt with sufficiently well and doesn't need any further processing.\n * Otherwise, the platform-dependent global exception handler is also invoked.\n */\ninternal fun handleUncaughtCoroutineException(context: CoroutineContext, exception: Throwable) {\n    // use additional extension handlers\n    for (handler in platformExceptionHandlers) {\n        try {\n            handler.handleException(context, exception)\n        } catch (_: ExceptionSuccessfullyProcessed) {\n            return\n        } catch (t: Throwable) {\n            propagateExceptionFinalResort(handlerException(exception, t))\n        }\n    }\n\n    try {\n        exception.addSuppressed(DiagnosticCoroutineContextException(context))\n    } catch (e: Throwable) {\n        // addSuppressed is never user-defined and cannot normally throw with the only exception being OOM\n        // we do ignore that just in case to definitely deliver the exception\n    }\n    propagateExceptionFinalResort(exception)\n}\n\n/**\n * Private exception that is added to suppressed exceptions of the original exception\n * when it is reported to the last-ditch current thread 'uncaughtExceptionHandler'.\n *\n * The purpose of this exception is to add an otherwise inaccessible diagnostic information and to\n * be able to poke the context of the failing coroutine in the debugger.\n */\ninternal expect class DiagnosticCoroutineContextException(context: CoroutineContext) : RuntimeException\n\n/**\n * A dummy exception that signifies that the exception was successfully processed by the handler and no further\n * action is required.\n *\n * Would be nicer if [CoroutineExceptionHandler] could return a boolean, but that would be a breaking change.\n * For now, we will take solace in knowledge that such exceptions are exceedingly rare, even rarer than globally\n * uncaught exceptions in general.\n */\ninternal object ExceptionSuccessfullyProcessed : Exception()\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\nprivate val UNDEFINED = Symbol(\"UNDEFINED\")\n@JvmField\ninternal val REUSABLE_CLAIMED = Symbol(\"REUSABLE_CLAIMED\")\n\n@PublishedApi\ninternal class DispatchedContinuation<in T>(\n    @JvmField internal val dispatcher: CoroutineDispatcher,\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @JvmField val continuation: Continuation<T>\n) : DispatchedTask<T>(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation<T> by continuation {\n    @JvmField\n    @Suppress(\"PropertyName\")\n    internal var _state: Any? = UNDEFINED\n    override val callerFrame: CoroutineStackFrame? get() = continuation as? CoroutineStackFrame\n    override fun getStackTraceElement(): StackTraceElement? = null\n    @JvmField // pre-cached value to avoid ctx.fold on every resumption\n    internal val countOrElement = threadContextElements(context)\n\n    /**\n     * Possible states of reusability:\n     *\n     * 1) `null`. Cancellable continuation wasn't yet attempted to be reused or\n     *     was used and then invalidated (e.g. because of the cancellation).\n     * 2) [CancellableContinuation]. Continuation to be/that is being reused.\n     * 3) [REUSABLE_CLAIMED]. CC is currently being reused and its owner executes `suspend` block:\n     *    ```\n     *    // state == null | CC\n     *    suspendCancellableCoroutineReusable { cont ->\n     *        // state == REUSABLE_CLAIMED\n     *        block(cont)\n     *    }\n     *    // state == CC\n     *    ```\n     * 4) [Throwable] continuation was cancelled with this cause while being in [suspendCancellableCoroutineReusable],\n     *    [CancellableContinuationImpl.getResult] will check for cancellation later.\n     *\n     * [REUSABLE_CLAIMED] state is required to prevent double-use of the reused continuation.\n     * In the `getResult`, we have the following code:\n     * ```\n     * if (trySuspend()) {\n     *     // <- at this moment current continuation can be redispatched and claimed again.\n     *     attachChildToParent()\n     *     releaseClaimedContinuation()\n     * }\n     * ```\n     */\n    private val _reusableCancellableContinuation = atomic<Any?>(null)\n\n    private val reusableCancellableContinuation: CancellableContinuationImpl<*>?\n        get() = _reusableCancellableContinuation.value as? CancellableContinuationImpl<*>\n\n    internal fun isReusable(): Boolean {\n        /*\n        Invariant: caller.resumeMode.isReusableMode\n         * Reusability control:\n         * `null` -> no reusability at all, `false`\n         * anything else -> reusable.\n         */\n        return _reusableCancellableContinuation.value != null\n    }\n\n    /**\n     * Awaits until previous call to `suspendCancellableCoroutineReusable` will\n     * stop mutating cached instance\n     */\n    internal fun awaitReusability() {\n        _reusableCancellableContinuation.loop {\n            if (it !== REUSABLE_CLAIMED) return\n        }\n    }\n\n    internal fun release() {\n        /*\n         * Called from `releaseInterceptedContinuation`, can be concurrent with\n         * the code in `getResult` right after `trySuspend` returned `true`, so we have\n         * to wait for a release here.\n         */\n        awaitReusability()\n        reusableCancellableContinuation?.detachChild()\n    }\n\n    /**\n     * Claims the continuation for [suspendCancellableCoroutineReusable] block,\n     * so all cancellations will be postponed.\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    internal fun claimReusableCancellableContinuation(): CancellableContinuationImpl<T>? {\n        /*\n         * Transitions:\n         * 1) `null` -> claimed, caller will instantiate CC instance\n         * 2) `CC` -> claimed, caller will reuse CC instance\n         */\n        _reusableCancellableContinuation.loop { state ->\n            when {\n                state === null -> {\n                    /*\n                     * null -> CC was not yet published -> we do not compete with cancel\n                     * -> can use plain store instead of CAS\n                     */\n                    _reusableCancellableContinuation.value = REUSABLE_CLAIMED\n                    return null\n                }\n                // potentially competing with cancel\n                state is CancellableContinuationImpl<*> -> {\n                    if (_reusableCancellableContinuation.compareAndSet(state, REUSABLE_CLAIMED)) {\n                        return state as CancellableContinuationImpl<T>\n                    }\n                }\n                state === REUSABLE_CLAIMED -> {\n                    // Do nothing, wait until reusable instance will be returned from\n                    // getResult() of a previous `suspendCancellableCoroutineReusable`\n                }\n                state is Throwable -> {\n                    // Also do nothing, Throwable can only indicate that the CC\n                    // is in REUSABLE_CLAIMED state, but with postponed cancellation\n                }\n                else -> error(\"Inconsistent state $state\")\n            }\n        }\n    }\n\n    /**\n     * Checks whether there were any attempts to cancel reusable CC while it was in [REUSABLE_CLAIMED] state\n     * and returns cancellation cause if so, `null` otherwise.\n     * If continuation was cancelled, it becomes non-reusable.\n     *\n     * ```\n     * suspendCancellableCoroutineReusable { // <- claimed\n     * // Any asynchronous cancellation is \"postponed\" while this block\n     * // is being executed\n     * } // postponed cancellation is checked here in `getResult`\n     * ```\n     *\n     * See [CancellableContinuationImpl.getResult].\n     */\n    internal fun tryReleaseClaimedContinuation(continuation: CancellableContinuation<*>): Throwable? {\n        _reusableCancellableContinuation.loop { state ->\n            // not when(state) to avoid Intrinsics.equals call\n            when {\n                state === REUSABLE_CLAIMED -> {\n                    if (_reusableCancellableContinuation.compareAndSet(REUSABLE_CLAIMED, continuation)) return null\n                }\n                state is Throwable -> {\n                    require(_reusableCancellableContinuation.compareAndSet(state, null))\n                    return state\n                }\n                else -> error(\"Inconsistent state $state\")\n            }\n        }\n    }\n\n    /**\n     * Tries to postpone cancellation if reusable CC is currently in [REUSABLE_CLAIMED] state.\n     * Returns `true` if cancellation is (or previously was) postponed, `false` otherwise.\n     */\n    internal fun postponeCancellation(cause: Throwable): Boolean {\n        _reusableCancellableContinuation.loop { state ->\n            when (state) {\n                REUSABLE_CLAIMED -> {\n                    if (_reusableCancellableContinuation.compareAndSet(REUSABLE_CLAIMED, cause))\n                        return true\n                }\n                is Throwable -> return true\n                else -> {\n                    // Invalidate\n                    if (_reusableCancellableContinuation.compareAndSet(state, null))\n                        return false\n                }\n            }\n        }\n    }\n\n    override fun takeState(): Any? {\n        val state = _state\n        assert { state !== UNDEFINED } // fail-fast if repeatedly invoked\n        _state = UNDEFINED\n        return state\n    }\n\n    override val delegate: Continuation<T>\n        get() = this\n\n    override fun resumeWith(result: Result<T>) {\n        val context = continuation.context\n        val state = result.toState()\n        if (dispatcher.isDispatchNeeded(context)) {\n            _state = state\n            resumeMode = MODE_ATOMIC\n            dispatcher.dispatch(context, this)\n        } else {\n            executeUnconfined(state, MODE_ATOMIC) {\n                withCoroutineContext(this.context, countOrElement) {\n                    continuation.resumeWith(result)\n                }\n            }\n        }\n    }\n\n    // We inline it to save an entry on the stack in cases where it shows (unconfined dispatcher)\n    // It is used only in Continuation<T>.resumeCancellableWith\n    @Suppress(\"NOTHING_TO_INLINE\")\n    internal inline fun resumeCancellableWith(\n        result: Result<T>,\n        noinline onCancellation: ((cause: Throwable) -> Unit)?\n    ) {\n        val state = result.toState(onCancellation)\n        if (dispatcher.isDispatchNeeded(context)) {\n            _state = state\n            resumeMode = MODE_CANCELLABLE\n            dispatcher.dispatch(context, this)\n        } else {\n            executeUnconfined(state, MODE_CANCELLABLE) {\n                if (!resumeCancelled(state)) {\n                    resumeUndispatchedWith(result)\n                }\n            }\n        }\n    }\n\n    // takeState had already cleared the state so we cancel takenState here\n    override fun cancelCompletedResult(takenState: Any?, cause: Throwable) {\n        // It is Ok to call onCancellation here without try/catch around it, since this function only faces\n        // a \"bound\" cancellation handler that performs the safe call to the user-specified code.\n        if (takenState is CompletedWithCancellation) {\n            takenState.onCancellation(cause)\n        }\n    }\n\n    // inline here is to save us an entry on the stack for the sake of better stacktraces\n    @Suppress(\"NOTHING_TO_INLINE\")\n    internal inline fun resumeCancelled(state: Any?): Boolean {\n        val job = context[Job]\n        if (job != null && !job.isActive) {\n            val cause = job.getCancellationException()\n            cancelCompletedResult(state, cause)\n            resumeWithException(cause)\n            return true\n        }\n        return false\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    internal inline fun resumeUndispatchedWith(result: Result<T>) {\n        withContinuationContext(continuation, countOrElement) {\n            continuation.resumeWith(result)\n        }\n    }\n\n    // used by \"yield\" implementation\n    internal fun dispatchYield(context: CoroutineContext, value: T) {\n        _state = value\n        resumeMode = MODE_CANCELLABLE\n        dispatcher.dispatchYield(context, this)\n    }\n\n    override fun toString(): String =\n        \"DispatchedContinuation[$dispatcher, ${continuation.toDebugString()}]\"\n}\n\n/**\n * It is not inline to save bytecode (it is pretty big and used in many places)\n * and we leave it public so that its name is not mangled in use stack traces if it shows there.\n * It may appear in stack traces when coroutines are started/resumed with unconfined dispatcher.\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic fun <T> Continuation<T>.resumeCancellableWith(\n    result: Result<T>,\n    onCancellation: ((cause: Throwable) -> Unit)? = null\n): Unit = when (this) {\n    is DispatchedContinuation -> resumeCancellableWith(result, onCancellation)\n    else -> resumeWith(result)\n}\n\ninternal fun DispatchedContinuation<Unit>.yieldUndispatched(): Boolean =\n    executeUnconfined(Unit, MODE_CANCELLABLE, doYield = true) {\n        run()\n    }\n\n/**\n * Executes given [block] as part of current event loop, updating current continuation\n * mode and state if continuation is not resumed immediately.\n * [doYield] indicates whether current continuation is yielding (to provide fast-path if event-loop is empty).\n * Returns `true` if execution of continuation was queued (trampolined) or `false` otherwise.\n */\nprivate inline fun DispatchedContinuation<*>.executeUnconfined(\n    contState: Any?, mode: Int, doYield: Boolean = false,\n    block: () -> Unit\n): Boolean {\n    assert { mode != MODE_UNINITIALIZED } // invalid execution mode\n    val eventLoop = ThreadLocalEventLoop.eventLoop\n    // If we are yielding and unconfined queue is empty, we can bail out as part of fast path\n    if (doYield && eventLoop.isUnconfinedQueueEmpty) return false\n    return if (eventLoop.isUnconfinedLoopActive) {\n        // When unconfined loop is active -- dispatch continuation for execution to avoid stack overflow\n        _state = contState\n        resumeMode = mode\n        eventLoop.dispatchUnconfined(this)\n        true // queued into the active loop\n    } else {\n        // Was not active -- run event loop until all unconfined tasks are executed\n        runUnconfinedEventLoop(eventLoop, block = block)\n        false\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/DispatchedTask.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * Non-cancellable dispatch mode.\n *\n * **DO NOT CHANGE THE CONSTANT VALUE**. It might be inlined into legacy user code that was calling\n * inline `suspendAtomicCancellableCoroutine` function and did not support reuse.\n */\ninternal const val MODE_ATOMIC = 0\n\n/**\n * Cancellable dispatch mode. It is used by user-facing [suspendCancellableCoroutine].\n * Note, that implementation of cancellability checks mode via [Int.isCancellableMode] extension.\n *\n * **DO NOT CHANGE THE CONSTANT VALUE**. It is being into the user code from [suspendCancellableCoroutine].\n */\n@PublishedApi\ninternal const val MODE_CANCELLABLE: Int = 1\n\n/**\n * Cancellable dispatch mode for [suspendCancellableCoroutineReusable].\n * Note, that implementation of cancellability checks mode via [Int.isCancellableMode] extension;\n * implementation of reuse checks mode via [Int.isReusableMode] extension.\n */\ninternal const val MODE_CANCELLABLE_REUSABLE = 2\n\n/**\n * Undispatched mode for [CancellableContinuation.resumeUndispatched].\n * It is used when the thread is right, but it needs to be marked with the current coroutine.\n */\ninternal const val MODE_UNDISPATCHED = 4\n\n/**\n * Initial mode for [DispatchedContinuation] implementation, should never be used for dispatch, because it is always\n * overwritten when continuation is resumed with the actual resume mode.\n */\ninternal const val MODE_UNINITIALIZED = -1\n\ninternal val Int.isCancellableMode get() = this == MODE_CANCELLABLE || this == MODE_CANCELLABLE_REUSABLE\ninternal val Int.isReusableMode get() = this == MODE_CANCELLABLE_REUSABLE\n\n@PublishedApi\ninternal abstract class DispatchedTask<in T> internal constructor(\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @JvmField public var resumeMode: Int\n) : SchedulerTask() {\n    internal abstract val delegate: Continuation<T>\n\n    internal abstract fun takeState(): Any?\n\n    /**\n     * Called when this task was cancelled while it was being dispatched.\n     */\n    internal open fun cancelCompletedResult(takenState: Any?, cause: Throwable) {}\n\n    /**\n     * There are two implementations of `DispatchedTask`:\n     * - [DispatchedContinuation] keeps only simple values as successfully results.\n     * - [CancellableContinuationImpl] keeps additional data with values and overrides this method to unwrap it.\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    internal open fun <T> getSuccessfulResult(state: Any?): T =\n        state as T\n\n    /**\n     * There are two implementations of `DispatchedTask`:\n     * - [DispatchedContinuation] is just an intermediate storage that stores the exception that has its stack-trace\n     *   properly recovered and is ready to pass to the [delegate] continuation directly.\n     * - [CancellableContinuationImpl] stores raw cause of the failure in its state; when it needs to be dispatched\n     *   its stack-trace has to be recovered, so it overrides this method for that purpose.\n     */\n    internal open fun getExceptionalResult(state: Any?): Throwable? =\n        (state as? CompletedExceptionally)?.cause\n\n    final override fun run() {\n        assert { resumeMode != MODE_UNINITIALIZED } // should have been set before dispatching\n        val taskContext = this.taskContext\n        var fatalException: Throwable? = null\n        try {\n            val delegate = delegate as DispatchedContinuation<T>\n            val continuation = delegate.continuation\n            withContinuationContext(continuation, delegate.countOrElement) {\n                val context = continuation.context\n                val state = takeState() // NOTE: Must take state in any case, even if cancelled\n                val exception = getExceptionalResult(state)\n                /*\n                 * Check whether continuation was originally resumed with an exception.\n                 * If so, it dominates cancellation, otherwise the original exception\n                 * will be silently lost.\n                 */\n                val job = if (exception == null && resumeMode.isCancellableMode) context[Job] else null\n                if (job != null && !job.isActive) {\n                    val cause = job.getCancellationException()\n                    cancelCompletedResult(state, cause)\n                    continuation.resumeWithStackTrace(cause)\n                } else {\n                    if (exception != null) {\n                        continuation.resumeWithException(exception)\n                    } else {\n                        continuation.resume(getSuccessfulResult(state))\n                    }\n                }\n            }\n        } catch (e: Throwable) {\n            // This instead of runCatching to have nicer stacktrace and debug experience\n            fatalException = e\n        } finally {\n            val result = runCatching { taskContext.afterTask() }\n            handleFatalException(fatalException, result.exceptionOrNull())\n        }\n    }\n\n    /**\n     * Machinery that handles fatal exceptions in kotlinx.coroutines.\n     * There are two kinds of fatal exceptions:\n     *\n     * 1) Exceptions from kotlinx.coroutines code. Such exceptions indicate that either\n     *    the library or the compiler has a bug that breaks internal invariants.\n     *    They usually have specific workarounds, but require careful study of the cause and should\n     *    be reported to the maintainers and fixed on the library's side anyway.\n     *\n     * 2) Exceptions from [ThreadContextElement.updateThreadContext] and [ThreadContextElement.restoreThreadContext].\n     *    While a user code can trigger such exception by providing an improper implementation of [ThreadContextElement],\n     *    we can't ignore it because it may leave coroutine in the inconsistent state.\n     *    If you encounter such exception, you can either disable this context element or wrap it into\n     *    another context element that catches all exceptions and handles it in the application specific manner.\n     *\n     * Fatal exception handling can be intercepted with [CoroutineExceptionHandler] element in the context of\n     * a failed coroutine, but such exceptions should be reported anyway.\n     */\n    internal fun handleFatalException(exception: Throwable?, finallyException: Throwable?) {\n        if (exception === null && finallyException === null) return\n        if (exception !== null && finallyException !== null) {\n            exception.addSuppressed(finallyException)\n        }\n\n        val cause = exception ?: finallyException\n        val reason = CoroutinesInternalError(\"Fatal exception in coroutines machinery for $this. \" +\n                \"Please read KDoc to 'handleFatalException' method and report this incident to maintainers\", cause!!)\n        handleCoroutineException(this.delegate.context, reason)\n    }\n}\n\ninternal fun <T> DispatchedTask<T>.dispatch(mode: Int) {\n    assert { mode != MODE_UNINITIALIZED } // invalid mode value for this method\n    val delegate = this.delegate\n    val undispatched = mode == MODE_UNDISPATCHED\n    if (!undispatched && delegate is DispatchedContinuation<*> && mode.isCancellableMode == resumeMode.isCancellableMode) {\n        // dispatch directly using this instance's Runnable implementation\n        val dispatcher = delegate.dispatcher\n        val context = delegate.context\n        if (dispatcher.isDispatchNeeded(context)) {\n            dispatcher.dispatch(context, this)\n        } else {\n            resumeUnconfined()\n        }\n    } else {\n        // delegate is coming from 3rd-party interceptor implementation (and does not support cancellation)\n        // or undispatched mode was requested\n        resume(delegate, undispatched)\n    }\n}\n\ninternal fun <T> DispatchedTask<T>.resume(delegate: Continuation<T>, undispatched: Boolean) {\n    // This resume is never cancellable. The result is always delivered to delegate continuation.\n    val state = takeState()\n    val exception = getExceptionalResult(state)\n    val result = if (exception != null) Result.failure(exception) else Result.success(getSuccessfulResult<T>(state))\n    when {\n        undispatched -> (delegate as DispatchedContinuation).resumeUndispatchedWith(result)\n        else -> delegate.resumeWith(result)\n    }\n}\n\nprivate fun DispatchedTask<*>.resumeUnconfined() {\n    val eventLoop = ThreadLocalEventLoop.eventLoop\n    if (eventLoop.isUnconfinedLoopActive) {\n        // When unconfined loop is active -- dispatch continuation for execution to avoid stack overflow\n        eventLoop.dispatchUnconfined(this)\n    } else {\n        // Was not active -- run event loop until all unconfined tasks are executed\n        runUnconfinedEventLoop(eventLoop) {\n            resume(delegate, undispatched = true)\n        }\n    }\n}\n\ninternal inline fun DispatchedTask<*>.runUnconfinedEventLoop(\n    eventLoop: EventLoop,\n    block: () -> Unit\n) {\n    eventLoop.incrementUseCount(unconfined = true)\n    try {\n        block()\n        while (true) {\n            // break when all unconfined continuations where executed\n            if (!eventLoop.processUnconfinedEvent()) break\n        }\n    } catch (e: Throwable) {\n        /*\n         * This exception doesn't happen normally, only if we have a bug in implementation.\n         * Report it as a fatal exception.\n         */\n        handleFatalException(e, null)\n    } finally {\n        eventLoop.decrementUseCount(unconfined = true)\n    }\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Continuation<*>.resumeWithStackTrace(exception: Throwable) {\n    resumeWith(Result.failure(recoverStackTrace(exception, this)))\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/InlineList.kt",
        "content": "@file:Suppress(\"UNCHECKED_CAST\")\n\npackage kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.assert\nimport kotlin.jvm.*\n\n/*\n * Inline class that represents a mutable list, but does not allocate an underlying storage\n * for zero and one elements.\n * Cannot be parametrized with `List<*>`.\n */\n@JvmInline\ninternal value class InlineList<E>(private val holder: Any? = null) {\n    operator fun plus(element: E): InlineList<E>  {\n        assert { element !is List<*> } // Lists are prohibited\n        return when (holder) {\n            null -> InlineList(element)\n            is ArrayList<*> -> {\n                (holder as ArrayList<E>).add(element)\n                InlineList(holder)\n            }\n            else -> {\n                val list = ArrayList<E>(4)\n                list.add(holder as E)\n                list.add(element)\n                InlineList(list)\n            }\n        }\n    }\n\n    inline fun forEachReversed(action: (E) -> Unit) {\n        when (holder) {\n            null -> return\n            !is ArrayList<*> -> action(holder as E)\n            else -> {\n                val list = holder as ArrayList<E>\n                for (i in (list.size - 1) downTo 0) {\n                    action(list[i])\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/InternalAnnotations.common.kt",
        "content": "package kotlinx.coroutines.internal\n\n// Ignore JRE requirements for animal-sniffer, compileOnly dependency\n@Target(\n    AnnotationTarget.FUNCTION,\n    AnnotationTarget.PROPERTY_GETTER,\n    AnnotationTarget.PROPERTY_SETTER,\n    AnnotationTarget.CONSTRUCTOR,\n    AnnotationTarget.CLASS,\n    AnnotationTarget.FILE\n)\n@OptionalExpectation\ninternal expect annotation class IgnoreJreRequirement()\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/LimitedDispatcher.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * The result of .limitedParallelism(x) call, a dispatcher\n * that wraps the given dispatcher, but limits the parallelism level, while\n * trying to emulate fairness.\n *\n * ### Implementation details\n *\n * By design, 'LimitedDispatcher' never [dispatches][CoroutineDispatcher.dispatch] originally sent tasks\n * to the underlying dispatcher. Instead, it maintains its own queue of tasks sent to this dispatcher and\n * dispatches at most [parallelism] \"worker-loop\" tasks that poll the underlying queue and cooperatively preempt\n * in order to avoid starvation of the underlying dispatcher.\n *\n * Such behavior is crucial to be compatible with any underlying dispatcher implementation without\n * direct cooperation.\n */\ninternal class LimitedDispatcher(\n    private val dispatcher: CoroutineDispatcher,\n    private val parallelism: Int\n) : CoroutineDispatcher(), Delay by (dispatcher as? Delay ?: DefaultDelay) {\n\n    // Atomic is necessary here for the sake of K/N memory ordering,\n    // there is no need in atomic operations for this property\n    private val runningWorkers = atomic(0)\n\n    private val queue = LockFreeTaskQueue<Runnable>(singleConsumer = false)\n\n    // A separate object that we can synchronize on for K/N\n    private val workerAllocationLock = SynchronizedObject()\n\n    @ExperimentalCoroutinesApi\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        parallelism.checkParallelism()\n        if (parallelism >= this.parallelism) return this\n        return super.limitedParallelism(parallelism)\n    }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        dispatchInternal(block) { worker ->\n            dispatcher.dispatch(this, worker)\n        }\n    }\n\n    @InternalCoroutinesApi\n    override fun dispatchYield(context: CoroutineContext, block: Runnable) {\n        dispatchInternal(block) { worker ->\n            dispatcher.dispatchYield(this, worker)\n        }\n    }\n\n    /**\n     * Tries to dispatch the given [block].\n     * If there are not enough workers, it starts a new one via [startWorker].\n     */\n    private inline fun dispatchInternal(block: Runnable, startWorker: (Worker) -> Unit) {\n        // Add task to queue so running workers will be able to see that\n        queue.addLast(block)\n        if (runningWorkers.value >= parallelism) return\n        // allocation may fail if some workers were launched in parallel or a worker temporarily decreased\n        // `runningWorkers` when they observed an empty queue.\n        if (!tryAllocateWorker()) return\n        val task = obtainTaskOrDeallocateWorker() ?: return\n        startWorker(Worker(task))\n    }\n\n    /**\n     * Tries to obtain the permit to start a new worker.\n     */\n    private fun tryAllocateWorker(): Boolean {\n        synchronized(workerAllocationLock) {\n            if (runningWorkers.value >= parallelism) return false\n            runningWorkers.incrementAndGet()\n            return true\n        }\n    }\n\n    /**\n     * Obtains the next task from the queue, or logically deallocates the worker if the queue is empty.\n     */\n    private fun obtainTaskOrDeallocateWorker(): Runnable? {\n        while (true) {\n            when (val nextTask = queue.removeFirstOrNull()) {\n                null -> synchronized(workerAllocationLock) {\n                    runningWorkers.decrementAndGet()\n                    if (queue.size == 0) return null\n                    runningWorkers.incrementAndGet()\n                }\n                else -> return nextTask\n            }\n        }\n    }\n\n    /**\n     * A worker that polls the queue and runs tasks until there are no more of them.\n     *\n     * It always stores the next task to run. This is done in order to prevent the possibility of the fairness\n     * re-dispatch happening when there are no more tasks in the queue. This is important because, after all the\n     * actual tasks are done, nothing prevents the user from closing the dispatcher and making it incorrect to\n     * perform any more dispatches.\n     */\n    private inner class Worker(private var currentTask: Runnable) : Runnable {\n        override fun run() {\n            var fairnessCounter = 0\n            while (true) {\n                try {\n                    currentTask.run()\n                } catch (e: Throwable) {\n                    handleCoroutineException(EmptyCoroutineContext, e)\n                }\n                currentTask = obtainTaskOrDeallocateWorker() ?: return\n                // 16 is our out-of-thin-air constant to emulate fairness. Used in JS dispatchers as well\n                if (++fairnessCounter >= 16 && dispatcher.isDispatchNeeded(this@LimitedDispatcher)) {\n                    // Do \"yield\" to let other views execute their runnable as well\n                    // Note that we do not decrement 'runningWorkers' as we are still committed to our part of work\n                    dispatcher.dispatch(this@LimitedDispatcher, this)\n                    return\n                }\n            }\n        }\n    }\n}\n\n// Save a few bytecode ops\ninternal fun Int.checkParallelism() = require(this >= 1) { \"Expected positive parallelism level, but got $this\" }\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/LocalAtomics.common.kt",
        "content": "package kotlinx.coroutines.internal\n\n/*\n * These are atomics that are used as local variables\n * where atomicfu doesn't support its tranformations.\n *\n * Have `Local` prefix to avoid AFU clashes during star-imports\n */\ninternal expect class LocalAtomicInt(value: Int) {\n    fun get(): Int\n    fun set(value: Int)\n    fun decrementAndGet(): Int\n}\n\ninternal inline var LocalAtomicInt.value\n    get() = get()\n    set(value) = set(value)\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/LockFreeLinkedList.common.kt",
        "content": "@file:Suppress(\"NO_EXPLICIT_VISIBILITY_IN_API_MODE\")\n\npackage kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport kotlin.jvm.*\n\n/** @suppress **This is unstable API and it is subject to change.** */\npublic expect open class LockFreeLinkedListNode() {\n    public val isRemoved: Boolean\n    public val nextNode: LockFreeLinkedListNode\n    public val prevNode: LockFreeLinkedListNode\n    public fun addLast(node: LockFreeLinkedListNode)\n    public fun addOneIfEmpty(node: LockFreeLinkedListNode): Boolean\n    public inline fun addLastIf(node: LockFreeLinkedListNode, crossinline condition: () -> Boolean): Boolean\n    public open fun remove(): Boolean\n\n}\n\n/** @suppress **This is unstable API and it is subject to change.** */\npublic expect open class LockFreeLinkedListHead() : LockFreeLinkedListNode {\n    public val isEmpty: Boolean\n    public inline fun <reified T : LockFreeLinkedListNode> forEach(block: (T) -> Unit)\n    public final override fun remove(): Nothing\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/LockFreeTaskQueue.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.jvm.*\n\nprivate typealias Core<E> = LockFreeTaskQueueCore<E>\n\n/**\n * Lock-free Multiply-Producer xxx-Consumer Queue for task scheduling purposes.\n *\n * **Note 1: This queue is NOT linearizable. It provides only quiescent consistency for its operations.**\n * However, this guarantee is strong enough for task-scheduling purposes.\n * In particular, the following execution is permitted for this queue, but is not permitted for a linearizable queue:\n *\n * ```\n * Thread 1: addLast(1) = true, removeFirstOrNull() = null\n * Thread 2: addLast(2) = 2 // this operation is concurrent with both operations in the first thread\n * ```\n *\n * **Note 2: When this queue is used with multiple consumers (`singleConsumer == false`) this it is NOT lock-free.**\n * In particular, consumer spins until producer finishes its operation in the case of near-empty queue.\n * It is a very short window that could manifest itself rarely and only under specific load conditions,\n * but it still deprives this algorithm of its lock-freedom.\n */\ninternal open class LockFreeTaskQueue<E : Any>(\n    singleConsumer: Boolean // true when there is only a single consumer (slightly faster & lock-free)\n) {\n    private val _cur = atomic(Core<E>(Core.INITIAL_CAPACITY, singleConsumer))\n\n    // Note: it is not atomic w.r.t. remove operation (remove can transiently fail when isEmpty is false)\n    val isEmpty: Boolean get() = _cur.value.isEmpty\n    val size: Int get() = _cur.value.size\n\n    fun close() {\n        _cur.loop { cur ->\n            if (cur.close()) return // closed this copy\n            _cur.compareAndSet(cur, cur.next()) // move to next\n        }\n    }\n\n    fun addLast(element: E): Boolean {\n        _cur.loop { cur ->\n            when (cur.addLast(element)) {\n                Core.ADD_SUCCESS -> return true\n                Core.ADD_CLOSED -> return false\n                Core.ADD_FROZEN -> _cur.compareAndSet(cur, cur.next()) // move to next\n            }\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun removeFirstOrNull(): E? {\n        _cur.loop { cur ->\n            val result = cur.removeFirstOrNull()\n            if (result !== Core.REMOVE_FROZEN) return result as E?\n            _cur.compareAndSet(cur, cur.next())\n        }\n    }\n\n    // Used for validation in tests only\n    fun <R> map(transform: (E) -> R): List<R> = _cur.value.map(transform)\n\n    // Used for validation in tests only\n    fun isClosed(): Boolean = _cur.value.isClosed()\n}\n\n/**\n * Lock-free Multiply-Producer xxx-Consumer Queue core.\n * @see LockFreeTaskQueue\n */\ninternal class LockFreeTaskQueueCore<E : Any>(\n    private val capacity: Int,\n    private val singleConsumer: Boolean // true when there is only a single consumer (slightly faster)\n) {\n    private val mask = capacity - 1\n    private val _next = atomic<Core<E>?>(null)\n    private val _state = atomic(0L)\n    private val array = atomicArrayOfNulls<Any?>(capacity)\n\n    init {\n        check(mask <= MAX_CAPACITY_MASK)\n        check(capacity and mask == 0)\n    }\n\n    // Note: it is not atomic w.r.t. remove operation (remove can transiently fail when isEmpty is false)\n    val isEmpty: Boolean get() = _state.value.withState { head, tail -> head == tail }\n    val size: Int get() = _state.value.withState { head, tail -> (tail - head) and MAX_CAPACITY_MASK }\n\n    fun close(): Boolean {\n        _state.update { state ->\n            if (state and CLOSED_MASK != 0L) return true // ok - already closed\n            if (state and FROZEN_MASK != 0L) return false // frozen -- try next\n            state or CLOSED_MASK // try set closed bit\n        }\n        return true\n    }\n\n    // ADD_CLOSED | ADD_FROZEN | ADD_SUCCESS\n    fun addLast(element: E): Int {\n        _state.loop { state ->\n            if (state and (FROZEN_MASK or CLOSED_MASK) != 0L) return state.addFailReason() // cannot add\n            state.withState { head, tail ->\n                val mask = this.mask // manually move instance field to local for performance\n                // If queue is Single-Consumer then there could be one element beyond head that we cannot overwrite,\n                // so we check for full queue with an extra margin of one element\n                if ((tail + 2) and mask == head and mask) return ADD_FROZEN // overfull, so do freeze & copy\n                // If queue is Multi-Consumer then the consumer could still have not cleared element\n                // despite the above check for one free slot.\n                if (!singleConsumer && array[tail and mask].value != null) {\n                    // There are two options in this situation\n                    // 1. Spin-wait until consumer clears the slot\n                    // 2. Freeze & resize to avoid spinning\n                    // We use heuristic here to avoid memory-overallocation\n                    // Freeze & reallocate when queue is small or more than half of the queue is used\n                    if (capacity < MIN_ADD_SPIN_CAPACITY || (tail - head) and MAX_CAPACITY_MASK > capacity shr 1) {\n                        return ADD_FROZEN\n                    }\n                    // otherwise spin\n                    return@loop\n                }\n                val newTail = (tail + 1) and MAX_CAPACITY_MASK\n                if (_state.compareAndSet(state, state.updateTail(newTail))) {\n                    // successfully added\n                    array[tail and mask].value = element\n                    // could have been frozen & copied before this item was set -- correct it by filling placeholder\n                    var cur = this\n                    while(true) {\n                        if (cur._state.value and FROZEN_MASK == 0L) break // all fine -- not frozen yet\n                        cur = cur.next().fillPlaceholder(tail, element) ?: break\n                    }\n                    return ADD_SUCCESS // added successfully\n                }\n            }\n        }\n    }\n\n    private fun fillPlaceholder(index: Int, element: E): Core<E>? {\n        val old = array[index and mask].value\n        /*\n         * addLast actions:\n         * 1) Commit tail slot\n         * 2) Write element to array slot\n         * 3) Check for array copy\n         *\n         * If copy happened between 2 and 3 then the consumer might have consumed our element,\n         * then another producer might have written its placeholder in our slot, so we should\n         * perform *unique* check that current placeholder is our to avoid overwriting another producer placeholder\n         */\n        if (old is Placeholder && old.index == index) {\n            array[index and mask].value = element\n            // we've corrected missing element, should check if that propagated to further copies, just in case\n            return this\n        }\n        // it is Ok, no need for further action\n        return null\n    }\n\n    // REMOVE_FROZEN | null (EMPTY) | E (SUCCESS)\n    fun removeFirstOrNull(): Any? {\n        _state.loop { state ->\n            if (state and FROZEN_MASK != 0L) return REMOVE_FROZEN // frozen -- cannot modify\n            state.withState { head, tail ->\n                if ((tail and mask) == (head and mask)) return null // empty\n                val element = array[head and mask].value\n                if (element == null) {\n                    // If queue is Single-Consumer, then element == null only when add has not finished yet\n                    if (singleConsumer) return null // consider it not added yet\n                    // retry (spin) until consumer adds it\n                    return@loop\n                }\n                // element == Placeholder can only be when add has not finished yet\n                if (element is Placeholder) return null // consider it not added yet\n                // we cannot put null into array here, because copying thread could replace it with Placeholder and that is a disaster\n                val newHead = (head + 1) and MAX_CAPACITY_MASK\n                if (_state.compareAndSet(state, state.updateHead(newHead))) {\n                    // Array could have been copied by another thread and it is perfectly fine, since only elements\n                    // between head and tail were copied and there are no extra steps we should take here\n                    array[head and mask].value = null // now can safely put null (state was updated)\n                    return element // successfully removed in fast-path\n                }\n                // Multi-Consumer queue must retry this loop on CAS failure (another consumer might have removed element)\n                if (!singleConsumer) return@loop\n                // Single-consumer queue goes to slow-path for remove in case of interference\n                var cur = this\n                while (true) {\n                    @Suppress(\"UNUSED_VALUE\")\n                    cur = cur.removeSlowPath(head, newHead) ?: return element\n                }\n            }\n        }\n    }\n\n    private fun removeSlowPath(oldHead: Int, newHead: Int): Core<E>? {\n        _state.loop { state ->\n            state.withState { head, _ ->\n                assert { head == oldHead } // \"This queue can have only one consumer\"\n                if (state and FROZEN_MASK != 0L) {\n                    // state was already frozen, so removed element was copied to next\n                    return next() // continue to correct head in next\n                }\n                if (_state.compareAndSet(state, state.updateHead(newHead))) {\n                    array[head and mask].value = null // now can safely put null (state was updated)\n                    return null\n                }\n            }\n        }\n    }\n\n    fun next(): LockFreeTaskQueueCore<E> = allocateOrGetNextCopy(markFrozen())\n\n    private fun markFrozen(): Long =\n        _state.updateAndGet { state ->\n            if (state and FROZEN_MASK != 0L) return state // already marked\n            state or FROZEN_MASK\n        }\n\n    private fun allocateOrGetNextCopy(state: Long): Core<E> {\n        _next.loop { next ->\n            if (next != null) return next // already allocated & copied\n            _next.compareAndSet(null, allocateNextCopy(state))\n        }\n    }\n\n    private fun allocateNextCopy(state: Long): Core<E> {\n        val next = LockFreeTaskQueueCore<E>(capacity * 2, singleConsumer)\n        state.withState { head, tail ->\n            var index = head\n            while (index and mask != tail and mask) {\n                // replace nulls with placeholders on copy\n                val value = array[index and mask].value ?: Placeholder(index)\n                next.array[index and next.mask].value = value\n                index++\n            }\n            next._state.value = state wo FROZEN_MASK\n        }\n        return next\n    }\n\n    // Used for validation in tests only\n    fun <R> map(transform: (E) -> R): List<R> {\n        val res = ArrayList<R>(capacity)\n        _state.value.withState { head, tail ->\n            var index = head\n            while (index and mask != tail and mask) {\n                // replace nulls with placeholders on copy\n                val element = array[index and mask].value\n                @Suppress(\"UNCHECKED_CAST\")\n                if (element != null && element !is Placeholder) res.add(transform(element as E))\n                index++\n            }\n        }\n        return res\n    }\n\n    // Used for validation in tests only\n    fun isClosed(): Boolean = _state.value and CLOSED_MASK != 0L\n\n\n    // Instance of this class is placed into array when we have to copy array, but addLast is in progress --\n    // it had already reserved a slot in the array (with null) and have not yet put its value there.\n    // Placeholder keeps the actual index (not masked) to distinguish placeholders on different wraparounds of array\n    // Internal because of inlining\n    internal class Placeholder(@JvmField val index: Int)\n\n    @Suppress(\"PrivatePropertyName\", \"MemberVisibilityCanBePrivate\")\n    internal companion object {\n        const val INITIAL_CAPACITY = 8\n\n        const val CAPACITY_BITS = 30\n        const val MAX_CAPACITY_MASK = (1 shl CAPACITY_BITS) - 1\n        const val HEAD_SHIFT = 0\n        const val HEAD_MASK = MAX_CAPACITY_MASK.toLong() shl HEAD_SHIFT\n        const val TAIL_SHIFT = HEAD_SHIFT + CAPACITY_BITS\n        const val TAIL_MASK = MAX_CAPACITY_MASK.toLong() shl TAIL_SHIFT\n\n        const val FROZEN_SHIFT = TAIL_SHIFT + CAPACITY_BITS\n        const val FROZEN_MASK = 1L shl FROZEN_SHIFT\n        const val CLOSED_SHIFT = FROZEN_SHIFT + 1\n        const val CLOSED_MASK = 1L shl CLOSED_SHIFT\n\n        const val MIN_ADD_SPIN_CAPACITY = 1024\n\n        @JvmField val REMOVE_FROZEN = Symbol(\"REMOVE_FROZEN\")\n\n        const val ADD_SUCCESS = 0\n        const val ADD_FROZEN = 1\n        const val ADD_CLOSED = 2\n\n        infix fun Long.wo(other: Long) = this and other.inv()\n        fun Long.updateHead(newHead: Int) = (this wo HEAD_MASK) or (newHead.toLong() shl HEAD_SHIFT)\n        fun Long.updateTail(newTail: Int) = (this wo TAIL_MASK) or (newTail.toLong() shl TAIL_SHIFT)\n\n        inline fun <T> Long.withState(block: (head: Int, tail: Int) -> T): T {\n            val head = ((this and HEAD_MASK) shr HEAD_SHIFT).toInt()\n            val tail = ((this and TAIL_MASK) shr TAIL_SHIFT).toInt()\n            return block(head, tail)\n        }\n\n        // FROZEN | CLOSED\n        fun Long.addFailReason(): Int = if (this and CLOSED_MASK != 0L) ADD_CLOSED else ADD_FROZEN\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/MainDispatcherFactory.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\n\n/** @suppress */\n@InternalCoroutinesApi // Emulating DI for Kotlin object's\npublic interface MainDispatcherFactory {\n    public val loadPriority: Int // higher priority wins\n\n    /**\n     * Creates the main dispatcher. [allFactories] parameter contains all factories found by service loader.\n     * This method is not guaranteed to be idempotent.\n     *\n     * It is required that this method fails with an exception instead of returning an instance that doesn't work\n     * correctly as a [Delay].\n     * The reason for this is that, on the JVM, [DefaultDelay] will use [Dispatchers.Main] for most delays by default\n     * if this method returns an instance without throwing.\n     */\n    public fun createDispatcher(allFactories: List<MainDispatcherFactory>): MainCoroutineDispatcher\n\n    /**\n     * Hint used along with error message when the factory failed to create a dispatcher.\n     */\n    public fun hintOnError(): String? = null\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/OnUndeliveredElement.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\ninternal typealias OnUndeliveredElement<E> = (E) -> Unit\n\ninternal fun <E> OnUndeliveredElement<E>.callUndeliveredElementCatchingException(\n    element: E,\n    undeliveredElementException: UndeliveredElementException? = null\n): UndeliveredElementException? {\n    try {\n        invoke(element)\n    } catch (ex: Throwable) {\n        // undeliveredElementException.cause !== ex is an optimization in case the same exception is thrown\n        // over and over again by on OnUndeliveredElement\n        if (undeliveredElementException != null && undeliveredElementException.cause !== ex) {\n            undeliveredElementException.addSuppressed(ex)\n        } else {\n            return UndeliveredElementException(\"Exception in undelivered element handler for $element\", ex)\n        }\n    }\n    return undeliveredElementException\n}\n\ninternal fun <E> OnUndeliveredElement<E>.callUndeliveredElement(element: E, context: CoroutineContext) {\n    callUndeliveredElementCatchingException(element, null)?.let { ex ->\n        handleCoroutineException(context, ex)\n    }\n}\n\ninternal fun <E> OnUndeliveredElement<E>.bindCancellationFun(element: E, context: CoroutineContext): (Throwable) -> Unit =\n    { _: Throwable -> callUndeliveredElement(element, context) }\n\n/**\n * Internal exception that is thrown when [OnUndeliveredElement] handler in\n * a [kotlinx.coroutines.channels.Channel] throws an exception.\n */\ninternal class UndeliveredElementException(message: String, cause: Throwable) : RuntimeException(message, cause)\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/ProbesSupport.common.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\n\ninternal expect inline fun <T> probeCoroutineCreated(completion: Continuation<T>): Continuation<T>\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/Scopes.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.jvm.*\n\n/**\n * This is a coroutine instance that is created by [coroutineScope] builder.\n */\ninternal open class ScopeCoroutine<in T>(\n    context: CoroutineContext,\n    @JvmField val uCont: Continuation<T> // unintercepted continuation\n) : AbstractCoroutine<T>(context, true, true), CoroutineStackFrame {\n\n    final override val callerFrame: CoroutineStackFrame? get() = uCont as? CoroutineStackFrame\n    final override fun getStackTraceElement(): StackTraceElement? = null\n\n    final override val isScopedCoroutine: Boolean get() = true\n\n    override fun afterCompletion(state: Any?) {\n        // Resume in a cancellable way by default when resuming from another context\n        uCont.intercepted().resumeCancellableWith(recoverResult(state, uCont))\n    }\n\n    override fun afterResume(state: Any?) {\n        // Resume direct because scope is already in the correct context\n        uCont.resumeWith(recoverResult(state, uCont))\n    }\n}\n\ninternal class ContextScope(context: CoroutineContext) : CoroutineScope {\n    override val coroutineContext: CoroutineContext = context\n    // CoroutineScope is used intentionally for user-friendly representation\n    override fun toString(): String = \"CoroutineScope(coroutineContext=$coroutineContext)\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/StackTraceRecovery.common.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\n\n/**\n * Tries to recover stacktrace for given [exception] and [continuation].\n * Stacktrace recovery tries to restore [continuation] stack frames using its debug metadata with [CoroutineStackFrame] API\n * and then reflectively instantiate exception of given type with original exception as a cause and\n * sets new stacktrace for wrapping exception.\n * Some frames may be missing due to tail-call elimination.\n *\n * Works only on JVM with enabled debug-mode.\n */\ninternal expect fun <E: Throwable> recoverStackTrace(exception: E, continuation: Continuation<*>): E\n\n/**\n * initCause on JVM, nop on other platforms\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\ninternal expect fun Throwable.initCause(cause: Throwable)\n\n/**\n * Tries to recover stacktrace for given [exception]. Used in non-suspendable points of awaiting.\n * Stacktrace recovery tries to instantiate exception of given type with original exception as a cause.\n * Wrapping exception will have proper stacktrace as it's instantiated in the right context.\n *\n * Works only on JVM with enabled debug-mode.\n */\ninternal expect fun <E: Throwable> recoverStackTrace(exception: E): E\n\n// Name conflict with recoverStackTrace\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal expect suspend inline fun recoverAndThrow(exception: Throwable): Nothing\n\n/**\n * The opposite of [recoverStackTrace].\n * It is guaranteed that `unwrap(recoverStackTrace(e)) === e`\n */\n@PublishedApi // Used from kotlinx-coroutines-test and reactor modules via suppress, not part of ABI\ninternal expect fun <E: Throwable> unwrap(exception: E): E\n\ninternal expect class StackTraceElement\n\ninternal expect interface CoroutineStackFrame {\n    public val callerFrame: CoroutineStackFrame?\n    public fun getStackTraceElement(): StackTraceElement?\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/Symbol.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.jvm.*\n\n/**\n * A symbol class that is used to define unique constants that are self-explanatory in debugger.\n *\n * @suppress **This is unstable API and it is subject to change.**\n */\ninternal class Symbol(@JvmField val symbol: String) {\n    override fun toString(): String = \"<$symbol>\"\n\n    @Suppress(\"UNCHECKED_CAST\", \"NOTHING_TO_INLINE\")\n    inline fun <T> unbox(value: Any?): T = if (value === this) null as T else value as T\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/Synchronized.common.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport kotlin.contracts.*\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic expect open class SynchronizedObject() // marker abstract class\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic expect inline fun <T> synchronizedImpl(lock: SynchronizedObject, block: () -> T): T\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@OptIn(ExperimentalContracts::class)\n@InternalCoroutinesApi\npublic inline fun <T> synchronized(lock: SynchronizedObject, block: () -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return synchronizedImpl(lock, block)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/SystemProps.common.kt",
        "content": "@file:JvmName(\"SystemPropsKt\")\n@file:JvmMultifileClass\n\npackage kotlinx.coroutines.internal\n\nimport kotlin.jvm.*\n\n/**\n * Gets the system property indicated by the specified [property name][propertyName],\n * or returns [defaultValue] if there is no property with that key.\n *\n * **Note: this function should be used in JVM tests only, other platforms use the default value.**\n */\ninternal fun systemProp(\n    propertyName: String,\n    defaultValue: Boolean\n): Boolean = systemProp(propertyName)?.toBoolean() ?: defaultValue\n\n/**\n * Gets the system property indicated by the specified [property name][propertyName],\n * or returns [defaultValue] if there is no property with that key. It also checks that the result\n * is between [minValue] and [maxValue] (inclusively), throws [IllegalStateException] if it is not.\n *\n * **Note: this function should be used in JVM tests only, other platforms use the default value.**\n */\ninternal fun systemProp(\n    propertyName: String,\n    defaultValue: Int,\n    minValue: Int = 1,\n    maxValue: Int = Int.MAX_VALUE\n): Int = systemProp(propertyName, defaultValue.toLong(), minValue.toLong(), maxValue.toLong()).toInt()\n\n/**\n * Gets the system property indicated by the specified [property name][propertyName],\n * or returns [defaultValue] if there is no property with that key. It also checks that the result\n * is between [minValue] and [maxValue] (inclusively), throws [IllegalStateException] if it is not.\n *\n * **Note: this function should be used in JVM tests only, other platforms use the default value.**\n */\ninternal fun systemProp(\n    propertyName: String,\n    defaultValue: Long,\n    minValue: Long = 1,\n    maxValue: Long = Long.MAX_VALUE\n): Long {\n    val value = systemProp(propertyName) ?: return defaultValue\n    val parsed = value.toLongOrNull()\n        ?: error(\"System property '$propertyName' has unrecognized value '$value'\")\n    if (parsed !in minValue..maxValue) {\n        error(\"System property '$propertyName' should be in range $minValue..$maxValue, but is '$parsed'\")\n    }\n    return parsed\n}\n\n/**\n * Gets the system property indicated by the specified [property name][propertyName],\n * or returns [defaultValue] if there is no property with that key.\n *\n * **Note: this function should be used in JVM tests only, other platforms use the default value.**\n */\ninternal fun systemProp(\n    propertyName: String,\n    defaultValue: String\n): String = systemProp(propertyName) ?: defaultValue\n\n/**\n * Gets the system property indicated by the specified [property name][propertyName],\n * or returns `null` if there is no property with that key.\n *\n * **Note: this function should be used in JVM tests only, other platforms use the default value.**\n */\ninternal expect fun systemProp(propertyName: String): String?\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/ThreadContext.common.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\n\ninternal expect fun threadContextElements(context: CoroutineContext): Any\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/ThreadLocal.common.kt",
        "content": "package kotlinx.coroutines.internal\n\ninternal expect class CommonThreadLocal<T> {\n    fun get(): T\n    fun set(value: T)\n}\n\n/**\n * Create a thread-local storage for an object of type [T].\n *\n * If two different thread-local objects share the same [name], they will not necessarily share the same value,\n * but they may.\n * Therefore, use a unique [name] for each thread-local object.\n */\ninternal expect fun<T> commonThreadLocal(name: Symbol): CommonThreadLocal<T>\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/internal/ThreadSafeHeap.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic interface ThreadSafeHeapNode {\n    public var heap: ThreadSafeHeap<*>?\n    public var index: Int\n}\n\n/**\n * Synchronized binary heap.\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic open class ThreadSafeHeap<T> : SynchronizedObject() where T: ThreadSafeHeapNode, T: Comparable<T> {\n    private var a: Array<T?>? = null\n\n    private val _size = atomic(0)\n\n    public var size: Int\n        get() = _size.value\n        private set(value) { _size.value = value }\n\n    public val isEmpty: Boolean get() = size == 0\n\n    public fun find(\n        predicate: (value: T) -> Boolean\n    ): T? = synchronized(this) block@{\n        for (i in 0 until size) {\n            val value = a?.get(i)!!\n            if (predicate(value)) return@block value\n        }\n        null\n    }\n\n    public fun peek(): T? = synchronized(this) { firstImpl() }\n\n    public fun removeFirstOrNull(): T? = synchronized(this) {\n        if (size > 0) {\n            removeAtImpl(0)\n        } else {\n            null\n        }\n    }\n\n    public inline fun removeFirstIf(predicate: (T) -> Boolean): T? = synchronized(this) {\n        val first = firstImpl() ?: return null\n        if (predicate(first)) {\n            removeAtImpl(0)\n        } else {\n            null\n        }\n    }\n\n    public fun addLast(node: T): Unit = synchronized(this) { addImpl(node) }\n\n    // Condition also receives current first node in the heap\n    public inline fun addLastIf(node: T, cond: (T?) -> Boolean): Boolean = synchronized(this) {\n        if (cond(firstImpl())) {\n            addImpl(node)\n            true\n        } else {\n            false\n        }\n    }\n\n    public fun remove(node: T): Boolean = synchronized(this) {\n        return if (node.heap == null) {\n            false\n        } else {\n            val index = node.index\n            assert { index >= 0 }\n            removeAtImpl(index)\n            true\n        }\n    }\n\n    @PublishedApi\n    internal fun firstImpl(): T? = a?.get(0)\n\n    @PublishedApi\n    internal fun removeAtImpl(index: Int): T {\n        assert { size > 0 }\n        val a = this.a!!\n        size--\n        if (index < size) {\n            swap(index, size)\n            val j = (index - 1) / 2\n            if (index > 0 && a[index]!! < a[j]!!) {\n                swap(index, j)\n                siftUpFrom(j)\n            } else {\n                siftDownFrom(index)\n            }\n        }\n        val result = a[size]!!\n        assert { result.heap === this }\n        result.heap = null\n        result.index = -1\n        a[size] = null\n        return result\n    }\n\n    @PublishedApi\n    internal fun addImpl(node: T) {\n        assert { node.heap == null }\n        node.heap = this\n        val a = realloc()\n        val i = size++\n        a[i] = node\n        node.index = i\n        siftUpFrom(i)\n    }\n\n    private tailrec fun siftUpFrom(i: Int) {\n        if (i <= 0) return\n        val a = a!!\n        val j = (i - 1) / 2\n        if (a[j]!! <= a[i]!!) return\n        swap(i, j)\n        siftUpFrom(j)\n    }\n\n    private tailrec fun siftDownFrom(i: Int) {\n        var j = 2 * i + 1\n        if (j >= size) return\n        val a = a!!\n        if (j + 1 < size && a[j + 1]!! < a[j]!!) j++\n        if (a[i]!! <= a[j]!!) return\n        swap(i, j)\n        siftDownFrom(j)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun realloc(): Array<T?> {\n        val a = this.a\n        return when {\n            a == null -> (arrayOfNulls<ThreadSafeHeapNode>(4) as Array<T?>).also { this.a = it }\n            size >= a.size -> a.copyOf(size * 2).also { this.a = it }\n            else -> a\n        }\n    }\n\n    private fun swap(i: Int, j: Int) {\n        val a = a!!\n        val ni = a[j]!!\n        val nj = a[i]!!\n        a[i] = ni\n        a[j] = nj\n        ni.index = i\n        nj.index = j\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/intrinsics/Cancellable.kt",
        "content": "package kotlinx.coroutines.intrinsics\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n/**\n * Use this function to start coroutine in a cancellable way, so that it can be cancelled\n * while waiting to be dispatched.\n */\n@InternalCoroutinesApi\npublic fun <T> (suspend () -> T).startCoroutineCancellable(completion: Continuation<T>): Unit = runSafely(completion) {\n    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))\n}\n\n/**\n * Use this function to start coroutine in a cancellable way, so that it can be cancelled\n * while waiting to be dispatched.\n */\ninternal fun <R, T> (suspend (R) -> T).startCoroutineCancellable(\n    receiver: R, completion: Continuation<T>,\n    onCancellation: ((cause: Throwable) -> Unit)? = null\n) =\n    runSafely(completion) {\n        createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellableWith(Result.success(Unit), onCancellation)\n    }\n\n/**\n * Similar to [startCoroutineCancellable], but for already created coroutine.\n * [fatalCompletion] is used only when interception machinery throws an exception\n */\ninternal fun Continuation<Unit>.startCoroutineCancellable(fatalCompletion: Continuation<*>) =\n    runSafely(fatalCompletion) {\n        intercepted().resumeCancellableWith(Result.success(Unit))\n    }\n\n/**\n * Runs given block and completes completion with its exception if it occurs.\n * Rationale: [startCoroutineCancellable] is invoked when we are about to run coroutine asynchronously in its own dispatcher.\n * Thus if dispatcher throws an exception during coroutine start, coroutine never completes, so we should treat dispatcher exception\n * as its cause and resume completion.\n */\nprivate inline fun runSafely(completion: Continuation<*>, block: () -> Unit) {\n    try {\n        block()\n    } catch (e: Throwable) {\n        dispatcherFailure(completion, e)\n    }\n}\n\nprivate fun dispatcherFailure(completion: Continuation<*>, e: Throwable) {\n    /*\n     * This method is invoked when we failed to start a coroutine due to the throwing\n     * dispatcher implementation or missing Dispatchers.Main.\n     * This situation is not recoverable, so we are trying to deliver the exception by all means:\n     * 1) Resume the coroutine with an exception, so it won't prevent its parent from completion\n     * 2) Rethrow the exception immediately, so it will crash the caller (e.g. when the coroutine had\n     *    no parent or it was async/produce over MainScope).\n     */\n    completion.resumeWith(Result.failure(e))\n    throw e\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/intrinsics/Undispatched.kt",
        "content": "package kotlinx.coroutines.intrinsics\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n/**\n * Use this function to restart a coroutine directly from inside of [suspendCoroutine],\n * when the code is already in the context of this coroutine.\n * It does not use [ContinuationInterceptor] and does not update the context of the current thread.\n */\ninternal fun <T> (suspend () -> T).startCoroutineUnintercepted(completion: Continuation<T>) {\n    startDirect(completion) { actualCompletion ->\n        startCoroutineUninterceptedOrReturn(actualCompletion)\n    }\n}\n\n/**\n * Use this function to start a new coroutine in [CoroutineStart.UNDISPATCHED] mode &mdash;\n * immediately execute the coroutine in the current thread until the next suspension.\n * It does not use [ContinuationInterceptor], but updates the context of the current thread for the new coroutine.\n */\ninternal fun <R, T> (suspend (R) -> T).startCoroutineUndispatched(receiver: R, completion: Continuation<T>) {\n    startDirect(completion) { actualCompletion ->\n        withCoroutineContext(completion.context, null) {\n            startCoroutineUninterceptedOrReturn(receiver, actualCompletion)\n        }\n    }\n}\n\n/**\n * Starts the given [block] immediately in the current stack-frame until the first suspension point.\n * This method supports debug probes and thus can intercept completion, thus completion is provided\n * as the parameter of [block].\n */\nprivate inline fun <T> startDirect(completion: Continuation<T>, block: (Continuation<T>) -> Any?) {\n    val actualCompletion = probeCoroutineCreated(completion)\n    val value = try {\n        block(actualCompletion)\n    } catch (e: Throwable) {\n        actualCompletion.resumeWithException(e)\n        return\n    }\n    if (value !== COROUTINE_SUSPENDED) {\n        @Suppress(\"UNCHECKED_CAST\")\n        actualCompletion.resume(value as T)\n    }\n}\n\n/**\n * Starts this coroutine with the given code [block] in the same context and returns the coroutine result when it\n * completes without suspension.\n * This function shall be invoked at most once on this coroutine.\n * This function checks cancellation of the outer [Job] on fast-path.\n *\n * It starts the coroutine using [startCoroutineUninterceptedOrReturn].\n */\ninternal fun <T, R> ScopeCoroutine<T>.startUndispatchedOrReturn(receiver: R, block: suspend R.() -> T): Any? {\n    return undispatchedResult({ true }) {\n        block.startCoroutineUninterceptedOrReturn(receiver, this)\n    }\n}\n\n/**\n * Same as [startUndispatchedOrReturn], but ignores [TimeoutCancellationException] on fast-path.\n */\ninternal fun <T, R> ScopeCoroutine<T>.startUndispatchedOrReturnIgnoreTimeout(\n    receiver: R, block: suspend R.() -> T\n): Any? {\n    return undispatchedResult({ e -> !(e is TimeoutCancellationException && e.coroutine === this) }) {\n        block.startCoroutineUninterceptedOrReturn(receiver, this)\n    }\n}\n\nprivate inline fun <T> ScopeCoroutine<T>.undispatchedResult(\n    shouldThrow: (Throwable) -> Boolean,\n    startBlock: () -> Any?\n): Any? {\n    val result = try {\n        startBlock()\n    } catch (e: Throwable) {\n        CompletedExceptionally(e)\n    }\n    /*\n     * We're trying to complete our undispatched block here and have three code-paths:\n     * (1) Coroutine is suspended.\n     * Otherwise, coroutine had returned result, so we are completing our block (and its job).\n     * (2) If we can't complete it or started waiting for children, we suspend.\n     * (3) If we have successfully completed the coroutine state machine here,\n     *     then we take the actual final state of the coroutine from makeCompletingOnce and return it.\n     *\n     * shouldThrow parameter is a special code path for timeout coroutine:\n     * If timeout is exceeded, but withTimeout() block was not suspended, we would like to return block value,\n     * not a timeout exception.\n     */\n    if (result === COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED // (1)\n    val state = makeCompletingOnce(result)\n    if (state === COMPLETING_WAITING_CHILDREN) return COROUTINE_SUSPENDED // (2)\n    return if (state is CompletedExceptionally) { // (3)\n        when {\n            shouldThrow(state.cause) -> throw recoverStackTrace(state.cause, uCont)\n            result is CompletedExceptionally -> throw recoverStackTrace(result.cause, uCont)\n            else -> result\n        }\n    } else {\n        state.unboxState()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/selects/OnTimeout.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.*\nimport kotlin.time.*\n\n/**\n * Clause that selects the given [block] after a specified timeout passes.\n * If timeout is negative or zero, [block] is selected immediately.\n *\n * **Note: This is an experimental api.** It may be replaced with light-weight timer/timeout channels in the future.\n *\n * @param timeMillis timeout time in milliseconds.\n */\n@ExperimentalCoroutinesApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun <R> SelectBuilder<R>.onTimeout(timeMillis: Long, block: suspend () -> R): Unit =\n    OnTimeout(timeMillis).selectClause.invoke(block)\n\n/**\n * Clause that selects the given [block] after the specified [timeout] passes.\n * If timeout is negative or zero, [block] is selected immediately.\n *\n * **Note: This is an experimental api.** It may be replaced with light-weight timer/timeout channels in the future.\n */\n@ExperimentalCoroutinesApi\npublic fun <R> SelectBuilder<R>.onTimeout(timeout: Duration, block: suspend () -> R): Unit =\n    onTimeout(timeout.toDelayMillis(), block)\n\n/**\n * We implement [SelectBuilder.onTimeout] as a clause, so each invocation creates\n * an instance of [OnTimeout] that specifies the registration part according to\n * the [timeout][timeMillis] parameter.\n */\nprivate class OnTimeout(\n    private val timeMillis: Long\n) {\n    @Suppress(\"UNCHECKED_CAST\")\n    val selectClause: SelectClause0\n        get() = SelectClause0Impl(\n            clauseObject = this@OnTimeout,\n            regFunc = OnTimeout::register as RegistrationFunction\n        )\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun register(select: SelectInstance<*>, ignoredParam: Any?) {\n        // Should this clause complete immediately?\n        if (timeMillis <= 0) {\n            select.selectInRegistrationPhase(Unit)\n            return\n        }\n        // Invoke `trySelect` after the timeout is reached.\n        val action = Runnable {\n            select.trySelect(this@OnTimeout, Unit)\n        }\n        select as SelectImplementation<*>\n        val context = select.context\n        val disposableHandle = context.delay.invokeOnTimeout(timeMillis, action, context)\n        // Do not forget to clean-up when this `select` is completed or cancelled.\n        select.disposeOnCompletion(disposableHandle)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/selects/Select.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.TrySelectDetailedResult.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.*\nimport kotlin.jvm.*\n\n/**\n * Waits for the result of multiple suspending functions simultaneously, which are specified using _clauses_\n * in the [builder] scope of this select invocation. The caller is suspended until one of the clauses\n * is either _selected_ or _fails_.\n *\n * At most one clause is *atomically* selected and its block is executed. The result of the selected clause\n * becomes the result of the select. If any clause _fails_, then the select invocation produces the\n * corresponding exception. No clause is selected in this case.\n *\n * This select function is _biased_ to the first clause. When multiple clauses can be selected at the same time,\n * the first one of them gets priority. Use [selectUnbiased] for an unbiased (randomized) selection among\n * the clauses.\n\n * There is no `default` clause for select expression. Instead, each selectable suspending function has the\n * corresponding non-suspending version that can be used with a regular `when` expression to select one\n * of the alternatives or to perform the default (`else`) action if none of them can be immediately selected.\n *\n * ### List of supported select methods\n *\n * | **Receiver**     | **Suspending function**                           | **Select clause**\n * | ---------------- | ---------------------------------------------     | -----------------------------------------------------\n * | [Job]            | [join][Job.join]                                  | [onJoin][Job.onJoin]\n * | [Deferred]       | [await][Deferred.await]                           | [onAwait][Deferred.onAwait]\n * | [SendChannel]    | [send][SendChannel.send]                          | [onSend][SendChannel.onSend]\n * | [ReceiveChannel] | [receive][ReceiveChannel.receive]                 | [onReceive][ReceiveChannel.onReceive]\n * | [ReceiveChannel] | [receiveCatching][ReceiveChannel.receiveCatching] | [onReceiveCatching][ReceiveChannel.onReceiveCatching]\n * | none             | [delay]                                           | [onTimeout][SelectBuilder.onTimeout]\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n *\n * Note that this function does not check for cancellation when it is not suspended.\n * Use [yield] or [CoroutineScope.isActive] to periodically check for cancellation in tight loops if needed.\n */\n@OptIn(ExperimentalContracts::class)\npublic suspend inline fun <R> select(crossinline builder: SelectBuilder<R>.() -> Unit): R {\n    contract {\n        callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n    }\n    return SelectImplementation<R>(coroutineContext).run {\n        builder(this)\n        // TAIL-CALL OPTIMIZATION: the only\n        // suspend call is at the last position.\n        doSelect()\n    }\n}\n\n/**\n * Scope for [select] invocation.\n *\n * An instance of [SelectBuilder] can only be retrieved as a receiver of a [select] block call,\n * and it is only valid during the registration phase of the select builder.\n * Any uses outside it lead to unspecified behaviour and are prohibited.\n *\n * The general rule of thumb is that instances of this type should always be used\n * implicitly and there shouldn't be any signatures mentioning this type,\n * whether explicitly (e.g. function signature) or implicitly (e.g. inferred `val` type).\n */\npublic sealed interface SelectBuilder<in R> {\n    /**\n     * Registers a clause in this [select] expression without additional parameters that does not select any value.\n     */\n    public operator fun SelectClause0.invoke(block: suspend () -> R)\n\n    /**\n     * Registers clause in this [select] expression without additional parameters that selects value of type [Q].\n     */\n    public operator fun <Q> SelectClause1<Q>.invoke(block: suspend (Q) -> R)\n\n    /**\n     * Registers clause in this [select] expression with additional parameter of type [P] that selects value of type [Q].\n     */\n    public operator fun <P, Q> SelectClause2<P, Q>.invoke(param: P, block: suspend (Q) -> R)\n\n    /**\n     * Registers clause in this [select] expression with additional nullable parameter of type [P]\n     * with the `null` value for this parameter that selects value of type [Q].\n     */\n    public operator fun <P, Q> SelectClause2<P?, Q>.invoke(block: suspend (Q) -> R): Unit = invoke(null, block)\n\n    /**\n     * Clause that selects the given [block] after a specified timeout passes.\n     * If timeout is negative or zero, [block] is selected immediately.\n     *\n     * **Note: This is an experimental api.** It may be replaced with light-weight timer/timeout channels in the future.\n     *\n     * @param timeMillis timeout time in milliseconds.\n     */\n    @ExperimentalCoroutinesApi\n    @Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n    @LowPriorityInOverloadResolution\n    @Deprecated(\n        message = \"Replaced with the same extension function\",\n        level = DeprecationLevel.ERROR, replaceWith = ReplaceWith(expression = \"onTimeout\", imports = [\"kotlinx.coroutines.selects.onTimeout\"])\n    ) // Since 1.7.0, was experimental\n    public fun onTimeout(timeMillis: Long, block: suspend () -> R): Unit = onTimeout(timeMillis, block)\n}\n\n/**\n * Each [select] clause is specified with:\n * 1) the [object of this clause][clauseObject],\n *    such as the channel instance for [SendChannel.onSend];\n * 2) the function that specifies how this clause\n *    should be registered in the object above;\n * 3) the function that modifies the internal result\n *    (passed via [SelectInstance.trySelect] or\n *    [SelectInstance.selectInRegistrationPhase])\n *    to the argument of the user-specified block.\n * 4) the function that specifies how the internal result provided via\n *    [SelectInstance.trySelect] or [SelectInstance.selectInRegistrationPhase]\n *    should be processed in case of this `select` cancellation while dispatching.\n */\n@InternalCoroutinesApi\npublic sealed interface SelectClause {\n    public val clauseObject: Any\n    public val regFunc: RegistrationFunction\n    public val processResFunc: ProcessResultFunction\n    public val onCancellationConstructor: OnCancellationConstructor?\n}\n\n/**\n * The registration function specifies how the `select` instance should be registered into\n * the specified clause object. In case of channels, the registration logic\n * coincides with the plain `send/receive` operation with the only difference that\n * the `select` instance is stored as a waiter instead of continuation.\n */\n@InternalCoroutinesApi\npublic typealias RegistrationFunction = (clauseObject: Any, select: SelectInstance<*>, param: Any?) -> Unit\n\n/**\n * This function specifies how the _internal_ result, provided via [SelectInstance.selectInRegistrationPhase]\n * or [SelectInstance.trySelect] should be processed. For example, both [ReceiveChannel.onReceive] and\n * [ReceiveChannel.onReceiveCatching] clauses perform exactly the same synchronization logic,\n * but differ when the channel has been discovered in the closed or cancelled state.\n */\n@InternalCoroutinesApi\npublic typealias ProcessResultFunction = (clauseObject: Any, param: Any?, clauseResult: Any?) -> Any?\n\n/**\n * This function specifies how the internal result, provided via [SelectInstance.trySelect]\n * or [SelectInstance.selectInRegistrationPhase], should be processed in case of this `select`\n * cancellation while dispatching. Unfortunately, we cannot pass this function only in [SelectInstance.trySelect],\n * as [SelectInstance.selectInRegistrationPhase] can be called when the coroutine is already cancelled.\n */\n@InternalCoroutinesApi\npublic typealias OnCancellationConstructor = (select: SelectInstance<*>, param: Any?, internalResult: Any?) -> (Throwable) -> Unit\n\n/**\n * Clause for [select] expression without additional parameters that does not select any value.\n */\npublic sealed interface SelectClause0 : SelectClause\n\ninternal class SelectClause0Impl(\n    override val clauseObject: Any,\n    override val regFunc: RegistrationFunction,\n    override val onCancellationConstructor: OnCancellationConstructor? = null\n) : SelectClause0 {\n    override val processResFunc: ProcessResultFunction = DUMMY_PROCESS_RESULT_FUNCTION\n}\nprivate val DUMMY_PROCESS_RESULT_FUNCTION: ProcessResultFunction = { _, _, _ -> null }\n\n/**\n * Clause for [select] expression without additional parameters that selects value of type [Q].\n */\npublic sealed interface SelectClause1<out Q> : SelectClause\n\ninternal class SelectClause1Impl<Q>(\n    override val clauseObject: Any,\n    override val regFunc: RegistrationFunction,\n    override val processResFunc: ProcessResultFunction,\n    override val onCancellationConstructor: OnCancellationConstructor? = null\n) : SelectClause1<Q>\n\n/**\n * Clause for [select] expression with additional parameter of type [P] that selects value of type [Q].\n */\npublic sealed interface SelectClause2<in P, out Q> : SelectClause\n\ninternal class SelectClause2Impl<P, Q>(\n    override val clauseObject: Any,\n    override val regFunc: RegistrationFunction,\n    override val processResFunc: ProcessResultFunction,\n    override val onCancellationConstructor: OnCancellationConstructor? = null\n) : SelectClause2<P, Q>\n\n/**\n * Internal representation of `select` instance.\n *\n * @suppress **This is unstable API, and it is subject to change.**\n */\n@InternalCoroutinesApi\npublic sealed interface SelectInstance<in R> {\n    /**\n     * The context of the coroutine that is performing this `select` operation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * This function should be called by other operations,\n     * which are trying to perform a rendezvous with this `select`.\n     * Returns `true` if the rendezvous succeeds, `false` otherwise.\n     *\n     * Note that according to the current implementation, a rendezvous attempt can fail\n     * when either another clause is already selected or this `select` is still in\n     * REGISTRATION phase. To distinguish the reasons, [SelectImplementation.trySelectDetailed]\n     * function can be used instead.\n     */\n    public fun trySelect(clauseObject: Any, result: Any?): Boolean\n\n    /**\n     * When this `select` instance is stored as a waiter, the specified [handle][disposableHandle]\n     * defines how the stored `select` should be removed in case of cancellation or another clause selection.\n     */\n    public fun disposeOnCompletion(disposableHandle: DisposableHandle)\n\n    /**\n     * When a clause becomes selected during registration, the corresponding internal result\n     * (which is further passed to the clause's [ProcessResultFunction]) should be provided\n     * via this function. After that, other clause registrations are ignored and [trySelect] fails.\n     */\n    public fun selectInRegistrationPhase(internalResult: Any?)\n}\ninternal interface SelectInstanceInternal<R>: SelectInstance<R>, Waiter\n\n@PublishedApi\ninternal open class SelectImplementation<R>(\n    override val context: CoroutineContext\n) : CancelHandler, SelectBuilder<R>, SelectInstanceInternal<R> {\n\n    /**\n     * Essentially, the `select` operation is split into three phases: REGISTRATION, WAITING, and COMPLETION.\n     *\n     * == Phase 1: REGISTRATION ==\n     * In the first REGISTRATION phase, the user-specified [SelectBuilder] is applied, and all the listed clauses\n     * are registered via the provided [registration functions][SelectClause.regFunc]. Intuitively, `select` clause\n     * registration is similar to the plain blocking operation, with the only difference that this [SelectInstance]\n     * is stored as a waiter instead of continuation, and [SelectInstance.trySelect] is used to make a rendezvous.\n     * Also, when registering, it is possible for the operation to complete immediately, without waiting. In this case,\n     * [SelectInstance.selectInRegistrationPhase] should be used. Otherwise, when no rendezvous happens and this `select`\n     * instance is stored as a waiter, a completion handler for the registering clause should be specified via\n     * [SelectInstance.disposeOnCompletion]; this handler specifies how to remove this `select` instance from the\n     * clause object when another clause becomes selected or the operation cancels.\n     *\n     * After a clause registration is completed, another coroutine can attempt to make a rendezvous with this `select`.\n     * However, to resolve a race between clauses registration and [SelectInstance.trySelect], the latter fails when\n     * this `select` is still in REGISTRATION phase. Thus, the corresponding clause has to be registered again.\n     *\n     * In this phase, the `state` field stores either a special [STATE_REG] marker or\n     * a list of clauses to be re-registered due to failed rendezvous attempts.\n     *\n     * == Phase 2: WAITING ==\n     * If no rendezvous happens in REGISTRATION phase, the `select` operation moves to WAITING one and suspends until\n     * [SelectInstance.trySelect] is called. Also, when waiting, this `select` can be cancelled. In the latter case,\n     * further [SelectInstance.trySelect] attempts fail, and all the completion handlers, specified via\n     * [SelectInstance.disposeOnCompletion], are invoked to remove this `select` instance from the corresponding\n     * clause objects.\n     *\n     * In this phase, the `state` field stores either the continuation to be later resumed or a special `Cancelled`\n     * object (with the cancellation cause inside) when this `select` becomes cancelled.\n     *\n     * == Phase 3: COMPLETION ==\n     * Once a rendezvous happens either in REGISTRATION phase (via [SelectInstance.selectInRegistrationPhase]) or\n     * in WAITING phase (via [SelectInstance.trySelect]), this `select` moves to the final `COMPLETION` phase.\n     * First, the provided internal result is processed via the [ProcessResultFunction] of the selected clause;\n     * it returns the argument for the user-specified block or throws an exception (see [SendChannel.onSend] as\n     * an example). After that, this `select` should be removed from all other clause objects by calling the\n     * corresponding [DisposableHandle]-s, provided via [SelectInstance.disposeOnCompletion] during registration.\n     * At the end, the user-specified block is called and this `select` finishes.\n     *\n     * In this phase, once a rendezvous is happened, the `state` field stores the corresponding clause.\n     * After that, it moves to [STATE_COMPLETED] to avoid memory leaks.\n     *\n     *\n     *\n     * The state machine is listed below:\n     *\n     *            REGISTRATION PHASE                   WAITING PHASE             COMPLETION PHASE\n     *       \u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322             \u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322         \u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\u2322\n     *\n     *                                                 +-----------+                 +-----------+\n     *                                                 | CANCELLED |                 | COMPLETED |\n     *                                                 +-----------+                 +-----------+\n     *                                                       ^                             ^\n     *     INITIAL STATE                                     |                             | this `select`\n     *     ------------+                                     |  cancelled                  | is completed\n     *                  \\                                    |                             |\n     *                   +=============+     move to     +------+    successful   +------------+\n     *                +--|  STATE_REG  |---------------> | cont |-----------------| ClauseData |\n     *                |  +=============+  WAITING phase  +------+  trySelect(..)  +------------+\n     *                |    ^     |                                                       ^\n     *                |    |     |    some clause has been selected during registration  |\n     *         add a  |    |     +-------------------------------------------------------+\n     *   clause to be |    |                                                             |\n     *  re-registered |    | re-register                   some clause has been selected |\n     *                |    | clauses                     during registration while there |\n     *                v    |                            are clauses to be re-registered; |\n     *          +------------------+                                   ignore the latter |\n     *       +--| List<ClauseData> |-----------------------------------------------------+\n     *       |  +------------------+\n     *       |            ^\n     *       |            |  add one more clause\n     *       |            |  for re-registration\n     *       +------------+\n     *\n     * One of the most valuable benefits of this `select` design is that it allows processing clauses\n     * in a way similar to plain operations, such as `send` or `receive` on channels. The only difference\n     * is that instead of continuation, the operation should store the provided `select` instance object.\n     * Thus, this design makes it possible to support the `select` expression for any blocking data structure\n     * in Kotlin Coroutines.\n     *\n     * It is worth mentioning that the algorithm above provides \"obstruction-freedom\" non-blocking guarantee\n     * instead of the standard \"lock-freedom\" to avoid using heavy descriptors. In practice, this relaxation\n     * does not make significant difference. However, it is vital for Kotlin Coroutines to provide some\n     * non-blocking guarantee, as users may add blocking code in [SelectBuilder], and this blocking code\n     * should not cause blocking behaviour in other places, such as an attempt to make a rendezvous with\n     * the `select` that is hang in REGISTRATION phase.\n     *\n     * Also, this implementation is NOT linearizable under some circumstances. The reason is that a rendezvous\n     * attempt with `select` (via [SelectInstance.trySelect]) may fail when this `select` operation is still\n     * in REGISTRATION phase. Consider the following situation on two empty rendezvous channels `c1` and `c2`\n     * and the `select` operation that tries to send an element to one of these channels. First, this `select`\n     * instance is registered as a waiter in `c1`. After that, another thread can observe that `c1` is no longer\n     * empty and try to receive an element from `c1` -- this receive attempt fails due to the `select` operation\n     * being in REGISTRATION phase.\n     * It is also possible to observe that this `select` operation registered in `c2` first, and only after that in\n     * `c1` (it has to re-register in `c1` after the unsuccessful rendezvous attempt), which is also non-linearizable.\n     * We, however, find such a non-linearizable behaviour not so important in practice and leverage the correctness\n     * relaxation for the algorithm simplicity and the non-blocking progress guarantee.\n     */\n\n    /**\n     * The state of this `select` operation. See the description above for details.\n     */\n    private val state = atomic<Any>(STATE_REG)\n    /**\n     * Returns `true` if this `select` instance is in the REGISTRATION phase;\n     * otherwise, returns `false`.\n     */\n    private val inRegistrationPhase\n        get() = state.value.let {\n            it === STATE_REG || it is List<*>\n        }\n    /**\n     * Returns `true` if this `select` is already selected;\n     * thus, other parties are bound to fail when making a rendezvous with it.\n     */\n    private val isSelected\n        get() = state.value is SelectImplementation<*>.ClauseData\n    /**\n     * Returns `true` if this `select` is cancelled.\n     */\n    private val isCancelled\n        get() = state.value === STATE_CANCELLED\n\n    /**\n     * List of clauses waiting on this `select` instance.\n     *\n     * This property is the subject to bening data race: concurrent cancellation might null-out this property\n     * while [trySelect] operation reads it and iterates over its content.\n     * A logical race is resolved by the consensus on [state] property.\n     */\n    @BenignDataRace\n    private var clauses: MutableList<ClauseData>? = ArrayList(2)\n\n    /**\n     * Stores the completion action provided through [disposeOnCompletion] or [invokeOnCancellation]\n     * during clause registration. After that, if the clause is successfully registered\n     * (so, it has not completed immediately), this handler is stored into\n     * the corresponding [ClauseData] instance.\n     *\n     * Note that either [DisposableHandle] is provided, or a [Segment] instance with\n     * the index in it, which specify the location of storing this `select`.\n     * In the latter case, [Segment.onCancellation] should be called on completion/cancellation.\n     */\n    private var disposableHandleOrSegment: Any? = null\n\n    /**\n     * In case the disposable handle is specified via [Segment]\n     * and index in it, implying calling [Segment.onCancellation],\n     * the corresponding index is stored in this field.\n     * The segment is stored in [disposableHandleOrSegment].\n     */\n    private var indexInSegment: Int = -1\n\n    /**\n     * Stores the result passed via [selectInRegistrationPhase] during clause registration\n     * or [trySelect], which is called by another coroutine trying to make a rendezvous\n     * with this `select` instance. Further, this result is processed via the\n     * [ProcessResultFunction] of the selected clause.\n     *\n     * Unfortunately, we cannot store the result in the [state] field, as the latter stores\n     * the clause object upon selection (see [ClauseData.clauseObject] and [SelectClause.clauseObject]).\n     * Instead, it is possible to merge the [internalResult] and [disposableHandle] fields into\n     * one that stores either result when the clause is successfully registered ([inRegistrationPhase] is `true`),\n     * or [DisposableHandle] instance when the clause is completed during registration ([inRegistrationPhase] is `false`).\n     * Yet, this optimization is omitted for code simplicity.\n     *\n     * This property is the subject to benign data race:\n     * [Cleanup][cleanup] procedure can be invoked both as part of the completion sequence\n     * and as a cancellation handler triggered by an external cancellation.\n     * In both scenarios, [NO_RESULT] is written to this property via race.\n     */\n    @BenignDataRace\n    private var internalResult: Any? = NO_RESULT\n\n    /**\n     * This function is called after the [SelectBuilder] is applied. In case one of the clauses is already selected,\n     * the algorithm applies the corresponding [ProcessResultFunction] and invokes the user-specified [block][ClauseData.block].\n     * Otherwise, it moves this `select` to WAITING phase (re-registering clauses if needed), suspends until a rendezvous\n     * is happened, and then completes the operation by applying the corresponding [ProcessResultFunction] and\n     * invoking the user-specified [block][ClauseData.block].\n     */\n    @PublishedApi\n    internal open suspend fun doSelect(): R =\n        if (isSelected) complete()  // Fast path\n        else doSelectSuspend()      // Slow path\n\n    // We separate the following logic as it has two suspension points\n    // and, therefore, breaks the tail-call optimization if it were\n    // inlined in [doSelect]\n    private suspend fun doSelectSuspend(): R {\n        // In case no clause has been selected during registration,\n        // the `select` operation suspends and waits for a rendezvous.\n        waitUntilSelected() // <-- suspend call => no tail-call optimization here\n        // There is a selected clause! Apply the corresponding\n        // [ProcessResultFunction] and invoke the user-specified block.\n        return complete() // <-- one more suspend call\n    }\n\n    // ========================\n    // = CLAUSES REGISTRATION =\n    // ========================\n\n    override fun SelectClause0.invoke(block: suspend () -> R) =\n        ClauseData(clauseObject, regFunc, processResFunc, PARAM_CLAUSE_0, block, onCancellationConstructor).register()\n    override fun <Q> SelectClause1<Q>.invoke(block: suspend (Q) -> R) =\n        ClauseData(clauseObject, regFunc, processResFunc, null, block, onCancellationConstructor).register()\n    override fun <P, Q> SelectClause2<P, Q>.invoke(param: P, block: suspend (Q) -> R) =\n        ClauseData(clauseObject, regFunc, processResFunc, param, block, onCancellationConstructor).register()\n\n    /**\n     * Attempts to register this `select` clause. If another clause is already selected,\n     * this function does nothing and completes immediately.\n     * Otherwise, it registers this `select` instance in\n     * the [clause object][ClauseData.clauseObject]\n     * according to the provided [registration function][ClauseData.regFunc].\n     * On success, this `select` instance is stored as a waiter\n     * in the clause object -- the algorithm also stores\n     * the provided via [disposeOnCompletion] completion action\n     * and adds the clause to the list of registered one.\n     * In case of registration failure, the internal result\n     * (not processed by [ProcessResultFunction] yet) must be\n     * provided via [selectInRegistrationPhase] -- the algorithm\n     * updates the state to this clause reference.\n     */\n    @JvmName(\"register\")\n    internal fun ClauseData.register(reregister: Boolean = false) {\n        assert { state.value !== STATE_CANCELLED }\n        // Is there already selected clause?\n        if (state.value.let { it is SelectImplementation<*>.ClauseData }) return\n        // For new clauses, check that there does not exist\n        // another clause with the same object.\n        if (!reregister) checkClauseObject(clauseObject)\n        // Try to register in the corresponding object.\n        if (tryRegisterAsWaiter(this@SelectImplementation)) {\n            // Successfully registered, and this `select` instance\n            // is stored as a waiter. Add this clause to the list\n            // of registered clauses and store the provided via\n            // [invokeOnCompletion] completion action into the clause.\n            //\n            // Importantly, the [waitUntilSelected] function is implemented\n            // carefully to ensure that the cancellation handler has not been\n            // installed when clauses re-register, so the logic below cannot\n            // be invoked concurrently with the clean-up procedure.\n            // This also guarantees that the list of clauses cannot be cleared\n            // in the registration phase, so it is safe to read it with \"!!\".\n            if (!reregister) clauses!! += this\n            disposableHandleOrSegment = this@SelectImplementation.disposableHandleOrSegment\n            indexInSegment = this@SelectImplementation.indexInSegment\n            this@SelectImplementation.disposableHandleOrSegment = null\n            this@SelectImplementation.indexInSegment = -1\n        } else {\n            // This clause has been selected!\n            // Update the state correspondingly.\n            state.value = this\n        }\n    }\n\n    /**\n     * Checks that there does not exist another clause with the same object.\n     */\n    private fun checkClauseObject(clauseObject: Any) {\n        // Read the list of clauses, it is guaranteed that it is non-null.\n        // In fact, it can become `null` only in the clean-up phase, while\n        // this check can be called only in the registration one.\n        val clauses = clauses!!\n        // Check that there does not exist another clause with the same object.\n        check(clauses.none { it.clauseObject === clauseObject }) {\n            \"Cannot use select clauses on the same object: $clauseObject\"\n        }\n    }\n\n    override fun disposeOnCompletion(disposableHandle: DisposableHandle) {\n        this.disposableHandleOrSegment = disposableHandle\n    }\n\n    /**\n     * An optimized version for the code below that does not allocate\n     * a cancellation handler object and efficiently stores the specified\n     * [segment] and [index].\n     *\n     * ```\n     * disposeOnCompletion {\n     *   segment.onCancellation(index, null)\n     * }\n     * ```\n     */\n    override fun invokeOnCancellation(segment: Segment<*>, index: Int) {\n        this.disposableHandleOrSegment = segment\n        this.indexInSegment = index\n    }\n\n    override fun selectInRegistrationPhase(internalResult: Any?) {\n        this.internalResult = internalResult\n    }\n\n    // =========================\n    // = WAITING FOR SELECTION =\n    // =========================\n\n    /**\n     * Suspends and waits until some clause is selected. However, it is possible for a concurrent\n     * coroutine to invoke [trySelect] while this `select` is still in REGISTRATION phase.\n     * In this case, [trySelect] marks the corresponding select clause to be re-registered, and\n     * this function performs registration of such clauses. After that, it atomically stores\n     * the continuation into the [state] field if there is no more clause to be re-registered.\n     */\n    private suspend fun waitUntilSelected() = suspendCancellableCoroutine<Unit> sc@ { cont ->\n        // Update the state.\n        state.loop { curState ->\n            when {\n                // This `select` is in REGISTRATION phase, and there is no clause to be re-registered.\n                // Perform a transition to WAITING phase by storing the current continuation.\n                curState === STATE_REG -> if (state.compareAndSet(curState, cont)) {\n                    // Perform a clean-up in case of cancellation.\n                    //\n                    // Importantly, we MUST install the cancellation handler\n                    // only when the algorithm is bound to suspend. Otherwise,\n                    // a race with [tryRegister] is possible, and the provided\n                    // via [disposeOnCompletion] cancellation action can be ignored.\n                    // Also, we MUST guarantee that this dispose handle is _visible_\n                    // according to the memory model, and we CAN guarantee this when\n                    // the state is updated.\n                    cont.invokeOnCancellation(this)\n                    return@sc\n                }\n                // This `select` is in REGISTRATION phase, but there are clauses that has to be registered again.\n                // Perform the required registrations and try again.\n                curState is List<*> -> if (state.compareAndSet(curState, STATE_REG)) {\n                    @Suppress(\"UNCHECKED_CAST\")\n                    curState as List<Any>\n                    curState.forEach { reregisterClause(it) }\n                }\n                // This `select` operation became completed during clauses re-registration.\n                curState is SelectImplementation<*>.ClauseData -> {\n                    cont.resume(Unit, curState.createOnCancellationAction(this, internalResult))\n                    return@sc\n                }\n                // This `select` cannot be in any other state.\n                else -> error(\"unexpected state: $curState\")\n            }\n        }\n    }\n\n    /**\n     * Re-registers the clause with the specified\n     * [clause object][clauseObject] after unsuccessful\n     * [trySelect] of this clause while the `select`\n     * was still in REGISTRATION phase.\n     */\n    private fun reregisterClause(clauseObject: Any) {\n        val clause = findClause(clauseObject)!! // it is guaranteed that the corresponding clause is presented\n        clause.disposableHandleOrSegment = null\n        clause.indexInSegment = -1\n        clause.register(reregister = true)\n    }\n\n    // ==============\n    // = RENDEZVOUS =\n    // ==============\n\n    override fun trySelect(clauseObject: Any, result: Any?): Boolean =\n        trySelectInternal(clauseObject, result) == TRY_SELECT_SUCCESSFUL\n\n    /**\n     * Similar to [trySelect] but provides a failure reason\n     * if this rendezvous is unsuccessful. We need this function\n     * in the channel implementation.\n     */\n    fun trySelectDetailed(clauseObject: Any, result: Any?) =\n        TrySelectDetailedResult(trySelectInternal(clauseObject, result))\n\n    private fun trySelectInternal(clauseObject: Any, internalResult: Any?): Int {\n        while (true) {\n            when (val curState = state.value) {\n                // Perform a rendezvous with this select if it is in WAITING state.\n                is CancellableContinuation<*> -> {\n                    val clause = findClause(clauseObject) ?: continue // retry if `clauses` is already `null`\n                    val onCancellation = clause.createOnCancellationAction(this@SelectImplementation, internalResult)\n                    if (state.compareAndSet(curState, clause)) {\n                        @Suppress(\"UNCHECKED_CAST\")\n                        val cont = curState as CancellableContinuation<Unit>\n                        // Success! Store the resumption value and\n                        // try to resume the continuation.\n                        this.internalResult = internalResult\n                        if (cont.tryResume(onCancellation)) return TRY_SELECT_SUCCESSFUL\n                        // If the resumption failed, we need to clean the [result] field to avoid memory leaks.\n                        this.internalResult = NO_RESULT\n                        return TRY_SELECT_CANCELLED\n                    }\n                }\n                // Already selected.\n                STATE_COMPLETED, is SelectImplementation<*>.ClauseData -> return TRY_SELECT_ALREADY_SELECTED\n                // Already cancelled.\n                STATE_CANCELLED -> return TRY_SELECT_CANCELLED\n                // This select is still in REGISTRATION phase, re-register the clause\n                // in order not to wait until this select moves to WAITING phase.\n                // This is a rare race, so we do not need to worry about performance here.\n                STATE_REG -> if (state.compareAndSet(curState, listOf(clauseObject))) return TRY_SELECT_REREGISTER\n                // This select is still in REGISTRATION phase, and the state stores a list of clauses\n                // for re-registration, add the selecting clause to this list.\n                // This is a rare race, so we do not need to worry about performance here.\n                is List<*> -> if (state.compareAndSet(curState, curState + clauseObject)) return TRY_SELECT_REREGISTER\n                // Another state? Something went really wrong.\n                else -> error(\"Unexpected state: $curState\")\n            }\n        }\n    }\n\n    /**\n     * Finds the clause with the corresponding [clause object][SelectClause.clauseObject].\n     * If the reference to the list of clauses is already cleared due to completion/cancellation,\n     * this function returns `null`\n     */\n    private fun findClause(clauseObject: Any): ClauseData? {\n        // Read the list of clauses. If the `clauses` field is already `null`,\n        // the clean-up phase has already completed, and this function returns `null`.\n        val clauses = this.clauses ?: return null\n        // Find the clause with the specified clause object.\n        return clauses.find { it.clauseObject === clauseObject }\n            ?: error(\"Clause with object $clauseObject is not found\")\n    }\n\n    // ==============\n    // = COMPLETION =\n    // ==============\n\n    /**\n     * Completes this `select` operation after the internal result is provided\n     * via [SelectInstance.trySelect] or [SelectInstance.selectInRegistrationPhase].\n     * (1) First, this function applies the [ProcessResultFunction] of the selected clause\n     * to the internal result.\n     * (2) After that, the [clean-up procedure][cleanup]\n     * is called to remove this `select` instance from other clause objects, and\n     * make it possible to collect it by GC after this `select` finishes.\n     * (3) Finally, the user-specified block is invoked\n     * with the processed result as an argument.\n     */\n    private suspend fun complete(): R {\n        assert { isSelected }\n        // Get the selected clause.\n        @Suppress(\"UNCHECKED_CAST\")\n        val selectedClause = state.value as SelectImplementation<R>.ClauseData\n        // Perform the clean-up before the internal result processing and\n        // the user-specified block invocation to guarantee the absence\n        // of memory leaks. Collect the internal result before that.\n        val internalResult = this.internalResult\n        cleanup(selectedClause)\n        // Process the internal result and invoke the user's block.\n        return if (!RECOVER_STACK_TRACES) {\n            // TAIL-CALL OPTIMIZATION: the `suspend` block\n            // is invoked at the very end.\n            val blockArgument = selectedClause.processResult(internalResult)\n            selectedClause.invokeBlock(blockArgument)\n        } else {\n            // TAIL-CALL OPTIMIZATION: the `suspend`\n            // function is invoked at the very end.\n            // However, internally this `suspend` function\n            // constructs a state machine to recover a\n            // possible stack-trace.\n            processResultAndInvokeBlockRecoveringException(selectedClause, internalResult)\n        }\n    }\n\n    private suspend fun processResultAndInvokeBlockRecoveringException(clause: ClauseData, internalResult: Any?): R =\n        try {\n            val blockArgument = clause.processResult(internalResult)\n            clause.invokeBlock(blockArgument)\n        } catch (e: Throwable) {\n            // In the debug mode, we need to properly recover\n            // the stack-trace of the exception; the tail-call\n            // optimization cannot be applied here.\n            recoverAndThrow(e)\n        }\n\n    /**\n     * Invokes all [DisposableHandle]-s provided via\n     * [SelectInstance.disposeOnCompletion] during\n     * clause registrations.\n     */\n    private fun cleanup(selectedClause: ClauseData) {\n        assert { state.value == selectedClause }\n        // Read the list of clauses. If the `clauses` field is already `null`,\n        // a concurrent clean-up procedure has already completed, and it is safe to finish.\n        val clauses = this.clauses ?: return\n        // Invoke all cancellation handlers except for the\n        // one related to the selected clause, if specified.\n        clauses.forEach { clause ->\n            if (clause !== selectedClause) clause.dispose()\n        }\n        // We do need to clean all the data to avoid memory leaks.\n        this.state.value = STATE_COMPLETED\n        this.internalResult = NO_RESULT\n        this.clauses = null\n    }\n\n    // [CompletionHandler] implementation, must be invoked on cancellation.\n    override fun invoke(cause: Throwable?) {\n        // Update the state.\n        state.update { cur ->\n            // Finish immediately when this `select` is already completed.\n            // Notably, this select might be logically completed\n            // (the `state` field stores the selected `ClauseData`),\n            // while the continuation is already cancelled.\n            // We need to invoke the cancellation handler in this case.\n            if (cur === STATE_COMPLETED) return\n            STATE_CANCELLED\n        }\n        // Read the list of clauses. If the `clauses` field is already `null`,\n        // a concurrent clean-up procedure has already completed, and it is safe to finish.\n        val clauses = this.clauses ?: return\n        // Remove this `select` instance from all the clause object (channels, mutexes, etc.).\n        clauses.forEach { it.dispose() }\n        // We do need to clean all the data to avoid memory leaks.\n        this.internalResult = NO_RESULT\n        this.clauses = null\n    }\n\n    /**\n     * Each `select` clause is internally represented with a [ClauseData] instance.\n      */\n    internal inner class ClauseData(\n        @JvmField val clauseObject: Any, // the object of this `select` clause: Channel, Mutex, Job, ...\n        private val regFunc: RegistrationFunction,\n        private val processResFunc: ProcessResultFunction,\n        private val param: Any?, // the user-specified param\n        private val block: Any, // the user-specified block, which should be called if this clause becomes selected\n        @JvmField val onCancellationConstructor: OnCancellationConstructor?\n    ) {\n        @JvmField var disposableHandleOrSegment: Any? = null\n        @JvmField var indexInSegment: Int = -1\n\n        /**\n         * Tries to register the specified [select] instance in [clauseObject] and check\n         * whether the registration succeeded or a rendezvous has happened during the registration.\n         * This function returns `true` if this [select] is successfully registered and\n         * is _waiting_ for a rendezvous, or `false` when this clause becomes\n         * selected during registration.\n         *\n         * For example, the [Channel.onReceive] clause registration\n         * on a non-empty channel retrieves the first element and completes\n         * the corresponding [select] via [SelectInstance.selectInRegistrationPhase].\n         */\n        fun tryRegisterAsWaiter(select: SelectImplementation<R>): Boolean {\n            assert { select.inRegistrationPhase || select.isCancelled }\n            assert { select.internalResult === NO_RESULT }\n            regFunc(clauseObject, select, param)\n            return select.internalResult === NO_RESULT\n        }\n\n        /**\n         * Processes the internal result provided via either\n         * [SelectInstance.selectInRegistrationPhase] or\n         * [SelectInstance.trySelect] and returns an argument\n         * for the user-specified [block].\n         *\n         * Importantly, this function may throw an exception\n         * (e.g., when the channel is closed in [Channel.onSend], the\n         * corresponding [ProcessResultFunction] is bound to fail).\n         */\n        fun processResult(result: Any?) = processResFunc(clauseObject, param, result)\n\n        /**\n         * Invokes the user-specified block and returns\n         * the final result of this `select` clause.\n         */\n        @Suppress(\"UNCHECKED_CAST\")\n        suspend fun invokeBlock(argument: Any?): R {\n            val block = block\n            // We distinguish no-argument and 1-argument\n            // lambdas via special markers for the clause\n            // parameters. Specifically, PARAM_CLAUSE_0\n            // is always used with [SelectClause0], which\n            // takes a no-argument lambda.\n            //\n            // TAIL-CALL OPTIMIZATION: we invoke\n            // the `suspend` block at the very end.\n            return if (this.param === PARAM_CLAUSE_0) {\n                block as suspend () -> R\n                block()\n            } else {\n                block as suspend (Any?) -> R\n                block(argument)\n            }\n        }\n\n        fun dispose() {\n            with(disposableHandleOrSegment) {\n                if (this is Segment<*>) {\n                    this.onCancellation(indexInSegment, null, context)\n                } else {\n                    (this as? DisposableHandle)?.dispose()\n                }\n            }\n        }\n\n        fun createOnCancellationAction(select: SelectInstance<*>, internalResult: Any?) =\n            onCancellationConstructor?.invoke(select, param, internalResult)\n    }\n}\n\nprivate fun CancellableContinuation<Unit>.tryResume(onCancellation: ((cause: Throwable) -> Unit)?): Boolean {\n    val token = tryResume(Unit, null, onCancellation) ?: return false\n    completeResume(token)\n    return true\n}\n\n// trySelectInternal(..) results.\nprivate const val TRY_SELECT_SUCCESSFUL = 0\nprivate const val TRY_SELECT_REREGISTER = 1\nprivate const val TRY_SELECT_CANCELLED = 2\nprivate const val TRY_SELECT_ALREADY_SELECTED = 3\n// trySelectDetailed(..) results.\ninternal enum class TrySelectDetailedResult {\n    SUCCESSFUL, REREGISTER, CANCELLED, ALREADY_SELECTED\n}\nprivate fun TrySelectDetailedResult(trySelectInternalResult: Int): TrySelectDetailedResult = when(trySelectInternalResult) {\n    TRY_SELECT_SUCCESSFUL -> SUCCESSFUL\n    TRY_SELECT_REREGISTER -> REREGISTER\n    TRY_SELECT_CANCELLED -> CANCELLED\n    TRY_SELECT_ALREADY_SELECTED -> ALREADY_SELECTED\n    else -> error(\"Unexpected internal result: $trySelectInternalResult\")\n}\n\n// Markers for REGISTRATION, COMPLETED, and CANCELLED states.\nprivate val STATE_REG = Symbol(\"STATE_REG\")\nprivate val STATE_COMPLETED = Symbol(\"STATE_COMPLETED\")\nprivate val STATE_CANCELLED = Symbol(\"STATE_CANCELLED\")\n// As the selection result is nullable, we use this special\n// marker for the absence of result.\nprivate val NO_RESULT = Symbol(\"NO_RESULT\")\n// We use this marker parameter objects to distinguish\n// SelectClause[0,1,2] and invoke the user-specified block correctly.\ninternal val PARAM_CLAUSE_0 = Symbol(\"PARAM_CLAUSE_0\")\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/selects/SelectOld.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n/*\n * For binary compatibility, we need to maintain the previous `select` implementations.\n * Thus, we keep [SelectBuilderImpl] and [UnbiasedSelectBuilderImpl] and implement the\n * functions marked with `@PublishedApi`.\n *\n * We keep the old `select` functions as [selectOld] and [selectUnbiasedOld] for test purpose.\n */\n\n@PublishedApi\ninternal class SelectBuilderImpl<R>(\n    uCont: Continuation<R> // unintercepted delegate continuation\n) : SelectImplementation<R>(uCont.context) {\n    private val cont = CancellableContinuationImpl(uCont.intercepted(), MODE_CANCELLABLE)\n\n    @PublishedApi\n    internal fun getResult(): Any? {\n        // In the current `select` design, the [select] and [selectUnbiased] functions\n        // do not wrap the operation in `suspendCoroutineUninterceptedOrReturn` and\n        // suspend explicitly via [doSelect] call, which returns the final result.\n        // However, [doSelect] is a suspend function, so it cannot be invoked directly.\n        // In addition, the `select` builder is eligible to throw an exception, which\n        // should be handled properly.\n        //\n        // As a solution, we:\n        // 1) check whether the `select` building is already completed with exception, finishing immediately in this case;\n        // 2) create a CancellableContinuationImpl with the provided unintercepted continuation as a delegate;\n        // 3) wrap the [doSelect] call in an additional coroutine, which we launch in UNDISPATCHED mode;\n        // 4) resume the created CancellableContinuationImpl after the [doSelect] invocation completes;\n        // 5) use CancellableContinuationImpl.getResult() as a result of this function.\n        if (cont.isCompleted) return cont.getResult()\n        CoroutineScope(context).launch(start = CoroutineStart.UNDISPATCHED) {\n            val result = try {\n                doSelect()\n            } catch (e: Throwable) {\n                cont.resumeUndispatchedWithException(e)\n                return@launch\n            }\n            cont.resumeUndispatched(result)\n        }\n        return cont.getResult()\n    }\n\n    @PublishedApi\n    internal fun handleBuilderException(e: Throwable) {\n        cont.resumeWithException(e) // will be thrown later via `cont.getResult()`\n    }\n}\n\n@PublishedApi\ninternal class UnbiasedSelectBuilderImpl<R>(\n    uCont: Continuation<R> // unintercepted delegate continuation\n) : UnbiasedSelectImplementation<R>(uCont.context) {\n    private val cont = CancellableContinuationImpl(uCont.intercepted(), MODE_CANCELLABLE)\n\n    @PublishedApi\n    internal fun initSelectResult(): Any? {\n        // Here, we do the same trick as in [SelectBuilderImpl].\n        if (cont.isCompleted) return cont.getResult()\n        CoroutineScope(context).launch(start = CoroutineStart.UNDISPATCHED) {\n            val result = try {\n                doSelect()\n            } catch (e: Throwable) {\n                cont.resumeUndispatchedWithException(e)\n                return@launch\n            }\n            cont.resumeUndispatched(result)\n        }\n        return cont.getResult()\n    }\n\n    @PublishedApi\n    internal fun handleBuilderException(e: Throwable) {\n        cont.resumeWithException(e)\n    }\n}\n\n/*\n * This is the old version of `select`. It should work to guarantee binary compatibility.\n *\n * Internal note:\n * We do test it manually by changing the implementation of **new** select with the following:\n * ```\n * public suspend inline fun <R> select(crossinline builder: SelectBuilder<R>.() -> Unit): R {\n *     contract {\n *         callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n *     }\n *     return selectOld(builder)\n * }\n * ```\n *\n * These signatures are not used by the already compiled code, but their body is.\n */\n@PublishedApi\ninternal suspend inline fun <R> selectOld(crossinline builder: SelectBuilder<R>.() -> Unit): R {\n    return suspendCoroutineUninterceptedOrReturn { uCont ->\n        val scope = SelectBuilderImpl(uCont)\n        try {\n            builder(scope)\n        } catch (e: Throwable) {\n            scope.handleBuilderException(e)\n        }\n        scope.getResult()\n    }\n}\n\n// This is the old version of `selectUnbiased`. It should work to guarantee binary compatibility.\n@PublishedApi\ninternal suspend inline fun <R> selectUnbiasedOld(crossinline builder: SelectBuilder<R>.() -> Unit): R =\n    suspendCoroutineUninterceptedOrReturn { uCont ->\n        val scope = UnbiasedSelectBuilderImpl(uCont)\n        try {\n            builder(scope)\n        } catch (e: Throwable) {\n            scope.handleBuilderException(e)\n        }\n        scope.initSelectResult()\n    }\n\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun <T> CancellableContinuation<T>.resumeUndispatched(result: T) {\n    val dispatcher = context[CoroutineDispatcher]\n    if (dispatcher != null) {\n        dispatcher.resumeUndispatched(result)\n    } else {\n        resume(result)\n    }\n}\n\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun CancellableContinuation<*>.resumeUndispatchedWithException(exception: Throwable) {\n    val dispatcher = context[CoroutineDispatcher]\n    if (dispatcher != null) {\n        dispatcher.resumeUndispatchedWithException(exception)\n    } else {\n        resumeWithException(exception)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/selects/SelectUnbiased.kt",
        "content": "@file:OptIn(ExperimentalContracts::class)\n\npackage kotlinx.coroutines.selects\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\n\n/**\n * Waits for the result of multiple suspending functions simultaneously like [select], but in an _unbiased_\n * way when multiple clauses are selectable at the same time.\n *\n * This unbiased implementation of `select` expression randomly shuffles the clauses before checking\n * if they are selectable, thus ensuring that there is no statistical bias to the selection of the first\n * clauses.\n *\n * See [select] function description for all the other details.\n */\n@OptIn(ExperimentalContracts::class)\npublic suspend inline fun <R> selectUnbiased(crossinline builder: SelectBuilder<R>.() -> Unit): R {\n    contract {\n        callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n    }\n    return UnbiasedSelectImplementation<R>(coroutineContext).run {\n        builder(this)\n        doSelect()\n    }\n}\n\n/**\n * The unbiased `select` inherits the [standard one][SelectImplementation],\n * but does not register clauses immediately. Instead, it stores all of them\n * in [clausesToRegister] lists, shuffles and registers them in the beginning of [doSelect]\n * (see [shuffleAndRegisterClauses]), and then delegates the rest\n * to the parent's [doSelect] implementation.\n */\n@PublishedApi\ninternal open class UnbiasedSelectImplementation<R>(context: CoroutineContext) : SelectImplementation<R>(context) {\n    private val clausesToRegister: MutableList<ClauseData> = arrayListOf()\n\n    override fun SelectClause0.invoke(block: suspend () -> R) {\n        clausesToRegister += ClauseData(clauseObject, regFunc, processResFunc, PARAM_CLAUSE_0, block, onCancellationConstructor)\n    }\n\n    override fun <Q> SelectClause1<Q>.invoke(block: suspend (Q) -> R) {\n        clausesToRegister += ClauseData(clauseObject, regFunc, processResFunc, null, block, onCancellationConstructor)\n    }\n\n    override fun <P, Q> SelectClause2<P, Q>.invoke(param: P, block: suspend (Q) -> R) {\n        clausesToRegister += ClauseData(clauseObject, regFunc, processResFunc, param, block, onCancellationConstructor)\n    }\n\n    @PublishedApi\n    override suspend fun doSelect(): R {\n        shuffleAndRegisterClauses()\n        return super.doSelect()\n    }\n\n    private fun shuffleAndRegisterClauses() = try {\n        clausesToRegister.shuffle()\n        clausesToRegister.forEach { it.register() }\n    } finally {\n        clausesToRegister.clear()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/selects/WhileSelect.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.*\n\n/**\n * Loops while [select] expression returns `true`.\n *\n * The statement of the form:\n *\n * ```\n * whileSelect {\n *     /*body*/\n * }\n * ```\n *\n * is a shortcut for:\n *\n * ```\n * while(select<Boolean> {\n *    /*body*/\n * }) {}\n *\n * **Note: This is an experimental api.** It may be replaced with a higher-performance DSL for selection from loops.\n */\n@ExperimentalCoroutinesApi\npublic suspend inline fun whileSelect(crossinline builder: SelectBuilder<Boolean>.() -> Unit) {\n    while(select(builder)) { /* do nothing */ }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/sync/Mutex.kt",
        "content": "package kotlinx.coroutines.sync\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.contracts.*\nimport kotlin.jvm.*\n\n/**\n * Mutual exclusion for coroutines.\n *\n * Mutex has two states: _locked_ and _unlocked_.\n * It is **non-reentrant**, that is invoking [lock] even from the same thread/coroutine that currently holds\n * the lock still suspends the invoker.\n *\n * JVM API note:\n * Memory semantic of the [Mutex] is similar to `synchronized` block on JVM:\n * An unlock operation on a [Mutex] happens-before every subsequent successful lock on that [Mutex].\n * Unsuccessful call to [tryLock] do not have any memory effects.\n */\npublic interface Mutex {\n    /**\n     * Returns `true` if this mutex is locked.\n     */\n    public val isLocked: Boolean\n\n    /**\n     * Tries to lock this mutex, returning `false` if this mutex is already locked.\n     *\n     * It is recommended to use [withLock] for safety reasons, so that the acquired lock is always\n     * released at the end of your critical section, and [unlock] is never invoked before a successful\n     * lock acquisition.\n     *\n     * @param owner Optional owner token for debugging. When `owner` is specified (non-null value) and this mutex\n     *        is already locked with the same token (same identity), this function throws [IllegalStateException].\n     */\n    public fun tryLock(owner: Any? = null): Boolean\n\n    /**\n     * Locks this mutex, suspending caller until the lock is acquired (in other words, while the lock is held elsewhere).\n     *\n     * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n     * suspending function is waiting, this function immediately resumes with [CancellationException].\n     * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n     * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n     * This function releases the lock if it was already acquired by this function before the [CancellationException]\n     * was thrown.\n     *\n     * Note that this function does not check for cancellation when it is not suspended.\n     * Use [yield] or [CoroutineScope.isActive] to periodically check for cancellation in tight loops if needed.\n     *\n     * Use [tryLock] to try acquiring the lock without waiting.\n     *\n     * This function is fair; suspended callers are resumed in first-in-first-out order.\n     *\n     * It is recommended to use [withLock] for safety reasons, so that the acquired lock is always\n     * released at the end of the critical section, and [unlock] is never invoked before a successful\n     * lock acquisition.\n     *\n     * @param owner Optional owner token for debugging. When `owner` is specified (non-null value) and this mutex\n     *        is already locked with the same token (same identity), this function throws [IllegalStateException].\n     */\n    public suspend fun lock(owner: Any? = null)\n\n    /**\n     * Clause for [select] expression of [lock] suspending function that selects when the mutex is locked.\n     * Additional parameter for the clause in the `owner` (see [lock]) and when the clause is selected\n     * the reference to this mutex is passed into the corresponding block.\n     */\n    @Deprecated(level = DeprecationLevel.WARNING, message = \"Mutex.onLock deprecated without replacement. \" +\n        \"For additional details please refer to #2794\") // WARNING since 1.6.0\n    public val onLock: SelectClause2<Any?, Mutex>\n\n    /**\n     * Checks whether this mutex is locked by the specified owner.\n     *\n     * @return `true` when this mutex is locked by the specified owner;\n     * `false` if the mutex is not locked or locked by another owner.\n     */\n    public fun holdsLock(owner: Any): Boolean\n\n    /**\n     * Unlocks this mutex. Throws [IllegalStateException] if invoked on a mutex that is not locked or\n     * was locked with a different owner token (by identity).\n     *\n     * It is recommended to use [withLock] for safety reasons, so that the acquired lock is always\n     * released at the end of the critical section, and [unlock] is never invoked before a successful\n     * lock acquisition.\n     *\n     * @param owner Optional owner token for debugging. When `owner` is specified (non-null value) and this mutex\n     *        was locked with the different token (by identity), this function throws [IllegalStateException].\n     */\n    public fun unlock(owner: Any? = null)\n}\n\n/**\n * Creates a [Mutex] instance.\n * The mutex created is fair: lock is granted in first come, first served order.\n *\n * @param locked initial state of the mutex.\n */\n@Suppress(\"FunctionName\")\npublic fun Mutex(locked: Boolean = false): Mutex =\n    MutexImpl(locked)\n\n/**\n * Executes the given [action] under this mutex's lock.\n *\n * @param owner Optional owner token for debugging. When `owner` is specified (non-null value) and this mutex\n *        is already locked with the same token (same identity), this function throws [IllegalStateException].\n *\n * @return the return value of the action.\n */\n@OptIn(ExperimentalContracts::class)\npublic suspend inline fun <T> Mutex.withLock(owner: Any? = null, action: () -> T): T {\n    contract {\n        callsInPlace(action, InvocationKind.EXACTLY_ONCE)\n    }\n    lock(owner)\n    return try {\n        action()\n    } finally {\n        unlock(owner)\n    }\n}\n\n\ninternal open class MutexImpl(locked: Boolean) : SemaphoreImpl(1, if (locked) 1 else 0), Mutex {\n    /**\n     * After the lock is acquired, the corresponding owner is stored in this field.\n     * The [unlock] operation checks the owner and either re-sets it to [NO_OWNER],\n     * if there is no waiting request, or to the owner of the suspended [lock] operation\n     * to be resumed, otherwise.\n     */\n    private val owner = atomic<Any?>(if (locked) null else NO_OWNER)\n\n    private val onSelectCancellationUnlockConstructor: OnCancellationConstructor =\n        { _: SelectInstance<*>, owner: Any?, _: Any? ->\n            { unlock(owner) }\n        }\n\n    override val isLocked: Boolean get() =\n        availablePermits == 0\n\n    override fun holdsLock(owner: Any): Boolean = holdsLockImpl(owner) == HOLDS_LOCK_YES\n\n    /**\n     * [HOLDS_LOCK_UNLOCKED] if the mutex is unlocked\n     * [HOLDS_LOCK_YES] if the mutex is held with the specified [owner]\n     * [HOLDS_LOCK_ANOTHER_OWNER] if the mutex is held with a different owner\n     */\n    private fun holdsLockImpl(owner: Any?): Int {\n        while (true) {\n            // Is this mutex locked?\n            if (!isLocked) return HOLDS_LOCK_UNLOCKED\n            val curOwner = this.owner.value\n            // Wait in a spin-loop until the owner is set\n            if (curOwner === NO_OWNER) continue // <-- ATTENTION, BLOCKING PART HERE\n            // Check the owner\n            return if (curOwner === owner) HOLDS_LOCK_YES else HOLDS_LOCK_ANOTHER_OWNER\n        }\n    }\n\n    override suspend fun lock(owner: Any?) {\n        if (tryLock(owner)) return\n        lockSuspend(owner)\n    }\n\n    private suspend fun lockSuspend(owner: Any?) = suspendCancellableCoroutineReusable<Unit> { cont ->\n        val contWithOwner = CancellableContinuationWithOwner(cont, owner)\n        acquire(contWithOwner)\n    }\n\n    override fun tryLock(owner: Any?): Boolean = when (tryLockImpl(owner)) {\n        TRY_LOCK_SUCCESS -> true\n        TRY_LOCK_FAILED -> false\n        TRY_LOCK_ALREADY_LOCKED_BY_OWNER -> error(\"This mutex is already locked by the specified owner: $owner\")\n        else -> error(\"unexpected\")\n    }\n\n    private fun tryLockImpl(owner: Any?): Int {\n        while (true) {\n            if (tryAcquire()) {\n                assert { this.owner.value === NO_OWNER }\n                this.owner.value = owner\n                return TRY_LOCK_SUCCESS\n            } else {\n                // The semaphore permit acquisition has failed.\n                // However, we need to check that this mutex is not\n                // locked by our owner.\n                if (owner == null) return TRY_LOCK_FAILED\n                when (holdsLockImpl(owner)) {\n                    // This mutex is already locked by our owner.\n                    HOLDS_LOCK_YES -> return TRY_LOCK_ALREADY_LOCKED_BY_OWNER\n                    // This mutex is locked by another owner, `trylock(..)` must return `false`.\n                    HOLDS_LOCK_ANOTHER_OWNER -> return TRY_LOCK_FAILED\n                    // This mutex is no longer locked, restart the operation.\n                    HOLDS_LOCK_UNLOCKED -> continue\n                }\n            }\n        }\n    }\n\n    override fun unlock(owner: Any?) {\n        while (true) {\n            // Is this mutex locked?\n            check(isLocked) { \"This mutex is not locked\" }\n            // Read the owner, waiting until it is set in a spin-loop if required.\n            val curOwner = this.owner.value\n            if (curOwner === NO_OWNER) continue // <-- ATTENTION, BLOCKING PART HERE\n            // Check the owner.\n            check(curOwner === owner || owner == null) { \"This mutex is locked by $curOwner, but $owner is expected\" }\n            // Try to clean the owner first. We need to use CAS here to synchronize with concurrent `unlock(..)`-s.\n            if (!this.owner.compareAndSet(curOwner, NO_OWNER)) continue\n            // Release the semaphore permit at the end.\n            release()\n            return\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\", \"OverridingDeprecatedMember\", \"OVERRIDE_DEPRECATION\")\n    override val onLock: SelectClause2<Any?, Mutex> get() = SelectClause2Impl(\n        clauseObject = this,\n        regFunc = MutexImpl::onLockRegFunction as RegistrationFunction,\n        processResFunc = MutexImpl::onLockProcessResult as ProcessResultFunction,\n        onCancellationConstructor = onSelectCancellationUnlockConstructor\n    )\n\n    protected open fun onLockRegFunction(select: SelectInstance<*>, owner: Any?) {\n        if (owner != null && holdsLock(owner)) {\n            select.selectInRegistrationPhase(ON_LOCK_ALREADY_LOCKED_BY_OWNER)\n        } else {\n            onAcquireRegFunction(SelectInstanceWithOwner(select as SelectInstanceInternal<*>, owner), owner)\n        }\n    }\n\n    protected open fun onLockProcessResult(owner: Any?, result: Any?): Any? {\n        if (result == ON_LOCK_ALREADY_LOCKED_BY_OWNER) {\n            error(\"This mutex is already locked by the specified owner: $owner\")\n        }\n        return this\n    }\n\n    private inner class CancellableContinuationWithOwner(\n        @JvmField\n        val cont: CancellableContinuationImpl<Unit>,\n        @JvmField\n        val owner: Any?\n    ) : CancellableContinuation<Unit> by cont, Waiter by cont {\n        override fun tryResume(value: Unit, idempotent: Any?, onCancellation: ((cause: Throwable) -> Unit)?): Any? {\n            assert { this@MutexImpl.owner.value === NO_OWNER }\n            val token = cont.tryResume(value, idempotent) {\n                assert { this@MutexImpl.owner.value.let { it === NO_OWNER ||it === owner } }\n                this@MutexImpl.owner.value = owner\n                unlock(owner)\n            }\n            if (token != null) {\n                assert { this@MutexImpl.owner.value === NO_OWNER }\n                this@MutexImpl.owner.value = owner\n            }\n            return token\n        }\n\n        override fun resume(value: Unit, onCancellation: ((cause: Throwable) -> Unit)?) {\n            assert { this@MutexImpl.owner.value === NO_OWNER }\n            this@MutexImpl.owner.value = owner\n            cont.resume(value) { unlock(owner) }\n        }\n    }\n\n    private inner class SelectInstanceWithOwner<Q>(\n        @JvmField\n        val select: SelectInstanceInternal<Q>,\n        @JvmField\n        val owner: Any?\n    ) : SelectInstanceInternal<Q> by select {\n        override fun trySelect(clauseObject: Any, result: Any?): Boolean {\n            assert { this@MutexImpl.owner.value === NO_OWNER }\n            return select.trySelect(clauseObject, result).also { success ->\n                if (success) this@MutexImpl.owner.value = owner\n            }\n        }\n\n        override fun selectInRegistrationPhase(internalResult: Any?) {\n            assert { this@MutexImpl.owner.value === NO_OWNER }\n            this@MutexImpl.owner.value = owner\n            select.selectInRegistrationPhase(internalResult)\n        }\n    }\n\n    override fun toString() = \"Mutex@${hexAddress}[isLocked=$isLocked,owner=${owner.value}]\"\n}\n\nprivate val NO_OWNER = Symbol(\"NO_OWNER\")\nprivate val ON_LOCK_ALREADY_LOCKED_BY_OWNER = Symbol(\"ALREADY_LOCKED_BY_OWNER\")\n\nprivate const val TRY_LOCK_SUCCESS = 0\nprivate const val TRY_LOCK_FAILED = 1\nprivate const val TRY_LOCK_ALREADY_LOCKED_BY_OWNER = 2\n\nprivate const val HOLDS_LOCK_UNLOCKED = 0\nprivate const val HOLDS_LOCK_YES = 1\nprivate const val HOLDS_LOCK_ANOTHER_OWNER = 2\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/src/sync/Semaphore.kt",
        "content": "package kotlinx.coroutines.sync\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.js.*\nimport kotlin.math.*\n\n/**\n * A counting semaphore for coroutines that logically maintains a number of available permits.\n * Each [acquire] takes a single permit or suspends until it is available.\n * Each [release] adds a permit, potentially releasing a suspended acquirer.\n * Semaphore is fair and maintains a FIFO order of acquirers.\n *\n * Semaphores are mostly used to limit the number of coroutines that have access to particular resource.\n * Semaphore with `permits = 1` is essentially a [Mutex].\n **/\npublic interface Semaphore {\n    /**\n     * Returns the current number of permits available in this semaphore.\n     */\n    public val availablePermits: Int\n\n    /**\n     * Acquires a permit from this semaphore, suspending until one is available.\n     * All suspending acquirers are processed in first-in-first-out (FIFO) order.\n     *\n     * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n     * suspending function is waiting, this function immediately resumes with [CancellationException].\n     * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n     * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n     * This function releases the semaphore if it was already acquired by this function before the [CancellationException]\n     * was thrown.\n     *\n     * Note that this function does not check for cancellation when it does not suspend.\n     * Use [CoroutineScope.isActive] or [CoroutineScope.ensureActive] to periodically\n     * check for cancellation in tight loops if needed.\n     *\n     * Use [tryAcquire] to try to acquire a permit of this semaphore without suspension.\n     */\n    public suspend fun acquire()\n\n    /**\n     * Tries to acquire a permit from this semaphore without suspension.\n     *\n     * @return `true` if a permit was acquired, `false` otherwise.\n     */\n    public fun tryAcquire(): Boolean\n\n    /**\n     * Releases a permit, returning it into this semaphore. Resumes the first\n     * suspending acquirer if there is one at the point of invocation.\n     * Throws [IllegalStateException] if the number of [release] invocations is greater than the number of preceding [acquire].\n     */\n    public fun release()\n}\n\n/**\n * Creates new [Semaphore] instance.\n * @param permits the number of permits available in this semaphore.\n * @param acquiredPermits the number of already acquired permits,\n *        should be between `0` and `permits` (inclusively).\n */\n@Suppress(\"FunctionName\")\npublic fun Semaphore(permits: Int, acquiredPermits: Int = 0): Semaphore = SemaphoreImpl(permits, acquiredPermits)\n\n/**\n * Executes the given [action], acquiring a permit from this semaphore at the beginning\n * and releasing it after the [action] is completed.\n *\n * @return the return value of the [action].\n */\n@OptIn(ExperimentalContracts::class)\npublic suspend inline fun <T> Semaphore.withPermit(action: () -> T): T {\n    contract {\n        callsInPlace(action, InvocationKind.EXACTLY_ONCE)\n    }\n    acquire()\n    return try {\n        action()\n    } finally {\n        release()\n    }\n}\n\n@Suppress(\"UNCHECKED_CAST\")\ninternal open class SemaphoreImpl(private val permits: Int, acquiredPermits: Int) : Semaphore {\n    /*\n       The queue of waiting acquirers is essentially an infinite array based on the list of segments\n       (see `SemaphoreSegment`); each segment contains a fixed number of slots. To determine a slot for each enqueue\n       and dequeue operation, we increment the corresponding counter at the beginning of the operation\n       and use the value before the increment as a slot number. This way, each enqueue-dequeue pair\n       works with an individual cell. We use the corresponding segment pointers to find the required ones.\n\n       Here is a state machine for cells. Note that only one `acquire` and at most one `release` operation\n       can deal with each cell, and that `release` uses `getAndSet(PERMIT)` to perform transitions for performance reasons\n       so that the state `PERMIT` represents different logical states.\n\n         +------+ `acquire` suspends   +------+   `release` tries    +--------+                    // if `cont.tryResume(..)` succeeds, then\n         | NULL | -------------------> | cont | -------------------> | PERMIT | (cont RETRIEVED)   // the corresponding `acquire` operation gets\n         +------+                      +------+   to resume `cont`   +--------+                    // a permit and the `release` one completes.\n            |                             |\n            |                             | `acquire` request is cancelled and the continuation is\n            | `release` comes             | replaced with a special `CANCEL` token to avoid memory leaks\n            | to the slot before          V\n            | `acquire` and puts    +-----------+   `release` has    +--------+\n            | a permit into the     | CANCELLED | -----------------> | PERMIT | (RElEASE FAILED)\n            | slot, waiting for     +-----------+        failed      +--------+\n            | `acquire` after\n            | that.\n            |\n            |           `acquire` gets   +-------+\n            |        +-----------------> | TAKEN | (ELIMINATION HAPPENED)\n            V        |    the permit     +-------+\n        +--------+   |\n        | PERMIT | -<\n        +--------+  |\n                    |  `release` has waited a bounded time,   +--------+\n                    +---------------------------------------> | BROKEN | (BOTH RELEASE AND ACQUIRE FAILED)\n                           but `acquire` has not come         +--------+\n    */\n\n    private val head: AtomicRef<SemaphoreSegment>\n    private val deqIdx = atomic(0L)\n    private val tail: AtomicRef<SemaphoreSegment>\n    private val enqIdx = atomic(0L)\n\n    init {\n        require(permits > 0) { \"Semaphore should have at least 1 permit, but had $permits\" }\n        require(acquiredPermits in 0..permits) { \"The number of acquired permits should be in 0..$permits\" }\n        val s = SemaphoreSegment(0, null, 2)\n        head = atomic(s)\n        tail = atomic(s)\n    }\n\n    /**\n     * This counter indicates the number of available permits if it is positive,\n     * or the negated number of waiters on this semaphore otherwise.\n     * Note, that 32-bit counter is enough here since the maximal number of available\n     * permits is [permits] which is [Int], and the maximum number of waiting acquirers\n     * cannot be greater than 2^31 in any real application.\n     */\n    private val _availablePermits = atomic(permits - acquiredPermits)\n    override val availablePermits: Int get() = max(_availablePermits.value, 0)\n\n    private val onCancellationRelease = { _: Throwable -> release() }\n\n    override fun tryAcquire(): Boolean {\n        while (true) {\n            // Get the current number of available permits.\n            val p = _availablePermits.value\n            // Is the number of available permits greater\n            // than the maximal one because of an incorrect\n            // `release()` call without a preceding `acquire()`?\n            // Change it to `permits` and start from the beginning.\n            if (p > permits) {\n                coerceAvailablePermitsAtMaximum()\n                continue\n            }\n            // Try to decrement the number of available\n            // permits if it is greater than zero.\n            if (p <= 0) return false\n            if (_availablePermits.compareAndSet(p, p - 1)) return true\n        }\n    }\n\n    override suspend fun acquire() {\n        // Decrement the number of available permits.\n        val p = decPermits()\n        // Is the permit acquired?\n        if (p > 0) return // permit acquired\n        // Try to suspend otherwise.\n        // While it looks better when the following function is inlined,\n        // it is important to make `suspend` function invocations in a way\n        // so that the tail-call optimization can be applied here.\n        acquireSlowPath()\n    }\n\n    private suspend fun acquireSlowPath() = suspendCancellableCoroutineReusable<Unit> sc@ { cont ->\n        // Try to suspend.\n        if (addAcquireToQueue(cont)) return@sc\n        // The suspension has been failed\n        // due to the synchronous resumption mode.\n        // Restart the whole `acquire`.\n        acquire(cont)\n    }\n\n    @JsName(\"acquireCont\")\n    protected fun acquire(waiter: CancellableContinuation<Unit>) = acquire(\n        waiter = waiter,\n        suspend = { cont -> addAcquireToQueue(cont as Waiter) },\n        onAcquired = { cont -> cont.resume(Unit, onCancellationRelease) }\n    )\n\n    @JsName(\"acquireInternal\")\n    private inline fun <W> acquire(waiter: W, suspend: (waiter: W) -> Boolean, onAcquired: (waiter: W) -> Unit) {\n        while (true) {\n            // Decrement the number of available permits at first.\n            val p = decPermits()\n            // Is the permit acquired?\n            if (p > 0) {\n                onAcquired(waiter)\n                return\n            }\n            // Permit has not been acquired, try to suspend.\n            if (suspend(waiter)) return\n        }\n    }\n\n    // We do not fully support `onAcquire` as it is needed only for `Mutex.onLock`.\n    @Suppress(\"UNUSED_PARAMETER\")\n    protected fun onAcquireRegFunction(select: SelectInstance<*>, ignoredParam: Any?) =\n        acquire(\n            waiter = select,\n            suspend = { s -> addAcquireToQueue(s as Waiter) },\n            onAcquired = { s -> s.selectInRegistrationPhase(Unit) }\n        )\n\n    /**\n     * Decrements the number of available permits\n     * and ensures that it is not greater than [permits]\n     * at the point of decrement. The last may happen\n     * due to an incorrect `release()` call without\n     * a preceding `acquire()`.\n     */\n    private fun decPermits(): Int {\n        while (true) {\n            // Decrement the number of available permits.\n            val p = _availablePermits.getAndDecrement()\n            // Is the number of available permits greater\n            // than the maximal one due to an incorrect\n            // `release()` call without a preceding `acquire()`?\n            if (p > permits) continue\n            // The number of permits is correct, return it.\n            return p\n        }\n    }\n\n    override fun release() {\n        while (true) {\n            // Increment the number of available permits.\n            val p = _availablePermits.getAndIncrement()\n            // Is this `release` call correct and does not\n            // exceed the maximal number of permits?\n            if (p >= permits) {\n                // Revert the number of available permits\n                // back to the correct one and fail with error.\n                coerceAvailablePermitsAtMaximum()\n                error(\"The number of released permits cannot be greater than $permits\")\n            }\n            // Is there a waiter that should be resumed?\n            if (p >= 0) return\n            // Try to resume the first waiter, and\n            // restart the operation if either this\n            // first waiter is cancelled or\n            // due to `SYNC` resumption mode.\n            if (tryResumeNextFromQueue()) return\n        }\n    }\n\n    /**\n     * Changes the number of available permits to\n     * [permits] if it became greater due to an\n     * incorrect [release] call.\n     */\n    private fun coerceAvailablePermitsAtMaximum() {\n        while (true) {\n            val cur = _availablePermits.value\n            if (cur <= permits) break\n            if (_availablePermits.compareAndSet(cur, permits)) break\n        }\n    }\n\n    /**\n     * Returns `false` if the received permit cannot be used and the calling operation should restart.\n     */\n    private fun addAcquireToQueue(waiter: Waiter): Boolean {\n        val curTail = this.tail.value\n        val enqIdx = enqIdx.getAndIncrement()\n        val createNewSegment = ::createSegment\n        val segment = this.tail.findSegmentAndMoveForward(id = enqIdx / SEGMENT_SIZE, startFrom = curTail,\n            createNewSegment = createNewSegment).segment // cannot be closed\n        val i = (enqIdx % SEGMENT_SIZE).toInt()\n        // the regular (fast) path -- if the cell is empty, try to install continuation\n        if (segment.cas(i, null, waiter)) { // installed continuation successfully\n            waiter.invokeOnCancellation(segment, i)\n            return true\n        }\n        // On CAS failure -- the cell must be either PERMIT or BROKEN\n        // If the cell already has PERMIT from tryResumeNextFromQueue, try to grab it\n        if (segment.cas(i, PERMIT, TAKEN)) { // took permit thus eliminating acquire/release pair\n            /// This continuation is not yet published, but still can be cancelled via outer job\n            when (waiter) {\n                is CancellableContinuation<*> -> {\n                    waiter as CancellableContinuation<Unit>\n                    waiter.resume(Unit, onCancellationRelease)\n                }\n                is SelectInstance<*> -> {\n                    waiter.selectInRegistrationPhase(Unit)\n                }\n                else -> error(\"unexpected: $waiter\")\n            }\n            return true\n        }\n        assert { segment.get(i) === BROKEN } // it must be broken in this case, no other way around it\n        return false // broken cell, need to retry on a different cell\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun tryResumeNextFromQueue(): Boolean {\n        val curHead = this.head.value\n        val deqIdx = deqIdx.getAndIncrement()\n        val id = deqIdx / SEGMENT_SIZE\n        val createNewSegment = ::createSegment\n        val segment = this.head.findSegmentAndMoveForward(id, startFrom = curHead,\n            createNewSegment = createNewSegment).segment // cannot be closed\n        segment.cleanPrev()\n        if (segment.id > id) return false\n        val i = (deqIdx % SEGMENT_SIZE).toInt()\n        val cellState = segment.getAndSet(i, PERMIT) // set PERMIT and retrieve the prev cell state\n        when {\n            cellState === null -> {\n                // Acquire has not touched this cell yet, wait until it comes for a bounded time\n                // The cell state can only transition from PERMIT to TAKEN by addAcquireToQueue\n                repeat(MAX_SPIN_CYCLES) {\n                    if (segment.get(i) === TAKEN) return true\n                }\n                // Try to break the slot in order not to wait\n                return !segment.cas(i, PERMIT, BROKEN)\n            }\n            cellState === CANCELLED -> return false // the acquirer has already been cancelled\n            else -> return cellState.tryResumeAcquire()\n        }\n    }\n\n    private fun Any.tryResumeAcquire(): Boolean = when(this) {\n        is CancellableContinuation<*> -> {\n            this as CancellableContinuation<Unit>\n            val token = tryResume(Unit, null, onCancellationRelease)\n            if (token != null) {\n                completeResume(token)\n                true\n            } else false\n        }\n        is SelectInstance<*> -> {\n            trySelect(this@SemaphoreImpl, Unit)\n        }\n        else -> error(\"unexpected: $this\")\n    }\n}\n\nprivate fun createSegment(id: Long, prev: SemaphoreSegment?) = SemaphoreSegment(id, prev, 0)\n\nprivate class SemaphoreSegment(id: Long, prev: SemaphoreSegment?, pointers: Int) : Segment<SemaphoreSegment>(id, prev, pointers) {\n    val acquirers = atomicArrayOfNulls<Any?>(SEGMENT_SIZE)\n    override val numberOfSlots: Int get() = SEGMENT_SIZE\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    inline fun get(index: Int): Any? = acquirers[index].value\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    inline fun set(index: Int, value: Any?) {\n        acquirers[index].value = value\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    inline fun cas(index: Int, expected: Any?, value: Any?): Boolean = acquirers[index].compareAndSet(expected, value)\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    inline fun getAndSet(index: Int, value: Any?) = acquirers[index].getAndSet(value)\n\n    // Cleans the acquirer slot located by the specified index\n    // and removes this segment physically if all slots are cleaned.\n    override fun onCancellation(index: Int, cause: Throwable?, context: CoroutineContext) {\n        // Clean the slot\n        set(index, CANCELLED)\n        // Remove this segment if needed\n        onSlotCleaned()\n    }\n\n    override fun toString() = \"SemaphoreSegment[id=$id, hashCode=${hashCode()}]\"\n}\nprivate val MAX_SPIN_CYCLES = systemProp(\"kotlinx.coroutines.semaphore.maxSpinCycles\", 100)\nprivate val PERMIT = Symbol(\"PERMIT\")\nprivate val TAKEN = Symbol(\"TAKEN\")\nprivate val BROKEN = Symbol(\"BROKEN\")\nprivate val CANCELLED = Symbol(\"CANCELLED\")\nprivate val SEGMENT_SIZE = systemProp(\"kotlinx.coroutines.semaphore.segmentSize\", 16)\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/AbstractCoroutineTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@Suppress(\"DEPRECATION\") // cancel(cause)\nclass AbstractCoroutineTest : TestBase() {\n    @Test\n    fun testNotifications() = runTest {\n        expect(1)\n        val coroutineContext = coroutineContext // workaround for KT-22984\n        val coroutine = object : AbstractCoroutine<String>(coroutineContext, true, false) {\n            override fun onStart() {\n                expect(3)\n            }\n\n            override fun onCancelling(cause: Throwable?) {\n                assertNull(cause)\n                expect(5)\n            }\n\n            override fun onCompleted(value: String) {\n                assertEquals(\"OK\", value)\n                expect(6)\n            }\n\n            override fun onCancelled(cause: Throwable, handled: Boolean) {\n                expectUnreached()\n            }\n        }\n\n        coroutine.invokeOnCompletion(onCancelling = true) {\n            assertNull(it)\n            expect(7)\n        }\n\n        coroutine.invokeOnCompletion {\n            assertNull(it)\n            expect(8)\n        }\n        expect(2)\n        coroutine.start()\n        expect(4)\n        coroutine.resume(\"OK\")\n        finish(9)\n    }\n\n    @Test\n    fun testNotificationsWithException() = runTest {\n        expect(1)\n        val coroutineContext = coroutineContext // workaround for KT-22984\n        val coroutine = object : AbstractCoroutine<String>(coroutineContext + NonCancellable, true, false) {\n            override fun onStart() {\n                expect(3)\n            }\n\n            override fun onCancelling(cause: Throwable?) {\n                assertIs<TestException1>(cause)\n                expect(5)\n            }\n\n            override fun onCompleted(value: String) {\n                expectUnreached()\n            }\n\n            override fun onCancelled(cause: Throwable, handled: Boolean) {\n                assertIs<TestException1>(cause)\n                expect(8)\n            }\n        }\n\n        coroutine.invokeOnCompletion(onCancelling = true) {\n            assertIs<TestException1>(it)\n            expect(6)\n        }\n\n        coroutine.invokeOnCompletion {\n            assertIs<TestException1>(it)\n            expect(9)\n        }\n\n        expect(2)\n        coroutine.start()\n        expect(4)\n        coroutine.cancelCoroutine(TestException1())\n        expect(7)\n        coroutine.resumeWithException(TestException2())\n        finish(10)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/AsyncLazyTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass AsyncLazyTest : TestBase() {\n\n    @Test\n    fun testSimple() = runTest {\n        expect(1)\n        val d = async(start = CoroutineStart.LAZY) {\n            expect(3)\n            42\n        }\n        expect(2)\n        assertTrue(!d.isActive && !d.isCompleted)\n        assertEquals(d.await(), 42)\n        assertTrue(!d.isActive && d.isCompleted && !d.isCancelled)\n        expect(4)\n        assertEquals(d.await(), 42) // second await -- same result\n        finish(5)\n    }\n\n    @Test\n    fun testLazyDeferAndYield() = runTest {\n        expect(1)\n        val d = async(start = CoroutineStart.LAZY) {\n            expect(3)\n            yield() // this has not effect, because parent coroutine is waiting\n            expect(4)\n            42\n        }\n        expect(2)\n        assertTrue(!d.isActive && !d.isCompleted)\n        assertEquals(d.await(), 42)\n        assertTrue(!d.isActive && d.isCompleted && !d.isCancelled)\n        expect(5)\n        assertEquals(d.await(), 42) // second await -- same result\n        finish(6)\n    }\n\n    @Test\n    fun testLazyDeferAndYield2() = runTest {\n        expect(1)\n        val d = async(start = CoroutineStart.LAZY) {\n            expect(7)\n            42\n        }\n        expect(2)\n        assertTrue(!d.isActive && !d.isCompleted)\n        launch { // see how it looks from another coroutine\n            expect(4)\n            assertTrue(!d.isActive && !d.isCompleted)\n            yield() // yield back to main\n            expect(6)\n            assertTrue(d.isActive && !d.isCompleted) // implicitly started by main's await\n            yield() // yield to d\n        }\n        expect(3)\n        assertTrue(!d.isActive && !d.isCompleted)\n        yield() // yield to second child (lazy async is not computing yet)\n        expect(5)\n        assertTrue(!d.isActive && !d.isCompleted)\n        assertEquals(d.await(), 42) // starts computing\n        assertTrue(!d.isActive && d.isCompleted && !d.isCancelled)\n        finish(8)\n    }\n\n    @Test\n    fun testSimpleException() = runTest(\n        expected = { it is TestException }\n    ) {\n        expect(1)\n        val d = async<Unit>(start = CoroutineStart.LAZY) {\n            finish(3)\n            throw TestException()\n        }\n        expect(2)\n        assertTrue(!d.isActive && !d.isCompleted)\n        d.await() // will throw IOException\n    }\n\n    @Test\n    fun testLazyDeferAndYieldException() =  runTest(\n        expected = { it is TestException }\n    ) {\n        expect(1)\n        val d = async<Unit>(start = CoroutineStart.LAZY) {\n            expect(3)\n            yield() // this has not effect, because parent coroutine is waiting\n            finish(4)\n            throw TestException()\n        }\n        expect(2)\n        assertTrue(!d.isActive && !d.isCompleted)\n        d.await() // will throw IOException\n    }\n\n    @Test\n    fun testCatchException() = runTest {\n        expect(1)\n        val d = async<Unit>(NonCancellable, start = CoroutineStart.LAZY) {\n            expect(3)\n            throw TestException()\n        }\n        expect(2)\n        assertTrue(!d.isActive && !d.isCompleted)\n        try {\n            d.await() // will throw IOException\n        } catch (e: TestException) {\n            assertTrue(!d.isActive && d.isCompleted && d.isCancelled)\n            expect(4)\n        }\n        finish(5)\n    }\n\n    @Test\n    fun testStart() = runTest {\n        expect(1)\n        val d = async(start = CoroutineStart.LAZY) {\n            expect(4)\n            42\n        }\n        expect(2)\n        assertTrue(!d.isActive && !d.isCompleted)\n        assertTrue(d.start())\n        assertTrue(d.isActive && !d.isCompleted)\n        expect(3)\n        assertTrue(!d.start())\n        yield() // yield to started coroutine\n        assertTrue(!d.isActive && d.isCompleted && !d.isCancelled) // and it finishes\n        expect(5)\n        assertEquals(d.await(), 42) // await sees result\n        finish(6)\n    }\n\n    @Test\n    fun testCancelBeforeStart() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        expect(1)\n        val d = async(start = CoroutineStart.LAZY) {\n            expectUnreached()\n            42\n        }\n        expect(2)\n        assertTrue(!d.isActive && !d.isCompleted)\n        d.cancel()\n        assertTrue(!d.isActive && d.isCompleted && d.isCancelled)\n        assertTrue(!d.start())\n        finish(3)\n        assertEquals(d.await(), 42) // await shall throw CancellationException\n        expectUnreached()\n    }\n\n    @Test\n    fun testCancelWhileComputing() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        expect(1)\n        val d = async(start = CoroutineStart.LAZY) {\n            expect(4)\n            yield() // yield to main, that is going to cancel us\n            expectUnreached()\n            42\n        }\n        expect(2)\n        assertTrue(!d.isActive && !d.isCompleted && !d.isCancelled)\n        assertTrue(d.start())\n        assertTrue(d.isActive && !d.isCompleted && !d.isCancelled)\n        expect(3)\n        yield() // yield to d\n        expect(5)\n        assertTrue(d.isActive && !d.isCompleted && !d.isCancelled)\n        d.cancel()\n        assertTrue(!d.isActive && d.isCancelled) // cancelling !\n        assertTrue(!d.isActive && d.isCancelled) // still cancelling\n        finish(6)\n        assertEquals(d.await(), 42) // await shall throw CancellationException\n        expectUnreached()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/AsyncTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\", \"UNREACHABLE_CODE\", \"USELESS_IS_CHECK\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass AsyncTest : TestBase() {\n\n    @Test\n    fun testSimple() = runTest {\n        expect(1)\n        val d = async {\n            expect(3)\n            42\n        }\n        expect(2)\n        assertTrue(d.isActive)\n        assertEquals(d.await(), 42)\n        assertTrue(!d.isActive)\n        expect(4)\n        assertEquals(d.await(), 42) // second await -- same result\n        finish(5)\n    }\n\n    @Test\n    fun testUndispatched() = runTest {\n        expect(1)\n        val d = async(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            42\n        }\n        expect(3)\n        assertTrue(!d.isActive)\n        assertEquals(d.await(), 42)\n        finish(4)\n    }\n\n    @Test\n    fun testSimpleException() = runTest(expected = { it is TestException }) {\n        expect(1)\n        val d = async<Unit> {\n            finish(3)\n            throw TestException()\n        }\n        expect(2)\n        d.await() // will throw TestException\n    }\n\n    @Test\n    fun testCancellationWithCause() = runTest {\n        expect(1)\n        val d = async(NonCancellable, start = CoroutineStart.ATOMIC) {\n            expect(3)\n            yield()\n        }\n        expect(2)\n        d.cancel(TestCancellationException(\"TEST\"))\n        try {\n            d.await()\n        } catch (e: TestCancellationException) {\n            finish(4)\n            assertEquals(\"TEST\", e.message)\n        }\n    }\n\n    @Test\n    fun testLostException() = runTest {\n        expect(1)\n        val deferred = async(Job()) {\n            expect(2)\n            throw Exception()\n        }\n\n        // Exception is not consumed -> nothing is reported\n        deferred.join()\n        finish(3)\n    }\n\n    @Test\n    fun testParallelDecompositionCaughtException() = runTest {\n        val deferred = async(NonCancellable) {\n            val decomposed = async(NonCancellable) {\n                throw TestException()\n                1\n            }\n            try {\n                decomposed.await()\n            } catch (e: TestException) {\n                42\n            }\n        }\n        assertEquals(42, deferred.await())\n    }\n\n    @Test\n    fun testParallelDecompositionCaughtExceptionWithInheritedParent() = runTest {\n        expect(1)\n        val deferred = async(NonCancellable) {\n            expect(2)\n            val decomposed = async { // inherits parent job!\n                expect(3)\n                throw TestException()\n                1\n            }\n            try {\n                decomposed.await()\n            } catch (e: TestException) {\n                expect(4) // Should catch this exception, but parent is already cancelled\n                42\n            }\n        }\n        try {\n            // This will fail\n            assertEquals(42, deferred.await())\n        } catch (e: TestException) {\n            finish(5)\n        }\n    }\n\n    @Test\n    fun testParallelDecompositionUncaughtExceptionWithInheritedParent() = runTest(expected = { it is TestException }) {\n        val deferred = async(NonCancellable) {\n            val decomposed = async {\n                throw TestException()\n                1\n            }\n\n            decomposed.await()\n        }\n\n        deferred.await()\n        expectUnreached()\n    }\n\n    @Test\n    fun testParallelDecompositionUncaughtException() = runTest(expected = { it is TestException }) {\n        val deferred = async(NonCancellable) {\n            val decomposed = async {\n                throw TestException()\n                1\n            }\n\n            decomposed.await()\n        }\n\n        deferred.await()\n        expectUnreached()\n    }\n\n    @Test\n    fun testCancellationTransparency() = runTest {\n        val deferred = async(NonCancellable, start = CoroutineStart.ATOMIC) {\n            expect(2)\n            throw TestException()\n        }\n        expect(1)\n        deferred.cancel()\n        try {\n            deferred.await()\n        } catch (e: TestException) {\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testDeferAndYieldException() = runTest(expected = { it is TestException }) {\n        expect(1)\n        val d = async<Unit> {\n            expect(3)\n            yield() // no effect, parent waiting\n            finish(4)\n            throw TestException()\n        }\n        expect(2)\n        d.await() // will throw IOException\n    }\n\n    @Test\n    fun testDeferWithTwoWaiters() = runTest {\n        expect(1)\n        val d = async {\n            expect(5)\n            yield()\n            expect(9)\n            42\n        }\n        expect(2)\n        launch {\n            expect(6)\n            assertEquals(d.await(), 42)\n            expect(11)\n        }\n        expect(3)\n        launch {\n            expect(7)\n            assertEquals(d.await(), 42)\n            expect(12)\n        }\n        expect(4)\n        yield() // this actually yields control to async, which produces results and resumes both waiters (in order)\n        expect(8)\n        yield() // yield again to \"d\", which completes\n        expect(10)\n        yield() // yield to both waiters\n        finish(13)\n    }\n\n    @Test\n    fun testDeferBadClass() = runTest {\n        val bad = BadClass()\n        val d = async {\n            expect(1)\n            bad\n        }\n        assertSame(d.await(), bad)\n        finish(2)\n    }\n\n    @Test\n    fun testOverriddenParent() = runTest {\n        val parent = Job()\n        val deferred = async(parent, CoroutineStart.ATOMIC) {\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n\n        parent.cancel()\n        try {\n            expect(1)\n            deferred.await()\n        } catch (e: CancellationException) {\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testIncompleteAsyncState() = runTest {\n        val deferred = async {\n            coroutineContext[Job]!!.invokeOnCompletion { }\n        }\n\n        deferred.await().dispose()\n        assertIs<DisposableHandle>(deferred.getCompleted())\n        assertNull(deferred.getCompletionExceptionOrNull())\n        assertTrue(deferred.isCompleted)\n        assertFalse(deferred.isActive)\n        assertFalse(deferred.isCancelled)\n    }\n\n    @Test\n    fun testIncompleteAsyncFastPath() = runTest {\n        val deferred = async(Dispatchers.Unconfined) {\n            coroutineContext[Job]!!.invokeOnCompletion { }\n        }\n\n        deferred.await().dispose()\n        assertIs<DisposableHandle>(deferred.getCompleted())\n        assertNull(deferred.getCompletionExceptionOrNull())\n        assertTrue(deferred.isCompleted)\n        assertFalse(deferred.isActive)\n        assertFalse(deferred.isCancelled)\n    }\n\n    @Test\n    fun testAsyncWithFinally() = runTest {\n        expect(1)\n\n        @Suppress(\"UNREACHABLE_CODE\")\n        val d = async {\n            expect(3)\n            try {\n                yield() // to main, will cancel\n            } finally {\n                expect(6) // will go there on await\n                return@async \"Fail\" // result will not override cancellation\n            }\n            expectUnreached()\n            \"Fail2\"\n        }\n        expect(2)\n        yield() // to async\n        expect(4)\n        check(d.isActive && !d.isCompleted && !d.isCancelled)\n        d.cancel()\n        check(!d.isActive && !d.isCompleted && d.isCancelled)\n        check(!d.isActive && !d.isCompleted && d.isCancelled)\n        expect(5)\n        try {\n            d.await() // awaits\n            expectUnreached() // does not complete normally\n        } catch (e: Throwable) {\n            expect(7)\n            check(e is CancellationException)\n        }\n        check(!d.isActive && d.isCompleted && d.isCancelled)\n        finish(8)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/AtomicCancellationCommonTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.selects.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.test.*\n\nclass AtomicCancellationCommonTest : TestBase() {\n    @Test\n    fun testCancellableLaunch() = runTest {\n        expect(1)\n        val job = launch {\n            expectUnreached() // will get cancelled before start\n        }\n        expect(2)\n        job.cancel()\n        finish(3)\n    }\n\n    @Test\n    fun testAtomicLaunch() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.ATOMIC) {\n            finish(4) // will execute even after it was cancelled\n        }\n        expect(2)\n        job.cancel()\n        expect(3)\n    }\n\n    @Test\n    fun testUndispatchedLaunch() = runTest {\n        expect(1)\n        assertFailsWith<CancellationException> {\n            withContext(Job()) {\n                cancel()\n                launch(start = CoroutineStart.UNDISPATCHED) {\n                    expect(2)\n                    yield()\n                    expectUnreached()\n                }\n            }\n        }\n        finish(3)\n    }\n\n    @Test\n    fun testUndispatchedLaunchWithUnconfinedContext() = runTest {\n        expect(1)\n        assertFailsWith<CancellationException> {\n            withContext(Dispatchers.Unconfined + Job()) {\n                cancel()\n                launch(start = CoroutineStart.UNDISPATCHED) {\n                    expect(2)\n                    yield()\n                    expectUnreached()\n                }\n            }\n        }\n        finish(3)\n    }\n\n    @Test\n    fun testDeferredAwaitCancellable() = runTest {\n        expect(1)\n        val deferred = async { // deferred, not yet complete\n            expect(4)\n            \"OK\"\n        }\n        assertEquals(false, deferred.isCompleted)\n        var job: Job? = null\n        launch { // will cancel job as soon as deferred completes\n            expect(5)\n            assertEquals(true, deferred.isCompleted)\n            job!!.cancel()\n        }\n        job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                deferred.await() // suspends\n                expectUnreached() // will not execute -- cancelled while dispatched\n            } finally {\n                finish(7) // but will execute finally blocks\n            }\n        }\n        expect(3) // continues to execute when the job suspends\n        yield() // to deferred & canceller\n        expect(6)\n    }\n\n    @Test\n    fun testJobJoinCancellable() = runTest {\n        expect(1)\n        val jobToJoin = launch { // not yet complete\n            expect(4)\n        }\n        assertEquals(false, jobToJoin.isCompleted)\n        var job: Job? = null\n        launch { // will cancel job as soon as jobToJoin completes\n            expect(5)\n            assertEquals(true, jobToJoin.isCompleted)\n            job!!.cancel()\n        }\n        job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                jobToJoin.join() // suspends\n                expectUnreached() // will not execute -- cancelled while dispatched\n            } finally {\n                finish(7) // but will execute finally blocks\n            }\n        }\n        expect(3) // continues to execute when the job suspends\n        yield() // to jobToJoin & canceller\n        expect(6)\n    }\n\n    @Test\n    fun testLockCancellable() = runTest {\n        expect(1)\n        val mutex = Mutex(true) // locked mutex\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            mutex.lock() // suspends\n            expectUnreached() // should NOT execute because of cancellation\n        }\n        expect(3)\n        mutex.unlock() // unlock mutex first\n        job.cancel() // cancel the job next\n        yield() // now yield\n        finish(4)\n    }\n\n    @Test\n    fun testSelectLockCancellable() = runTest {\n        expect(1)\n        val mutex = Mutex(true) // locked mutex\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            select<String> { // suspends\n                mutex.onLock {\n                    expect(4)\n                    \"OK\"\n                }\n            }\n            expectUnreached() // should NOT execute because of cancellation\n        }\n        expect(3)\n        mutex.unlock() // unlock mutex first\n        job.cancel() // cancel the job next\n        yield() // now yield\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/AwaitCancellationTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass AwaitCancellationTest : TestBase() {\n\n    @Test\n    fun testCancellation() = runTest(expected = { it is CancellationException }) {\n        expect(1)\n        coroutineScope {\n            val deferred: Deferred<Nothing> = async {\n                expect(2)\n                awaitCancellation()\n            }\n            yield()\n            expect(3)\n            require(deferred.isActive)\n            deferred.cancel()\n            finish(4)\n            deferred.await()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/AwaitTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass AwaitTest : TestBase() {\n\n    @Test\n    fun testAwaitAll() = runTest {\n        expect(1)\n        val d = async {\n            expect(3)\n            \"OK\"\n        }\n\n        val d2 = async {\n            yield()\n            expect(4)\n            1L\n        }\n\n        expect(2)\n        require(d2.isActive && !d2.isCompleted)\n\n        assertEquals(listOf(\"OK\", 1L), awaitAll(d, d2))\n        expect(5)\n\n        require(d.isCompleted && d2.isCompleted)\n        require(!d.isCancelled && !d2.isCancelled)\n        finish(6)\n    }\n\n    @Test\n    fun testAwaitAllLazy() = runTest {\n        expect(1)\n        val d = async(start = CoroutineStart.LAZY) {\n            expect(2)\n            1\n        }\n        val d2 = async(start = CoroutineStart.LAZY) {\n            expect(3)\n            2\n        }\n        assertEquals(listOf(1, 2), awaitAll(d, d2))\n        finish(4)\n    }\n\n    @Test\n    fun testAwaitAllTyped() = runTest {\n        val d1 = async { 1L }\n        val d2 = async { \"\" }\n        val d3 = async { }\n\n        assertEquals(listOf(1L, \"\"), listOf(d1, d2).awaitAll())\n        assertEquals(listOf(1L, Unit), listOf(d1, d3).awaitAll())\n        assertEquals(listOf(\"\", Unit), listOf(d2, d3).awaitAll())\n    }\n\n    @Test\n    fun testAwaitAllExceptionally() = runTest {\n        expect(1)\n        val d = async {\n            expect(3)\n            \"OK\"\n        }\n\n        val d2 = async(NonCancellable) {\n            yield()\n            throw TestException()\n        }\n\n        val d3 = async {\n            expect(4)\n            delay(Long.MAX_VALUE)\n            1\n        }\n\n        expect(2)\n        try {\n            awaitAll(d, d2, d3)\n        } catch (e: TestException) {\n            expect(5)\n        }\n\n        yield()\n        require(d.isCompleted && d2.isCancelled && d3.isActive)\n        d3.cancel()\n        finish(6)\n    }\n\n    @Test\n    fun testAwaitAllMultipleExceptions() = runTest {\n        val d = async(NonCancellable) {\n            expect(2)\n            throw TestException()\n        }\n\n        val d2 = async(NonCancellable) {\n            yield()\n            throw TestException()\n        }\n\n        val d3 = async {\n            yield()\n        }\n\n        expect(1)\n        try {\n            awaitAll(d, d2, d3)\n        } catch (e: TestException) {\n            expect(3)\n        }\n\n        finish(4)\n    }\n\n    @Test\n    fun testAwaitAllCancellation() = runTest {\n        val outer = async {\n\n            expect(1)\n            val inner = async {\n                expect(4)\n                delay(Long.MAX_VALUE)\n            }\n\n            expect(2)\n            awaitAll(inner)\n            expectUnreached()\n        }\n\n        yield()\n        expect(3)\n        yield()\n        require(outer.isActive)\n        outer.cancel()\n        require(outer.isCancelled)\n        finish(5)\n    }\n\n    @Test\n    fun testAwaitAllPartiallyCompleted() = runTest {\n        val d1 = async { expect(1); 1 }\n        d1.await()\n        val d2 = async { expect(3); 2 }\n        expect(2)\n        assertEquals(listOf(1, 2), awaitAll(d1, d2))\n        require(d1.isCompleted && d2.isCompleted)\n        finish(4)\n    }\n\n    @Test\n    fun testAwaitAllPartiallyCompletedExceptionally() = runTest {\n        val d1 = async(NonCancellable) {\n            expect(1)\n            throw TestException()\n        }\n\n        yield()\n\n        // This job is called after exception propagation\n        val d2 = async { expect(4) }\n\n        expect(2)\n        try {\n            awaitAll(d1, d2)\n            expectUnreached()\n        } catch (e: TestException) {\n            expect(3)\n        }\n\n        require(d2.isActive)\n        d2.await()\n        require(d1.isCompleted && d2.isCompleted)\n        finish(5)\n    }\n\n    @Test\n    fun testAwaitAllFullyCompleted() = runTest {\n        val d1 = CompletableDeferred(Unit)\n        val d2 = CompletableDeferred(Unit)\n        val job = async { expect(3) }\n        expect(1)\n        awaitAll(d1, d2)\n        expect(2)\n        job.await()\n        finish(4)\n    }\n\n    @Test\n    fun testAwaitOnSet() = runTest {\n        val d1 = CompletableDeferred(Unit)\n        val d2 = CompletableDeferred(Unit)\n        val job = async { expect(2) }\n        expect(1)\n        listOf(d1, d2, job).awaitAll()\n        finish(3)\n    }\n\n    @Test\n    fun testAwaitAllFullyCompletedExceptionally() = runTest {\n        val d1 = CompletableDeferred<Unit>(parent = null)\n            .apply { completeExceptionally(TestException()) }\n        val d2 = CompletableDeferred<Unit>(parent = null)\n            .apply { completeExceptionally(TestException()) }\n        val job = async { expect(3) }\n        expect(1)\n        try {\n            awaitAll(d1, d2)\n        } catch (e: TestException) {\n            expect(2)\n        }\n\n        job.await()\n        finish(4)\n    }\n\n    @Test\n    fun testAwaitAllSameJobMultipleTimes() = runTest {\n        val d = async { \"OK\" }\n        // Duplicates are allowed though kdoc doesn't guarantee that\n        assertEquals(listOf(\"OK\", \"OK\", \"OK\"), awaitAll(d, d, d))\n    }\n\n    @Test\n    fun testAwaitAllSameThrowingJobMultipleTimes() = runTest {\n        val d1 =\n            async(NonCancellable) { throw TestException() }\n        val d2 = async { } // do nothing\n\n        try {\n            expect(1)\n            // Duplicates are allowed though kdoc doesn't guarantee that\n            awaitAll(d1, d2, d1, d2)\n            expectUnreached()\n        } catch (e: TestException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testAwaitAllEmpty() = runTest {\n        expect(1)\n        assertEquals(emptyList(), awaitAll<Unit>())\n        assertEquals(emptyList(), emptyList<Deferred<Unit>>().awaitAll())\n        finish(2)\n    }\n\n    // joinAll\n\n    @Test\n    fun testJoinAll() = runTest {\n        val d1 = launch { expect(2) }\n        val d2 = async {\n            expect(3)\n            \"OK\"\n        }\n        val d3 = launch { expect(4) }\n\n        expect(1)\n        joinAll(d1, d2, d3)\n        finish(5)\n    }\n\n    @Test\n    fun testJoinAllLazy() = runTest {\n        expect(1)\n        val d = async(start = CoroutineStart.LAZY) {\n            expect(2)\n        }\n        val d2 = launch(start = CoroutineStart.LAZY) {\n            expect(3)\n        }\n        joinAll(d, d2)\n        finish(4)\n    }\n\n    @Test\n    fun testJoinAllExceptionally() = runTest {\n        val d1 = launch {\n            expect(2)\n        }\n        val d2 = async(NonCancellable) {\n            expect(3)\n            throw TestException()\n        }\n        val d3 = async {\n            expect(4)\n        }\n\n        expect(1)\n        joinAll(d1, d2, d3)\n        finish(5)\n    }\n\n    @Test\n    fun testJoinAllCancellation() = runTest {\n        val outer = launch {\n            expect(2)\n            val inner = launch {\n                expect(3)\n                delay(Long.MAX_VALUE)\n            }\n\n            joinAll(inner)\n            expectUnreached()\n        }\n\n        expect(1)\n        yield()\n        require(outer.isActive)\n        yield()\n        outer.cancel()\n        outer.join()\n        finish(4)\n    }\n\n    @Test\n    fun testJoinAllAlreadyCompleted() = runTest {\n        val job = launch {\n            expect(1)\n        }\n\n        job.join()\n        expect(2)\n\n        joinAll(job)\n        finish(3)\n    }\n\n    @Test\n    fun testJoinAllEmpty() = runTest {\n        expect(1)\n        joinAll()\n        listOf<Job>().joinAll()\n        finish(2)\n    }\n\n    @Test\n    fun testJoinAllSameJob() = runTest {\n        val job = launch { }\n        joinAll(job, job, job)\n    }\n\n    @Test\n    fun testJoinAllSameJobExceptionally() = runTest {\n        val job =\n            async(NonCancellable) { throw TestException() }\n        joinAll(job, job, job)\n    }\n\n    @Test\n    fun testAwaitAllDelegates() = runTest {\n        expect(1)\n        val deferred = CompletableDeferred<String>()\n        val delegate = object : Deferred<String> by deferred {}\n        launch {\n            expect(3)\n            deferred.complete(\"OK\")\n        }\n        expect(2)\n        awaitAll(delegate)\n        finish(4)\n    }\n\n    @Test\n    fun testCancelAwaitAllDelegate() = runTest {\n        expect(1)\n        val deferred = CompletableDeferred<String>()\n        val delegate = object : Deferred<String> by deferred {}\n        launch {\n            expect(3)\n            deferred.cancel()\n        }\n        expect(2)\n        assertFailsWith<CancellationException> { awaitAll(delegate) }\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/BuilderContractsTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.test.*\n\nclass BuilderContractsTest : TestBase() {\n\n    @Test\n    fun testContracts() = runTest {\n        // Coroutine scope\n        val cs: Int\n        coroutineScope {\n            cs = 42\n        }\n        consume(cs)\n\n        // Supervisor scope\n        val svs: Int\n        supervisorScope {\n            svs = 21\n        }\n        consume(svs)\n\n        // with context scope\n        val wctx: Int\n        withContext(Dispatchers.Unconfined) {\n            wctx = 239\n        }\n        consume(wctx)\n\n        val wt: Int\n        withTimeout(Long.MAX_VALUE) {\n            wt = 123\n        }\n        consume(wt)\n\n        val s: Int\n        select<Unit> {\n            s = 42\n            Job().apply { complete() }.onJoin {}\n        }\n        consume(s)\n\n\n        val ch: Int\n        val i = Channel<Int>()\n        i.consume {\n            ch = 321\n        }\n        consume(ch)\n    }\n\n    private fun consume(a: Int) {\n        /*\n         * Verify the value is actually set correctly\n         * (non-zero, VerificationError is not triggered, can be read)\n         */\n        assertNotEquals(0, a)\n        assertEquals(a.hashCode(), a)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CancellableContinuationHandlersTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass CancellableContinuationHandlersTest : TestBase() {\n\n    @Test\n    fun testDoubleSubscription() = runTest({ it is IllegalStateException }) {\n        suspendCancellableCoroutine<Unit> { c ->\n            c.invokeOnCancellation { finish(1) }\n            c.invokeOnCancellation { expectUnreached() }\n        }\n    }\n\n    @Test\n    fun testDoubleSubscriptionAfterCompletion() = runTest {\n        suspendCancellableCoroutine<Unit> { c ->\n            c.resume(Unit)\n            // First invokeOnCancellation is Ok\n            c.invokeOnCancellation { expectUnreached() }\n            // Second invokeOnCancellation is not allowed\n            assertFailsWith<IllegalStateException> { c.invokeOnCancellation { expectUnreached() } }\n        }\n    }\n\n    @Test\n    fun testDoubleSubscriptionAfterCompletionWithException() = runTest {\n        assertFailsWith<TestException> {\n            suspendCancellableCoroutine<Unit> { c ->\n                c.resumeWithException(TestException())\n                // First invokeOnCancellation is Ok\n                c.invokeOnCancellation { expectUnreached() }\n                // Second invokeOnCancellation is not allowed\n                assertFailsWith<IllegalStateException> { c.invokeOnCancellation { expectUnreached() } }\n            }\n        }\n    }\n\n    @Test\n    fun testDoubleSubscriptionAfterCancellation() = runTest {\n        try {\n            suspendCancellableCoroutine<Unit> { c ->\n                c.cancel()\n                c.invokeOnCancellation {\n                    assertIs<CancellationException>(it)\n                    expect(1)\n                }\n                assertFailsWith<IllegalStateException> { c.invokeOnCancellation { expectUnreached() } }\n            }\n        } catch (e: CancellationException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testSecondSubscriptionAfterCancellation() = runTest {\n        try {\n            suspendCancellableCoroutine<Unit> { c ->\n                // Set IOC first\n                c.invokeOnCancellation {\n                    assertNull(it)\n                    expect(2)\n                }\n                expect(1)\n                // then cancel (it gets called)\n                c.cancel()\n                // then try to install another one\n                assertFailsWith<IllegalStateException> { c.invokeOnCancellation { expectUnreached() } }\n            }\n        } catch (e: CancellationException) {\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testSecondSubscriptionAfterResumeCancelAndDispatch() = runTest {\n        var cont: CancellableContinuation<Unit>? = null\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            // will be cancelled during dispatch\n            assertFailsWith<CancellationException> {\n                suspendCancellableCoroutine<Unit> { c ->\n                    cont = c\n                    // Set IOC first -- not called (completed)\n                    c.invokeOnCancellation {\n                        assertIs<CancellationException>(it)\n                        expect(4)\n                    }\n                    expect(1)\n                }\n            }\n            expect(5)\n        }\n        expect(2)\n        // then resume it\n        cont!!.resume(Unit) // schedule cancelled continuation for dispatch\n        // then cancel the job during dispatch\n        job.cancel()\n        expect(3)\n        yield() // finish dispatching (will call IOC handler here!)\n        expect(6)\n        // then try to install another one after we've done dispatching it\n        assertFailsWith<IllegalStateException> {\n            cont!!.invokeOnCancellation { expectUnreached() }\n        }\n        finish(7)\n    }\n\n    @Test\n    fun testDoubleSubscriptionAfterCancellationWithCause() = runTest {\n        try {\n            suspendCancellableCoroutine<Unit> { c ->\n                c.cancel(AssertionError())\n                c.invokeOnCancellation {\n                    require(it is AssertionError)\n                    expect(1)\n                }\n                assertFailsWith<IllegalStateException> { c.invokeOnCancellation { expectUnreached() } }\n            }\n        } catch (e: AssertionError) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testDoubleSubscriptionMixed() = runTest {\n        try {\n            suspendCancellableCoroutine<Unit> { c ->\n                c.invokeOnCancellation {\n                    require(it is IndexOutOfBoundsException)\n                    expect(1)\n                }\n                c.cancel(IndexOutOfBoundsException())\n                assertFailsWith<IllegalStateException> { c.invokeOnCancellation { expectUnreached() } }\n            }\n        } catch (e: IndexOutOfBoundsException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testExceptionInHandler() = runTest(\n        unhandled = listOf({ it -> it is CompletionHandlerException })\n    ) {\n        expect(1)\n        try {\n            suspendCancellableCoroutine<Unit> { c ->\n                c.invokeOnCancellation { throw AssertionError() }\n                c.cancel()\n            }\n        } catch (e: CancellationException) {\n            expect(2)\n        }\n        finish(3)\n    }\n\n    @Test\n    fun testSegmentAsHandler() = runTest {\n        class MySegment : Segment<MySegment>(0, null, 0) {\n            override val numberOfSlots: Int get() = 0\n\n            var invokeOnCancellationCalled = false\n            override fun onCancellation(index: Int, cause: Throwable?, context: CoroutineContext) {\n                invokeOnCancellationCalled = true\n            }\n        }\n        val s = MySegment()\n        expect(1)\n        try {\n            suspendCancellableCoroutine<Unit> { c ->\n                expect(2)\n                c as CancellableContinuationImpl<*>\n                c.invokeOnCancellation(s, 0)\n                c.cancel()\n            }\n        } catch (e: CancellationException) {\n            expect(3)\n        }\n        expect(4)\n        check(s.invokeOnCancellationCalled)\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CancellableContinuationTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass CancellableContinuationTest : TestBase() {\n    @Test\n    fun testResumeWithExceptionAndResumeWithException() = runTest {\n        var continuation: Continuation<Unit>? = null\n        val job = launch {\n            try {\n                expect(2)\n                suspendCancellableCoroutine<Unit> { c ->\n                    continuation = c\n                }\n            } catch (e: TestException) {\n                expect(3)\n            }\n        }\n        expect(1)\n        yield()\n        continuation!!.resumeWithException(TestException())\n        yield()\n        assertFailsWith<IllegalStateException> { continuation!!.resumeWithException(TestException()) }\n        job.join()\n        finish(4)\n    }\n\n    @Test\n    fun testResumeAndResumeWithException() = runTest {\n        var continuation: Continuation<Unit>? = null\n        val job = launch {\n            expect(2)\n            suspendCancellableCoroutine<Unit> { c ->\n                continuation = c\n            }\n            expect(3)\n        }\n        expect(1)\n        yield()\n        continuation!!.resume(Unit)\n        job.join()\n        assertFailsWith<IllegalStateException> { continuation!!.resumeWithException(TestException()) }\n        finish(4)\n    }\n\n    @Test\n    fun testResumeAndResume() = runTest {\n        var continuation: Continuation<Unit>? = null\n        val job = launch {\n            expect(2)\n            suspendCancellableCoroutine<Unit> { c ->\n                continuation = c\n            }\n            expect(3)\n        }\n        expect(1)\n        yield()\n        continuation!!.resume(Unit)\n        job.join()\n        assertFailsWith<IllegalStateException> { continuation!!.resume(Unit) }\n        finish(4)\n    }\n\n    /**\n     * Cancelling outer job may, in practise, race with attempt to resume continuation and resumes\n     * should be ignored. Here suspended coroutine is cancelled but then resumed with exception.\n     */\n    @Test\n    fun testCancelAndResumeWithException() = runTest {\n        var continuation: Continuation<Unit>? = null\n        val job = launch {\n            try {\n                expect(2)\n                suspendCancellableCoroutine<Unit> { c ->\n                    continuation = c\n                }\n            } catch (e: CancellationException) {\n                expect(3)\n            }\n        }\n        expect(1)\n        yield()\n        job.cancel() // Cancel job\n        yield()\n        continuation!!.resumeWithException(TestException()) // Should not fail\n        finish(4)\n    }\n\n    /**\n     * Cancelling outer job may, in practise, race with attempt to resume continuation and resumes\n     * should be ignored. Here suspended coroutine is cancelled but then resumed with exception.\n     */\n    @Test\n    fun testCancelAndResume() = runTest {\n        var continuation: Continuation<Unit>? = null\n        val job = launch {\n            try {\n                expect(2)\n                suspendCancellableCoroutine<Unit> { c ->\n                    continuation = c\n                }\n            } catch (e: CancellationException) {\n                expect(3)\n            }\n        }\n        expect(1)\n        yield()\n        job.cancel() // Cancel job\n        yield()\n        continuation!!.resume(Unit) // Should not fail\n        finish(4)\n    }\n\n    @Test\n    fun testCompleteJobWhileSuspended() = runTest {\n        expect(1)\n        val completableJob = Job()\n        val coroutineBlock = suspend {\n            assertFailsWith<CancellationException> {\n                suspendCancellableCoroutine<Unit> { cont ->\n                    expect(2)\n                    assertSame(completableJob, cont.context[Job])\n                    completableJob.complete()\n                }\n                expectUnreached()\n            }\n            expect(3)\n        }\n        coroutineBlock.startCoroutine(Continuation(completableJob) {\n            assertEquals(Unit, it.getOrNull())\n            expect(4)\n        })\n        finish(5)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CancellableResumeTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\n/**\n * Test for [CancellableContinuation.resume] with `onCancellation` parameter.\n */\nclass CancellableResumeTest : TestBase() {\n    @Test\n    fun testResumeImmediateNormally() = runTest {\n        expect(1)\n        val ok = suspendCancellableCoroutine<String> { cont ->\n            expect(2)\n            cont.invokeOnCancellation { expectUnreached() }\n            cont.resume(\"OK\") { expectUnreached() }\n            expect(3)\n        }\n        assertEquals(\"OK\", ok)\n        finish(4)\n    }\n\n    @Test\n    fun testResumeImmediateAfterCancel() = runTest(\n        expected = { it is TestException }\n    ) {\n        expect(1)\n        suspendCancellableCoroutine<String> { cont ->\n            expect(2)\n            cont.invokeOnCancellation { expect(3) }\n            cont.cancel(TestException(\"FAIL\"))\n            expect(4)\n            cont.resume(\"OK\") { cause ->\n                expect(5)\n                assertIs<TestException>(cause)\n            }\n            finish(6)\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testResumeImmediateAfterCancelWithHandlerFailure() = runTest(\n        expected = { it is TestException },\n        unhandled = listOf(\n            { it is CompletionHandlerException && it.cause is TestException2 },\n            { it is CompletionHandlerException && it.cause is TestException3 }\n        )\n    ) {\n        expect(1)\n        suspendCancellableCoroutine<String> { cont ->\n            expect(2)\n            cont.invokeOnCancellation {\n                expect(3)\n                throw TestException2(\"FAIL\") // invokeOnCancellation handler fails with exception\n            }\n            cont.cancel(TestException(\"FAIL\"))\n            expect(4)\n            cont.resume(\"OK\") { cause ->\n                expect(5)\n                assertIs<TestException>(cause)\n                throw TestException3(\"FAIL\") // onCancellation block fails with exception\n            }\n            finish(6)\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testResumeImmediateAfterIndirectCancel() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        expect(1)\n        val ctx = coroutineContext\n        suspendCancellableCoroutine<String> { cont ->\n            expect(2)\n            cont.invokeOnCancellation { expect(3) }\n            ctx.cancel()\n            expect(4)\n            cont.resume(\"OK\") {\n                expect(5)\n            }\n            finish(6)\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testResumeImmediateAfterIndirectCancelWithHandlerFailure() = runTest(\n        expected = { it is CancellationException },\n        unhandled = listOf(\n            { it is CompletionHandlerException && it.cause is TestException2 },\n            { it is CompletionHandlerException && it.cause is TestException3 }\n        )\n    ) {\n        expect(1)\n        val ctx = coroutineContext\n        suspendCancellableCoroutine<String> { cont ->\n            expect(2)\n            cont.invokeOnCancellation {\n                expect(3)\n                throw TestException2(\"FAIL\") // invokeOnCancellation handler fails with exception\n            }\n            ctx.cancel()\n            expect(4)\n            cont.resume(\"OK\") {\n                expect(5)\n                throw TestException3(\"FAIL\") // onCancellation block fails with exception\n            }\n            finish(6)\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testResumeLaterNormally() = runTest {\n        expect(1)\n        lateinit var cc: CancellableContinuation<String>\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            val ok = suspendCancellableCoroutine<String> { cont ->\n                expect(3)\n                cont.invokeOnCancellation { expectUnreached() }\n                cc = cont\n            }\n            assertEquals(\"OK\", ok)\n            finish(6)\n        }\n        expect(4)\n        cc.resume(\"OK\") { expectUnreached() }\n        expect(5)\n    }\n\n    @Test\n    fun testResumeLaterAfterCancel() = runTest {\n        expect(1)\n        lateinit var cc: CancellableContinuation<String>\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                suspendCancellableCoroutine<String> { cont ->\n                    expect(3)\n                    cont.invokeOnCancellation { expect(5) }\n                    cc = cont\n                }\n                expectUnreached()\n            } catch (e: CancellationException) {\n                finish(9)\n            }\n        }\n        expect(4)\n        job.cancel(TestCancellationException())\n        expect(6)\n        cc.resume(\"OK\") { cause ->\n            expect(7)\n            assertIs<TestCancellationException>(cause)\n        }\n        expect(8)\n    }\n\n    @Test\n    fun testResumeLaterAfterCancelWithHandlerFailure() = runTest(\n        unhandled = listOf(\n            { it is CompletionHandlerException && it.cause is TestException2 },\n            { it is CompletionHandlerException && it.cause is TestException3 }\n        )\n    ) {\n        expect(1)\n        lateinit var cc: CancellableContinuation<String>\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                suspendCancellableCoroutine<String> { cont ->\n                    expect(3)\n                    cont.invokeOnCancellation {\n                        expect(5)\n                        throw TestException2(\"FAIL\") // invokeOnCancellation handler fails with exception\n                    }\n                    cc = cont\n                }\n                expectUnreached()\n            } catch (e: CancellationException) {\n                finish(9)\n            }\n        }\n        expect(4)\n        job.cancel(TestCancellationException())\n        expect(6)\n        cc.resume(\"OK\") { cause ->\n            expect(7)\n            assertIs<TestCancellationException>(cause)\n            throw TestException3(\"FAIL\") // onCancellation block fails with exception\n        }\n        expect(8)\n    }\n\n    @Test\n    fun testResumeCancelWhileDispatched() = runTest {\n        expect(1)\n        lateinit var cc: CancellableContinuation<String>\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                suspendCancellableCoroutine<String> { cont ->\n                    expect(3)\n                    // resumed first, dispatched, then cancelled, but still got invokeOnCancellation call\n                    cont.invokeOnCancellation { cause ->\n                        // Note: invokeOnCancellation is called before cc.resume(value) { ... } handler\n                        expect(7)\n                        assertIs<TestCancellationException>(cause)\n                    }\n                    cc = cont\n                }\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(9)\n            }\n        }\n        expect(4)\n        cc.resume(\"OK\") { cause ->\n            // Note: this handler is called after invokeOnCancellation handler\n            expect(8)\n            assertIs<TestCancellationException>(cause)\n        }\n        expect(5)\n        job.cancel(TestCancellationException()) // cancel while execution is dispatched\n        expect(6)\n        yield() // to coroutine -- throws cancellation exception\n        finish(10)\n    }\n\n    @Test\n    fun testResumeCancelWhileDispatchedWithHandlerFailure() = runTest(\n        unhandled = listOf(\n            { it is CompletionHandlerException && it.cause is TestException2 },\n            { it is CompletionHandlerException && it.cause is TestException3 }\n        )\n    ) {\n        expect(1)\n        lateinit var cc: CancellableContinuation<String>\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                suspendCancellableCoroutine<String> { cont ->\n                    expect(3)\n                    // resumed first, dispatched, then cancelled, but still got invokeOnCancellation call\n                    cont.invokeOnCancellation { cause ->\n                        // Note: invokeOnCancellation is called before cc.resume(value) { ... } handler\n                        expect(7)\n                        assertIs<TestCancellationException>(cause)\n                        throw TestException2(\"FAIL\") // invokeOnCancellation handler fails with exception\n                    }\n                    cc = cont\n                }\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(9)\n            }\n        }\n        expect(4)\n        cc.resume(\"OK\") { cause ->\n            // Note: this handler is called after invokeOnCancellation handler\n            expect(8)\n            assertIs<TestCancellationException>(cause)\n            throw TestException3(\"FAIL\") // onCancellation block fails with exception\n        }\n        expect(5)\n        job.cancel(TestCancellationException()) // cancel while execution is dispatched\n        expect(6)\n        yield() // to coroutine -- throws cancellation exception\n        finish(10)\n    }\n\n    @Test\n    fun testResumeUnconfined() = runTest {\n        val outerScope = this\n        withContext(Dispatchers.Unconfined) {\n            val result = suspendCancellableCoroutine<String> {\n                outerScope.launch {\n                    it.resume(\"OK\") {\n                        expectUnreached()\n                    }\n                }\n            }\n            assertEquals(\"OK\", result)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CancelledParentAttachTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.test.*\n\nclass CancelledParentAttachTest : TestBase() {\n\n    @Test\n    fun testAsync() = runTest {\n        CoroutineStart.values().forEach { testAsyncCancelledParent(it) }\n    }\n\n    private suspend fun testAsyncCancelledParent(start: CoroutineStart) {\n        try {\n            withContext(Job()) {\n                cancel()\n                expect(1)\n                val d = async<Int>(start = start) { 42 }\n                expect(2)\n                d.invokeOnCompletion {\n                    finish(3)\n                    reset()\n                }\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            // Expected\n        }\n    }\n\n    @Test\n    fun testLaunch() = runTest {\n        CoroutineStart.values().forEach { testLaunchCancelledParent(it) }\n    }\n\n    private suspend fun testLaunchCancelledParent(start: CoroutineStart) {\n        try {\n            withContext(Job()) {\n                cancel()\n                expect(1)\n                val d = launch(start = start) { }\n                expect(2)\n                d.invokeOnCompletion {\n                    finish(3)\n                    reset()\n                }\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            // Expected\n        }\n    }\n\n    @Test\n    fun testProduce() = runTest({ it is CancellationException }) {\n        cancel()\n        expect(1)\n        val d = produce<Int> { }\n        expect(2)\n        (d as Job).invokeOnCompletion {\n            finish(3)\n            reset()\n        }\n    }\n\n    @Test\n    fun testBroadcast() = runTest {\n        CoroutineStart.values().forEach { testBroadcastCancelledParent(it) }\n    }\n\n    private suspend fun testBroadcastCancelledParent(start: CoroutineStart) {\n        try {\n            withContext(Job()) {\n                cancel()\n                expect(1)\n                val bc = broadcast<Int>(start = start) {}\n                expect(2)\n                (bc as Job).invokeOnCompletion {\n                    finish(3)\n                    reset()\n                }\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            // Expected\n        }\n    }\n\n    @Test\n    fun testScopes() = runTest {\n        testScope { coroutineScope { } }\n        testScope { supervisorScope { } }\n        testScope { flowScope { } }\n        testScope { withTimeout(Long.MAX_VALUE) { } }\n        testScope { withContext(Job()) { } }\n        testScope { withContext(CoroutineName(\"\")) { } }\n    }\n\n    private suspend inline fun testScope(crossinline block: suspend () -> Unit) {\n        try {\n            withContext(Job()) {\n                cancel()\n                block()\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            // Expected\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CompletableDeferredTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\", \"DEPRECATION\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass CompletableDeferredTest : TestBase() {\n    @Test\n    fun testFresh() {\n        val c = CompletableDeferred<String>()\n        checkFresh(c)\n    }\n\n    @Test\n    fun testComplete() {\n        val c = CompletableDeferred<String>()\n        assertEquals(true, c.complete(\"OK\"))\n        checkCompleteOk(c)\n        assertEquals(\"OK\", c.getCompleted())\n        assertEquals(false, c.complete(\"OK\"))\n        checkCompleteOk(c)\n        assertEquals(\"OK\", c.getCompleted())\n    }\n\n    @Test\n    fun testCompleteWithIncompleteResult() {\n        val c = CompletableDeferred<DisposableHandle>()\n        assertEquals(true, c.complete(c.invokeOnCompletion { }))\n        checkCompleteOk(c)\n        assertEquals(false, c.complete(c.invokeOnCompletion { }))\n        checkCompleteOk(c)\n        assertIs<Incomplete>(c.getCompleted())\n    }\n\n    private fun checkFresh(c: CompletableDeferred<*>) {\n        assertEquals(true, c.isActive)\n        assertEquals(false, c.isCancelled)\n        assertEquals(false, c.isCompleted)\n        assertThrows<IllegalStateException> { c.getCancellationException() }\n        assertThrows<IllegalStateException> { c.getCompleted() }\n        assertThrows<IllegalStateException> { c.getCompletionExceptionOrNull() }\n    }\n\n    private fun checkCompleteOk(c: CompletableDeferred<*>) {\n        assertEquals(false, c.isActive)\n        assertEquals(false, c.isCancelled)\n        assertEquals(true, c.isCompleted)\n        assertIs<JobCancellationException>(c.getCancellationException())\n        assertNull(c.getCompletionExceptionOrNull())\n    }\n\n    private fun checkCancel(c: CompletableDeferred<String>) {\n        assertEquals(false, c.isActive)\n        assertEquals(true, c.isCancelled)\n        assertEquals(true, c.isCompleted)\n        assertThrows<CancellationException> { c.getCompleted() }\n        assertIs<CancellationException>(c.getCompletionExceptionOrNull())\n    }\n\n    @Test\n    fun testCancelWithException() {\n        val c = CompletableDeferred<String>()\n        assertEquals(true, c.completeExceptionally(TestException()))\n        checkCancelWithException(c)\n        assertEquals(false, c.completeExceptionally(TestException()))\n        checkCancelWithException(c)\n    }\n\n    private fun checkCancelWithException(c: CompletableDeferred<String>) {\n        assertEquals(false, c.isActive)\n        assertEquals(true, c.isCancelled)\n        assertEquals(true, c.isCompleted)\n        assertIs<JobCancellationException>(c.getCancellationException())\n        assertThrows<TestException> { c.getCompleted() }\n        assertIs<TestException>(c.getCompletionExceptionOrNull())\n    }\n\n    @Test\n    fun testCompleteWithResultOK() {\n        val c = CompletableDeferred<String>()\n        assertEquals(true, c.completeWith(Result.success(\"OK\")))\n        checkCompleteOk(c)\n        assertEquals(\"OK\", c.getCompleted())\n        assertEquals(false, c.completeWith(Result.success(\"OK\")))\n        checkCompleteOk(c)\n        assertEquals(\"OK\", c.getCompleted())\n    }\n\n    @Test\n    fun testCompleteWithResultException() {\n        val c = CompletableDeferred<String>()\n        assertEquals(true, c.completeWith(Result.failure(TestException())))\n        checkCancelWithException(c)\n        assertEquals(false, c.completeWith(Result.failure(TestException())))\n        checkCancelWithException(c)\n    }\n\n    @Test\n    fun testParentCancelsChild() {\n        val parent = Job()\n        val c = CompletableDeferred<String>(parent)\n        checkFresh(c)\n        parent.cancel()\n        assertEquals(false, parent.isActive)\n        assertEquals(true, parent.isCancelled)\n        assertEquals(false, c.isActive)\n        assertEquals(true, c.isCancelled)\n        assertEquals(true, c.isCompleted)\n        assertThrows<CancellationException> { c.getCompleted() }\n        assertIs<CancellationException>(c.getCompletionExceptionOrNull())\n    }\n\n    @Test\n    fun testParentActiveOnChildCompletion() {\n        val parent = Job()\n        val c = CompletableDeferred<String>(parent)\n        checkFresh(c)\n        assertEquals(true, parent.isActive)\n        assertEquals(true, c.complete(\"OK\"))\n        checkCompleteOk(c)\n        assertEquals(true, parent.isActive)\n    }\n\n    @Test\n    fun testParentCancelledOnChildException() {\n        val parent = Job()\n        val c = CompletableDeferred<String>(parent)\n        checkFresh(c)\n        assertEquals(true, parent.isActive)\n        assertEquals(true, c.completeExceptionally(TestException()))\n        checkCancelWithException(c)\n        assertEquals(false, parent.isActive)\n        assertEquals(true, parent.isCancelled)\n    }\n\n    @Test\n    fun testParentActiveOnChildCancellation() {\n        val parent = Job()\n        val c = CompletableDeferred<String>(parent)\n        checkFresh(c)\n        assertEquals(true, parent.isActive)\n        c.cancel()\n        checkCancel(c)\n        assertEquals(true, parent.isActive)\n    }\n\n    @Test\n    fun testAwait() = runTest {\n        expect(1)\n        val c = CompletableDeferred<String>()\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            assertEquals(\"OK\", c.await()) // suspends\n            expect(5)\n            assertEquals(\"OK\", c.await()) // does not suspend\n            expect(6)\n        }\n        expect(3)\n        c.complete(\"OK\")\n        expect(4)\n        yield() // to launch\n        finish(7)\n    }\n\n    @Test\n    fun testCancelAndAwaitParentWaitChildren() = runTest {\n        expect(1)\n        val parent = CompletableDeferred<String>()\n        launch(parent, start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                yield() // will get cancelled\n            } finally {\n                expect(5)\n            }\n        }\n        expect(3)\n        parent.cancel()\n        expect(4)\n        try {\n            parent.await()\n        } catch (e: CancellationException) {\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testCompleteAndAwaitParentWaitChildren() = runTest {\n        expect(1)\n        val parent = CompletableDeferred<String>()\n        launch(parent, start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                yield() // will get cancelled\n            } finally {\n                expect(5)\n            }\n        }\n        expect(3)\n        parent.complete(\"OK\")\n        expect(4)\n        assertEquals(\"OK\", parent.await())\n        finish(6)\n    }\n\n    private inline fun <reified T: Throwable> assertThrows(block: () -> Unit) {\n        try {\n            block()\n            fail(\"Should not complete normally\")\n        } catch (e: Throwable) {\n            assertIs<T>(e)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CompletableJobTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass CompletableJobTest : TestBase() {\n    @Test\n    fun testComplete() {\n        val job = Job()\n        assertTrue(job.isActive)\n        assertFalse(job.isCompleted)\n        assertTrue(job.complete())\n        assertTrue(job.isCompleted)\n        assertFalse(job.isActive)\n        assertFalse(job.isCancelled)\n        assertFalse(job.complete())\n    }\n\n    @Test\n    fun testCompleteWithException() {\n        val job = Job()\n        assertTrue(job.isActive)\n        assertFalse(job.isCompleted)\n        assertTrue(job.completeExceptionally(TestException()))\n        assertTrue(job.isCompleted)\n        assertFalse(job.isActive)\n        assertTrue(job.isCancelled)\n        assertFalse(job.completeExceptionally(TestException()))\n        assertFalse(job.complete())\n    }\n\n    @Test\n    fun testCompleteWithChildren() {\n        val parent = Job()\n        val child = Job(parent)\n        assertTrue(parent.complete())\n        assertFalse(parent.complete())\n        assertTrue(parent.isActive)\n        assertFalse(parent.isCompleted)\n        assertTrue(child.complete())\n        assertTrue(child.isCompleted)\n        assertTrue(parent.isCompleted)\n        assertFalse(child.isActive)\n        assertFalse(parent.isActive)\n    }\n\n    @Test\n    fun testExceptionIsNotReportedToChildren() = parametrized { job ->\n        expect(1)\n        val child = launch(job) {\n            expect(2)\n            try {\n                // KT-33840\n                hang {}\n            } catch (e: Throwable) {\n                assertIs<CancellationException>(e)\n                assertIs<TestException>(if (RECOVER_STACK_TRACES) e.cause?.cause else e.cause)\n                expect(4)\n                throw e\n            }\n        }\n        yield()\n        expect(3)\n        job.completeExceptionally(TestException())\n        child.join()\n        finish(5)\n    }\n\n    @Test\n    fun testCompleteExceptionallyDoesntAffectDeferred() = parametrized { job ->\n        expect(1)\n        val child = async(job) {\n            expect(2)\n            try {\n                // KT-33840\n                hang {}\n            } catch (e: Throwable) {\n                assertIs<CancellationException>(e)\n                assertIs<TestException>(if (RECOVER_STACK_TRACES) e.cause?.cause else e.cause)\n                expect(4)\n                throw e\n            }\n        }\n        yield()\n        expect(3)\n        job.completeExceptionally(TestException())\n        child.join()\n        assertTrue { child.getCompletionExceptionOrNull() is CancellationException }\n        finish(5)\n    }\n\n    private fun parametrized(block: suspend CoroutineScope.(CompletableJob) -> Unit) {\n        runTest {\n            block(Job())\n            reset()\n            block(SupervisorJob())\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CoroutineDispatcherOperatorFunInvokeTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.ContinuationInterceptor\nimport kotlin.coroutines.CoroutineContext\nimport kotlin.test.*\n\nclass CoroutineDispatcherOperatorFunInvokeTest : TestBase() {\n\n    /**\n     * Copy pasted from [WithContextTest.testThrowException],\n     * then edited to use operator.\n     */\n    @Test\n    fun testThrowException() = runTest {\n        expect(1)\n        try {\n            (wrappedCurrentDispatcher()) {\n                expect(2)\n                throw AssertionError()\n            }\n        } catch (e: AssertionError) {\n            expect(3)\n        }\n\n        yield()\n        finish(4)\n    }\n\n    /**\n     * Copy pasted from [WithContextTest.testWithContextChildWaitSameContext],\n     * then edited to use operator fun invoke for [CoroutineDispatcher].\n     */\n    @Test\n    fun testWithContextChildWaitSameContext() = runTest {\n        expect(1)\n        (wrappedCurrentDispatcher()) {\n            expect(2)\n            launch {\n                // ^^^ schedules to main thread\n                expect(4) // waits before return\n            }\n            expect(3)\n            \"OK\".wrap()\n        }.unwrap()\n        finish(5)\n    }\n\n    private class Wrapper(val value: String) : Incomplete {\n        override val isActive: Boolean\n            get() = error(\"\")\n        override val list: NodeList?\n            get() = error(\"\")\n    }\n\n    private fun String.wrap() = Wrapper(this)\n    private fun Wrapper.unwrap() = value\n\n    private fun CoroutineScope.wrappedCurrentDispatcher() = object : CoroutineDispatcher() {\n        val dispatcher = coroutineContext[ContinuationInterceptor] as CoroutineDispatcher\n        override fun dispatch(context: CoroutineContext, block: Runnable) {\n            dispatcher.dispatch(context, block)\n        }\n\n        override fun isDispatchNeeded(context: CoroutineContext): Boolean {\n            return dispatcher.isDispatchNeeded(context)\n        }\n\n        @InternalCoroutinesApi\n        override fun dispatchYield(context: CoroutineContext, block: Runnable) {\n            dispatcher.dispatchYield(context, block)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CoroutineExceptionHandlerTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass CoroutineExceptionHandlerTest : TestBase() {\n    // Parent Job() does not handle exception --> handler is invoked on child crash\n    @Test\n    fun testJob() = runTest {\n        expect(1)\n        var coroutineException: Throwable? = null\n        val handler = CoroutineExceptionHandler { _, ex ->\n            coroutineException = ex\n            expect(3)\n        }\n        val parent = Job()\n        val job = launch(handler + parent) {\n            throw TestException()\n        }\n        expect(2)\n        job.join()\n        finish(4)\n        assertIs<TestException>(coroutineException)\n        assertTrue(parent.isCancelled)\n    }\n\n    // Parent CompletableDeferred() \"handles\" exception --> handler is NOT invoked on child crash\n    @Test\n    fun testCompletableDeferred() = runTest {\n        expect(1)\n        val handler = CoroutineExceptionHandler { _, _ ->\n            expectUnreached()\n        }\n        val parent = CompletableDeferred<Unit>()\n        val job = launch(handler + parent) {\n            throw TestException()\n        }\n        expect(2)\n        job.join()\n        finish(3)\n        assertTrue(parent.isCancelled)\n        assertIs<TestException>(parent.getCompletionExceptionOrNull())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CoroutineScopeTest.kt",
        "content": "@file:Suppress(\"UNREACHABLE_CODE\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass CoroutineScopeTest : TestBase() {\n    @Test\n    fun testScope() = runTest {\n        suspend fun callJobScoped() = coroutineScope {\n            expect(2)\n            launch {\n                expect(4)\n            }\n            launch {\n                expect(5)\n\n                launch {\n                    expect(7)\n                }\n\n                expect(6)\n\n            }\n            expect(3)\n            42\n        }\n        expect(1)\n        val result = callJobScoped()\n        assertEquals(42, result)\n        yield() // Check we're not cancelled\n        finish(8)\n    }\n\n    @Test\n    fun testScopeCancelledFromWithin() = runTest {\n        expect(1)\n        suspend fun callJobScoped() = coroutineScope {\n            launch {\n                expect(2)\n                delay(Long.MAX_VALUE)\n            }\n            launch {\n                expect(3)\n                throw TestException2()\n            }\n        }\n\n        try {\n            callJobScoped()\n            expectUnreached()\n        } catch (e: TestException2) {\n            expect(4)\n        }\n        yield() // Check we're not cancelled\n        finish(5)\n    }\n\n    @Test\n    fun testExceptionFromWithin() = runTest {\n        expect(1)\n        try {\n            expect(2)\n            coroutineScope {\n                expect(3)\n                throw TestException1()\n            }\n            expectUnreached()\n        } catch (e: TestException1) {\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testScopeBlockThrows() = runTest {\n        expect(1)\n        suspend fun callJobScoped(): Unit = coroutineScope {\n            launch {\n                expect(2)\n                delay(Long.MAX_VALUE)\n            }\n            yield() // let launch sleep\n            throw TestException1()\n        }\n        try {\n            callJobScoped()\n            expectUnreached()\n        } catch (e: TestException1) {\n            expect(3)\n        }\n        yield() // Check we're not cancelled\n        finish(4)\n    }\n\n    @Test\n    fun testOuterJobIsCancelled() = runTest {\n        suspend fun callJobScoped() = coroutineScope {\n            launch {\n                expect(3)\n                try {\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    expect(4)\n                }\n            }\n\n            expect(2)\n            delay(Long.MAX_VALUE)\n            42\n        }\n\n        val outerJob = launch(NonCancellable) {\n            expect(1)\n            try {\n                callJobScoped()\n                expectUnreached()\n            } catch (e: JobCancellationException) {\n                expect(5)\n                if (RECOVER_STACK_TRACES) {\n                    val cause = e.cause as JobCancellationException // shall be recovered JCE\n                    assertNull(cause.cause)\n                } else {\n                    assertNull(e.cause)\n                }\n            }\n        }\n        repeat(3) { yield() } // let everything to start properly\n        outerJob.cancel()\n        outerJob.join()\n        finish(6)\n    }\n\n    @Test\n    fun testAsyncCancellationFirst() = runTest {\n        try {\n            expect(1)\n            failedConcurrentSumFirst()\n            expectUnreached()\n        } catch (e: TestException1) {\n            finish(6)\n        }\n    }\n\n    // First async child fails -> second is cancelled\n    private suspend fun failedConcurrentSumFirst(): Int = coroutineScope {\n        val one = async<Int> {\n            expect(3)\n            throw TestException1()\n        }\n        val two = async(start = CoroutineStart.ATOMIC) {\n            try {\n                expect(4)\n                delay(Long.MAX_VALUE) // Emulates very long computation\n                42\n            } finally {\n                expect(5)\n            }\n        }\n        expect(2)\n        one.await() + two.await()\n    }\n\n    @Test\n    fun testAsyncCancellationSecond() = runTest {\n        try {\n            expect(1)\n            failedConcurrentSumSecond()\n            expectUnreached()\n        } catch (e: TestException1) {\n            finish(6)\n        }\n    }\n\n    // Second async child fails -> fist is cancelled\n    private suspend fun failedConcurrentSumSecond(): Int = coroutineScope {\n        val one = async<Int> {\n            try {\n                expect(3)\n                delay(Long.MAX_VALUE) // Emulates very long computation\n                42\n            } finally {\n                expect(5)\n            }\n        }\n        val two = async<Int>(start = CoroutineStart.ATOMIC) {\n            expect(4)\n            throw TestException1()\n        }\n        expect(2)\n        one.await() + two.await()\n    }\n\n    @Test\n    @Suppress(\"UNREACHABLE_CODE\")\n    fun testDocumentationExample() = runTest {\n        suspend fun loadData() = coroutineScope {\n            expect(1)\n            val data = async {\n                try {\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    expect(3)\n                }\n            }\n            yield()\n            // UI updater\n            withContext(coroutineContext) {\n                expect(2)\n                throw TestException1()\n                data.await() // Actually unreached\n                expectUnreached()\n            }\n        }\n\n        try {\n            loadData()\n            expectUnreached()\n        } catch (e: TestException1) {\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testCoroutineScopeCancellationVsException() = runTest {\n        expect(1)\n        var job: Job? = null\n        job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                coroutineScope {\n                    expect(3)\n                    yield() // must suspend\n                    expect(5)\n                    job!!.cancel() // cancel this job _before_ it throws\n                    throw TestException1()\n                }\n            } catch (e: TestException1) {\n                // must have caught TextException\n                expect(6)\n            }\n        }\n        expect(4)\n        yield() // to coroutineScope\n        finish(7)\n    }\n\n    @Test\n    fun testScopePlusContext() {\n        assertSame(EmptyCoroutineContext, scopePlusContext(EmptyCoroutineContext, EmptyCoroutineContext))\n        assertSame(Dispatchers.Default, scopePlusContext(EmptyCoroutineContext, Dispatchers.Default))\n        assertSame(Dispatchers.Default, scopePlusContext(Dispatchers.Default, EmptyCoroutineContext))\n        assertSame(Dispatchers.Default, scopePlusContext(Dispatchers.Default, Dispatchers.Default))\n        assertSame(Dispatchers.Default, scopePlusContext(Dispatchers.Unconfined, Dispatchers.Default))\n        assertSame(Dispatchers.Unconfined, scopePlusContext(Dispatchers.Default, Dispatchers.Unconfined))\n        assertSame(Dispatchers.Unconfined, scopePlusContext(Dispatchers.Unconfined, Dispatchers.Unconfined))\n    }\n\n    @Test\n    fun testIncompleteScopeState() = runTest {\n        lateinit var scopeJob: Job\n        coroutineScope {\n            scopeJob = coroutineContext[Job]!!\n            scopeJob.invokeOnCompletion { }\n        }\n\n        scopeJob.join()\n        assertTrue(scopeJob.isCompleted)\n        assertFalse(scopeJob.isActive)\n        assertFalse(scopeJob.isCancelled)\n    }\n\n    private fun scopePlusContext(c1: CoroutineContext, c2: CoroutineContext) =\n        (ContextScope(c1) + c2).coroutineContext\n\n    @Test\n    fun testIsActiveWithoutJob() {\n        var invoked = false\n        suspend fun testIsActive() {\n            assertTrue(coroutineContext.isActive)\n            invoked = true\n        }\n        ::testIsActive.startCoroutine(Continuation(EmptyCoroutineContext){})\n        assertTrue(invoked)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/CoroutinesTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass CoroutinesTest : TestBase() {\n\n    @Test\n    fun testSimple() = runTest {\n        expect(1)\n        finish(2)\n    }\n\n    @Test\n    fun testYield() = runTest {\n        expect(1)\n        yield() // effectively does nothing, as we don't have other coroutines\n        finish(2)\n    }\n\n    @Test\n    fun testLaunchAndYieldJoin() = runTest {\n        expect(1)\n        val job = launch {\n            expect(3)\n            yield()\n            expect(4)\n        }\n        expect(2)\n        assertTrue(job.isActive && !job.isCompleted)\n        job.join()\n        assertTrue(!job.isActive && job.isCompleted)\n        finish(5)\n    }\n\n    @Test\n    fun testLaunchUndispatched() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            yield()\n            expect(4)\n        }\n        expect(3)\n        assertTrue(job.isActive && !job.isCompleted)\n        job.join()\n        assertTrue(!job.isActive && job.isCompleted)\n        finish(5)\n    }\n\n    @Test\n    fun testNested() = runTest {\n        expect(1)\n        val j1 = launch {\n            expect(3)\n            val j2 = launch {\n                expect(5)\n            }\n            expect(4)\n            j2.join()\n            expect(6)\n        }\n        expect(2)\n        j1.join()\n        finish(7)\n    }\n\n    @Test\n    fun testWaitChild() = runTest {\n        expect(1)\n        launch {\n            expect(3)\n            yield() // to parent\n            finish(5)\n        }\n        expect(2)\n        yield()\n        expect(4)\n        // parent waits for child's completion\n    }\n\n    @Test\n    fun testCancelChildExplicit() = runTest {\n        expect(1)\n        val job = launch {\n            expect(3)\n            yield()\n            expectUnreached()\n        }\n        expect(2)\n        yield()\n        expect(4)\n        job.cancel()\n        finish(5)\n    }\n\n    @Test\n    fun testCancelChildWithFinally() = runTest {\n        expect(1)\n        val job = launch {\n            expect(3)\n            try {\n                yield()\n            } finally {\n                finish(6) // cancelled child will still execute finally\n            }\n            expectUnreached()\n        }\n        expect(2)\n        yield()\n        expect(4)\n        job.cancel()\n        expect(5)\n    }\n\n    @Test\n    fun testWaitNestedChild() = runTest {\n        expect(1)\n        launch {\n            expect(3)\n            launch {\n                expect(6)\n                yield() // to parent\n                expect(9)\n            }\n            expect(4)\n            yield()\n            expect(7)\n            yield()  // to parent\n            finish(10) // the last one to complete\n        }\n        expect(2)\n        yield()\n        expect(5)\n        yield()\n        expect(8)\n        // parent waits for child\n    }\n\n    @Test\n    fun testExceptionPropagation() = runTest(\n        expected = { it is TestException }\n    ) {\n        finish(1)\n        throw TestException()\n    }\n\n    @Test\n    fun testCancelParentOnChildException() = runTest(expected = { it is TestException }) {\n        expect(1)\n        launch {\n            finish(3)\n            throwTestException() // does not propagate exception to launch, but cancels parent (!)\n            expectUnreached()\n        }\n        expect(2)\n        yield()\n        expectUnreached() // because of exception in child\n    }\n\n    @Test\n    fun testCancelParentOnNestedException() = runTest(expected = { it is TestException }) {\n        expect(1)\n        launch {\n            expect(3)\n            launch {\n                finish(6)\n                throwTestException() // unhandled exception kills all parents\n                expectUnreached()\n            }\n            expect(4)\n            yield()\n            expectUnreached() // because of exception in child\n        }\n        expect(2)\n        yield()\n        expect(5)\n        yield()\n        expectUnreached() // because of exception in child\n    }\n\n    @Test\n    fun testJoinWithFinally() = runTest {\n        expect(1)\n        val job = launch {\n            expect(3)\n            try {\n                yield() // to main, will cancel us\n            } finally {\n                expect(7) // join is waiting\n            }\n        }\n        expect(2)\n        yield() // to job\n        expect(4)\n        assertTrue(job.isActive && !job.isCompleted)\n        job.cancel()  // cancels job\n        expect(5) // still here\n        assertTrue(!job.isActive && !job.isCompleted)\n        expect(6) // we're still here\n        job.join() // join the job, let job complete its \"finally\" section\n        expect(8)\n        assertTrue(!job.isActive && job.isCompleted)\n        finish(9)\n    }\n\n    @Test\n    fun testCancelAndJoin() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                yield()\n                expectUnreached() // will get cancelled\n            } finally {\n                expect(4)\n            }\n        }\n        expect(3)\n        job.cancelAndJoin()\n        finish(5)\n    }\n\n    @Test\n    fun testCancelAndJoinChildCrash() = runTest(expected = { it is TestException }) {\n        expect(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            throwTestException()\n            expectUnreached()\n        }\n        // now we have a failed job with TestException\n        finish(3)\n        try {\n            job.cancelAndJoin() // join should crash on child's exception but it will be wrapped into CancellationException\n        } catch (e: Throwable) {\n            e as CancellationException // type assertion\n            assertIs<TestException>(e.cause)\n            throw e\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testYieldInFinally() = runTest(\n        expected = { it is TestException }\n    ) {\n        expect(1)\n        try {\n            expect(2)\n            throwTestException()\n        } finally {\n            expect(3)\n            yield()\n            finish(4)\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testCancelAndJoinChildren() = runTest {\n        expect(1)\n        val parent = Job()\n        launch(parent, CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                yield() // to be cancelled\n            } finally {\n                expect(5)\n            }\n            expectUnreached()\n        }\n        expect(3)\n        parent.cancelChildren()\n        expect(4)\n        parent.children.forEach { it.join() } // will yield to child\n        assertTrue(parent.isActive) // make sure it did not cancel parent\n        finish(6)\n    }\n\n    @Test\n    fun testParentCrashCancelsChildren() = runTest(\n        unhandled = listOf({ it -> it is TestException })\n    ) {\n        expect(1)\n        val parent = launch(Job()) {\n            expect(4)\n            throw TestException(\"Crashed\")\n        }\n        val child = launch(parent, CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                yield() // to test\n            } finally {\n                expect(5)\n                withContext(NonCancellable) { yield() } // to test\n                expect(7)\n            }\n            expectUnreached() // will get cancelled, because parent crashes\n        }\n        expect(3)\n        yield() // to parent\n        expect(6)\n        parent.join() // make sure crashed parent still waits for its child\n        finish(8)\n        // make sure is cancelled\n        assertTrue(child.isCancelled)\n    }\n\n    @Test\n    fun testNotCancellableChildWithExceptionCancelled() = runTest(\n        expected = { it is TestException }\n    ) {\n        expect(1)\n        // CoroutineStart.ATOMIC makes sure it will not get cancelled for it starts executing\n        val d = async(NonCancellable, start = CoroutineStart.ATOMIC) {\n            finish(4)\n            throwTestException() // will throw\n            expectUnreached()\n        }\n        expect(2)\n        // now cancel with some other exception\n        d.cancel(TestCancellationException())\n        // now await to see how it got crashed -- TestCancellationException should have been suppressed by TestException\n        expect(3)\n        d.await()\n    }\n\n    private fun throwTestException() { throw TestException() }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/DelayDurationTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\", \"DEPRECATION\")\n\n// KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.seconds\nimport kotlin.time.Duration.Companion.nanoseconds\n\nclass DelayDurationTest : TestBase() {\n\n    @Test\n    fun testCancellation() = runTest(expected = { it is CancellationException }) {\n        runAndCancel(1.seconds)\n    }\n\n    @Test\n    fun testInfinite() = runTest(expected = { it is CancellationException }) {\n        runAndCancel(Duration.INFINITE)\n    }\n\n    @Test\n    fun testRegularDelay() = runTest {\n        val deferred = async {\n            expect(2)\n            delay(1.seconds)\n            expect(4)\n        }\n\n        expect(1)\n        yield()\n        expect(3)\n        deferred.await()\n        finish(5)\n    }\n\n    @Test\n    fun testNanoDelay() = runTest {\n        val deferred = async {\n            expect(2)\n            delay(1.nanoseconds)\n            expect(4)\n        }\n\n        expect(1)\n        yield()\n        expect(3)\n        deferred.await()\n        finish(5)\n    }\n\n    private suspend fun runAndCancel(time: Duration) = coroutineScope {\n        expect(1)\n        val deferred = async {\n            expect(2)\n            delay(time)\n            expectUnreached()\n        }\n\n        yield()\n        expect(3)\n        require(deferred.isActive)\n        deferred.cancel()\n        finish(4)\n        deferred.await()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/DelayTest.kt",
        "content": "\n@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\", \"DEPRECATION\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass DelayTest : TestBase() {\n\n    @Test\n    fun testCancellation() = runTest(expected = {it is CancellationException }) {\n        runAndCancel(1000)\n    }\n\n    @Test\n    fun testMaxLongValue()= runTest(expected = {it is CancellationException }) {\n        runAndCancel(Long.MAX_VALUE)\n    }\n\n    @Test\n    fun testMaxIntValue()= runTest(expected = {it is CancellationException }) {\n        runAndCancel(Int.MAX_VALUE.toLong())\n    }\n\n    @Test\n    fun testRegularDelay() = runTest {\n        val deferred = async {\n            expect(2)\n            delay(1)\n            expect(3)\n        }\n\n        expect(1)\n        yield()\n        deferred.await()\n        finish(4)\n    }\n\n    private suspend fun runAndCancel(time: Long) = coroutineScope {\n        expect(1)\n        val deferred = async {\n            expect(2)\n            delay(time)\n            expectUnreached()\n        }\n\n        yield()\n        expect(3)\n        require(deferred.isActive)\n        deferred.cancel()\n        finish(4)\n        deferred.await()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/DispatchedContinuationTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n/**\n * When using [suspendCoroutine] from the standard library the continuation must be dispatched atomically,\n * without checking for cancellation at any point in time.\n */\nclass DispatchedContinuationTest : TestBase() {\n    private lateinit var cont: Continuation<String>\n\n    @Test\n    fun testCancelThenResume() = runTest {\n        expect(1)\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            coroutineContext[Job]!!.cancel()\n            // a regular suspendCoroutine will still suspend despite the fact that coroutine was cancelled\n            val value = suspendCoroutine<String> {\n                expect(3)\n                cont = it\n            }\n            expect(6)\n            assertEquals(\"OK\", value)\n        }\n        expect(4)\n        cont.resume(\"OK\")\n        expect(5)\n        yield() // to the launched job\n        finish(7)\n    }\n\n    @Test\n    fun testCancelThenResumeUnconfined() = runTest {\n        expect(1)\n        launch(Dispatchers.Unconfined) {\n            expect(2)\n            coroutineContext[Job]!!.cancel()\n            // a regular suspendCoroutine will still suspend despite the fact that coroutine was cancelled\n            val value = suspendCoroutine<String> {\n                expect(3)\n                cont = it\n            }\n            expect(5)\n            assertEquals(\"OK\", value)\n        }\n        expect(4)\n        cont.resume(\"OK\") // immediately resumes -- because unconfined\n        finish(6)\n    }\n\n    @Test\n    fun testResumeThenCancel() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            val value = suspendCoroutine<String> {\n                expect(3)\n                cont = it\n            }\n            expect(7)\n            assertEquals(\"OK\", value)\n        }\n        expect(4)\n        cont.resume(\"OK\")\n        expect(5)\n        // now cancel the job, which the coroutine is waiting to be dispatched\n        job.cancel()\n        expect(6)\n        yield() // to the launched job\n        finish(8)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/DurationToMillisTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.nanoseconds\nimport kotlin.time.Duration.Companion.seconds\n\nclass DurationToMillisTest {\n\n    @Test\n    fun testNegativeDurationCoercedToZeroMillis() {\n        assertEquals(0L, (-1).seconds.toDelayMillis())\n    }\n\n    @Test\n    fun testZeroDurationCoercedToZeroMillis() {\n        assertEquals(0L, 0.seconds.toDelayMillis())\n    }\n\n    @Test\n    fun testOneNanosecondCoercedToOneMillisecond() {\n        assertEquals(1L, 1.nanoseconds.toDelayMillis())\n    }\n\n    @Test\n    fun testOneSecondCoercedTo1000Milliseconds() {\n        assertEquals(1_000L, 1.seconds.toDelayMillis())\n    }\n\n    @Test\n    fun testMixedComponentDurationRoundedUpToNextMillisecond() {\n        assertEquals(999L, (998.milliseconds + 75909.nanoseconds).toDelayMillis())\n    }\n\n    @Test\n    fun testOneExtraNanosecondRoundedUpToNextMillisecond() {\n        assertEquals(999L, (998.milliseconds + 1.nanoseconds).toDelayMillis())\n    }\n\n    @Test\n    fun testInfiniteDurationCoercedToLongMaxValue() {\n        assertEquals(Long.MAX_VALUE, Duration.INFINITE.toDelayMillis())\n    }\n\n    @Test\n    fun testNegativeInfiniteDurationCoercedToZero() {\n        assertEquals(0L, (-Duration.INFINITE).toDelayMillis())\n    }\n\n    @Test\n    fun testNanosecondOffByOneInfinityDoesNotOverflow() {\n        assertEquals(Long.MAX_VALUE / 1_000_000, (Long.MAX_VALUE - 1L).nanoseconds.toDelayMillis())\n    }\n\n    @Test\n    fun testMillisecondOffByOneInfinityDoesNotIncrement() {\n        assertEquals((Long.MAX_VALUE / 2) - 1, ((Long.MAX_VALUE / 2) - 1).milliseconds.toDelayMillis())\n    }\n\n    @Test\n    fun testOutOfBoundsNanosecondsButFiniteDoesNotIncrement() {\n        val milliseconds = Long.MAX_VALUE / 10\n        assertEquals(milliseconds, milliseconds.milliseconds.toDelayMillis())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/EmptyContext.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.intrinsics.*\nimport kotlin.coroutines.*\n\nsuspend fun <T> withEmptyContext(block: suspend () -> T): T = suspendCoroutine { cont ->\n    block.startCoroutineUnintercepted(Continuation(EmptyCoroutineContext) { cont.resumeWith(it) })\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/ExperimentalDispatchModeTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass ExperimentalDispatchModeTest : TestBase() {\n    @Test\n    fun testUnconfinedCancellation() = runTest {\n        val parent = Job()\n        launch(parent) {\n            expect(1)\n            parent.cancel()\n            launch(Dispatchers.Unconfined) {\n                expectUnreached()\n            }\n\n        }.join()\n        finish(2)\n    }\n\n    @Test\n    fun testUnconfinedCancellationState() = runTest {\n        val parent = Job()\n        launch(parent) {\n            expect(1)\n            parent.cancel()\n            val job = launch(Dispatchers.Unconfined) {\n                expectUnreached()\n            }\n\n            assertTrue(job.isCancelled)\n            assertTrue(job.isCompleted)\n            assertFalse(job.isActive)\n        }.join()\n        finish(2)\n    }\n\n    @Test\n    fun testUnconfinedCancellationLazy() = runTest {\n        val parent = Job()\n        launch(parent) {\n            expect(1)\n            val job = launch(Dispatchers.Unconfined, start = CoroutineStart.LAZY) {\n                expectUnreached()\n            }\n            job.invokeOnCompletion { expect(2) }\n            assertFalse(job.isCompleted)\n\n            parent.cancel()\n            job.join()\n        }.join()\n        finish(3)\n    }\n\n    @Test\n    fun testUndispatchedCancellation() = runTest {\n        val parent = Job()\n        launch(parent) {\n            expect(1)\n            parent.cancel()\n            launch(start = CoroutineStart.UNDISPATCHED) {\n                expect(2)\n                yield()\n                expectUnreached()\n            }\n\n        }.join()\n        finish(3)\n    }\n\n    @Test\n    fun testCancelledAtomicUnconfined() = runTest {\n        val parent = Job()\n        launch(parent) {\n            expect(1)\n            parent.cancel()\n            launch(Dispatchers.Unconfined, start = CoroutineStart.ATOMIC) {\n                expect(2)\n                yield()\n                expectUnreached()\n            }\n        }.join()\n        finish(3)\n    }\n\n\n    @Test\n    fun testCancelledWithContextUnconfined() = runTest {\n        val parent = Job()\n        launch(parent) {\n            expect(1)\n            parent.cancel()\n            withContext(Dispatchers.Unconfined) {\n                expectUnreached()\n            }\n        }.join()\n        finish(2)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/FailedJobTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\n// see https://github.com/Kotlin/kotlinx.coroutines/issues/585\nclass FailedJobTest : TestBase() {\n    @Test\n    fun testCancelledJob() = runTest {\n        expect(1)\n        val job = launch {\n            expectUnreached()\n        }\n        expect(2)\n        job.cancelAndJoin()\n        finish(3)\n        assertTrue(job.isCompleted)\n        assertTrue(!job.isActive)\n        assertTrue(job.isCancelled)\n    }\n\n    @Test\n    fun testFailedJob() = runTest(\n        unhandled = listOf({it -> it is TestException })\n    ) {\n        expect(1)\n        val job = launch(NonCancellable) {\n            expect(3)\n            throw TestException()\n        }\n        expect(2)\n        job.join()\n        finish(4)\n        assertTrue(job.isCompleted)\n        assertTrue(!job.isActive)\n        assertTrue(job.isCancelled)\n    }\n\n    @Test\n    fun testFailedChildJob() = runTest(\n        unhandled = listOf({it -> it is TestException })\n    ) {\n        expect(1)\n        val job = launch(NonCancellable) {\n            expect(3)\n            launch {\n                throw TestException()\n            }\n        }\n        expect(2)\n        job.join()\n        finish(4)\n        assertTrue(job.isCompleted)\n        assertTrue(!job.isActive)\n        assertTrue(job.isCancelled)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/ImmediateYieldTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ImmediateYieldTest : TestBase() {\n\n    // See https://github.com/Kotlin/kotlinx.coroutines/issues/1474\n    @Test\n    fun testImmediateYield() = runTest {\n        expect(1)\n        launch(ImmediateDispatcher(coroutineContext[ContinuationInterceptor])) {\n            expect(2)\n            yield()\n            expect(4)\n        }\n        expect(3) // after yield\n        yield() // yield back\n        finish(5)\n    }\n\n    // imitate immediate dispatcher\n    private class ImmediateDispatcher(job: ContinuationInterceptor?) : CoroutineDispatcher() {\n        val delegate: CoroutineDispatcher = job as CoroutineDispatcher\n\n        override fun isDispatchNeeded(context: CoroutineContext): Boolean = false\n\n        override fun dispatch(context: CoroutineContext, block: Runnable) =\n            delegate.dispatch(context, block)\n    }\n\n    @Test\n    fun testWrappedUnconfinedDispatcherYield() = runTest {\n        expect(1)\n        launch(wrapperDispatcher(Dispatchers.Unconfined)) {\n            expect(2)\n            yield() // Would not work with wrapped unconfined dispatcher\n            expect(3)\n        }\n        finish(4) // after launch\n    }\n\n    @Test\n    fun testWrappedUnconfinedDispatcherYieldStackOverflow() = runTest {\n        expect(1)\n        withContext(wrapperDispatcher(Dispatchers.Unconfined)) {\n            repeat(100_000) {\n                yield()\n            }\n        }\n        finish(2)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/JobExtensionsTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass JobExtensionsTest : TestBase() {\n\n    private val job = Job()\n    private val scope = CoroutineScope(job + CoroutineExceptionHandler { _, _ ->  })\n\n    @Test\n    fun testIsActive() = runTest {\n        expect(1)\n        scope.launch(Dispatchers.Unconfined) {\n            ensureActive()\n            coroutineContext.ensureActive()\n            coroutineContext[Job]!!.ensureActive()\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n\n        expect(3)\n        job.ensureActive()\n        scope.ensureActive()\n        scope.coroutineContext.ensureActive()\n        job.cancelAndJoin()\n        finish(4)\n    }\n\n    @Test\n    fun testIsCompleted() = runTest {\n        expect(1)\n        scope.launch(Dispatchers.Unconfined) {\n            ensureActive()\n            coroutineContext.ensureActive()\n            coroutineContext[Job]!!.ensureActive()\n            expect(2)\n        }\n\n        expect(3)\n        job.complete()\n        job.join()\n        assertFailsWith<JobCancellationException> { job.ensureActive() }\n        assertFailsWith<JobCancellationException> { scope.ensureActive() }\n        assertFailsWith<JobCancellationException> { scope.coroutineContext.ensureActive() }\n        finish(4)\n    }\n\n\n    @Test\n    fun testIsCancelled() = runTest {\n        expect(1)\n        scope.launch(Dispatchers.Unconfined) {\n            ensureActive()\n            coroutineContext.ensureActive()\n            coroutineContext[Job]!!.ensureActive()\n            expect(2)\n            throw TestException()\n        }\n\n        expect(3)\n        checkException { job.ensureActive() }\n        checkException { scope.ensureActive() }\n        checkException { scope.coroutineContext.ensureActive() }\n        finish(4)\n    }\n\n    @Test\n    fun testEnsureActiveWithEmptyContext() = runTest {\n        withEmptyContext {\n            ensureActive() // should not do anything\n        }\n    }\n\n    private inline fun checkException(block: () -> Unit) {\n        val result = runCatching(block)\n        val exception = result.exceptionOrNull() ?: fail()\n        assertIs<JobCancellationException>(exception)\n        assertIs<TestException>(exception.cause)\n    }\n\n    @Test\n    fun testJobExtension() = runTest {\n        assertSame(coroutineContext[Job]!!, coroutineContext.job)\n        assertSame(NonCancellable, NonCancellable.job)\n        assertSame(job, job.job)\n        assertFailsWith<IllegalStateException> { EmptyCoroutineContext.job }\n        assertFailsWith<IllegalStateException> { Dispatchers.Default.job }\n        assertFailsWith<IllegalStateException> { (Dispatchers.Default + CoroutineName(\"\")).job }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/JobStatesTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\n/**\n * Tests that the transitions to the state of the [Job] correspond to documentation in the\n * table that is presented in the [Job] documentation.\n */\nclass JobStatesTest : TestBase() {\n    @Test\n    public fun testNormalCompletion() = runTest {\n        expect(1)\n        val parent = coroutineContext.job\n        val job = launch(start = CoroutineStart.LAZY) {\n            expect(2)\n            // launches child\n            launch {\n                expect(4)\n            }\n            // completes normally\n        }\n        // New job\n        assertFalse(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        assertSame(parent, job.parent)\n        // New -> Active\n        job.start()\n        assertTrue(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        assertSame(parent, job.parent)\n        // Active -> Completing\n        yield() // scheduled & starts child\n        expect(3)\n        assertTrue(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        assertSame(parent, job.parent)\n        // Completing -> Completed\n        yield()\n        finish(5)\n        assertFalse(job.isActive)\n        assertTrue(job.isCompleted)\n        assertFalse(job.isCancelled)\n        assertNull(job.parent)\n    }\n\n    @Test\n    public fun testCompletingFailed() = runTest(\n        unhandled = listOf({ it -> it is TestException })\n    ) {\n        expect(1)\n        val job = launch(NonCancellable, start = CoroutineStart.LAZY) {\n            expect(2)\n            // launches child\n            launch {\n                expect(4)\n                throw TestException()\n            }\n            // completes normally\n        }\n        // New job\n        assertFalse(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        // New -> Active\n        job.start()\n        assertTrue(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        // Active -> Completing\n        yield() // scheduled & starts child\n        expect(3)\n        assertTrue(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        // Completing -> Cancelled\n        yield()\n        finish(5)\n        assertFalse(job.isActive)\n        assertTrue(job.isCompleted)\n        assertTrue(job.isCancelled)\n    }\n\n    @Test\n    public fun testFailed() = runTest(\n        unhandled = listOf({ it -> it is TestException })\n    ) {\n        expect(1)\n        val job = launch(NonCancellable, start = CoroutineStart.LAZY) {\n            expect(2)\n            // launches child\n            launch(start = CoroutineStart.ATOMIC) {\n                expect(4)\n            }\n            // failing\n            throw TestException()\n        }\n        // New job\n        assertFalse(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        // New -> Active\n        job.start()\n        assertTrue(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        // Active -> Cancelling\n        yield() // scheduled & starts child\n        expect(3)\n        assertFalse(job.isActive)\n        assertFalse(job.isCompleted)\n        assertTrue(job.isCancelled)\n        // Cancelling -> Cancelled\n        yield()\n        finish(5)\n        assertFalse(job.isActive)\n        assertTrue(job.isCompleted)\n        assertTrue(job.isCancelled)\n    }\n\n    @Test\n    public fun testCancelling() = runTest {\n        expect(1)\n        val job = launch(NonCancellable, start = CoroutineStart.LAZY) {\n            expect(2)\n            // launches child\n            launch(start = CoroutineStart.ATOMIC) {\n                expect(4)\n            }\n            // completes normally\n        }\n        // New job\n        assertFalse(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        // New -> Active\n        job.start()\n        assertTrue(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        // Active -> Completing\n        yield() // scheduled & starts child\n        expect(3)\n        assertTrue(job.isActive)\n        assertFalse(job.isCompleted)\n        assertFalse(job.isCancelled)\n        // Completing -> Cancelling\n        job.cancel()\n        assertFalse(job.isActive)\n        assertFalse(job.isCompleted)\n        assertTrue(job.isCancelled)\n        // Cancelling -> Cancelled\n        yield()\n        finish(5)\n        assertFalse(job.isActive)\n        assertTrue(job.isCompleted)\n        assertTrue(job.isCancelled)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/JobTest.kt",
        "content": "@file:Suppress(\"DEPRECATION\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass JobTest : TestBase() {\n    @Test\n    fun testState() {\n        val job = Job()\n        assertNull(job.parent)\n        assertTrue(job.isActive)\n        job.cancel()\n        assertTrue(!job.isActive)\n    }\n\n    @Test\n    fun testHandler() {\n        val job = Job()\n        var fireCount = 0\n        job.invokeOnCompletion { fireCount++ }\n        assertTrue(job.isActive)\n        assertEquals(0, fireCount)\n        // cancel once\n        job.cancel()\n        assertTrue(!job.isActive)\n        assertEquals(1, fireCount)\n        // cancel again\n        job.cancel()\n        assertTrue(!job.isActive)\n        assertEquals(1, fireCount)\n    }\n\n    @Test\n    fun testManyHandlers() {\n        val job = Job()\n        val n = 100 * stressTestMultiplier\n        val fireCount = IntArray(n)\n        for (i in 0 until n) job.invokeOnCompletion { fireCount[i]++ }\n        assertTrue(job.isActive)\n        for (i in 0 until n) assertEquals(0, fireCount[i])\n        // cancel once\n        job.cancel()\n        assertTrue(!job.isActive)\n        for (i in 0 until n) assertEquals(1, fireCount[i])\n        // cancel again\n        job.cancel()\n        assertTrue(!job.isActive)\n        for (i in 0 until n) assertEquals(1, fireCount[i])\n    }\n\n    @Test\n    fun testUnregisterInHandler() {\n        val job = Job()\n        val n = 100 * stressTestMultiplier\n        val fireCount = IntArray(n)\n        for (i in 0 until n) {\n            var registration: DisposableHandle? = null\n            registration = job.invokeOnCompletion {\n                fireCount[i]++\n                registration!!.dispose()\n            }\n        }\n        assertTrue(job.isActive)\n        for (i in 0 until n) assertEquals(0, fireCount[i])\n        // cancel once\n        job.cancel()\n        assertTrue(!job.isActive)\n        for (i in 0 until n) assertEquals(1, fireCount[i])\n        // cancel again\n        job.cancel()\n        assertTrue(!job.isActive)\n        for (i in 0 until n) assertEquals(1, fireCount[i])\n    }\n\n    @Test\n    fun testManyHandlersWithUnregister() {\n        val job = Job()\n        val n = 100 * stressTestMultiplier\n        val fireCount = IntArray(n)\n        val registrations = Array<DisposableHandle>(n) { i -> job.invokeOnCompletion { fireCount[i]++ } }\n        assertTrue(job.isActive)\n        fun unreg(i: Int) = i % 4 <= 1\n        for (i in 0 until n) if (unreg(i)) registrations[i].dispose()\n        for (i in 0 until n) assertEquals(0, fireCount[i])\n        job.cancel()\n        assertTrue(!job.isActive)\n        for (i in 0 until n) assertEquals(if (unreg(i)) 0 else 1, fireCount[i])\n    }\n\n    @Test\n    fun testExceptionsInHandler() {\n        val job = Job()\n        val n = 100 * stressTestMultiplier\n        val fireCount = IntArray(n)\n        for (i in 0 until n) job.invokeOnCompletion {\n            fireCount[i]++\n            throw TestException()\n        }\n        assertTrue(job.isActive)\n        for (i in 0 until n) assertEquals(0, fireCount[i])\n        val cancelResult = runCatching { job.cancel() }\n        assertTrue(!job.isActive)\n        for (i in 0 until n) assertEquals(1, fireCount[i])\n        assertIs<CompletionHandlerException>(cancelResult.exceptionOrNull())\n        assertIs<TestException>(cancelResult.exceptionOrNull()!!.cause)\n    }\n\n    @Test\n    fun testCancelledParent() {\n        val parent = Job()\n        parent.cancel()\n        assertTrue(!parent.isActive)\n        val child = Job(parent)\n        assertTrue(!child.isActive)\n    }\n\n    @Test\n    fun testDisposeSingleHandler() {\n        val job = Job()\n        var fireCount = 0\n        val handler = job.invokeOnCompletion { fireCount++ }\n        handler.dispose()\n        job.cancel()\n        assertEquals(0, fireCount)\n    }\n\n    @Test\n    fun testDisposeMultipleHandler() {\n        val job = Job()\n        val handlerCount = 10\n        var fireCount = 0\n        val handlers = Array(handlerCount) { job.invokeOnCompletion { fireCount++ } }\n        handlers.forEach { it.dispose() }\n        job.cancel()\n        assertEquals(0, fireCount)\n    }\n\n    @Test\n    fun testCancelAndJoinParentWaitChildren() = runTest {\n        expect(1)\n        val parent = Job()\n        launch(parent, start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                yield() // will get cancelled\n            } finally {\n                expect(5)\n            }\n        }\n        expect(3)\n        parent.cancel()\n        expect(4)\n        parent.join()\n        finish(6)\n    }\n\n    @Test\n    fun testOnCancellingHandler() = runTest {\n        val job = launch {\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n\n        job.invokeOnCompletion(onCancelling = true) {\n            assertNotNull(it)\n            expect(3)\n        }\n\n        expect(1)\n        yield()\n        job.cancelAndJoin()\n        finish(4)\n    }\n\n    @Test\n    fun testOverriddenParent() = runTest {\n        val parent = Job()\n        val deferred = launch(parent, CoroutineStart.ATOMIC) {\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n\n        parent.cancel()\n        expect(1)\n        deferred.join()\n        finish(3)\n    }\n\n    @Test\n    fun testJobWithParentCancelNormally() {\n        val parent = Job()\n        val job = Job(parent)\n        job.cancel()\n        assertTrue(job.isCancelled)\n        assertFalse(parent.isCancelled)\n    }\n\n    @Test\n    fun testJobWithParentCancelException() {\n        val parent = Job()\n        val job = Job(parent)\n        job.completeExceptionally(TestException())\n        assertTrue(job.isCancelled)\n        assertTrue(parent.isCancelled)\n    }\n\n    @Test\n    fun testIncompleteJobState() = runTest {\n        val parent = coroutineContext.job\n        val job = launch {\n            coroutineContext[Job]!!.invokeOnCompletion {  }\n        }\n        assertSame(parent, job.parent)\n        job.join()\n        assertNull(job.parent)\n        assertTrue(job.isCompleted)\n        assertFalse(job.isActive)\n        assertFalse(job.isCancelled)\n    }\n\n    @Test\n    fun testChildrenWithIncompleteState() = runTest {\n        val job = async { Wrapper() }\n        job.join()\n        assertTrue(job.children.toList().isEmpty())\n    }\n\n    private class Wrapper : Incomplete {\n        override val isActive: Boolean\n            get() =  error(\"\")\n        override val list: NodeList?\n            get() = error(\"\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/LaunchLazyTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass LaunchLazyTest : TestBase() {\n    @Test\n    fun testLaunchAndYieldJoin() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.LAZY) {\n            expect(4)\n            yield() // does nothing -- main waits\n            expect(5)\n        }\n        expect(2)\n        yield() // does nothing, was not started yet\n        expect(3)\n        assertTrue(!job.isActive && !job.isCompleted)\n        job.join()\n        assertTrue(!job.isActive && job.isCompleted)\n        finish(6)\n    }\n\n    @Test\n    fun testStart() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.LAZY) {\n            expect(5)\n            yield() // yields back to main\n            expect(7)\n        }\n        expect(2)\n        yield() // does nothing, was not started yet\n        expect(3)\n        assertTrue(!job.isActive && !job.isCompleted)\n        assertTrue(job.start())\n        assertTrue(job.isActive && !job.isCompleted)\n        assertTrue(!job.start()) // start again -- does nothing\n        assertTrue(job.isActive && !job.isCompleted)\n        expect(4)\n        yield() // now yield to started coroutine\n        expect(6)\n        assertTrue(job.isActive && !job.isCompleted)\n        yield() // yield again\n        assertTrue(!job.isActive && job.isCompleted) // it completes this time\n        expect(8)\n        job.join() // immediately returns\n        finish(9)\n    }\n\n    @Test\n    fun testInvokeOnCompletionAndStart() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.LAZY) {\n            expect(5)\n        }\n        yield() // no started yet!\n        expect(2)\n        job.invokeOnCompletion {\n            expect(6)\n        }\n        expect(3)\n        job.start()\n        expect(4)\n        yield()\n        finish(7)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/LimitedParallelismSharedTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass LimitedParallelismSharedTest : TestBase() {\n\n    @Test\n    fun testLimitedDefault() = runTest {\n        // Test that evaluates the very basic completion of tasks in limited dispatcher\n        // for all supported platforms.\n        // For more specific and concurrent tests, see 'concurrent' package.\n        val view = Dispatchers.Default.limitedParallelism(1)\n        val view2 = Dispatchers.Default.limitedParallelism(1)\n        val j1 = launch(view) {\n            while (true) {\n                yield()\n            }\n        }\n        val j2 = launch(view2) { j1.cancel() }\n        joinAll(j1, j2)\n    }\n\n    @Test\n    fun testParallelismSpec() {\n        assertFailsWith<IllegalArgumentException> { Dispatchers.Default.limitedParallelism(0) }\n        assertFailsWith<IllegalArgumentException> { Dispatchers.Default.limitedParallelism(-1) }\n        assertFailsWith<IllegalArgumentException> { Dispatchers.Default.limitedParallelism(Int.MIN_VALUE) }\n        Dispatchers.Default.limitedParallelism(Int.MAX_VALUE)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/NonCancellableTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass NonCancellableTest : TestBase() {\n    @Test\n    fun testNonCancellable() = runTest {\n        expect(1)\n        val job = async {\n            withContext(NonCancellable) {\n                expect(2)\n                yield()\n                expect(4)\n            }\n\n            expect(5)\n            yield()\n            expectUnreached()\n        }\n\n        yield()\n        job.cancel()\n        expect(3)\n        assertTrue(job.isCancelled)\n        try {\n            job.await()\n            expectUnreached()\n        } catch (e: JobCancellationException) {\n            if (RECOVER_STACK_TRACES) {\n                val cause = e.cause as JobCancellationException // shall be recovered JCE\n                assertNull(cause.cause)\n            } else {\n                assertNull(e.cause)\n            }\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testNonCancellableWithException() = runTest {\n        expect(1)\n        val deferred = async(NonCancellable) {\n            withContext(NonCancellable) {\n                expect(2)\n                yield()\n                expect(4)\n            }\n\n            expect(5)\n            yield()\n            expectUnreached()\n        }\n\n        yield()\n        deferred.cancel(TestCancellationException(\"TEST\"))\n        expect(3)\n        assertTrue(deferred.isCancelled)\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: TestCancellationException) {\n            assertEquals(\"TEST\", e.message)\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testNonCancellableFinally() = runTest {\n        expect(1)\n        val job = async {\n            try {\n                expect(2)\n                yield()\n                expectUnreached()\n            } finally {\n                withContext(NonCancellable) {\n                    expect(4)\n                    yield()\n                    expect(5)\n                }\n            }\n\n            expectUnreached()\n        }\n\n        yield()\n        job.cancel()\n        expect(3)\n        assertTrue(job.isCancelled)\n\n        try {\n            job.await()\n            expectUnreached()\n        } catch (e: CancellationException) {\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testNonCancellableTwice() = runTest {\n        expect(1)\n        val job = async {\n            withContext(NonCancellable) {\n                expect(2)\n                yield()\n                expect(4)\n            }\n\n            withContext(NonCancellable) {\n                expect(5)\n                yield()\n                expect(6)\n            }\n        }\n\n        yield()\n        job.cancel()\n        expect(3)\n        assertTrue(job.isCancelled)\n        try {\n            job.await()\n            expectUnreached()\n        } catch (e: JobCancellationException) {\n            if (RECOVER_STACK_TRACES) {\n                val cause = e.cause as JobCancellationException // shall be recovered JCE\n                assertNull(cause.cause)\n            } else {\n                assertNull(e.cause)\n            }\n            finish(7)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/ParentCancellationTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n/**\n * Systematically tests that various builders cancel parent on failure.\n */\nclass ParentCancellationTest : TestBase() {\n    @Test\n    fun testJobChild() = runTest {\n        testParentCancellation(expectUnhandled = false) { fail ->\n            val child = Job(coroutineContext[Job])\n            CoroutineScope(coroutineContext + child).fail()\n        }\n    }\n\n    @Test\n    fun testSupervisorJobChild() = runTest {\n        testParentCancellation(expectParentActive = true, expectUnhandled = true) { fail ->\n            val child = SupervisorJob(coroutineContext[Job])\n            CoroutineScope(coroutineContext + child).fail()\n        }\n    }\n\n    @Test\n    fun testCompletableDeferredChild() = runTest {\n        testParentCancellation { fail ->\n            val child = CompletableDeferred<Unit>(coroutineContext[Job])\n            CoroutineScope(coroutineContext + child).fail()\n        }\n    }\n\n    @Test\n    fun testLaunchChild() = runTest {\n        testParentCancellation(runsInScopeContext = true) { fail ->\n            launch { fail() }\n        }\n    }\n\n    @Test\n    fun testAsyncChild() = runTest {\n        testParentCancellation(runsInScopeContext = true) { fail ->\n            async { fail() }\n        }\n    }\n\n    @Test\n    fun testProduceChild() = runTest {\n        testParentCancellation(runsInScopeContext = true) { fail ->\n            produce<Unit> { fail() }\n        }\n    }\n\n    @Test\n    fun testBroadcastChild() = runTest {\n        testParentCancellation(runsInScopeContext = true) { fail ->\n            broadcast<Unit> { fail() }.openSubscription()\n        }\n    }\n\n    @Test\n    fun testSupervisorChild() = runTest {\n        testParentCancellation(expectParentActive = true, expectUnhandled = true, runsInScopeContext = true) { fail ->\n            supervisorScope { fail() }\n        }\n    }\n\n    @Test\n    fun testCoroutineScopeChild() = runTest {\n        testParentCancellation(expectParentActive = true, expectRethrows = true, runsInScopeContext = true) { fail ->\n            coroutineScope { fail() }\n        }\n    }\n\n    @Test\n    fun testWithContextChild() = runTest {\n        testParentCancellation(expectParentActive = true, expectRethrows = true, runsInScopeContext = true) { fail ->\n            withContext(CoroutineName(\"fail\")) { fail() }\n        }\n    }\n\n    @Test\n    fun testWithTimeoutChild() = runTest {\n        testParentCancellation(expectParentActive = true, expectRethrows = true, runsInScopeContext = true) { fail ->\n            withTimeout(1000) { fail() }\n        }\n    }\n\n    private suspend fun CoroutineScope.testParentCancellation(\n        expectParentActive: Boolean = false,\n        expectRethrows: Boolean = false,\n        expectUnhandled: Boolean = false,\n        runsInScopeContext: Boolean = false,\n        child: suspend CoroutineScope.(block: suspend CoroutineScope.() -> Unit) -> Unit\n    ) {\n        testWithException(\n            expectParentActive,\n            expectRethrows,\n            expectUnhandled,\n            runsInScopeContext,\n            TestException(),\n            child\n        )\n        testWithException(\n            true,\n            expectRethrows,\n            false,\n            runsInScopeContext,\n            CancellationException(\"Test\"),\n            child\n        )\n    }\n\n    private suspend fun CoroutineScope.testWithException(\n        expectParentActive: Boolean,\n        expectRethrows: Boolean,\n        expectUnhandled: Boolean,\n        runsInScopeContext: Boolean,\n        throwException: Throwable,\n        child: suspend CoroutineScope.(block: suspend CoroutineScope.() -> Unit) -> Unit\n    ) {\n        reset()\n        expect(1)\n        val parent = CompletableDeferred<Unit>() // parent that handles exception (!)\n        val scope = CoroutineScope(coroutineContext + parent)\n        try {\n            scope.child {\n                // launch failing grandchild\n                var unhandledException: Throwable? = null\n                val handler = CoroutineExceptionHandler { _, e -> unhandledException = e }\n                val grandchild = launch(handler) {\n                    throw throwException\n                }\n                grandchild.join()\n                when {\n                    !expectParentActive && runsInScopeContext -> expectUnreached()\n                    expectUnhandled -> assertSame(throwException, unhandledException)\n                    else -> assertNull(unhandledException)\n                }\n            }\n            if (expectRethrows && throwException !is CancellationException) {\n                expectUnreached()\n            } else {\n                expect(2)\n            }\n        } catch (e: Throwable) {\n            if (expectRethrows) {\n                expect(2)\n                assertSame(throwException, e)\n            } else {\n                expectUnreached()\n            }\n        }\n        if (expectParentActive) {\n            assertTrue(parent.isActive)\n        } else {\n            parent.join()\n            assertFalse(parent.isActive)\n            assertTrue(parent.isCancelled)\n        }\n        finish(3)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/SupervisorTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass SupervisorTest : TestBase() {\n    @Test\n    fun testSupervisorJob() = runTest(\n        unhandled = listOf(\n            { it -> it is TestException2 },\n            { it -> it is TestException1 }\n        )\n    ) {\n        expect(1)\n        val supervisor = SupervisorJob()\n        val job1 = launch(supervisor + CoroutineName(\"job1\")) {\n            expect(2)\n            yield() // to second child\n            expect(4)\n            throw TestException1()\n        }\n        val job2 = launch(supervisor + CoroutineName(\"job2\")) {\n            expect(3)\n            throw TestException2()\n        }\n        joinAll(job1, job2)\n        finish(5)\n        assertTrue(job1.isCancelled)\n        assertTrue(job2.isCancelled)\n        assertFalse(supervisor.isCancelled)\n        assertFalse(supervisor.isCompleted)\n    }\n\n    @Test\n    fun testSupervisorScope() = runTest(\n        unhandled = listOf(\n            { it -> it is TestException1 },\n            { it -> it is TestException2 }\n        )\n    ) {\n        val result = supervisorScope {\n            launch {\n                throw TestException1()\n            }\n            launch {\n                throw TestException2()\n            }\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n    }\n\n    @Test\n    fun testSupervisorScopeIsolation() = runTest(\n        unhandled = listOf(\n            { it -> it is TestException2 })\n    ) {\n        val result = supervisorScope {\n            expect(1)\n            val job = launch {\n                expect(2)\n                delay(Long.MAX_VALUE)\n            }\n\n            val failingJob = launch {\n                expect(3)\n                throw TestException2()\n            }\n\n            failingJob.join()\n            yield()\n            expect(4)\n            assertTrue(job.isActive)\n            assertFalse(job.isCancelled)\n            job.cancel()\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(5)\n    }\n\n    @Test\n    fun testThrowingSupervisorScope() = runTest {\n        var childJob: Job? = null\n        var supervisorJob: Job? = null\n        try {\n            expect(1)\n            supervisorScope {\n                childJob = async {\n                    try {\n                        delay(Long.MAX_VALUE)\n                    } finally {\n                        expect(3)\n                    }\n                }\n\n                expect(2)\n                yield()\n                supervisorJob = coroutineContext.job\n                throw TestException2()\n            }\n        } catch (e: Throwable) {\n            assertIs<TestException2>(e)\n            assertTrue(childJob!!.isCancelled)\n            assertTrue(supervisorJob!!.isCancelled)\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testSupervisorThrows() = runTest {\n        try {\n            supervisorScope {\n                expect(1)\n                launch {\n                    expect(2)\n                    delay(Long.MAX_VALUE)\n                }\n\n                launch {\n                    expect(3)\n                    delay(Long.MAX_VALUE)\n                }\n\n                yield()\n                expect(4)\n                throw TestException1()\n            }\n        } catch (e: TestException1) {\n            finish(5)\n        }\n    }\n\n    @Test\n    fun testSupervisorThrowsWithFailingChild() = runTest(unhandled = listOf({e -> e is TestException2})) {\n        try {\n            supervisorScope {\n                expect(1)\n                launch {\n                    expect(2)\n                    delay(Long.MAX_VALUE)\n                }\n\n                launch {\n                    expect(3)\n                    try {\n                        delay(Long.MAX_VALUE)\n                    } finally {\n                        throw TestException2()\n                    }\n                }\n\n                yield()\n                expect(4)\n                throw TestException1()\n            }\n        } catch (e: TestException1) {\n            finish(5)\n        }\n    }\n\n    /**\n     * Tests that [supervisorScope] cancels all its children when the current coroutine is cancelled.\n     */\n    @Test\n    fun testSupervisorScopeExternalCancellation() = runTest {\n        var childJob: Job? = null\n        val job = launch {\n            supervisorScope {\n                childJob = launch(start = CoroutineStart.UNDISPATCHED) {\n                    try {\n                        delay(Long.MAX_VALUE)\n                    } finally {\n                        expect(2)\n                    }\n                }\n            }\n        }\n        while (childJob == null) yield()\n        expect(1)\n        job.cancel()\n        assertTrue(childJob!!.isCancelled)\n        job.join()\n        finish(3)\n    }\n\n    @Test\n    fun testAsyncCancellation() = runTest {\n        val parent = SupervisorJob()\n        val deferred = async(parent) {\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n        expect(1)\n        yield()\n        parent.completeExceptionally(TestException1())\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: CancellationException) {\n            val cause = if (RECOVER_STACK_TRACES) e.cause?.cause!! else e.cause\n            assertIs<TestException1>(cause)\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testSupervisorWithParentCancelNormally() {\n        val parent = Job()\n        val supervisor = SupervisorJob(parent)\n        supervisor.cancel()\n        assertTrue(supervisor.isCancelled)\n        assertFalse(parent.isCancelled)\n    }\n\n    @Test\n    fun testSupervisorWithParentCancelException() {\n        val parent = Job()\n        val supervisor = SupervisorJob(parent)\n        supervisor.completeExceptionally(TestException1())\n        assertTrue(supervisor.isCancelled)\n        assertTrue(parent.isCancelled)\n    }\n\n    @Test\n    fun testSupervisorScopeCancellationVsException() = runTest {\n        expect(1)\n        var job: Job? = null\n        job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                supervisorScope {\n                    expect(3)\n                    yield() // must suspend\n                    expect(5)\n                    job!!.cancel() // cancel this job _before_ it throws\n                    throw TestException1()\n                }\n            } catch (e: TestException1) {\n                // must have caught TextException\n                expect(6)\n            }\n        }\n        expect(4)\n        yield() // to coroutineScope\n        finish(7)\n    }\n\n    @Test\n    fun testSupervisorJobCancellationException() = runTest {\n        val job = SupervisorJob()\n        val child = launch(job + CoroutineExceptionHandler { _, _ -> expectUnreached() }) {\n            expect(1)\n            hang {\n                expect(3)\n            }\n        }\n\n        yield()\n        expect(2)\n        child.cancelAndJoin()\n        job.complete()\n        job.join()\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/UnconfinedTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass UnconfinedTest : TestBase() {\n\n    @Test\n    fun testOrder() = runTest {\n        expect(1)\n        launch(Dispatchers.Unconfined) {\n            expect(2)\n            launch {\n                expect(4)\n                launch {\n                    expect(6)\n                }\n\n                launch {\n                    expect(7)\n                }\n                expect(5)\n            }\n\n            expect(3)\n        }\n\n        finish(8)\n    }\n\n    @Test\n    fun testBlockThrows() = runTest {\n        expect(1)\n        try {\n            withContext(Dispatchers.Unconfined) {\n                expect(2)\n                withContext(Dispatchers.Unconfined + CoroutineName(\"a\")) {\n                    expect(3)\n                }\n\n                expect(4)\n                launch(start = CoroutineStart.ATOMIC) {\n                    expect(5)\n                }\n\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testEnterMultipleTimes() = runTest {\n        launch(Unconfined) {\n            expect(1)\n        }\n\n        launch(Unconfined) {\n            expect(2)\n        }\n\n        launch(Unconfined) {\n            expect(3)\n        }\n\n        finish(4)\n    }\n\n    @Test\n    fun testYield() = runTest {\n        expect(1)\n        launch(Dispatchers.Unconfined) {\n            expect(2)\n            yield()\n            launch {\n                expect(4)\n            }\n            expect(3)\n            yield()\n            expect(5)\n        }.join()\n\n        finish(6)\n    }\n\n    @Test\n    fun testCancellationWihYields() = runTest {\n        expect(1)\n        GlobalScope.launch(Dispatchers.Unconfined) {\n            val job = coroutineContext[Job]!!\n            expect(2)\n            yield()\n            GlobalScope.launch(Dispatchers.Unconfined) {\n                expect(4)\n                job.cancel()\n                expect(5)\n            }\n            expect(3)\n\n            try {\n                yield()\n            } finally {\n                expect(6)\n            }\n        }\n\n        finish(7)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/UndispatchedResultTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass UndispatchedResultTest : TestBase() {\n\n    @Test\n    fun testWithContext() = runTest {\n        invokeTest { block -> withContext(wrapperDispatcher(coroutineContext), block) }\n    }\n\n    @Test\n    fun testWithContextFastPath() = runTest {\n        invokeTest { block -> withContext(coroutineContext, block) }\n    }\n\n    @Test\n    fun testWithTimeout() = runTest {\n        invokeTest { block -> withTimeout(Long.MAX_VALUE, block) }\n    }\n\n    @Test\n    fun testAsync() = runTest {\n        invokeTest { block -> async(NonCancellable, block = block).await() }\n    }\n\n    @Test\n    fun testCoroutineScope() = runTest {\n        invokeTest { block -> coroutineScope(block) }\n    }\n\n    private suspend fun invokeTest(scopeProvider: suspend (suspend CoroutineScope.() -> Unit) -> Unit) {\n        invokeTest(EmptyCoroutineContext, scopeProvider)\n        invokeTest(Unconfined, scopeProvider)\n    }\n\n    private suspend fun invokeTest(\n        context: CoroutineContext,\n        scopeProvider: suspend (suspend CoroutineScope.() -> Unit) -> Unit\n    ) {\n        try {\n            scopeProvider { block(context) }\n        } catch (e: TestException) {\n            finish(5)\n            reset()\n        }\n    }\n\n    private suspend fun CoroutineScope.block(context: CoroutineContext) {\n        try {\n            expect(1)\n            // Will cancel its parent\n            async<Unit>(context) {\n                expect(2)\n                throw TestException()\n            }.await()\n        } catch (e: TestException) {\n            expect(3)\n        }\n        expect(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/WithContextTest.kt",
        "content": "\n@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-22237\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass WithContextTest : TestBase() {\n\n    @Test\n    fun testThrowException() = runTest {\n        expect(1)\n        try {\n            withContext<Unit>(coroutineContext) {\n                expect(2)\n                throw AssertionError()\n            }\n        } catch (e: AssertionError) {\n            expect(3)\n        }\n\n        yield()\n        finish(4)\n    }\n\n    @Test\n    fun testThrowExceptionFromWrappedContext() = runTest {\n        expect(1)\n        try {\n            withContext<Unit>(wrapperDispatcher(coroutineContext)) {\n                expect(2)\n                throw AssertionError()\n            }\n        } catch (e: AssertionError) {\n            expect(3)\n        }\n\n        yield()\n        finish(4)\n    }\n\n    @Test\n    fun testSameContextNoSuspend() = runTest {\n        expect(1)\n        launch(coroutineContext) { // make sure there is not early dispatch here\n            finish(5) // after main exits\n        }\n        expect(2)\n        val result = withContext(coroutineContext) { // same context!\n            expect(3) // still here\n            \"OK\".wrap()\n        }.unwrap()\n        assertEquals(\"OK\", result)\n        expect(4)\n        // will wait for the first coroutine\n    }\n\n    @Test\n    fun testSameContextWithSuspend() = runTest {\n        expect(1)\n        launch(coroutineContext) { // make sure there is not early dispatch here\n            expect(4)\n        }\n        expect(2)\n        val result = withContext(coroutineContext) { // same context!\n            expect(3) // still here\n            yield() // now yields to launch!\n            expect(5)\n            \"OK\".wrap()\n        }.unwrap()\n        assertEquals(\"OK\", result)\n        finish(6)\n    }\n\n    @Test\n    fun testCancelWithJobNoSuspend() = runTest {\n        expect(1)\n        launch(coroutineContext) { // make sure there is not early dispatch to here\n            finish(6) // after main exits\n        }\n        expect(2)\n        val job = Job()\n        try {\n            withContext(coroutineContext + job) {\n                // same context + new job\n                expect(3) // still here\n                job.cancel() // cancel out job!\n                try {\n                    yield() // shall throw CancellationException\n                    expectUnreached()\n                } catch (e: CancellationException) {\n                    expect(4)\n                }\n                \"OK\".wrap()\n            }\n\n            expectUnreached()\n        } catch (e: CancellationException) {\n            expect(5)\n            // will wait for the first coroutine\n        }\n    }\n\n    @Test\n    fun testCancelWithJobWithSuspend() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        expect(1)\n        launch(coroutineContext) { // make sure there is not early dispatch to here\n            expect(4)\n        }\n        expect(2)\n        val job = Job()\n        withContext(coroutineContext + job) { // same context + new job\n            expect(3) // still here\n            yield() // now yields to launch!\n            expect(5)\n            job.cancel() // cancel out job!\n            try {\n                yield() // shall throw CancellationException\n                expectUnreached()\n            } catch (e: CancellationException) {\n                finish(6)\n            }\n            \"OK\".wrap()\n        }\n        // still fails, because parent job was cancelled\n        expectUnreached()\n    }\n\n    @Test\n    fun testRunCancellableDefault() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        val job = Job()\n        job.cancel() // cancel before it has a chance to run\n        withContext(job + wrapperDispatcher(coroutineContext)) {\n            expectUnreached() // will get cancelled\n        }\n    }\n\n    @Test\n    fun testRunCancellationUndispatchedVsException() = runTest {\n        expect(1)\n        var job: Job? = null\n        job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                // Same dispatcher, different context\n                withContext<Unit>(CoroutineName(\"testRunCancellationUndispatchedVsException\")) {\n                    expect(3)\n                    yield() // must suspend\n                    expect(5)\n                    job!!.cancel() // cancel this job _before_ it throws\n                    throw TestException()\n                }\n            } catch (e: TestException) {\n                // must have caught TextException\n                expect(6)\n            }\n        }\n        expect(4)\n        yield() // to coroutineScope\n        finish(7)\n    }\n\n    @Test\n    fun testRunCancellationDispatchedVsException() = runTest {\n        expect(1)\n        var job: Job? = null\n        job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                // \"Different\" dispatcher (schedules execution back and forth)\n                withContext<Unit>(wrapperDispatcher(coroutineContext)) {\n                    expect(4)\n                    yield() // must suspend\n                    expect(6)\n                    job!!.cancel() // cancel this job _before_ it throws\n                    throw TestException()\n                }\n            } catch (e: TestException) {\n                // must have caught TextException\n                expect(8)\n            }\n        }\n        expect(3)\n        yield() // withContext is next\n        expect(5)\n        yield() // withContext again\n        expect(7)\n        yield() // to catch block\n        finish(9)\n    }\n\n    @Test\n    fun testRunSelfCancellationWithException() = runTest {\n        expect(1)\n        var job: Job? = null\n        job = launch(Job()) {\n            try {\n                expect(3)\n                withContext<Unit>(wrapperDispatcher(coroutineContext)) {\n                    require(isActive)\n                    expect(5)\n                    job!!.cancel()\n                    require(!isActive)\n                    throw TestException() // but throw an exception\n                }\n            } catch (e: Throwable) {\n                expect(7)\n                // make sure TestException, not CancellationException is thrown\n                assertIs<TestException>(e, \"Caught $e\")\n            }\n        }\n        expect(2)\n        yield() // to the launched job\n        expect(4)\n        yield() // again to the job\n        expect(6)\n        yield() // again to exception handler\n        finish(8)\n    }\n\n    @Test\n    fun testRunSelfCancellation() = runTest {\n        expect(1)\n        var job: Job? = null\n        job = launch(Job()) {\n            try {\n                expect(3)\n                withContext(wrapperDispatcher(coroutineContext)) {\n                    require(isActive)\n                    expect(5)\n                    job!!.cancel() // cancel itself\n                    require(!isActive)\n                    \"OK\".wrap()\n                }\n                expectUnreached()\n            } catch (e: Throwable) {\n                expect(7)\n                // make sure CancellationException is thrown\n                assertIs<CancellationException>(e, \"Caught $e\")\n            }\n        }\n\n        expect(2)\n        yield() // to the launched job\n        expect(4)\n        yield() // again to the job\n        expect(6)\n        yield() // again to exception handler\n        finish(8)\n    }\n\n    @Test\n    fun testWithContextScopeFailure() = runTest {\n        expect(1)\n        try {\n            withContext(wrapperDispatcher(coroutineContext)) {\n                expect(2)\n                // launch a child that fails\n                launch {\n                    expect(4)\n                    throw TestException()\n                }\n                expect(3)\n                \"OK\".wrap()\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            // ensure that we can catch exception outside of the scope\n            expect(5)\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testWithContextChildWaitSameContext() = runTest {\n        expect(1)\n        withContext(coroutineContext) {\n            expect(2)\n            launch {\n                // ^^^ schedules to main thread\n                expect(4) // waits before return\n            }\n            expect(3)\n            \"OK\".wrap()\n        }.unwrap()\n        finish(5)\n    }\n\n    @Test\n    fun testWithContextChildWaitWrappedContext() = runTest {\n        expect(1)\n        withContext(wrapperDispatcher(coroutineContext)) {\n            expect(2)\n            launch {\n                // ^^^ schedules to main thread\n                expect(4) // waits before return\n            }\n            expect(3)\n            \"OK\".wrap()\n        }.unwrap()\n        finish(5)\n    }\n\n    @Test\n    fun testIncompleteWithContextState() = runTest {\n        lateinit var ctxJob: Job\n        withContext(wrapperDispatcher(coroutineContext)) {\n            ctxJob = coroutineContext[Job]!!\n            ctxJob.invokeOnCompletion { }\n        }\n\n        ctxJob.join()\n        assertTrue(ctxJob.isCompleted)\n        assertFalse(ctxJob.isActive)\n        assertFalse(ctxJob.isCancelled)\n    }\n\n    @Test\n    fun testWithContextCancelledJob() = runTest {\n        expect(1)\n        val job = Job()\n        job.cancel()\n        try {\n            withContext(job) {\n                expectUnreached()\n            }\n        } catch (e: CancellationException) {\n            expect(2)\n        }\n        finish(3)\n    }\n\n    @Test\n    fun testWithContextCancelledThisJob() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        coroutineContext.cancel()\n        withContext(wrapperDispatcher(coroutineContext)) {\n            expectUnreached()\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testSequentialCancellation() = runTest {\n        val job = launch {\n            expect(1)\n            withContext(wrapperDispatcher()) {\n                expect(2)\n            }\n            expectUnreached()\n        }\n\n        yield()\n        val job2 = launch {\n            expect(3)\n            job.cancel()\n        }\n\n        joinAll(job, job2)\n        finish(4)\n    }\n\n    private class Wrapper(val value: String) : Incomplete {\n        override val isActive: Boolean\n            get() =  error(\"\")\n        override val list: NodeList?\n            get() = error(\"\")\n    }\n\n    private fun String.wrap() = Wrapper(this)\n    private fun Wrapper.unwrap() = value\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/WithTimeoutDurationTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\", \"UNREACHABLE_CODE\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\nclass WithTimeoutDurationTest : TestBase() {\n    /**\n     * Tests a case of no timeout and no suspension inside.\n     */\n    @Test\n    fun testBasicNoSuspend() = runTest {\n        expect(1)\n        val result = withTimeout(10.seconds) {\n            expect(2)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    /**\n     * Tests a case of no timeout and one suspension inside.\n     */\n    @Test\n    fun testBasicSuspend() = runTest {\n        expect(1)\n        val result = withTimeout(10.seconds) {\n            expect(2)\n            yield()\n            expect(3)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(4)\n    }\n\n    /**\n     * Tests proper dispatching of `withTimeout` blocks\n     */\n    @Test\n    fun testDispatch() = runTest {\n        expect(1)\n        launch {\n            expect(4)\n            yield() // back to main\n            expect(7)\n        }\n        expect(2)\n        // test that it does not yield to the above job when started\n        val result = withTimeout(1.seconds) {\n            expect(3)\n            yield() // yield only now\n            expect(5)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        expect(6)\n        yield() // back to launch\n        finish(8)\n    }\n\n\n    /**\n     * Tests that a 100% CPU-consuming loop will react on timeout if it has yields.\n     */\n    @Test\n    fun testYieldBlockingWithTimeout() = runTest(\n            expected = { it is CancellationException }\n    ) {\n        withTimeout(100.milliseconds) {\n            while (true) {\n                yield()\n            }\n        }\n    }\n\n    /**\n     * Tests that [withTimeout] waits for children coroutines to complete.\n     */\n    @Test\n    fun testWithTimeoutChildWait() = runTest {\n        expect(1)\n        withTimeout(100.milliseconds) {\n            expect(2)\n            // launch child with timeout\n            launch {\n                expect(4)\n            }\n            expect(3)\n            // now will wait for child before returning\n        }\n        finish(5)\n    }\n\n    @Test\n    fun testBadClass() = runTest {\n        val bad = BadClass()\n        val result = withTimeout(100.milliseconds) {\n            bad\n        }\n        assertSame(bad, result)\n    }\n\n    class BadClass {\n        override fun equals(other: Any?): Boolean = error(\"Should not be called\")\n        override fun hashCode(): Int = error(\"Should not be called\")\n        override fun toString(): String = error(\"Should not be called\")\n    }\n\n    @Test\n    fun testExceptionOnTimeout() = runTest {\n        expect(1)\n        try {\n            withTimeout(100.milliseconds) {\n                expect(2)\n                delay(1000.milliseconds)\n                expectUnreached()\n                \"OK\"\n            }\n        } catch (e: CancellationException) {\n            assertEquals(\"Timed out waiting for 100 ms\", e.message)\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testSuppressExceptionWithResult() = runTest(\n            expected = { it is CancellationException }\n    ) {\n        expect(1)\n        withTimeout(100.milliseconds) {\n            expect(2)\n            try {\n                delay(1000.milliseconds)\n            } catch (e: CancellationException) {\n                finish(3)\n            }\n            \"OK\"\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testSuppressExceptionWithAnotherException() = runTest {\n        expect(1)\n        try {\n            withTimeout(100.milliseconds) {\n                expect(2)\n                try {\n                    delay(1000.milliseconds)\n                } catch (e: CancellationException) {\n                    expect(3)\n                    throw TestException()\n                }\n                expectUnreached()\n                \"OK\"\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testNegativeTimeout() = runTest {\n        expect(1)\n        try {\n            withTimeout(-1.milliseconds) {\n                expectUnreached()\n                \"OK\"\n            }\n        } catch (e: TimeoutCancellationException) {\n            assertEquals(\"Timed out immediately\", e.message)\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testExceptionFromWithinTimeout() = runTest {\n        expect(1)\n        try {\n            expect(2)\n            withTimeout(1.seconds) {\n                expect(3)\n                throw TestException()\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testIncompleteWithTimeoutState() = runTest {\n        lateinit var timeoutJob: Job\n        val handle = withTimeout(Duration.INFINITE) {\n            timeoutJob = coroutineContext[Job]!!\n            timeoutJob.invokeOnCompletion { }\n        }\n\n        handle.dispose()\n        timeoutJob.join()\n        assertTrue(timeoutJob.isCompleted)\n        assertFalse(timeoutJob.isActive)\n        assertFalse(timeoutJob.isCancelled)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/WithTimeoutOrNullDurationTest.kt",
        "content": "\n@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\nclass WithTimeoutOrNullDurationTest : TestBase() {\n    /**\n     * Tests a case of no timeout and no suspension inside.\n     */\n    @Test\n    fun testBasicNoSuspend() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(10.seconds) {\n            expect(2)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    /**\n     * Tests a case of no timeout and one suspension inside.\n     */\n    @Test\n    fun testBasicSuspend() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(10.seconds) {\n            expect(2)\n            yield()\n            expect(3)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(4)\n    }\n\n    /**\n     * Tests property dispatching of `withTimeoutOrNull` blocks\n     */\n    @Test\n    fun testDispatch() = runTest {\n        expect(1)\n        launch {\n            expect(4)\n            yield() // back to main\n            expect(7)\n        }\n        expect(2)\n        // test that it does not yield to the above job when started\n        val result = withTimeoutOrNull(1.seconds) {\n            expect(3)\n            yield() // yield only now\n            expect(5)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        expect(6)\n        yield() // back to launch\n        finish(8)\n    }\n\n    /**\n     * Tests that a 100% CPU-consuming loop will react on timeout if it has yields.\n     */\n    @Test\n    fun testYieldBlockingWithTimeout() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(100.milliseconds) {\n            while (true) {\n                yield()\n            }\n        }\n        assertNull(result)\n        finish(2)\n    }\n\n    @Test\n    fun testSmallTimeout() = runTest {\n        val channel = Channel<Int>(1)\n        val value = withTimeoutOrNull(1.milliseconds) {\n            channel.receive()\n        }\n        assertNull(value)\n    }\n\n    @Test\n    fun testThrowException() = runTest(expected = {it is AssertionError}) {\n        withTimeoutOrNull<Unit>(Duration.INFINITE) {\n            throw AssertionError()\n        }\n    }\n\n    @Test\n    fun testInnerTimeout() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        withTimeoutOrNull(1000.milliseconds) {\n            withTimeout(10.milliseconds) {\n                while (true) {\n                    yield()\n                }\n            }\n            @Suppress(\"UNREACHABLE_CODE\")\n            expectUnreached() // will timeout\n        }\n        expectUnreached() // will timeout\n    }\n\n    @Test\n    fun testNestedTimeout() = runTest(expected = { it is TimeoutCancellationException }) {\n        withTimeoutOrNull(Duration.INFINITE) {\n            // Exception from this withTimeout is not suppressed by withTimeoutOrNull\n            withTimeout(10.milliseconds) {\n                delay(Duration.INFINITE)\n                1\n            }\n        }\n\n        expectUnreached()\n    }\n\n    @Test\n    fun testOuterTimeout() = runTest {\n        if (isJavaAndWindows) return@runTest\n        var counter = 0\n        val result = withTimeoutOrNull(320.milliseconds) {\n            while (true) {\n                val inner = withTimeoutOrNull(150.milliseconds) {\n                    while (true) {\n                        yield()\n                    }\n                }\n                assertNull(inner)\n                counter++\n            }\n        }\n        assertNull(result)\n        check(counter in 1..2) {\"Executed: $counter times\"}\n    }\n\n    @Test\n    fun testBadClass() = runTest {\n        val bad = BadClass()\n        val result = withTimeoutOrNull(100.milliseconds) {\n            bad\n        }\n        assertSame(bad, result)\n    }\n\n    class BadClass {\n        override fun equals(other: Any?): Boolean = error(\"Should not be called\")\n        override fun hashCode(): Int = error(\"Should not be called\")\n        override fun toString(): String = error(\"Should not be called\")\n    }\n\n    @Test\n    fun testNullOnTimeout() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(100.milliseconds) {\n            expect(2)\n            delay(1000.milliseconds)\n            expectUnreached()\n            \"OK\"\n        }\n        assertNull(result)\n        finish(3)\n    }\n\n    @Test\n    fun testSuppressExceptionWithResult() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(100.milliseconds) {\n            expect(2)\n            try {\n                delay(1000.milliseconds)\n            } catch (e: CancellationException) {\n                expect(3)\n            }\n            \"OK\"\n        }\n        assertNull(result)\n        finish(4)\n    }\n\n    @Test\n    fun testSuppressExceptionWithAnotherException() = runTest {\n        expect(1)\n        try {\n            withTimeoutOrNull(100.milliseconds) {\n                expect(2)\n                try {\n                    delay(1000.milliseconds)\n                } catch (e: CancellationException) {\n                    expect(3)\n                    throw TestException()\n                }\n                expectUnreached()\n                \"OK\"\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            // catches TestException\n            finish(4)\n\n        }\n    }\n\n    @Test\n    fun testNegativeTimeout() = runTest {\n        expect(1)\n        var result = withTimeoutOrNull(-1.milliseconds) {\n            expectUnreached()\n        }\n        assertNull(result)\n        result = withTimeoutOrNull(0.milliseconds) {\n            expectUnreached()\n        }\n        assertNull(result)\n        finish(2)\n    }\n\n    @Test\n    fun testExceptionFromWithinTimeout() = runTest {\n        expect(1)\n        try {\n            expect(2)\n            withTimeoutOrNull<Unit>(1000.milliseconds) {\n                expect(3)\n                throw TestException()\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            finish(4)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/WithTimeoutOrNullTest.kt",
        "content": "\n@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass WithTimeoutOrNullTest : TestBase() {\n    /**\n     * Tests a case of no timeout and no suspension inside.\n     */\n    @Test\n    fun testBasicNoSuspend() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(10_000) {\n            expect(2)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    /**\n     * Tests a case of no timeout and one suspension inside.\n     */\n    @Test\n    fun testBasicSuspend() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(10_000) {\n            expect(2)\n            yield()\n            expect(3)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(4)\n    }\n\n    /**\n     * Tests property dispatching of `withTimeoutOrNull` blocks\n     */\n    @Test\n    fun testDispatch() = runTest {\n        expect(1)\n        launch {\n            expect(4)\n            yield() // back to main\n            expect(7)\n        }\n        expect(2)\n        // test that it does not yield to the above job when started\n        val result = withTimeoutOrNull(1000) {\n            expect(3)\n            yield() // yield only now\n            expect(5)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        expect(6)\n        yield() // back to launch\n        finish(8)\n    }\n\n    /**\n     * Tests that a 100% CPU-consuming loop will react on timeout if it has yields.\n     */\n    @Test\n    fun testYieldBlockingWithTimeout() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(100) {\n            while (true) {\n                yield()\n            }\n        }\n        assertNull(result)\n        finish(2)\n    }\n\n    @Test\n    fun testSmallTimeout() = runTest {\n        val channel = Channel<Int>(1)\n        val value = withTimeoutOrNull(1) {\n            channel.receive()\n        }\n        assertNull(value)\n    }\n\n    @Test\n    fun testThrowException() = runTest(expected = {it is AssertionError}) {\n        withTimeoutOrNull<Unit>(Long.MAX_VALUE) {\n            throw AssertionError()\n        }\n    }\n\n    @Test\n    fun testInnerTimeout() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        withTimeoutOrNull(1000) {\n            withTimeout(10) {\n                while (true) {\n                    yield()\n                }\n            }\n            @Suppress(\"UNREACHABLE_CODE\")\n            expectUnreached() // will timeout\n        }\n        expectUnreached() // will timeout\n    }\n\n    @Test\n    fun testNestedTimeout() = runTest(expected = { it is TimeoutCancellationException }) {\n        withTimeoutOrNull(Long.MAX_VALUE) {\n            // Exception from this withTimeout is not suppressed by withTimeoutOrNull\n            withTimeout(10) {\n                delay(Long.MAX_VALUE)\n                1\n            }\n        }\n\n        expectUnreached()\n    }\n\n    @Test\n    fun testOuterTimeout() = runTest {\n        if (isJavaAndWindows) return@runTest\n        var counter = 0\n        val result = withTimeoutOrNull(320) {\n            while (true) {\n                val inner = withTimeoutOrNull(150) {\n                    while (true) {\n                        yield()\n                    }\n                }\n                assertNull(inner)\n                counter++\n            }\n        }\n        assertNull(result)\n        check(counter in 1..2) {\"Executed: $counter times\"}\n    }\n\n    @Test\n    fun testBadClass() = runTest {\n        val bad = BadClass()\n        val result = withTimeoutOrNull(100) {\n            bad\n        }\n        assertSame(bad, result)\n    }\n\n    @Test\n    fun testNullOnTimeout() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(100) {\n            expect(2)\n            delay(1000)\n            expectUnreached()\n            \"OK\"\n        }\n        assertNull(result)\n        finish(3)\n    }\n\n    @Test\n    fun testSuppressExceptionWithResult() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(100) {\n            expect(2)\n            try {\n                delay(1000)\n            } catch (e: CancellationException) {\n                expect(3)\n            }\n            \"OK\"\n        }\n        assertNull(result)\n        finish(4)\n    }\n\n    @Test\n    fun testSuppressExceptionWithAnotherException() = runTest {\n        expect(1)\n        try {\n            withTimeoutOrNull(100) {\n                expect(2)\n                try {\n                    delay(1000)\n                } catch (e: CancellationException) {\n                    expect(3)\n                    throw TestException()\n                }\n                expectUnreached()\n                \"OK\"\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            // catches TestException\n            finish(4)\n\n        }\n    }\n\n    @Test\n    fun testNegativeTimeout() = runTest {\n        expect(1)\n        var result = withTimeoutOrNull(-1) {\n            expectUnreached()\n        }\n        assertNull(result)\n        result = withTimeoutOrNull(0) {\n            expectUnreached()\n        }\n        assertNull(result)\n        finish(2)\n    }\n\n    @Test\n    fun testExceptionFromWithinTimeout() = runTest {\n        expect(1)\n        try {\n            expect(2)\n            withTimeoutOrNull(1000) {\n                expect(3)\n                throw TestException()\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            finish(4)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/WithTimeoutTest.kt",
        "content": "\n@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\", \"UNREACHABLE_CODE\") // KT-21913\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass WithTimeoutTest : TestBase() {\n    /**\n     * Tests a case of no timeout and no suspension inside.\n     */\n    @Test\n    fun testBasicNoSuspend() = runTest {\n        expect(1)\n        val result = withTimeout(10_000) {\n            expect(2)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    /**\n     * Tests a case of no timeout and one suspension inside.\n     */\n    @Test\n    fun testBasicSuspend() = runTest {\n        expect(1)\n        val result = withTimeout(10_000) {\n            expect(2)\n            yield()\n            expect(3)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(4)\n    }\n\n    /**\n     * Tests proper dispatching of `withTimeout` blocks\n     */\n    @Test\n    fun testDispatch() = runTest {\n        expect(1)\n        launch {\n            expect(4)\n            yield() // back to main\n            expect(7)\n        }\n        expect(2)\n        // test that it does not yield to the above job when started\n        val result = withTimeout(1000) {\n            expect(3)\n            yield() // yield only now\n            expect(5)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        expect(6)\n        yield() // back to launch\n        finish(8)\n    }\n\n\n    /**\n     * Tests that a 100% CPU-consuming loop will react on timeout if it has yields.\n     */\n    @Test\n    fun testYieldBlockingWithTimeout() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        withTimeout(100) {\n            while (true) {\n                yield()\n            }\n        }\n    }\n\n    /**\n     * Tests that [withTimeout] waits for children coroutines to complete.\n     */\n    @Test\n    fun testWithTimeoutChildWait() = runTest {\n        expect(1)\n        withTimeout(100) {\n            expect(2)\n            // launch child with timeout\n            launch {\n                expect(4)\n            }\n            expect(3)\n            // now will wait for child before returning\n        }\n        finish(5)\n    }\n\n    @Test\n    fun testBadClass() = runTest {\n        val bad = BadClass()\n        val result = withTimeout(100) {\n            bad\n        }\n        assertSame(bad, result)\n    }\n\n    @Test\n    fun testExceptionOnTimeout() = runTest {\n        expect(1)\n        try {\n            withTimeout(100) {\n                expect(2)\n                delay(1000)\n                expectUnreached()\n                \"OK\"\n            }\n        } catch (e: CancellationException) {\n            assertEquals(\"Timed out waiting for 100 ms\", e.message)\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testSuppressExceptionWithResult() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        expect(1)\n        withTimeout(100) {\n            expect(2)\n            try {\n                delay(1000)\n            } catch (e: CancellationException) {\n                finish(3)\n            }\n            \"OK\"\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testSuppressExceptionWithAnotherException() = runTest{\n        expect(1)\n        try {\n            withTimeout(100) {\n                expect(2)\n                try {\n                    delay(1000)\n                } catch (e: CancellationException) {\n                    expect(3)\n                    throw TestException()\n                }\n                expectUnreached()\n                \"OK\"\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testNegativeTimeout() = runTest {\n        expect(1)\n        try {\n            withTimeout(-1) {\n                expectUnreached()\n                \"OK\"\n            }\n        } catch (e: TimeoutCancellationException) {\n            assertEquals(\"Timed out immediately\", e.message)\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testExceptionFromWithinTimeout() = runTest {\n        expect(1)\n        try {\n            expect(2)\n            withTimeout(1000) {\n                expect(3)\n                throw TestException()\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testIncompleteWithTimeoutState() = runTest {\n        lateinit var timeoutJob: Job\n        val handle = withTimeout(Long.MAX_VALUE) {\n            timeoutJob = coroutineContext[Job]!!\n            timeoutJob.invokeOnCompletion { }\n        }\n\n        handle.dispose()\n        timeoutJob.join()\n        assertTrue(timeoutJob.isCompleted)\n        assertFalse(timeoutJob.isActive)\n        assertFalse(timeoutJob.isCancelled)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/BasicOperationsTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass BasicOperationsTest : TestBase() {\n    @Test\n    fun testSimpleSendReceive() = runTest {\n        // Parametrized common test :(\n        TestChannelKind.values().forEach { kind -> testSendReceive(kind, 20) }\n    }\n\n    @Test\n    fun testTrySendToFullChannel() = runTest {\n        TestChannelKind.values().forEach { kind -> testTrySendToFullChannel(kind) }\n    }\n\n    @Test\n    fun testTrySendAfterClose() = runTest {\n        TestChannelKind.values().forEach { kind -> testTrySendAfterClose(kind) }\n    }\n\n    @Test\n    fun testSendAfterClose() = runTest {\n        TestChannelKind.values().forEach { kind -> testSendAfterClose(kind) }\n    }\n\n    @Test\n    fun testReceiveCatching() = runTest {\n        TestChannelKind.values().forEach { kind -> testReceiveCatching(kind) }\n    }\n\n    @Test\n    fun testInvokeOnClose() = TestChannelKind.values().forEach { kind ->\n        reset()\n        val channel = kind.create<Int>()\n        channel.invokeOnClose {\n            if (it is AssertionError) {\n                expect(3)\n            }\n        }\n        expect(1)\n        channel.trySend(42)\n        expect(2)\n        channel.close(AssertionError())\n        finish(4)\n    }\n\n    @Test\n    fun testInvokeOnClosed() = TestChannelKind.values().forEach { kind ->\n        reset()\n        expect(1)\n        val channel = kind.create<Int>()\n        channel.close()\n        channel.invokeOnClose { expect(2) }\n        assertFailsWith<IllegalStateException> { channel.invokeOnClose { expect(3) } }\n        finish(3)\n    }\n\n    @Test\n    fun testMultipleInvokeOnClose() = TestChannelKind.values().forEach { kind ->\n        reset()\n        val channel = kind.create<Int>()\n        channel.invokeOnClose { expect(3) }\n        expect(1)\n        assertFailsWith<IllegalStateException> { channel.invokeOnClose { expect(4) } }\n        expect(2)\n        channel.close()\n        finish(4)\n    }\n\n    @Test\n    fun testIterator() = runTest {\n        TestChannelKind.values().forEach { kind ->\n            val channel = kind.create<Int>()\n            val iterator = channel.iterator()\n            assertFailsWith<IllegalStateException> { iterator.next() }\n            channel.close()\n            assertFailsWith<IllegalStateException> { iterator.next() }\n            assertFalse(iterator.hasNext())\n        }\n    }\n\n    @Test\n    fun testCancelledChannelInvokeOnClose() {\n        val ch = Channel<Int>()\n        ch.invokeOnClose { assertIs<CancellationException>(it) }\n        ch.cancel()\n    }\n\n    @Test\n    fun testCancelledChannelWithCauseInvokeOnClose() {\n        val ch = Channel<Int>()\n        ch.invokeOnClose { assertIs<TimeoutCancellationException>(it) }\n        ch.cancel(TimeoutCancellationException(\"\"))\n    }\n\n    @Test\n    fun testThrowingInvokeOnClose() = runTest {\n        val channel = Channel<Int>()\n        channel.invokeOnClose {\n            assertNull(it)\n            expect(3)\n            throw TestException()\n        }\n\n        launch {\n            try {\n                expect(2)\n                channel.close()\n            } catch (e: TestException) {\n                expect(4)\n            }\n        }\n        expect(1)\n        yield()\n        assertTrue(channel.isClosedForReceive)\n        assertTrue(channel.isClosedForSend)\n        assertFalse(channel.close())\n        finish(5)\n    }\n\n    @Suppress(\"ReplaceAssertBooleanWithAssertEquality\")\n    private suspend fun testReceiveCatching(kind: TestChannelKind) = coroutineScope {\n        reset()\n        val channel = kind.create<Int>()\n        launch {\n            expect(2)\n            channel.send(1)\n        }\n\n        expect(1)\n        val result = channel.receiveCatching()\n        assertEquals(1, result.getOrThrow())\n        assertEquals(1, result.getOrNull())\n        assertTrue(ChannelResult.success(1) == result)\n\n        expect(3)\n        launch {\n            expect(4)\n            channel.close()\n        }\n        val closed = channel.receiveCatching()\n        expect(5)\n        assertNull(closed.getOrNull())\n        assertTrue(closed.isClosed)\n        assertNull(closed.exceptionOrNull())\n        assertTrue(ChannelResult.closed<Int>(closed.exceptionOrNull()) == closed)\n        finish(6)\n    }\n\n    private suspend fun testTrySendAfterClose(kind: TestChannelKind) = coroutineScope {\n        val channel = kind.create<Int>()\n        val d = async { channel.send(42) }\n        yield()\n        channel.close()\n\n        assertTrue(channel.isClosedForSend)\n        channel.trySend(2)\n            .onSuccess { expectUnreached() }\n            .onClosed {\n                assertTrue { it is ClosedSendChannelException }\n                if (!kind.isConflated) {\n                    assertEquals(42, channel.receive())\n                }\n            }\n        d.await()\n    }\n\n    private suspend fun testTrySendToFullChannel(kind: TestChannelKind) = coroutineScope {\n        if (kind.isConflated || kind.capacity == Int.MAX_VALUE) return@coroutineScope\n        val channel = kind.create<Int>()\n        // Make it full\n        repeat(11) {\n            channel.trySend(42)\n        }\n        channel.trySend(1)\n            .onSuccess { expectUnreached() }\n            .onFailure { assertNull(it) }\n            .onClosed {\n                expectUnreached()\n            }\n    }\n\n    /**\n     * [ClosedSendChannelException] should not be eaten.\n     * See [https://github.com/Kotlin/kotlinx.coroutines/issues/957]\n     */\n    private suspend fun testSendAfterClose(kind: TestChannelKind) {\n        assertFailsWith<ClosedSendChannelException> {\n            coroutineScope {\n                val channel = kind.create<Int>()\n                channel.close()\n\n                launch {\n                    channel.send(1)\n                }\n            }\n        }\n    }\n\n    private suspend fun testSendReceive(kind: TestChannelKind, iterations: Int) = coroutineScope {\n        val channel = kind.create<Int>()\n        launch {\n            repeat(iterations) { channel.send(it) }\n            channel.close()\n        }\n        var expected = 0\n        for (x in channel) {\n            if (!kind.isConflated) {\n                assertEquals(expected++, x)\n            } else {\n                assertTrue(x >= expected)\n                expected = x + 1\n            }\n        }\n        if (!kind.isConflated) {\n            assertEquals(iterations, expected)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/BroadcastChannelFactoryTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\n\nclass BroadcastChannelFactoryTest : TestBase() {\n\n    @Test\n    fun testRendezvousChannelNotSupported() {\n        assertFailsWith<IllegalArgumentException> { BroadcastChannel<Int>(0) }\n    }\n\n    @Test\n    fun testUnlimitedChannelNotSupported() {\n        assertFailsWith<IllegalArgumentException> { BroadcastChannel<Int>(Channel.UNLIMITED) }\n    }\n\n    @Test\n    fun testConflatedBroadcastChannel() {\n        assertTrue { BroadcastChannel<Int>(Channel.CONFLATED) is ConflatedBroadcastChannel }\n    }\n\n    @Test\n    fun testBufferedBroadcastChannel() {\n        assertTrue { BroadcastChannel<Int>(1) is BroadcastChannelImpl }\n        assertTrue { BroadcastChannel<Int>(10) is BroadcastChannelImpl }\n    }\n\n    @Test\n    fun testInvalidCapacityNotSupported() {\n        assertFailsWith<IllegalArgumentException> { BroadcastChannel<Int>(-3) }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/BroadcastTest.kt",
        "content": "@file:Suppress(\"DEPRECATION\")\n\npackage kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.test.*\n\nclass BroadcastTest : TestBase() {\n    @Test\n    fun testBroadcastBasic() = runTest {\n        expect(1)\n        val b = broadcast {\n            expect(4)\n            send(1) // goes to receiver\n            expect(5)\n            select<Unit> { onSend(2) {} } // goes to buffer\n            expect(6)\n            send(3) // suspends, will not be consumes, but will not be cancelled either\n            expect(10)\n        }\n        yield() // has no effect, because default is lazy\n        expect(2)\n\n        val subscription = b.openSubscription()\n        expect(3)\n        assertEquals(1, subscription.receive()) // suspends\n        expect(7)\n        assertEquals(2, subscription.receive()) // suspends\n        expect(8)\n        subscription.cancel()\n        expect(9)\n        yield() // to broadcast\n        finish(11)\n    }\n\n    /**\n     * See https://github.com/Kotlin/kotlinx.coroutines/issues/1713\n     */\n    @Test\n    fun testChannelBroadcastLazyCancel() = runTest {\n        expect(1)\n        val a = produce {\n            expect(3)\n            assertFailsWith<CancellationException> { send(\"MSG\") }\n            expect(5)\n        }\n        expect(2)\n        yield() // to produce\n        val b = a.broadcast()\n        b.cancel()\n        expect(4)\n        yield() // to abort produce\n        assertTrue(a.isClosedForReceive) // the source channel was consumed\n        finish(6)\n    }\n\n    @Test\n    fun testChannelBroadcastLazyClose() = runTest {\n        expect(1)\n        val a = produce {\n            expect(3)\n            send(\"MSG\")\n            expectUnreached() // is not executed, because send is cancelled\n        }\n        expect(2)\n        yield() // to produce\n        val b = a.broadcast()\n        b.close()\n        expect(4)\n        yield() // to abort produce\n        assertTrue(a.isClosedForReceive) // the source channel was consumed\n        finish(5)\n    }\n\n    @Test\n    fun testChannelBroadcastEagerCancel() = runTest {\n        expect(1)\n        val a = produce<Unit> {\n            expect(3)\n            yield() // back to main\n            expectUnreached() // will be cancelled\n        }\n        expect(2)\n        val b = a.broadcast(start = CoroutineStart.DEFAULT)\n        yield() // to produce\n        expect(4)\n        b.cancel()\n        yield() // to produce (cancelled)\n        assertTrue(a.isClosedForReceive) // the source channel was consumed\n        finish(5)\n    }\n\n    @Test\n    fun testChannelBroadcastEagerClose() = runTest {\n        expect(1)\n        val a = produce<Unit> {\n            expect(3)\n            yield() // back to main\n            // shall eventually get cancelled\n            assertFailsWith<CancellationException> {\n                while (true) { send(Unit) }\n            }\n        }\n        expect(2)\n        val b = a.broadcast(start = CoroutineStart.DEFAULT)\n        yield() // to produce\n        expect(4)\n        b.close()\n        yield() // to produce (closed)\n        assertTrue(a.isClosedForReceive) // the source channel was consumed\n        finish(5)\n    }\n\n    @Test\n    fun testBroadcastCloseWithException() = runTest {\n        expect(1)\n        val b = broadcast(NonCancellable, capacity = 1) {\n            expect(2)\n            send(1)\n            expect(3)\n            send(2) // suspends\n            expect(5)\n            // additional attempts to send fail\n            assertFailsWith<TestException> { send(3) }\n        }\n        val sub = b.openSubscription()\n        yield() // into broadcast\n        expect(4)\n        b.close(TestException()) // close broadcast channel with exception\n        assertTrue(b.isClosedForSend) // sub was also closed\n        assertEquals(1, sub.receive()) // 1st element received\n        assertEquals(2, sub.receive()) // 2nd element received\n        assertFailsWith<TestException> { sub.receive() } // then closed with exception\n        yield() // to cancel broadcast\n        finish(6)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/BufferedBroadcastChannelTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass BufferedBroadcastChannelTest : TestBase() {\n\n    @Test\n    fun testConcurrentModification() = runTest {\n        val channel = BroadcastChannel<Int>(1)\n        val s1 = channel.openSubscription()\n        val s2 = channel.openSubscription()\n\n        val job1 = launch(Dispatchers.Unconfined, CoroutineStart.UNDISPATCHED) {\n            expect(1)\n            s1.receive()\n            s1.cancel()\n        }\n\n        val job2 = launch(Dispatchers.Unconfined, CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            s2.receive()\n        }\n\n        expect(3)\n        channel.send(1)\n        joinAll(job1, job2)\n        finish(4)\n    }\n\n    @Test\n    fun testBasic() = runTest {\n        expect(1)\n        val broadcast = BroadcastChannel<Int>(1)\n        assertFalse(broadcast.isClosedForSend)\n        val first = broadcast.openSubscription()\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            assertEquals(1, first.receive()) // suspends\n            assertFalse(first.isClosedForReceive)\n            expect(5)\n            assertEquals(2, first.receive()) // suspends\n            assertFalse(first.isClosedForReceive)\n            expect(10)\n            assertTrue(first.receiveCatching().isClosed) // suspends\n            assertTrue(first.isClosedForReceive)\n            expect(14)\n        }\n        expect(3)\n        broadcast.send(1)\n        expect(4)\n        yield() // to the first receiver\n        expect(6)\n\n        val second = broadcast.openSubscription()\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(7)\n            assertEquals(2, second.receive()) // suspends\n            assertFalse(second.isClosedForReceive)\n            expect(11)\n            assertNull(second.receiveCatching().getOrNull()) // suspends\n            assertTrue(second.isClosedForReceive)\n            expect(15)\n        }\n        expect(8)\n        broadcast.send(2)\n        expect(9)\n        yield() // to first & second receivers\n        expect(12)\n        broadcast.close()\n        expect(13)\n        assertTrue(broadcast.isClosedForSend)\n        yield() // to first & second receivers\n        finish(16)\n    }\n\n    @Test\n    fun testSendSuspend() = runTest {\n        expect(1)\n        val broadcast = BroadcastChannel<Int>(1)\n        val first = broadcast.openSubscription()\n        launch {\n            expect(4)\n            assertEquals(1, first.receive())\n            expect(5)\n            assertEquals(2, first.receive())\n            expect(6)\n        }\n        expect(2)\n        broadcast.send(1) // puts to buffer, receiver not running yet\n        expect(3)\n        broadcast.send(2) // suspends\n        finish(7)\n    }\n\n    @Test\n    fun testConcurrentSendCompletion() = runTest {\n        expect(1)\n        val broadcast = BroadcastChannel<Int>(1)\n        val sub = broadcast.openSubscription()\n        // launch 3 concurrent senders (one goes buffer, two other suspend)\n        for (x in 1..3) {\n            launch(start = CoroutineStart.UNDISPATCHED) {\n                expect(x + 1)\n                broadcast.send(x)\n            }\n        }\n        // and close it for send\n        expect(5)\n        broadcast.close()\n        // now must receive all 3 items\n        expect(6)\n        assertFalse(sub.isClosedForReceive)\n        for (x in 1..3)\n            assertEquals(x, sub.receiveCatching().getOrNull())\n        // and receive close signal\n        assertNull(sub.receiveCatching().getOrNull())\n        assertTrue(sub.isClosedForReceive)\n        finish(7)\n    }\n\n    @Test\n    fun testForgetUnsubscribed() = runTest {\n        expect(1)\n        val broadcast = BroadcastChannel<Int>(1)\n        broadcast.send(1)\n        broadcast.send(2)\n        broadcast.send(3)\n        expect(2) // should not suspend anywhere above\n        val sub = broadcast.openSubscription()\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(3)\n            assertEquals(4, sub.receive()) // suspends\n            expect(5)\n        }\n        expect(4)\n        broadcast.send(4) // sends\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testReceiveFullAfterClose() = runTest {\n        val channel = BroadcastChannel<Int>(10)\n        val sub = channel.openSubscription()\n        // generate into buffer & close\n        for (x in 1..5) channel.send(x)\n        channel.close()\n        // make sure all of them are consumed\n        check(!sub.isClosedForReceive)\n        for (x in 1..5) check(sub.receive() == x)\n        check(sub.receiveCatching().getOrNull() == null)\n        check(sub.isClosedForReceive)\n    }\n\n    @Test\n    fun testCloseSubDuringIteration() = runTest {\n        val channel = BroadcastChannel<Int>(1)\n        // launch generator (for later) in this context\n        launch {\n            for (x in 1..5) {\n                channel.send(x)\n            }\n            channel.close()\n        }\n        // start consuming\n        val sub = channel.openSubscription()\n        var expected = 0\n        assertFailsWith<CancellationException> {\n            sub.consumeEach {\n                check(it == ++expected)\n                if (it == 2) {\n                    sub.cancel()\n                }\n            }\n        }\n        check(expected == 2)\n    }\n\n    @Test\n    fun testReceiveFromCancelledSub() = runTest {\n        val channel = BroadcastChannel<Int>(1)\n        val sub = channel.openSubscription()\n        assertFalse(sub.isClosedForReceive)\n        sub.cancel()\n        assertTrue(sub.isClosedForReceive)\n        assertFailsWith<CancellationException> { sub.receive() }\n    }\n\n    @Test\n    fun testCancelWithCause() = runTest({ it is TestCancellationException }) {\n        val channel = BroadcastChannel<Int>(1)\n        val subscription = channel.openSubscription()\n        subscription.cancel(TestCancellationException())\n        subscription.receive()\n    }\n\n    @Test\n    fun testReceiveNoneAfterCancel() = runTest {\n        val channel = BroadcastChannel<Int>(10)\n        val sub = channel.openSubscription()\n        // generate into buffer & cancel\n        for (x in 1..5) channel.send(x)\n        channel.cancel()\n        assertTrue(channel.isClosedForSend)\n        assertTrue(sub.isClosedForReceive)\n        check(sub.receiveCatching().getOrNull() == null)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/BufferedChannelTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass BufferedChannelTest : TestBase() {\n    @Test\n    fun testSimple() = runTest {\n        val q = Channel<Int>(1)\n        check(q.isEmpty)\n        expect(1)\n        val sender = launch {\n            expect(4)\n            q.send(1) // success -- buffered\n            check(!q.isEmpty)\n            expect(5)\n            q.send(2) // suspends (buffer full)\n            expect(9)\n        }\n        expect(2)\n        val receiver = launch {\n            expect(6)\n            check(q.receive() == 1) // does not suspend -- took from buffer\n            check(!q.isEmpty) // waiting sender's element moved to buffer\n            expect(7)\n            check(q.receive() == 2) // does not suspend (takes from sender)\n            expect(8)\n        }\n        expect(3)\n        sender.join()\n        receiver.join()\n        check(q.isEmpty)\n        (q as BufferedChannel<*>).checkSegmentStructureInvariants()\n        finish(10)\n    }\n\n    @Test\n    fun testClosedBufferedReceiveCatching() = runTest {\n        val q = Channel<Int>(1)\n        check(q.isEmpty && !q.isClosedForSend && !q.isClosedForReceive)\n        expect(1)\n        launch {\n            expect(5)\n            check(!q.isEmpty && q.isClosedForSend && !q.isClosedForReceive)\n            assertEquals(42, q.receiveCatching().getOrNull())\n            expect(6)\n            check(!q.isEmpty && q.isClosedForSend && q.isClosedForReceive)\n            assertNull(q.receiveCatching().getOrNull())\n            expect(7)\n        }\n        expect(2)\n        q.send(42) // buffers\n        expect(3)\n        q.close() // goes on\n        expect(4)\n        check(!q.isEmpty && q.isClosedForSend && !q.isClosedForReceive)\n        yield()\n        check(!q.isEmpty && q.isClosedForSend && q.isClosedForReceive)\n        (q as BufferedChannel<*>).checkSegmentStructureInvariants()\n        finish(8)\n    }\n\n    @Test\n    fun testClosedExceptions() = runTest {\n        val q = Channel<Int>(1)\n        expect(1)\n        launch {\n            expect(4)\n            try { q.receive() }\n            catch (e: ClosedReceiveChannelException) {\n                expect(5)\n            }\n        }\n        expect(2)\n\n        require(q.close())\n        expect(3)\n        yield()\n        expect(6)\n        try { q.send(42) }\n        catch (e: ClosedSendChannelException) {\n            (q as BufferedChannel<*>).checkSegmentStructureInvariants()\n            finish(7)\n        }\n    }\n\n    @Test\n    fun testTryOp() = runTest {\n        val q = Channel<Int>(1)\n        assertTrue(q.trySend(1).isSuccess)\n        expect(1)\n        launch {\n            expect(3)\n            assertEquals(1, q.tryReceive().getOrNull())\n            expect(4)\n            assertNull(q.tryReceive().getOrNull())\n            expect(5)\n            assertEquals(2, q.receive()) // suspends\n            expect(9)\n            assertEquals(3, q.tryReceive().getOrNull())\n            expect(10)\n            assertNull(q.tryReceive().getOrNull())\n            expect(11)\n        }\n        expect(2)\n        yield()\n        expect(6)\n        assertTrue(q.trySend(2).isSuccess)\n        expect(7)\n        assertTrue(q.trySend(3).isSuccess)\n        expect(8)\n        assertFalse(q.trySend(4).isSuccess)\n        yield()\n        (q as BufferedChannel<*>).checkSegmentStructureInvariants()\n        finish(12)\n    }\n\n    @Test\n    fun testConsumeAll() = runTest {\n        val q = Channel<Int>(5)\n        for (i in 1..10) {\n            if (i <= 5) {\n                expect(i)\n                q.send(i) // shall buffer\n            } else {\n                launch(start = CoroutineStart.UNDISPATCHED) {\n                    expect(i)\n                    q.send(i) // suspends\n                    expectUnreached() // will get cancelled by cancel\n                }\n            }\n        }\n        expect(11)\n        q.cancel()\n        check(q.isClosedForSend)\n        check(q.isClosedForReceive)\n        assertFailsWith<CancellationException> { q.receiveCatching().getOrThrow() }\n        (q as BufferedChannel<*>).checkSegmentStructureInvariants()\n        finish(12)\n    }\n\n    @Test\n    fun testCancelWithCause() = runTest({ it is TestCancellationException }) {\n        val channel = Channel<Int>(5)\n        channel.cancel(TestCancellationException())\n        channel.receive()\n    }\n\n    @Test\n    fun testBufferSize() = runTest {\n        val capacity = 42\n        val channel = Channel<Int>(capacity)\n        checkBufferChannel(channel, capacity)\n    }\n\n    @Test\n    fun testBufferSizeFromTheMiddle() = runTest {\n        val capacity = 42\n        val channel = Channel<Int>(capacity)\n        repeat(4) {\n            channel.trySend(-1)\n        }\n        repeat(4) {\n            channel.receiveCatching().getOrNull()\n        }\n        checkBufferChannel(channel, capacity)\n    }\n\n    @Test\n    fun testBufferIsNotPreallocated() {\n        (0..100_000).map { Channel<Int>(Int.MAX_VALUE / 2) }\n    }\n\n    private suspend fun CoroutineScope.checkBufferChannel(\n        channel: Channel<Int>,\n        capacity: Int\n    ) {\n        launch {\n            expect(2)\n            repeat(42) {\n                channel.send(it)\n            }\n            expect(3)\n            channel.send(42)\n            expect(5)\n            channel.close()\n        }\n\n        expect(1)\n        yield()\n\n        expect(4)\n        val result = ArrayList<Int>(42)\n        channel.consumeEach {\n            result.add(it)\n        }\n        assertEquals((0..capacity).toList(), result)\n        (channel as BufferedChannel<*>).checkSegmentStructureInvariants()\n        finish(6)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ChannelBufferOverflowTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass ChannelBufferOverflowTest : TestBase() {\n    @Test\n    fun testDropLatest() = runTest {\n        val c = Channel<Int>(2, BufferOverflow.DROP_LATEST)\n        assertTrue(c.trySend(1).isSuccess)\n        assertTrue(c.trySend(2).isSuccess)\n        assertTrue(c.trySend(3).isSuccess) // overflows, dropped\n        c.send(4) // overflows dropped\n        assertEquals(1, c.receive())\n        assertTrue(c.trySend(5).isSuccess)\n        assertTrue(c.trySend(6).isSuccess) // overflows, dropped\n        assertEquals(2, c.receive())\n        assertEquals(5, c.receive())\n        assertEquals(null, c.tryReceive().getOrNull())\n    }\n\n    @Test\n    fun testDropOldest() = runTest {\n        val c = Channel<Int>(2, BufferOverflow.DROP_OLDEST)\n        assertTrue(c.trySend(1).isSuccess)\n        assertTrue(c.trySend(2).isSuccess)\n        assertTrue(c.trySend(3).isSuccess) // overflows, keeps 2, 3\n        c.send(4) // overflows, keeps 3, 4\n        assertEquals(3, c.receive())\n        assertTrue(c.trySend(5).isSuccess)\n        assertTrue(c.trySend(6).isSuccess) // overflows, keeps 5, 6\n        assertEquals(5, c.receive())\n        assertEquals(6, c.receive())\n        assertEquals(null, c.tryReceive().getOrNull())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ChannelFactoryTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\n\nclass ChannelFactoryTest : TestBase() {\n    @Test\n    fun testRendezvousChannel() {\n        assertIs<BufferedChannel<*>>(Channel<Int>())\n        assertIs<BufferedChannel<*>>(Channel<Int>(0))\n    }\n\n    @Test\n    fun testUnlimitedChannel() {\n        assertIs<BufferedChannel<*>>(Channel<Int>(Channel.UNLIMITED))\n        assertIs<BufferedChannel<*>>(Channel<Int>(Channel.UNLIMITED, BufferOverflow.DROP_OLDEST))\n        assertIs<BufferedChannel<*>>(Channel<Int>(Channel.UNLIMITED, BufferOverflow.DROP_LATEST))\n    }\n\n    @Test\n    fun testConflatedChannel() {\n        assertIs<ConflatedBufferedChannel<*>>(Channel<Int>(Channel.CONFLATED))\n        assertIs<ConflatedBufferedChannel<*>>(Channel<Int>(1, BufferOverflow.DROP_OLDEST))\n    }\n\n    @Test\n    fun testBufferedChannel() {\n        assertIs<BufferedChannel<*>>(Channel<Int>(1))\n        assertIs<ConflatedBufferedChannel<*>>(Channel<Int>(1, BufferOverflow.DROP_LATEST))\n        assertIs<BufferedChannel<*>>(Channel<Int>(10))\n    }\n\n    @Test\n    fun testInvalidCapacityNotSupported() {\n        assertFailsWith<IllegalArgumentException> { Channel<Int>(-3) }\n    }\n    \n    @Test\n    fun testUnsupportedBufferOverflow() {\n        assertFailsWith<IllegalArgumentException> { Channel<Int>(Channel.CONFLATED, BufferOverflow.DROP_OLDEST) }\n        assertFailsWith<IllegalArgumentException> { Channel<Int>(Channel.CONFLATED, BufferOverflow.DROP_LATEST) }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ChannelReceiveCatchingTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass ChannelReceiveCatchingTest : TestBase() {\n    @Test\n    fun testChannelOfThrowables() = runTest {\n        val channel = Channel<Throwable>()\n        launch {\n            channel.send(TestException1())\n            channel.close(TestException2())\n        }\n\n        val element = channel.receiveCatching()\n        assertIs<TestException1>(element.getOrThrow())\n        assertIs<TestException1>(element.getOrNull())\n\n        val closed = channel.receiveCatching()\n        assertTrue(closed.isClosed)\n        assertTrue(closed.isFailure)\n        assertIs<TestException2>(closed.exceptionOrNull())\n    }\n\n    @Test\n    @Suppress(\"ReplaceAssertBooleanWithAssertEquality\") // inline classes test\n    fun testNullableIntChanel() = runTest {\n        val channel = Channel<Int?>()\n        launch {\n            expect(2)\n            channel.send(1)\n            expect(3)\n            channel.send(null)\n\n            expect(6)\n            channel.close()\n        }\n\n        expect(1)\n        val element = channel.receiveCatching()\n        assertEquals(1, element.getOrThrow())\n        assertEquals(1, element.getOrNull())\n        assertEquals(\"Value(1)\", element.toString())\n        assertTrue(ChannelResult.success(1) == element) // Don't box\n        assertFalse(element.isFailure)\n        assertFalse(element.isClosed)\n\n        expect(4)\n        val nullElement = channel.receiveCatching()\n        assertNull(nullElement.getOrThrow())\n        assertNull(nullElement.getOrNull())\n        assertEquals(\"Value(null)\", nullElement.toString())\n        assertTrue(ChannelResult.success(null) == nullElement) // Don't box\n        assertFalse(element.isFailure)\n        assertFalse(element.isClosed)\n\n        expect(5)\n        val closed = channel.receiveCatching()\n        assertTrue(closed.isClosed)\n        assertTrue(closed.isFailure)\n\n        val closed2 = channel.receiveCatching()\n        assertTrue(closed2.isClosed)\n        assertTrue(closed.isFailure)\n        assertNull(closed2.exceptionOrNull())\n        finish(7)\n    }\n\n    @Test\n    @ExperimentalUnsignedTypes\n    fun testUIntChannel() = runTest {\n        val channel = Channel<UInt>()\n        launch {\n            expect(2)\n            channel.send(1u)\n            yield()\n            expect(4)\n            channel.send((Long.MAX_VALUE - 1).toUInt())\n            expect(5)\n        }\n\n        expect(1)\n        val element = channel.receiveCatching()\n        assertEquals(1u, element.getOrThrow())\n\n        expect(3)\n        val element2 = channel.receiveCatching()\n        assertEquals((Long.MAX_VALUE - 1).toUInt(), element2.getOrThrow())\n        finish(6)\n    }\n\n    @Test\n    fun testCancelChannel() = runTest {\n        val channel = Channel<Boolean>()\n        launch {\n            expect(2)\n            channel.cancel()\n        }\n\n        expect(1)\n        val closed = channel.receiveCatching()\n        assertTrue(closed.isClosed)\n        assertTrue(closed.isFailure)\n        finish(3)\n    }\n\n    @Test\n    @ExperimentalUnsignedTypes\n    fun testReceiveResultChannel() = runTest {\n        val channel = Channel<ChannelResult<UInt>>()\n        launch {\n            channel.send(ChannelResult.success(1u))\n            channel.send(ChannelResult.closed(TestException1()))\n            channel.close(TestException2())\n        }\n\n        val intResult = channel.receiveCatching()\n        assertEquals(1u, intResult.getOrThrow().getOrThrow())\n        assertFalse(intResult.isFailure)\n        assertFalse(intResult.isClosed)\n\n        val closeCauseResult = channel.receiveCatching()\n        assertIs<TestException1>(closeCauseResult.getOrThrow().exceptionOrNull())\n\n        val closeCause = channel.receiveCatching()\n        assertTrue(closeCause.isClosed)\n        assertTrue(closeCause.isFailure)\n        assertIs<TestException2>(closeCause.exceptionOrNull())\n    }\n\n    @Test\n    fun testToString() = runTest {\n        val channel = Channel<String>(1)\n        channel.send(\"message\")\n        channel.close(TestException1(\"OK\"))\n        assertEquals(\"Value(message)\", channel.receiveCatching().toString())\n        // toString implementation for exception differs on every platform\n        val str = channel.receiveCatching().toString()\n        if (!str.matches(\"Closed\\\\(.*TestException1: OK\\\\)\".toRegex()))\n            error(\"Unexpected string: '$str'\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ChannelUndeliveredElementFailureTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.test.*\n\n/**\n * Tests for failures inside `onUndeliveredElement` handler in [Channel].\n */\nclass ChannelUndeliveredElementFailureTest : TestBase() {\n    private val item = \"LOST\"\n    private val onCancelFail: (String) -> Unit = { throw TestException(it) }\n    private val shouldBeUnhandled: List<(Throwable) -> Boolean> = listOf({ it.isElementCancelException() })\n\n    private fun Throwable.isElementCancelException() =\n        this is UndeliveredElementException && cause is TestException && cause!!.message == item\n\n    @Test\n    fun testSendCancelledFail() = runTest(unhandled = shouldBeUnhandled) {\n        val channel = Channel(onUndeliveredElement = onCancelFail)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            channel.send(item)\n            expectUnreached()\n        }\n        job.cancel()\n    }\n\n    @Test\n    fun testSendSelectCancelledFail() = runTest(unhandled = shouldBeUnhandled) {\n        val channel = Channel(onUndeliveredElement = onCancelFail)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            select {\n                channel.onSend(item) {\n                    expectUnreached()\n                }\n            }\n        }\n        job.cancel()\n    }\n\n    @Test\n    fun testReceiveCancelledFail() = runTest(unhandled = shouldBeUnhandled) {\n        val channel = Channel(onUndeliveredElement = onCancelFail)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            channel.receive()\n            expectUnreached() // will be cancelled before it dispatches\n        }\n        channel.send(item)\n        job.cancel()\n    }\n\n    @Test\n    fun testReceiveSelectCancelledFail() = runTest(unhandled = shouldBeUnhandled) {\n        val channel = Channel(onUndeliveredElement = onCancelFail)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            select<Unit> {\n                channel.onReceive {\n                    expectUnreached()\n                }\n            }\n            expectUnreached() // will be cancelled before it dispatches\n        }\n        channel.send(item)\n        job.cancel()\n    }\n\n    @Test\n    fun testReceiveCatchingCancelledFail() = runTest(unhandled = shouldBeUnhandled) {\n        val channel = Channel(onUndeliveredElement = onCancelFail)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            channel.receiveCatching()\n            expectUnreached() // will be cancelled before it dispatches\n        }\n        channel.send(item)\n        job.cancel()\n    }\n\n    @Test\n    fun testReceiveOrClosedSelectCancelledFail() = runTest(unhandled = shouldBeUnhandled) {\n        val channel = Channel(onUndeliveredElement = onCancelFail)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            select<Unit> {\n                channel.onReceiveCatching {\n                    expectUnreached()\n                }\n            }\n            expectUnreached() // will be cancelled before it dispatches\n        }\n        channel.send(item)\n        job.cancel()\n    }\n\n    @Test\n    fun testHasNextCancelledFail() = runTest(unhandled = shouldBeUnhandled) {\n        val channel = Channel(onUndeliveredElement = onCancelFail)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            channel.iterator().hasNext()\n            expectUnreached() // will be cancelled before it dispatches\n        }\n        channel.send(item)\n        job.cancel()\n    }\n\n    @Test\n    fun testChannelCancelledFail() = runTest(expected = { it.isElementCancelException() }) {\n        val channel = Channel(1, onUndeliveredElement = onCancelFail)\n        channel.send(item)\n        channel.cancel()\n        expectUnreached()\n    }\n\n    @Test\n    fun testFailedHandlerInClosedConflatedChannel() = runTest(expected = { it is UndeliveredElementException }) {\n        val conflated = Channel<Int>(Channel.CONFLATED, onUndeliveredElement = {\n            finish(2)\n            throw TestException()\n        })\n        expect(1)\n        conflated.close(IndexOutOfBoundsException())\n        conflated.send(3)\n    }\n\n    @Test\n    fun testFailedHandlerInClosedBufferedChannel() = runTest(expected = { it is UndeliveredElementException }) {\n        val conflated = Channel<Int>(3, onUndeliveredElement = {\n            finish(2)\n            throw TestException()\n        })\n        expect(1)\n        conflated.close(IndexOutOfBoundsException())\n        conflated.send(3)\n    }\n\n    @Test\n    fun testSendDropOldestInvokeHandlerBuffered() = runTest(expected = { it is UndeliveredElementException }) {\n        val channel = Channel<Int>(1, BufferOverflow.DROP_OLDEST, onUndeliveredElement = {\n            finish(2)\n            throw TestException()\n        })\n\n        channel.send(42)\n        expect(1)\n        channel.send(12)\n    }\n\n    @Test\n    fun testSendDropLatestInvokeHandlerBuffered() = runTest(expected = { it is UndeliveredElementException }) {\n        val channel = Channel<Int>(2, BufferOverflow.DROP_LATEST, onUndeliveredElement = {\n            finish(2)\n            throw TestException()\n        })\n\n        channel.send(42)\n        channel.send(12)\n        expect(1)\n        channel.send(12)\n        expectUnreached()\n    }\n\n    @Test\n    fun testSendDropOldestInvokeHandlerConflated() = runTest(expected = { it is UndeliveredElementException }) {\n        val channel = Channel<Int>(Channel.CONFLATED, onUndeliveredElement = {\n            finish(2)\n            throw TestException()\n        })\n        channel.send(42)\n        expect(1)\n        channel.send(42)\n        expectUnreached()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ChannelUndeliveredElementTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass ChannelUndeliveredElementTest : TestBase() {\n    @Test\n    fun testSendSuccessfully() = runTest {\n        runAllKindsTest { kind ->\n            val channel = kind.create<Resource> { it.cancel() }\n            val res = Resource(\"OK\")\n            launch {\n                channel.send(res)\n            }\n            val ok = channel.receive()\n            assertEquals(\"OK\", ok.value)\n            assertFalse(res.isCancelled) // was not cancelled\n            channel.close()\n            assertFalse(res.isCancelled) // still was not cancelled\n        }\n    }\n\n    @Test\n    fun testRendezvousSendCancelled() = runTest {\n        val channel = Channel<Resource> { it.cancel() }\n        val res = Resource(\"OK\")\n        val sender = launch(start = CoroutineStart.UNDISPATCHED) {\n            assertFailsWith<CancellationException> {\n                channel.send(res) // suspends & get cancelled\n            }\n        }\n        sender.cancelAndJoin()\n        assertTrue(res.isCancelled)\n    }\n\n    @Test\n    fun testBufferedSendCancelled() = runTest {\n        val channel = Channel<Resource>(1) { it.cancel() }\n        val resA = Resource(\"A\")\n        val resB = Resource(\"B\")\n        val sender = launch(start = CoroutineStart.UNDISPATCHED) {\n            channel.send(resA) // goes to buffer\n            assertFailsWith<CancellationException> {\n                channel.send(resB) // suspends & get cancelled\n            }\n        }\n        sender.cancelAndJoin()\n        assertFalse(resA.isCancelled) // it is in buffer, not cancelled\n        assertTrue(resB.isCancelled) // send was cancelled\n        channel.cancel() // now cancel the channel\n        assertTrue(resA.isCancelled) // now cancelled in buffer\n    }\n\n    @Test\n    fun testUnlimitedChannelCancelled() = runTest {\n        val channel = Channel<Resource>(Channel.UNLIMITED) { it.cancel() }\n        val resA = Resource(\"A\")\n        val resB = Resource(\"B\")\n        channel.send(resA) // goes to buffer\n        channel.send(resB) // goes to buffer\n        assertFalse(resA.isCancelled) // it is in buffer, not cancelled\n        assertFalse(resB.isCancelled) //  it is in buffer, not cancelled\n        channel.cancel() // now cancel the channel\n        assertTrue(resA.isCancelled) // now cancelled in buffer\n        assertTrue(resB.isCancelled) // now cancelled in buffer\n    }\n\n    @Test\n    fun testConflatedResourceCancelled() = runTest {\n        val channel = Channel<Resource>(Channel.CONFLATED) { it.cancel() }\n        val resA = Resource(\"A\")\n        val resB = Resource(\"B\")\n        channel.send(resA)\n        assertFalse(resA.isCancelled)\n        assertFalse(resB.isCancelled)\n        channel.send(resB)\n        assertTrue(resA.isCancelled) // it was conflated (lost) and thus cancelled\n        assertFalse(resB.isCancelled)\n        channel.close()\n        assertFalse(resB.isCancelled) // not cancelled yet, can be still read by receiver\n        channel.cancel()\n        assertTrue(resB.isCancelled) // now it is cancelled\n    }\n\n    @Test\n    fun testSendToClosedChannel() = runTest {\n        runAllKindsTest { kind ->\n            val channel = kind.create<Resource> { it.cancel() }\n            channel.close() // immediately close channel\n            val res = Resource(\"OK\")\n            assertFailsWith<ClosedSendChannelException> {\n                channel.send(res) // send fails to closed channel, resource was not delivered\n            }\n            assertTrue(res.isCancelled)\n        }\n    }\n\n    private suspend fun runAllKindsTest(test: suspend CoroutineScope.(TestChannelKind) -> Unit) {\n        for (kind in TestChannelKind.values()) {\n            if (kind.viaBroadcast) continue // does not support onUndeliveredElement\n            try {\n                withContext(Job()) {\n                    test(kind)\n                }\n            } catch(e: Throwable) {\n                error(\"$kind: $e\", e)\n            }\n        }\n    }\n\n    private class Resource(val value: String) {\n        private val _cancelled = atomic(false)\n\n        val isCancelled: Boolean\n            get() = _cancelled.value\n\n        fun cancel() {\n            check(!_cancelled.getAndSet(true)) { \"Already cancelled\" }\n        }\n    }\n\n    @Test\n    fun testHandlerIsNotInvoked() = runTest { // #2826\n        val channel = Channel<Unit> {\n            expectUnreached()\n        }\n\n        expect(1)\n        launch {\n            expect(2)\n            channel.receive()\n        }\n        channel.send(Unit)\n        finish(3)\n    }\n\n    @Test\n    fun testChannelBufferOverflow() = runTest {\n        testBufferOverflowStrategy(listOf(1, 2), BufferOverflow.DROP_OLDEST)\n        testBufferOverflowStrategy(listOf(3), BufferOverflow.DROP_LATEST)\n    }\n\n    private suspend fun testBufferOverflowStrategy(expectedDroppedElements: List<Int>, strategy: BufferOverflow) {\n        val list = ArrayList<Int>()\n        val channel = Channel<Int>(\n            capacity = 2,\n            onBufferOverflow = strategy,\n            onUndeliveredElement = { value -> list.add(value) }\n        )\n\n        channel.send(1)\n        channel.send(2)\n\n        channel.send(3)\n        channel.trySend(4).onFailure { expectUnreached() }\n        assertEquals(expectedDroppedElements, list)\n    }\n\n\n    @Test\n    fun testTrySendDoesNotInvokeHandlerOnClosedConflatedChannel() = runTest {\n        val conflated = Channel<Int>(Channel.CONFLATED, onUndeliveredElement = {\n            expectUnreached()\n        })\n        conflated.close(IndexOutOfBoundsException())\n        conflated.trySend(3)\n    }\n\n    @Test\n    fun testTrySendDoesNotInvokeHandlerOnClosedChannel() = runTest {\n        val conflated = Channel<Int>(3, onUndeliveredElement = {\n            expectUnreached()\n        })\n        conflated.close(IndexOutOfBoundsException())\n        repeat(10) {\n            conflated.trySend(3)\n        }\n    }\n\n    @Test\n    fun testTrySendDoesNotInvokeHandler() {\n        for (capacity in 0..2) {\n            testTrySendDoesNotInvokeHandler(capacity)\n        }\n    }\n\n    private fun testTrySendDoesNotInvokeHandler(capacity: Int) {\n        val channel = Channel<Int>(capacity, BufferOverflow.DROP_LATEST, onUndeliveredElement = {\n            expectUnreached()\n        })\n        repeat(10) {\n            channel.trySend(3)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ChannelsTest.kt",
        "content": "@file:Suppress(\"DEPRECATION\")\n\npackage kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.math.*\nimport kotlin.test.*\n\nclass ChannelsTest: TestBase() {\n    private val testList = listOf(1, 2, 3)\n\n    @Test\n    fun testIterableAsReceiveChannel() = runTest {\n        assertEquals(testList, testList.asReceiveChannel().toList())\n    }\n\n    @Test\n    fun testCloseWithMultipleSuspendedReceivers() = runTest {\n        // Once the channel is closed, the waiting\n        // requests should be cancelled in the order\n        // they were suspended in the channel.\n        val channel = Channel<Int>()\n        launch {\n            try {\n                expect(2)\n                channel.receive()\n                expectUnreached()\n            } catch (e: ClosedReceiveChannelException) {\n                expect(5)\n            }\n        }\n\n        launch {\n            try {\n                expect(3)\n                channel.receive()\n                expectUnreached()\n            } catch (e: ClosedReceiveChannelException) {\n                expect(6)\n            }\n        }\n\n        expect(1)\n        yield()\n        expect(4)\n        channel.close()\n        yield()\n        finish(7)\n    }\n\n    @Test\n    fun testCloseWithMultipleSuspendedSenders() = runTest {\n        // Once the channel is closed, the waiting\n        // requests should be cancelled in the order\n        // they were suspended in the channel.\n        val channel = Channel<Int>()\n        launch {\n            try {\n                expect(2)\n                channel.send(42)\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(5)\n            }\n        }\n\n        launch {\n            try {\n                expect(3)\n                channel.send(42)\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(6)\n            }\n        }\n\n        expect(1)\n        yield()\n        expect(4)\n        channel.cancel()\n        yield()\n        finish(7)\n    }\n\n    @Test\n    fun testEmptyList() = runTest {\n        assertTrue(emptyList<Nothing>().asReceiveChannel().toList().isEmpty())\n    }\n\n    @Test\n    fun testToList() = runTest {\n        assertEquals(testList, testList.asReceiveChannel().toList())\n\n    }\n\n    private fun <E> Iterable<E>.asReceiveChannel(context: CoroutineContext = Dispatchers.Unconfined): ReceiveChannel<E> =\n        GlobalScope.produce(context) {\n            for (element in this@asReceiveChannel)\n                send(element)\n        }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ConflatedBroadcastChannelTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass ConflatedBroadcastChannelTest : TestBase() {\n\n    @Test\n    fun testConcurrentModification() = runTest {\n        val channel = ConflatedBroadcastChannel<Int>()\n        val s1 = channel.openSubscription()\n        val s2 = channel.openSubscription()\n\n        val job1 = launch(Dispatchers.Unconfined, CoroutineStart.UNDISPATCHED) {\n            expect(1)\n            s1.receive()\n            s1.cancel()\n        }\n\n        val job2 = launch(Dispatchers.Unconfined, CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            s2.receive()\n        }\n\n        expect(3)\n        channel.send(1)\n        joinAll(job1, job2)\n        finish(4)\n    }\n\n    @Test\n    fun testBasicScenario() = runTest {\n        expect(1)\n        val broadcast = ConflatedBroadcastChannel<String>()\n        assertIs<IllegalStateException>(exceptionFrom { broadcast.value })\n        assertNull(broadcast.valueOrNull)\n\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            val sub = broadcast.openSubscription()\n            assertNull(sub.tryReceive().getOrNull())\n            expect(3)\n            assertEquals(\"one\", sub.receive()) // suspends\n            expect(6)\n            assertEquals(\"two\", sub.receive()) // suspends\n            expect(12)\n            sub.cancel()\n            expect(13)\n        }\n\n        expect(4)\n        broadcast.send(\"one\") // does not suspend\n        assertEquals(\"one\", broadcast.value)\n        assertEquals(\"one\", broadcast.valueOrNull)\n        expect(5)\n        yield() // to receiver\n        expect(7)\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(8)\n            val sub = broadcast.openSubscription()\n            assertEquals(\"one\", sub.receive()) // does not suspend\n            expect(9)\n            assertEquals(\"two\", sub.receive()) // suspends\n            expect(14)\n            assertEquals(\"three\", sub.receive()) // suspends\n            expect(17)\n            assertNull(sub.receiveCatching().getOrNull()) // suspends until closed\n            expect(20)\n            sub.cancel()\n            expect(21)\n        }\n\n        expect(10)\n        broadcast.send(\"two\") // does not suspend\n        assertEquals(\"two\", broadcast.value)\n        assertEquals(\"two\", broadcast.valueOrNull)\n        expect(11)\n        yield() // to both receivers\n        expect(15)\n        broadcast.send(\"three\") // does not suspend\n        assertEquals(\"three\", broadcast.value)\n        assertEquals(\"three\", broadcast.valueOrNull)\n        expect(16)\n        yield() // to second receiver\n        expect(18)\n        broadcast.close()\n        assertIs<IllegalStateException>(exceptionFrom { broadcast.value })\n        assertNull(broadcast.valueOrNull)\n        expect(19)\n        yield() // to second receiver\n        assertIs<ClosedSendChannelException>(exceptionFrom { broadcast.send(\"four\") })\n        finish(22)\n    }\n\n    @Test\n    fun testInitialValueAndReceiveClosed() = runTest {\n        expect(1)\n        val broadcast = ConflatedBroadcastChannel(1)\n        assertEquals(1, broadcast.value)\n        assertEquals(1, broadcast.valueOrNull)\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            val sub = broadcast.openSubscription()\n            assertEquals(1, sub.receive())\n            expect(3)\n            assertIs<ClosedReceiveChannelException>(exceptionFrom { sub.receive() }) // suspends\n            expect(6)\n        }\n        expect(4)\n        broadcast.close()\n        expect(5)\n        yield() // to child\n        finish(7)\n    }\n\n    private inline fun exceptionFrom(block: () -> Unit): Throwable? {\n        return try {\n            block()\n            null\n        } catch (e: Throwable) {\n            e\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ConflatedChannelTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nopen class ConflatedChannelTest : TestBase() {\n    protected open fun <T> createConflatedChannel() =\n        Channel<T>(Channel.CONFLATED)\n    \n    @Test\n    fun testBasicConflationOfferTryReceive() {\n        val q = createConflatedChannel<Int>()\n        assertNull(q.tryReceive().getOrNull())\n        assertTrue(q.trySend(1).isSuccess)\n        assertTrue(q.trySend(2).isSuccess)\n        assertTrue(q.trySend(3).isSuccess)\n        assertEquals(3, q.tryReceive().getOrNull())\n        assertNull(q.tryReceive().getOrNull())\n    }\n\n    @Test\n    fun testConflatedSend() = runTest {\n        val q = createConflatedChannel<Int>()\n        q.send(1)\n        q.send(2) // shall conflated previously sent\n        assertEquals(2, q.receiveCatching().getOrNull())\n    }\n\n    @Test\n    fun testConflatedClose() = runTest {\n        val q = createConflatedChannel<Int>()\n        q.send(1)\n        q.close() // shall become closed but do not conflate last sent item yet\n        assertTrue(q.isClosedForSend)\n        assertFalse(q.isClosedForReceive)\n        assertEquals(1, q.receive())\n        // not it is closed for receive, too\n        assertTrue(q.isClosedForSend)\n        assertTrue(q.isClosedForReceive)\n        assertNull(q.receiveCatching().getOrNull())\n    }\n\n    @Test\n    fun testConflationSendReceive() = runTest {\n        val q = createConflatedChannel<Int>()\n        expect(1)\n        launch { // receiver coroutine\n            expect(4)\n            assertEquals(2, q.receive())\n            expect(5)\n            assertEquals(3, q.receive()) // this receive suspends\n            expect(8)\n            assertEquals(6, q.receive()) // last conflated value\n            expect(9)\n        }\n        expect(2)\n        q.send(1)\n        q.send(2) // shall conflate\n        expect(3)\n        yield() // to receiver\n        expect(6)\n        q.send(3) // send to the waiting receiver\n        q.send(4) // buffer\n        q.send(5) // conflate\n        q.send(6) // conflate again\n        expect(7)\n        yield() // to receiver\n        finish(10)\n    }\n\n    @Test\n    fun testConsumeAll() = runTest {\n        val q = createConflatedChannel<Int>()\n        expect(1)\n        for (i in 1..10) {\n            q.send(i) // stores as last\n        }\n        q.cancel()\n        check(q.isClosedForSend)\n        check(q.isClosedForReceive)\n        assertFailsWith<CancellationException> { q.receiveCatching().getOrThrow() }\n        finish(2)\n    }\n\n    @Test\n    fun testCancelWithCause() = runTest({ it is TestCancellationException }) {\n        val channel = createConflatedChannel<Int>()\n        channel.cancel(TestCancellationException())\n        channel.receive()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ConsumeTest.kt",
        "content": "@file:OptIn(DelicateCoroutinesApi::class)\npackage kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass ConsumeTest: TestBase() {\n\n    /** Check that [ReceiveChannel.consume] does not suffer from KT-58685 */\n    @Test\n    fun testConsumeJsMiscompilation() = runTest {\n        val channel = Channel<Int>()\n        assertFailsWith<IndexOutOfBoundsException> {\n            try {\n                channel.consume { null } ?: throw IndexOutOfBoundsException() // should throw\u2026\n            } catch (e: Exception) {\n                throw e // \u2026but instead fails here\n            }\n        }\n    }\n\n    /** Checks that [ReceiveChannel.consume] closes the channel when the block executes successfully. */\n    @Test\n    fun testConsumeClosesOnSuccess() = runTest {\n        val channel = Channel<Int>()\n        channel.consume { }\n        assertTrue(channel.isClosedForReceive)\n    }\n\n    /** Checks that [ReceiveChannel.consume] closes the channel when the block executes successfully. */\n    @Test\n    fun testConsumeClosesOnFailure() = runTest {\n        val channel = Channel<Int>()\n        try {\n            channel.consume { throw TestException() }\n        } catch (e: TestException) {\n            // Expected\n        }\n        assertTrue(channel.isClosedForReceive)\n    }\n\n    /** Checks that [ReceiveChannel.consume] closes the channel when the block does an early return. */\n    @Test\n    fun testConsumeClosesOnEarlyReturn() = runTest {\n        val channel = Channel<Int>()\n        fun f() {\n            try {\n                channel.consume { return }\n            } catch (e: TestException) {\n                // Expected\n            }\n        }\n        f()\n        assertTrue(channel.isClosedForReceive)\n    }\n\n    /** Checks that [ReceiveChannel.consume] closes the channel when the block executes successfully. */\n    @Test\n    fun testConsumeEachClosesOnSuccess() = runTest {\n        val channel = Channel<Int>(Channel.UNLIMITED)\n        launch { channel.close() }\n        channel.consumeEach { fail(\"unreached\") }\n        assertTrue(channel.isClosedForReceive)\n    }\n\n    /** Checks that [ReceiveChannel.consume] closes the channel when the block executes successfully. */\n    @Test\n    fun testConsumeEachClosesOnFailure() = runTest {\n        val channel = Channel<Unit>(Channel.UNLIMITED)\n        channel.send(Unit)\n        try {\n            channel.consumeEach { throw TestException() }\n        } catch (e: TestException) {\n            // Expected\n        }\n        assertTrue(channel.isClosedForReceive)\n    }\n\n    /** Checks that [ReceiveChannel.consume] closes the channel when the block does an early return. */\n    @Test\n    fun testConsumeEachClosesOnEarlyReturn() = runTest {\n        val channel = Channel<Unit>(Channel.UNLIMITED)\n        channel.send(Unit)\n        suspend fun f() {\n            channel.consumeEach {\n                return@f\n            }\n        }\n        f()\n        assertTrue(channel.isClosedForReceive)\n    }\n\n    /** Check that [BroadcastChannel.consume] does not suffer from KT-58685 */\n    @Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\n    @Test\n    fun testBroadcastChannelConsumeJsMiscompilation() = runTest {\n        val channel = BroadcastChannel<Int>(1)\n        assertFailsWith<IndexOutOfBoundsException> {\n            try {\n                channel.consume { null } ?: throw IndexOutOfBoundsException() // should throw\u2026\n            } catch (e: Exception) {\n                throw e // \u2026but instead fails here\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ProduceConsumeTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ProduceConsumeTest : TestBase() {\n\n    @Test\n    fun testRendezvous() = runTest {\n        testProducer(1)\n    }\n\n    @Test\n    fun testSmallBuffer() = runTest {\n        testProducer(1)\n    }\n\n    @Test\n    fun testMediumBuffer() = runTest {\n        testProducer(10)\n    }\n\n    @Test\n    fun testLargeMediumBuffer() = runTest {\n        testProducer(1000)\n    }\n\n    @Test\n    fun testUnlimited() = runTest {\n        testProducer(Channel.UNLIMITED)\n    }\n\n    private suspend fun testProducer(producerCapacity: Int) {\n        testProducer(1, producerCapacity)\n        testProducer(10, producerCapacity)\n        testProducer(100, producerCapacity)\n    }\n\n    private suspend fun testProducer(messages: Int, producerCapacity: Int) {\n        var sentAll = false\n        val producer = GlobalScope.produce(coroutineContext, capacity = producerCapacity) {\n            for (i in 1..messages) {\n                send(i)\n            }\n            sentAll = true\n        }\n        var consumed = 0\n        for (x in producer) {\n            consumed++\n        }\n        assertTrue(sentAll)\n        assertEquals(messages, consumed)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/ProduceTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ProduceTest : TestBase() {\n    @Test\n    fun testBasic() = runTest {\n        val c = produce {\n            expect(2)\n            send(1)\n            expect(3)\n            send(2)\n            expect(6)\n        }\n        expect(1)\n        check(c.receive() == 1)\n        expect(4)\n        check(c.receive() == 2)\n        expect(5)\n        assertNull(c.receiveCatching().getOrNull())\n        finish(7)\n    }\n\n    @Test\n    fun testCancelWithoutCause() = runTest {\n        val c = produce(NonCancellable) {\n            expect(2)\n            send(1)\n            expect(3)\n            try {\n                send(2) // will get cancelled\n                expectUnreached()\n            } catch (e: Throwable) {\n                expect(7)\n                check(e is CancellationException)\n                throw e\n            }\n            expectUnreached()\n        }\n        expect(1)\n        check(c.receive() == 1)\n        expect(4)\n        c.cancel()\n        expect(5)\n        assertFailsWith<CancellationException> { c.receiveCatching().getOrThrow() }\n        expect(6)\n        yield() // to produce\n        finish(8)\n    }\n\n    @Test\n    fun testCancelWithCause() = runTest {\n        val c = produce(NonCancellable) {\n            expect(2)\n            send(1)\n            expect(3)\n            try {\n                send(2) // will get cancelled\n                expectUnreached()\n            } catch (e: Throwable) {\n                expect(6)\n                check(e is TestCancellationException)\n                throw e\n            }\n            expectUnreached()\n        }\n        expect(1)\n        check(c.receive() == 1)\n        expect(4)\n        c.cancel(TestCancellationException())\n        try {\n            c.receive()\n            expectUnreached()\n        } catch (e: TestCancellationException) {\n            expect(5)\n        }\n        yield() // to produce\n        finish(7)\n    }\n\n    @Test\n    fun testCancelOnCompletionUnconfined() = runTest {\n        cancelOnCompletion(Dispatchers.Unconfined)\n    }\n\n    @Test\n    fun testCancelOnCompletion() = runTest {\n        cancelOnCompletion(coroutineContext)\n    }\n\n    @Test\n    fun testCancelWhenTheChannelIsClosed() = runTest {\n        val channel = produce<Int> {\n            send(1)\n            close()\n            expect(2)\n            launch {\n                expect(3)\n                hang { expect(5) }\n            }\n        }\n\n        expect(1)\n        channel.receive()\n        yield()\n        expect(4)\n        channel.cancel()\n        (channel as Job).join()\n        finish(6)\n    }\n\n    @Test\n    fun testAwaitConsumerCancellation() = runTest {\n        val parent = Job()\n        val channel = produce<Int>(parent) {\n            expect(2)\n            awaitClose { expect(4) }\n        }\n        expect(1)\n        yield()\n        expect(3)\n        channel.cancel()\n        parent.complete()\n        parent.join()\n        finish(5)\n    }\n\n    @Test\n    fun testAwaitProducerCancellation() = runTest {\n        val parent = Job()\n        produce<Int>(parent) {\n            expect(2)\n            launch {\n                expect(3)\n                this@produce.cancel()\n            }\n            awaitClose { expect(4) }\n        }\n        expect(1)\n        parent.complete()\n        parent.join()\n        finish(5)\n    }\n\n    @Test\n    fun testAwaitParentCancellation() = runTest {\n        val parent = Job()\n        produce<Int>(parent) {\n            expect(2)\n            awaitClose { expect(4) }\n        }\n        expect(1)\n        yield()\n        expect(3)\n        parent.cancelAndJoin()\n        finish(5)\n    }\n\n    @Test\n    fun testAwaitIllegalState() = runTest {\n        val channel = produce<Int> { }\n        assertFailsWith<IllegalStateException> { (channel as ProducerScope<*>).awaitClose() }\n        callbackFlow<Unit> {\n            expect(1)\n            launch {\n                expect(2)\n                assertFailsWith<IllegalStateException> {\n                    awaitClose { expectUnreached() }\n                    expectUnreached()\n                }\n            }\n            close()\n        }.collect()\n        finish(3)\n    }\n\n    private suspend fun cancelOnCompletion(coroutineContext: CoroutineContext) = CoroutineScope(coroutineContext).apply {\n        val source = Channel<Int>()\n        expect(1)\n        val produced = produce<Int>(coroutineContext, onCompletion = { source.cancelConsumed(it) }) {\n            expect(2)\n            source.receive()\n        }\n\n        yield()\n        expect(3)\n        produced.cancel()\n        try {\n            source.receive()\n        } catch (e: CancellationException) {\n            finish(4)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/RendezvousChannelTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass RendezvousChannelTest : TestBase() {\n    @Test\n    fun testSimple() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        check(q.isEmpty)\n        expect(1)\n        val sender = launch {\n            expect(4)\n            q.send(1) // suspend -- the first to come to rendezvous\n            expect(7)\n            q.send(2) // does not suspend -- receiver is there\n            expect(8)\n        }\n        expect(2)\n        val receiver = launch {\n            expect(5)\n            check(q.receive() == 1) // does not suspend -- sender was there\n            expect(6)\n            check(q.receive() == 2) // suspends\n            expect(9)\n        }\n        expect(3)\n        sender.join()\n        receiver.join()\n        check(q.isEmpty)\n        finish(10)\n    }\n\n    @Test\n    fun testClosedReceiveCatching() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        check(q.isEmpty && !q.isClosedForSend && !q.isClosedForReceive)\n        expect(1)\n        launch {\n            expect(3)\n            assertEquals(42, q.receiveCatching().getOrNull())\n            expect(4)\n            assertNull(q.receiveCatching().getOrNull())\n            expect(6)\n        }\n        expect(2)\n        q.send(42)\n        expect(5)\n        q.close()\n        check(!q.isEmpty && q.isClosedForSend && q.isClosedForReceive)\n        yield()\n        check(!q.isEmpty && q.isClosedForSend && q.isClosedForReceive)\n        finish(7)\n    }\n\n    @Test\n    fun testClosedExceptions() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(4)\n            try { q.receive() }\n            catch (e: ClosedReceiveChannelException) {\n                expect(5)\n            }\n        }\n        expect(2)\n        q.close()\n        expect(3)\n        yield()\n        expect(6)\n        try { q.send(42) }\n        catch (e: ClosedSendChannelException) {\n            finish(7)\n        }\n    }\n\n    @Test\n    fun testTrySendTryReceive() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        assertFalse(q.trySend(1).isSuccess)\n        expect(1)\n        launch {\n            expect(3)\n            assertNull(q.tryReceive().getOrNull())\n            expect(4)\n            assertEquals(2, q.receive())\n            expect(7)\n            assertNull(q.tryReceive().getOrNull())\n            yield()\n            expect(9)\n            assertEquals(3, q.tryReceive().getOrNull())\n            expect(10)\n        }\n        expect(2)\n        yield()\n        expect(5)\n        assertTrue(q.trySend(2).isSuccess)\n        expect(6)\n        yield()\n        expect(8)\n        q.send(3)\n        finish(11)\n    }\n\n    @Test\n    fun testIteratorClosed() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(3)\n            q.close()\n            expect(4)\n        }\n        expect(2)\n        for (x in q) {\n            expectUnreached()\n        }\n        finish(5)\n    }\n\n    @Test\n    fun testIteratorOne() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(3)\n            q.send(1)\n            expect(4)\n            q.close()\n            expect(5)\n        }\n        expect(2)\n        for (x in q) {\n            expect(6)\n            assertEquals(1, x)\n        }\n        finish(7)\n    }\n\n    @Test\n    fun testIteratorOneWithYield() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(3)\n            q.send(1) // will suspend\n            expect(6)\n            q.close()\n            expect(7)\n        }\n        expect(2)\n        yield() // yield to sender coroutine right before starting for loop\n        expect(4)\n        for (x in q) {\n            expect(5)\n            assertEquals(1, x)\n        }\n        finish(8)\n    }\n\n    @Test\n    fun testIteratorTwo() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(3)\n            q.send(1)\n            expect(4)\n            q.send(2)\n            expect(7)\n            q.close()\n            expect(8)\n        }\n        expect(2)\n        for (x in q) {\n            when (x) {\n                1 -> expect(5)\n                2 -> expect(6)\n                else -> expectUnreached()\n            }\n        }\n        finish(9)\n    }\n\n    @Test\n    fun testIteratorTwoWithYield() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(3)\n            q.send(1) // will suspend\n            expect(6)\n            q.send(2)\n            expect(7)\n            q.close()\n            expect(8)\n        }\n        expect(2)\n        yield() // yield to sender coroutine right before starting for loop\n        expect(4)\n        for (x in q) {\n            when (x) {\n                1 -> expect(5)\n                2 -> expect(9)\n                else -> expectUnreached()\n            }\n        }\n        finish(10)\n    }\n\n    @Test\n    fun testSuspendSendOnClosedChannel() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(4)\n            q.send(42) // suspend\n            expect(11)\n        }\n        expect(2)\n        launch {\n            expect(5)\n            q.close()\n            expect(6)\n        }\n        expect(3)\n        yield() // to sender\n        expect(7)\n        yield() // try to resume sender (it will not resume despite the close!)\n        expect(8)\n        assertEquals(42, q.receiveCatching().getOrNull())\n        expect(9)\n        assertNull(q.receiveCatching().getOrNull())\n        expect(10)\n        yield() // to sender, it was resumed!\n        finish(12)\n    }\n\n    @Test\n    fun testProduceBadClass() = runTest {\n        val bad = BadClass()\n        val c = produce {\n            expect(1)\n            send(bad)\n        }\n        assertSame(c.receive(), bad)\n        finish(2)\n    }\n\n    @Test\n    fun testConsumeAll() = runTest {\n        val q = Channel<Int>(Channel.RENDEZVOUS)\n        for (i in 1..10) {\n            launch(start = CoroutineStart.UNDISPATCHED) {\n                expect(i)\n                q.send(i) // suspends\n                expectUnreached() // will get cancelled by cancel\n            }\n        }\n        expect(11)\n        q.cancel()\n        check(q.isClosedForSend)\n        check(q.isClosedForReceive)\n        assertFailsWith<CancellationException> { q.receiveCatching().getOrThrow() }\n        finish(12)\n    }\n\n    @Test\n    fun testCancelWithCause() = runTest({ it is TestCancellationException }) {\n        val channel = Channel<Int>(Channel.RENDEZVOUS)\n        channel.cancel(TestCancellationException())\n        channel.receiveCatching().getOrThrow()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/SendReceiveStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass SendReceiveStressTest : TestBase() {\n\n    // Emulate parametrized by hand :(\n\n    @Test\n    fun testBufferedChannel() = runTest {\n        testStress(Channel(2))\n    }\n\n    @Test\n    fun testUnlimitedChannel() = runTest {\n        testStress(Channel(Channel.UNLIMITED))\n    }\n\n    @Test\n    fun testRendezvousChannel() = runTest {\n        testStress(Channel(Channel.RENDEZVOUS))\n    }\n\n    private suspend fun testStress(channel: Channel<Int>) = coroutineScope {\n        val n = 100 // Do not increase, otherwise node.js will fail with timeout :(\n        val sender = launch {\n            for (i in 1..n) {\n                channel.send(i)\n            }\n            expect(2)\n        }\n        val receiver = launch {\n            for (i in 1..n) {\n                val next = channel.receive()\n                check(next == i)\n            }\n            expect(3)\n        }\n        expect(1)\n        sender.join()\n        receiver.join()\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/TestBroadcastChannelKind.kt",
        "content": "package kotlinx.coroutines.channels\n\nenum class TestBroadcastChannelKind {\n    ARRAY_1 {\n        override fun <T> create(): BroadcastChannel<T> = BroadcastChannel(1)\n        override fun toString(): String = \"BufferedBroadcastChannel(1)\"\n    },\n    ARRAY_10 {\n        override fun <T> create(): BroadcastChannel<T> = BroadcastChannel(10)\n        override fun toString(): String = \"BufferedBroadcastChannel(10)\"\n    },\n    CONFLATED {\n        override fun <T> create(): BroadcastChannel<T> = ConflatedBroadcastChannel()\n        override fun toString(): String = \"ConflatedBroadcastChannel\"\n        override val isConflated: Boolean get() = true\n    }\n    ;\n\n    abstract fun <T> create(): BroadcastChannel<T>\n    open val isConflated: Boolean get() = false\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/TestChannelKind.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\n\nenum class TestChannelKind(\n    val capacity: Int,\n    private val description: String,\n    val viaBroadcast: Boolean = false\n) {\n    RENDEZVOUS(0, \"RendezvousChannel\"),\n    BUFFERED_1(1, \"BufferedChannel(1)\"),\n    BUFFERED_2(2, \"BufferedChannel(2)\"),\n    BUFFERED_10(10, \"BufferedChannel(10)\"),\n    UNLIMITED(Channel.UNLIMITED, \"UnlimitedChannel\"),\n    CONFLATED(Channel.CONFLATED, \"ConflatedChannel\"),\n    BUFFERED_1_BROADCAST(1, \"BufferedBroadcastChannel(1)\", viaBroadcast = true),\n    BUFFERED_10_BROADCAST(10, \"BufferedBroadcastChannel(10)\", viaBroadcast = true),\n    CONFLATED_BROADCAST(Channel.CONFLATED, \"ConflatedBroadcastChannel\", viaBroadcast = true)\n    ;\n\n    fun <T> create(onUndeliveredElement: ((T) -> Unit)? = null): Channel<T> = when {\n        viaBroadcast && onUndeliveredElement != null -> error(\"Broadcast channels to do not support onUndeliveredElement\")\n        viaBroadcast -> ChannelViaBroadcast(BroadcastChannel(capacity))\n        else -> Channel(capacity, onUndeliveredElement = onUndeliveredElement)\n    }\n\n    val isConflated get() = capacity == Channel.CONFLATED\n    override fun toString(): String = description\n}\n\ninternal class ChannelViaBroadcast<E>(\n    private val broadcast: BroadcastChannel<E>\n): Channel<E>, SendChannel<E> by broadcast {\n    val sub = broadcast.openSubscription()\n\n    override val isClosedForReceive: Boolean get() = sub.isClosedForReceive\n    override val isEmpty: Boolean get() = sub.isEmpty\n\n    override suspend fun receive(): E = sub.receive()\n    override suspend fun receiveCatching(): ChannelResult<E> = sub.receiveCatching()\n    override fun iterator(): ChannelIterator<E> = sub.iterator()\n    override fun tryReceive(): ChannelResult<E> = sub.tryReceive()\n\n    override fun cancel(cause: CancellationException?) = broadcast.cancel(cause)\n\n    // implementing hidden method anyway, so can cast to an internal class\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.2.0, binary compatibility with versions <= 1.1.x\")\n    override fun cancel(cause: Throwable?): Boolean = error(\"unsupported\")\n\n    override val onReceive: SelectClause1<E>\n        get() = sub.onReceive\n    override val onReceiveCatching: SelectClause1<ChannelResult<E>>\n        get() = sub.onReceiveCatching\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/channels/UnlimitedChannelTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass UnlimitedChannelTest : TestBase() {\n    @Test\n    fun testBasic() = runTest {\n        val c = Channel<Int>(Channel.UNLIMITED)\n        c.send(1)\n        assertTrue(c.trySend(2).isSuccess)\n        c.send(3)\n        check(c.close())\n        check(!c.close())\n        assertEquals(1, c.receive())\n        assertEquals(2, c.tryReceive().getOrNull())\n        assertEquals(3, c.receiveCatching().getOrNull())\n        assertNull(c.receiveCatching().getOrNull())\n    }\n\n    @Test\n    fun testConsumeAll() = runTest {\n        val q = Channel<Int>(Channel.UNLIMITED)\n        for (i in 1..10) {\n            q.send(i) // buffers\n        }\n        q.cancel()\n        check(q.isClosedForSend)\n        check(q.isClosedForReceive)\n        assertFailsWith<CancellationException> { q.receive() }\n    }\n\n    @Test\n    fun testCancelWithCause() = runTest({ it is TestCancellationException }) {\n        val channel = Channel<Int>(Channel.UNLIMITED)\n        channel.cancel(TestCancellationException())\n        channel.receive()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/BuildersTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass BuildersTest : TestBase() {\n\n    @Test\n    fun testSuspendLambdaAsFlow() = runTest {\n        val lambda = suspend { 42 }\n        assertEquals(42, lambda.asFlow().single())\n    }\n\n    @Test\n    fun testRangeAsFlow() = runTest {\n        assertEquals((0..9).toList(), (0..9).asFlow().toList())\n        assertEquals(emptyList(), (0..-1).asFlow().toList())\n\n        assertEquals((0L..9L).toList(), (0L..9L).asFlow().toList())\n        assertEquals(emptyList(), (0L..-1L).asFlow().toList())\n    }\n\n    @Test\n    fun testArrayAsFlow() = runTest {\n        assertEquals((0..9).toList(), IntArray(10) { it }.asFlow().toList())\n        assertEquals(emptyList(), intArrayOf().asFlow().toList())\n\n        assertEquals((0L..9L).toList(), LongArray(10) { it.toLong() }.asFlow().toList())\n        assertEquals(emptyList(), longArrayOf().asFlow().toList())\n    }\n\n    @Test\n    fun testSequence() = runTest {\n        val expected = (0..9).toList()\n        assertEquals(expected, expected.iterator().asFlow().toList())\n        assertEquals(expected, expected.asIterable().asFlow().toList())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/FlowInvariantsTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.testing.flow.*\nimport kotlin.coroutines.*\nimport kotlin.reflect.*\nimport kotlin.test.*\n\nclass FlowInvariantsTest : TestBase() {\n\n    private fun <T> runParametrizedTest(\n        expectedException: KClass<out Throwable>? = null,\n        testBody: suspend (flowFactory: (suspend FlowCollector<T>.() -> Unit) -> Flow<T>) -> Unit\n    ) = runTest {\n        val r1 = runCatching { testBody { flow(it) } }.exceptionOrNull()\n        check(r1, expectedException)\n        reset()\n\n        val r2 = runCatching { testBody { abstractFlow(it) } }.exceptionOrNull()\n        check(r2, expectedException)\n    }\n\n    private fun <T> abstractFlow(block: suspend FlowCollector<T>.() -> Unit): Flow<T> = object : AbstractFlow<T>() {\n        override suspend fun collectSafely(collector: FlowCollector<T>) {\n            collector.block()\n        }\n    }\n\n    private fun check(exception: Throwable?, expectedException: KClass<out Throwable>?) {\n        if (expectedException != null && exception == null) fail(\"Expected $expectedException, but test completed successfully\")\n        if (expectedException != null && exception != null) assertTrue(expectedException.isInstance(exception))\n        if (expectedException == null && exception != null) throw exception\n    }\n\n    @Test\n    fun testWithContextContract() = runParametrizedTest<Int>(IllegalStateException::class) { flow ->\n        flow {\n            withContext(NonCancellable) {\n                emit(1)\n            }\n        }.collect {\n            expectUnreached()\n        }\n    }\n\n    @Test\n    fun testWithDispatcherContractViolated() = runParametrizedTest<Int>(IllegalStateException::class) { flow ->\n        flow {\n            withContext(NamedDispatchers(\"foo\")) {\n                emit(1)\n            }\n        }.collect {\n            expectUnreached()\n        }\n    }\n\n    @Test\n    fun testWithNameContractViolated() = runParametrizedTest<Int>(IllegalStateException::class) { flow ->\n        flow {\n            withContext(CoroutineName(\"foo\")) {\n                emit(1)\n            }\n        }.collect {\n            expectUnreached()\n        }\n    }\n\n    @Test\n    fun testWithContextDoesNotChangeExecution() = runTest {\n        val flow = flow {\n            emit(NamedDispatchers.name())\n        }.flowOn(NamedDispatchers(\"original\"))\n\n        var result = \"unknown\"\n        withContext(NamedDispatchers(\"misc\")) {\n            flow\n                .flowOn(NamedDispatchers(\"upstream\"))\n                .launchIn(this + NamedDispatchers(\"consumer\")) {\n                    onEach {\n                        result = it\n                    }\n                }.join()\n        }\n        assertEquals(\"original\", result)\n    }\n\n    @Test\n    fun testScopedJob() = runParametrizedTest<Int>(IllegalStateException::class) { flow ->\n        flow { emit(1) }.buffer(EmptyCoroutineContext, flow).collect {\n            expect(1)\n        }\n        finish(2)\n    }\n\n    @Test\n    fun testScopedJobWithViolation() = runParametrizedTest<Int>(IllegalStateException::class) { flow ->\n        flow { emit(1) }.buffer(Dispatchers.Unconfined, flow).collect {\n            expect(1)\n        }\n        finish(2)\n    }\n\n    @Test\n    fun testMergeViolation() = runParametrizedTest<Int> { flow ->\n        fun Flow<Int>.merge(other: Flow<Int>): Flow<Int> = flow {\n            coroutineScope {\n                launch {\n                    collect { value -> emit(value) }\n                }\n                other.collect { value -> emit(value) }\n            }\n        }\n\n        fun Flow<Int>.trickyMerge(other: Flow<Int>): Flow<Int> = flow {\n            coroutineScope {\n                launch {\n                    collect { value ->\n                        coroutineScope { emit(value) }\n                    }\n                }\n                other.collect { value -> emit(value) }\n            }\n        }\n\n        val flowInstance = flowOf(1)\n        assertFailsWith<IllegalStateException> { flowInstance.merge(flowInstance).toList() }\n        assertFailsWith<IllegalStateException> { flowInstance.trickyMerge(flowInstance).toList() }\n    }\n\n    @Test\n    fun testNoMergeViolation() = runTest {\n        fun Flow<Int>.merge(other: Flow<Int>): Flow<Int> = channelFlow {\n            launch {\n                collect { value -> send(value) }\n            }\n            other.collect { value -> send(value) }\n        }\n\n        fun Flow<Int>.trickyMerge(other: Flow<Int>): Flow<Int> = channelFlow {\n            coroutineScope {\n                launch {\n                    collect { value ->\n                        coroutineScope { send(value) }\n                    }\n                }\n                other.collect { value -> send(value) }\n            }\n        }\n\n        val flow = flowOf(1)\n        assertEquals(listOf(1, 1), flow.merge(flow).toList())\n        assertEquals(listOf(1, 1), flow.trickyMerge(flow).toList())\n    }\n\n    @Test\n    fun testScopedCoroutineNoViolation() = runParametrizedTest<Int> { flow ->\n        fun Flow<Int>.buffer(): Flow<Int> = flow {\n            coroutineScope {\n                val channel = produce {\n                    collect {\n                        send(it)\n                    }\n                }\n                channel.consumeEach {\n                    emit(it)\n                }\n            }\n        }\n        assertEquals(listOf(1, 1), flowOf(1, 1).buffer().toList())\n    }\n\n    private fun Flow<Int>.buffer(coroutineContext: CoroutineContext, flow: (suspend FlowCollector<Int>.() -> Unit) -> Flow<Int>): Flow<Int> = flow {\n        coroutineScope {\n            val channel = Channel<Int>()\n            launch {\n                collect { value ->\n                    channel.send(value)\n                }\n                channel.close()\n            }\n\n            launch(coroutineContext) {\n                for (i in channel) {\n                    emit(i)\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testEmptyCoroutineContextMap() = runTest {\n        emptyContextTest {\n            map {\n                expect(it)\n                it + 1\n            }\n        }\n    }\n\n    @Test\n    fun testEmptyCoroutineContextTransform() = runTest {\n        emptyContextTest {\n            transform {\n                expect(it)\n                emit(it + 1)\n            }\n        }\n    }\n\n    @Test\n    fun testEmptyCoroutineContextTransformWhile() = runTest {\n        emptyContextTest {\n            transformWhile {\n                expect(it)\n                emit(it + 1)\n                true\n            }\n        }\n    }\n\n    @Test\n    fun testEmptyCoroutineContextViolationTransform() = runTest {\n        try {\n            emptyContextTest {\n                transform {\n                    expect(it)\n                    withContext(Dispatchers.Unconfined) {\n                        emit(it + 1)\n                    }\n                }\n            }\n            expectUnreached()\n        } catch (e: IllegalStateException) {\n            assertTrue(e.message!!.contains(\"Flow invariant is violated\"), \"But had: ${e.message}\")\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testEmptyCoroutineContextViolationTransformWhile() = runTest {\n        try {\n            emptyContextTest {\n                transformWhile {\n                    expect(it)\n                    withContext(Dispatchers.Unconfined) {\n                        emit(it + 1)\n                    }\n                    true\n                }\n            }\n            expectUnreached()\n        } catch (e: IllegalStateException) {\n            assertTrue(e.message!!.contains(\"Flow invariant is violated\"))\n            finish(2)\n        }\n    }\n\n    private suspend fun emptyContextTest(block: Flow<Int>.() -> Flow<Int>) {\n        suspend fun collector(): Int {\n            var result: Int = -1\n            channelFlow {\n                send(1)\n            }.block()\n                .collect {\n                    expect(it)\n                    result = it\n                }\n            return result\n        }\n\n        val result = withEmptyContext { collector() }\n        assertEquals(2, result)\n        finish(3)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/IdFlowTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\n// See https://github.com/Kotlin/kotlinx.coroutines/issues/1128\nclass IdFlowTest : TestBase() {\n    @Test\n    fun testCancelInCollect() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        expect(1)\n        flow {\n            expect(2)\n            emit(1)\n            expect(3)\n            hang { finish(6) }\n        }.idScoped().collect { value ->\n            expect(4)\n            assertEquals(1, value)\n            kotlin.coroutines.coroutineContext.cancel()\n            expect(5)\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testCancelInFlow() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        expect(1)\n        flow {\n            expect(2)\n            emit(1)\n            kotlin.coroutines.coroutineContext.cancel()\n            expect(3)\n        }.idScoped().collect { value ->\n            finish(4)\n            assertEquals(1, value)\n        }\n        expectUnreached()\n    }\n}\n\n/**\n * This flow should be \"identity\" function with respect to cancellation.\n */\nprivate fun <T> Flow<T>.idScoped(): Flow<T> = flow {\n    coroutineScope {\n        val channel = produce {\n            collect { send(it) }\n        }\n        channel.consumeEach {\n            emit(it)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/NamedDispatchers.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\n\n/**\n * Test dispatchers that emulate multiplatform context tracking.\n */\npublic object NamedDispatchers {\n\n    private val stack = ArrayStack()\n\n    public fun name(): String = stack.peek() ?: error(\"No names on stack\")\n\n    public fun nameOr(defaultValue: String): String = stack.peek() ?: defaultValue\n\n    public operator fun invoke(name: String) = named(name)\n\n    private fun named(name: String): CoroutineDispatcher = object : CoroutineDispatcher() {\n        override fun dispatch(context: CoroutineContext, block: Runnable) {\n            stack.push(name)\n            try {\n                block.run()\n            } finally {\n                val last = stack.pop() ?: error(\"No names on stack\")\n                require(last == name) { \"Inconsistent stack: expected $name, but had $last\" }\n            }\n        }\n    }\n}\n\nprivate class ArrayStack {\n    private var elements = arrayOfNulls<String>(16)\n    private var head = 0\n\n    public fun push(value: String) {\n        if (elements.size == head - 1) ensureCapacity()\n        elements[head++] = value\n    }\n\n    public fun peek(): String? = elements.getOrNull(head - 1)\n\n    public fun pop(): String? {\n        if (head == 0) return null\n        return elements[--head]\n    }\n\n    private fun ensureCapacity() {\n        val currentSize = elements.size\n        val newCapacity = currentSize shl 1\n        val newElements = arrayOfNulls<String>(newCapacity)\n        elements.copyInto(\n            destination = newElements,\n            startIndex = head\n        )\n        elements.copyInto(\n            destination = newElements,\n            destinationOffset = elements.size - head,\n            endIndex = head\n        )\n        elements = newElements\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/SafeFlowTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass SafeFlowTest : TestBase() {\n\n    @Test\n    fun testEmissionsFromDifferentStateMachine() = runTest {\n        val result = flow<Int> {\n            emit1(1)\n            emit2(2)\n        }.onEach { yield() }.toList()\n        assertEquals(listOf(1, 2), result)\n        finish(3)\n    }\n\n    private suspend fun FlowCollector<Int>.emit1(expect: Int) {\n        emit(expect)\n        expect(expect)\n    }\n\n    private suspend fun FlowCollector<Int>.emit2(expect: Int) {\n        emit(expect)\n        expect(expect)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/VirtualTime.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\n\ninternal class VirtualTimeDispatcher(enclosingScope: CoroutineScope) : CoroutineDispatcher(), Delay {\n    private val originalDispatcher = enclosingScope.coroutineContext[ContinuationInterceptor] as CoroutineDispatcher\n    private val heap = ArrayList<TimedTask>() // TODO use MPP heap/ordered set implementation (commonize ThreadSafeHeap)\n\n    var currentTime = 0L\n        private set\n\n    init {\n        /*\n         * Launch \"event-loop-owning\" task on start of the virtual time event loop.\n         * It ensures the progress of the enclosing event-loop and polls the timed queue\n         * when the enclosing event loop is empty, emulating virtual time.\n         */\n        enclosingScope.launch {\n            while (true) {\n                val delayNanos = ThreadLocalEventLoop.currentOrNull()?.processNextEvent()\n                    ?: error(\"Event loop is missing, virtual time source works only as part of event loop\")\n                if (delayNanos <= 0) continue\n                if (delayNanos > 0 && delayNanos != Long.MAX_VALUE) error(\"Unexpected external delay: $delayNanos\")\n                val nextTask = heap.minByOrNull { it.deadline } ?: return@launch\n                heap.remove(nextTask)\n                currentTime = nextTask.deadline\n                nextTask.run()\n            }\n        }\n    }\n\n    private inner class TimedTask(\n        private val runnable: Runnable,\n        @JvmField val deadline: Long\n    ) : DisposableHandle, Runnable by runnable {\n\n        override fun dispose() {\n            heap.remove(this)\n        }\n    }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        originalDispatcher.dispatch(context, block)\n    }\n\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = originalDispatcher.isDispatchNeeded(context)\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        val task = TimedTask(block, deadline(timeMillis))\n        heap += task\n        return task\n    }\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val task = TimedTask(Runnable { with(continuation) { resumeUndispatched(Unit) } }, deadline(timeMillis))\n        heap += task\n        continuation.invokeOnCancellation { task.dispose() }\n    }\n\n    private fun deadline(timeMillis: Long) =\n        if (timeMillis == Long.MAX_VALUE) Long.MAX_VALUE else currentTime + timeMillis\n}\n\n/**\n * Runs a test ([TestBase.runTest]) with a virtual time source.\n * This runner has the following constraints:\n * 1) It works only in the event-loop environment and it is relying on it.\n *    None of the coroutines should be launched in any dispatcher different from a current\n * 2) Regular tasks always dominate delayed ones. It means that\n *    `launch { while(true) yield() }` will block the progress of the delayed tasks\n * 3) [TestBase.finish] should always be invoked.\n *    Given all the constraints into account, it is easy to mess up with a test and actually\n *    return from [withVirtualTime] before the test is executed completely.\n *    To decrease the probability of such error, additional `finish` constraint is added.\n */\npublic fun TestBase.withVirtualTime(block: suspend CoroutineScope.() -> Unit) = runTest {\n    withContext(Dispatchers.Unconfined) {\n        // Create a platform-independent event loop\n        val dispatcher = VirtualTimeDispatcher(this)\n        withContext(dispatcher) { block() }\n        checkFinishCall(allowNotUsingExpect = false)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/channels/ChannelBuildersFlowTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass ChannelBuildersFlowTest : TestBase() {\n    @Test\n    fun testChannelConsumeAsFlow() = runTest {\n        val channel = produce {\n           repeat(10) {\n               send(it + 1)\n           }\n        }\n        val flow = channel.consumeAsFlow()\n        assertEquals(55, flow.sum())\n        assertFailsWith<IllegalStateException> { flow.collect() }\n    }\n\n    @Test\n    fun testChannelReceiveAsFlow() = runTest {\n        val channel = produce {\n           repeat(10) {\n               send(it + 1)\n           }\n        }\n        val flow = channel.receiveAsFlow()\n        assertEquals(55, flow.sum())\n        assertEquals(emptyList(), flow.toList())\n    }\n\n    @Test\n    fun testConsumeAsFlowCancellation() = runTest {\n        val channel = produce(NonCancellable) { // otherwise failure will cancel scope as well\n            repeat(10) {\n                send(it + 1)\n            }\n            throw TestException()\n        }\n        val flow = channel.consumeAsFlow()\n        assertEquals(15, flow.take(5).sum())\n        // the channel should have been canceled, even though took only 5 elements\n        assertTrue(channel.isClosedForReceive)\n        assertFailsWith<IllegalStateException> { flow.collect() }\n    }\n\n    @Test\n    fun testReceiveAsFlowCancellation() = runTest {\n        val channel = produce(NonCancellable) { // otherwise failure will cancel scope as well\n            repeat(10) {\n                send(it + 1)\n            }\n            throw TestException()\n        }\n        val flow = channel.receiveAsFlow()\n        assertEquals(15, flow.take(5).sum()) // sum of first 5\n        assertEquals(40, flow.take(5).sum()) // sum the rest 5\n        assertFailsWith<TestException> { flow.sum() } // exception in the rest\n    }\n\n    @Test\n    fun testConsumeAsFlowException() = runTest {\n        val channel = produce(NonCancellable) { // otherwise failure will cancel scope as well\n            repeat(10) {\n                send(it + 1)\n            }\n            throw TestException()\n        }\n        val flow = channel.consumeAsFlow()\n        assertFailsWith<TestException> { flow.sum() }\n        assertFailsWith<IllegalStateException> { flow.collect() }\n    }\n\n    @Test\n    fun testReceiveAsFlowException() = runTest {\n        val channel = produce(NonCancellable) { // otherwise failure will cancel scope as well\n            repeat(10) {\n                send(it + 1)\n            }\n            throw TestException()\n        }\n        val flow = channel.receiveAsFlow()\n        assertFailsWith<TestException> { flow.sum() }\n        assertFailsWith<TestException> { flow.collect() } // repeated collection -- same exception\n    }\n\n    @Test\n    fun testConsumeAsFlowProduceFusing() = runTest {\n        val channel = produce { send(\"OK\") }\n        val flow = channel.consumeAsFlow()\n        assertSame(channel, flow.produceIn(this))\n        assertFailsWith<IllegalStateException> { flow.produceIn(this) }\n        channel.cancel()\n    }\n\n    @Test\n    fun testReceiveAsFlowProduceFusing() = runTest {\n        val channel = produce { send(\"OK\") }\n        val flow = channel.receiveAsFlow()\n        assertSame(channel, flow.produceIn(this))\n        assertSame(channel, flow.produceIn(this)) // can use produce multiple times\n        channel.cancel()\n    }\n\n    @Test\n    fun testConsumeAsFlowProduceBuffered() = runTest {\n        expect(1)\n        val channel = produce {\n            expect(3)\n            (1..10).forEach { send(it) }\n            expect(4) // produces everything because of buffering\n        }\n        val flow = channel.consumeAsFlow().buffer() // request buffering\n        expect(2) // producer is not running yet\n        val result = flow.produceIn(this)\n        // run the flow pipeline until it consumes everything into buffer\n        while (!channel.isClosedForReceive) yield()\n        expect(5) // produced had done running (buffered stuff)\n        assertNotSame(channel, result)\n        assertFailsWith<IllegalStateException> { flow.produceIn(this) }\n        // check that we received everything\n        assertEquals((1..10).toList(), result.toList())\n        finish(6)\n    }\n\n    @Test\n    fun testProduceInAtomicity() = runTest {\n        val flow = flowOf(1).onCompletion { expect(2) }\n        val scope = CoroutineScope(wrapperDispatcher())\n        flow.produceIn(scope)\n        expect(1)\n        scope.cancel()\n        scope.coroutineContext[Job]?.join()\n        finish(3)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/channels/ChannelFlowTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass ChannelFlowTest : TestBase() {\n    @Test\n    fun testRegular() = runTest {\n        val flow = channelFlow {\n            assertTrue(trySend(1).isSuccess)\n            assertTrue(trySend(2).isSuccess)\n            assertTrue(trySend(3).isSuccess)\n        }\n        assertEquals(listOf(1, 2, 3), flow.toList())\n    }\n\n    @Test\n    fun testBuffer() = runTest {\n        val flow = channelFlow {\n            assertTrue(trySend(1).isSuccess)\n            assertTrue(trySend(2).isSuccess)\n            assertFalse(trySend(3).isSuccess)\n        }.buffer(1)\n        assertEquals(listOf(1, 2), flow.toList())\n    }\n\n    @Test\n    fun testConflated() = runTest {\n        val flow = channelFlow {\n            assertTrue(trySend(1).isSuccess)\n            assertTrue(trySend(2).isSuccess)\n            assertTrue(trySend(3).isSuccess)\n            assertTrue(trySend(4).isSuccess)\n        }.buffer(Channel.CONFLATED)\n        assertEquals(listOf(1, 4), flow.toList()) // two elements in the middle got conflated\n    }\n\n    @Test\n    fun testFailureCancelsChannel() = runTest {\n        val flow = channelFlow {\n            trySend(1)\n            invokeOnClose {\n                expect(2)\n            }\n        }.onEach { throw TestException() }\n\n        expect(1)\n        assertFailsWith<TestException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testFailureInSourceCancelsConsumer() = runTest {\n        val flow = channelFlow<Int> {\n            expect(2)\n            throw TestException()\n        }.onEach { expectUnreached() }\n\n        expect(1)\n        assertFailsWith<TestException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testScopedCancellation() = runTest {\n        val flow = channelFlow<Int> {\n            expect(2)\n            launch(start = CoroutineStart.ATOMIC) {\n                hang { expect(3) }\n            }\n            throw TestException()\n        }.onEach { expectUnreached() }\n\n        expect(1)\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testMergeOneCoroutineWithCancellation() = runTest {\n        val flow = flowOf(1, 2, 3)\n        val f = flow.mergeOneCoroutine(flow).take(2)\n        assertEquals(listOf(1, 1), f.toList())\n    }\n\n    @Test\n    fun testMergeTwoCoroutinesWithCancellation() = runTest {\n        val flow = flowOf(1, 2, 3)\n        val f = flow.mergeTwoCoroutines(flow).take(2)\n        assertEquals(listOf(1, 1), f.toList())\n    }\n\n    private fun Flow<Int>.mergeTwoCoroutines(other: Flow<Int>): Flow<Int> = channelFlow {\n        launch {\n            collect { send(it); yield() }\n        }\n        launch {\n            other.collect { send(it) }\n        }\n    }\n\n    private fun Flow<Int>.mergeOneCoroutine(other: Flow<Int>): Flow<Int> = channelFlow {\n        launch {\n            collect { send(it); yield() }\n        }\n\n        other.collect { send(it); yield() }\n    }\n\n    @Test\n    @Ignore // #1374\n    fun testBufferWithTimeout() = runTest {\n        fun Flow<Int>.bufferWithTimeout(): Flow<Int> = channelFlow {\n            expect(2)\n            launch {\n                expect(3)\n                hang {\n                    expect(5)\n                }\n            }\n            launch {\n                expect(4)\n                collect {\n                    withTimeout(-1) {\n                        send(it)\n                    }\n                    expectUnreached()\n                }\n                expectUnreached()\n            }\n        }\n\n        val flow = flowOf(1, 2, 3).bufferWithTimeout()\n        expect(1)\n        assertFailsWith<TimeoutCancellationException>(flow)\n        finish(6)\n    }\n\n    @Test\n    fun testChildCancellation() = runTest {\n        channelFlow {\n            val job = launch {\n                expect(2)\n                hang { expect(4) }\n            }\n            expect(1)\n            yield()\n            expect(3)\n            job.cancelAndJoin()\n            send(5)\n\n        }.collect {\n            expect(it)\n        }\n\n        finish(6)\n    }\n\n    @Test\n    fun testClosedPrematurely() = runTest(unhandled = listOf({ e -> e is ClosedSendChannelException })) {\n        val outerScope = this\n        val flow = channelFlow {\n            // ~ callback-based API, no children\n            outerScope.launch(Job()) {\n                expect(2)\n                send(1)\n                expectUnreached()\n            }\n            expect(1)\n        }\n        assertEquals(emptyList(), flow.toList())\n        finish(3)\n    }\n\n    @Test\n    fun testNotClosedPrematurely() = runTest {\n        val outerScope = this\n        val flow = channelFlow {\n            // ~ callback-based API\n            outerScope.launch(Job()) {\n                expect(2)\n                send(1)\n                close()\n            }\n            expect(1)\n            awaitClose()\n        }\n\n        assertEquals(listOf(1), flow.toList())\n        finish(3)\n    }\n\n    @Test\n    fun testCancelledOnCompletion() = runTest {\n        val myFlow = callbackFlow<Any> {\n            expect(2)\n            close()\n            hang { expect(3) }\n        }\n\n        expect(1)\n        myFlow.collect()\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/channels/FlowCallbackTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass FlowCallbackTest : TestBase() {\n    @Test\n    fun testClosedPrematurely() = runTest {\n        val outerScope = this\n        val flow = callbackFlow {\n            // ~ callback-based API\n            outerScope.launch(Job()) {\n                expect(2)\n                try {\n                    send(1)\n                    expectUnreached()\n                } catch (e: IllegalStateException) {\n                    expect(3)\n                    assertTrue(e.message!!.contains(\"awaitClose\"))\n                }\n            }\n            expect(1)\n        }\n        try {\n            flow.collect()\n        } catch (e: IllegalStateException) {\n            expect(4)\n            assertTrue(e.message!!.contains(\"awaitClose\"))\n        }\n        finish(5)\n    }\n\n    @Test\n    fun testNotClosedPrematurely() = runTest {\n        val outerScope = this\n        val flow = callbackFlow {\n            // ~ callback-based API\n            outerScope.launch(Job()) {\n                expect(2)\n                send(1)\n                close()\n            }\n            expect(1)\n            awaitClose()\n        }\n\n        assertEquals(listOf(1), flow.toList())\n        finish(3)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/internal/FlowScopeTest.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass FlowScopeTest : TestBase() {\n\n    @Test\n    fun testCancellation() = runTest {\n        assertFailsWith<CancellationException> {\n            flowScope {\n                expect(1)\n                val child = launch {\n                    expect(3)\n                    hang { expect(5) }\n                }\n                expect(2)\n                yield()\n                expect(4)\n                child.cancel()\n            }\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testCancellationWithChildCancelled() = runTest {\n        flowScope {\n            expect(1)\n            val child = launch {\n                expect(3)\n                hang { expect(5) }\n            }\n            expect(2)\n            yield()\n            expect(4)\n            child.cancel(ChildCancelledException())\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testCancellationWithSuspensionPoint() = runTest {\n        assertFailsWith<CancellationException> {\n            flowScope {\n                expect(1)\n                val child = launch {\n                    expect(3)\n                    hang { expect(6) }\n                }\n                expect(2)\n                yield()\n                expect(4)\n                child.cancel()\n                hang { expect(5) }\n            }\n        }\n        finish(7)\n    }\n\n    @Test\n    fun testNestedScopes() = runTest {\n        assertFailsWith<CancellationException> {\n            flowScope {\n                flowScope {\n                    launch {\n                       throw CancellationException(\"\")\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/BufferConflationTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\n/**\n * A _behavioral_ test for conflation options that can be configured by the [buffer] operator to test that it is\n * implemented properly and that adjacent [buffer] calls are fused properly.\n*/\nclass BufferConflationTest : TestBase() {\n    private val n = 100 // number of elements to emit for test\n\n    private fun checkConflate(\n        capacity: Int,\n        onBufferOverflow: BufferOverflow = BufferOverflow.DROP_OLDEST,\n        op: suspend Flow<Int>.() -> Flow<Int>\n    ) = runTest {\n        expect(1)\n        // emit all and conflate, then collect first & last\n        val expectedList = when (onBufferOverflow) {\n            BufferOverflow.DROP_OLDEST -> listOf(0) + (n - capacity until n).toList() // first item & capacity last ones\n            BufferOverflow.DROP_LATEST -> (0..capacity).toList() // first & capacity following ones\n            else -> error(\"cannot happen\")\n        }\n        flow {\n            repeat(n) { i ->\n                expect(i + 2)\n                emit(i)\n            }\n        }\n            .op()\n            .collect { i ->\n                val j = expectedList.indexOf(i)\n                expect(n + 2 + j)\n            }\n        finish(n + 2 + expectedList.size)\n    }\n\n    @Test\n    fun testConflate() =\n        checkConflate(1) {\n            conflate()\n        }\n\n    @Test\n    fun testBufferConflated() =\n        checkConflate(1) {\n            buffer(Channel.CONFLATED)\n        }\n\n    @Test\n    fun testBufferDropOldest() =\n        checkConflate(1) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_OLDEST)\n        }\n\n    @Test\n    fun testBuffer0DropOldest() =\n        checkConflate(1) {\n            buffer(0, onBufferOverflow = BufferOverflow.DROP_OLDEST)\n        }\n\n    @Test\n    fun testBuffer1DropOldest() =\n        checkConflate(1) {\n            buffer(1, onBufferOverflow = BufferOverflow.DROP_OLDEST)\n        }\n\n    @Test\n    fun testBuffer10DropOldest() =\n        checkConflate(10) {\n            buffer(10, onBufferOverflow = BufferOverflow.DROP_OLDEST)\n        }\n\n    @Test\n    fun testConflateOverridesBuffer() =\n        checkConflate(1) {\n            buffer(42).conflate()\n        }\n\n    @Test // conflate().conflate() should work like a single conflate\n    fun testDoubleConflate() =\n        checkConflate(1) {\n            conflate().conflate()\n        }\n\n    @Test\n    fun testConflateBuffer10Combine() =\n        checkConflate(10) {\n            conflate().buffer(10)\n        }\n\n    @Test\n    fun testBufferDropLatest() =\n        checkConflate(1, BufferOverflow.DROP_LATEST) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_LATEST)\n        }\n\n    @Test\n    fun testBuffer0DropLatest() =\n        checkConflate(1, BufferOverflow.DROP_LATEST) {\n            buffer(0, onBufferOverflow = BufferOverflow.DROP_LATEST)\n        }\n\n    @Test\n    fun testBuffer1DropLatest() =\n        checkConflate(1, BufferOverflow.DROP_LATEST) {\n            buffer(1, onBufferOverflow = BufferOverflow.DROP_LATEST)\n        }\n\n    @Test // overrides previous buffer\n    fun testBufferDropLatestOverrideBuffer() =\n        checkConflate(1, BufferOverflow.DROP_LATEST) {\n            buffer(42).buffer(onBufferOverflow = BufferOverflow.DROP_LATEST)\n        }\n\n    @Test // overrides previous conflate\n    fun testBufferDropLatestOverrideConflate() =\n        checkConflate(1, BufferOverflow.DROP_LATEST) {\n            conflate().buffer(onBufferOverflow = BufferOverflow.DROP_LATEST)\n        }\n\n    @Test\n    fun testBufferDropLatestBuffer7Combine() =\n        checkConflate(7, BufferOverflow.DROP_LATEST) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_LATEST).buffer(7)\n        }\n\n    @Test\n    fun testConflateOverrideBufferDropLatest() =\n        checkConflate(1) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_LATEST).conflate()\n        }\n\n    @Test\n    fun testBuffer3DropOldestOverrideBuffer8DropLatest() =\n        checkConflate(3, BufferOverflow.DROP_OLDEST) {\n            buffer(8, onBufferOverflow = BufferOverflow.DROP_LATEST)\n            .buffer(3, BufferOverflow.DROP_OLDEST)\n        }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/BufferTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.math.*\nimport kotlin.test.*\n\n/**\n * A _behavioral_ test for buffering that is introduced by the [buffer] operator to test that it is\n * implemented properly and that adjacent [buffer] calls are fused properly.\n */\nclass BufferTest : TestBase() {\n    private val n = 200 // number of elements to emit for test\n    private val defaultBufferSize = 64 // expected default buffer size (per docs)\n\n    // Use capacity == -1 to check case of \"no buffer\"\n    private fun checkBuffer(capacity: Int, op: suspend Flow<Int>.() -> Flow<Int>) = runTest {\n        expect(1)\n        /*\n           Channels perform full rendezvous. Sender does not suspend when there is a suspended receiver and vice-versa.\n           Thus, perceived batch size is +2 from capacity.\n         */\n        val batchSize = capacity + 2\n        flow {\n            repeat(n) { i ->\n                val batchNo = i / batchSize\n                val batchIdx = i % batchSize\n                expect(batchNo * batchSize * 2 + batchIdx + 2)\n                emit(i)\n            }\n        }\n            .op() // insert user-defined operator\n            .collect { i ->\n                val batchNo = i / batchSize\n                val batchIdx = i % batchSize\n                // last batch might have smaller size\n                val k = min((batchNo + 1) * batchSize, n) - batchNo * batchSize\n                expect(batchNo * batchSize * 2 + k + batchIdx + 2)\n            }\n        finish(2 * n + 2)\n    }\n\n    @Test\n    // capacity == -1 to checkBuffer means \"no buffer\" -- emits / collects are sequentially ordered\n    fun testBaseline() =\n        checkBuffer(-1) { this }\n\n    @Test\n    fun testBufferDefault() =\n        checkBuffer(defaultBufferSize) {\n            buffer()\n        }\n\n    @Test\n    fun testBufferRendezvous() =\n        checkBuffer(0) {\n            buffer(0)\n        }\n\n    @Test\n    fun testBuffer1() =\n        checkBuffer(1) {\n            buffer(1)\n        }\n\n    @Test\n    fun testBuffer2() =\n        checkBuffer(2) {\n            buffer(2)\n        }\n\n    @Test\n    fun testBuffer3() =\n        checkBuffer(3) {\n            buffer(3)\n        }\n\n    @Test\n    fun testBuffer00Fused() =\n        checkBuffer(0) {\n            buffer(0).buffer(0)\n        }\n\n    @Test\n    fun testBuffer01Fused() =\n        checkBuffer(1) {\n            buffer(0).buffer(1)\n        }\n\n    @Test\n    fun testBuffer11Fused() =\n        checkBuffer(2) {\n            buffer(1).buffer(1)\n        }\n\n    @Test\n    fun testBuffer111Fused() =\n        checkBuffer(3) {\n            buffer(1).buffer(1).buffer(1)\n        }\n\n    @Test\n    fun testBuffer123Fused() =\n        checkBuffer(6) {\n            buffer(1).buffer(2).buffer(3)\n        }\n\n    @Test // multiple calls to buffer() create one channel of default size\n    fun testBufferDefaultTwiceFused() =\n        checkBuffer(defaultBufferSize) {\n            buffer().buffer()\n        }\n\n    @Test // explicit buffer takes precedence of default buffer on fuse\n    fun testBufferDefaultBufferFused() =\n        checkBuffer(7) {\n            buffer().buffer(7)\n        }\n\n    @Test // explicit buffer takes precedence of default buffer on fuse\n    fun testBufferBufferDefaultFused() =\n        checkBuffer(8) {\n            buffer(8).buffer()\n        }\n\n    @Test // flowOn operator does not use buffer when dispatches does not change\n    fun testFlowOnNameNoBuffer() =\n        checkBuffer(-1) {\n            flowOn(CoroutineName(\"Name\"))\n        }\n\n    @Test // flowOn operator uses default buffer size when dispatcher changes\n    fun testFlowOnDispatcherBufferDefault() =\n        checkBuffer(defaultBufferSize) {\n            flowOn(wrapperDispatcher())\n        }\n\n    @Test // flowOn(...).buffer(n) sets explicit buffer size to n\n    fun testFlowOnDispatcherBufferFused() =\n        checkBuffer(5) {\n            flowOn(wrapperDispatcher()).buffer(5)\n        }\n    \n    @Test // buffer(n).flowOn(...) sets explicit buffer size to n\n    fun testBufferFlowOnDispatcherFused() =\n        checkBuffer(6) {\n            buffer(6).flowOn(wrapperDispatcher())\n        }\n\n    @Test // flowOn(...).buffer(n) sets explicit buffer size to n\n    fun testFlowOnNameBufferFused() =\n        checkBuffer(7) {\n            flowOn(CoroutineName(\"Name\")).buffer(7)\n        }\n\n    @Test // buffer(n).flowOn(...) sets explicit buffer size to n\n    fun testBufferFlowOnNameFused() =\n        checkBuffer(8) {\n            buffer(8).flowOn(CoroutineName(\"Name\"))\n        }\n\n    @Test // multiple flowOn/buffer all fused together\n    fun testBufferFlowOnMultipleFused() =\n        checkBuffer(12) {\n            flowOn(wrapperDispatcher()).buffer(3)\n                .flowOn(CoroutineName(\"Name\")).buffer(4)\n                .flowOn(wrapperDispatcher()).buffer(5)\n        }\n\n    @Test\n    fun testCancellation() = runTest {\n        val result = flow {\n            emit(1)\n            emit(2)\n            emit(3)\n            expectUnreached()\n            emit(4)\n        }.buffer(0)\n            .take(2)\n            .toList()\n        assertEquals(listOf(1, 2), result)\n    }\n\n    @Test\n    fun testFailsOnIllegalArguments() {\n        val flow = emptyFlow<Int>()\n        assertFailsWith<IllegalArgumentException> { flow.buffer(capacity = -3) }\n        assertFailsWith<IllegalArgumentException> { flow.buffer(capacity = Int.MIN_VALUE) }\n        assertFailsWith<IllegalArgumentException> { flow.buffer(capacity = Channel.CONFLATED, onBufferOverflow = BufferOverflow.DROP_LATEST) }\n        assertFailsWith<IllegalArgumentException> { flow.buffer(capacity = Channel.CONFLATED, onBufferOverflow = BufferOverflow.DROP_OLDEST) }\n    }\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/CancellableTest.kt",
        "content": "package kotlinx.coroutines.flow.operators\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\n\nclass CancellableTest : TestBase() {\n\n    @Test\n    fun testCancellable() = runTest {\n        var sum = 0\n        val flow = (0..1000).asFlow()\n            .onEach {\n                if (it != 0) currentCoroutineContext().cancel()\n                sum += it\n            }\n\n        flow.launchIn(this).join()\n        assertEquals(500500, sum)\n        \n        sum = 0\n        flow.cancellable().launchIn(this).join()\n        assertEquals(1, sum)\n    }\n\n    @Test\n    fun testFastPath() {\n        val flow = listOf(1).asFlow()\n        assertNotSame(flow, flow.cancellable())\n\n        val cancellableFlow = flow { emit(42) }\n        assertSame(cancellableFlow, cancellableFlow.cancellable())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/CatchTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass CatchTest : TestBase() {\n    @Test\n    fun testCatchEmit() = runTest {\n        val flow = flow {\n            emit(1)\n            throw TestException()\n        }\n\n        assertEquals(42, flow.catch { emit(41) }.sum())\n        assertFailsWith<TestException>(flow)\n    }\n\n    @Test\n    fun testCatchEmitExceptionFromDownstream() = runTest {\n        var executed = 0\n        val flow = flow {\n            emit(1)\n        }.catch { emit(42) }.map {\n            ++executed\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        assertEquals(1, executed)\n    }\n\n    @Test\n    fun testCatchEmitAll() = runTest {\n        val flow = flow {\n            emit(1)\n            throw TestException()\n        }.catch { emitAll(flowOf(2)) }\n\n        assertEquals(3, flow.sum())\n    }\n\n    @Test\n    fun testCatchEmitAllExceptionFromDownstream() = runTest {\n        var executed = 0\n        val flow = flow {\n            emit(1)\n        }.catch { emitAll(flowOf(1, 2, 3)) }.map {\n            ++executed\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        assertEquals(1, executed)\n    }\n\n    @Test\n    fun testWithTimeoutCatch() = runTest {\n        val flow = flow<Int> {\n            withTimeout(1) {\n                hang { expect(1) }\n            }\n            expectUnreached()\n        }.catch { emit(1) }\n\n        assertEquals(1, flow.single())\n        finish(2)\n    }\n\n    @Test\n    fun testCancellationFromUpstreamCatch() = runTest {\n        val flow = flow<Int> {\n            hang {  }\n        }.catch { expectUnreached() }\n\n        val job = launch {\n            expect(1)\n            flow.collect {  }\n        }\n\n        yield()\n        expect(2)\n        job.cancelAndJoin()\n        finish(3)\n    }\n\n    @Test\n    fun testCatchContext() = runTest {\n        expect(1)\n        val flow = flow {\n            expect(2)\n            emit(\"OK\")\n            expect(3)\n            throw TestException()\n        }\n        val d0 = coroutineContext[ContinuationInterceptor] as CoroutineContext\n        val d1 = wrapperDispatcher(coroutineContext)\n        val d2 = wrapperDispatcher(coroutineContext)\n        flow\n            .catch { e ->\n                expect(4)\n                assertIs<TestException>(e)\n                assertEquals(\"A\", kotlin.coroutines.coroutineContext[CoroutineName]?.name)\n                assertSame(d1, kotlin.coroutines.coroutineContext[ContinuationInterceptor] as CoroutineContext)\n                throw e // rethrow downstream\n            }\n            .flowOn(CoroutineName(\"A\"))\n            .catch { e ->\n                expect(5)\n                assertIs<TestException>(e)\n                assertEquals(\"B\", kotlin.coroutines.coroutineContext[CoroutineName]?.name)\n                assertSame(d1, kotlin.coroutines.coroutineContext[ContinuationInterceptor] as CoroutineContext)\n                throw e // rethrow downstream\n            }\n            .flowOn(CoroutineName(\"B\"))\n            .catch { e ->\n                expect(6)\n                assertIs<TestException>(e)\n                assertSame(d1, kotlin.coroutines.coroutineContext[ContinuationInterceptor] as CoroutineContext)\n                throw e // rethrow downstream\n            }\n            .flowOn(d1)\n            .catch { e ->\n                expect(7)\n                assertIs<TestException>(e)\n                assertSame(d2, kotlin.coroutines.coroutineContext[ContinuationInterceptor] as CoroutineContext)\n                throw e // rethrow downstream\n            }\n            .flowOn(d2)\n            // flowOn with a different dispatcher introduces asynchrony so that all exceptions in the\n            // upstream flows are handled before they go downstream\n            .onEach {\n                expectUnreached() // already cancelled\n            }\n            .catch { e ->\n                expect(8)\n                assertIs<TestException>(e)\n                assertSame(d0, kotlin.coroutines.coroutineContext[ContinuationInterceptor] as CoroutineContext)\n            }\n            .collect()\n        finish(9)\n    }\n\n    @Test\n    fun testUpstreamExceptionConcurrentWithDownstream() = runTest {\n        val flow = flow {\n            try {\n                expect(1)\n                emit(1)\n            } finally {\n                expect(3)\n                throw TestException()\n            }\n        }.catch { expectUnreached() }.onEach {\n            expect(2)\n            throw TestException2()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testUpstreamExceptionConcurrentWithDownstreamCancellation() = runTest {\n        val flow = flow {\n            try {\n                expect(1)\n                emit(1)\n            } finally {\n                expect(3)\n                throw TestException()\n            }\n        }.catch { expectUnreached() }.onEach {\n            expect(2)\n            throw CancellationException(\"\")\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testUpstreamCancellationIsIgnoredWhenDownstreamFails() = runTest {\n        val flow = flow {\n            try {\n                expect(1)\n                emit(1)\n            } finally {\n                expect(3)\n                throw CancellationException(\"\")\n            }\n        }.catch { expectUnreached() }.onEach {\n            expect(2)\n            throw TestException(\"\")\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/CombineParametersTest.kt",
        "content": "package kotlinx.coroutines.flow.operators\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\n\nclass CombineParametersTest : TestBase() {\n\n    @Test\n    fun testThreeParameters() = runTest {\n        val flow = combine(flowOf(\"1\"), flowOf(2), flowOf(null)) { a, b, c -> a + b + c }\n        assertEquals(\"12null\", flow.single())\n\n        val flow2 = combineTransform(flowOf(\"1\"), flowOf(2), flowOf(null)) { a, b, c -> emit(a + b + c) }\n        assertEquals(\"12null\", flow2.single())\n    }\n\n    @Test\n    fun testThreeParametersTransform() = runTest {\n        val flow = combineTransform(flowOf(\"1\"), flowOf(2), flowOf(null)) { a, b, c -> emit(a + b + c) }\n        assertEquals(\"12null\", flow.single())\n    }\n\n    @Test\n    fun testFourParameters() = runTest {\n        val flow = combine(flowOf(\"1\"), flowOf(2), flowOf(\"3\"), flowOf(null)) { a, b, c, d -> a + b + c + d }\n        assertEquals(\"123null\", flow.single())\n    }\n\n    @Test\n    fun testFourParametersTransform() = runTest {\n        val flow = combineTransform(flowOf(\"1\"), flowOf(2), flowOf(\"3\"), flowOf(null)) { a, b, c, d ->\n            emit(a + b + c + d)\n        }\n        assertEquals(\"123null\", flow.single())\n    }\n\n    @Test\n    fun testFiveParameters() = runTest {\n        val flow = combine(flowOf(\"1\"), flowOf(2), flowOf(\"3\"), flowOf(4.toByte()), flowOf(null)) { a, b, c, d, e ->\n                a + b + c + d + e\n            }\n        assertEquals(\"1234null\", flow.single())\n    }\n\n    @Test\n    fun testFiveParametersTransform() = runTest {\n        val flow =\n            combineTransform(flowOf(\"1\"), flowOf(2), flowOf(\"3\"), flowOf(4.toByte()), flowOf(null)) { a, b, c, d, e ->\n                emit(a + b + c + d + e)\n            }\n        assertEquals(\"1234null\", flow.single())\n    }\n\n    @Test\n    fun testNonMatchingTypes() = runTest {\n        val flow = combine(flowOf(1), flowOf(\"2\")) { args: Array<Any?> ->\n            args[0]?.toString() + args[1]?.toString()\n        }\n        assertEquals(\"12\", flow.single())\n    }\n\n    @Test\n    fun testNonMatchingTypesIterable() = runTest {\n        val flow = combine(listOf(flowOf(1), flowOf(\"2\"))) { args: Array<Any?> ->\n            args[0]?.toString() + args[1]?.toString()\n        }\n        assertEquals(\"12\", flow.single())\n    }\n\n    @Test\n    fun testVararg() = runTest {\n        val flow = combine(\n            flowOf(\"1\"),\n            flowOf(2),\n            flowOf(\"3\"),\n            flowOf(4.toByte()),\n            flowOf(\"5\"),\n            flowOf(null)\n        ) { arr -> arr.joinToString(\"\") }\n        assertEquals(\"12345null\", flow.single())\n    }\n\n    @Test\n    fun testVarargTransform() = runTest {\n        val flow = combineTransform(\n            flowOf(\"1\"),\n            flowOf(2),\n            flowOf(\"3\"),\n            flowOf(4.toByte()),\n            flowOf(\"5\"),\n            flowOf(null)\n        ) { arr -> emit(arr.joinToString(\"\")) }\n        assertEquals(\"12345null\", flow.single())\n    }\n\n    @Test\n    fun testSingleVararg() = runTest {\n        val list = combine(flowOf(1, 2, 3)) { args: Array<Any?> -> args[0] }.toList()\n        assertEquals(listOf(1, 2, 3), list)\n    }\n\n    @Test\n    fun testSingleVarargTransform() = runTest {\n        val list = combineTransform(flowOf(1, 2, 3)) { args: Array<Any?> -> emit(args[0]) }.toList()\n        assertEquals(listOf(1, 2, 3), list)\n    }\n\n    @Test\n    fun testReified() = runTest {\n        val value = combine(flowOf(1), flowOf(2)) { args: Array<Int> ->\n            assertIs<Array<Int>>(args)\n            args[0] + args[1]\n        }.single()\n        assertEquals(3, value)\n    }\n\n    @Test\n    fun testReifiedTransform() = runTest {\n        val value = combineTransform(flowOf(1), flowOf(2)) { args: Array<Int> ->\n            assertIs<Array<Int>>(args)\n            emit(args[0] + args[1])\n        }.single()\n        assertEquals(3, value)\n    }\n\n    @Test\n    fun testTransformEmptyIterable() = runTest {\n        val value = combineTransform(emptyList()) { args: Array<Int> ->\n            emit(args[0] + args[1])\n        }.singleOrNull()\n        assertNull(value)\n    }\n\n    @Test\n    fun testTransformEmptyVararg() = runTest {\n        val value = combineTransform { args: Array<Int> ->\n            emit(args[0] + args[1])\n        }.singleOrNull()\n        assertNull(value)\n    }\n\n    @Test\n    fun testEmptyIterable() = runTest {\n        val value = combine(emptyList()) { args: Array<Int> ->\n            args[0] + args[1]\n        }.singleOrNull()\n        assertNull(value)\n    }\n\n    @Test\n    fun testEmptyVararg() = runTest {\n        val value = combine { args: Array<Int> ->\n            args[0] + args[1]\n        }.singleOrNull()\n        assertNull(value)\n    }\n\n    @Test\n    fun testFairnessInVariousConfigurations() = runTest {\n        // Test various configurations\n        for (flowsCount in 2..5) {\n            for (flowSize in 1..5) {\n                val flows = List(flowsCount) { (1..flowSize).asFlow() }\n                val combined = combine(flows) { it.joinToString(separator = \"\") }.toList()\n                val expected = List(flowSize) { (it +  1).toString().repeat(flowsCount) }\n                assertEquals(expected, combined, \"Count: $flowsCount, size: $flowSize\")\n            }\n        }\n    }\n\n    @Test\n    fun testEpochOverflow() = runTest {\n        val flow = (0..1023).asFlow()\n        val result = flow.combine(flow) { a, b -> a + b }.toList()\n        assertEquals(List(1024) { it * 2 } , result)\n    }\n\n    @Test\n    fun testArrayType() = runTest {\n        val arr = flowOf(1)\n        combine(listOf(arr, arr)) {\n            println(it[0])\n            it[0]\n        }.toList().also { println(it) }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/CombineTest.kt",
        "content": "@file:Suppress(\"UNCHECKED_CAST\")\npackage kotlinx.coroutines.flow.operators\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\nimport kotlinx.coroutines.flow.combine as combineOriginal\nimport kotlinx.coroutines.flow.combineTransform as combineTransformOriginal\n\nabstract class CombineTestBase : TestBase() {\n\n    abstract fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R>\n\n    @Test\n    fun testCombineLatest() = runTest {\n        val flow = flowOf(\"a\", \"b\", \"c\")\n        val flow2 = flowOf(1, 2, 3)\n        val list = flow.combineLatest(flow2, String::plus).toList()\n        assertEquals(listOf(\"a1\", \"b2\", \"c3\"), list)\n    }\n\n    @Test\n    fun testNulls() = runTest {\n        val flow = flowOf(\"a\", null, null)\n        val flow2 = flowOf(1, 2, 3)\n        val list = flow.combineLatest(flow2, String?::plus).toList()\n        assertEquals(listOf(\"a1\", \"null2\", \"null3\"), list)\n    }\n\n    @Test\n    fun testNullsOther() = runTest {\n        val flow = flowOf(\"a\", \"b\", \"c\")\n        val flow2 = flowOf(null, 2, null)\n        val list = flow.combineLatest(flow2, String::plus).toList()\n        assertEquals(listOf(\"anull\", \"b2\", \"cnull\"), list)\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        val flow = emptyFlow<String>().combineLatest(emptyFlow<Int>(), String::plus)\n        assertNull(flow.singleOrNull())\n    }\n\n    @Test\n    fun testFirstIsEmpty() = runTest {\n        val f1 = emptyFlow<String>()\n        val f2 = flowOf(1)\n        assertEquals(emptyList(), f1.combineLatest(f2, String::plus).toList())\n    }\n\n    @Test\n    fun testSecondIsEmpty() = runTest {\n        val f1 = flowOf(\"a\")\n        val f2 = emptyFlow<Int>()\n        assertEquals(emptyList(), f1.combineLatest(f2, String::plus).toList())\n    }\n\n    @Test\n    fun testPreservingOrder() = runTest {\n        val f1 = flow {\n            expect(1)\n            emit(\"a\")\n            expect(3)\n            emit(\"b\")\n            emit(\"c\")\n            expect(4)\n        }\n\n        val f2 = flow {\n            expect(2)\n            emit(1)\n            yield()\n            yield()\n            expect(5)\n            emit(2)\n            expect(6)\n            yield()\n            expect(7)\n            emit(3)\n        }\n\n        val result = f1.combineLatest(f2, String::plus).toList()\n        assertEquals(listOf(\"a1\", \"b1\", \"c1\", \"c2\", \"c3\"), result)\n        finish(8)\n    }\n\n    @Test\n    fun testPreservingOrderReversed() = runTest {\n        val f1 = flow {\n            expect(1)\n            emit(\"a\")\n            expect(3)\n            emit(\"b\")\n            emit(\"c\")\n            expect(4)\n        }\n\n        val f2 = flow {\n            yield() // One more yield because now this flow starts first\n            expect(2)\n            emit(1)\n            yield()\n            yield()\n            expect(5)\n            emit(2)\n            expect(6)\n            yield()\n            expect(7)\n            emit(3)\n        }\n\n        val result = f2.combineLatest(f1) { i, j -> j + i }.toList()\n        assertEquals(listOf(\"a1\", \"b1\", \"c1\", \"c2\", \"c3\"), result)\n        finish(8)\n    }\n\n    @Test\n    fun testContextIsIsolated() = runTest {\n        val f1 = flow {\n            emit(\"a\")\n            assertEquals(\"first\", NamedDispatchers.name())\n            expect(1)\n        }.flowOn(NamedDispatchers(\"first\")).onEach {\n            assertEquals(\"nested\", NamedDispatchers.name())\n            expect(2)\n        }.flowOn(NamedDispatchers(\"nested\"))\n\n        val f2 = flow {\n            emit(1)\n            assertEquals(\"second\", NamedDispatchers.name())\n            expect(3)\n        }.flowOn(NamedDispatchers(\"second\"))\n            .onEach {\n                assertEquals(\"onEach\", NamedDispatchers.name())\n                expect(4)\n            }.flowOn(NamedDispatchers(\"onEach\"))\n\n        val value = withContext(NamedDispatchers(\"main\")) {\n            f1.combineLatest(f2) { i, j ->\n                assertEquals(\"main\", NamedDispatchers.name())\n                expect(5)\n                i + j\n            }.single()\n        }\n\n        assertEquals(\"a1\", value)\n        finish(6)\n    }\n\n    @Test\n    fun testErrorInDownstreamCancelsUpstream() = runTest {\n        val f1 = flow {\n            emit(\"a\")\n            hang {\n                expect(2)\n            }\n        }.flowOn(NamedDispatchers(\"first\"))\n\n        val f2 = flow {\n            emit(1)\n            hang {\n                expect(3)\n            }\n        }.flowOn(NamedDispatchers(\"second\"))\n\n        val flow = f1.combineLatest(f2) { i, j ->\n            assertEquals(\"combine\", NamedDispatchers.name())\n            expect(1)\n            i + j\n        }.flowOn(NamedDispatchers(\"combine\")).onEach {\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testErrorCancelsSibling() = runTest {\n        val f1 = flow {\n            emit(\"a\")\n            hang {\n                expect(1)\n            }\n        }.flowOn(NamedDispatchers(\"first\"))\n\n        val f2 = flow {\n            emit(1)\n            throw TestException()\n        }.flowOn(NamedDispatchers(\"second\"))\n\n        val flow = f1.combineLatest(f2) { _, _ -> 1 }\n        assertFailsWith<TestException>(flow)\n        finish(2)\n    }\n\n    @Test\n    fun testCancellationExceptionUpstream() = runTest {\n        val f1 = flow {\n            expect(1)\n            emit(1)\n            throw CancellationException(\"\")\n        }\n        val f2 = flow {\n            emit(1)\n            expectUnreached()\n        }\n\n        val flow = f1.combineLatest(f2) { _, _ -> 1 }.onEach { expect(2) }\n        assertFailsWith<CancellationException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testCancellationExceptionDownstream() = runTest {\n        val f1 = flow {\n            emit(1)\n            expect(2)\n            hang { expect(5) }\n        }\n        val f2 = flow {\n            emit(1)\n            expect(3)\n            hang { expect(6) }\n        }\n\n        val flow = f1.combineLatest(f2) { _, _ -> 1 }.onEach {\n            expect(1)\n            yield()\n            expect(4)\n            throw CancellationException(\"\")\n        }\n        assertFailsWith<CancellationException>(flow)\n        finish(7)\n    }\n\n    @Test\n    fun testCancelledCombine() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        coroutineScope {\n            val flow =  flow {\n                emit(Unit) // emit\n            }\n            cancel() // cancel the scope\n            flow.combineLatest(flow) { _, _ ->  }.collect {\n                // should not be reached, because cancelled before it runs\n                expectUnreached()\n            }\n        }\n    }\n}\n\nclass CombineTest : CombineTestBase() {\n    override fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> = combineOriginal(other, transform)\n}\n\nclass CombineOverloadTest : CombineTestBase() {\n    override fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> = combineOriginal(this, other, transform)\n}\n\nclass CombineTransformTest : CombineTestBase() {\n    override fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> = combineTransformOriginal(other) { a, b ->\n        emit(transform(a, b))\n    }\n}\n// Array null-out is an additional test for our array elimination optimization\n\nclass CombineVarargAdapterTest : CombineTestBase() {\n    override fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> =\n        combineOriginal(this, other) { args: Array<Any?> ->\n            transform(args[0] as T1, args[1] as T2).also {\n                args[0] = null\n                args[1] = null\n            }\n        }\n}\n\nclass CombineIterableTest : CombineTestBase() {\n    override fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> =\n        combineOriginal(listOf(this, other)) { args ->\n            transform(args[0] as T1, args[1] as T2).also {\n                args[0] = null\n                args[1] = null\n            }\n        }\n}\n\nclass CombineTransformAdapterTest : CombineTestBase() {\n    override fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> =\n        combineTransformOriginal(flow = this, flow2 = other) { a1, a2 -> emit(transform(a1, a2)) }\n}\n\nclass CombineTransformVarargAdapterTest : CombineTestBase() {\n    override fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> =\n        combineTransformOriginal(this, other) { args: Array<Any?> ->\n            emit(transform(args[0] as T1, args[1] as T2))   // Mess up with array\n            args[0] = null\n            args[1] = null\n        }\n}\n\nclass CombineTransformIterableTest : CombineTestBase() {\n    override fun <T1, T2, R> Flow<T1>.combineLatest(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R> =\n        combineTransformOriginal(listOf(this, other)) { args ->\n            emit(transform(args[0] as T1, args[1] as T2))\n            // Mess up with array\n            args[0] = null\n            args[1] = null\n        }\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/ConflateTest.kt",
        "content": "package kotlinx.coroutines.flow.operators\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\n\nclass ConflateTest : TestBase() {\n    @Test // from example\n    fun testExample() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            for (i in 1..30) {\n                delay(100)\n                emit(i)\n            }\n        }\n        val result = flow.conflate().onEach {\n            delay(1000)\n        }.toList()\n        assertEquals(listOf(1, 10, 20, 30), result)\n        finish(2)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/DebounceTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nclass DebounceTest : TestBase() {\n    @Test\n    fun testBasic() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(1500)\n            emit(\"B\")\n            delay(500)\n            emit(\"C\")\n            delay(250)\n            emit(\"D\")\n            delay(2000)\n            emit(\"E\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.debounce(1000).toList()\n        assertEquals(listOf(\"A\", \"D\", \"E\"), result)\n        finish(5)\n    }\n\n    @Test\n    fun testSingleNull() = runTest {\n        val flow = flowOf<Int?>(null).debounce(Long.MAX_VALUE)\n        assertNull(flow.single())\n    }\n\n    @Test\n    fun testBasicWithNulls() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(1500)\n            emit(\"B\")\n            delay(500)\n            emit(\"C\")\n            delay(250)\n            emit(null)\n            delay(2000)\n            emit(null)\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.debounce(1000).toList()\n        assertEquals(listOf(\"A\", null, null), result)\n        finish(5)\n    }\n\n    @Test\n    fun testEmpty() = runTest {\n        val flow = emptyFlow<Int>().debounce(Long.MAX_VALUE)\n        assertNull(flow.singleOrNull())\n    }\n\n    @Test\n    fun testScalar() = withVirtualTime {\n        val flow = flowOf(1, 2, 3).debounce(1000)\n        assertEquals(3, flow.single())\n        finish(1)\n    }\n\n    @Test\n    fun testPace() = withVirtualTime {\n        val flow = flow {\n            expect(1)\n            repeat(10) {\n                emit(-it)\n                delay(99)\n            }\n\n            repeat(10) {\n                emit(it)\n                delay(101)\n            }\n            expect(2)\n        }.debounce(100)\n\n        assertEquals((0..9).toList(), flow.toList())\n        finish(3)\n    }\n\n    @Test\n    fun testUpstreamError()= testUpstreamError(TimeoutCancellationException(\"\"))\n\n    @Test\n    fun testUpstreamErrorCancellation() = testUpstreamError(TimeoutCancellationException(\"\"))\n\n    private inline fun <reified T: Throwable> testUpstreamError(cause: T) = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            latch.receive()\n            throw cause\n        }.debounce(1).map {\n            latch.send(Unit)\n            hang { expect(3) }\n        }\n\n        assertFailsWith<T>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testUpstreamErrorIsolatedContext() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            assertEquals(\"upstream\", NamedDispatchers.name())\n            expect(1)\n            emit(1)\n            expect(2)\n            latch.receive()\n            throw TestException()\n        }.flowOn(NamedDispatchers(\"upstream\")).debounce(1).map {\n            latch.send(Unit)\n            hang { expect(3) }\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testUpstreamErrorDebounceNotTriggered() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            throw TestException()\n        }.debounce(Long.MAX_VALUE).map {\n            expectUnreached()\n        }\n        assertFailsWith<TestException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testUpstreamErrorDebounceNotTriggeredInIsolatedContext() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            throw TestException()\n        }.flowOn(NamedDispatchers(\"source\")).debounce(Long.MAX_VALUE).map {\n            expectUnreached()\n        }\n        assertFailsWith<TestException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testDownstreamError() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            hang { expect(3) }\n        }.debounce(100).map {\n            expect(2)\n            yield()\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testDownstreamErrorIsolatedContext() = runTest {\n        val flow = flow {\n            assertEquals(\"upstream\", NamedDispatchers.name())\n            expect(1)\n            emit(1)\n            hang { expect(3) }\n        }.flowOn(NamedDispatchers(\"upstream\")).debounce(100).map {\n            expect(2)\n            yield()\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testDurationBasic() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(1500.milliseconds)\n            emit(\"B\")\n            delay(500.milliseconds)\n            emit(\"C\")\n            delay(250.milliseconds)\n            emit(\"D\")\n            delay(2000.milliseconds)\n            emit(\"E\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.debounce(1000.milliseconds).toList()\n        assertEquals(listOf(\"A\", \"D\", \"E\"), result)\n        finish(5)\n    }\n\n    @Test\n    fun testDebounceSelectorBasic() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(1)\n            delay(90)\n            emit(2)\n            delay(90)\n            emit(3)\n            delay(1010)\n            emit(4)\n            delay(1010)\n            emit(5)\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.debounce {\n            if (it == 1) {\n                0\n            } else {\n                1000\n            }\n        }.toList()\n\n        assertEquals(listOf(1, 3, 4, 5), result)\n        finish(5)\n    }\n\n    @Test\n    fun testZeroDebounceTime() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            emit(\"B\")\n            emit(\"C\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.debounce(0).toList()\n\n        assertEquals(listOf(\"A\", \"B\", \"C\"), result)\n        finish(5)\n    }\n\n    @Test\n    fun testZeroDebounceTimeSelector() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            emit(\"B\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.debounce { 0 }.toList()\n\n        assertEquals(listOf(\"A\", \"B\"), result)\n        finish(5)\n    }\n\n    @Test\n    fun testDebounceDurationSelectorBasic() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(1500.milliseconds)\n            emit(\"B\")\n            delay(500.milliseconds)\n            emit(\"C\")\n            delay(250.milliseconds)\n            emit(\"D\")\n            delay(2000.milliseconds)\n            emit(\"E\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.debounce {\n            if (it == \"C\") {\n                0.milliseconds\n            } else {\n                1000.milliseconds\n            }\n        }.toList()\n\n        assertEquals(listOf(\"A\", \"C\", \"D\", \"E\"), result)\n        finish(5)\n    }\n\n    @Test\n    fun testFailsWithIllegalArgument() {\n        val flow = emptyFlow<Int>()\n        assertFailsWith<IllegalArgumentException> { flow.debounce(-1) }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/DistinctUntilChangedTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass DistinctUntilChangedTest : TestBase() {\n\n    private class Box(val i: Int)\n\n    @Test\n    fun testDistinctUntilChanged() = runTest {\n        val flow = flowOf(1, 1, 2, 2, 1).distinctUntilChanged()\n        assertEquals(4, flow.sum())\n    }\n\n    @Test\n    fun testDistinctUntilChangedKeySelector() = runTest {\n        val flow = flow {\n            emit(Box(1))\n            emit(Box(1))\n            emit(Box(2))\n            emit(Box(1))\n        }\n\n        val sum1 = flow.distinctUntilChanged().map { it.i }.sum()\n        val sum2 = flow.distinctUntilChangedBy(Box::i).map { it.i }.sum()\n        assertEquals(5, sum1)\n        assertEquals(4, sum2)\n    }\n\n    @Test\n    fun testDistinctUntilChangedAreEquivalent() = runTest {\n        val flow = flow {\n            emit(Box(1))\n            emit(Box(1))\n            emit(Box(2))\n            emit(Box(1))\n        }\n\n        val sum1 = flow.distinctUntilChanged().map { it.i }.sum()\n        val sum2 = flow.distinctUntilChanged { old, new -> old.i == new.i }.map { it.i }.sum()\n        assertEquals(5, sum1)\n        assertEquals(4, sum2)\n    }\n\n    @Test\n    fun testDistinctUntilChangedAreEquivalentSingleValue() = runTest {\n        val flow = flowOf(1)\n        val values = flow.distinctUntilChanged { _, _ -> fail(\"Expected not to compare single value.\") }.toList()\n        assertEquals(listOf(1), values)\n    }\n\n    @Test\n    fun testThrowingKeySelector() = runTest {\n        val flow = flow {\n            coroutineScope {\n                launch(start = CoroutineStart.ATOMIC) {\n                    hang { expect(3) }\n                }\n                expect(2)\n                emit(1)\n            }\n        }.distinctUntilChangedBy { throw TestException() }\n\n        expect(1)\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testThrowingAreEquivalent() = runTest {\n        val flow = flow {\n            coroutineScope {\n                launch(start = CoroutineStart.ATOMIC) {\n                    hang { expect(3) }\n                }\n                expect(2)\n                emit(1)\n                emit(2)\n            }\n        }.distinctUntilChanged { _, _ -> throw TestException() }\n\n        expect(1)\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testDistinctUntilChangedNull() = runTest {\n        val flow = flowOf(null, 1, null, null).distinctUntilChanged()\n        assertEquals(listOf(null, 1, null), flow.toList())\n    }\n\n    @Test\n    fun testRepeatedDistinctFusionDefault() = testRepeatedDistinctFusion {\n        distinctUntilChanged()\n    }\n\n    // A separate variable is needed for K/N that does not optimize non-captured lambdas (yet)\n    private val areEquivalentTestFun: (old: Int, new: Int) -> Boolean = { old, new -> old == new }\n\n    @Test\n    fun testRepeatedDistinctFusionAreEquivalent() = testRepeatedDistinctFusion {\n        distinctUntilChanged(areEquivalentTestFun)\n    }\n\n    // A separate variable is needed for K/N that does not optimize non-captured lambdas (yet)\n    private val keySelectorTestFun: (Int) -> Int = { it % 2 }\n\n    @Test\n    fun testRepeatedDistinctFusionByKey() = testRepeatedDistinctFusion {\n        distinctUntilChangedBy(keySelectorTestFun)\n    }\n\n    private fun testRepeatedDistinctFusion(op: Flow<Int>.() -> Flow<Int>) = runTest {\n        val flow = (1..10).asFlow()\n        val d1 = flow.op()\n        assertNotSame(flow, d1)\n        val d2 = d1.op()\n        assertSame(d1, d2)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/DropTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass DropTest : TestBase() {\n    @Test\n    fun testDrop() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(2)\n            emit(3)\n        }\n\n        assertEquals(5, flow.drop(1).sum())\n        assertEquals(0, flow.drop(Int.MAX_VALUE).sum())\n        assertNull(flow.drop(Int.MAX_VALUE).singleOrNull())\n        assertEquals(3, flow.drop(1).take(2).drop(1).single())\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        assertEquals(0, flowOf<Int>().drop(1).sum())\n    }\n\n    @Test\n    fun testNegativeCount() {\n        assertFailsWith<IllegalArgumentException> {\n            emptyFlow<Int>().drop(-1)\n        }\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        val flow = flow {\n            coroutineScope {\n                launch(start = CoroutineStart.ATOMIC) {\n                    hang { expect(5) }\n                }\n                expect(2)\n                emit(1)\n                expect(3)\n                emit(2)\n                expectUnreached()\n            }\n        }.drop(1)\n            .map<Int, Int> {\n                expect(4)\n                throw TestException()\n            }.catch { emit(42) }\n\n        expect(1)\n        assertEquals(42, flow.single())\n        finish(6)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/DropWhileTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass DropWhileTest : TestBase() {\n    @Test\n    fun testDropWhile() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(2)\n            emit(3)\n        }\n\n        assertEquals(6, flow.dropWhile { false }.sum())\n        assertNull(flow.dropWhile { true }.singleOrNull())\n        assertEquals(5, flow.dropWhile { it < 2 }.sum())\n        assertEquals(1, flow.take(1).dropWhile { it > 1 }.single())\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        assertEquals(0, flowOf<Int>().dropWhile { true }.sum())\n        assertEquals(0, flowOf<Int>().dropWhile { false }.sum())\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        val flow = flow {\n            coroutineScope {\n                launch(start = CoroutineStart.ATOMIC) {\n                    hang { expect(4) }\n                }\n                expect(2)\n                emit(1)\n                expectUnreached()\n            }\n        }.dropWhile {\n            expect(3)\n            throw TestException()\n        }\n\n        expect(1)\n        assertFailsWith<TestException>(flow)\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FilterTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass FilterTest : TestBase() {\n    @Test\n    fun testFilter() = runTest {\n        val flow = flowOf(1, 2)\n        assertEquals(2, flow.filter { it % 2 == 0 }.sum())\n        assertEquals(3, flow.filter { true }.sum())\n        assertEquals(0, flow.filter { false }.sum())\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        val sum = emptyFlow<Int>().filter { true }.sum()\n        assertEquals(0, sum)\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        var cancelled = false\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang {cancelled = true}\n                }\n                emit(1)\n            }\n        }.filter {\n            latch.receive()\n            throw TestException()\n        }.catch { emit(42) }\n\n        assertEquals(42, flow.single())\n        assertTrue(cancelled)\n    }\n\n\n    @Test\n    fun testFilterNot() = runTest {\n        val flow = flowOf(1, 2)\n        assertEquals(0, flow.filterNot { true }.sum())\n        assertEquals(3, flow.filterNot { false }.sum())\n    }\n\n    @Test\n    fun testEmptyFlowFilterNot() = runTest {\n        val sum = emptyFlow<Int>().filterNot { true }.sum()\n        assertEquals(0, sum)\n    }\n\n    @Test\n    fun testErrorCancelsUpstreamwFilterNot() = runTest {\n        var cancelled = false\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang {cancelled = true}\n                }\n                emit(1)\n            }\n        }.filterNot {\n            latch.receive()\n            throw TestException()\n        }.catch { emit(42) }\n\n        assertEquals(42, flow.single())\n        assertTrue(cancelled)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FilterTrivialTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass FilterTrivialTest : TestBase() {\n\n    @Test\n    fun testFilterNotNull() = runTest {\n        val flow = flowOf(1, 2, null)\n        assertEquals(3, flow.filterNotNull().sum())\n    }\n\n    @Test\n    fun testEmptyFlowNotNull() = runTest {\n        val sum = emptyFlow<Int?>().filterNotNull().sum()\n        assertEquals(0, sum)\n    }\n\n    @Test\n    fun testFilterIsInstance() = runTest {\n        val flow = flowOf(\"value\", 2.0)\n        assertEquals(2.0, flow.filterIsInstance<Double>().single())\n        assertEquals(\"value\", flow.filterIsInstance<String>().single())\n    }\n\n    @Test\n    fun testParametrizedFilterIsInstance() = runTest {\n        val flow = flowOf(\"value\", 2.0)\n        assertEquals(2.0, flow.filterIsInstance(Double::class).single())\n        assertEquals(\"value\", flow.filterIsInstance(String::class).single())\n    }\n\n    @Test\n    fun testSubtypesFilterIsInstance() = runTest {\n        open class Super\n        class Sub : Super()\n\n        val flow = flowOf(Super(), Super(), Super(), Sub(), Sub(), Sub())\n        assertEquals(6, flow.filterIsInstance<Super>().count())\n        assertEquals(3, flow.filterIsInstance<Sub>().count())\n    }\n\n    @Test\n    fun testSubtypesParametrizedFilterIsInstance() = runTest {\n        open class Super\n        class Sub : Super()\n\n        val flow = flowOf(Super(), Super(), Super(), Sub(), Sub(), Sub())\n        assertEquals(6, flow.filterIsInstance(Super::class).count())\n        assertEquals(3, flow.filterIsInstance(Sub::class).count())\n    }\n\n    @Test\n    fun testFilterIsInstanceNullable() = runTest {\n        val flow = flowOf(1, 2, null)\n        assertEquals(2, flow.filterIsInstance<Int>().count())\n        assertEquals(3, flow.filterIsInstance<Int?>().count())\n    }\n\n    @Test\n    fun testEmptyFlowIsInstance() = runTest {\n        val sum = emptyFlow<Int>().filterIsInstance<Int>().sum()\n        assertEquals(0, sum)\n    }\n\n    @Test\n    fun testEmptyFlowParametrizedIsInstance() = runTest {\n        val sum = emptyFlow<Int>().filterIsInstance(Int::class).sum()\n        assertEquals(0, sum)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlatMapBaseTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nabstract class FlatMapBaseTest : TestBase() {\n\n    abstract fun <T> Flow<T>.flatMap(mapper: suspend (T) -> Flow<T>): Flow<T>\n\n    @Test\n    fun testFlatMap() = runTest {\n        val n = 100\n        val sum = (1..100).asFlow()\n            .flatMap { value ->\n                // 1 + (1 + 2) + (1 + 2 + 3) + ... (1 + .. + n)\n                flow {\n                    repeat(value) {\n                        emit(it + 1)\n                    }\n                }\n            }.sum()\n\n        assertEquals(n * (n + 1) * (n + 2) / 6, sum)\n    }\n\n    @Test\n    fun testSingle() = runTest {\n        val flow = flow {\n            repeat(100) {\n                emit(it)\n            }\n        }.flatMap { value ->\n            if (value == 99) flowOf(42)\n            else flowOf()\n        }\n\n        val value = flow.single()\n        assertEquals(42, value)\n    }\n\n    @Test\n    fun testNulls() = runTest {\n        val list = flowOf(1, null, 2).flatMap {\n            flowOf(1, null, null, 2)\n        }.toList()\n\n        assertEquals(List(3) { listOf(1, null, null, 2)}.flatten(), list)\n    }\n\n    @Test\n    fun testContext() = runTest {\n        val captured = ArrayList<String>()\n        val flow = flowOf(1)\n            .flowOn(NamedDispatchers(\"irrelevant\"))\n            .flatMap {\n                captured += NamedDispatchers.name()\n                flow {\n                    captured += NamedDispatchers.name()\n                    emit(it)\n                }\n            }\n\n        flow.flowOn(NamedDispatchers(\"1\")).sum()\n        flow.flowOn(NamedDispatchers(\"2\")).sum()\n        assertEquals(listOf(\"1\", \"1\", \"2\", \"2\"), captured)\n    }\n\n    @Test\n    fun testIsolatedContext() = runTest {\n        val flow = flowOf(1)\n            .flowOn(NamedDispatchers(\"irrelevant\"))\n            .flatMap {\n                    flow {\n                        assertEquals(\"inner\", NamedDispatchers.name())\n                        emit(it)\n                    }\n            }.flowOn(NamedDispatchers(\"inner\"))\n            .flatMap {\n                flow {\n                    assertEquals(\"outer\", NamedDispatchers.name())\n                    emit(it)\n                }\n            }.flowOn(NamedDispatchers(\"outer\"))\n\n        assertEquals(1, flow.singleOrNull())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlatMapConcatTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass FlatMapConcatTest : FlatMapBaseTest() {\n\n    override fun <T> Flow<T>.flatMap(mapper: suspend (T) -> Flow<T>): Flow<T> = flatMapConcat(transform = mapper)\n\n    @Test\n    fun testFlatMapConcurrency() = runTest {\n        var concurrentRequests = 0\n        val flow = (1..100).asFlow().flatMapConcat { value ->\n            flow {\n                ++concurrentRequests\n                emit(value)\n                delay(Long.MAX_VALUE)\n            }\n        }\n\n        val consumer = launch {\n            flow.collect { value ->\n                expect(value)\n            }\n        }\n\n        repeat(4) {\n            yield()\n        }\n\n        assertEquals(1, concurrentRequests)\n        consumer.cancelAndJoin()\n        finish(2)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlatMapLatestTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass FlatMapLatestTest : TestBase() {\n\n    @Test\n    fun testFlatMapLatest() = runTest {\n        val flow = flowOf(1, 2, 3).flatMapLatest { value ->\n            flowOf(value, value + 1)\n        }\n        assertEquals(listOf(1, 2, 2, 3, 3, 4), flow.toList())\n    }\n\n    @Test\n    fun testEmission() = runTest {\n        val list = flow {\n            repeat(5) {\n                emit(it)\n            }\n        }.flatMapLatest { flowOf(it) }.toList()\n        assertEquals(listOf(0, 1, 2, 3, 4), list)\n    }\n\n    @Test\n    fun testSwitchIntuitiveBehaviour() = runTest {\n        val flow = flowOf(1, 2, 3, 4, 5)\n        flow.flatMapLatest {\n            flow {\n                expect(it)\n                emit(it)\n                yield() // Explicit cancellation check\n                if (it != 5) expectUnreached()\n                else expect(6)\n            }\n        }.collect()\n        finish(7)\n    }\n\n    @Test\n    fun testSwitchRendevouzBuffer() = runTest {\n        val flow = flowOf(1, 2, 3, 4, 5)\n        flow.flatMapLatest {\n            flow {\n                emit(it)\n                // Reach here every uneven element because of channel's unfairness\n                expect(it)\n            }\n        }.buffer(0).onEach { expect(it + 1) }\n            .collect()\n        finish(7)\n    }\n\n    @Test\n    fun testHangFlows() = runTest {\n        val flow = listOf(1, 2, 3, 4).asFlow()\n        val result = flow.flatMapLatest { value ->\n            flow {\n                if (value != 4) hang { expect(value) }\n                emit(42)\n            }\n        }.toList()\n\n        assertEquals(listOf(42), result)\n        finish(4)\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        assertNull(emptyFlow<Int>().flatMapLatest { flowOf(1) }.singleOrNull())\n    }\n\n    @Test\n    fun testFailureInTransform() = runTest {\n        val flow = flowOf(1, 2).flatMapLatest { value ->\n            flow {\n                if (value == 1) {\n                    emit(1)\n                    hang { expect(1) }\n                } else {\n                    expect(2)\n                    throw TestException()\n                }\n            }\n        }\n        assertFailsWith<TestException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testFailureDownstream() = runTest {\n        val flow = flowOf(1).flatMapLatest { value ->\n            flow {\n                expect(1)\n                emit(value)\n                expect(2)\n                hang { expect(4) }\n            }\n        }.flowOn(NamedDispatchers(\"downstream\")).onEach {\n            expect(3)\n            throw TestException()\n        }\n        assertFailsWith<TestException>(flow)\n        finish(5)\n    }\n\n    @Test\n    fun testFailureUpstream() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            yield()\n            expect(3)\n            throw TestException()\n        }.flatMapLatest<Int, Long> {\n            flow {\n                expect(2)\n                hang {\n                    expect(4)\n                }\n            }\n        }\n        assertFailsWith<TestException>(flow)\n        finish(5)\n    }\n\n    @Test\n    fun testTake() = runTest {\n        val flow = flowOf(1, 2, 3, 4, 5).flatMapLatest { flowOf(it) }\n        assertEquals(listOf(1), flow.take(1).toList())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlatMapMergeBaseTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\nimport kotlin.test.assertFailsWith\n\nabstract class FlatMapMergeBaseTest : FlatMapBaseTest() {\n    @Test\n    fun testFailureCancellation() = runTest {\n        val flow = flow {\n            expect(2)\n            emit(1)\n            expect(3)\n            emit(2)\n            expect(4)\n        }.flatMap {\n            if (it == 1) flow {\n                hang { expect(6) }\n            } else flow<Int> {\n                expect(5)\n                throw TestException()\n            }\n        }\n\n        expect(1)\n        assertFailsWith<TestException> { flow.singleOrNull() }\n        finish(7)\n    }\n\n    @Test\n    fun testConcurrentFailure() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            expect(2)\n            emit(1)\n            expect(3)\n            emit(2)\n        }.flatMap {\n            if (it == 1) flow<Int> {\n                expect(5)\n                latch.send(Unit)\n                hang {\n                    expect(7)\n                    throw TestException2()\n\n                }\n            } else {\n                expect(4)\n                latch.receive()\n                expect(6)\n                throw TestException()\n            }\n        }\n\n        expect(1)\n        assertFailsWith<TestException>(flow)\n        finish(8)\n    }\n\n    @Test\n    fun testFailureInMapOperationCancellation() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            expect(2)\n            emit(1)\n            expect(3)\n            emit(2)\n            expectUnreached()\n        }.flatMap {\n            if (it == 1) flow {\n                expect(5)\n                latch.send(Unit)\n                hang { expect(7) }\n            } else {\n                expect(4)\n                latch.receive()\n                expect(6)\n                throw TestException()\n            }\n        }\n\n        expect(1)\n        assertFailsWith<TestException> { flow.count() }\n        finish(8)\n    }\n\n    @Test\n    abstract fun testFlatMapConcurrency(): TestResult\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlatMapMergeFastPathTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\nimport kotlin.test.assertFailsWith\n\nclass FlatMapMergeFastPathTest : FlatMapMergeBaseTest() {\n\n    override fun <T> Flow<T>.flatMap(mapper: suspend (T) -> Flow<T>): Flow<T> = flatMapMerge(transform = mapper).buffer(64)\n\n    @Test\n    override fun testFlatMapConcurrency() = runTest {\n        var concurrentRequests = 0\n        val flow = (1..100).asFlow().flatMapMerge(concurrency = 2) { value ->\n            flow {\n                ++concurrentRequests\n                emit(value)\n                delay(Long.MAX_VALUE)\n            }\n        }.buffer(64)\n\n        val consumer = launch {\n            flow.collect { value ->\n                expect(value)\n            }\n        }\n\n        repeat(4) {\n            yield()\n        }\n\n        assertEquals(2, concurrentRequests)\n        consumer.cancelAndJoin()\n        finish(3)\n    }\n\n    @Test\n    fun testCancellationExceptionDownstream() = runTest {\n        val flow = flowOf(1, 2, 3).flatMapMerge {\n            flow {\n                emit(it)\n                throw CancellationException(\"\")\n            }\n        }.buffer(64)\n\n        assertEquals(listOf(1, 2, 3), flow.toList())\n    }\n\n    @Test\n    fun testCancellationExceptionUpstream() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            yield()\n            throw CancellationException(\"\")\n        }.flatMapMerge {\n            flow {\n                expect(3)\n                emit(it)\n                hang { expect(4) }\n            }\n        }.buffer(64)\n\n        assertFailsWith<CancellationException>(flow)\n        finish(5)\n    }\n\n    @Test\n    fun testCancellation() = runTest {\n        val result = flow {\n            emit(1)\n            emit(2)\n            emit(3)\n            emit(4)\n            expectUnreached() // Cancelled by take\n            emit(5)\n        }.flatMapMerge(2) { v -> flow { emit(v) } }\n            .buffer(64)\n            .take(2)\n            .toList()\n        assertEquals(listOf(1, 2), result)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlatMapMergeTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass FlatMapMergeTest : FlatMapMergeBaseTest() {\n\n    override fun <T> Flow<T>.flatMap(mapper: suspend (T) -> Flow<T>): Flow<T> = flatMapMerge(transform = mapper)\n\n    @Test\n    override fun testFlatMapConcurrency() = runTest {\n        var concurrentRequests = 0\n        val flow = (1..100).asFlow().flatMapMerge(concurrency = 2) { value ->\n            flow {\n                ++concurrentRequests\n                emit(value)\n                delay(Long.MAX_VALUE)\n            }\n        }\n\n        val consumer = launch {\n            flow.collect { value ->\n                expect(value)\n            }\n        }\n\n        repeat(4) {\n            yield()\n        }\n\n        assertEquals(2, concurrentRequests)\n        consumer.cancelAndJoin()\n        finish(3)\n    }\n\n    @Test\n    fun testAtomicStart() = runTest {\n        try {\n            coroutineScope {\n                val job = coroutineContext[Job]!!\n                val flow = flow {\n                    expect(3)\n                    emit(1)\n                }\n                    .onCompletion { expect(5) }\n                    .flatMapMerge {\n                        expect(4)\n                        flowOf(it).onCompletion { expectUnreached() } }\n                    .onCompletion { expect(6) }\n\n                launch {\n                    expect(1)\n                    flow.collect()\n                }\n                launch {\n                    expect(2)\n                    yield()\n                    job.cancel()\n                }\n            }\n        } catch (e: CancellationException) {\n            finish(7)\n        }\n    }\n\n    @Test\n    fun testCancellationExceptionDownstream() = runTest {\n        val flow = flowOf(1, 2, 3).flatMapMerge {\n            flow {\n                emit(it)\n                throw CancellationException(\"\")\n            }\n        }\n\n        assertEquals(listOf(1, 2, 3), flow.toList())\n    }\n\n    @Test\n    fun testCancellationExceptionUpstream() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            yield()\n            throw CancellationException(\"\")\n        }.flatMapMerge {\n            flow {\n                expect(3)\n                emit(it)\n                hang { expect(4) }\n            }\n        }\n\n        assertFailsWith<CancellationException>(flow)\n        finish(5)\n    }\n\n    @Test\n    fun testCancellation() = runTest {\n        val result = flow {\n            emit(1)\n            emit(2)\n            emit(3)\n            emit(4)\n            expectUnreached() // Cancelled by take\n            emit(5)\n        }.flatMapMerge(2) { v -> flow { emit(v) } }\n            .take(2)\n            .toList()\n        assertEquals(listOf(1, 2), result)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlattenConcatTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass FlattenConcatTest : FlatMapBaseTest() {\n\n    override fun <T> Flow<T>.flatMap(mapper: suspend (T) -> Flow<T>): Flow<T> = map(mapper).flattenConcat()\n\n    @Test\n    fun testFlatMapConcurrency() = runTest {\n        var concurrentRequests = 0\n        val flow = (1..100).asFlow().map { value ->\n            flow {\n                ++concurrentRequests\n                emit(value)\n                delay(Long.MAX_VALUE)\n            }\n        }.flattenConcat()\n\n        val consumer = launch {\n            flow.collect { value ->\n                expect(value)\n            }\n        }\n\n        repeat(4) {\n            yield()\n        }\n\n        assertEquals(1, concurrentRequests)\n        consumer.cancelAndJoin()\n        finish(2)\n    }\n\n    @Test\n    fun testCancellation() = runTest {\n        val flow = flow {\n            repeat(5) {\n                emit(flow {\n                    if (it == 2) throw CancellationException(\"\")\n                    emit(1)\n                })\n            }\n        }\n        assertFailsWith<CancellationException>(flow.flattenConcat())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlattenMergeTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass FlattenMergeTest : FlatMapMergeBaseTest() {\n\n    override fun <T> Flow<T>.flatMap(mapper: suspend (T) -> Flow<T>): Flow<T> = map(mapper).flattenMerge()\n\n    @Test\n    override fun testFlatMapConcurrency() = runTest {\n        var concurrentRequests = 0\n        val flow = (1..100).asFlow().map { value ->\n            flow {\n                ++concurrentRequests\n                emit(value)\n                delay(Long.MAX_VALUE)\n            }\n        }.flattenMerge(concurrency = 2)\n\n        val consumer = launch {\n            flow.collect { value ->\n                expect(value)\n            }\n        }\n\n        repeat(4) {\n            yield()\n        }\n\n        assertEquals(2, concurrentRequests)\n        consumer.cancelAndJoin()\n        finish(3)\n    }\n\n    @Test\n    fun testContextPreservationAcrossFlows() = runTest {\n        val result = flow {\n            flowOf(1, 2).flatMapMerge {\n                flow {\n                    yield()\n                    emit(it)\n                }\n            }.collect {\n                emit(it)\n            }\n        }.toList()\n        assertEquals(listOf(1, 2), result)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlowContextOptimizationsTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\nimport kotlin.coroutines.coroutineContext as currentContext\n\nclass FlowContextOptimizationsTest : TestBase() {\n    @Test\n    fun testBaseline() = runTest {\n        val flowDispatcher = wrapperDispatcher(currentContext)\n        val collectContext = currentContext\n        flow {\n            assertSame(flowDispatcher, currentContext[ContinuationInterceptor] as CoroutineContext)\n            expect(1)\n            emit(1)\n            expect(2)\n            emit(2)\n            expect(3)\n        }\n            .flowOn(flowDispatcher)\n            .collect { value ->\n                assertEquals(collectContext.minusKey(Job), currentContext.minusKey(Job))\n                if (value == 1) expect(4)\n                else expect(5)\n            }\n\n        finish(6)\n    }\n\n    @Test\n    fun testFusedSameContext() = runTest {\n        flow {\n            expect(1)\n            emit(1)\n            expect(3)\n            emit(2)\n            expect(5)\n        }\n            .flowOn(currentContext.minusKey(Job))\n            .collect { value ->\n                if (value == 1) expect(2)\n                else expect(4)\n            }\n        finish(6)\n    }\n\n    @Test\n    fun testFusedSameContextWithIntermediateOperators() = runTest {\n        flow {\n            expect(1)\n            emit(1)\n            expect(3)\n            emit(2)\n            expect(5)\n        }\n            .flowOn(currentContext.minusKey(Job))\n            .map { it }\n            .flowOn(currentContext.minusKey(Job))\n            .collect { value ->\n                if (value == 1) expect(2)\n                else expect(4)\n            }\n        finish(6)\n    }\n\n    @Test\n    fun testFusedSameDispatcher() = runTest {\n        flow {\n            assertEquals(\"Name\", currentContext[CoroutineName]?.name)\n            expect(1)\n            emit(1)\n            expect(3)\n            emit(2)\n            expect(5)\n        }\n            .flowOn(CoroutineName(\"Name\"))\n            .collect { value ->\n                assertNull(currentContext[CoroutineName]?.name)\n                if (value == 1) expect(2)\n                else expect(4)\n            }\n        finish(6)\n    }\n\n    @Test\n    fun testFusedManySameDispatcher() = runTest {\n        flow {\n            assertEquals(\"Name1\", currentContext[CoroutineName]?.name)\n            assertEquals(\"OK\", currentContext[CustomContextElement]?.str)\n            expect(1)\n            emit(1)\n            expect(3)\n            emit(2)\n            expect(5)\n        }\n            .flowOn(CoroutineName(\"Name1\")) // the first one works\n            .flowOn(CoroutineName(\"Name2\"))\n            .flowOn(CoroutineName(\"Name3\") + CustomContextElement(\"OK\")) // but this is not lost\n            .collect { value ->\n                assertNull(currentContext[CoroutineName]?.name)\n                assertNull(currentContext[CustomContextElement]?.str)\n                if (value == 1) expect(2)\n                else expect(4)\n            }\n        finish(6)\n    }\n\n    data class CustomContextElement(val str: String) : AbstractCoroutineContextElement(Key) {\n        companion object Key : CoroutineContext.Key<CustomContextElement>\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/FlowOnTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.testing.flow.*\nimport kotlin.test.*\n\nclass FlowOnTest : TestBase() {\n\n    @Test\n    fun testFlowOn() = runTest {\n        val source = Source(42)\n        val consumer = Consumer(42)\n\n        val flow = source::produce.asFlow()\n        flow.flowOn(NamedDispatchers(\"ctx1\")).launchIn(this) {\n            onEach { consumer.consume(it) }\n        }.join()\n\n        assertEquals(\"ctx1\", source.contextName)\n        assertEquals(\"main\", consumer.contextName)\n\n        flow.flowOn(NamedDispatchers(\"ctx2\")).launchIn(this) {\n            onEach { consumer.consume(it) }\n        }.join()\n\n        assertEquals(\"ctx2\", source.contextName)\n        assertEquals(\"main\", consumer.contextName)\n    }\n\n    @Test\n    fun testFlowOnAndOperators() = runTest {\n        val source = Source(42)\n        val consumer = Consumer(42)\n        val captured = ArrayList<String>()\n        val mapper: suspend (Int) -> Int = {\n            captured += NamedDispatchers.nameOr(\"main\")\n            it\n        }\n\n        val flow = source::produce.asFlow()\n        flow.map(mapper)\n            .flowOn(NamedDispatchers(\"ctx1\"))\n            .map(mapper)\n            .flowOn(NamedDispatchers(\"ctx2\"))\n            .map(mapper)\n            .launchIn(this) {\n                onEach { consumer.consume(it) }\n            }.join()\n\n        assertEquals(listOf(\"ctx1\", \"ctx2\", \"main\"), captured)\n        assertEquals(\"ctx1\", source.contextName)\n        assertEquals(\"main\", consumer.contextName)\n    }\n\n    @Test\n    public fun testFlowOnThrowingSource() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(NamedDispatchers.name())\n            expect(3)\n            throw TestException()\n        }.map {\n            expect(2)\n            assertEquals(\"throwing\", it)\n            it\n        }.flowOn(NamedDispatchers(\"throwing\"))\n\n        assertFailsWith<TestException> { flow.single() }\n        ensureActive()\n        finish(4)\n    }\n\n    @Test\n    public fun testFlowOnThrowingOperator() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(NamedDispatchers.name())\n            expectUnreached()\n        }.map {\n            expect(2)\n            assertEquals(\"throwing\", it)\n            throw TestException()\n        }.flowOn(NamedDispatchers(\"throwing\"))\n\n        assertFailsWith<TestException>(flow)\n        ensureActive()\n        finish(3)\n    }\n\n    @Test\n    public fun testFlowOnDownstreamOperator() = runTest() {\n        val flow = flow {\n            expect(2)\n            emit(NamedDispatchers.name())\n            hang { expect(5) }\n            delay(Long.MAX_VALUE)\n        }.map {\n            expect(3)\n            it\n        }.flowOn(NamedDispatchers(\"throwing\"))\n            .map<String, String> {\n                expect(4);\n                throw TestException()\n            }\n\n        expect(1)\n        assertFailsWith<TestException> { flow.single() }\n        ensureActive()\n        finish(6)\n    }\n\n    @Test\n    public fun testFlowOnThrowingConsumer() = runTest {\n        val flow = flow {\n            expect(2)\n            emit(NamedDispatchers.name())\n            hang { expect(4) }\n        }\n\n        expect(1)\n        flow.flowOn(NamedDispatchers(\"...\")).launchIn(this + NamedDispatchers(\"launch\")) {\n            onEach {\n                expect(3)\n                throw TestException()\n            }\n            catch<Throwable> { expect(5) }\n        }.join()\n\n        ensureActive()\n        finish(6)\n    }\n\n    @Test\n    fun testFlowOnWithJob() = runTest({ it is IllegalArgumentException }) {\n        flow {\n            emit(1)\n        }.flowOn(NamedDispatchers(\"foo\") + Job())\n    }\n\n    @Test\n    fun testFlowOnCancellation() = runTest {\n        val latch = Channel<Unit>()\n        expect(1)\n        val job = launch(NamedDispatchers(\"launch\")) {\n            flow<Int> {\n                expect(2)\n                latch.send(Unit)\n                expect(3)\n                hang {\n                    assertEquals(\"cancelled\", NamedDispatchers.name())\n                    expect(5)\n                }\n            }.flowOn(NamedDispatchers(\"cancelled\")).single()\n        }\n\n        latch.receive()\n        expect(4)\n        job.cancel()\n        job.join()\n        ensureActive()\n        finish(6)\n    }\n\n    @Test\n    fun testFlowOnCancellationHappensBefore() = runTest {\n        launch {\n            try {\n                flow<Int> {\n                    expect(1)\n                    val flowJob = kotlin.coroutines.coroutineContext[Job]!!\n                    launch {\n                        expect(2)\n                        flowJob.cancel()\n                    }\n                    hang { expect(3) }\n                }.flowOn(NamedDispatchers(\"upstream\")).single()\n            } catch (e: CancellationException) {\n                expect(4)\n            }\n        }.join()\n        ensureActive()\n        finish(5)\n    }\n\n    @Test\n    fun testIndependentOperatorContext() = runTest {\n        val value = flow {\n            assertEquals(\"base\", NamedDispatchers.nameOr(\"main\"))\n            expect(1)\n            emit(-239)\n        }.map {\n            assertEquals(\"base\", NamedDispatchers.nameOr(\"main\"))\n            expect(2)\n            it\n        }.flowOn(NamedDispatchers(\"base\"))\n            .map {\n                assertEquals(\"main\", NamedDispatchers.nameOr(\"main\"))\n                expect(3)\n                it\n            }.single()\n\n        assertEquals(-239, value)\n        finish(4)\n    }\n\n    @Test\n    fun testMultipleFlowOn() = runTest {\n        flow {\n            assertEquals(\"ctx1\", NamedDispatchers.nameOr(\"main\"))\n            expect(1)\n            emit(1)\n        }.map {\n            assertEquals(\"ctx1\", NamedDispatchers.nameOr(\"main\"))\n            expect(2)\n        }.flowOn(NamedDispatchers(\"ctx1\"))\n            .map {\n                assertEquals(\"ctx2\", NamedDispatchers.nameOr(\"main\"))\n                expect(3)\n            }.flowOn(NamedDispatchers(\"ctx2\"))\n            .map {\n                assertEquals(\"ctx3\", NamedDispatchers.nameOr(\"main\"))\n                expect(4)\n            }.flowOn(NamedDispatchers(\"ctx3\"))\n            .map {\n                assertEquals(\"main\", NamedDispatchers.nameOr(\"main\"))\n                expect(5)\n            }\n            .single()\n\n        finish(6)\n    }\n\n    @Test\n    fun testTimeoutExceptionUpstream() = runTest {\n        val flow = flow {\n            emit(1)\n            yield()\n            withTimeout(-1) {}\n            emit(42)\n        }.flowOn(NamedDispatchers(\"foo\")).onEach {\n            expect(1)\n        }\n        assertFailsWith<TimeoutCancellationException>(flow)\n        finish(2)\n    }\n\n    @Test\n    fun testTimeoutExceptionDownstream() = runTest {\n        val flow = flow {\n            emit(1)\n            hang { expect(2) }\n        }.flowOn(NamedDispatchers(\"foo\")).onEach {\n            expect(1)\n            withTimeout(-1) {}\n        }\n        assertFailsWith<TimeoutCancellationException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testCancellation() = runTest {\n        val result = flow {\n            emit(1)\n            emit(2)\n            emit(3)\n            expectUnreached()\n            emit(4)\n        }.flowOn(wrapperDispatcher())\n            .buffer(0)\n            .take(2)\n            .toList()\n        assertEquals(listOf(1, 2), result)\n    }\n\n    @Test\n    fun testAtomicStart() = runTest {\n        try {\n            coroutineScope {\n                val job = coroutineContext[Job]!!\n                val flow = flow {\n                    expect(3)\n                    emit(1)\n                }\n                    .onCompletion { expect(4) }\n                    .flowOn(wrapperDispatcher())\n                    .onCompletion { expect(5) }\n\n                launch {\n                    expect(1)\n                    flow.collect()\n                }\n                launch {\n                    expect(2)\n                    job.cancel()\n                }\n            }\n        } catch (e: CancellationException) {\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testException() = runTest {\n        val flow = flow {\n            emit(314)\n            delay(Long.MAX_VALUE)\n        }.flowOn(NamedDispatchers(\"upstream\"))\n            .map {\n                throw TestException()\n            }\n\n        assertFailsWith<TestException> { flow.single() }\n        assertFailsWith<TestException>(flow)\n        ensureActive()\n    }\n\n    @Test\n    fun testIllegalArgumentException() {\n        val flow = emptyFlow<Int>()\n        assertFailsWith<IllegalArgumentException> { flow.flowOn(Job()) }\n    }\n\n    private inner class Source(private val value: Int) {\n        public var contextName: String = \"unknown\"\n\n        fun produce(): Int {\n            contextName = NamedDispatchers.nameOr(\"main\")\n            return value\n        }\n    }\n\n    private inner class Consumer(private val expected: Int) {\n        public var contextName: String = \"unknown\"\n\n        fun consume(value: Int) {\n            contextName = NamedDispatchers.nameOr(\"main\")\n            assertEquals(expected, value)\n        }\n    }\n\n    @Test\n    fun testCancelledFlowOn() = runTest {\n        assertFailsWith<CancellationException> {\n            coroutineScope {\n                val scope = this\n                flow {\n                    emit(Unit) // emit to buffer\n                    scope.cancel() // now cancel outer scope\n                }.flowOn(wrapperDispatcher()).collect {\n                    // should not be reached, because cancelled before it runs\n                    expectUnreached()\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/IndexedTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass IndexedTest : TestBase() {\n\n    @Test\n    fun testWithIndex() = runTest {\n        val flow = flowOf(3, 2, 1).withIndex()\n        assertEquals(listOf(IndexedValue(0, 3), IndexedValue(1, 2), IndexedValue(2, 1)), flow.toList())\n    }\n\n    @Test\n    fun testWithIndexEmpty() = runTest {\n        val flow = emptyFlow<Int>().withIndex()\n        assertEquals(emptyList(), flow.toList())\n    }\n\n    @Test\n    fun testCollectIndexed() = runTest {\n        val result = ArrayList<IndexedValue<Long>>()\n        flowOf(3L, 2L, 1L).collectIndexed { index, value ->\n            result.add(IndexedValue(index, value))\n        }\n        assertEquals(listOf(IndexedValue(0, 3L), IndexedValue(1, 2L), IndexedValue(2, 1L)), result)\n    }\n\n    @Test\n    fun testCollectIndexedEmptyFlow() = runTest {\n        val flow = flow<Int> {\n            expect(1)\n        }\n\n        flow.collectIndexed { _, _ ->\n            expectUnreached()\n        }\n\n        finish(2)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/LintTest.kt",
        "content": "package kotlinx.coroutines.flow.operators\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\n\nclass LintTest: TestBase() {\n    /**\n     * Tests that using [SharedFlow.toList] and similar functions by passing a mutable collection does add values\n     * to the provided collection.\n     */\n    @Test\n    fun testSharedFlowToCollection() = runTest {\n        val sharedFlow = MutableSharedFlow<Int>()\n        val list = mutableListOf<Int>()\n        val set = mutableSetOf<Int>()\n        val jobs = listOf(suspend { sharedFlow.toList(list) }, { sharedFlow.toSet(set) }).map {\n            launch(Dispatchers.Unconfined) { it() }\n        }\n        repeat(10) {\n            sharedFlow.emit(it)\n        }\n        jobs.forEach { it.cancelAndJoin() }\n        assertEquals((0..9).toList(), list)\n        assertEquals((0..9).toSet(), set)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/MapNotNullTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass MapNotNullTest : TestBase() {\n    @Test\n    fun testMap() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(null)\n            emit(2)\n        }\n\n        val result = flow.mapNotNull { it }.sum()\n        assertEquals(3, result)\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        val sum = emptyFlow<Int>().mapNotNull { expectUnreached(); it }.sum()\n        assertEquals(0, sum)\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        var cancelled = false\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang { cancelled = true }\n                }\n                emit(1)\n            }\n        }.mapNotNull<Int, Int> {\n            latch.receive()\n            throw TestException()\n        }.catch { emit(42) }\n\n        assertEquals(42, flow.single())\n        assertTrue(cancelled)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/MapTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass MapTest : TestBase() {\n    @Test\n    fun testMap() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(2)\n        }\n\n        val result = flow.map { it + 1 }.sum()\n        assertEquals(5, result)\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        val sum = emptyFlow<Int>().map { expectUnreached(); it }.sum()\n        assertEquals(0, sum)\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        var cancelled = false\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang { cancelled = true }\n                }\n                emit(1)\n                expectUnreached()\n            }\n        }.map<Int, Int> {\n            latch.receive()\n            throw TestException()\n        }.catch { emit(42) }\n\n        assertEquals(42, flow.single())\n        assertTrue(cancelled)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/MergeTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\nimport kotlinx.coroutines.flow.merge as originalMerge\n\nabstract class MergeTest : TestBase() {\n\n    abstract fun <T> Iterable<Flow<T>>.merge(): Flow<T>\n\n    @Test\n    fun testMerge() = runTest {\n        val n = 100\n        val sum = (1..n).map { flowOf(it) }\n            .merge()\n            .sum()\n\n        assertEquals(n * (n + 1) / 2, sum)\n    }\n\n    @Test\n    fun testSingle() = runTest {\n        val flow = listOf(flowOf(), flowOf(42), flowOf()).merge()\n        val value = flow.single()\n        assertEquals(42, value)\n    }\n\n    @Test\n    fun testNulls() = runTest {\n        val list = listOf(flowOf(1), flowOf(null), flowOf(2)).merge().toList()\n        assertEquals(listOf(1, null, 2), list)\n    }\n\n    @Test\n    fun testContext() = runTest {\n        val flow = flow {\n            emit(NamedDispatchers.name())\n        }.flowOn(NamedDispatchers(\"source\"))\n\n        val result = listOf(flow).merge().flowOn(NamedDispatchers(\"irrelevant\")).toList()\n        assertEquals(listOf(\"source\"), result)\n    }\n\n    @Test\n    fun testOneSourceCancelled() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            yield()\n            throw CancellationException(\"\")\n        }\n\n        val otherFlow = flow {\n            repeat(5) {\n                emit(1)\n                yield()\n            }\n\n            expect(3)\n        }\n\n        val result = listOf(flow, otherFlow).merge().toList()\n        assertEquals(MutableList(6) { 1 }, result)\n        finish(4)\n    }\n\n    @Test\n    fun testOneSourceCancelledNonFused() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            yield()\n            throw CancellationException(\"\")\n        }\n\n        val otherFlow = flow {\n            repeat(5) {\n                emit(1)\n                yield()\n            }\n\n            expect(3)\n        }\n\n        val result = listOf(flow, otherFlow).nonFuseableMerge().toList()\n        assertEquals(MutableList(6) { 1 }, result)\n        finish(4)\n    }\n\n    private fun <T> Iterable<Flow<T>>.nonFuseableMerge(): Flow<T> {\n        return channelFlow {\n            forEach { flow ->\n                launch {\n                    flow.collect { send(it) }\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testIsolatedContext() = runTest {\n        val flow = flow {\n            emit(NamedDispatchers.name())\n        }\n\n        val result = listOf(flow.flowOn(NamedDispatchers(\"1\")), flow.flowOn(NamedDispatchers(\"2\")))\n            .merge()\n            .flowOn(NamedDispatchers(\"irrelevant\"))\n            .toList()\n        assertEquals(listOf(\"1\", \"2\"), result)\n    }\n}\n\nclass IterableMergeTest : MergeTest() {\n    override fun <T> Iterable<Flow<T>>.merge(): Flow<T> = originalMerge()\n}\n\nclass VarargMergeTest : MergeTest() {\n    override fun <T> Iterable<Flow<T>>.merge(): Flow<T> = originalMerge(*toList().toTypedArray())\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/OnCompletionTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.test.*\n\nclass OnCompletionTest : TestBase() {\n\n    @Test\n    fun testOnCompletion() = runTest {\n        flow {\n            expect(1)\n            emit(2)\n            expect(4)\n        }.onEach {\n            expect(2)\n        }.onCompletion {\n            assertNull(it)\n            expect(5)\n        }.onEach {\n            expect(3)\n        }.collect()\n        finish(6)\n    }\n\n    @Test\n    fun testOnCompletionWithException() = runTest {\n        flowOf(1).onEach {\n            expect(1)\n            throw TestException()\n        }.onCompletion {\n            assertIs<TestException>(it)\n            expect(2)\n        }.catch {\n            assertIs<TestException>(it)\n            expect(3)\n        }.collect()\n        finish(4)\n    }\n\n    @Test\n    fun testOnCompletionWithExceptionDownstream() = runTest {\n        flow {\n            expect(1)\n            emit(2)\n        }.onEach {\n            expect(2)\n        }.onCompletion {\n            assertIs<TestException>(it) // flow fails because of this exception\n            expect(4)\n        }.onEach {\n            expect(3)\n            throw TestException()\n        }.catch {\n            assertIs<TestException>(it)\n            expect(5)\n        }.collect()\n        finish(6)\n    }\n\n    @Test\n    fun testMultipleOnCompletions() = runTest {\n        flowOf(1).onCompletion {\n            assertIs<TestException>(it)\n            expect(2)\n        }.onEach {\n            expect(1)\n            throw TestException()\n        }.onCompletion {\n            assertIs<TestException>(it)\n            expect(3)\n        }.catch {\n            assertIs<TestException>(it)\n            expect(4)\n        }.collect()\n        finish(5)\n    }\n\n    @Test\n    fun testExceptionFromOnCompletion() = runTest {\n        flowOf(1).onEach {\n            expect(1)\n            throw TestException()\n        }.onCompletion {\n            expect(2)\n            throw TestException2()\n        }.catch {\n            assertIs<TestException2>(it)\n            expect(3)\n        }.collect()\n        finish(4)\n    }\n\n    @Test\n    fun testContextPreservation() = runTest {\n        flowOf(1).onCompletion {\n            assertEquals(\"OK\", NamedDispatchers.name())\n            assertNull(it)\n            expect(1)\n        }.flowOn(NamedDispatchers(\"OK\"))\n            .onEach {\n                expect(2)\n                assertEquals(\"default\", NamedDispatchers.nameOr(\"default\"))\n                throw TestException()\n            }\n            .catch {\n                assertIs<TestException>(it)\n                expect(3)\n            }.collect()\n        finish(4)\n    }\n\n    @Test\n    fun testEmitExample() = runTest {\n        val flow = flowOf(\"a\", \"b\", \"c\")\n            .onCompletion() { emit(\"Done\") }\n        assertEquals(listOf(\"a\", \"b\", \"c\", \"Done\"), flow.toList())\n    }\n\n    sealed class TestData {\n        data class Value(val i: Int) : TestData()\n        data class Done(val e: Throwable?) : TestData() {\n            override fun equals(other: Any?): Boolean =\n                other is Done && other.e?.message == e?.message\n        }\n    }\n\n    @Test\n    fun testCrashedEmit() = runTest {\n        expect(1)\n        val collected = ArrayList<TestData>()\n        assertFailsWith<TestException> {\n            (1..10).asFlow()\n                .map<Int, TestData> { TestData.Value(it) }\n                .onEach { value ->\n                    value as TestData.Value\n                    expect(value.i + 1)\n                    if (value.i == 6) throw TestException(\"OK\")\n                    yield()\n                }\n                .onCompletion { e ->\n                    expect(8)\n                    assertIs<TestException>(e)\n                    emit(TestData.Done(e)) // will fail\n                }.collect {\n                    collected += it\n                }\n        }\n        val expected: List<TestData> = (1..5).map { TestData.Value(it) }\n        assertEquals(expected, collected)\n        finish(9)\n    }\n\n    @Test\n    fun testCancelledEmit() = runTest {\n        expect(1)\n        val collected = ArrayList<TestData>()\n        assertFailsWith<JobCancellationException> {\n            coroutineScope {\n                (1..10).asFlow()\n                    .map<Int, TestData> { TestData.Value(it) }\n                    .onEach { value ->\n                        value as TestData.Value\n                        expect(value.i + 1)\n                        if (value.i == 6) coroutineContext.cancel()\n                        yield()\n                    }\n                    .onCompletion { e ->\n                        expect(8)\n                        assertIs<CancellationException>(e)\n                        try {\n                            emit(TestData.Done(e))\n                            expectUnreached()\n                        } finally {\n                            expect(9)\n                        }\n                    }.collect {\n                        collected += it\n                    }\n            }\n        }\n        val expected = (1..5).map<Int, TestData> { TestData.Value(it) }\n        assertEquals(expected, collected)\n        finish(10)\n    }\n\n    @Test\n    fun testFailedEmit() = runTest {\n        val cause = TestException()\n        assertFailsWith<TestException> {\n            flow<TestData> {\n                expect(1)\n                emit(TestData.Value(2))\n                expectUnreached()\n            }.onCompletion {\n                assertSame(cause, it) // flow failed because of the exception in downstream\n                expect(3)\n                try {\n                    emit(TestData.Done(it))\n                    expectUnreached()\n                } catch (e: TestException) {\n                    assertSame(cause, e)\n                    finish(4)\n                }\n            }.collect {\n                expect((it as TestData.Value).i)\n                throw cause\n            }\n        }\n    }\n\n    @Test\n    fun testFirst() = runTest {\n        val value = flowOf(239).onCompletion {\n            assertNotNull(it) // the flow did not complete normally\n            expect(1)\n            try {\n                emit(42)\n                expectUnreached()\n            } catch (e: Throwable) {\n                assertTrue { e is AbortFlowException }\n            }\n        }.first()\n        assertEquals(239, value)\n        finish(2)\n    }\n\n    @Test\n    fun testSingle() = runTest {\n        assertFailsWith<IllegalArgumentException> {\n            flowOf(239).onCompletion {\n                assertNull(it)\n                expect(1)\n                try {\n                    emit(42)\n                    expectUnreached()\n                } catch (e: Throwable) {\n                    // Second emit -- failure\n                    assertTrue { e is IllegalArgumentException }\n                    throw e\n                }\n            }.single()\n            expectUnreached()\n        }\n        finish(2)\n    }\n\n    @Test\n    fun testEmptySingleInterference() = runTest {\n        val value = emptyFlow<Int>().onCompletion {\n            assertNull(it)\n            expect(1)\n            emit(42)\n        }.single()\n        assertEquals(42, value)\n        finish(2)\n    }\n\n    @Test\n    fun testTransparencyViolation() = runTest {\n        val flow = emptyFlow<Int>().onCompletion {\n            expect(2)\n            coroutineScope {\n                launch {\n                    try {\n                        emit(1)\n                    } catch (e: IllegalStateException) {\n                        expect(3)\n                    }\n                }\n            }\n        }\n        expect(1)\n        assertNull(flow.singleOrNull())\n        finish(4)\n    }\n\n    @Test\n    fun testTakeOnCompletion() = runTest {\n        // even though it uses \"take\" from the outside it completes normally\n        val flow = (1..10).asFlow().take(5)\n        val result = flow.onCompletion { cause ->\n            assertNull(cause)\n            emit(-1)\n        }.toList()\n        val expected = (1..5).toList() + (-1)\n        assertEquals(expected, result)\n    }\n\n    @Test\n    fun testCancelledEmitAllFlow() = runTest {\n        // emitAll does not call 'collect' on onCompletion collector\n        // if the target flow is empty\n        flowOf(1, 2, 3)\n            .onCompletion { emitAll(MutableSharedFlow()) }\n            .take(1)\n            .collect()\n    }\n\n    @Test\n    fun testCancelledEmitAllChannel() = runTest {\n        // emitAll does not call 'collect' on onCompletion collector\n        // if the target channel is empty\n        flowOf(1, 2, 3)\n            .onCompletion { emitAll(Channel()) }\n            .take(1)\n            .collect()\n    }\n\n    /**\n     * Tests that the operators that are used to limit the flow (like [take] and [zip]) faithfully propagate the\n     * cancellation exception to the original owner.\n     */\n    @Test\n    fun testOnCompletionBetweenLimitingOperators() = runTest {\n        // `zip` doesn't eat the exception thrown by `take`:\n        flowOf(1, 2, 3)\n            .zip(flowOf(4, 5)) { a, b -> a + b }\n            .onCompletion {\n                expect(2)\n                assertNotNull(it)\n            }\n            .take(1)\n            .collect {\n                expect(1)\n            }\n\n        // `take` doesn't eat the exception thrown by `zip`:\n        flowOf(1, 2, 3)\n            .take(2)\n            .onCompletion {\n                expect(4)\n                assertNotNull(it)\n            }\n            .zip(flowOf(4)) { a, b -> a + b }\n            .collect {\n                expect(3)\n            }\n\n        // `take` doesn't eat the exception thrown by `first`:\n        flowOf(1, 2, 3)\n            .take(2)\n            .onCompletion {\n                expect(5)\n                assertNotNull(it)\n            }\n            .first()\n\n        // `zip` doesn't eat the exception thrown by `first`:\n        flowOf(1, 2, 3)\n            .zip(flowOf(4, 5)) { a, b -> a + b }\n            .onCompletion {\n                expect(6)\n                assertNotNull(it)\n            }\n            .first()\n\n        // `take` doesn't eat the exception thrown by another `take`:\n        flowOf(1, 2, 3)\n            .take(2)\n            .onCompletion {\n                expect(8)\n                assertNotNull(it)\n            }\n            .take(1)\n            .collect {\n                expect(7)\n            }\n\n        // `zip` doesn't eat the exception thrown by another `zip`:\n        flowOf(1, 2, 3)\n            .zip(flowOf(4, 5)) { a, b -> a + b }\n            .onCompletion {\n                expect(10)\n                assertNotNull(it)\n            }\n            .zip(flowOf(6)) { a, b -> a + b }\n            .collect {\n                expect(9)\n            }\n\n        finish(11)\n    }\n\n    /**\n     * Tests that emitting new elements after completion doesn't overwrite the old elements.\n     */\n    @Test\n    fun testEmittingElementsAfterCancellation() = runTest {\n        assertEquals(1, flowOf(1, 2, 3)\n            .take(100)\n            .onCompletion { emit(4) }\n            .first())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/OnEachTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass OnEachTest : TestBase() {\n    @Test\n    fun testOnEach() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(2)\n        }\n\n        val result = flow.onEach { expect(it) }.sum()\n        assertEquals(3, result)\n        finish(3)\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        val value = emptyFlow<Int>().onEach { fail() }.singleOrNull()\n        assertNull(value)\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        var cancelled = false\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang { cancelled = true }\n                }\n                emit(1)\n            }\n        }.onEach {\n            latch.receive()\n            throw TestException()\n        }.catch { emit(42) }\n\n        assertEquals(42, flow.single())\n        assertTrue(cancelled)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/OnEmptyTest.kt",
        "content": "package kotlinx.coroutines.flow.operators\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\n\nclass OnEmptyTest : TestBase() {\n\n    @Test\n    fun testOnEmptyInvoked() = runTest {\n        val flow = emptyFlow<Int>().onEmpty { emit(1) }\n        assertEquals(1, flow.single())\n    }\n\n    @Test\n    fun testOnEmptyNotInvoked() = runTest {\n        val flow = flowOf(1).onEmpty { emit(2) }\n        assertEquals(1, flow.single())\n    }\n\n    @Test\n    fun testOnEmptyNotInvokedOnError() = runTest {\n        val flow = flow<Int> {\n            throw TestException()\n        }.onEmpty { expectUnreached() }\n        assertFailsWith<TestException>(flow)\n    }\n\n    @Test\n    fun testOnEmptyNotInvokedOnCancellation() = runTest {\n        val flow = flow<Int> {\n            expect(2)\n            hang { expect(4) }\n        }.onEmpty { expectUnreached() }\n\n        expect(1)\n        val job = flow.onEach { expectUnreached() }.launchIn(this)\n        yield()\n        expect(3)\n        job.cancelAndJoin()\n        finish(5)\n    }\n\n    @Test\n    fun testOnEmptyCancellation() = runTest {\n        val flow = emptyFlow<Int>().onEmpty {\n            expect(2)\n            hang { expect(4) }\n            emit(1)\n        }\n        expect(1)\n        val job = flow.onEach { expectUnreached() }.launchIn(this)\n        yield()\n        expect(3)\n        job.cancelAndJoin()\n        finish(5)\n    }\n\n    @Test\n    fun testTransparencyViolation() = runTest {\n        val flow = emptyFlow<Int>().onEmpty {\n            expect(2)\n            coroutineScope {\n                launch {\n                    try {\n                        emit(1)\n                    } catch (e: IllegalStateException) {\n                        expect(3)\n                    }\n                }\n            }\n        }\n        expect(1)\n        assertNull(flow.singleOrNull())\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/OnStartTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass OnStartTest : TestBase() {\n    @Test\n    fun testEmitExample() = runTest {\n        val flow = flowOf(\"a\", \"b\", \"c\")\n            .onStart { emit(\"Begin\") }\n        assertEquals(listOf(\"Begin\", \"a\", \"b\", \"c\"), flow.toList())\n    }\n\n    @Test\n    fun testTransparencyViolation() = runTest {\n        val flow = emptyFlow<Int>().onStart {\n            expect(2)\n            coroutineScope {\n                launch {\n                    try {\n                        emit(1)\n                    } catch (e: IllegalStateException) {\n                        expect(3)\n                    }\n                }\n            }\n        }\n        expect(1)\n        assertNull(flow.singleOrNull())\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/RetryTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass RetryTest : TestBase() {\n    @Test\n    fun testRetryWhen() = runTest {\n        expect(1)\n        val flow = flow {\n            emit(1)\n            throw TestException()\n        }\n        val sum = flow.retryWhen { cause, attempt ->\n            assertIs<TestException>(cause)\n            expect(2 + attempt.toInt())\n            attempt < 3\n        }.catch { cause ->\n            expect(6)\n            assertIs<TestException>(cause)\n        }.sum()\n        assertEquals(4, sum)\n        finish(7)\n    }\n\n    @Test\n    fun testRetry() = runTest {\n        var counter = 0\n        val flow = flow {\n            emit(1)\n            if (++counter < 4) throw TestException()\n        }\n\n        assertEquals(4, flow.retry(4).sum())\n        counter = 0\n        assertFailsWith<TestException>(flow)\n        counter = 0\n        assertFailsWith<TestException>(flow.retry(2))\n    }\n\n    @Test\n    fun testRetryPredicate() = runTest {\n        var counter = 0\n        val flow = flow {\n            emit(1);\n            if (++counter == 1) throw TestException()\n        }\n\n        assertEquals(2, flow.retry(1) { it is TestException }.sum())\n        counter = 0\n        assertFailsWith<TestException>(flow.retry(1) { it !is TestException })\n    }\n\n    @Test\n    fun testRetryExceptionFromDownstream() = runTest {\n        var executed = 0\n        val flow = flow {\n            emit(1)\n        }.retry(42).map {\n            ++executed\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        assertEquals(1, executed)\n    }\n\n    @Test\n    fun testWithTimeoutRetried() = runTest {\n        var state = 0\n        val flow = flow {\n            if (state++ == 0) {\n                expect(1)\n                withTimeout(1) {\n                    hang { expect(2) }\n                }\n                expectUnreached()\n            }\n            expect(3)\n            emit(1)\n        }.retry(1)\n\n        assertEquals(1, flow.single())\n        finish(4)\n    }\n\n    @Test\n    fun testCancellationFromUpstreamIsNotRetried() = runTest {\n        val flow = flow<Int> {\n            hang {  }\n        }.retry()\n\n        val job = launch {\n            expect(1)\n            flow.collect {  }\n        }\n\n        yield()\n        expect(2)\n        job.cancelAndJoin()\n        finish(3)\n    }\n\n    @Test\n    fun testUpstreamExceptionConcurrentWithDownstream() = runTest {\n        val flow = flow {\n            try {\n                expect(1)\n                emit(1)\n            } finally {\n                expect(3)\n                throw TestException()\n            }\n        }.retry { expectUnreached(); true }.onEach {\n            expect(2)\n            throw TestException2()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testUpstreamExceptionConcurrentWithDownstreamCancellation() = runTest {\n        val flow = flow {\n            try {\n                expect(1)\n                emit(1)\n            } finally {\n                expect(3)\n                throw TestException()\n            }\n        }.retry { expectUnreached(); true }.onEach {\n            expect(2)\n            throw CancellationException(\"\")\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testUpstreamCancellationIsIgnoredWhenDownstreamFails() = runTest {\n        val flow = flow {\n            try {\n                expect(1)\n                emit(1)\n            } finally {\n                expect(3)\n                throw CancellationException(\"\")\n            }\n        }.retry { expectUnreached(); true }.onEach {\n            expect(2)\n            throw TestException(\"\")\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/SampleTest.kt",
        "content": "package kotlinx.coroutines.flow.operators\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nclass SampleTest : TestBase() {\n    @Test\n    public fun testBasic() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(1500)\n            emit(\"B\")\n            delay(500)\n            emit(\"C\")\n            delay(250)\n            emit(\"D\")\n            delay(2000)\n            emit(\"E\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.sample(1000).toList()\n        assertEquals(listOf(\"A\", \"B\", \"D\"), result)\n        finish(5)\n    }\n\n    @Test\n    fun testDelayedFirst() = withVirtualTime {\n        val flow = flow {\n            delay(60)\n            emit(1)\n            delay(60)\n            expect(1)\n        }.sample(100)\n        assertEquals(1, flow.singleOrNull())\n        finish(2)\n    }\n\n    @Test\n    fun testBasic2() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(1)\n            emit(2)\n            delay(501)\n            emit(3)\n            delay(100)\n            emit(4)\n            delay(100)\n            emit(5)\n            emit(6)\n            delay(301)\n            emit(7)\n            delay(501)\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.sample(500).toList()\n        assertEquals(listOf(2, 6, 7), result)\n        finish(5)\n    }\n\n    @Test\n    fun testFixedDelay() = withVirtualTime {\n        val flow = flow {\n            emit(\"A\")\n            delay(150)\n            emit(\"B\")\n            expect(1)\n        }.sample(100)\n        assertEquals(\"A\", flow.single())\n        finish(2)\n    }\n\n    @Test\n    fun testSingleNull() = withVirtualTime {\n        val flow = flow<Int?> {\n            emit(null)\n            delay(2)\n            expect(1)\n        }.sample(1)\n        assertNull(flow.single())\n        finish(2)\n    }\n\n    @Test\n    fun testBasicWithNulls() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(1500)\n            emit(null)\n            delay(500)\n            emit(\"C\")\n            delay(250)\n            emit(null)\n            delay(2000)\n            emit(\"E\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.sample(1000).toList()\n        assertEquals(listOf(\"A\", null, null), result)\n        finish(5)\n    }\n\n    @Test\n    fun testEmpty() = runTest {\n        val flow = emptyFlow<Int>().sample(Long.MAX_VALUE)\n        assertNull(flow.singleOrNull())\n    }\n\n    @Test\n    fun testScalar() = runTest {\n        val flow = flowOf(1, 2, 3).sample(Long.MAX_VALUE)\n        assertNull(flow.singleOrNull())\n    }\n\n    @Test\n    // note that this test depends on the sampling strategy -- when sampling time starts on a quiescent flow that suddenly emits\n    fun testLongWait() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(2)\n            emit(\"A\")\n            delay(3500) // long delay -- multiple sampling intervals\n            emit(\"B\")\n            delay(900) // crosses time = 4000 barrier\n            emit(\"C\")\n            delay(3000) // long wait again\n\n        }\n        val result = flow.sample(1000).toList()\n        assertEquals(listOf(\"A\", \"B\", \"C\"), result)\n        finish(3)\n    }\n\n    @Test\n    fun testPace() = withVirtualTime {\n        val flow = flow {\n            expect(1)\n            repeat(4) {\n                emit(-it)\n                delay(50)\n            }\n\n            repeat(4) {\n                emit(it)\n                delay(100)\n            }\n            expect(2)\n        }.sample(100)\n\n        assertEquals(listOf(-1, -3, 0, 1, 2, 3), flow.toList())\n        finish(3)\n    }\n\n    @Test\n    fun testUpstreamError() = testUpstreamError(TestException())\n\n    @Test\n    fun testUpstreamErrorCancellationException() = testUpstreamError(CancellationException(\"\"))\n\n    private inline fun <reified T: Throwable> testUpstreamError(cause: T) = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            latch.receive()\n            throw cause\n        }.sample(1).map {\n            latch.send(Unit)\n            hang { expect(3) }\n        }\n\n        assertFailsWith<T>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testUpstreamErrorIsolatedContext() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            assertEquals(\"upstream\", NamedDispatchers.name())\n            expect(1)\n            emit(1)\n            expect(2)\n            latch.receive()\n            throw TestException()\n        }.flowOn(NamedDispatchers(\"upstream\")).sample(1).map {\n            latch.send(Unit)\n            hang { expect(3) }\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testUpstreamErrorSampleNotTriggered() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            throw TestException()\n        }.sample(Long.MAX_VALUE).map {\n            expectUnreached()\n        }\n        assertFailsWith<TestException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testUpstreamErrorSampleNotTriggeredInIsolatedContext() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            throw TestException()\n        }.flowOn(NamedDispatchers(\"unused\")).sample(Long.MAX_VALUE).map {\n            expectUnreached()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testDownstreamError() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            hang { expect(3) }\n        }.sample(100).map {\n            expect(2)\n            yield()\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testDownstreamErrorIsolatedContext() = runTest {\n        val flow = flow {\n            assertEquals(\"upstream\", NamedDispatchers.name())\n            expect(1)\n            emit(1)\n            hang { expect(3) }\n        }.flowOn(NamedDispatchers(\"upstream\")).sample(100).map {\n            expect(2)\n            yield()\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testDurationBasic() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(1500.milliseconds)\n            emit(\"B\")\n            delay(500.milliseconds)\n            emit(\"C\")\n            delay(250.milliseconds)\n            emit(\"D\")\n            delay(2000.milliseconds)\n            emit(\"E\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.sample(1000.milliseconds).toList()\n        assertEquals(listOf(\"A\", \"B\", \"D\"), result)\n        finish(5)\n    }\n\n    @Test\n    fun testFailsWithIllegalArgument() {\n        val flow = emptyFlow<Int>()\n        assertFailsWith<IllegalArgumentException> { flow.debounce(-1) }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/ScanTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass ScanTest : TestBase() {\n    @Test\n    fun testScan() = runTest {\n        val flow = flowOf(1, 2, 3, 4, 5)\n        val result = flow.runningReduce { acc, v -> acc + v }.toList()\n        assertEquals(listOf(1, 3, 6, 10, 15), result)\n    }\n\n    @Test\n    fun testScanWithInitial() = runTest {\n        val flow = flowOf(1, 2, 3)\n        val result = flow.scan(emptyList<Int>()) { acc, value -> acc + value }.toList()\n        assertEquals(listOf(emptyList(), listOf(1), listOf(1, 2), listOf(1, 2, 3)), result)\n    }\n\n    @Test\n    fun testFoldWithInitial() = runTest {\n        val flow = flowOf(1, 2, 3)\n        val result = flow.runningFold(emptyList<Int>()) { acc, value -> acc + value }.toList()\n        assertEquals(listOf(emptyList(), listOf(1), listOf(1, 2), listOf(1, 2, 3)), result)\n    }\n\n    @Test\n    fun testNulls() = runTest {\n        val flow = flowOf(null, 2, null, null, null, 5)\n        val result = flow.runningReduce { acc, v -> if (v == null) acc else (if (acc == null) v else acc + v) }.toList()\n        assertEquals(listOf(null, 2, 2, 2, 2, 7), result)\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        val result = emptyFlow<Int>().runningReduce { _, _ -> 1 }.toList()\n        assertTrue(result.isEmpty())\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        expect(1)\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang { expect(3) }\n                }\n                emit(1)\n                emit(2)\n            }\n        }.runningReduce { _, value ->\n            expect(value) // 2\n            latch.receive()\n            throw TestException()\n        }.catch { /* ignore */ }\n\n        assertEquals(1, flow.single())\n        finish(4)\n    }\n\n    private operator fun <T> Collection<T>.plus(element: T): List<T> {\n        val result = ArrayList<T>(size + 1)\n        result.addAll(this)\n        result.add(element)\n        return result\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/TakeTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass TakeTest : TestBase() {\n    @Test\n    fun testTake() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(2)\n        }\n\n        assertEquals(3, flow.take(2).sum())\n        assertEquals(3, flow.take(Int.MAX_VALUE).sum())\n        assertEquals(1, flow.take(1).single())\n        assertEquals(2, flow.drop(1).take(1).single())\n    }\n\n    @Test\n    fun testIllegalArgument() {\n        assertFailsWith<IllegalArgumentException> { flowOf(1).take(0) }\n        assertFailsWith<IllegalArgumentException> { flowOf(1).take(-1) }\n    }\n\n    @Test\n    fun testTakeSuspending() = runTest {\n        val flow = flow {\n            emit(1)\n            yield()\n            emit(2)\n            yield()\n        }\n\n        assertEquals(3, flow.take(2).sum())\n        assertEquals(3, flow.take(Int.MAX_VALUE).sum())\n        assertEquals(1, flow.take(1).single())\n        assertEquals(2, flow.drop(1).take(1).single())\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        val sum = emptyFlow<Int>().take(10).sum()\n        assertEquals(0, sum)\n    }\n\n    @Test\n    fun testNonPositiveValues() {\n        val flow = flowOf(1)\n        assertFailsWith<IllegalArgumentException> {\n            flow.take(-1)\n        }\n\n        assertFailsWith<IllegalArgumentException> {\n            flow.take(0)\n        }\n    }\n\n    @Test\n    fun testCancelUpstream() = runTest {\n        var cancelled = false\n        val flow = flow {\n            coroutineScope {\n                launch(start = CoroutineStart.ATOMIC) {\n                    hang { cancelled = true }\n                }\n\n                emit(1)\n            }\n        }\n\n        assertEquals(1, flow.take(1).single())\n        assertTrue(cancelled)\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        var cancelled = false\n        val flow = flow {\n            coroutineScope {\n                launch(start = CoroutineStart.ATOMIC) {\n                    hang { cancelled = true }\n                }\n                emit(1)\n            }\n        }.take(2)\n            .map<Int, Int> {\n                throw TestException()\n            }.catch { emit(42) }\n\n        assertEquals(42, flow.single())\n        assertTrue(cancelled)\n    }\n\n    @Test\n    fun takeWithRetries() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            expect(2)\n            emit(2)\n\n            while (true) {\n                emit(42)\n                expectUnreached()\n            }\n\n        }.retry(2) {\n            expectUnreached()\n            true\n        }.take(2)\n\n        val sum = flow.sum()\n        assertEquals(3, sum)\n        finish(3)\n    }\n\n    @Test\n    fun testNonIdempotentRetry() = runTest {\n        var count = 0\n        flow { while (true) emit(1) }\n            .retry { count++ % 2 != 0 }\n            .take(1)\n            .collect {\n                expect(1)\n            }\n        finish(2)\n    }\n\n    @Test\n    fun testNestedTake() = runTest {\n        val inner = flow {\n            emit(1)\n            expectUnreached()\n        }.take(1)\n        val outer = flow {\n            while(true) {\n                emitAll(inner)\n            }\n        }\n        assertEquals(listOf(1, 1, 1), outer.take(3).toList())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/TakeWhileTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass TakeWhileTest : TestBase() {\n\n    @Test\n    fun testTakeWhile() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(2)\n        }\n\n        assertEquals(3, flow.takeWhile { true }.sum())\n        assertEquals(1, flow.takeWhile { it < 2 }.single())\n        assertEquals(2, flow.drop(1).takeWhile { it < 3 }.single())\n        assertNull(flow.drop(1).takeWhile { it < 2 }.singleOrNull())\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        assertEquals(0, emptyFlow<Int>().takeWhile { true }.sum())\n        assertEquals(0, emptyFlow<Int>().takeWhile { false }.sum())\n    }\n\n    @Test\n    fun testCancelUpstream() = runTest {\n        var cancelled = false\n        val flow = flow {\n            coroutineScope {\n                launch(start = CoroutineStart.ATOMIC) {\n                    hang { cancelled = true }\n                }\n\n                emit(1)\n                emit(2)\n            }\n        }\n\n        assertEquals(1, flow.takeWhile { it < 2 }.single())\n        assertTrue(cancelled)\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        var cancelled = false\n        val flow = flow {\n            coroutineScope {\n                launch(start = CoroutineStart.ATOMIC) {\n                    hang { cancelled = true }\n                }\n                emit(1)\n            }\n        }.takeWhile {\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        assertTrue(cancelled)\n        assertEquals(42, flow.catch { emit(42) }.single())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/TimeoutTest.kt",
        "content": "package kotlinx.coroutines.flow.operators\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\nclass TimeoutTest : TestBase() {\n    @Test\n    fun testBasic() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(100)\n            emit(\"B\")\n            delay(100)\n            emit(\"C\")\n            expect(4)\n            delay(400)\n            expectUnreached()\n        }\n\n        expect(2)\n        val list = mutableListOf<String>()\n        assertFailsWith<TimeoutCancellationException>(flow.timeout(300.milliseconds).onEach { list.add(it) })\n        assertEquals(listOf(\"A\", \"B\", \"C\"), list)\n        finish(5)\n    }\n\n    @Test\n    fun testSingleNull() = withVirtualTime {\n        val flow = flow<Int?> {\n            emit(null)\n            delay(1)\n            expect(1)\n        }.timeout(2.milliseconds)\n        assertNull(flow.single())\n        finish(2)\n    }\n\n    @Test\n    fun testBasicCustomAction() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(100)\n            emit(\"B\")\n            delay(100)\n            emit(\"C\")\n            expect(4)\n            delay(400)\n            expectUnreached()\n        }\n\n        expect(2)\n        val list = mutableListOf<String>()\n        flow.timeout(300.milliseconds).catch { if (it is TimeoutCancellationException) emit(\"-1\") }.collect { list.add(it) }\n        assertEquals(listOf(\"A\", \"B\", \"C\", \"-1\"), list)\n        finish(5)\n    }\n\n    @Test\n    fun testDelayedFirst() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            delay(100)\n            emit(1)\n            expect(4)\n        }.timeout(250.milliseconds)\n        expect(2)\n        assertEquals(1, flow.singleOrNull())\n        finish(5)\n    }\n\n    @Test\n    fun testEmpty() = withVirtualTime {\n        val flow = emptyFlow<Any?>().timeout(1.milliseconds)\n        assertNull(flow.singleOrNull())\n        finish(1)\n    }\n\n    @Test\n    fun testScalar() = withVirtualTime {\n        val flow = flowOf(1, 2, 3).timeout(1.milliseconds)\n        assertEquals(listOf(1, 2, 3), flow.toList())\n        finish(1)\n    }\n\n    @Test\n    fun testUpstreamError() = testUpstreamError(TestException())\n\n    @Test\n    fun testUpstreamErrorTimeoutException() =\n        testUpstreamError(TimeoutCancellationException(\"Timed out waiting for ${0} ms\", Job()))\n\n    @Test\n    fun testUpstreamErrorCancellationException() = testUpstreamError(CancellationException(\"\"))\n\n    private inline fun <reified T: Throwable> testUpstreamError(cause: T) = runTest {\n        try {\n            // Workaround for JS legacy bug\n            flow {\n                emit(1)\n                throw cause\n            }.timeout(1000.milliseconds).collect()\n            expectUnreached()\n        } catch (e: Throwable) {\n            assertTrue { e is T }\n            finish(1)\n        }\n    }\n\n    @Test\n    fun testUpstreamExceptionsTakingPriority() = withVirtualTime {\n        val flow = flow<Unit> {\n            expect(2)\n            withContext(NonCancellable) {\n                delay(2.milliseconds)\n            }\n            assertFalse(currentCoroutineContext().isActive) // cancelled already\n            expect(3)\n            throw TestException()\n        }.timeout(1.milliseconds)\n        expect(1)\n        assertFailsWith<TestException> {\n            flow.collect {\n                expectUnreached()\n            }\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testDownstreamError() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            hang { expect(3) }\n            expectUnreached()\n        }.timeout(100.milliseconds).map {\n            expect(2)\n            yield()\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testUpstreamTimeoutIsolatedContext() = withVirtualTime {\n        val flow = flow {\n            assertEquals(\"upstream\", NamedDispatchers.name())\n            expect(1)\n            emit(1)\n            expect(2)\n            delay(300)\n            expectUnreached()\n        }.flowOn(NamedDispatchers(\"upstream\")).timeout(100.milliseconds)\n\n        assertFailsWith<TimeoutCancellationException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testUpstreamTimeoutActionIsolatedContext() = withVirtualTime {\n        val flow = flow {\n            assertEquals(\"upstream\", NamedDispatchers.name())\n            expect(1)\n            emit(1)\n            expect(2)\n            delay(300)\n            expectUnreached()\n        }.flowOn(NamedDispatchers(\"upstream\")).timeout(100.milliseconds).catch {\n            expect(3)\n            emit(2)\n        }\n\n        assertEquals(listOf(1, 2), flow.toList())\n        finish(4)\n    }\n\n    @Test\n    fun testSharedFlowTimeout() = withVirtualTime {\n        // Workaround for JS legacy bug\n        try {\n            MutableSharedFlow<Int>().asSharedFlow().timeout(100.milliseconds).collect()\n            expectUnreached()\n        } catch (e: TimeoutCancellationException) {\n            finish(1)\n        }\n    }\n\n    @Test\n    fun testSharedFlowCancelledNoTimeout() = runTest {\n        val mutableSharedFlow = MutableSharedFlow<Int>()\n        val list = arrayListOf<Int>()\n\n        expect(1)\n        val consumerJob = launch {\n            expect(3)\n            mutableSharedFlow.asSharedFlow().timeout(100.milliseconds).collect { list.add(it) }\n            expectUnreached()\n        }\n        val producerJob = launch {\n            expect(4)\n            repeat(10) {\n                delay(50)\n                mutableSharedFlow.emit(it)\n            }\n            yield()\n            consumerJob.cancel()\n            expect(5)\n        }\n\n        expect(2)\n\n        producerJob.join()\n        consumerJob.join()\n\n        assertEquals((0 until 10).toList(), list)\n        finish(6)\n    }\n\n    @Test\n    fun testImmediateTimeout() {\n        testImmediateTimeout(Duration.ZERO)\n        reset()\n        testImmediateTimeout(-1.seconds)\n    }\n\n    @Test\n    fun testClosing() = runTest {\n        assertFailsWith<TestException> {\n            channelFlow<Int> { close(TestException()) }\n                .timeout(Duration.INFINITE)\n                .collect {\n                    expectUnreached()\n                }\n        }\n    }\n\n    private fun testImmediateTimeout(timeout: Duration) {\n        expect(1)\n        val flow = emptyFlow<Int>().timeout(timeout)\n        flow::collect.startCoroutine(NopCollector, Continuation(EmptyCoroutineContext) {\n            assertIs<TimeoutCancellationException>(it.exceptionOrNull())\n            finish(2)\n        })\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/TransformLatestTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass TransformLatestTest : TestBase() {\n\n    @Test\n    fun testTransformLatest() = runTest {\n        val flow = flowOf(1, 2, 3).transformLatest { value ->\n            emit(value)\n            emit(value + 1)\n        }\n        assertEquals(listOf(1, 2, 2, 3, 3, 4), flow.toList())\n    }\n\n    @Test\n    fun testEmission() = runTest {\n        val list = flow {\n            repeat(5) {\n                emit(it)\n            }\n        }.transformLatest {\n            emit(it)\n        }.toList()\n        assertEquals(listOf(0, 1, 2, 3, 4), list)\n    }\n\n    @Test\n    fun testSwitchIntuitiveBehaviour() = runTest {\n        val flow = flowOf(1, 2, 3, 4, 5)\n        flow.transformLatest {\n            expect(it)\n            emit(it)\n            yield() // Explicit cancellation check\n            if (it != 5) expectUnreached()\n            else expect(6)\n        }.collect()\n        finish(7)\n    }\n\n    @Test\n    fun testSwitchRendezvousBuffer() = runTest {\n        val flow = flowOf(1, 2, 3, 4, 5)\n        flow.transformLatest {\n            emit(it)\n            // Reach here every uneven element because of channel's unfairness\n            expect(it)\n        }.buffer(0).onEach { expect(it + 1) }.collect()\n        finish(7)\n    }\n\n    @Test\n    fun testSwitchBuffer() = runTest {\n        val flow = flowOf(1, 2, 3, 42, 4)\n        flow.transformLatest {\n            emit(it)\n            expect(it)\n        }.buffer(2).collect()\n        finish(5)\n    }\n\n    @Test\n    fun testHangFlows() = runTest {\n        val flow = listOf(1, 2, 3, 4).asFlow()\n        val result = flow.transformLatest { value ->\n            if (value != 4) hang { expect(value) }\n            emit(42)\n        }.toList()\n\n        assertEquals(listOf(42), result)\n        finish(4)\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        assertNull(emptyFlow<Int>().transformLatest { emit(1) }.singleOrNull())\n    }\n\n    @Test\n    fun testIsolatedContext() = runTest {\n        val flow = flow {\n            assertEquals(\"source\", NamedDispatchers.name())\n            expect(1)\n            emit(4)\n            expect(2)\n            emit(5)\n            expect(3)\n        }.flowOn(NamedDispatchers(\"source\")).transformLatest<Int, Int> { value ->\n            emitAll(flow<Int> {\n                assertEquals(\"switch$value\", NamedDispatchers.name())\n                expect(value)\n                emit(value)\n            }.flowOn(NamedDispatchers(\"switch$value\")))\n        }.onEach {\n            expect(it + 2)\n            assertEquals(\"main\", NamedDispatchers.nameOr(\"main\"))\n        }\n        assertEquals(2, flow.count())\n        finish(8)\n    }\n\n    @Test\n    fun testFailureInTransform() = runTest {\n        val flow = flowOf(1, 2).transformLatest { value ->\n            if (value == 1) {\n                emit(1)\n                hang { expect(1) }\n            } else {\n                expect(2)\n                throw TestException()\n            }\n        }\n        assertFailsWith<TestException>(flow)\n        finish(3)\n    }\n\n    @Test\n    fun testFailureDownstream() = runTest {\n        val flow = flowOf(1).transformLatest { value ->\n            expect(1)\n            emit(value)\n            expect(2)\n            hang { expect(4) }\n        }.flowOn(NamedDispatchers(\"downstream\")).onEach {\n            expect(3)\n            throw TestException()\n        }\n        assertFailsWith<TestException>(flow)\n        finish(5)\n    }\n\n    @Test\n    fun testFailureUpstream() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            yield()\n            expect(3)\n            throw TestException()\n        }.transformLatest<Int, Long> {\n            expect(2)\n            hang {\n                expect(4)\n            }\n        }\n        assertFailsWith<TestException>(flow)\n        finish(5)\n    }\n\n    @Test\n    fun testTake() = runTest {\n        val flow = flowOf(1, 2, 3, 4, 5).transformLatest { emit(it) }\n        assertEquals(listOf(1), flow.take(1).toList())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/TransformTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass TransformTest : TestBase() {\n    @Test\n    fun testDoubleEmit() = runTest {\n         val flow = flowOf(1, 2, 3)\n             .transform {\n                 emit(it)\n                 emit(it)\n             }\n        assertEquals(listOf(1, 1, 2, 2, 3, 3), flow.toList())\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/TransformWhileTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass TransformWhileTest : TestBase() {\n    @Test\n    fun testSimple() = runTest {\n        val flow = (0..10).asFlow()\n        val expected = listOf(\"A\", \"B\", \"C\", \"D\")\n        val actual = flow.transformWhile { value ->\n            when(value) {\n                0 -> { emit(\"A\"); true }\n                1 -> true\n                2 -> { emit(\"B\"); emit(\"C\"); true }\n                3 -> { emit(\"D\"); false }\n                else -> { expectUnreached(); false }\n            }\n        }.toList()\n        assertEquals(expected, actual)\n    }\n\n    @Test\n    fun testCancelUpstream() = runTest {\n        var cancelled = false\n        val flow = flow {\n            coroutineScope {\n                launch(start = CoroutineStart.ATOMIC) {\n                    hang { cancelled = true }\n                }\n                emit(1)\n                emit(2)\n                emit(3)\n            }\n        }\n        val transformed = flow.transformWhile {\n            emit(it)\n            it < 2\n        }\n        assertEquals(listOf(1, 2), transformed.toList())\n        assertTrue(cancelled)\n    }\n    \n    @Test\n    fun testExample() = runTest {\n        val source = listOf(\n            DownloadProgress(0),\n            DownloadProgress(50),\n            DownloadProgress(100),\n            DownloadProgress(147)\n        )\n        val expected = source.subList(0, 3)\n        val actual = source.asFlow().completeWhenDone().toList()\n        assertEquals(expected, actual)\n    }\n\n    private fun Flow<DownloadProgress>.completeWhenDone(): Flow<DownloadProgress> =\n        transformWhile { progress ->\n            emit(progress) // always emit progress\n            !progress.isDone() // continue while download is not done\n        }\n\n    private data class DownloadProgress(val percent: Int) {\n        fun isDone() = percent >= 100\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/operators/ZipTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass ZipTest : TestBase() {\n\n    @Test\n    fun testZip() = runTest {\n        val f1 = flowOf(\"a\", \"b\", \"c\")\n        val f2 = flowOf(1, 2, 3)\n        assertEquals(listOf(\"a1\", \"b2\", \"c3\"), f1.zip(f2, String::plus).toList())\n    }\n\n    @Test\n    fun testUnevenZip() = runTest {\n        val f1 = flowOf(\"a\", \"b\", \"c\", \"d\", \"e\")\n        val f2 = flowOf(1, 2, 3)\n        assertEquals(listOf(\"a1\", \"b2\", \"c3\"), f1.zip(f2, String::plus).toList())\n        assertEquals(listOf(\"a1\", \"b2\", \"c3\"), f2.zip(f1) { i, j -> j + i }.toList())\n    }\n\n    @Test\n    fun testEmptyFlows() = runTest {\n        val f1 = emptyFlow<String>()\n        val f2 = emptyFlow<Int>()\n        assertEquals(emptyList(), f1.zip(f2, String::plus).toList())\n    }\n\n    @Test\n    fun testEmpty() = runTest {\n        val f1 = emptyFlow<String>()\n        val f2 = flowOf(1)\n        assertEquals(emptyList(), f1.zip(f2, String::plus).toList())\n    }\n\n    @Test\n    fun testEmptyOther() = runTest {\n        val f1 = flowOf(\"a\")\n        val f2 = emptyFlow<Int>()\n        assertEquals(emptyList(), f1.zip(f2, String::plus).toList())\n    }\n\n    @Test\n    fun testNulls() = runTest {\n        val f1 = flowOf(\"a\", null, null, \"d\")\n        val f2 = flowOf(1, 2, 3)\n        assertEquals(listOf(\"a1\", \"null2\", \"null3\"), f1.zip(f2, String?::plus).toList())\n    }\n\n    @Test\n    fun testNullsOther() = runTest {\n        val f1 = flowOf(\"a\", \"b\", \"c\")\n        val f2 = flowOf(1, null, null, 2)\n        assertEquals(listOf(\"a1\", \"bnull\", \"cnull\"), f1.zip(f2, String::plus).toList())\n    }\n\n    @Test\n    fun testCancelWhenFlowIsDone() = runTest {\n        val f1 = flow<String> {\n            emit(\"1\")\n            emit(\"2\")\n        }\n\n        val f2 = flow<String> {\n            emit(\"a\")\n            emit(\"b\")\n            expectUnreached()\n        }\n        assertEquals(listOf(\"1a\", \"2b\"), f1.zip(f2, String::plus).toList())\n        finish(1)\n    }\n\n    @Test\n    fun testCancelWhenFlowIsDone2() = runTest {\n        val f1 = flow<String> {\n            emit(\"1\")\n            emit(\"2\")\n            try {\n                emit(\"3\")\n                expectUnreached()\n            } finally {\n                expect(1)\n            }\n        }\n\n        val f2 = flowOf(\"a\", \"b\")\n        assertEquals(listOf(\"1a\", \"2b\"), f1.zip(f2, String::plus).toList())\n        finish(2)\n    }\n\n    @Test\n    fun testCancelWhenFlowIsDoneReversed() = runTest {\n        val f1 = flow<String> {\n            emit(\"1\")\n            emit(\"2\")\n            hang {\n                expect(1)\n            }\n        }\n\n        val f2 = flow<String> {\n            emit(\"a\")\n            emit(\"b\")\n            yield()\n        }\n\n        assertEquals(listOf(\"a1\", \"b2\"), f2.zip(f1, String::plus).toList())\n        finish(2)\n    }\n\n    @Test\n    fun testContextIsIsolatedReversed() = runTest {\n        val f1 = flow {\n            emit(\"a\")\n            assertEquals(\"first\", NamedDispatchers.name())\n            expect(3)\n        }.flowOn(NamedDispatchers(\"first\")).onEach {\n            assertEquals(\"with\", NamedDispatchers.name())\n            expect(4)\n        }.flowOn(NamedDispatchers(\"with\"))\n\n        val f2 = flow {\n            emit(1)\n            assertEquals(\"second\", NamedDispatchers.name())\n            expect(1)\n        }.flowOn(NamedDispatchers(\"second\")).onEach {\n            assertEquals(\"nested\", NamedDispatchers.name())\n            expect(2)\n        }.flowOn(NamedDispatchers(\"nested\"))\n\n        val value = withContext(NamedDispatchers(\"main\")) {\n            f1.zip(f2) { i, j ->\n                assertEquals(\"main\", NamedDispatchers.name())\n                expect(5)\n                i + j\n            }.single()\n        }\n\n        assertEquals(\"a1\", value)\n        finish(6)\n    }\n\n    @Test\n    fun testErrorInDownstreamCancelsUpstream() = runTest {\n        val f1 = flow {\n            emit(\"a\")\n            hang {\n                expect(3)\n            }\n        }.flowOn(NamedDispatchers(\"first\"))\n\n        val f2 = flow {\n            emit(1)\n            hang {\n                expect(2)\n            }\n        }.flowOn(NamedDispatchers(\"second\"))\n\n        val flow = f1.zip(f2) { i, j ->\n            assertEquals(\"zip\", NamedDispatchers.name())\n            expect(1)\n            i + j\n        }.flowOn(NamedDispatchers(\"zip\")).onEach {\n            throw TestException()\n        }\n\n        assertFailsWith<TestException>(flow)\n        finish(4)\n    }\n\n    @Test\n    fun testErrorCancelsSibling() = runTest {\n        val f1 = flow {\n            emit(\"a\")\n            hang {\n                expect(1)\n            }\n        }.flowOn(NamedDispatchers(\"first\"))\n\n        val f2 = flow {\n            emit(1)\n            throw TestException()\n        }.flowOn(NamedDispatchers(\"second\"))\n\n        val flow = f1.zip(f2) { _, _ -> 1 }\n        assertFailsWith<TestException>(flow)\n        finish(2)\n    }\n\n    @Test\n    fun testCancellationUpstream() = runTest {\n        val f1 = flow {\n            expect(1)\n            emit(1)\n            expect(5)\n            throw CancellationException(\"\")\n        }\n\n        val f2 = flow {\n            expect(2)\n            emit(1)\n            expect(3)\n            hang { expect(6) }\n        }\n\n        val flow = f1.zip(f2) { _, _ -> 1 }.onEach { expect(4) }\n        assertFailsWith<CancellationException>(flow)\n        finish(7)\n    }\n\n    @Test\n    fun testCancellationDownstream() = runTest {\n        val f1 = flow {\n            expect(1)\n            emit(1)\n            expectUnreached() // Will throw CE\n        }\n\n        val f2 = flow {\n            expect(2)\n            emit(1)\n            expect(3)\n            hang { expect(5) }\n        }\n\n        val flow = f1.zip(f2, { _, _ -> 1 }).onEach {\n            expect(4)\n            yield()\n            throw CancellationException(\"\")\n        }\n        assertFailsWith<CancellationException>(flow)\n        finish(6)\n    }\n\n    @Test\n    fun testCancellationOfCollector() = runTest {\n        val f1 = flow {\n            emit(\"1\")\n            awaitCancellation()\n        }\n\n        val f2 = flow {\n            emit(\"2\")\n            yield()\n        }\n\n        f1.zip(f2, String::plus).collect { }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/ShareInBufferTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.math.*\nimport kotlin.test.*\n\n/**\n * Similar to [BufferTest], but tests [shareIn] buffering and its fusion with [buffer] operators.\n */\nclass ShareInBufferTest : TestBase() {\n    private val n = 200 // number of elements to emit for test\n    private val defaultBufferSize = 64 // expected default buffer size (per docs)\n\n    // Use capacity == -1 to check case of \"no buffer\"\n    private fun checkBuffer(capacity: Int, op: suspend Flow<Int>.(CoroutineScope) -> Flow<Int>) = runTest {\n        expect(1)\n        /*\n           Shared flows do not perform full rendezvous. On buffer overflow emitter always suspends until all\n           subscribers get the value and then resumes. Thus, perceived batch size is +1 from buffer capacity.\n         */\n        val batchSize = capacity + 1\n        val upstream = flow {\n            repeat(n) { i ->\n                val batchNo = i / batchSize\n                val batchIdx = i % batchSize\n                expect(batchNo * batchSize * 2 + batchIdx + 2)\n                emit(i)\n            }\n            emit(-1) // done\n        }\n        coroutineScope {\n            upstream\n                .op(this)\n                .takeWhile { i -> i >= 0 } // until done\n                .collect { i ->\n                    val batchNo = i / batchSize\n                    val batchIdx = i % batchSize\n                    // last batch might have smaller size\n                    val k = min((batchNo + 1) * batchSize, n) - batchNo * batchSize\n                    expect(batchNo * batchSize * 2 + k + batchIdx + 2)\n                }\n            coroutineContext.cancelChildren() // cancels sharing\n        }\n        finish(2 * n + 2)\n    }\n\n    @Test\n    fun testReplay0DefaultBuffer() =\n        checkBuffer(defaultBufferSize) {\n            shareIn(it, SharingStarted.Eagerly)\n        }\n\n    @Test\n    fun testReplay1DefaultBuffer() =\n        checkBuffer(defaultBufferSize) {\n            shareIn(it, SharingStarted.Eagerly, 1)\n        }\n\n    @Test // buffer is padded to default size as needed\n    fun testReplay10DefaultBuffer() =\n        checkBuffer(maxOf(10, defaultBufferSize)) {\n            shareIn(it, SharingStarted.Eagerly, 10)\n        }\n\n    @Test // buffer is padded to default size as needed\n    fun testReplay100DefaultBuffer() =\n        checkBuffer( maxOf(100, defaultBufferSize)) {\n            shareIn(it, SharingStarted.Eagerly, 100)\n        }\n\n    @Test\n    fun testDefaultBufferKeepsDefault() =\n        checkBuffer(defaultBufferSize) {\n            buffer().shareIn(it, SharingStarted.Eagerly)\n        }\n\n    @Test\n    fun testOverrideDefaultBuffer0() =\n        checkBuffer(0) {\n            buffer(0).shareIn(it, SharingStarted.Eagerly)\n        }\n\n    @Test\n    fun testOverrideDefaultBuffer10() =\n        checkBuffer(10) {\n            buffer(10).shareIn(it, SharingStarted.Eagerly)\n        }\n                                         \n    @Test // buffer and replay sizes add up\n    fun testBufferReplaySum() =\n        checkBuffer(41) {\n            buffer(10).buffer(20).shareIn(it, SharingStarted.Eagerly, 11)\n        }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/ShareInConflationTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\n/**\n * Similar to [ShareInBufferTest] and [BufferConflationTest],\n * but tests [shareIn] and its fusion with [conflate] operator.\n */\nclass ShareInConflationTest : TestBase() {\n    private val n = 100\n\n    private fun checkConflation(\n        bufferCapacity: Int,\n        onBufferOverflow: BufferOverflow = BufferOverflow.DROP_OLDEST,\n        op: suspend Flow<Int>.(CoroutineScope) -> Flow<Int>\n    ) = runTest {\n        expect(1)\n        // emit all and conflate, then should collect bufferCapacity the latest ones\n        val done = Job()\n        flow {\n            repeat(n) { i ->\n                expect(i + 2)\n                emit(i)\n            }\n            done.join() // wait until done collection\n            emit(-1) // signal flow completion\n        }\n            .op(this)\n            .takeWhile { i -> i >= 0 }\n            .collect { i ->\n                val first = if (onBufferOverflow == BufferOverflow.DROP_LATEST) 0 else n - bufferCapacity\n                val last = first + bufferCapacity - 1\n                if (i in first..last) {\n                    expect(n + i - first + 2)\n                    if (i == last) done.complete() // received the last one\n                } else {\n                    error(\"Unexpected $i\")\n                }\n            }\n        finish(n + bufferCapacity + 2)\n    }\n\n    @Test\n    fun testConflateReplay1() =\n        checkConflation(1) {\n            conflate().shareIn(it, SharingStarted.Eagerly, 1)\n        }\n\n    @Test // still looks like conflating the last value for the first subscriber (will not replay to others though)\n    fun testConflateReplay0() =\n        checkConflation(1) {\n            conflate().shareIn(it, SharingStarted.Eagerly, 0)\n        }\n\n    @Test\n    fun testConflateReplay5() =\n        checkConflation(5) {\n            conflate().shareIn(it, SharingStarted.Eagerly, 5)\n        }\n\n    @Test\n    fun testBufferDropOldestReplay1() =\n        checkConflation(1) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_OLDEST).shareIn(it, SharingStarted.Eagerly, 1)\n        }\n\n    @Test\n    fun testBufferDropOldestReplay0() =\n        checkConflation(1) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_OLDEST).shareIn(it, SharingStarted.Eagerly, 0)\n        }\n\n    @Test\n    fun testBufferDropOldestReplay10() =\n        checkConflation(10) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_OLDEST).shareIn(it, SharingStarted.Eagerly, 10)\n        }\n\n    @Test\n    fun testBuffer20DropOldestReplay0() =\n        checkConflation(20) {\n            buffer(20, onBufferOverflow = BufferOverflow.DROP_OLDEST).shareIn(it, SharingStarted.Eagerly, 0)\n        }\n\n    @Test\n    fun testBuffer7DropOldestReplay11() =\n        checkConflation(18) {\n            buffer(7, onBufferOverflow = BufferOverflow.DROP_OLDEST).shareIn(it, SharingStarted.Eagerly, 11)\n        }\n\n    @Test // a preceding buffer() gets overridden by conflate()\n    fun testBufferConflateOverride() =\n        checkConflation(1) {\n            buffer(23).conflate().shareIn(it, SharingStarted.Eagerly, 1)\n        }\n\n    @Test // a preceding buffer() gets overridden by buffer(onBufferOverflow = BufferOverflow.DROP_OLDEST)\n    fun testBufferDropOldestOverride() =\n        checkConflation(1) {\n            buffer(23).buffer(onBufferOverflow = BufferOverflow.DROP_OLDEST).shareIn(it, SharingStarted.Eagerly, 1)\n        }\n\n    @Test\n    fun testBufferDropLatestReplay0() =\n        checkConflation(1, BufferOverflow.DROP_LATEST) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_LATEST).shareIn(it, SharingStarted.Eagerly, 0)\n        }\n\n    @Test\n    fun testBufferDropLatestReplay1() =\n        checkConflation(1, BufferOverflow.DROP_LATEST) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_LATEST).shareIn(it, SharingStarted.Eagerly, 1)\n        }\n\n    @Test\n    fun testBufferDropLatestReplay10() =\n        checkConflation(10, BufferOverflow.DROP_LATEST) {\n            buffer(onBufferOverflow = BufferOverflow.DROP_LATEST).shareIn(it, SharingStarted.Eagerly, 10)\n        }\n\n    @Test\n    fun testBuffer0DropLatestReplay0() =\n        checkConflation(1, BufferOverflow.DROP_LATEST) {\n            buffer(0, onBufferOverflow = BufferOverflow.DROP_LATEST).shareIn(it, SharingStarted.Eagerly, 0)\n        }\n\n    @Test\n    fun testBuffer0DropLatestReplay1() =\n        checkConflation(1, BufferOverflow.DROP_LATEST) {\n            buffer(0, onBufferOverflow = BufferOverflow.DROP_LATEST).shareIn(it, SharingStarted.Eagerly, 1)\n        }\n\n    @Test\n    fun testBuffer0DropLatestReplay10() =\n        checkConflation(10, BufferOverflow.DROP_LATEST) {\n            buffer(0, onBufferOverflow = BufferOverflow.DROP_LATEST).shareIn(it, SharingStarted.Eagerly, 10)\n        }\n\n    @Test\n    fun testBuffer5DropLatestReplay0() =\n        checkConflation(5, BufferOverflow.DROP_LATEST) {\n            buffer(5, onBufferOverflow = BufferOverflow.DROP_LATEST).shareIn(it, SharingStarted.Eagerly, 0)\n        }\n\n    @Test\n    fun testBuffer5DropLatestReplay10() =\n        checkConflation(15, BufferOverflow.DROP_LATEST) {\n            buffer(5, onBufferOverflow = BufferOverflow.DROP_LATEST).shareIn(it, SharingStarted.Eagerly, 10)\n        }\n\n    @Test // a preceding buffer() gets overridden by buffer(onBufferOverflow = BufferOverflow.DROP_LATEST)\n    fun testBufferDropLatestOverride() =\n        checkConflation(1, BufferOverflow.DROP_LATEST) {\n            buffer(23).buffer(onBufferOverflow = BufferOverflow.DROP_LATEST).shareIn(it, SharingStarted.Eagerly, 0)\n        }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/ShareInFusionTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass ShareInFusionTest : TestBase() {\n    /**\n     * Test perfect fusion for operators **after** [shareIn].\n     */\n    @Test\n    fun testOperatorFusion() = runTest {\n        val sh = emptyFlow<Int>().shareIn(this, SharingStarted.Eagerly)\n        assertTrue(sh !is MutableSharedFlow<*>) // cannot be cast to mutable shared flow!!!\n        assertSame(sh, (sh as Flow<*>).cancellable())\n        assertSame(sh, (sh as Flow<*>).flowOn(Dispatchers.Default))\n        assertSame(sh, sh.buffer(Channel.RENDEZVOUS))\n        coroutineContext.cancelChildren()\n    }\n\n    @Test\n    fun testFlowOnContextFusion() = runTest {\n        val flow = flow {\n            assertEquals(\"FlowCtx\", currentCoroutineContext()[CoroutineName]?.name)\n            emit(\"OK\")\n        }.flowOn(CoroutineName(\"FlowCtx\"))\n        assertEquals(\"OK\", flow.shareIn(this, SharingStarted.Eagerly, 1).first())\n        coroutineContext.cancelChildren()\n    }\n\n    /**\n     * Tests that `channelFlow { ... }.buffer(x)` works according to the [channelFlow] docs, and subsequent\n     * application of [shareIn] does not leak upstream.\n     */\n    @Test\n    fun testChannelFlowBufferShareIn() = runTest {\n        expect(1)\n        val flow = channelFlow {\n            // send a batch of 10 elements using [offer]\n            for (i in 1..10) {\n                assertTrue(trySend(i).isSuccess) // offer must succeed, because buffer\n            }\n            send(0) // done\n        }.buffer(10) // request a buffer of 10\n        // ^^^^^^^^^ buffer stays here\n        val shared = flow.shareIn(this, SharingStarted.Eagerly)\n        shared\n            .takeWhile { it > 0 }\n            .collect { i -> expect(i + 1) }\n        finish(12)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/ShareInTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass ShareInTest : TestBase() {\n    @Test\n    fun testReplay0Eager() = runTest {\n        expect(1)\n        val flow = flowOf(\"OK\")\n        val shared = flow.shareIn(this, SharingStarted.Eagerly)\n        yield() // actually start sharing\n        // all subscribers miss \"OK\"\n        val jobs = List(10) {\n            shared.onEach { expectUnreached() }.launchIn(this)\n        }\n        yield() // ensure nothing is collected\n        jobs.forEach { it.cancel() }\n        finish(2)\n    }\n\n    @Test\n    fun testReplay0Lazy() = testReplayZeroOrOne(0)\n\n    @Test\n    fun testReplay1Lazy() = testReplayZeroOrOne(1)\n\n    private fun testReplayZeroOrOne(replay: Int) = runTest {\n        expect(1)\n        val doneBarrier = Job()\n        val flow = flow {\n            expect(2)\n            emit(\"OK\")\n            doneBarrier.join()\n            emit(\"DONE\")\n        }\n        val sharingJob = Job()\n        val shared = flow.shareIn(this + sharingJob, started = SharingStarted.Lazily, replay = replay)\n        yield() // should not start sharing\n        // first subscriber gets \"OK\", other subscribers miss \"OK\"\n        val n = 10\n        val replayOfs = replay * (n - 1)\n        val subscriberJobs = List(n) { index ->\n            val subscribedBarrier = Job()\n            val job = shared\n                .onSubscription {\n                    subscribedBarrier.complete()\n                }\n                .onEach { value ->\n                    when (value) {\n                        \"OK\" -> {\n                            expect(3 + index)\n                            if (replay == 0) { // only the first subscriber collects \"OK\" without replay\n                                assertEquals(0, index)\n                            }\n                        }\n                        \"DONE\" -> {\n                            expect(4 + index + replayOfs)\n                        }\n                        else -> expectUnreached()\n                    }\n                }\n                .takeWhile { it != \"DONE\" }\n                .launchIn(this)\n            subscribedBarrier.join() // wait until the launched job subscribed before launching the next one\n            job\n        }\n        doneBarrier.complete()\n        subscriberJobs.joinAll()\n        expect(4 + n + replayOfs)\n        sharingJob.cancel()\n        finish(5 + n + replayOfs)\n    }\n\n    @Test\n    fun testUpstreamCompleted() =\n        testUpstreamCompletedOrFailed(failed = false)\n\n    @Test\n    fun testUpstreamFailed() =\n        testUpstreamCompletedOrFailed(failed = true)\n\n    private fun testUpstreamCompletedOrFailed(failed: Boolean) = runTest {\n        val emitted = Job()\n        val terminate = Job()\n        val sharingJob = CompletableDeferred<Unit>()\n        val upstream = flow {\n            emit(\"OK\")\n            emitted.complete()\n            terminate.join()\n            if (failed) throw TestException()\n        }\n        val shared = upstream.shareIn(this + sharingJob, SharingStarted.Eagerly, 1)\n        assertEquals(emptyList(), shared.replayCache)\n        emitted.join() // should start sharing, emit & cache\n        assertEquals(listOf(\"OK\"), shared.replayCache)\n        terminate.complete()\n        sharingJob.complete(Unit)\n        sharingJob.join() // should complete sharing\n        assertEquals(listOf(\"OK\"), shared.replayCache) // cache is still there\n        if (failed) {\n            assertIs<TestException>(sharingJob.getCompletionExceptionOrNull())\n        } else {\n            assertNull(sharingJob.getCompletionExceptionOrNull())\n        }\n    }\n\n    @Test\n    fun testWhileSubscribedBasic() =\n        testWhileSubscribed(1, SharingStarted.WhileSubscribed())\n\n    @Test\n    fun testWhileSubscribedCustomAtLeast1() =\n        testWhileSubscribed(1, SharingStarted.WhileSubscribedAtLeast(1))\n\n    @Test\n    fun testWhileSubscribedCustomAtLeast2() =\n        testWhileSubscribed(2, SharingStarted.WhileSubscribedAtLeast(2))\n\n    @OptIn(ExperimentalStdlibApi::class)\n    private fun testWhileSubscribed(threshold: Int, started: SharingStarted) = runTest {\n        expect(1)\n        val flowState = FlowState()\n        val n = 3 // max number of subscribers\n        val log = Channel<String>(2 * n)\n\n        suspend fun checkStartTransition(subscribers: Int) {\n            when (subscribers) {\n                in 0 until threshold -> assertFalse(flowState.started)\n                threshold -> {\n                    flowState.awaitStart() // must eventually start the flow\n                    for (i in 1..threshold) {\n                        assertEquals(\"sub$i: OK\", log.receive()) // threshold subs must receive the values\n                    }\n                }\n                in threshold + 1..n -> assertTrue(flowState.started)\n            }\n        }\n\n        suspend fun checkStopTransition(subscribers: Int) {\n            when (subscribers) {\n                in threshold + 1..n -> assertTrue(flowState.started)\n                threshold - 1 -> flowState.awaitStop() // upstream flow must be eventually stopped\n                in 0..threshold - 2 -> assertFalse(flowState.started) // should have stopped already\n            }\n        }\n\n        val flow = flow {\n            flowState.track {\n                emit(\"OK\")\n                delay(Long.MAX_VALUE) // await forever, will get cancelled\n            }\n        }\n        \n        val shared = flow.shareIn(this, started)\n        repeat(5) { // repeat scenario a few times\n            yield()\n            assertFalse(flowState.started) // flow is not running even if we yield\n            // start 3 subscribers\n            val subs = ArrayList<Job>()\n            for (i in 1..n) {\n                subs += shared\n                    .onEach { value -> // only the first threshold subscribers get the value\n                        when (i) {\n                            in 1..threshold -> log.trySend(\"sub$i: $value\")\n                            else -> expectUnreached()\n                        }\n                    }\n                    .onCompletion { log.trySend(\"sub$i: completion\") }\n                    .launchIn(this)\n                checkStartTransition(i)\n            }\n            // now cancel all subscribers\n            for (i in 1..n) {\n                subs.removeFirst().cancel() // cancel subscriber\n                assertEquals(\"sub$i: completion\", log.receive()) // subscriber shall shutdown\n                checkStopTransition(n - i)\n            }\n        }\n        coroutineContext.cancelChildren() // cancel sharing job\n        finish(2)\n    }\n\n    @Suppress(\"TestFunctionName\")\n    private fun SharingStarted.Companion.WhileSubscribedAtLeast(threshold: Int) =\n        SharingStarted { subscriptionCount ->\n            subscriptionCount.map { if (it >= threshold) SharingCommand.START else SharingCommand.STOP }\n        }\n\n    private class FlowState {\n        private val timeLimit = 10000L\n        private val _started = MutableStateFlow(false)\n        val started: Boolean get() = _started.value\n        fun start() = check(_started.compareAndSet(expect = false, update = true))\n        fun stop() = check(_started.compareAndSet(expect = true, update = false))\n        suspend fun awaitStart() = withTimeout(timeLimit) { _started.first { it } }\n        suspend fun awaitStop() = withTimeout(timeLimit) { _started.first { !it } }\n    }\n\n    private suspend fun FlowState.track(block: suspend () -> Unit) {\n        start()\n        try {\n            block()\n        } finally {\n            stop()\n        }\n    }\n\n    @Test\n    fun testShouldStart() = runTest {\n        val flow = flow {\n            expect(2)\n            emit(1)\n            expect(3)\n        }.shareIn(this, SharingStarted.Lazily)\n\n        expect(1)\n        flow.onSubscription { throw CancellationException(\"\") }\n            .catch { e -> assertTrue { e is CancellationException } }\n            .collect()\n        yield()\n        finish(4)\n    }\n\n    @Test\n    fun testShouldStartScalar() = runTest {\n        val j = Job()\n        val shared = flowOf(239).stateIn(this + j, SharingStarted.Lazily, 42)\n        assertEquals(42, shared.first())\n        yield()\n        assertEquals(239, shared.first())\n        j.cancel()\n    }\n\n    @Test\n    fun testSubscriptionByFirstSuspensionInSharedFlow() = runTest {\n        testSubscriptionByFirstSuspensionInCollect(flowOf(1).stateIn(this@runTest), emit = { })\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/SharedFlowScenarioTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n/**\n * This test suit for [SharedFlow] has a dense framework that allows to test complex\n * suspend/resume scenarios while keeping the code readable. Each test here is for\n * one specific [SharedFlow] configuration, testing all the various corner cases in its\n * behavior.\n */\nclass SharedFlowScenarioTest : TestBase() {\n    @Test\n    fun testReplay1Extra2() =\n        testSharedFlow(MutableSharedFlow<Int>(1, 2)) {\n            // total buffer size == 3\n            expectReplayOf()\n            emitRightNow(1); expectReplayOf(1)\n            emitRightNow(2); expectReplayOf(2)\n            emitRightNow(3); expectReplayOf(3)\n            emitRightNow(4); expectReplayOf(4) // no prob - no subscribers\n            val a = subscribe(\"a\"); collect(a, 4)\n            emitRightNow(5); expectReplayOf(5)\n            emitRightNow(6); expectReplayOf(6)\n            emitRightNow(7); expectReplayOf(7)\n            // suspend/collect sequentially\n            val e8 = emitSuspends(8); collect(a, 5); emitResumes(e8); expectReplayOf(8)\n            val e9 = emitSuspends(9); collect(a, 6); emitResumes(e9); expectReplayOf(9)\n            // buffer full, but parallel emitters can still suspend (queue up)\n            val e10 = emitSuspends(10)\n            val e11 = emitSuspends(11)\n            val e12 = emitSuspends(12)\n            collect(a, 7); emitResumes(e10); expectReplayOf(10) // buffer 8, 9 | 10\n            collect(a, 8); emitResumes(e11); expectReplayOf(11) // buffer 9, 10 | 11\n            sharedFlow.resetReplayCache(); expectReplayOf() // 9, 10 11 | no replay\n            collect(a, 9); emitResumes(e12); expectReplayOf(12)\n            collect(a, 10, 11, 12); expectReplayOf(12) // buffer empty | 12\n            emitRightNow(13); expectReplayOf(13)\n            emitRightNow(14); expectReplayOf(14)\n            emitRightNow(15); expectReplayOf(15) // buffer 13, 14 | 15\n            val e16 = emitSuspends(16)\n            val e17 = emitSuspends(17)\n            val e18 = emitSuspends(18)\n            cancel(e17); expectReplayOf(15) // cancel in the middle of three emits; buffer 13, 14 | 15\n            collect(a, 13); emitResumes(e16); expectReplayOf(16) // buffer 14, 15, | 16\n            collect(a, 14); emitResumes(e18); expectReplayOf(18) // buffer 15, 16 | 18\n            val e19 = emitSuspends(19)\n            val e20 = emitSuspends(20)\n            val e21 = emitSuspends(21)\n            cancel(e21); expectReplayOf(18) // cancel last emit; buffer 15, 16, 18\n            collect(a, 15); emitResumes(e19); expectReplayOf(19) // buffer 16, 18 | 19\n            collect(a, 16); emitResumes(e20); expectReplayOf(20) // buffer 18, 19 | 20\n            collect(a, 18, 19, 20); expectReplayOf(20) // buffer empty | 20\n            emitRightNow(22); expectReplayOf(22)\n            emitRightNow(23); expectReplayOf(23)\n            emitRightNow(24); expectReplayOf(24) // buffer 22, 23 | 24\n            val e25 = emitSuspends(25)\n            val e26 = emitSuspends(26)\n            val e27 = emitSuspends(27)\n            cancel(e25); expectReplayOf(24) // cancel first emit, buffer 22, 23 | 24\n            sharedFlow.resetReplayCache(); expectReplayOf() // buffer 22, 23, 24 | no replay\n            val b = subscribe(\"b\") // new subscriber\n            collect(a, 22); emitResumes(e26); expectReplayOf(26) // buffer 23, 24 | 26\n            collect(b, 26)\n            collect(a, 23); emitResumes(e27); expectReplayOf(27) // buffer 24, 26 | 27\n            collect(a, 24, 26, 27) // buffer empty | 27\n            emitRightNow(28); expectReplayOf(28)\n            emitRightNow(29); expectReplayOf(29) // buffer 27, 28 | 29\n            collect(a, 28, 29) // but b is slow\n            val e30 = emitSuspends(30)\n            val e31 = emitSuspends(31)\n            val e32 = emitSuspends(32)\n            val e33 = emitSuspends(33)\n            val e34 = emitSuspends(34)\n            val e35 = emitSuspends(35)\n            val e36 = emitSuspends(36)\n            val e37 = emitSuspends(37)\n            val e38 = emitSuspends(38)\n            val e39 = emitSuspends(39)\n            cancel(e31) // cancel emitter in queue\n            cancel(b) // cancel slow subscriber -> 3 emitters resume\n            emitResumes(e30); emitResumes(e32); emitResumes(e33); expectReplayOf(33) // buffer 30, 32 | 33\n            val c = subscribe(\"c\"); collect(c, 33) // replays\n            cancel(e34)\n            collect(a, 30); emitResumes(e35); expectReplayOf(35) // buffer 32, 33 | 35\n            cancel(e37)\n            cancel(a); emitResumes(e36); emitResumes(e38); expectReplayOf(38) // buffer 35, 36 | 38\n            collect(c, 35); emitResumes(e39); expectReplayOf(39) // buffer 36, 38 | 39\n            collect(c, 36, 38, 39); expectReplayOf(39)\n            cancel(c); expectReplayOf(39) // replay stays\n        }\n\n    @Test\n    fun testReplay1() =\n        testSharedFlow(MutableSharedFlow<Int>(1)) {\n            emitRightNow(0); expectReplayOf(0)\n            emitRightNow(1); expectReplayOf(1)\n            emitRightNow(2); expectReplayOf(2)\n            sharedFlow.resetReplayCache(); expectReplayOf()\n            sharedFlow.resetReplayCache(); expectReplayOf()\n            emitRightNow(3); expectReplayOf(3)\n            emitRightNow(4); expectReplayOf(4)\n            val a = subscribe(\"a\"); collect(a, 4)\n            emitRightNow(5); expectReplayOf(5); collect(a, 5)\n            emitRightNow(6)\n            sharedFlow.resetReplayCache(); expectReplayOf()\n            sharedFlow.resetReplayCache(); expectReplayOf()\n            val e7 = emitSuspends(7)\n            val e8 = emitSuspends(8)\n            val e9 = emitSuspends(9)\n            collect(a, 6); emitResumes(e7); expectReplayOf(7)\n            sharedFlow.resetReplayCache(); expectReplayOf()\n            sharedFlow.resetReplayCache(); expectReplayOf() // buffer 7 | -- no replay, but still buffered\n            val b = subscribe(\"b\")\n            collect(a, 7); emitResumes(e8); expectReplayOf(8)\n            collect(b, 8) // buffer | 8 -- a is slow\n            val e10 = emitSuspends(10)\n            val e11 = emitSuspends(11)\n            val e12 = emitSuspends(12)\n            cancel(e9)\n            collect(a, 8); emitResumes(e10); expectReplayOf(10)\n            collect(a, 10) // now b's slow\n            cancel(e11)\n            collect(b, 10); emitResumes(e12); expectReplayOf(12)\n            collect(a, 12)\n            collect(b, 12)\n            sharedFlow.resetReplayCache(); expectReplayOf()\n            sharedFlow.resetReplayCache(); expectReplayOf() // nothing is buffered -- both collectors up to date\n            emitRightNow(13); expectReplayOf(13)\n            collect(b, 13) // a is slow\n            val e14 = emitSuspends(14)\n            val e15 = emitSuspends(15)\n            val e16 = emitSuspends(16)\n            cancel(e14)\n            cancel(a); emitResumes(e15); expectReplayOf(15) // cancelling slow subscriber\n            collect(b, 15); emitResumes(e16); expectReplayOf(16)\n            collect(b, 16)\n        }\n\n    @Test\n    fun testReplay2Extra2DropOldest() =\n        testSharedFlow<Int>(MutableSharedFlow(2, 2, BufferOverflow.DROP_OLDEST)) {\n            emitRightNow(0); expectReplayOf(0)\n            emitRightNow(1); expectReplayOf(0, 1)\n            emitRightNow(2); expectReplayOf(1, 2)\n            emitRightNow(3); expectReplayOf(2, 3)\n            emitRightNow(4); expectReplayOf(3, 4)\n            val a = subscribe(\"a\")\n            collect(a, 3)\n            emitRightNow(5); expectReplayOf(4, 5)\n            emitRightNow(6); expectReplayOf(5, 6)\n            emitRightNow(7); expectReplayOf(6, 7) // buffer 4, 5 | 6, 7\n            emitRightNow(8); expectReplayOf(7, 8) // buffer 5, 6 | 7, 8\n            emitRightNow(9); expectReplayOf(8, 9) // buffer 6, 7 | 8, 9\n            collect(a, 6, 7)\n            val b = subscribe(\"b\")\n            collect(b, 8, 9) // buffer | 8, 9\n            emitRightNow(10); expectReplayOf(9, 10) // buffer 8 | 9, 10\n            collect(a, 8, 9, 10) // buffer | 9, 10, note \"b\" had not collected 10 yet\n            emitRightNow(11); expectReplayOf(10, 11) // buffer | 10, 11\n            emitRightNow(12); expectReplayOf(11, 12) // buffer 10 | 11, 12\n            emitRightNow(13); expectReplayOf(12, 13) // buffer 10, 11 | 12, 13\n            emitRightNow(14); expectReplayOf(13, 14) // buffer 11, 12 | 13, 14, \"b\" missed 10\n            collect(b, 11, 12, 13, 14)\n            sharedFlow.resetReplayCache(); expectReplayOf() // buffer 11, 12, 13, 14 |\n            sharedFlow.resetReplayCache(); expectReplayOf()\n            collect(a, 11, 12, 13, 14)\n            emitRightNow(15); expectReplayOf(15)\n            collect(a, 15)\n            collect(b, 15)\n        }\n\n    @Test // https://github.com/Kotlin/kotlinx.coroutines/issues/2320\n    fun testResumeFastSubscriberOnResumedEmitter() =\n        testSharedFlow<Int>(MutableSharedFlow(1)) {\n            // create two subscribers and start collecting\n            val s1 = subscribe(\"s1\"); resumeCollecting(s1)\n            val s2 = subscribe(\"s2\"); resumeCollecting(s2)\n            // now emit 0, make sure it is collected\n            emitRightNow(0); expectReplayOf(0)\n            awaitCollected(s1, 0)\n            awaitCollected(s2, 0)\n            // now emit 1, and only first subscriber continues and collects it\n            emitRightNow(1); expectReplayOf(1)\n            collect(s1, 1)\n            // now emit 2, it suspend (s2 is blocking it)\n            val e2 = emitSuspends(2)\n            resumeCollecting(s1) // resume, but does not collect (e2 is still queued)\n            collect(s2, 1) // resume + collect next --> resumes emitter, thus resumes s1\n            awaitCollected(s1, 2) // <-- S1 collects value from the newly resumed emitter here !!!\n            emitResumes(e2); expectReplayOf(2)\n            // now emit 3, it suspends (s2 blocks it)\n            val e3 = emitSuspends(3)\n            collect(s2, 2)\n            emitResumes(e3); expectReplayOf(3)\n        }\n\n    @Test\n    fun testSuspendedConcurrentEmitAndCancelSubscriberReplay1() =\n        testSharedFlow<Int>(MutableSharedFlow(1)) {\n            val a = subscribe(\"a\");\n            emitRightNow(0); expectReplayOf(0)\n            collect(a, 0)\n            emitRightNow(1); expectReplayOf(1)\n            val e2 = emitSuspends(2) // suspends until 1 is collected\n            val e3 = emitSuspends(3) // suspends until 1 is collected, too\n            cancel(a) // must resume emitters 2 & 3\n            emitResumes(e2)\n            emitResumes(e3)\n            expectReplayOf(3) // but replay size is 1 so only 3 should be kept\n            // Note: originally, SharedFlow was in a broken state here with 3 elements in the buffer\n            val b = subscribe(\"b\")\n            collect(b, 3)\n            emitRightNow(4); expectReplayOf(4)\n            collect(b, 4)\n        }\n\n    @Test\n    fun testSuspendedConcurrentEmitAndCancelSubscriberReplay1ExtraBuffer1() =\n        testSharedFlow<Int>(MutableSharedFlow( replay = 1, extraBufferCapacity = 1)) {\n            val a = subscribe(\"a\");\n            emitRightNow(0); expectReplayOf(0)\n            collect(a, 0)\n            emitRightNow(1); expectReplayOf(1)\n            emitRightNow(2); expectReplayOf(2)\n            val e3 = emitSuspends(3) // suspends until 1 is collected\n            val e4 = emitSuspends(4) // suspends until 1 is collected, too\n            val e5 = emitSuspends(5) // suspends until 1 is collected, too\n            cancel(a) // must resume emitters 3, 4, 5\n            emitResumes(e3)\n            emitResumes(e4)\n            emitResumes(e5)\n            expectReplayOf(5)\n            val b = subscribe(\"b\")\n            collect(b, 5)\n            emitRightNow(6); expectReplayOf(6)\n            collect(b, 6)\n        }\n\n    private fun <T> testSharedFlow(\n        sharedFlow: MutableSharedFlow<T>,\n        scenario: suspend ScenarioDsl<T>.() -> Unit\n    ) = runTest {\n        var dsl: ScenarioDsl<T>? = null\n        try {\n            coroutineScope {\n                dsl = ScenarioDsl<T>(sharedFlow, coroutineContext)\n                dsl!!.scenario()\n                dsl!!.stop()\n            }\n        } catch (e: Throwable) {\n            dsl?.printLog()\n            throw e\n        }\n    }\n\n    private data class TestJob(val job: Job, val name: String) {\n        override fun toString(): String = name\n    }\n\n    private open class Action\n    private data class EmitResumes(val job: TestJob) : Action()\n    private data class Collected(val job: TestJob, val value: Any?) : Action()\n    private data class ResumeCollecting(val job: TestJob) : Action()\n    private data class Cancelled(val job: TestJob) : Action()\n\n    @OptIn(ExperimentalStdlibApi::class)\n    private class ScenarioDsl<T>(\n        val sharedFlow: MutableSharedFlow<T>,\n        coroutineContext: CoroutineContext\n    ) {\n        private val log = ArrayList<String>()\n        private val timeout = 10000L\n        private val scope = CoroutineScope(coroutineContext + Job())\n        private val actions = HashSet<Action>()\n        private val actionWaiters = ArrayDeque<Continuation<Unit>>()\n        private var expectedReplay = emptyList<T>()\n\n        private fun checkReplay() {\n            assertEquals(expectedReplay, sharedFlow.replayCache)\n        }\n\n        private fun wakeupWaiters() {\n            repeat(actionWaiters.size) {\n                actionWaiters.removeFirst().resume(Unit)\n            }\n        }\n\n        private fun addAction(action: Action) {\n            actions.add(action)\n            wakeupWaiters()\n        }\n\n        private suspend fun awaitAction(action: Action) {\n            withTimeoutOrNull(timeout) {\n                while (!actions.remove(action)) {\n                    suspendCancellableCoroutine<Unit> { actionWaiters.add(it) }\n                }\n            } ?: error(\"Timed out waiting for action: $action\")\n            wakeupWaiters()\n        }\n\n        private fun launchEmit(a: T): TestJob {\n            val name = \"emit($a)\"\n            val job = scope.launch(start = CoroutineStart.UNDISPATCHED) {\n                val job = TestJob(coroutineContext[Job]!!, name)\n                try {\n                    log(name)\n                    sharedFlow.emit(a)\n                    log(\"$name resumes\")\n                    addAction(EmitResumes(job))\n                } catch(e: CancellationException) {\n                    log(\"$name cancelled\")\n                    addAction(Cancelled(job))\n                }\n            }\n            return TestJob(job, name)\n        }\n\n        fun expectReplayOf(vararg a: T) {\n            expectedReplay = a.toList()\n            checkReplay()\n        }\n\n        fun emitRightNow(a: T) {\n            val job = launchEmit(a)\n            assertTrue(actions.remove(EmitResumes(job)))\n        }\n\n        fun emitSuspends(a: T): TestJob {\n            val job = launchEmit(a)\n            assertFalse(EmitResumes(job) in actions)\n            checkReplay()\n            return job\n        }\n\n        suspend fun emitResumes(job: TestJob) {\n            awaitAction(EmitResumes(job))\n        }\n\n        suspend fun cancel(job: TestJob) {\n            log(\"cancel(${job.name})\")\n            job.job.cancel()\n            awaitAction(Cancelled(job))\n        }\n\n        fun subscribe(id: String): TestJob {\n            val name = \"collect($id)\"\n            val job = scope.launch(start = CoroutineStart.UNDISPATCHED) {\n                val job = TestJob(coroutineContext[Job]!!, name)\n                try {\n                    awaitAction(ResumeCollecting(job))\n                    log(\"$name start\")\n                    sharedFlow.collect { value ->\n                        log(\"$name -> $value\")\n                        addAction(Collected(job, value))\n                        awaitAction(ResumeCollecting(job))\n                        log(\"$name -> $value resumes\")\n                    }\n                    error(\"$name completed\")\n                } catch(e: CancellationException) {\n                    log(\"$name cancelled\")\n                    addAction(Cancelled(job))\n                }\n            }\n            return TestJob(job, name)\n        }\n\n        // collect ~== resumeCollecting + awaitCollected (for each value)\n        suspend fun collect(job: TestJob, vararg a: T) {\n            for (value in a) {\n                checkReplay() // should not have changed\n                resumeCollecting(job)\n                awaitCollected(job, value)\n            }\n        }\n\n        suspend fun resumeCollecting(job: TestJob) {\n            addAction(ResumeCollecting(job))\n        }\n\n        suspend fun awaitCollected(job: TestJob, value: T) {\n            awaitAction(Collected(job, value))\n        }\n\n        fun stop() {\n            log(\"--- stop\")\n            scope.cancel()\n        }\n\n        private fun log(text: String) {\n            log.add(text)\n        }\n\n        fun printLog() {\n            println(\"--- The most recent log entries ---\")\n            log.takeLast(30).forEach(::println)\n            println(\"--- That's it ---\")\n        }\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/SharedFlowTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.random.*\nimport kotlin.test.*\n\n/**\n * This test suite contains some basic tests for [SharedFlow]. There are some scenarios here written\n * using [expect] and they are not very readable. See [SharedFlowScenarioTest] for a better\n * behavioral test-suit.\n */\nclass SharedFlowTest : TestBase() {\n    @Test\n    fun testRendezvousSharedFlowBasic() = runTest {\n        expect(1)\n        val sh = MutableSharedFlow<Int?>()\n        assertTrue(sh.replayCache.isEmpty())\n        assertEquals(0, sh.subscriptionCount.value)\n        sh.emit(1) // no suspend\n        assertTrue(sh.replayCache.isEmpty())\n        assertEquals(0, sh.subscriptionCount.value)\n        expect(2)\n        // one collector\n        val job1 = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(3)\n            sh.collect {\n                when(it) {\n                    4 -> expect(5)\n                    6 -> expect(7)\n                    10 -> expect(11)\n                    13 -> expect(14)\n                    else -> expectUnreached()\n                }\n            }\n            expectUnreached() // does not complete normally\n        }\n        expect(4)\n        assertEquals(1, sh.subscriptionCount.value)\n        sh.emit(4)\n        assertTrue(sh.replayCache.isEmpty())\n        expect(6)\n        sh.emit(6)\n        expect(8)\n        // one more collector\n        val job2 = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(9)\n            sh.collect {\n                when(it) {\n                    10 -> expect(12)\n                    13 -> expect(15)\n                    17 -> expect(18)\n                    null -> expect(20)\n                    21 -> expect(22)\n                    else -> expectUnreached()\n                }\n            }\n            expectUnreached() // does not complete normally\n        }\n        expect(10)\n        assertEquals(2, sh.subscriptionCount.value)\n        sh.emit(10) // to both collectors now!\n        assertTrue(sh.replayCache.isEmpty())\n        expect(13)\n        sh.emit(13)\n        expect(16)\n        job1.cancel() // cancel the first collector\n        yield()\n        assertEquals(1, sh.subscriptionCount.value)\n        expect(17)\n        sh.emit(17) // only to second collector\n        expect(19)\n        sh.emit(null) // emit null to the second collector\n        expect(21)\n        sh.emit(21) // non-null again\n        expect(23)\n        job2.cancel() // cancel the second collector\n        yield()\n        assertEquals(0, sh.subscriptionCount.value)\n        expect(24)\n        sh.emit(24) // does not go anywhere\n        assertEquals(0, sh.subscriptionCount.value)\n        assertTrue(sh.replayCache.isEmpty())\n        finish(25)\n    }\n\n    @Test\n    fun testRendezvousSharedFlowReset() = runTest {\n        expect(1)\n        val sh = MutableSharedFlow<Int>()\n        val barrier = Channel<Unit>(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            sh.collect {\n                when (it) {\n                    3 -> {\n                        expect(4)\n                        barrier.receive() // hold on before collecting next one\n                    }\n                    6 -> expect(10)\n                    else -> expectUnreached()\n                }\n            }\n            expectUnreached() // does not complete normally\n        }\n        expect(3)\n        sh.emit(3) // rendezvous\n        expect(5)\n        assertFalse(sh.tryEmit(5)) // collector is not ready now\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(6)\n            sh.emit(6) // suspends\n            expect(12)\n        }\n        expect(7)\n        yield() // no wakeup -> all suspended\n        expect(8)\n        // now reset cache -> nothing happens, there is no cache\n        sh.resetReplayCache()\n        yield()\n        expect(9)\n        // now resume collector\n        barrier.send(Unit)\n        yield() // to collector\n        expect(11)\n        yield() // to emitter\n        expect(13)\n        assertFalse(sh.tryEmit(13)) // rendezvous does not work this way\n        job.cancel()\n        finish(14)\n    }\n\n    @Test\n    fun testReplay1SharedFlowBasic() = runTest {\n        expect(1)\n        val sh = MutableSharedFlow<Int?>(1)\n        assertTrue(sh.replayCache.isEmpty())\n        assertEquals(0, sh.subscriptionCount.value)\n        sh.emit(1) // no suspend\n        assertEquals(listOf(1), sh.replayCache)\n        assertEquals(0, sh.subscriptionCount.value)\n        expect(2)\n        sh.emit(2) // no suspend\n        assertEquals(listOf(2), sh.replayCache)\n        expect(3)\n        // one collector\n        val job1 = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(4)\n            sh.collect {\n                when(it) {\n                    2 -> expect(5) // got it immediately from replay cache\n                    6 -> expect(8)\n                    null -> expect(14)\n                    17 -> expect(18)\n                    else -> expectUnreached()\n                }\n            }\n            expectUnreached() // does not complete normally\n        }\n        expect(6)\n        assertEquals(1, sh.subscriptionCount.value)\n        sh.emit(6) // does not suspend, but buffers\n        assertEquals(listOf(6), sh.replayCache)\n        expect(7)\n        yield()\n        expect(9)\n        // one more collector\n        val job2 = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(10)\n            sh.collect {\n                when(it) {\n                    6 -> expect(11) // from replay cache\n                    null -> expect(15)\n                    else -> expectUnreached()\n                }\n            }\n            expectUnreached() // does not complete normally\n        }\n        expect(12)\n        assertEquals(2, sh.subscriptionCount.value)\n        sh.emit(null)\n        expect(13)\n        assertEquals(listOf(null), sh.replayCache)\n        yield()\n        assertEquals(listOf(null), sh.replayCache)\n        expect(16)\n        job2.cancel()\n        yield()\n        assertEquals(1, sh.subscriptionCount.value)\n        expect(17)\n        sh.emit(17)\n        assertEquals(listOf(17), sh.replayCache)\n        yield()\n        expect(19)\n        job1.cancel()\n        yield()\n        assertEquals(0, sh.subscriptionCount.value)\n        assertEquals(listOf(17), sh.replayCache)\n        finish(20)\n    }\n\n    @Test\n    fun testReplay1() = runTest {\n        expect(1)\n        val sh = MutableSharedFlow<Int>(1)\n        assertEquals(listOf(), sh.replayCache)\n        val barrier = Channel<Unit>(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            sh.collect {\n                when (it) {\n                    3 -> {\n                        expect(4)\n                        barrier.receive() // collector waits\n                    }\n                    5 -> expect(10)\n                    6 -> expect(11)\n                    else -> expectUnreached()\n                }\n            }\n            expectUnreached() // does not complete normally\n        }\n        expect(3)\n        assertTrue(sh.tryEmit(3)) // buffered\n        assertEquals(listOf(3), sh.replayCache)\n        yield() // to collector\n        expect(5)\n        assertTrue(sh.tryEmit(5)) // buffered\n        assertEquals(listOf(5), sh.replayCache)\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(6)\n            sh.emit(6) // buffer full, suspended\n            expect(13)\n        }\n        expect(7)\n        assertEquals(listOf(5), sh.replayCache)\n        sh.resetReplayCache() // clear cache\n        assertEquals(listOf(), sh.replayCache)\n        expect(8)\n        yield() // emitter still suspended\n        expect(9)\n        assertEquals(listOf(), sh.replayCache)\n        assertFalse(sh.tryEmit(10)) // still no buffer space\n        assertEquals(listOf(), sh.replayCache)\n        barrier.send(Unit) // resume collector\n        yield() // to collector\n        expect(12)\n        yield() // to emitter, that should have resumed\n        expect(14)\n        job.cancel()\n        assertEquals(listOf(6), sh.replayCache)\n        finish(15)\n    }\n\n    @Test\n    fun testReplay2Extra1() = runTest {\n        expect(1)\n        val sh = MutableSharedFlow<Int>(\n            replay = 2,\n            extraBufferCapacity = 1\n        )\n        assertEquals(listOf(), sh.replayCache)\n        assertTrue(sh.tryEmit(0))\n        assertEquals(listOf(0), sh.replayCache)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            var cnt = 0\n            sh.collect {\n                when (it) {\n                    0 -> when (cnt++) {\n                        0 -> expect(3)\n                        1 -> expect(14)\n                        else -> expectUnreached()\n                    }\n                    1 -> expect(6)\n                    2 -> expect(7)\n                    3 -> expect(8)\n                    4 -> expect(12)\n                    5 -> expect(13)\n                    16 -> expect(17)\n                    else -> expectUnreached()\n                }\n            }\n            expectUnreached() // does not complete normally\n        }\n        expect(4)\n        assertTrue(sh.tryEmit(1)) // buffered\n        assertEquals(listOf(0, 1), sh.replayCache)\n        assertTrue(sh.tryEmit(2)) // buffered\n        assertEquals(listOf(1, 2), sh.replayCache)\n        assertTrue(sh.tryEmit(3)) // buffered (buffer size is 3)\n        assertEquals(listOf(2, 3), sh.replayCache)\n        expect(5)\n        yield() // to collector\n        expect(9)\n        assertEquals(listOf(2, 3), sh.replayCache)\n        assertTrue(sh.tryEmit(4)) // can buffer now\n        assertEquals(listOf(3, 4), sh.replayCache)\n        assertTrue(sh.tryEmit(5)) // can buffer now\n        assertEquals(listOf(4, 5), sh.replayCache)\n        assertTrue(sh.tryEmit(0)) // can buffer one more, let it be zero again\n        assertEquals(listOf(5, 0), sh.replayCache)\n        expect(10)\n        assertFalse(sh.tryEmit(10)) // cannot buffer anymore!\n        sh.resetReplayCache() // replay cache\n        assertEquals(listOf(), sh.replayCache) // empty\n        assertFalse(sh.tryEmit(0)) // still cannot buffer anymore (reset does not help)\n        assertEquals(listOf(), sh.replayCache) // empty\n        expect(11)\n        yield() // resume collector, will get next values\n        expect(15)\n        sh.resetReplayCache() // reset again, nothing happens\n        assertEquals(listOf(), sh.replayCache) // empty\n        yield() // collector gets nothing -- no change\n        expect(16)\n        assertTrue(sh.tryEmit(16))\n        assertEquals(listOf(16), sh.replayCache)\n        yield() // gets it\n        expect(18)\n        job.cancel()\n        finish(19)\n    }\n\n    @Test\n    fun testBufferNoReplayCancelWhileBuffering() = runTest {\n        val n = 123\n        val sh = MutableSharedFlow<Int>(replay = 0, extraBufferCapacity = n)\n        repeat(3) {\n            val m = n / 2 // collect half, then suspend\n            val barrier = Channel<Int>(1)\n            val collectorJob = sh\n                .onSubscription {\n                    barrier.send(1)\n                }\n                .onEach { value ->\n                    if (value == m) {\n                        barrier.send(2)\n                        delay(Long.MAX_VALUE)\n                    }\n                }\n                .launchIn(this)\n            assertEquals(1, barrier.receive()) // make sure it subscribes\n            launch(start = CoroutineStart.UNDISPATCHED) {\n                for (i in 0 until n + m) sh.emit(i) // these emits should go Ok\n                barrier.send(3)\n                sh.emit(n + 4) // this emit will suspend on buffer overflow\n                barrier.send(4)\n            }\n            assertEquals(2, barrier.receive()) // wait until m collected\n            assertEquals(3, barrier.receive()) // wait until all are emitted\n            collectorJob.cancel() // cancelling collector job must clear buffer and resume emitter\n            assertEquals(4, barrier.receive()) // verify that emitter resumes\n        }\n    }\n\n    @Test\n    fun testRepeatedResetWithReplay() = runTest {\n        val n = 10\n        val sh = MutableSharedFlow<Int>(n)\n        var i = 0\n        repeat(3) {\n            // collector is slow\n            val collector = sh.onEach { delay(Long.MAX_VALUE) }.launchIn(this)\n            val emitter = launch {\n                repeat(3 * n) { sh.emit(i); i++ }\n            }\n            repeat(3) { yield() } // enough to run it to suspension\n            assertEquals((i - n until i).toList(), sh.replayCache)\n            sh.resetReplayCache()\n            assertEquals(emptyList(), sh.replayCache)\n            repeat(3) { yield() } // enough to run it to suspension\n            assertEquals(emptyList(), sh.replayCache) // still blocked\n            collector.cancel()\n            emitter.cancel()\n            repeat(3) { yield() } // enough to run it to suspension\n        }\n    }\n\n    @Test\n    fun testSynchronousSharedFlowEmitterCancel() = runTest {\n        expect(1)\n        val sh = MutableSharedFlow<Int>()\n        val barrier1 = Job()\n        val barrier2 = Job()\n        val barrier3 = Job()\n        val collector1 = sh.onEach {\n            when (it) {\n                1 ->  expect(3)\n                2 -> {\n                    expect(6)\n                    barrier2.complete()\n                }\n                3 -> {\n                    expect(9)\n                    barrier3.complete()\n                }\n                else -> expectUnreached()\n            }\n        }.launchIn(this)\n        val collector2 = sh.onEach {\n            when (it) {\n                1 -> {\n                    expect(4)\n                    barrier1.complete()\n                    delay(Long.MAX_VALUE)\n                }\n                else -> expectUnreached()\n            }\n        }.launchIn(this)\n        repeat(2) { yield() } // launch both subscribers\n        val emitter = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            sh.emit(1)\n            barrier1.join()\n            expect(5)\n            sh.emit(2) // suspends because of slow collector2\n            expectUnreached() // will be cancelled\n        }\n        barrier2.join() // wait\n        expect(7)\n        // Now cancel the emitter!\n        emitter.cancel()\n        yield()\n        // Cancel slow collector\n        collector2.cancel()\n        yield()\n        // emit to fast collector1\n        expect(8)\n        sh.emit(3)\n        barrier3.join()\n        expect(10)\n        //  cancel it, too\n        collector1.cancel()\n        finish(11)\n    }\n\n    @Test\n    fun testDifferentBufferedFlowCapacities() = runTest {\n        if (isBoundByJsTestTimeout) return@runTest // Too slow for JS, bounded by 2 sec. default JS timeout\n        for (replay in 0..10) {\n            for (extraBufferCapacity in 0..5) {\n                if (replay == 0 && extraBufferCapacity == 0) continue // test only buffered shared flows\n                try {\n                    val sh = MutableSharedFlow<Int>(replay, extraBufferCapacity)\n                    // repeat the whole test a few times to make sure it works correctly when slots are reused\n                    repeat(3) {\n                        testBufferedFlow(sh, replay)\n                    }\n                } catch (e: Throwable) {\n                    error(\"Failed for replay=$replay, extraBufferCapacity=$extraBufferCapacity\", e)\n                }\n            }\n        }\n    }\n\n    private suspend fun testBufferedFlow(sh: MutableSharedFlow<Int>, replay: Int) = withContext(Job()) {\n        reset()\n        expect(1)\n        val n = 100 // initially emitted to fill buffer\n        for (i in 1..n) assertTrue(sh.tryEmit(i))\n        // initial expected replayCache\n        val rcStart = n - replay + 1\n        val rcRange = rcStart..n\n        val rcSize = n - rcStart + 1\n        assertEquals(rcRange.toList(), sh.replayCache)\n        // create collectors\n        val m = 10 // collectors created\n        var ofs = 0\n        val k = 42 // emissions to collectors\n        val ecRange = n + 1..n + k\n        val jobs = List(m) { jobIndex ->\n            launch(start = CoroutineStart.UNDISPATCHED) {\n                sh.collect { i ->\n                    when (i) {\n                        in rcRange -> expect(2 + i - rcStart + jobIndex * rcSize)\n                        in ecRange -> expect(2 + ofs + jobIndex)\n                        else -> expectUnreached()\n                    }\n                }\n                expectUnreached() // does not complete normally\n            }\n        }\n        ofs = rcSize * m + 2\n        expect(ofs)\n        // emit to all k times\n        for (p in ecRange) {\n            sh.emit(p)\n            expect(1 + ofs) // buffered, no suspend\n            yield()\n            ofs += 2 + m\n            expect(ofs)\n        }\n        assertEquals(ecRange.toList().takeLast(replay), sh.replayCache)\n        // cancel all collectors\n        jobs.forEach { it.cancel() }\n        yield()\n        // replay cache is still there\n        assertEquals(ecRange.toList().takeLast(replay), sh.replayCache)\n        finish(1 + ofs)\n    }\n\n    @Test\n    fun testDropLatest() = testDropLatestOrOldest(BufferOverflow.DROP_LATEST)\n\n    @Test\n    fun testDropOldest() = testDropLatestOrOldest(BufferOverflow.DROP_OLDEST)\n\n    private fun testDropLatestOrOldest(bufferOverflow: BufferOverflow) = runTest {\n        reset()\n        expect(1)\n        val sh = MutableSharedFlow<Int?>(1, onBufferOverflow = bufferOverflow)\n        sh.emit(1)\n        sh.emit(2)\n        // always keeps last w/o collectors\n        assertEquals(listOf(2), sh.replayCache)\n        assertEquals(0, sh.subscriptionCount.value)\n        // one collector\n        val valueAfterOverflow = when (bufferOverflow) {\n            BufferOverflow.DROP_OLDEST -> 5\n            BufferOverflow.DROP_LATEST -> 4\n            else -> error(\"not supported in this test: $bufferOverflow\")\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            sh.collect {\n                when(it) {\n                    2 -> { // replayed\n                        expect(3)\n                        yield() // and suspends, busy waiting\n                    }\n                    valueAfterOverflow -> expect(7)\n                    8 -> expect(9)\n                    else -> expectUnreached()\n                }\n            }\n            expectUnreached() // does not complete normally\n        }\n        expect(4)\n        assertEquals(1, sh.subscriptionCount.value)\n        assertEquals(listOf(2), sh.replayCache)\n        sh.emit(4) // buffering, collector is busy\n        assertEquals(listOf(4), sh.replayCache)\n        expect(5)\n        sh.emit(5) // Buffer overflow here, will not suspend\n        assertEquals(listOf(valueAfterOverflow), sh.replayCache)\n        expect(6)\n        yield() // to the job\n        expect(8)\n        sh.emit(8) // not busy now\n        assertEquals(listOf(8), sh.replayCache) // buffered\n        yield() // to process\n        expect(10)\n        job.cancel() // cancel the job\n        yield()\n        assertEquals(0, sh.subscriptionCount.value)\n        finish(11)\n    }\n\n    @Test\n    public fun testOnSubscription() = runTest {\n        expect(1)\n        val sh = MutableSharedFlow<String>()\n        fun share(s: String) { launch(start = CoroutineStart.UNDISPATCHED) { sh.emit(s) } }\n        sh\n            .onSubscription {\n                emit(\"collector->A\")\n                share(\"share->A\")\n            }\n            .onSubscription {\n                emit(\"collector->B\")\n                share(\"share->B\")\n            }\n            .onStart {\n                emit(\"collector->C\")\n                share(\"share->C\") // get's lost, no subscribers yet\n            }\n            .onStart {\n                emit(\"collector->D\")\n                share(\"share->D\") // get's lost, no subscribers yet\n            }\n            .onEach {\n                when (it) {\n                    \"collector->D\" -> expect(2)\n                    \"collector->C\" -> expect(3)\n                    \"collector->A\" -> expect(4)\n                    \"collector->B\" -> expect(5)\n                    \"share->A\" -> expect(6)\n                    \"share->B\" -> {\n                        expect(7)\n                        currentCoroutineContext().cancel()\n                    }\n                    else -> expectUnreached()\n                }\n            }\n            .launchIn(this)\n            .join()\n        finish(8)\n    }\n\n    @Test\n    @Suppress(\"DEPRECATION\") // 'catch'\n    fun onSubscriptionThrows() = runTest {\n        expect(1)\n        val sh = MutableSharedFlow<String>(1)\n        sh.tryEmit(\"OK\") // buffer a string\n        assertEquals(listOf(\"OK\"), sh.replayCache)\n        sh\n            .onSubscription {\n                expect(2)\n                throw TestException()\n            }\n            .catch { e ->\n                assertIs<TestException>(e)\n                expect(3)\n            }\n            .collect {\n                // onSubscription throw before replay is emitted, so no value is collected if it throws\n                expectUnreached()\n            }\n        assertEquals(0, sh.subscriptionCount.value)\n        finish(4)\n    }\n\n    @Test\n    fun testBigReplayManySubscribers() = testManySubscribers(true)\n\n    @Test\n    fun testBigBufferManySubscribers() = testManySubscribers(false)\n\n    private fun testManySubscribers(replay: Boolean) = runTest {\n        val n = 100\n        val rnd = Random(replay.hashCode())\n        val sh = MutableSharedFlow<Int>(\n            replay = if (replay) n else 0,\n            extraBufferCapacity = if (replay) 0 else n\n        )\n        val subs = ArrayList<SubJob>()\n        for (i in 1..n) {\n            sh.emit(i)\n            val subBarrier = Channel<Unit>()\n            val subJob = SubJob()\n            subs += subJob\n            // will receive all starting from replay or from new emissions only\n            subJob.lastReceived = if (replay) 0 else i\n            subJob.job = sh\n                .onSubscription {\n                    subBarrier.send(Unit) // signal subscribed\n                }\n                .onEach { value ->\n                    assertEquals(subJob.lastReceived + 1, value)\n                    subJob.lastReceived = value\n                }\n                .launchIn(this)\n            subBarrier.receive() // wait until subscribed\n            // must have also receive all from the replay buffer directly after being subscribed\n            assertEquals(subJob.lastReceived, i)\n            // 50% of time cancel one subscriber\n            if (i % 2 == 0) {\n                val victim = subs.removeAt(rnd.nextInt(subs.size))\n                yield() // make sure victim processed all emissions\n                assertEquals(victim.lastReceived, i)\n                victim.job.cancel()\n            }\n        }\n        yield() // make sure the last emission is processed\n        for (subJob in subs) {\n            assertEquals(subJob.lastReceived, n)\n            subJob.job.cancel()\n        }\n    }\n\n    private class SubJob {\n        lateinit var job: Job\n        var lastReceived = 0\n    }\n\n    @Test\n    fun testStateFlowModel() = runTest {\n        if (isBoundByJsTestTimeout) return@runTest // Too slow for JS, bounded by 2 sec. default JS timeout\n        val stateFlow = MutableStateFlow<Data?>(null)\n        val expect = modelLog(stateFlow)\n        val sharedFlow = MutableSharedFlow<Data?>(\n            replay = 1,\n            onBufferOverflow = BufferOverflow.DROP_OLDEST\n        )\n        sharedFlow.tryEmit(null) // initial value\n        val actual = modelLog(sharedFlow) { distinctUntilChanged() }\n        for (i in 0 until minOf(expect.size, actual.size)) {\n            if (actual[i] != expect[i]) {\n                for (j in maxOf(0, i - 10)..i) println(\"Actual log item #$j: ${actual[j]}\")\n                assertEquals(expect[i], actual[i], \"Log item #$i\")\n            }\n        }\n        assertEquals(expect.size, actual.size)\n    }\n\n    private suspend fun modelLog(\n        sh: MutableSharedFlow<Data?>,\n        op: Flow<Data?>.() -> Flow<Data?> = { this }\n    ): List<String> = coroutineScope {\n        val rnd = Random(1)\n        val result = ArrayList<String>()\n        val job = launch {\n            sh.op().collect { value ->\n                result.add(\"Collect: $value\")\n                repeat(rnd.nextInt(0..2)) {\n                    result.add(\"Collect: yield\")\n                    yield()\n                }\n            }\n        }\n        repeat(1000) {\n            val value = if (rnd.nextBoolean()) null else rnd.nextData()\n            if (rnd.nextInt(20) == 0) {\n                result.add(\"resetReplayCache & emit: $value\")\n                if (sh !is StateFlow<*>) sh.resetReplayCache()\n                assertTrue(sh.tryEmit(value))\n            } else {\n                result.add(\"Emit: $value\")\n                sh.emit(value)\n            }\n            repeat(rnd.nextInt(0..2)) {\n                result.add(\"Emit: yield\")\n                yield()\n            }\n        }\n        result.add(\"main: cancel\")\n        job.cancel()\n        result.add(\"main: yield\")\n        yield()\n        result.add(\"main: join\")\n        job.join()\n        result\n    }\n\n    data class Data(val x: Int)\n    private val dataCache = (1..5).associateWith { Data(it) }\n\n    // Note that we test proper null support here, too\n    private fun Random.nextData(): Data? {\n        val x = nextInt(0..5)\n        if (x == 0) return null\n        // randomly reuse ref or create a new instance\n        return if(nextBoolean()) dataCache[x] else Data(x)\n    }\n\n    @Test\n    fun testOperatorFusion() {\n        val sh = MutableSharedFlow<String>()\n        assertSame(sh, (sh as Flow<*>).cancellable())\n        assertSame(sh, (sh as Flow<*>).flowOn(Dispatchers.Default))\n        assertSame(sh, sh.buffer(Channel.RENDEZVOUS))\n    }\n\n    @Test\n    fun testIllegalArgumentException() {\n        assertFailsWith<IllegalArgumentException> { MutableSharedFlow<Int>(-1) }\n        assertFailsWith<IllegalArgumentException> { MutableSharedFlow<Int>(0, extraBufferCapacity = -1) }\n        assertFailsWith<IllegalArgumentException> { MutableSharedFlow<Int>(0, onBufferOverflow = BufferOverflow.DROP_LATEST) }\n        assertFailsWith<IllegalArgumentException> { MutableSharedFlow<Int>(0, onBufferOverflow = BufferOverflow.DROP_OLDEST) }\n    }\n\n    @Test\n    public fun testReplayCancellability() = testCancellability(fromReplay = true)\n\n    @Test\n    public fun testEmitCancellability() = testCancellability(fromReplay = false)\n\n    private fun testCancellability(fromReplay: Boolean) = runTest {\n        expect(1)\n        val sh = MutableSharedFlow<Int>(5)\n        fun emitTestData() {\n            for (i in 1..5) assertTrue(sh.tryEmit(i))\n        }\n        if (fromReplay) emitTestData() // fill in replay first\n        var subscribed = true\n        val job = sh\n            .onSubscription { subscribed = true }\n            .onEach { i ->\n                when (i) {\n                    1 -> expect(2)\n                    2 -> expect(3)\n                    3 -> {\n                        expect(4)\n                        currentCoroutineContext().cancel()\n                    }\n                    else -> expectUnreached() // shall check for cancellation\n                }\n            }\n            .launchIn(this)\n        yield()\n        assertTrue(subscribed) // yielding in enough\n        if (!fromReplay) emitTestData() // emit after subscription\n        job.join()\n        finish(5)\n    }\n\n    @Test\n    fun testSubscriptionCount() = runTest {\n        val flow = MutableSharedFlow<Int>()\n        fun startSubscriber() = launch(start = CoroutineStart.UNDISPATCHED) { flow.collect() }\n\n        assertEquals(0, flow.subscriptionCount.first())\n\n        val j1 = startSubscriber()\n        assertEquals(1, flow.subscriptionCount.first())\n\n        val j2 = startSubscriber()\n        assertEquals(2, flow.subscriptionCount.first())\n\n        j1.cancelAndJoin()\n        assertEquals(1, flow.subscriptionCount.first())\n\n        j2.cancelAndJoin()\n        assertEquals(0, flow.subscriptionCount.first())\n    }\n\n    @Test\n    fun testSubscriptionByFirstSuspensionInSharedFlow() = runTest {\n        testSubscriptionByFirstSuspensionInCollect(MutableSharedFlow()) { emit(it) }\n    }\n}\n\n/**\n * Check that, by the time [SharedFlow.collect] suspends for the first time, its subscription is already active.\n */\ninline fun<T: Flow<Int>> CoroutineScope.testSubscriptionByFirstSuspensionInCollect(flow: T, emit: T.(Int) -> Unit) {\n    var received = 0\n    val job = launch(start = CoroutineStart.UNDISPATCHED) {\n        flow.collect {\n            received = it\n        }\n    }\n    flow.emit(1)\n    assertEquals(1, received)\n    job.cancel()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/SharingStartedTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n/**\n * Functional tests for [SharingStarted] using [withVirtualTime] and a DSL to describe\n * testing scenarios and expected behavior for different implementations.\n */\nclass SharingStartedTest : TestBase() {\n    @Test\n    fun testEagerly() =\n        testSharingStarted(SharingStarted.Eagerly, SharingCommand.START) {\n            subscriptions(1)\n            rampUpAndDown()\n            subscriptions(0)\n            delay(100)\n        }\n\n    @Test\n    fun testLazily() =\n        testSharingStarted(SharingStarted.Lazily) {\n            subscriptions(1, SharingCommand.START)\n            rampUpAndDown()\n            subscriptions(0)\n        }\n\n    @Test\n    fun testWhileSubscribed() =\n        testSharingStarted(SharingStarted.WhileSubscribed()) {\n            subscriptions(1, SharingCommand.START)\n            rampUpAndDown()\n            subscriptions(0, SharingCommand.STOP)\n            delay(100)\n        }\n\n    @Test\n    fun testWhileSubscribedExpireImmediately() =\n        testSharingStarted(SharingStarted.WhileSubscribed(replayExpirationMillis = 0)) {\n            subscriptions(1, SharingCommand.START)\n            rampUpAndDown()\n            subscriptions(0, SharingCommand.STOP_AND_RESET_REPLAY_CACHE)\n            delay(100)\n        }\n\n    @Test\n    fun testWhileSubscribedWithTimeout() =\n        testSharingStarted(SharingStarted.WhileSubscribed(stopTimeoutMillis = 100)) {\n            subscriptions(1, SharingCommand.START)\n            rampUpAndDown()\n            subscriptions(0)\n            delay(50) // don't give it time to stop\n            subscriptions(1) // resubscribe again\n            rampUpAndDown()\n            subscriptions(0)\n            afterTime(100, SharingCommand.STOP)\n            delay(100)\n        }\n\n    @Test\n    fun testWhileSubscribedExpiration() =\n        testSharingStarted(SharingStarted.WhileSubscribed(replayExpirationMillis = 200)) {\n            subscriptions(1, SharingCommand.START)\n            rampUpAndDown()\n            subscriptions(0, SharingCommand.STOP)\n            delay(150) // don't give it time to reset cache\n            subscriptions(1, SharingCommand.START)\n            rampUpAndDown()\n            subscriptions(0, SharingCommand.STOP)\n            afterTime(200, SharingCommand.STOP_AND_RESET_REPLAY_CACHE)\n        }\n\n    @Test\n    fun testWhileSubscribedStopAndExpiration() =\n        testSharingStarted(SharingStarted.WhileSubscribed(stopTimeoutMillis = 400, replayExpirationMillis = 300)) {\n            subscriptions(1, SharingCommand.START)\n            rampUpAndDown()\n            subscriptions(0)\n            delay(350) // don't give it time to stop\n            subscriptions(1)\n            rampUpAndDown()\n            subscriptions(0)\n            afterTime(400, SharingCommand.STOP)\n            delay(250) // don't give it time to reset cache\n            subscriptions(1, SharingCommand.START)\n            rampUpAndDown()\n            subscriptions(0)\n            afterTime(400, SharingCommand.STOP)\n            afterTime(300, SharingCommand.STOP_AND_RESET_REPLAY_CACHE)\n            delay(100)\n        }\n\n    private suspend fun SharingStartedDsl.rampUpAndDown() {\n        for (i in 2..10) {\n            delay(100)\n            subscriptions(i)\n        }\n        delay(1000)\n        for (i in 9 downTo 1) {\n            subscriptions(i)\n            delay(100)\n        }\n    }\n\n    private fun testSharingStarted(\n        started: SharingStarted,\n        initialCommand: SharingCommand? = null,\n        scenario: suspend SharingStartedDsl.() -> Unit\n    ) = withVirtualTime {\n        expect(1)\n        val dsl = SharingStartedDsl(started, initialCommand, coroutineContext)\n        dsl.launch()\n        // repeat every scenario 3 times\n        repeat(3) {\n            dsl.scenario()\n            delay(1000)\n        }\n        dsl.stop()\n        finish(2)\n    }\n\n    private class SharingStartedDsl(\n        val started: SharingStarted,\n        initialCommand: SharingCommand?,\n        coroutineContext: CoroutineContext\n    ) {\n        val subscriptionCount = MutableStateFlow(0)\n        var previousCommand: SharingCommand? = null\n        var expectedCommand: SharingCommand? = initialCommand\n        var expectedTime = 0L\n\n        val dispatcher = coroutineContext[ContinuationInterceptor] as VirtualTimeDispatcher\n        val scope = CoroutineScope(coroutineContext + Job())\n\n        suspend fun launch() {\n            started\n                .command(subscriptionCount.asStateFlow())\n                .onEach { checkCommand(it) }\n                .launchIn(scope)\n            letItRun()\n        }\n\n        fun checkCommand(command: SharingCommand) {\n            assertTrue(command != previousCommand)\n            previousCommand = command\n            assertEquals(expectedCommand, command)\n            assertEquals(expectedTime, dispatcher.currentTime)\n        }\n\n        suspend fun subscriptions(count: Int, command: SharingCommand? = null) {\n            expectedTime = dispatcher.currentTime\n            subscriptionCount.value = count\n            if (command != null) {\n                afterTime(0, command)\n            } else {\n                letItRun()\n            }\n        }\n\n        suspend fun afterTime(time: Long = 0, command: SharingCommand) {\n            expectedCommand = command\n            val remaining = (time - 1).coerceAtLeast(0) // previous letItRun delayed 1ms\n            expectedTime += remaining\n            delay(remaining)\n            letItRun()\n        }\n\n        private suspend fun letItRun() {\n            delay(1)\n            assertEquals(expectedCommand, previousCommand) // make sure expected command was emitted\n            expectedTime++ // make one more time tick we've delayed\n        }\n\n        fun stop() {\n            scope.cancel()\n        }\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/SharingStartedWhileSubscribedTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\nclass SharingStartedWhileSubscribedTest : TestBase() {\n    @Test // make sure equals works properly, or otherwise other tests don't make sense\n    fun testEqualsAndHashcode() {\n        val params = listOf(0L, 1L, 10L, 100L, 213L, Long.MAX_VALUE)\n        // HashMap will simultaneously test equals, hashcode and their consistency\n        val map = HashMap<SharingStarted, Pair<Long, Long>>()\n        for (i in params) {\n            for (j in params) {\n                map[SharingStarted.WhileSubscribed(i, j)] = i to j\n            }\n        }\n        for (i in params) {\n            for (j in params) {\n                assertEquals(i to j, map[SharingStarted.WhileSubscribed(i, j)])\n            }\n        }\n    }\n\n    @Test\n    fun testDurationParams() {\n        assertEquals(SharingStarted.WhileSubscribed(0), SharingStarted.WhileSubscribed(Duration.ZERO))\n        assertEquals(SharingStarted.WhileSubscribed(10), SharingStarted.WhileSubscribed(10.milliseconds))\n        assertEquals(SharingStarted.WhileSubscribed(1000), SharingStarted.WhileSubscribed(1.seconds))\n        assertEquals(SharingStarted.WhileSubscribed(Long.MAX_VALUE), SharingStarted.WhileSubscribed(Duration.INFINITE))\n        assertEquals(SharingStarted.WhileSubscribed(replayExpirationMillis = 0), SharingStarted.WhileSubscribed(replayExpiration = Duration.ZERO))\n        assertEquals(SharingStarted.WhileSubscribed(replayExpirationMillis = 3), SharingStarted.WhileSubscribed(\n            replayExpiration = 3.milliseconds\n        ))\n        assertEquals(SharingStarted.WhileSubscribed(replayExpirationMillis = 7000),\n            SharingStarted.WhileSubscribed(replayExpiration = 7.seconds))\n        assertEquals(SharingStarted.WhileSubscribed(replayExpirationMillis = Long.MAX_VALUE), SharingStarted.WhileSubscribed(replayExpiration = Duration.INFINITE))\n    }\n\n    @Test\n    fun testShouldRestart() = runTest {\n        var started = 0\n        val flow = flow {\n            expect(1 + ++started)\n            emit(1)\n            hang {  }\n        }.shareIn(this, SharingStarted.WhileSubscribed(100 /* ms */))\n\n        expect(1)\n        flow.first()\n        delay(200)\n        flow.first()\n        finish(4)\n        coroutineContext.job.cancelChildren()\n    }\n\n    @Test\n    fun testImmediateUnsubscribe() = runTest {\n        val flow = flow {\n            expect(2)\n            emit(1)\n            hang { finish(4) }\n        }.shareIn(this, SharingStarted.WhileSubscribed(400, 0 /* ms */), 1)\n\n        expect(1)\n        repeat(5) {\n            flow.first()\n            delay(100)\n        }\n        expect(3)\n        coroutineContext.job.cancelChildren()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/StateFlowTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass StateFlowTest : TestBase() {\n    @Test\n    fun testNormalAndNull() = runTest {\n        expect(1)\n        val state = MutableStateFlow<Int?>(0)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            assertFailsWith<CancellationException> {\n                state.collect { value ->\n                    when (value) {\n                        0 -> expect(3)\n                        1 -> expect(5)\n                        null -> expect(8)\n                        2 -> expect(10)\n                        else -> expectUnreached()\n                    }\n                }\n            }\n            expect(12)\n        }\n        expect(4) // collector is waiting\n        state.value = 1 // fire in the hole!\n        assertEquals(1, state.value)\n        yield()\n        expect(6)\n        state.value = 1 // same value, nothing happens\n        yield()\n        expect(7)\n        state.value = null // null value\n        assertNull(state.value)\n        yield()\n        expect(9)\n        state.value = 2 // another value\n        assertEquals(2, state.value)\n        yield()\n        expect(11)\n        job.cancel()\n        yield()\n        finish(13)\n    }\n\n    @Test\n    fun testEqualsConflation() = runTest {\n        expect(1)\n        val state = MutableStateFlow(Data(0))\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            assertFailsWith<CancellationException> {\n                state.collect { value ->\n                    when (value.i) {\n                        0 -> expect(3) // initial value\n                        2 -> expect(5)\n                        4 -> expect(7)\n                        else -> error(\"Unexpected $value\")\n                    }\n                }\n            }\n            expect(9)\n        }\n        state.value = Data(1) // conflated\n        state.value = Data(0) // equals to last emitted\n        yield() // no repeat zero\n        state.value = Data(3) // conflated\n        state.value = Data(2) // delivered\n        expect(4)\n        yield()\n        state.value = Data(2) // equals to last one, dropped\n        yield()\n        state.value = Data(5) // conflated\n        state.value = Data(4) // delivered\n        expect(6)\n        yield()\n        expect(8)\n        job.cancel()\n        yield()\n        finish(10)\n    }\n\n    data class Data(val i: Int)\n\n    @Test\n    fun testDataModel() = runTest {\n        val s = CounterModel()\n        launch {\n            val sum = s.counter.take(11).sum()\n            assertEquals(55, sum)\n        }\n        repeat(10) {\n            yield()\n            s.inc()\n        }\n    }\n\n    class CounterModel {\n        // private data flow\n        private val _counter = MutableStateFlow(0)\n\n        // publicly exposed as a flow\n        val counter: StateFlow<Int> get() = _counter\n\n        fun inc() {\n            _counter.value++\n        }\n    }\n\n    @Test\n    public fun testOnSubscriptionWithException() = runTest {\n        expect(1)\n        val state = MutableStateFlow(\"A\")\n        state\n            .onSubscription {\n                emit(\"collector->A\")\n                state.value = \"A\"\n            }\n            .onSubscription {\n                emit(\"collector->B\")\n                state.value = \"B\"\n                throw TestException()\n            }\n            .onStart {\n                emit(\"collector->C\")\n                state.value = \"C\"\n            }\n            .onStart {\n                emit(\"collector->D\")\n                state.value = \"D\"\n            }\n            .onEach {\n                when (it) {\n                    \"collector->D\" -> expect(2)\n                    \"collector->C\" -> expect(3)\n                    \"collector->A\" -> expect(4)\n                    \"collector->B\" -> expect(5)\n                    else -> expectUnreached()\n                }\n            }\n            .catch { e ->\n                assertIs<TestException>(e)\n                expect(6)\n            }\n            .launchIn(this)\n            .join()\n        assertEquals(0, state.subscriptionCount.value)\n        finish(7)\n    }\n\n    @Test\n    fun testOperatorFusion() {\n        val state = MutableStateFlow(String)\n        assertSame(state, (state as Flow<*>).cancellable())\n        assertSame(state, (state as Flow<*>).distinctUntilChanged())\n        assertSame(state, (state as Flow<*>).flowOn(Dispatchers.Default))\n        assertSame(state, (state as Flow<*>).conflate())\n        assertSame(state, state.buffer(Channel.CONFLATED))\n        assertSame(state, state.buffer(Channel.RENDEZVOUS))\n    }\n\n    @Test\n    fun testResetUnsupported() {\n        val state = MutableStateFlow(42)\n        assertFailsWith<UnsupportedOperationException> { state.resetReplayCache() }\n        assertEquals(42, state.value)\n        assertEquals(listOf(42), state.replayCache)\n    }\n\n    @Test\n    fun testUpdate() = runTest {\n        val state = MutableStateFlow(0)\n        state.update { it + 2 }\n        assertEquals(2, state.value)\n        state.update { it + 3 }\n        assertEquals(5, state.value)\n    }\n\n    @Test\n    fun testSubscriptionByFirstSuspensionInStateFlow() = runTest {\n        testSubscriptionByFirstSuspensionInCollect(MutableStateFlow(0)) { value = it; yield() }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/sharing/StateInTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\n/**\n * It is mostly covered by [ShareInTest], this just add state-specific checks.\n */\nclass StateInTest : TestBase() {\n    @Test\n    fun testOperatorFusion() = runTest {\n        val state = flowOf(\"OK\").stateIn(this)\n        assertTrue(state !is MutableStateFlow<*>) // cannot be cast to mutable state flow\n        assertSame(state, (state as Flow<*>).cancellable())\n        assertSame(state, (state as Flow<*>).distinctUntilChanged())\n        assertSame(state, (state as Flow<*>).flowOn(Dispatchers.Default))\n        assertSame(state, (state as Flow<*>).conflate())\n        assertSame(state, state.buffer(Channel.CONFLATED))\n        assertSame(state, state.buffer(Channel.RENDEZVOUS))\n        assertSame(state, state.buffer(onBufferOverflow = BufferOverflow.DROP_OLDEST))\n        assertSame(state, state.buffer(0, onBufferOverflow = BufferOverflow.DROP_OLDEST))\n        assertSame(state, state.buffer(1, onBufferOverflow = BufferOverflow.DROP_OLDEST))\n        coroutineContext.cancelChildren()\n    }\n\n    @Test\n    fun testUpstreamCompletedNoInitialValue() =\n        testUpstreamCompletedOrFailedReset(failed = false, withInitialValue = false)\n\n    @Test\n    fun testUpstreamFailedNoInitialValue() =\n        testUpstreamCompletedOrFailedReset(failed = true, withInitialValue = false)\n\n    @Test\n    fun testUpstreamCompletedWithInitialValue() =\n        testUpstreamCompletedOrFailedReset(failed = false, withInitialValue = true)\n\n    @Test\n    fun testUpstreamFailedWithInitialValue() =\n        testUpstreamCompletedOrFailedReset(failed = true, withInitialValue = true)\n\n    private fun testUpstreamCompletedOrFailedReset(failed: Boolean, withInitialValue: Boolean) = runTest {\n        val emitted = Job()\n        val terminate = Job()\n        val sharingJob = CompletableDeferred<Unit>()\n        val upstream = flow {\n            emit(\"OK\")\n            emitted.complete()\n            terminate.join()\n            if (failed) throw TestException()\n        }\n        val scope = this + sharingJob\n        val shared: StateFlow<String?>\n        if (withInitialValue) {\n            shared = upstream.stateIn(scope, SharingStarted.Eagerly, null)\n            assertEquals(null, shared.value)\n        } else {\n            shared = upstream.stateIn(scope)\n            assertEquals(\"OK\", shared.value) // waited until upstream emitted\n        }\n        emitted.join() // should start sharing, emit & cache\n        assertEquals(\"OK\", shared.value)\n        terminate.complete()\n        sharingJob.complete(Unit)\n        sharingJob.join() // should complete sharing\n        assertEquals(\"OK\", shared.value) // value is still there\n        if (failed) {\n            assertIs<TestException>(sharingJob.getCompletionExceptionOrNull())\n        } else {\n            assertNull(sharingJob.getCompletionExceptionOrNull())\n        }\n    }\n\n    @Test\n    fun testUpstreamFailedImmediatelyWithInitialValue() = runTest {\n        val ceh = CoroutineExceptionHandler { _, _ -> expect(2) }\n        val flow = flow<Int> {\n            expect(1)\n            throw TestException()\n        }\n        assertFailsWith<TestException> { flow.stateIn(CoroutineScope(currentCoroutineContext() + Job() + ceh)) }\n        finish(3)\n    }\n\n    @Test\n    fun testSubscriptionByFirstSuspensionInStateFlow() = runTest {\n        testSubscriptionByFirstSuspensionInCollect(flowOf(1).stateIn(this@runTest)) { }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/terminal/CollectLatestTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass CollectLatestTest : TestBase() {\n    @Test\n    fun testNoSuspension() = runTest {\n        flowOf(1, 2, 3).collectLatest {\n            expect(it)\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testSuspension() = runTest {\n        flowOf(1, 2, 3).collectLatest {\n            yield()\n            expect(1)\n        }\n        finish(2)\n    }\n\n    @Test\n    fun testUpstreamErrorSuspension() = runTest({it is TestException}) {\n        try {\n            flow {\n                emit(1)\n                throw TestException()\n            }.collectLatest { expect(1) }\n            expectUnreached()\n        } finally {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testDownstreamError() = runTest({it is TestException}) {\n        try {\n            flow {\n                emit(1)\n                hang { expect(1) }\n            }.collectLatest {\n                throw TestException()\n            }\n            expectUnreached()\n        } finally {\n            finish(2)\n        }\n\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/terminal/CountTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass CountTest : TestBase() {\n    @Test\n    fun testCount() = runTest {\n        val flow = flowOf(239, 240)\n        assertEquals(2, flow.count())\n        assertEquals(2, flow.count { true })\n        assertEquals(1, flow.count { it % 2 == 0})\n        assertEquals(0, flow.count { false })\n    }\n\n    @Test\n    fun testNoValues() = runTest {\n        assertEquals(0, flowOf<Int>().count())\n        assertEquals(0, flowOf<Int>().count { false })\n        assertEquals(0, flowOf<Int>().count { true })\n    }\n\n    @Test\n    fun testException() = runTest {\n        val flow = flow<Int> {\n            throw TestException()\n        }\n\n        assertFailsWith<TestException> { flow.count() }\n        assertFailsWith<TestException> { flow.count { false } }\n    }\n\n    @Test\n    fun testExceptionAfterValue() = runTest {\n        val flow = flow {\n            emit(1)\n            throw TestException()\n        }\n\n        assertFailsWith<TestException> { flow.count() }\n        assertFailsWith<TestException> { flow.count { false } }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/terminal/FirstTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlin.test.*\n\nclass FirstTest : TestBase() {\n    @Test\n    fun testFirst() = runTest {\n        val flow = flowOf(1, 2, 3)\n        assertEquals(1, flow.first())\n    }\n\n    @Test\n    fun testNulls() = runTest {\n        val flow = flowOf(null, 1)\n        assertNull(flow.first())\n        assertNull(flow.first { it == null })\n        assertEquals(1, flow.first { it != null })\n    }\n\n    @Test\n    fun testFirstWithPredicate() = runTest {\n        val flow = flowOf(1, 2, 3)\n        assertEquals(1, flow.first { it > 0 })\n        assertEquals(2, flow.first { it > 1 })\n        assertFailsWith<NoSuchElementException> { flow.first { it > 3 } }\n    }\n\n    @Test\n    fun testFirstCancellation() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang { expect(1) }\n                }\n                emit(1)\n                emit(2)\n            }\n        }\n\n\n        val result = flow.first {\n            latch.receive()\n            true\n        }\n        assertEquals(1, result)\n        finish(2)\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        assertFailsWith<NoSuchElementException> { emptyFlow<Int>().first() }\n        assertFailsWith<NoSuchElementException> { emptyFlow<Int>().first { true } }\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang { expect(1) }\n                }\n                emit(1)\n            }\n        }\n\n        assertFailsWith<TestException> {\n            flow.first {\n                latch.receive()\n                throw TestException()\n            }\n        }\n\n        assertEquals(1, flow.first())\n        finish(2)\n    }\n\n    @Test\n    fun testFirstOrNull() = runTest {\n        val flow = flowOf(1, 2, 3)\n        assertEquals(1, flow.firstOrNull())\n    }\n\n    @Test\n    fun testFirstOrNullWithPredicate() = runTest {\n        val flow = flowOf(1, 2, 3)\n        assertEquals(1, flow.firstOrNull { it > 0 })\n        assertEquals(2, flow.firstOrNull { it > 1 })\n        assertNull(flow.firstOrNull { it > 3 })\n    }\n\n    @Test\n    fun testFirstOrNullCancellation() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang { expect(1) }\n                }\n                emit(1)\n                emit(2)\n            }\n        }\n\n\n        val result = flow.firstOrNull {\n            latch.receive()\n            true\n        }\n        assertEquals(1, result)\n        finish(2)\n    }\n\n    @Test\n    fun testFirstOrNullWithEmptyFlow() = runTest {\n        assertNull(emptyFlow<Int>().firstOrNull())\n        assertNull(emptyFlow<Int>().firstOrNull { true })\n    }\n\n    @Test\n    fun testFirstOrNullWithNullElement() = runTest {\n        assertNull(flowOf<String?>(null).firstOrNull())\n        assertNull(flowOf<String?>(null).firstOrNull { true })\n    }\n\n    @Test\n    fun testFirstOrNullWhenErrorCancelsUpstream() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    hang { expect(1) }\n                }\n                emit(1)\n            }\n        }\n\n        assertFailsWith<TestException> {\n            flow.firstOrNull {\n                latch.receive()\n                throw TestException()\n            }\n        }\n\n        assertEquals(1, flow.firstOrNull())\n        finish(2)\n    }\n\n    @Test\n    fun testBadClass() = runTest {\n        val instance = BadClass()\n        val flow = flowOf(instance)\n        assertSame(instance, flow.first())\n        assertSame(instance, flow.firstOrNull())\n        assertSame(instance, flow.first { true })\n        assertSame(instance, flow.firstOrNull { true })\n    }\n\n    @Test\n    fun testAbortFlowException() = runTest {\n        val flow = flow<Int> {\n            throw AbortFlowException(NopCollector) // Emulate cancellation\n        }\n\n        assertFailsWith<CancellationException> { flow.first() }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/terminal/FoldTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass FoldTest : TestBase() {\n    @Test\n    fun testFold() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(2)\n        }\n\n        val result = flow.fold(3) { value, acc -> value + acc }\n        assertEquals(6, result)\n    }\n\n    @Test\n    fun testEmptyFold() = runTest {\n        val flow = flowOf<Int>()\n        assertEquals(42, flow.fold(42) { value, acc -> value + acc })\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    expect(3)\n                    hang { expect(5) }\n                }\n                expect(2)\n                emit(1)\n            }\n        }\n\n        expect(1)\n        assertFailsWith<TestException> {\n            flow.fold(42) { _, _ ->\n                latch.receive()\n                expect(4)\n                throw TestException()\n            }\n        }\n        finish(6)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/terminal/LastTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass LastTest : TestBase() {\n    @Test\n    fun testLast() = runTest {\n        val flow = flowOf(1, 2, 3)\n        assertEquals(3, flow.last())\n        assertEquals(3, flow.lastOrNull())\n    }\n\n    @Test\n    fun testNulls() = runTest {\n        val flow = flowOf(1, null)\n        assertNull(flow.last())\n        assertNull(flow.lastOrNull())\n    }\n\n    @Test\n    fun testNullsLastOrNull() = runTest {\n        val flow = flowOf(null, 1)\n        assertEquals(1, flow.lastOrNull())\n    }\n\n    @Test\n    fun testEmptyFlow() = runTest {\n        assertFailsWith<NoSuchElementException> { emptyFlow<Int>().last() }\n        assertNull(emptyFlow<Int>().lastOrNull())\n    }\n\n    @Test\n    fun testBadClass() = runTest {\n        val instance = BadClass()\n        val flow = flowOf(instance)\n        assertSame(instance, flow.last())\n        assertSame(instance, flow.lastOrNull())\n\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/terminal/LaunchInTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass LaunchInTest : TestBase() {\n\n    @Test\n    fun testLaunchIn() = runTest {\n        val flow = flow {\n            expect(1)\n            emit(1)\n            throw TestException()\n        }.onEach {\n            assertEquals(1, it)\n            expect(2)\n        }.onCompletion {\n            assertIs<TestException>(it)\n            expect(3)\n        }.catch {\n            assertTrue { it is TestException }\n            expect(4)\n        }\n\n        flow.launchIn(this).join()\n        finish(5)\n    }\n\n    @Test\n    fun testDispatcher() = runTest {\n        flow {\n            assertEquals(\"flow\", NamedDispatchers.name())\n            emit(1)\n            expect(1)\n        }.launchIn(this + NamedDispatchers(\"flow\")).join()\n        finish(2)\n    }\n\n    @Test\n    fun testUnhandledError() = runTest(expected = { it is TestException }) {\n        flow {\n            emit(1)\n            expect(1)\n        }.catch {\n            expectUnreached()\n        }.onCompletion {\n            finish(2)\n            throw TestException()\n        }.launchIn(this)\n    }\n\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/terminal/ReduceTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass ReduceTest : TestBase() {\n    @Test\n    fun testReduce() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(2)\n        }\n\n        val result = flow.reduce { value, acc -> value + acc }\n        assertEquals(3, result)\n    }\n\n    @Test\n    fun testEmptyReduce() = runTest {\n        val flow = emptyFlow<Int>()\n        assertFailsWith<NoSuchElementException> { flow.reduce { acc, value -> value + acc } }\n    }\n\n    @Test\n    fun testNullableReduce() = runTest {\n        val flow = flowOf(1, null, null, 2)\n        var invocations = 0\n        val sum = flow.reduce { _, value ->\n            ++invocations\n            value\n        }\n        assertEquals(2, sum)\n        assertEquals(3, invocations)\n    }\n\n    @Test\n    fun testReduceNulls() = runTest {\n        assertNull(flowOf(null).reduce { _, value -> value })\n        assertNull(flowOf(null, null).reduce { _, value -> value })\n        assertFailsWith<NoSuchElementException> { flowOf<Nothing?>().reduce { _, value -> value } }\n    }\n\n    @Test\n    fun testErrorCancelsUpstream() = runTest {\n        val latch = Channel<Unit>()\n        val flow = flow {\n            coroutineScope {\n                launch {\n                    latch.send(Unit)\n                    expect(3)\n                    hang { expect(5) }\n                }\n                expect(2)\n                emit(1)\n                emit(2)\n            }\n        }\n\n        expect(1)\n        assertFailsWith<TestException> {\n            flow.reduce { _, _ ->\n                latch.receive()\n                expect(4)\n                throw TestException()\n            }\n        }\n        finish(6)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/terminal/SingleTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass SingleTest : TestBase() {\n\n    @Test\n    fun testSingle() = runTest {\n        val flow = flow {\n            emit(239L)\n        }\n\n        assertEquals(239L, flow.single())\n        assertEquals(239L, flow.singleOrNull())\n    }\n\n    @Test\n    fun testMultipleValues() = runTest {\n        val flow = flow {\n            emit(239L)\n            emit(240L)\n        }\n        assertFailsWith<IllegalArgumentException> { flow.single() }\n        assertNull(flow.singleOrNull())\n    }\n\n    @Test\n    fun testNoValues() = runTest {\n        assertFailsWith<NoSuchElementException> { flow<Int> {}.single() }\n        assertNull(flow<Int> {}.singleOrNull())\n    }\n\n    @Test\n    fun testException() = runTest {\n        val flow = flow<Int> {\n            throw TestException()\n        }\n\n        assertFailsWith<TestException> { flow.single() }\n        assertFailsWith<TestException> { flow.singleOrNull() }\n    }\n\n    @Test\n    fun testExceptionAfterValue() = runTest {\n        val flow = flow {\n            emit(1)\n            throw TestException()\n        }\n\n        assertFailsWith<TestException> { flow.single() }\n        assertFailsWith<TestException> { flow.singleOrNull() }\n    }\n\n    @Test\n    fun testNullableSingle() = runTest {\n        assertEquals(1, flowOf<Int?>(1).single())\n        assertNull(flowOf<Int?>(null).single())\n        assertFailsWith<NoSuchElementException> { flowOf<Int?>().single() }\n\n        assertEquals(1, flowOf<Int?>(1).singleOrNull())\n        assertNull(flowOf<Int?>(null).singleOrNull())\n        assertNull(flowOf<Int?>().singleOrNull())\n    }\n\n    @Test\n    fun testBadClass() = runTest {\n        val instance = BadClass()\n        val flow = flowOf(instance)\n        assertSame(instance, flow.single())\n        assertSame(instance, flow.singleOrNull())\n\n        val flow2 = flow {\n            emit(BadClass())\n            emit(BadClass())\n        }\n        assertFailsWith<IllegalArgumentException> { flow2.single() }\n    }\n\n    @Test\n    fun testSingleNoWait() = runTest {\n        val flow = flow {\n            emit(1)\n            emit(2)\n            awaitCancellation()\n        }\n\n        assertNull(flow.singleOrNull())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/flow/terminal/ToCollectionTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass ToCollectionTest : TestBase() {\n\n    private val flow = flow {\n        repeat(10) {\n            emit(42)\n        }\n    }\n\n    private val emptyFlow = flowOf<Int>()\n\n    @Test\n    fun testToList() = runTest {\n        assertEquals(List(10) { 42 }, flow.toList())\n        assertEquals(emptyList(), emptyFlow.toList())\n    }\n\n    @Test\n    fun testToSet() = runTest {\n        assertEquals(setOf(42), flow.toSet())\n        assertEquals(emptySet(), emptyFlow.toSet())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectBiasTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass SelectBiasTest : TestBase() {\n    val n = 10_000\n\n    @Test\n    fun testBiased() = runTest {\n        val d0 = async { 0 }\n        val d1 = async { 1 }\n        val counter = IntArray(2)\n        repeat(n) {\n            val selected = select<Int> {\n                d0.onAwait { 0 }\n                d1.onAwait { 1 }\n            }\n            counter[selected]++\n        }\n        assertEquals(n, counter[0])\n        assertEquals(0, counter[1])\n    }\n\n    @Test\n    fun testUnbiased() = runTest {\n        val d0 = async { 0 }\n        val d1 = async { 1 }\n        val counter = IntArray(2)\n        repeat(n) {\n            val selected = selectUnbiased<Int> {\n                d0.onAwait { 0 }\n                d1.onAwait { 1 }\n            }\n            counter[selected]++\n        }\n        assertTrue(counter[0] >= n / 4)\n        assertTrue(counter[1] >= n / 4)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectBufferedChannelTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass SelectBufferedChannelTest : TestBase() {\n\n    @Test\n    fun testSelectSendSuccess() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        launch {\n            expect(2)\n            assertEquals(\"OK\", channel.receive())\n            finish(6)\n        }\n        yield() // to launched coroutine\n        expect(3)\n        select<Unit> {\n            channel.onSend(\"OK\") {\n                expect(4)\n            }\n        }\n        expect(5)\n    }\n\n    @Test\n    fun testSelectSendSuccessWithDefault() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        launch {\n            expect(2)\n            assertEquals(\"OK\", channel.receive())\n            finish(6)\n        }\n        yield() // to launched coroutine\n        expect(3)\n        select<Unit> {\n            channel.onSend(\"OK\") {\n                expect(4)\n            }\n            default {\n                expectUnreached()\n            }\n        }\n        expect(5)\n    }\n\n    @Test\n    fun testSelectSendReceiveBuf() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        select<Unit> {\n            channel.onSend(\"OK\") {\n                expect(2)\n            }\n        }\n        expect(3)\n        select<Unit> {\n            channel.onReceive { v ->\n                expect(4)\n                assertEquals(\"OK\", v)\n            }\n        }\n        finish(5)\n    }\n\n    @Test\n    fun testSelectSendWait() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        launch {\n            expect(4)\n            assertEquals(\"BUF\", channel.receive())\n            expect(5)\n            assertEquals(\"OK\", channel.receive())\n            expect(6)\n        }\n        expect(2)\n        channel.send(\"BUF\")\n        expect(3)\n        select<Unit> {\n            channel.onSend(\"OK\") {\n                expect(7)\n            }\n        }\n        finish(8)\n    }\n\n    @Test\n    fun testSelectReceiveSuccess() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        channel.send(\"OK\")\n        expect(2)\n        select<Unit> {\n            channel.onReceive { v ->\n                expect(3)\n                assertEquals(\"OK\", v)\n            }\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testSelectReceiveSuccessWithDefault() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        channel.send(\"OK\")\n        expect(2)\n        select<Unit> {\n            channel.onReceive { v ->\n                expect(3)\n                assertEquals(\"OK\", v)\n            }\n            default {\n                expectUnreached()\n            }\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testSelectReceiveWaitWithDefault() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        select<Unit> {\n            channel.onReceive {\n                expectUnreached()\n            }\n            default {\n                expect(2)\n            }\n        }\n        expect(3)\n        channel.send(\"BUF\")\n        expect(4)\n        // make sure second send blocks (select above is over)\n        launch {\n            expect(6)\n            channel.send(\"CHK\")\n            finish(10)\n        }\n        expect(5)\n        yield()\n        expect(7)\n        assertEquals(\"BUF\", channel.receive())\n        expect(8)\n        assertEquals(\"CHK\", channel.receive())\n        expect(9)\n    }\n\n    @Test\n    fun testSelectReceiveWait() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        launch {\n            expect(3)\n            channel.send(\"OK\")\n            expect(4)\n        }\n        expect(2)\n        select<Unit> {\n            channel.onReceive { v ->\n                expect(5)\n                assertEquals(\"OK\", v)\n            }\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testSelectReceiveClosed() = runTest({it is ClosedReceiveChannelException}) {\n        expect(1)\n        val channel = Channel<String>(1)\n        channel.close()\n        finish(2)\n        select<Unit> {\n            channel.onReceive {\n                expectUnreached()\n            }\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testSelectReceiveWaitClosed() = runTest({it is ClosedReceiveChannelException}) {\n        expect(1)\n        val channel = Channel<String>(1)\n        launch {\n            expect(3)\n            channel.close()\n            finish(4)\n        }\n        expect(2)\n        select<Unit> {\n            channel.onReceive {\n                expectUnreached()\n            }\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testSelectSendResourceCleanup() = runTest {\n        val channel = Channel<Int>(1)\n        val n = 1000\n        expect(1)\n        channel.send(-1) // fill the buffer, so all subsequent sends cannot proceed\n        repeat(n) { i ->\n            select {\n                channel.onSend(i) { expectUnreached() }\n                default { expect(i + 2) }\n            }\n        }\n        finish(n + 2)\n    }\n\n    @Test\n    fun testSelectReceiveResourceCleanup() = runTest {\n        val channel = Channel<Int>(1)\n        val n = 1000\n        expect(1)\n        repeat(n) { i ->\n            select {\n                channel.onReceive { expectUnreached() }\n                default { expect(i + 2) }\n            }\n        }\n        finish(n + 2)\n    }\n\n    @Test\n    fun testSelectReceiveDispatchNonSuspending() = runTest {\n        val channel = Channel<Int>(1)\n        expect(1)\n        channel.send(42)\n        expect(2)\n        launch {\n            expect(4)\n            select<Unit> {\n                channel.onReceive { v ->\n                    expect(5)\n                    assertEquals(42, v)\n                    expect(6)\n                }\n            }\n            expect(7) // returns from select without further dispatch\n        }\n        expect(3)\n        yield() // to launched\n        finish(8)\n    }\n\n    @Test\n    fun testSelectReceiveDispatchNonSuspending2() = runTest {\n        val channel = Channel<Int>(1)\n        expect(1)\n        channel.send(42)\n        expect(2)\n        launch {\n            expect(4)\n            select<Unit> {\n                channel.onReceive { v ->\n                    expect(5)\n                    assertEquals(42, v)\n                    expect(6)\n                    yield() // back to main\n                    expect(8)\n                }\n            }\n            expect(9) // returns from select without further dispatch\n        }\n        expect(3)\n        yield() // to launched\n        expect(7)\n        yield() // again\n        finish(10)\n    }\n\n    @Test\n    fun testSelectReceiveOrClosedWaitClosed() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        launch {\n            expect(3)\n            channel.close()\n            expect(4)\n        }\n        expect(2)\n        select<Unit> {\n            channel.onReceiveCatching {\n                expect(5)\n                assertTrue(it.isClosed)\n                assertNull(it.exceptionOrNull())\n            }\n        }\n\n        finish(6)\n    }\n\n    @Test\n    fun testSelectReceiveOrClosedWaitClosedWithCause() = runTest {\n        expect(1)\n        val channel = Channel<String>(1)\n        launch {\n            expect(3)\n            channel.close(TestException())\n            expect(4)\n        }\n        expect(2)\n        select<Unit> {\n            channel.onReceiveCatching {\n                expect(5)\n                assertTrue(it.isClosed)\n                assertIs<TestException>(it.exceptionOrNull())\n            }\n        }\n\n        finish(6)\n    }\n\n    @Test\n    fun testSelectReceiveCatching() = runTest {\n        val c = Channel<Int>(1)\n        val iterations = 10\n        expect(1)\n        val job = launch {\n            repeat(iterations) {\n                select<Unit> {\n                    c.onReceiveCatching { v ->\n                        expect(4 + it * 2)\n                        assertEquals(it, v.getOrNull())\n                    }\n                }\n            }\n        }\n\n        expect(2)\n        repeat(iterations) {\n            expect(3 + it * 2)\n            c.send(it)\n            yield()\n        }\n\n        job.join()\n        finish(3 + iterations * 2)\n    }\n\n    @Test\n    fun testSelectReceiveOrClosedDispatch() = runTest {\n        val c = Channel<Int>(1)\n        expect(1)\n        launch {\n            expect(3)\n            val res = select<String> {\n                c.onReceiveCatching { v ->\n                    expect(6)\n                    assertEquals(42, v.getOrNull())\n                    yield() // back to main\n                    expect(8)\n                    \"OK\"\n                }\n            }\n            expect(9)\n            assertEquals(\"OK\", res)\n        }\n        expect(2)\n        yield() // to launch\n        expect(4)\n        c.send(42) // do not suspend\n        expect(5)\n        yield() // to receive\n        expect(7)\n        yield() // again\n        finish(10)\n    }\n\n    // only for debugging\n    internal fun <R> SelectBuilder<R>.default(block: suspend () -> R) = onTimeout(0, block)\n\n    @Test\n    fun testSelectReceiveOrClosedForClosedChannel() = runTest {\n        val channel = Channel<Int>(1)\n        channel.close()\n        expect(1)\n        select<Unit> {\n            expect(2)\n            channel.onReceiveCatching {\n                assertTrue(it.isClosed)\n                assertNull(it.exceptionOrNull())\n                finish(3)\n            }\n        }\n    }\n\n    @Test\n    fun testSelectReceiveOrClosedForClosedChannelWithValue() = runTest {\n        val channel = Channel<Int>(1)\n        channel.send(42)\n        channel.close()\n        expect(1)\n        select<Unit> {\n            expect(2)\n            channel.onReceiveCatching {\n                assertFalse(it.isClosed)\n                assertEquals(42, it.getOrNull())\n                finish(3)\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectDeferredTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\nimport kotlin.time.Duration.Companion.seconds\n\nclass SelectDeferredTest : TestBase() {\n    @Test\n    fun testSimpleReturnsImmediately() = runTest {\n        expect(1)\n        val d1 = async {\n            expect(3)\n            42\n        }\n        expect(2)\n        val res = select<String> {\n            d1.onAwait { v ->\n                expect(4)\n                assertEquals(42, v)\n                \"OK\"\n            }\n        }\n        expect(5)\n        assertEquals(\"OK\", res)\n        finish(6)\n    }\n\n    @Test\n    fun testSimpleWithYield() = runTest {\n        expect(1)\n        val d1 = async {\n            expect(3)\n            42\n        }\n        launch {\n            expect(4)\n            yield() // back to main\n            expect(6)\n        }\n        expect(2)\n        val res = select<String> {\n            d1.onAwait { v ->\n                expect(5)\n                assertEquals(42, v)\n                yield() // to launch\n                expect(7)\n                \"OK\"\n            }\n        }\n        finish(8)\n        assertEquals(\"OK\", res)\n    }\n\n    @Test\n    fun testSelectIncompleteLazy() = runTest {\n        expect(1)\n        val d1 = async(start = CoroutineStart.LAZY) {\n            expect(5)\n            42\n        }\n        launch {\n            expect(3)\n            val res = select<String> {\n                d1.onAwait { v ->\n                    expect(7)\n                    assertEquals(42, v)\n                    \"OK\"\n                }\n            }\n            expect(8)\n            assertEquals(\"OK\", res)\n        }\n        expect(2)\n        yield() // to launch\n        expect(4)\n        yield() // to started async\n        expect(6)\n        yield() // to triggered select\n        finish(9)\n    }\n\n    @Test\n    fun testSelectTwo() = runTest {\n        expect(1)\n        val d1 = async {\n            expect(3)\n            yield() // to the other deffered\n            expect(5)\n            yield() // to fired select\n            expect(7)\n            \"d1\"\n        }\n        val d2 = async {\n            expect(4)\n            \"d2\" // returns result\n        }\n        expect(2)\n        val res = select<String> {\n            d1.onAwait {\n                expectUnreached()\n                \"FAIL\"\n            }\n            d2.onAwait { v2 ->\n                expect(6)\n                assertEquals(\"d2\", v2)\n                yield() // to first deferred\n                expect(8)\n                \"OK\"\n            }\n        }\n        assertEquals(\"OK\", res)\n        finish(9)\n    }\n\n    /**\n     * Tests that completing a [Deferred] with an exception will cause the [select] that uses [Deferred.onAwait]\n     * to throw the same exception.\n     */\n    @Test\n    fun testSelectFailure() = runTest {\n        val d = CompletableDeferred<Nothing>()\n        d.completeExceptionally(TestException())\n        val d2 = CompletableDeferred(42)\n        assertFailsWith<TestException> {\n            select {\n                d.onAwait { expectUnreached() }\n                d2.onAwait { 4 }\n            }\n        }\n    }\n\n    @Test\n    fun testSelectCancel() = runTest(\n        expected = { it is CancellationException }\n    ) {\n        expect(1)\n        val d = CompletableDeferred<String>()\n        launch {\n            finish(3)\n            d.cancel() // will cancel after select starts\n        }\n        expect(2)\n        select<Unit> {\n            d.onAwait {\n                expectUnreached() // will not select\n            }\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testSelectIncomplete() = runTest {\n        val deferred = async { Wrapper(\"OK\") }\n        val result = select<Wrapper> {\n            assertFalse(deferred.isCompleted)\n            assertTrue(deferred.isActive)\n            deferred.onAwait {\n                it\n            }\n        }\n\n        assertEquals(\"OK\", result.value)\n    }\n\n    @Test\n    fun testSelectIncompleteFastPath() = runTest {\n        val deferred = async(Dispatchers.Unconfined) { Wrapper(\"OK\") }\n        val result = select<Wrapper> {\n            assertTrue(deferred.isCompleted)\n            assertFalse(deferred.isActive)\n            deferred.onAwait {\n                it\n            }\n        }\n\n        assertEquals(\"OK\", result.value)\n    }\n\n    private class Wrapper(val value: String) : Incomplete {\n        override val isActive: Boolean\n            get() = error(\"\")\n        override val list: NodeList?\n            get() = error(\"\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectJobTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass SelectJobTest : TestBase() {\n    @Test\n    fun testSelectCompleted() = runTest {\n        expect(1)\n        launch { // makes sure we don't yield to it earlier\n            finish(4) // after main exits\n        }\n        val job = Job()\n        job.cancel()\n        select<Unit> {\n            job.onJoin {\n                expect(2)\n            }\n        }\n        expect(3)\n        // will wait for the first coroutine\n    }\n\n    @Test\n    fun testSelectIncomplete() = runTest {\n        expect(1)\n        val job = Job()\n        launch { // makes sure we don't yield to it earlier\n            expect(3)\n            val res = select<String> {\n                job.onJoin {\n                    expect(6)\n                    \"OK\"\n                }\n            }\n            expect(7)\n            assertEquals(\"OK\", res)\n        }\n        expect(2)\n        yield()\n        expect(4)\n        job.cancel()\n        expect(5)\n        yield()\n        finish(8)\n    }\n\n    @Test\n    fun testSelectLazy() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.LAZY) {\n            expect(2)\n        }\n        val res = select<String> {\n            job.onJoin {\n                expect(3)\n                \"OK\"\n            }\n        }\n        finish(4)\n        assertEquals(\"OK\", res)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectLoopTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass SelectLoopTest : TestBase() {\n    // https://github.com/Kotlin/kotlinx.coroutines/issues/1130\n    @Test\n    fun testChannelSelectLoop() = runTest(\n        expected = { it is TestException }\n    ) {\n        expect(1)\n        val channel = Channel<Unit>()\n        val job = launch {\n            expect(2)\n            channel.send(Unit)\n            expect(3)\n            throw TestException()\n        }\n        try {\n            while (true) {\n                select<Unit> {\n                    channel.onReceiveCatching {\n                        expectUnreached()\n                    }\n                    job.onJoin {\n                        expectUnreached()\n                    }\n                }\n            }\n        } catch (e: CancellationException) {\n            // select will get cancelled because of the failure of job\n            finish(4)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectMutexTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.test.*\n\nclass SelectMutexTest : TestBase() {\n    @Test\n    fun testSelectLock() = runTest {\n        val mutex = Mutex()\n        expect(1)\n        launch { // ensure that it is not scheduled earlier than needed\n            finish(4) // after main exits\n        }\n        val res = select<String> {\n            mutex.onLock {\n                assertTrue(mutex.isLocked)\n                expect(2)\n                \"OK\"\n            }\n        }\n        assertEquals(\"OK\", res)\n        expect(3)\n        // will wait for the first coroutine\n    }\n\n    @Test\n    fun testSelectLockWait() = runTest {\n        val mutex = Mutex(true) // locked\n        expect(1)\n        launch {\n            expect(3)\n            val res = select<String> {\n                // will suspended\n                mutex.onLock {\n                    assertTrue(mutex.isLocked)\n                    expect(6)\n                    \"OK\"\n                }\n            }\n            assertEquals(\"OK\", res)\n            expect(7)\n        }\n        expect(2)\n        yield() // to launched coroutine\n        expect(4)\n        mutex.unlock()\n        expect(5)\n        yield() // to resumed select\n        finish(8)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectOldTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass SelectOldTest : TestBase() {\n    @Test\n    fun testSelectCompleted() = runTest {\n        expect(1)\n        launch { // makes sure we don't yield to it earlier\n            finish(4) // after main exits\n        }\n        val job = Job()\n        job.cancel()\n        selectOld<Unit> {\n            job.onJoin {\n                expect(2)\n            }\n        }\n        expect(3)\n        // will wait for the first coroutine\n    }\n\n    @Test\n    fun testSelectUnbiasedCompleted() = runTest {\n        expect(1)\n        launch { // makes sure we don't yield to it earlier\n            finish(4) // after main exits\n        }\n        val job = Job()\n        job.cancel()\n        selectUnbiasedOld<Unit> {\n            job.onJoin {\n                expect(2)\n            }\n        }\n        expect(3)\n        // will wait for the first coroutine\n    }\n\n    @Test\n    fun testSelectIncomplete() = runTest {\n        expect(1)\n        val job = Job()\n        launch { // makes sure we don't yield to it earlier\n            expect(3)\n            val res = selectOld<String> {\n                job.onJoin {\n                    expect(6)\n                    \"OK\"\n                }\n            }\n            expect(7)\n            assertEquals(\"OK\", res)\n        }\n        expect(2)\n        yield()\n        expect(4)\n        job.cancel()\n        expect(5)\n        yield()\n        finish(8)\n    }\n\n    @Test\n    fun testSelectUnbiasedIncomplete() = runTest {\n        expect(1)\n        val job = Job()\n        launch { // makes sure we don't yield to it earlier\n            expect(3)\n            val res = selectUnbiasedOld<String> {\n                job.onJoin {\n                    expect(6)\n                    \"OK\"\n                }\n            }\n            expect(7)\n            assertEquals(\"OK\", res)\n        }\n        expect(2)\n        yield()\n        expect(4)\n        job.cancel()\n        expect(5)\n        yield()\n        finish(8)\n    }\n\n    @Test\n    fun testSelectUnbiasedComplete() = runTest {\n        expect(1)\n        val job = Job()\n        job.complete()\n        expect(2)\n        val res = selectUnbiasedOld<String> {\n            job.onJoin {\n                expect(3)\n                \"OK\"\n            }\n        }\n        assertEquals(\"OK\", res)\n        finish(4)\n    }\n\n    @Test\n    fun testSelectUnbiasedThrows() = runTest {\n        try {\n            select<Unit> {\n                expect(1)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testSelectLazy() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.LAZY) {\n            expect(2)\n        }\n        val res = selectOld<String> {\n            job.onJoin {\n                expect(3)\n                \"OK\"\n            }\n        }\n        finish(4)\n        assertEquals(\"OK\", res)\n    }\n\n    @Test\n    fun testSelectUnbiasedLazy() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.LAZY) {\n            expect(2)\n        }\n        val res = selectUnbiasedOld<String> {\n            job.onJoin {\n                expect(3)\n                \"OK\"\n            }\n        }\n        finish(4)\n        assertEquals(\"OK\", res)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectRendezvousChannelTest.kt",
        "content": "@file:Suppress(\"NAMED_ARGUMENTS_NOT_ALLOWED\") // KT-21913\n\npackage kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass SelectRendezvousChannelTest : TestBase() {\n\n    @Test\n    fun testSelectSendSuccess() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        launch {\n            expect(2)\n            assertEquals(\"OK\", channel.receive())\n            finish(6)\n        }\n        yield() // to launched coroutine\n        expect(3)\n        select<Unit> {\n            channel.onSend(\"OK\") {\n                expect(4)\n            }\n        }\n        expect(5)\n    }\n\n    @Test\n    fun testSelectSendSuccessWithDefault() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        launch {\n            expect(2)\n            assertEquals(\"OK\", channel.receive())\n            finish(6)\n        }\n        yield() // to launched coroutine\n        expect(3)\n        select<Unit> {\n            channel.onSend(\"OK\") {\n                expect(4)\n            }\n            default {\n                expectUnreached()\n            }\n        }\n        expect(5)\n    }\n\n    @Test\n    fun testSelectSendWaitWithDefault() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        select<Unit> {\n            channel.onSend(\"OK\") {\n                expectUnreached()\n            }\n            default {\n                expect(2)\n            }\n        }\n        expect(3)\n        // make sure receive blocks (select above is over)\n        launch {\n            expect(5)\n            assertEquals(\"CHK\", channel.receive())\n            finish(8)\n        }\n        expect(4)\n        yield()\n        expect(6)\n        channel.send(\"CHK\")\n        expect(7)\n    }\n\n    @Test\n    fun testSelectSendWait() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        launch {\n            expect(3)\n            assertEquals(\"OK\", channel.receive())\n            expect(4)\n        }\n        expect(2)\n        select<Unit> {\n            channel.onSend(\"OK\") {\n                expect(5)\n            }\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testSelectReceiveSuccess() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        launch {\n            expect(2)\n            channel.send(\"OK\")\n            finish(6)\n        }\n        yield() // to launched coroutine\n        expect(3)\n        select<Unit> {\n            channel.onReceive { v ->\n                expect(4)\n                assertEquals(\"OK\", v)\n            }\n        }\n        expect(5)\n    }\n\n    @Test\n    fun testSelectReceiveSuccessWithDefault() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        launch {\n            expect(2)\n            channel.send(\"OK\")\n            finish(6)\n        }\n        yield() // to launched coroutine\n        expect(3)\n        select<Unit> {\n            channel.onReceive { v ->\n                expect(4)\n                assertEquals(\"OK\", v)\n            }\n            default {\n                expectUnreached()\n            }\n        }\n        expect(5)\n    }\n\n    @Test\n    fun testSelectReceiveWaitWithDefault() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        select<Unit> {\n            channel.onReceive {\n                expectUnreached()\n            }\n            default {\n                expect(2)\n            }\n        }\n        expect(3)\n        // make sure send blocks (select above is over)\n        launch {\n            expect(5)\n            channel.send(\"CHK\")\n            finish(8)\n        }\n        expect(4)\n        yield()\n        expect(6)\n        assertEquals(\"CHK\", channel.receive())\n        expect(7)\n    }\n\n    @Test\n    fun testSelectReceiveWait() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        launch {\n            expect(3)\n            channel.send(\"OK\")\n            expect(4)\n        }\n        expect(2)\n        select<Unit> {\n            channel.onReceive { v ->\n                expect(5)\n                assertEquals(\"OK\", v)\n            }\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testSelectReceiveClosed() = runTest(expected = { it is ClosedReceiveChannelException }) {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        channel.close()\n        finish(2)\n        select<Unit> {\n            channel.onReceive {\n                expectUnreached()\n            }\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testSelectReceiveWaitClosed() = runTest(expected = {it is ClosedReceiveChannelException}) {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        launch {\n            expect(3)\n            channel.close()\n            finish(4)\n        }\n        expect(2)\n        select<Unit> {\n            channel.onReceive {\n                expectUnreached()\n            }\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testSelectSendResourceCleanup() = runTest {\n        val channel = Channel<Int>(Channel.RENDEZVOUS)\n        val n = 1_000\n        expect(1)\n        repeat(n) { i ->\n            select {\n                channel.onSend(i) { expectUnreached() }\n                default { expect(i + 2) }\n            }\n        }\n        finish(n + 2)\n    }\n\n    @Test\n    fun testSelectReceiveResourceCleanup() = runTest {\n        val channel = Channel<Int>(Channel.RENDEZVOUS)\n        val n = 1_000\n        expect(1)\n        repeat(n) { i ->\n            select {\n                channel.onReceive { expectUnreached() }\n                default { expect(i + 2) }\n            }\n        }\n        finish(n + 2)\n    }\n\n    @Test\n    fun testSelectAtomicFailure() = runTest {\n        val c1 = Channel<Int>(Channel.RENDEZVOUS)\n        val c2 = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(3)\n            val res = select<String> {\n                c1.onReceive { v1 ->\n                    expect(4)\n                    assertEquals(42, v1)\n                    yield() // back to main\n                    expect(7)\n                    \"OK\"\n                }\n                c2.onReceive {\n                    \"FAIL\"\n                }\n            }\n            expect(8)\n            assertEquals(\"OK\", res)\n        }\n        expect(2)\n        c1.send(42) // send to coroutine, suspends\n        expect(5)\n        c2.close() // makes sure that selected expression does not fail!\n        expect(6)\n        yield() // back\n        finish(9)\n    }\n\n    @Test\n    fun testSelectWaitDispatch() = runTest {\n        val c = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(3)\n            val res = select<String> {\n                c.onReceive { v ->\n                    expect(6)\n                    assertEquals(42, v)\n                    yield() // back to main\n                    expect(8)\n                    \"OK\"\n                }\n            }\n            expect(9)\n            assertEquals(\"OK\", res)\n        }\n        expect(2)\n        yield() // to launch\n        expect(4)\n        c.send(42) // do not suspend\n        expect(5)\n        yield() // to receive\n        expect(7)\n        yield() // again\n        finish(10)\n    }\n\n    @Test\n    fun testSelectReceiveCatchingWaitClosed() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        launch {\n            expect(3)\n            channel.close()\n            expect(4)\n        }\n        expect(2)\n        select<Unit> {\n            channel.onReceiveCatching {\n                expect(5)\n                assertTrue(it.isClosed)\n                assertNull(it.exceptionOrNull())\n            }\n        }\n\n        finish(6)\n    }\n\n    @Test\n    fun testSelectReceiveCatchingWaitClosedWithCause() = runTest {\n        expect(1)\n        val channel = Channel<String>(Channel.RENDEZVOUS)\n        launch {\n            expect(3)\n            channel.close(TestException())\n            expect(4)\n        }\n        expect(2)\n        select<Unit> {\n            channel.onReceiveCatching {\n                expect(5)\n                assertTrue(it.isClosed)\n                assertIs<TestException>(it.exceptionOrNull())\n            }\n        }\n\n        finish(6)\n    }\n\n    @Test\n    fun testSelectReceiveCatchingForClosedChannel() = runTest {\n        val channel = Channel<Unit>()\n        channel.close()\n        expect(1)\n        select<Unit> {\n            expect(2)\n            channel.onReceiveCatching {\n                assertTrue(it.isClosed)\n                assertNull(it.exceptionOrNull())\n                finish(3)\n            }\n        }\n    }\n\n    @Test\n    fun testSelectReceiveCatching() = runTest {\n        val channel = Channel<Int>(Channel.RENDEZVOUS)\n        val iterations = 10\n        expect(1)\n        val job = launch {\n            repeat(iterations) {\n                select<Unit> {\n                    channel.onReceiveCatching { v ->\n                        expect(4 + it * 2)\n                        assertEquals(it, v.getOrThrow())\n                    }\n                }\n            }\n        }\n\n        expect(2)\n        repeat(iterations) {\n            expect(3 + it * 2)\n            channel.send(it)\n            yield()\n        }\n\n        job.join()\n        finish(3 + iterations * 2)\n    }\n\n    @Test\n    fun testSelectReceiveCatchingDispatch() = runTest {\n        val c = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        launch {\n            expect(3)\n            val res = select<String> {\n                c.onReceiveCatching { v ->\n                    expect(6)\n                    assertEquals(42, v.getOrThrow())\n                    yield() // back to main\n                    expect(8)\n                    \"OK\"\n                }\n            }\n            expect(9)\n            assertEquals(\"OK\", res)\n        }\n        expect(2)\n        yield() // to launch\n        expect(4)\n        c.send(42) // do not suspend\n        expect(5)\n        yield() // to receive\n        expect(7)\n        yield() // again\n        finish(10)\n    }\n\n    @Test\n    fun testSelectSendWhenClosed() = runTest {\n        expect(1)\n        val c = Channel<Int>(Channel.RENDEZVOUS)\n        val sender = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            c.send(1) // enqueue sender\n            expectUnreached()\n        }\n        c.close() // then close\n        assertFailsWith<ClosedSendChannelException> {\n            // select sender should fail\n            expect(3)\n            select {\n                c.onSend(2) {\n                    expectUnreached()\n                }\n            }\n        }\n        sender.cancel()\n        finish(4)\n    }\n\n    // only for debugging\n    internal fun <R> SelectBuilder<R>.default(block: suspend () -> R) = onTimeout(0, block)\n\n    @Test\n    fun testSelectSendAndReceive() = runTest {\n        val c = Channel<Int>()\n        assertFailsWith<IllegalStateException> {\n            select<Unit> {\n                c.onSend(1) { expectUnreached() }\n                c.onReceive { expectUnreached() }\n            }\n        }\n        checkNotBroken(c)\n    }\n\n    @Test\n    fun testSelectReceiveAndSend() = runTest {\n        val c = Channel<Int>()\n        assertFailsWith<IllegalStateException> {\n            select<Unit> {\n                c.onReceive { expectUnreached() }\n                c.onSend(1) { expectUnreached() }\n            }\n        }\n        checkNotBroken(c)\n    }\n\n    // makes sure the channel is not broken\n    private suspend fun checkNotBroken(c: Channel<Int>) {\n        coroutineScope {\n            launch {\n                c.send(42)\n            }\n            assertEquals(42, c.receive())\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectTimeoutDurationTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\nclass SelectTimeoutDurationTest : TestBase() {\n    @Test\n    fun testBasic() = runTest {\n        expect(1)\n        val result = select<String> {\n            onTimeout(1000.milliseconds) {\n                expectUnreached()\n                \"FAIL\"\n            }\n            onTimeout(100.milliseconds) {\n                expect(2)\n                \"OK\"\n            }\n            onTimeout(500.milliseconds) {\n                expectUnreached()\n                \"FAIL\"\n            }\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    @Test\n    fun testZeroTimeout() = runTest {\n        expect(1)\n        val result = select<String> {\n            onTimeout(1.seconds) {\n                expectUnreached()\n                \"FAIL\"\n            }\n            onTimeout(Duration.ZERO) {\n                expect(2)\n                \"OK\"\n            }\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    @Test\n    fun testNegativeTimeout() = runTest {\n        expect(1)\n        val result = select<String> {\n            onTimeout(1.seconds) {\n                expectUnreached()\n                \"FAIL\"\n            }\n            onTimeout(-10.milliseconds) {\n                expect(2)\n                \"OK\"\n            }\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    @Test\n    fun testUnbiasedNegativeTimeout() = runTest {\n        val counters = intArrayOf(0, 0, 0)\n        val iterations =10_000\n        for (i in 0..iterations) {\n            val result = selectUnbiased<Int> {\n                onTimeout((-1).seconds) {\n                    0\n                }\n                onTimeout(Duration.ZERO) {\n                    1\n                }\n                onTimeout(1.seconds) {\n                    expectUnreached()\n                    2\n                }\n            }\n            ++counters[result]\n        }\n        assertEquals(0, counters[2])\n        assertTrue { counters[0] >  iterations / 4 }\n        assertTrue { counters[1] >  iterations / 4 }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectTimeoutTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass SelectTimeoutTest : TestBase() {\n    @Test\n    fun testBasic() = runTest {\n        expect(1)\n        val result = select<String> {\n            onTimeout(1000) {\n                expectUnreached()\n                \"FAIL\"\n            }\n            onTimeout(100) {\n                expect(2)\n                \"OK\"\n            }\n            onTimeout(500) {\n                expectUnreached()\n                \"FAIL\"\n            }\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    @Test\n    fun testZeroTimeout() = runTest {\n        expect(1)\n        val result = select<String> {\n            onTimeout(1000) {\n                expectUnreached()\n                \"FAIL\"\n            }\n            onTimeout(0) {\n                expect(2)\n                \"OK\"\n            }\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    @Test\n    fun testNegativeTimeout() = runTest {\n        expect(1)\n        val result = select<String> {\n            onTimeout(1000) {\n                expectUnreached()\n                \"FAIL\"\n            }\n            onTimeout(-10) {\n                expect(2)\n                \"OK\"\n            }\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    @Test\n    fun testUnbiasedNegativeTimeout() = runTest {\n        val counters = intArrayOf(0, 0, 0)\n        val iterations =10_000\n        for (i in 0..iterations) {\n            val result = selectUnbiased<Int> {\n                onTimeout(-1000) {\n                    0\n                }\n                onTimeout(0) {\n                    1\n                }\n                onTimeout(1000) {\n                    expectUnreached()\n                    2\n                }\n            }\n            ++counters[result]\n        }\n        assertEquals(0, counters[2])\n        assertTrue { counters[0] >  iterations / 4 }\n        assertTrue { counters[1] >  iterations / 4 }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/selects/SelectUnlimitedChannelTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass SelectUnlimitedChannelTest : TestBase() {\n    @Test\n    fun testSelectSendWhenClosed() = runTest {\n        expect(1)\n        val c = Channel<Int>(Channel.UNLIMITED)\n        c.send(1) // enqueue buffered element\n        c.close() // then close\n        assertFailsWith<ClosedSendChannelException> {\n            // select sender should fail\n            expect(2)\n            select {\n                c.onSend(2) {\n                    expectUnreached()\n                }\n            }\n        }\n        finish(3)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/sync/MutexTest.kt",
        "content": "package kotlinx.coroutines.sync\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.test.*\n\nclass MutexTest : TestBase() {\n    @Test\n    fun testSimple() = runTest {\n        val mutex = Mutex()\n        expect(1)\n        launch {\n            expect(4)\n            mutex.lock() // suspends\n            expect(7) // now got lock\n            mutex.unlock()\n            expect(8)\n        }\n        expect(2)\n        mutex.lock() // locked\n        expect(3)\n        yield() // yield to child\n        expect(5)\n        mutex.unlock()\n        expect(6)\n        yield() // now child has lock\n        finish(9)\n    }\n\n    @Test\n    fun tryLockTest() {\n        val mutex = Mutex()\n        assertFalse(mutex.isLocked)\n        assertTrue(mutex.tryLock())\n        assertTrue(mutex.isLocked)\n        assertFalse(mutex.tryLock())\n        assertTrue(mutex.isLocked)\n        mutex.unlock()\n        assertFalse(mutex.isLocked)\n        assertTrue(mutex.tryLock())\n        assertTrue(mutex.isLocked)\n        assertFalse(mutex.tryLock())\n        assertTrue(mutex.isLocked)\n        mutex.unlock()\n        assertFalse(mutex.isLocked)\n    }\n\n    @Test\n    fun withLockTest() = runTest {\n        val mutex = Mutex()\n        assertFalse(mutex.isLocked)\n        mutex.withLock {\n            assertTrue(mutex.isLocked)\n        }\n        assertFalse(mutex.isLocked)\n    }\n\n    @Test\n    fun testWithLockFailureUnlocksTheMutex() = runTest {\n        val mutex = Mutex()\n        assertFalse(mutex.isLocked)\n        try {\n            mutex.withLock {\n                expect(1)\n                assertTrue(mutex.isLocked)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            expect(2)\n        }\n        assertFalse(mutex.isLocked)\n        finish(3)\n    }\n\n    @Test\n    fun withLockOnEarlyReturnTest() = runTest {\n        val mutex = Mutex()\n        assertFalse(mutex.isLocked)\n        suspend fun f() {\n            mutex.withLock {\n                assertTrue(mutex.isLocked)\n                return@f\n            }\n        }\n        f()\n        assertFalse(mutex.isLocked)\n    }\n\n    @Test\n    fun testUnconfinedStackOverflow() {\n        val waiters = 10000\n        val mutex = Mutex(true)\n        var done = 0\n        repeat(waiters) {\n            GlobalScope.launch(Dispatchers.Unconfined) {  // a lot of unconfined waiters\n                mutex.withLock {\n                    done++\n                }\n            }\n        }\n        mutex.unlock() // should not produce StackOverflowError\n        assertEquals(waiters, done)\n    }\n\n    @Test\n    fun holdLock() = runTest {\n        val mutex = Mutex()\n        val firstOwner = Any()\n        val secondOwner = Any()\n\n        // no lock\n        assertFalse(mutex.holdsLock(firstOwner))\n        assertFalse(mutex.holdsLock(secondOwner))\n\n        // owner firstOwner\n        mutex.lock(firstOwner)\n        val secondLockJob = launch {\n            mutex.lock(secondOwner)\n        }\n\n        assertTrue(mutex.holdsLock(firstOwner))\n        assertFalse(mutex.holdsLock(secondOwner))\n\n        // owner secondOwner\n        mutex.unlock(firstOwner)\n        secondLockJob.join()\n\n        assertFalse(mutex.holdsLock(firstOwner))\n        assertTrue(mutex.holdsLock(secondOwner))\n\n        mutex.unlock(secondOwner)\n\n        // no lock\n        assertFalse(mutex.holdsLock(firstOwner))\n        assertFalse(mutex.holdsLock(secondOwner))\n    }\n\n    @Test\n    fun testUnlockWithNullOwner() {\n        val owner = Any()\n        val mutex = Mutex()\n        assertTrue(mutex.tryLock(owner))\n        assertFailsWith<IllegalStateException> { mutex.unlock(Any()) }\n        mutex.unlock(null)\n        assertFalse(mutex.holdsLock(owner))\n        assertFalse(mutex.isLocked)\n    }\n\n    @Test\n    fun testUnlockWithoutOwnerWithLockedQueue() = runTest {\n        val owner = Any()\n        val owner2 = Any()\n        val mutex = Mutex()\n        assertTrue(mutex.tryLock(owner))\n        expect(1)\n        launch {\n            expect(2)\n            mutex.lock(owner2)\n        }\n        yield()\n        expect(3)\n        assertFailsWith<IllegalStateException> { mutex.unlock(owner2) }\n        mutex.unlock()\n        assertFalse(mutex.holdsLock(owner))\n        assertTrue(mutex.holdsLock(owner2))\n        finish(4)\n    }\n\n    @Test\n    fun testIllegalStateInvariant() = runTest {\n        val mutex = Mutex()\n        val owner = Any()\n        assertTrue(mutex.tryLock(owner))\n        assertFailsWith<IllegalStateException> { mutex.tryLock(owner) }\n        assertFailsWith<IllegalStateException> { mutex.lock(owner) }\n        assertFailsWith<IllegalStateException> { select { mutex.onLock(owner) {} } }\n    }\n\n    @Test\n    fun testWithLockJsMiscompilation() = runTest {\n        // This is a reproducer for KT-58685\n        // On Kotlin/JS IR, the compiler miscompiles calls to 'unlock' in an inlined finally\n        // This is visible on the withLock function\n        // Until the compiler bug is fixed, this test case checks that we do not suffer from it\n        val mutex = Mutex()\n        assertFailsWith<IndexOutOfBoundsException> {\n            try {\n                mutex.withLock { null } ?: throw IndexOutOfBoundsException() // should throw\u2026\n            } catch (e: Exception) {\n                throw e // \u2026but instead fails here\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/common/test/sync/SemaphoreTest.kt",
        "content": "package kotlinx.coroutines.sync\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass SemaphoreTest : TestBase() {\n\n    @Test\n    fun testSimple() = runTest {\n        val semaphore = Semaphore(2)\n        launch {\n            expect(3)\n            semaphore.release()\n            expect(4)\n        }\n        expect(1)\n        semaphore.acquire()\n        semaphore.acquire()\n        expect(2)\n        semaphore.acquire()\n        finish(5)\n    }\n\n    @Test\n    fun testSimpleAsMutex() = runTest {\n        val semaphore = Semaphore(1)\n        expect(1)\n        launch {\n            expect(4)\n            semaphore.acquire() // suspends\n            expect(7) // now got lock\n            semaphore.release()\n            expect(8)\n        }\n        expect(2)\n        semaphore.acquire() // locked\n        expect(3)\n        yield() // yield to child\n        expect(5)\n        semaphore.release()\n        expect(6)\n        yield() // now child has lock\n        finish(9)\n    }\n\n    @Test\n    fun tryAcquireTest() = runTest {\n        val semaphore = Semaphore(2)\n        assertTrue(semaphore.tryAcquire())\n        assertTrue(semaphore.tryAcquire())\n        assertFalse(semaphore.tryAcquire())\n        assertEquals(0, semaphore.availablePermits)\n        semaphore.release()\n        assertEquals(1, semaphore.availablePermits)\n        assertTrue(semaphore.tryAcquire())\n        assertEquals(0, semaphore.availablePermits)\n    }\n\n    @Test\n    fun withSemaphoreTest() = runTest {\n        val semaphore = Semaphore(1)\n        assertEquals(1, semaphore.availablePermits)\n        semaphore.withPermit {\n            assertEquals(0, semaphore.availablePermits)\n        }\n        assertEquals(1, semaphore.availablePermits)\n    }\n\n    @Test\n    fun withSemaphoreOnFailureTest() = runTest {\n        val semaphore = Semaphore(1)\n        assertEquals(1, semaphore.availablePermits)\n        try {\n            semaphore.withPermit {\n                assertEquals(0, semaphore.availablePermits)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            // Expected\n        }\n        assertEquals(1, semaphore.availablePermits)\n    }\n\n    @Test\n    fun withSemaphoreOnEarlyReturnTest() = runTest {\n        val semaphore = Semaphore(1)\n        assertEquals(1, semaphore.availablePermits)\n        suspend fun f() {\n            semaphore.withPermit {\n                assertEquals(0, semaphore.availablePermits)\n                return@f\n            }\n        }\n        f()\n        assertEquals(1, semaphore.availablePermits)\n    }\n\n    @Test\n    fun fairnessTest() = runTest {\n        val semaphore = Semaphore(1)\n        semaphore.acquire()\n        launch(coroutineContext) {\n            // first to acquire\n            expect(2)\n            semaphore.acquire() // suspend\n            expect(6)\n        }\n        launch(coroutineContext) {\n            // second to acquire\n            expect(3)\n            semaphore.acquire() // suspend\n            expect(9)\n        }\n        expect(1)\n        yield()\n        expect(4)\n        semaphore.release()\n        expect(5)\n        yield()\n        expect(7)\n        semaphore.release()\n        expect(8)\n        yield()\n        finish(10)\n    }\n\n    @Test\n    fun testCancellationReturnsPermitBack() = runTest {\n        val semaphore = Semaphore(1)\n        semaphore.acquire()\n        assertEquals(0, semaphore.availablePermits)\n        val job = launch {\n            assertFalse(semaphore.tryAcquire())\n            semaphore.acquire()\n        }\n        yield()\n        job.cancelAndJoin()\n        assertEquals(0, semaphore.availablePermits)\n        semaphore.release()\n        assertEquals(1, semaphore.availablePermits)\n    }\n\n    @Test\n    fun testCancellationDoesNotResumeWaitingAcquirers() = runTest {\n        val semaphore = Semaphore(1)\n        semaphore.acquire()\n        val job1 = launch { // 1st job in the waiting queue\n            expect(2)\n            semaphore.acquire()\n            expectUnreached()\n        }\n        val job2 = launch { // 2nd job in the waiting queue\n            expect(3)\n            semaphore.acquire()\n            expectUnreached()\n        }\n        expect(1)\n        yield()\n        expect(4)\n        job2.cancel()\n        yield()\n        expect(5)\n        job1.cancel()\n        finish(6)\n    }\n\n    @Test\n    fun testAcquiredPermits() = runTest {\n        val semaphore = Semaphore(5, acquiredPermits = 4)\n        assertEquals(semaphore.availablePermits, 1)\n        semaphore.acquire()\n        assertEquals(semaphore.availablePermits, 0)\n        assertFalse(semaphore.tryAcquire())\n        semaphore.release()\n        assertEquals(semaphore.availablePermits, 1)\n        assertTrue(semaphore.tryAcquire())\n    }\n\n    @Test\n    fun testReleaseAcquiredPermits() = runTest {\n        val semaphore = Semaphore(5, acquiredPermits = 4)\n        assertEquals(semaphore.availablePermits, 1)\n        repeat(4) { semaphore.release() }\n        assertEquals(5, semaphore.availablePermits)\n        assertFailsWith<IllegalStateException> { semaphore.release() }\n        repeat(5) { assertTrue(semaphore.tryAcquire()) }\n        assertFalse(semaphore.tryAcquire())\n    }\n\n    @Test\n    fun testIllegalArguments() {\n        assertFailsWith<IllegalArgumentException> { Semaphore(-1, 0) }\n        assertFailsWith<IllegalArgumentException> { Semaphore(0, 0) }\n        assertFailsWith<IllegalArgumentException> { Semaphore(1, -1) }\n        assertFailsWith<IllegalArgumentException> { Semaphore(1, 2) }\n    }\n\n    @Test\n    fun testWithPermitJsMiscompilation() = runTest {\n        // This is a reproducer for KT-58685\n        // On Kotlin/JS IR, the compiler miscompiles calls to 'release' in an inlined finally\n        // This is visible on the withPermit function\n        // Until the compiler bug is fixed, this test case checks that we do not suffer from it\n        val semaphore = Semaphore(1)\n        assertFailsWith<IndexOutOfBoundsException> {\n            try {\n                semaphore.withPermit { null } ?: throw IndexOutOfBoundsException() // should throw\u2026\n            } catch (e: Exception) {\n                throw e // \u2026but instead fails here\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/src/Builders.concurrent.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\n\n/**\n * Runs a new coroutine and **blocks** the current thread until its completion.\n *\n * It is designed to bridge regular blocking code to libraries that are written in suspending style, to be used in\n * `main` functions and in tests.\n *\n * Calling [runBlocking] from a suspend function is redundant.\n * For example, the following code is incorrect:\n * ```\n * suspend fun loadConfiguration() {\n *     // DO NOT DO THIS:\n *     val data = runBlocking { // <- redundant and blocks the thread, do not do that\n *         fetchConfigurationData() // suspending function\n *     }\n * ```\n *\n * Here, instead of releasing the thread on which `loadConfiguration` runs if `fetchConfigurationData` suspends, it will\n * block, potentially leading to thread starvation issues.\n */\npublic expect fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/src/Dispatchers.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * The [CoroutineDispatcher] that is designed for offloading blocking IO tasks to a shared pool of threads.\n * Additional threads in this pool are created on demand.\n * Default IO pool size is `64`; on JVM it can be configured using JVM-specific mechanisms,\n * please refer to `Dispatchers.IO` documentation on JVM platform.\n *\n * ### Elasticity for limited parallelism\n *\n * `Dispatchers.IO` has a unique property of elasticity: its views\n * obtained with [CoroutineDispatcher.limitedParallelism] are\n * not restricted by the `Dispatchers.IO` parallelism. Conceptually, there is\n * a dispatcher backed by an unlimited pool of threads, and both `Dispatchers.IO`\n * and views of `Dispatchers.IO` are actually views of that dispatcher. In practice\n * this means that, despite not abiding by `Dispatchers.IO`'s parallelism\n * restrictions, its views share threads and resources with it.\n *\n * In the following example\n * ```\n * // 100 threads for MySQL connection\n * val myMysqlDbDispatcher = Dispatchers.IO.limitedParallelism(100)\n * // 60 threads for MongoDB connection\n * val myMongoDbDispatcher = Dispatchers.IO.limitedParallelism(60)\n * ```\n * the system may have up to `64 + 100 + 60` threads dedicated to blocking tasks during peak loads,\n * but during its steady state there is only a small number of threads shared\n * among `Dispatchers.IO`, `myMysqlDbDispatcher` and `myMongoDbDispatcher`\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic expect val Dispatchers.IO: CoroutineDispatcher\n\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/src/MultithreadedDispatchers.common.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"ThreadPoolDispatcherKt\")\npackage kotlinx.coroutines\n\nimport kotlin.jvm.*\n\n/**\n * Creates a coroutine execution context using a single thread with built-in [yield] support.\n * **NOTE: The resulting [CloseableCoroutineDispatcher] owns native resources (its thread).\n * Resources are reclaimed by [CloseableCoroutineDispatcher.close].**\n *\n * If the resulting dispatcher is [closed][CloseableCoroutineDispatcher.close] and\n * attempt to submit a task is made, then:\n * - On the JVM, the [Job] of the affected task is [cancelled][Job.cancel] and the task is submitted to the\n *   [Dispatchers.IO], so that the affected coroutine can clean up its resources and promptly complete.\n * - On Native, the attempt to submit a task throws an exception.\n *\n * This is a **delicate** API. The result of this method is a closeable resource with the\n * associated native resources (threads or native workers). It should not be allocated in place,\n * should be closed at the end of its lifecycle, and has non-trivial memory and CPU footprint.\n * If you do not need a separate thread pool, but only have to limit effective parallelism of the dispatcher,\n * it is recommended to use [CoroutineDispatcher.limitedParallelism] instead.\n *\n * If you need a completely separate thread pool with scheduling policy that is based on the standard\n * JDK executors, use the following expression:\n * `Executors.newSingleThreadExecutor().asCoroutineDispatcher()`.\n * See `Executor.asCoroutineDispatcher` for details.\n *\n * @param name the base name of the created thread.\n */\n@ExperimentalCoroutinesApi\n@DelicateCoroutinesApi\npublic fun newSingleThreadContext(name: String): CloseableCoroutineDispatcher =\n    newFixedThreadPoolContext(1, name)\n\n/**\n * Creates a coroutine execution context with the fixed-size thread-pool and built-in [yield] support.\n * **NOTE: The resulting [CoroutineDispatcher] owns native resources (its threads).\n * Resources are reclaimed by [CloseableCoroutineDispatcher.close].**\n *\n * If the resulting dispatcher is [closed][CloseableCoroutineDispatcher.close] and\n * attempt to submit a continuation task is made,\n * - On the JVM, the [Job] of the affected task is [cancelled][Job.cancel] and the task is submitted to the\n *   [Dispatchers.IO], so that the affected coroutine can clean up its resources and promptly complete.\n * - On Native, the attempt to submit a task throws an exception.\n *\n * This is a **delicate** API. The result of this method is a closeable resource with the\n * associated native resources (threads or native workers). It should not be allocated in place,\n * should be closed at the end of its lifecycle, and has non-trivial memory and CPU footprint.\n * If you do not need a separate thread pool, but only have to limit effective parallelism of the dispatcher,\n * it is recommended to use [CoroutineDispatcher.limitedParallelism] instead.\n *\n * If you need a completely separate thread pool with scheduling policy that is based on the standard\n * JDK executors, use the following expression:\n * `Executors.newFixedThreadPool().asCoroutineDispatcher()`.\n * See `Executor.asCoroutineDispatcher` for details.\n *\n * @param nThreads the number of threads.\n * @param name the base name of the created threads.\n */\n@ExperimentalCoroutinesApi\npublic expect fun newFixedThreadPoolContext(nThreads: Int, name: String): CloseableCoroutineDispatcher\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/src/channels/Channels.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"ChannelsKt\")\n\npackage kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlin.jvm.*\n\n/**\n * Adds [element] to this channel, **blocking** the caller while this channel is full,\n * and returning either [successful][ChannelResult.isSuccess] result when the element was added, or\n * failed result representing closed channel with a corresponding exception.\n *\n * This is a way to call [Channel.send] method in a safe manner inside a blocking code using [runBlocking] and catching,\n * so this function should not be used from coroutine.\n *\n * Example of usage:\n *\n * ```\n * // From callback API\n * channel.trySendBlocking(element)\n *     .onSuccess { /* request next element or debug log */ }\n *     .onFailure { t: Throwable? -> /* throw or log */ }\n * ```\n *\n * For this operation it is guaranteed that [failure][ChannelResult.failed] always contains an exception in it.\n *\n * @throws `InterruptedException` on JVM if the current thread is interrupted during the blocking send operation.\n */\npublic fun <E> SendChannel<E>.trySendBlocking(element: E): ChannelResult<Unit> {\n    /*\n     * Sent successfully -- bail out.\n     * But failure may indicate either that the channel is full or that\n     * it is close. Go to slow path on failure to simplify the successful path and\n     * to materialize default exception.\n     */\n    trySend(element).onSuccess { return ChannelResult.success(Unit) }\n    return runBlocking {\n        val r = runCatching { send(element) }\n        if (r.isSuccess) ChannelResult.success(Unit)\n        else ChannelResult.closed(r.exceptionOrNull())\n    }\n}\n\n/** @suppress */\n@Deprecated(\n    level = DeprecationLevel.HIDDEN,\n    message = \"Deprecated in the favour of 'trySendBlocking'. \" +\n        \"Consider handling the result of 'trySendBlocking' explicitly and rethrow exception if necessary\",\n    replaceWith = ReplaceWith(\"trySendBlocking(element)\")\n) // WARNING in 1.5.0, ERROR in 1.6.0\npublic fun <E> SendChannel<E>.sendBlocking(element: E) {\n    // fast path\n    if (trySend(element).isSuccess)\n        return\n    // slow path\n    runBlocking {\n        send(element)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/src/internal/LockFreeLinkedList.kt",
        "content": "@file:Suppress(\"NO_EXPLICIT_VISIBILITY_IN_API_MODE\")\n\npackage kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.jvm.*\n\nprivate typealias Node = LockFreeLinkedListNode\n\n@PublishedApi\ninternal const val UNDECIDED: Int = 0\n\n@PublishedApi\ninternal const val SUCCESS: Int = 1\n\n@PublishedApi\ninternal const val FAILURE: Int = 2\n\n@PublishedApi\ninternal val CONDITION_FALSE: Any = Symbol(\"CONDITION_FALSE\")\n\n/**\n * Doubly-linked concurrent list node with remove support.\n * Based on paper\n * [\"Lock-Free and Practical Doubly Linked List-Based Deques Using Single-Word Compare-and-Swap\"](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.4693&rep=rep1&type=pdf)\n * by Sundell and Tsigas with considerable changes.\n *\n * The core idea of the algorithm is to maintain a doubly-linked list with an ever-present sentinel node (it is\n * never removed) that serves both as a list head and tail and to linearize all operations (both insert and remove) on\n * the update of the next pointer. Removed nodes have their next pointer marked with [Removed] class.\n *\n * Important notes:\n * - There are no operations to add items to left side of the list, only to the end (right side), because we cannot\n *   efficiently linearize them with atomic multi-step head-removal operations. In short,\n *   support for [describeRemoveFirst] operation precludes ability to add items at the beginning.\n * - Previous pointers are not marked for removal. We don't support linearizable backwards traversal.\n * - Remove-helping logic is simplified and consolidated in [correctPrev] method.\n *\n * @suppress **This is unstable API and it is subject to change.**\n */\n@Suppress(\"LeakingThis\")\n@InternalCoroutinesApi\npublic actual open class LockFreeLinkedListNode {\n    private val _next = atomic<Any>(this) // Node | Removed | OpDescriptor\n    private val _prev = atomic(this) // Node to the left (cannot be marked as removed)\n    private val _removedRef = atomic<Removed?>(null) // lazily cached removed ref to this\n\n    private fun removed(): Removed =\n        _removedRef.value ?: Removed(this).also { _removedRef.lazySet(it) }\n\n    @PublishedApi\n    internal abstract class CondAddOp(\n        @JvmField val newNode: Node\n    ) : AtomicOp<Node>() {\n        @JvmField var oldNext: Node? = null\n\n        override fun complete(affected: Node, failure: Any?) {\n            val success = failure == null\n            val update = if (success) newNode else oldNext\n            if (update != null && affected._next.compareAndSet( this, update)) {\n                // only the thread the makes this update actually finishes add operation\n                if (success) newNode.finishAdd(oldNext!!)\n            }\n        }\n    }\n\n    @PublishedApi\n    internal inline fun makeCondAddOp(node: Node, crossinline condition: () -> Boolean): CondAddOp =\n        object : CondAddOp(node) {\n            override fun prepare(affected: Node): Any? = if (condition()) null else CONDITION_FALSE\n        }\n\n    public actual open val isRemoved: Boolean get() = next is Removed\n\n    // LINEARIZABLE. Returns Node | Removed\n    public val next: Any get() {\n        _next.loop { next ->\n            if (next !is OpDescriptor) return next\n            next.perform(this)\n        }\n    }\n\n    // LINEARIZABLE. Returns next non-removed Node\n    public actual val nextNode: Node get() =\n        next.let { (it as? Removed)?.ref ?: it as Node } // unwraps the `next` node\n\n    // LINEARIZABLE WHEN THIS NODE IS NOT REMOVED:\n    // Returns prev non-removed Node, makes sure prev is correct (prev.next === this)\n    // NOTE: if this node is removed, then returns non-removed previous node without applying\n    // prev.next correction, which does not provide linearizable backwards iteration, but can be used to\n    // resume forward iteration when current node was removed.\n    public actual val prevNode: Node\n        get() = correctPrev(null) ?: findPrevNonRemoved(_prev.value)\n\n    private tailrec fun findPrevNonRemoved(current: Node): Node {\n        if (!current.isRemoved) return current\n        return findPrevNonRemoved(current._prev.value)\n    }\n\n    // ------ addOneIfEmpty ------\n\n    public actual fun addOneIfEmpty(node: Node): Boolean {\n        node._prev.lazySet(this)\n        node._next.lazySet(this)\n        while (true) {\n            val next = next\n            if (next !== this) return false // this is not an empty list!\n            if (_next.compareAndSet(this, node)) {\n                // added successfully (linearized add) -- fixup the list\n                node.finishAdd(this)\n                return true\n            }\n        }\n    }\n\n    // ------ addLastXXX ------\n\n    /**\n     * Adds last item to this list.\n     */\n    public actual fun addLast(node: Node) {\n        while (true) { // lock-free loop on prev.next\n            if (prevNode.addNext(node, this)) return\n        }\n    }\n\n    /**\n     * Adds last item to this list atomically if the [condition] is true.\n     */\n    public actual inline fun addLastIf(node: Node, crossinline condition: () -> Boolean): Boolean {\n        val condAdd = makeCondAddOp(node, condition)\n        while (true) { // lock-free loop on prev.next\n            val prev = prevNode // sentinel node is never removed, so prev is always defined\n            when (prev.tryCondAddNext(node, this, condAdd)) {\n                SUCCESS -> return true\n                FAILURE -> return false\n            }\n        }\n    }\n\n    // ------ addXXX util ------\n\n    /**\n     * Given:\n     * ```\n     *                +-----------------------+\n     *          this  |         node          V  next\n     *          +---+---+     +---+---+     +---+---+\n     *  ... <-- | P | N |     | P | N |     | P | N | --> ....\n     *          +---+---+     +---+---+     +---+---+\n     *                ^                       |\n     *                +-----------------------+\n     * ```\n     * Produces:\n     * ```\n     *          this            node             next\n     *          +---+---+     +---+---+     +---+---+\n     *  ... <-- | P | N | ==> | P | N | --> | P | N | --> ....\n     *          +---+---+     +---+---+     +---+---+\n     *                ^         |   ^         |\n     *                +---------+   +---------+\n     * ```\n     *  Where `==>` denotes linearization point.\n     *  Returns `false` if `next` was not following `this` node.\n     */\n    @PublishedApi\n    internal fun addNext(node: Node, next: Node): Boolean {\n        node._prev.lazySet(this)\n        node._next.lazySet(next)\n        if (!_next.compareAndSet(next, node)) return false\n        // added successfully (linearized add) -- fixup the list\n        node.finishAdd(next)\n        return true\n    }\n\n    // returns UNDECIDED, SUCCESS or FAILURE\n    @PublishedApi\n    internal fun tryCondAddNext(node: Node, next: Node, condAdd: CondAddOp): Int {\n        node._prev.lazySet(this)\n        node._next.lazySet(next)\n        condAdd.oldNext = next\n        if (!_next.compareAndSet(next, condAdd)) return UNDECIDED\n        // added operation successfully (linearized) -- complete it & fixup the list\n        return if (condAdd.perform(this) == null) SUCCESS else FAILURE\n    }\n\n    // ------ removeXXX ------\n\n    /**\n     * Removes this node from the list. Returns `true` when removed successfully, or `false` if the node was already\n     * removed or if it was not added to any list in the first place.\n     *\n     * **Note**: Invocation of this operation does not guarantee that remove was actually complete if result was `false`.\n     * In particular, invoking [nextNode].[prevNode] might still return this node even though it is \"already removed\".\n     */\n    public actual open fun remove(): Boolean =\n        removeOrNext() == null\n\n    // returns null if removed successfully or next node if this node is already removed\n    @PublishedApi\n    internal fun removeOrNext(): Node? {\n        while (true) { // lock-free loop on next\n            val next = this.next\n            if (next is Removed) return next.ref // was already removed -- don't try to help (original thread will take care)\n            if (next === this) return next // was not even added\n            val removed = (next as Node).removed()\n            if (_next.compareAndSet(next, removed)) {\n                // was removed successfully (linearized remove) -- fixup the list\n                next.correctPrev(null)\n                return null\n            }\n        }\n    }\n\n    // This is Harris's RDCSS (Restricted Double-Compare Single Swap) operation\n    // It inserts \"op\" descriptor of when \"op\" status is still undecided (rolls back otherwise)\n\n\n    // ------ other helpers ------\n\n    /**\n     * Given:\n     * ```\n     *\n     *          prev            this             next\n     *          +---+---+     +---+---+     +---+---+\n     *  ... <-- | P | N | --> | P | N | --> | P | N | --> ....\n     *          +---+---+     +---+---+     +---+---+\n     *              ^ ^         |             |\n     *              | +---------+             |\n     *              +-------------------------+\n     * ```\n     * Produces:\n     * ```\n     *          prev            this             next\n     *          +---+---+     +---+---+     +---+---+\n     *  ... <-- | P | N | --> | P | N | --> | P | N | --> ....\n     *          +---+---+     +---+---+     +---+---+\n     *                ^         |   ^         |\n     *                +---------+   +---------+\n     * ```\n     */\n    private fun finishAdd(next: Node) {\n        next._prev.loop { nextPrev ->\n            if (this.next !== next) return // this or next was removed or another node added, remover/adder fixes up links\n            if (next._prev.compareAndSet(nextPrev, this)) {\n                // This newly added node could have been removed, and the above CAS would have added it physically again.\n                // Let us double-check for this situation and correct if needed\n                if (isRemoved) next.correctPrev(null)\n                return\n            }\n        }\n    }\n\n    protected open fun nextIfRemoved(): Node? = (next as? Removed)?.ref\n\n    /**\n     * Returns the corrected value of the previous node while also correcting the `prev` pointer\n     * (so that `this.prev.next === this`) and helps complete node removals to the left ot this node.\n     *\n     * It returns `null` in two special cases:\n     *\n     * - When this node is removed. In this case there is no need to waste time on corrections, because\n     *   remover of this node will ultimately call [correctPrev] on the next node and that will fix all\n     *   the links from this node, too.\n     */\n    private tailrec fun correctPrev(op: OpDescriptor?): Node? {\n        val oldPrev = _prev.value\n        var prev: Node = oldPrev\n        var last: Node? = null // will be set so that last.next === prev\n        while (true) { // move the left until first non-removed node\n            val prevNext: Any = prev._next.value\n            when {\n                // fast path to find quickly find prev node when everything is properly linked\n                prevNext === this -> {\n                    if (oldPrev === prev) return prev // nothing to update -- all is fine, prev found\n                    // otherwise need to update prev\n                    if (!this._prev.compareAndSet(oldPrev, prev)) {\n                        // Note: retry from scratch on failure to update prev\n                        return correctPrev(op)\n                    }\n                    return prev // return the correct prev\n                }\n                // slow path when we need to help remove operations\n                this.isRemoved -> return null // nothing to do, this node was removed, bail out asap to save time\n                prevNext === op -> return prev // part of the same op -- don't recurse, didn't correct prev\n                prevNext is OpDescriptor -> { // help & retry\n                    prevNext.perform(prev)\n                    return correctPrev(op) // retry from scratch\n                }\n                prevNext is Removed -> {\n                    if (last !== null) {\n                        // newly added (prev) node is already removed, correct last.next around it\n                        if (!last._next.compareAndSet(prev, prevNext.ref)) {\n                            return correctPrev(op) // retry from scratch on failure to update next\n                        }\n                        prev = last\n                        last = null\n                    } else {\n                        prev = prev._prev.value\n                    }\n                }\n                else -> { // prevNext is a regular node, but not this -- help delete\n                    last = prev\n                    prev = prevNext as Node\n                }\n            }\n        }\n    }\n\n    internal fun validateNode(prev: Node, next: Node) {\n        assert { prev === this._prev.value }\n        assert { next === this._next.value }\n    }\n\n    override fun toString(): String = \"${this::classSimpleName}@${this.hexAddress}\"\n}\n\nprivate class Removed(@JvmField val ref: Node) {\n    override fun toString(): String = \"Removed[$ref]\"\n}\n\n/**\n * Head (sentinel) item of the linked list that is never removed.\n *\n * @suppress **This is unstable API and it is subject to change.**\n */\npublic actual open class LockFreeLinkedListHead : LockFreeLinkedListNode() {\n    public actual val isEmpty: Boolean get() = next === this\n\n    /**\n     * Iterates over all elements in this list of a specified type.\n     */\n    public actual inline fun <reified T : Node> forEach(block: (T) -> Unit) {\n        var cur: Node = next as Node\n        while (cur != this) {\n            if (cur is T) block(cur)\n            cur = cur.nextNode\n        }\n    }\n\n    // just a defensive programming -- makes sure that list head sentinel is never removed\n    public actual final override fun remove(): Nothing = error(\"head cannot be removed\")\n\n    // optimization: because head is never removed, we don't have to read _next.value to check these:\n    override val isRemoved: Boolean get() = false\n\n    override fun nextIfRemoved(): Node? = null\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/src/internal/OnDemandAllocatingPool.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\n\n/**\n * A thread-safe resource pool.\n *\n * [maxCapacity] is the maximum amount of elements.\n * [create] is the function that creates a new element.\n *\n * This is only used in the Native implementation,\n * but is part of the `concurrent` source set in order to test it on the JVM.\n */\ninternal class OnDemandAllocatingPool<T>(\n    private val maxCapacity: Int,\n    private val create: (Int) -> T\n) {\n    /**\n     * Number of existing elements + isClosed flag in the highest bit.\n     * Once the flag is set, the value is guaranteed not to change anymore.\n     */\n    private val controlState = atomic(0)\n    private val elements = atomicArrayOfNulls<T>(maxCapacity)\n\n    /**\n     * Returns the number of elements that need to be cleaned up due to the pool being closed.\n     */\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun tryForbidNewElements(): Int {\n        controlState.loop {\n            if (it.isClosed()) return 0 // already closed\n            if (controlState.compareAndSet(it, it or IS_CLOSED_MASK)) return it\n        }\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Int.isClosed(): Boolean = this and IS_CLOSED_MASK != 0\n\n    /**\n     * Request that a new element is created.\n     *\n     * Returns `false` if the pool is closed.\n     *\n     * Note that it will still return `true` even if an element was not created due to reaching [maxCapacity].\n     *\n     * Rethrows the exceptions thrown from [create]. In this case, this operation has no effect.\n     */\n    fun allocate(): Boolean {\n        controlState.loop { ctl ->\n            if (ctl.isClosed()) return false\n            if (ctl >= maxCapacity) return true\n            if (controlState.compareAndSet(ctl, ctl + 1)) {\n                elements[ctl].value = create(ctl)\n                return true\n            }\n        }\n    }\n\n    /**\n     * Close the pool.\n     *\n     * This will prevent any new elements from being created.\n     * All the elements present in the pool will be returned.\n     *\n     * The function is thread-safe.\n     *\n     * [close] can be called multiple times, but only a single call will return a non-empty list.\n     * This is due to the elements being cleaned out from the pool on the first invocation to avoid memory leaks,\n     * and no new elements being created after.\n     */\n    fun close(): List<T> {\n        val elementsExisting = tryForbidNewElements()\n        return (0 until elementsExisting).map { i ->\n            // we wait for the element to be created, because we know that eventually it is going to be there\n            loop {\n                val element = elements[i].getAndSet(null)\n                if (element != null) {\n                    return@map element\n                }\n            }\n        }\n    }\n\n    // for tests\n    internal fun stateRepresentation(): String {\n        val ctl = controlState.value\n        val elementsStr = (0 until (ctl and IS_CLOSED_MASK.inv())).map { elements[it].value }.toString()\n        val closedStr = if (ctl.isClosed()) \"[closed]\" else \"\"\n        return elementsStr + closedStr\n    }\n\n    override fun toString(): String = \"OnDemandAllocatingPool(${stateRepresentation()})\"\n}\n\n// KT-25023\nprivate inline fun loop(block: () -> Unit): Nothing {\n    while (true) {\n        block()\n    }\n}\n\nprivate const val IS_CLOSED_MASK = 1 shl 31\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/AbstractDispatcherConcurrencyTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\n\nabstract class AbstractDispatcherConcurrencyTest : TestBase() {\n\n   public abstract val dispatcher: CoroutineDispatcher\n\n    @Test\n    fun testLaunchAndJoin() = runTest {\n        expect(1)\n        var capturedMutableState = 0\n        val job = GlobalScope.launch(dispatcher) {\n            ++capturedMutableState\n            expect(2)\n        }\n        runBlocking { job.join() }\n        assertEquals(1, capturedMutableState)\n        finish(3)\n    }\n\n    @Test\n    fun testDispatcherHasOwnThreads() = runTest {\n        val channel = Channel<Int>()\n        GlobalScope.launch(dispatcher) {\n            channel.send(42)\n        }\n\n        var result = ChannelResult.failure<Int>()\n        while (!result.isSuccess) {\n            result = channel.tryReceive()\n            // Block the thread, wait\n        }\n        // Delivery was successful, let's check it\n        assertEquals(42, result.getOrThrow())\n    }\n\n    @Test\n    fun testDelayInDispatcher() = runTest {\n        expect(1)\n        val job = GlobalScope.launch(dispatcher) {\n            expect(2)\n            delay(100)\n            expect(3)\n        }\n        runBlocking { job.join() }\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/AtomicCancellationTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.test.*\n\nclass AtomicCancellationTest : TestBase() {\n    @Test\n    fun testSendCancellable() = runBlocking {\n        expect(1)\n        val channel = Channel<Int>()\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            channel.send(42) // suspends\n            expectUnreached() // should NOT execute because of cancellation\n        }\n        expect(3)\n        assertEquals(42, channel.receive()) // will schedule sender for further execution\n        job.cancel() // cancel the job next\n        yield() // now yield\n        finish(4)\n    }\n\n    @Suppress(\"UNUSED_VARIABLE\")\n    @Test\n    fun testSelectSendCancellable() = runBlocking {\n        expect(1)\n        val channel = Channel<Int>()\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            val result = select<String> { // suspends\n                channel.onSend(42) {\n                    expect(4)\n                    \"OK\"\n                }\n            }\n            expectUnreached() // should NOT execute because of cancellation\n        }\n        expect(3)\n        assertEquals(42, channel.receive()) // will schedule sender for further execution\n        job.cancel() // cancel the job next\n        yield() // now yield\n        finish(4)\n    }\n\n    @Test\n    fun testReceiveCancellable() = runBlocking {\n        expect(1)\n        val channel = Channel<Int>()\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            assertEquals(42, channel.receive()) // suspends\n            expectUnreached() // should NOT execute because of cancellation\n        }\n        expect(3)\n        channel.send(42) // will schedule receiver for further execution\n        job.cancel() // cancel the job next\n        yield() // now yield\n        finish(4)\n    }\n\n    @Test\n    fun testSelectReceiveCancellable() = runBlocking {\n        expect(1)\n        val channel = Channel<Int>()\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            val result = select<String> { // suspends\n                channel.onReceive {\n                    assertEquals(42, it)\n                    expect(4)\n                    \"OK\"\n                }\n            }\n            expectUnreached() // should NOT execute because of cancellation\n        }\n        expect(3)\n        channel.send(42) // will schedule receiver for further execution\n        job.cancel() // cancel the job next\n        yield() // now yield\n        finish(4)\n    }\n\n    @Test\n    fun testSelectDeferredAwaitCancellable() = runBlocking {\n        expect(1)\n        val deferred = async { // deferred, not yet complete\n            expect(4)\n            \"OK\"\n        }\n        assertEquals(false, deferred.isCompleted)\n        var job: Job? = null\n        launch { // will cancel job as soon as deferred completes\n            expect(5)\n            assertEquals(true, deferred.isCompleted)\n            job!!.cancel()\n        }\n        job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                select<Unit> { // suspends\n                    deferred.onAwait { expectUnreached() }\n                }\n                expectUnreached() // will not execute -- cancelled while dispatched\n            } finally {\n                finish(7) // but will execute finally blocks\n            }\n        }\n        expect(3) // continues to execute when the job suspends\n        yield() // to deferred & canceller\n        expect(6)\n    }\n\n    @Test\n    fun testSelectJobJoinCancellable() = runBlocking {\n        expect(1)\n        val jobToJoin = launch { // not yet complete\n            expect(4)\n        }\n        assertEquals(false, jobToJoin.isCompleted)\n        var job: Job? = null\n        launch { // will cancel job as soon as jobToJoin completes\n            expect(5)\n            assertEquals(true, jobToJoin.isCompleted)\n            job!!.cancel()\n        }\n        job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                select<Unit> { // suspends\n                    jobToJoin.onJoin { expectUnreached() }\n                }\n                expectUnreached() // will not execute -- cancelled while dispatched\n            } finally {\n                finish(7) // but will execute finally blocks\n            }\n        }\n        expect(3) // continues to execute when the job suspends\n        yield() // to jobToJoin & canceller\n        expect(6)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/CommonThreadLocalTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.exceptions.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.test.*\n\nclass CommonThreadLocalTest: TestBase() {\n\n    /**\n     * Tests the basic functionality of [commonThreadLocal]: storing a separate value for each thread.\n     */\n    @Test\n    fun testThreadLocalBeingThreadLocal() = runTest {\n        val threadLocal = commonThreadLocal<Int>(Symbol(\"Test1\"))\n        newSingleThreadContext(\"\").use {\n            threadLocal.set(10)\n            assertEquals(10, threadLocal.get())\n            val job1 = launch(it) {\n                threadLocal.set(20)\n                assertEquals(20, threadLocal.get())\n            }\n            assertEquals(10, threadLocal.get())\n            job1.join()\n            val job2 = launch(it) {\n                assertEquals(20, threadLocal.get())\n            }\n            job2.join()\n        }\n    }\n\n    /**\n     * Tests using [commonThreadLocal] with a nullable type.\n     */\n    @Test\n    fun testThreadLocalWithNullableType() = runTest {\n        val threadLocal = commonThreadLocal<Int?>(Symbol(\"Test2\"))\n        newSingleThreadContext(\"\").use {\n            assertNull(threadLocal.get())\n            threadLocal.set(10)\n            assertEquals(10, threadLocal.get())\n            val job1 = launch(it) {\n                assertNull(threadLocal.get())\n                threadLocal.set(20)\n                assertEquals(20, threadLocal.get())\n            }\n            assertEquals(10, threadLocal.get())\n            job1.join()\n            threadLocal.set(null)\n            assertNull(threadLocal.get())\n            val job2 = launch(it) {\n                assertEquals(20, threadLocal.get())\n                threadLocal.set(null)\n                assertNull(threadLocal.get())\n            }\n            job2.join()\n        }\n    }\n\n    /**\n     * Tests that several instances of [commonThreadLocal] with different names don't affect each other.\n     */\n    @Test\n    fun testThreadLocalsWithDifferentNamesNotInterfering() {\n        val value1 = commonThreadLocal<Int>(Symbol(\"Test3a\"))\n        val value2 = commonThreadLocal<Int>(Symbol(\"Test3b\"))\n        value1.set(5)\n        value2.set(6)\n        assertEquals(5, value1.get())\n        assertEquals(6, value2.get())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/ConcurrentExceptionsStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.exceptions.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.test.*\n\nclass ConcurrentExceptionsStressTest : TestBase() {\n    private val nWorkers = 4\n    private val nRepeat = 1000 * stressTestMultiplier\n\n    private var workers: Array<CloseableCoroutineDispatcher> = emptyArray()\n\n    @AfterTest\n    fun tearDown() {\n        workers.forEach {\n            it.close()\n        }\n    }\n\n    @Test\n    fun testStress() = runTest {\n        workers = Array(nWorkers) { index ->\n            newSingleThreadContext(\"JobExceptionsStressTest-$index\")\n        }\n\n        repeat(nRepeat) {\n            testOnce()\n        }\n    }\n\n    @Suppress(\"SuspendFunctionOnCoroutineScope\") // workaround native inline fun stacktraces\n    private suspend fun CoroutineScope.testOnce() {\n        val deferred = async(NonCancellable) {\n            repeat(nWorkers) { index ->\n                // Always launch a coroutine even if parent job was already cancelled (atomic start)\n                launch(workers[index], start = CoroutineStart.ATOMIC) {\n                    randomWait()\n                    throw StressException(index)\n                }\n            }\n        }\n        deferred.join()\n        assertTrue(deferred.isCancelled)\n        val completionException = deferred.getCompletionExceptionOrNull()\n        val cause = completionException as? StressException\n            ?: unexpectedException(\"completion\", completionException)\n        val suppressed = cause.suppressedExceptions\n        val indices = listOf(cause.index) + suppressed.mapIndexed { index, e ->\n            (e as? StressException)?.index ?: unexpectedException(\"suppressed $index\", e)\n        }\n        repeat(nWorkers) { index ->\n            assertTrue(index in indices, \"Exception $index is missing: $indices\")\n        }\n        assertEquals(nWorkers, indices.size, \"Duplicated exceptions in list: $indices\")\n    }\n\n    private fun unexpectedException(msg: String, e: Throwable?): Nothing {\n        throw IllegalStateException(\"Unexpected $msg exception\", e)\n    }\n\n    private class StressException(val index: Int) : Throwable()\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/ConcurrentTestUtilities.common.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.*\nimport kotlin.concurrent.Volatile\nimport kotlin.random.*\n\nfun randomWait() {\n    val n = Random.nextInt(1000)\n    if (n < 500) return // no wait 50% of time\n    repeat(n) {\n        BlackHole.sink *= 3\n    }\n    // use the BlackHole value somehow, so even if the compiler gets smarter, it won't remove the object\n    val sinkValue = if (BlackHole.sink > 16) 1 else 0\n    if (n + sinkValue > 900) yieldThread()\n}\n\nprivate object BlackHole {\n    @Volatile\n    var sink = 1\n}\n\nexpect inline fun yieldThread()\n\nexpect fun currentThreadName(): String\n\ninline fun CloseableCoroutineDispatcher.use(block: (CloseableCoroutineDispatcher) -> Unit) {\n    try {\n        block(this)\n    } finally {\n        close()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/DefaultDispatchersConcurrencyTest.kt",
        "content": "package kotlinx.coroutines\n\nclass DefaultDispatcherConcurrencyTest : AbstractDispatcherConcurrencyTest() {\n    override val dispatcher: CoroutineDispatcher = Dispatchers.Default\n}\n\nclass IoDispatcherConcurrencyTest : AbstractDispatcherConcurrencyTest() {\n    override val dispatcher: CoroutineDispatcher = Dispatchers.IO\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/JobStructuredJoinStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n/**\n * Test a race between job failure and join.\n *\n * See [#1123](https://github.com/Kotlin/kotlinx.coroutines/issues/1123).\n */\nclass JobStructuredJoinStressTest : TestBase() {\n    private val nRepeats = 10_000 * stressTestMultiplier\n\n    @Test\n    fun testStressRegularJoin() = runTest {\n        stress(Job::join)\n    }\n\n    @Test\n    fun testStressSuspendCancellable() = runTest {\n        stress { job ->\n            suspendCancellableCoroutine { cont ->\n                job.invokeOnCompletion { cont.resume(Unit) }\n            }\n        }\n    }\n\n    @Test\n    fun testStressSuspendCancellableReusable() = runTest {\n        stress { job ->\n            suspendCancellableCoroutineReusable { cont ->\n                job.invokeOnCompletion { cont.resume(Unit) }\n            }\n        }\n    }\n\n    private fun stress(join: suspend (Job) -> Unit) {\n        expect(1)\n        repeat(nRepeats) { index ->\n            assertFailsWith<TestException> {\n                runBlocking {\n                    // launch in background\n                    val job = launch(Dispatchers.Default) {\n                        throw TestException(\"OK\") // crash\n                    }\n                    try {\n                        join(job)\n                        error(\"Should not complete successfully\")\n                    } catch (e: CancellationException) {\n                        // must always crash with cancellation exception\n                        expect(2 + index)\n                    } catch (e: Throwable) {\n                        error(\"Unexpected exception\", e)\n                    }\n                }\n            }\n        }\n        finish(2 + nRepeats)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/LimitedParallelismConcurrentTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.exceptions.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass LimitedParallelismConcurrentTest : TestBase() {\n\n    private val targetParallelism = 4\n    private val iterations = 100_000\n    private val parallelism = atomic(0)\n\n    private fun checkParallelism() {\n        val value = parallelism.incrementAndGet()\n        randomWait()\n        assertTrue { value <= targetParallelism }\n        parallelism.decrementAndGet()\n    }\n\n    @Test\n    fun testLimitedExecutor() = runTest {\n        val executor = newFixedThreadPoolContext(targetParallelism, \"test\")\n        val view = executor.limitedParallelism(targetParallelism)\n        doStress {\n            repeat(iterations) {\n                launch(view) {\n                    checkParallelism()\n                }\n            }\n        }\n        executor.close()\n    }\n\n    private suspend inline fun doStress(crossinline block: suspend CoroutineScope.() -> Unit) {\n        repeat(stressTestMultiplier) {\n            coroutineScope {\n                block()\n            }\n        }\n    }\n\n    @Test\n    fun testTaskFairness() = runTest {\n        val executor = newSingleThreadContext(\"test\")\n        val view = executor.limitedParallelism(1)\n        val view2 = executor.limitedParallelism(1)\n        val j1 = launch(view) {\n            while (true) {\n                yield()\n            }\n        }\n        val j2 = launch(view2) { j1.cancel() }\n        joinAll(j1, j2)\n        executor.close()\n    }\n\n    /**\n     * Tests that, when no tasks are present, the limited dispatcher does not dispatch any tasks.\n     * This is important for the case when a dispatcher is closeable and the [CoroutineDispatcher.limitedParallelism]\n     * machinery could trigger a dispatch after the dispatcher is closed.\n     */\n    @Test\n    fun testNotDoingDispatchesWhenNoTasksArePresent() = runTest {\n        class NaggingDispatcher: CoroutineDispatcher() {\n            private val closed = atomic(false)\n            override fun dispatch(context: CoroutineContext, block: Runnable) {\n                if (closed.value)\n                    fail(\"Dispatcher was closed, but still dispatched a task\")\n                Dispatchers.Default.dispatch(context, block)\n            }\n            fun close() {\n                closed.value = true\n            }\n        }\n        repeat(stressTestMultiplier * 500_000) {\n            val dispatcher = NaggingDispatcher()\n            val view = dispatcher.limitedParallelism(1)\n            val deferred = CompletableDeferred<Unit>()\n            val job = launch(view) {\n                deferred.await()\n            }\n            launch(Dispatchers.Default) {\n                deferred.complete(Unit)\n            }\n            job.join()\n            dispatcher.close()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/MultithreadedDispatcherStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass MultithreadedDispatcherStressTest {\n    private val shared = atomic(0)\n\n    /**\n     * Tests that [newFixedThreadPoolContext] will not drop tasks when closed.\n     */\n    @Test\n    fun testClosingNotDroppingTasks() {\n        repeat(7) {\n            shared.value = 0\n            val nThreads = it + 1\n            val dispatcher = newFixedThreadPoolContext(nThreads, \"testMultiThreadedContext\")\n            repeat(1_000) {\n                dispatcher.dispatch(EmptyCoroutineContext, Runnable {\n                    shared.incrementAndGet()\n                })\n            }\n            dispatcher.close()\n            while (shared.value < 1_000) {\n                // spin.\n                // the test will hang here if the dispatcher drops tasks.\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/RunBlockingTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.exceptions.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass RunBlockingTest : TestBase() {\n\n    @Test\n    fun testWithTimeoutBusyWait() = runTest {\n        val value = withTimeoutOrNull(10) {\n            while (isActive) {\n                // Busy wait\n            }\n            \"value\"\n        }\n\n        assertEquals(\"value\", value)\n    }\n\n    @Test\n    fun testPrivateEventLoop() {\n        expect(1)\n        runBlocking {\n            expect(2)\n            assertIs<EventLoop>(coroutineContext[ContinuationInterceptor])\n            yield() // is supported!\n            expect(3)\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testOuterEventLoop() {\n        expect(1)\n        runBlocking {\n            expect(2)\n            val outerEventLoop = coroutineContext[ContinuationInterceptor] as EventLoop\n            runBlocking(coroutineContext) {\n                expect(3)\n                // still same event loop\n                assertSame(coroutineContext[ContinuationInterceptor], outerEventLoop)\n                yield() // still works\n                expect(4)\n            }\n            expect(5)\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testOtherDispatcher() = runTest {\n        expect(1)\n        val name = \"RunBlockingTest.testOtherDispatcher\"\n        val thread = newSingleThreadContext(name)\n        runBlocking(thread) {\n            expect(2)\n            assertSame(coroutineContext[ContinuationInterceptor], thread)\n            assertTrue(currentThreadName().contains(name))\n            yield() // should work\n            expect(3)\n        }\n        finish(4)\n        thread.close()\n    }\n\n    @Test\n    fun testCancellation()  = runTest {\n        newFixedThreadPoolContext(2, \"testCancellation\").use {\n            val job = GlobalScope.launch(it) {\n                runBlocking(coroutineContext) {\n                    while (true) {\n                        yield()\n                    }\n                }\n            }\n\n            runBlocking {\n                job.cancelAndJoin()\n            }\n        }\n    }\n\n    @Test\n    fun testCancelWithDelay() {\n        // see https://github.com/Kotlin/kotlinx.coroutines/issues/586\n        try {\n            runBlocking {\n                expect(1)\n                coroutineContext.cancel()\n                expect(2)\n                try {\n                    delay(1)\n                    expectUnreached()\n                } finally {\n                    expect(3)\n                }\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testDispatchOnShutdown(): Unit = assertFailsWith<CancellationException> {\n        runBlocking {\n            expect(1)\n            val job = launch(NonCancellable) {\n                try {\n                    expect(2)\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    finish(4)\n                }\n            }\n\n            yield()\n            expect(3)\n            coroutineContext.cancel()\n            job.cancel()\n        }\n    }.let { }\n\n    @Test\n    fun testDispatchOnShutdown2(): Unit = assertFailsWith<CancellationException> {\n        runBlocking {\n            coroutineContext.cancel()\n            expect(1)\n            val job = launch(NonCancellable, start = CoroutineStart.UNDISPATCHED) {\n                try {\n                    expect(2)\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    finish(4)\n                }\n            }\n\n            expect(3)\n            job.cancel()\n        }\n    }.let { }\n\n    @Test\n    fun testNestedRunBlocking() = runBlocking {\n        delay(100)\n        val value = runBlocking {\n            delay(100)\n            runBlocking {\n                delay(100)\n                1\n            }\n        }\n\n        assertEquals(1, value)\n    }\n\n    @Test\n    fun testIncompleteState() {\n        val handle = runBlocking {\n            // See #835\n            coroutineContext[Job]!!.invokeOnCompletion { }\n        }\n\n        handle.dispose()\n    }\n\n    @Test\n    fun testCancelledParent() {\n        val job = Job()\n        job.cancel()\n        assertFailsWith<CancellationException> {\n            runBlocking(job) {\n                expectUnreached()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/channels/BroadcastChannelSubStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\n/**\n * Creates a broadcast channel and repeatedly opens new subscription, receives event, closes it,\n * to stress test the logic of opening the subscription\n * to broadcast channel while events are being concurrently sent to it.\n */\nclass BroadcastChannelSubStressTest: TestBase() {\n\n    private val nSeconds = maxOf(5, stressTestMultiplier)\n    private val sentTotal = atomic(0L)\n    private val receivedTotal = atomic(0L)\n\n    @Test\n    fun testStress() = runTest {\n        TestBroadcastChannelKind.entries.forEach { kind ->\n            println(\"--- BroadcastChannelSubStressTest $kind\")\n            val broadcast = kind.create<Long>()\n            val sender =\n                launch(context = Dispatchers.Default + CoroutineName(\"Sender\")) {\n                    while (isActive) {\n                        broadcast.send(sentTotal.incrementAndGet())\n                    }\n                }\n            val receiver =\n                launch(context = Dispatchers.Default + CoroutineName(\"Receiver\")) {\n                    var last = -1L\n                    while (isActive) {\n                        val channel = broadcast.openSubscription()\n                        val i = channel.receive()\n                        check(i >= last) { \"Last was $last, got $i\" }\n                        if (!kind.isConflated) check(i != last) { \"Last was $last, got it again\" }\n                        receivedTotal.incrementAndGet()\n                        last = i\n                        channel.cancel()\n                    }\n                }\n            var prevSent = -1L\n            repeat(nSeconds) { sec ->\n                delay(1000)\n                val curSent = sentTotal.value\n                println(\"${sec + 1}: Sent $curSent, received ${receivedTotal.value}\")\n                check(curSent > prevSent) { \"Send stalled at $curSent events\" }\n                prevSent = curSent\n            }\n            withTimeout(5000) {\n                sender.cancelAndJoin()\n                receiver.cancelAndJoin()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/channels/ChannelCancelUndeliveredElementStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.random.*\nimport kotlin.test.*\n\nclass ChannelCancelUndeliveredElementStressTest : TestBase() {\n    private val repeatTimes = (if (isNative) 1_000 else 10_000) * stressTestMultiplier\n\n    // total counters\n    private var sendCnt = 0\n    private var trySendFailedCnt = 0\n    private var receivedCnt = 0\n    private var undeliveredCnt = 0\n\n    // last operation\n    private var lastReceived = 0\n    private var dSendCnt = 0\n    private var dSendExceptionCnt = 0\n    private var dTrySendFailedCnt = 0\n    private var dReceivedCnt = 0\n    private val dUndeliveredCnt = atomic(0)\n\n    @Test\n    fun testStress() = runTest {\n        repeat(repeatTimes) {\n            val channel = Channel<Int>(1) { dUndeliveredCnt.incrementAndGet() }\n            val j1 = launch(Dispatchers.Default) {\n                sendOne(channel) // send first\n                sendOne(channel) // send second\n            }\n            val j2 = launch(Dispatchers.Default) {\n                receiveOne(channel) // receive one element from the channel\n                channel.cancel() // cancel the channel\n            }\n\n            joinAll(j1, j2)\n\n            // All elements must be either received or undelivered (IN every run)\n            if (dSendCnt - dTrySendFailedCnt != dReceivedCnt + dUndeliveredCnt.value) {\n                println(\"          Send: $dSendCnt\")\n                println(\"Send exception: $dSendExceptionCnt\")\n                println(\"trySend failed: $dTrySendFailedCnt\")\n                println(\"      Received: $dReceivedCnt\")\n                println(\"   Undelivered: ${dUndeliveredCnt.value}\")\n                error(\"Failed\")\n            }\n            (channel as? BufferedChannel<*>)?.checkSegmentStructureInvariants()\n            trySendFailedCnt += dTrySendFailedCnt\n            receivedCnt += dReceivedCnt\n            undeliveredCnt += dUndeliveredCnt.value\n            // clear for next run\n            dSendCnt = 0\n            dSendExceptionCnt = 0\n            dTrySendFailedCnt = 0\n            dReceivedCnt = 0\n            dUndeliveredCnt.value = 0\n        }\n        // Stats\n        println(\"          Send: $sendCnt\")\n        println(\"trySend failed: $trySendFailedCnt\")\n        println(\"      Received: $receivedCnt\")\n        println(\"   Undelivered: $undeliveredCnt\")\n        assertEquals(sendCnt - trySendFailedCnt, receivedCnt + undeliveredCnt)\n    }\n\n    private suspend fun sendOne(channel: Channel<Int>) {\n        dSendCnt++\n        val i = ++sendCnt\n        try {\n            when (Random.nextInt(2)) {\n                0 -> channel.send(i)\n                1 -> if (!channel.trySend(i).isSuccess) {\n                    dTrySendFailedCnt++\n                }\n            }\n        } catch (e: Throwable) {\n            assertIs<CancellationException>(e) // the only exception possible in this test\n            dSendExceptionCnt++\n            throw e\n        }\n    }\n\n    private suspend fun receiveOne(channel: Channel<Int>) {\n        val received = when (Random.nextInt(3)) {\n            0 -> channel.receive()\n            1 -> channel.receiveCatching().getOrElse { error(\"Cannot be closed yet\") }\n            2 -> select {\n                channel.onReceive { it }\n            }\n            else -> error(\"Cannot happen\")\n        }\n        assertTrue(received > lastReceived)\n        dReceivedCnt++\n        lastReceived = received\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/channels/ConflatedBroadcastChannelNotifyStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass ConflatedBroadcastChannelNotifyStressTest : TestBase() {\n    private val nSenders = 2\n    private val nReceivers = 3\n    private val nEvents =  (if (isNative) 5_000 else 500_000) * stressTestMultiplier\n    private val timeLimit = 30_000L * stressTestMultiplier // 30 sec\n\n    private val broadcast = ConflatedBroadcastChannel<Int>()\n\n    private val sendersCompleted = atomic(0)\n    private val receiversCompleted = atomic(0)\n    private val sentTotal = atomic(0)\n    private val receivedTotal = atomic(0)\n\n    @Test\n    fun testStressNotify()= runTest {\n        println(\"--- ConflatedBroadcastChannelNotifyStressTest\")\n        val senders = List(nSenders) { senderId ->\n            launch(Dispatchers.Default + CoroutineName(\"Sender$senderId\")) {\n                repeat(nEvents) { i ->\n                    if (i % nSenders == senderId) {\n                        broadcast.trySend(i)\n                        sentTotal.incrementAndGet()\n                        yield()\n                    }\n                }\n                sendersCompleted.incrementAndGet()\n            }\n        }\n        val receivers = List(nReceivers) { receiverId ->\n            launch(Dispatchers.Default + CoroutineName(\"Receiver$receiverId\")) {\n                var last = -1\n                while (isActive) {\n                    val i = waitForEvent()\n                    if (i > last) {\n                        receivedTotal.incrementAndGet()\n                        last = i\n                    }\n                    if (i >= nEvents) break\n                    yield()\n                }\n                receiversCompleted.incrementAndGet()\n            }\n        }\n        // print progress\n        val progressJob = launch {\n            var seconds = 0\n            while (true) {\n                delay(1000)\n                println(\"${++seconds}: Sent ${sentTotal.value}, received ${receivedTotal.value}\")\n            }\n        }\n        try {\n            withTimeout(timeLimit) {\n                senders.forEach { it.join() }\n                broadcast.trySend(nEvents) // last event to signal receivers termination\n                receivers.forEach { it.join() }\n            }\n        } catch (e: CancellationException) {\n            println(\"!!! Test timed out $e\")\n        }\n        progressJob.cancel()\n        println(\"Tested with nSenders=$nSenders, nReceivers=$nReceivers\")\n        println(\"Completed successfully ${sendersCompleted.value} sender coroutines\")\n        println(\"Completed successfully ${receiversCompleted.value} receiver coroutines\")\n        println(\"                  Sent ${sentTotal.value} events\")\n        println(\"              Received ${receivedTotal.value} events\")\n        assertEquals(nSenders, sendersCompleted.value)\n        assertEquals(nReceivers, receiversCompleted.value)\n        assertEquals(nEvents, sentTotal.value)\n    }\n\n    private suspend fun waitForEvent(): Int =\n        with(broadcast.openSubscription()) {\n            val value = receive()\n            cancel()\n            value\n        }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/channels/TrySendBlockingTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass TrySendBlockingTest : TestBase() {\n\n    @Test\n    fun testTrySendBlocking() = runBlocking<Unit> { // For old MM\n        val ch = Channel<Int>()\n        val sum = GlobalScope.async {\n            var sum = 0\n            ch.consumeEach { sum += it }\n            sum\n        }\n        repeat(10) {\n            assertTrue(ch.trySendBlocking(it).isSuccess)\n        }\n        ch.close()\n        assertEquals(45, runBlocking { sum.await() })\n    }\n\n    @Test\n    fun testTrySendBlockingClosedChannel() {\n        run {\n            val channel = Channel<Unit>().also { it.close() }\n            channel.trySendBlocking(Unit)\n                .onSuccess { expectUnreached() }\n                .onFailure { assertIs<ClosedSendChannelException>(it) }\n                .also { assertTrue { it.isClosed } }\n        }\n\n        run {\n            val channel = Channel<Unit>().also { it.close(TestException()) }\n            channel.trySendBlocking(Unit)\n                .onSuccess { expectUnreached() }\n                .onFailure { assertIs<TestException>(it) }\n                .also { assertTrue { it.isClosed } }\n        }\n\n        run {\n            val channel = Channel<Unit>().also { it.cancel(TestCancellationException()) }\n            channel.trySendBlocking(Unit)\n                .onSuccess { expectUnreached() }\n                .onFailure { assertIs<TestCancellationException>(it) }\n                .also { assertTrue { it.isClosed } }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/flow/CombineStressTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass CombineStressTest : TestBase() {\n\n    @Test\n    fun testCancellation() = runTest {\n        withContext(Dispatchers.Default + CoroutineExceptionHandler { _, _ -> expectUnreached() }) {\n            flow {\n                expect(1)\n                repeat(1_000 * stressTestMultiplier) {\n                    emit(it)\n                }\n            }.flatMapLatest {\n                combine(flowOf(it), flowOf(it)) { arr -> arr[0] }\n            }.collect()\n            finish(2)\n            reset()\n        }\n    }\n\n    @Test\n    fun testFailure() = runTest {\n        val innerIterations = 100 * stressTestMultiplierSqrt\n        val outerIterations = 10 * stressTestMultiplierSqrt\n        withContext(Dispatchers.Default + CoroutineExceptionHandler { _, _ -> expectUnreached() }) {\n            repeat(outerIterations) {\n                try {\n                    flow {\n                        expect(1)\n                        repeat(innerIterations) {\n                            emit(it)\n                        }\n                    }.flatMapLatest {\n                        combine(flowOf(it), flowOf(it)) { arr -> arr[0] }\n                    }.onEach {\n                        if (it >= innerIterations / 2) throw TestException()\n                    }.collect()\n                } catch (e: TestException) {\n                    expect(2)\n                }\n                finish(3)\n                reset()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/flow/FlowCancellationTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\n\nclass FlowCancellationTest : TestBase() {\n\n    @Test\n    fun testEmitIsCooperative() = runTest {\n        val latch = Channel<Unit>(1)\n        val job = flow {\n            expect(1)\n            latch.send(Unit)\n            while (true) {\n                emit(42)\n            }\n        }.launchIn(this + Dispatchers.Default)\n\n        latch.receive()\n        expect(2)\n        job.cancelAndJoin()\n        finish(3)\n    }\n\n    @Test\n    fun testIsActiveOnCurrentContext() = runTest {\n        val latch = Channel<Unit>(1)\n        val job = flow<Unit> {\n            expect(1)\n            latch.send(Unit)\n            while (currentCoroutineContext().isActive) {\n                // Do nothing\n            }\n        }.launchIn(this + Dispatchers.Default)\n\n        latch.receive()\n        expect(2)\n        job.cancelAndJoin()\n        finish(3)\n    }\n\n    @Test\n    fun testFlowWithEmptyContext() = runTest {\n        expect(1)\n        withEmptyContext {\n            val flow = flow {\n                expect(2)\n                emit(\"OK\")\n            }\n            flow.collect {\n                expect(3)\n                assertEquals(\"OK\", it)\n            }\n        }\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/flow/StateFlowCommonStressTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.random.*\nimport kotlin.test.*\n\n// A simplified version of StateFlowStressTest\nclass StateFlowCommonStressTest : TestBase() {\n    private val state = MutableStateFlow<Long>(0)\n\n    @Test\n    fun testSingleEmitterAndCollector() = runTest {\n        var collected = 0L\n        val collector = launch(Dispatchers.Default) {\n            // collect, but abort and collect again after every 1000 values to stress allocation/deallocation\n            do {\n                val batchSize = Random.nextInt(1..1000)\n                var index = 0\n                val cnt = state.onEach { value ->\n                    // the first value in batch is allowed to repeat, but cannot go back\n                    val ok = if (index++ == 0) value >= collected else value > collected\n                    check(ok) {\n                        \"Values must be monotonic, but $value is not, was $collected\"\n                    }\n                    collected = value\n                }.take(batchSize).map { 1 }.sum()\n            } while (cnt == batchSize)\n        }\n\n        var current = 1L\n        val emitter = launch {\n            while (true) {\n                state.value = current++\n                if (current % 1000 == 0L) yield() // make it cancellable\n            }\n        }\n\n        delay(3000)\n        emitter.cancelAndJoin()\n        collector.cancelAndJoin()\n        assertTrue { current >= collected / 2 }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/flow/StateFlowUpdateCommonTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\n\n// A simplified version of StateFlowUpdateStressTest\nclass StateFlowUpdateCommonTest : TestBase() {\n    private val iterations = 100_000 * stressTestMultiplier\n\n    @Test\n    fun testUpdate() = doTest { update { it + 1 } }\n\n    @Test\n    fun testUpdateAndGet() = doTest { updateAndGet { it + 1 } }\n\n    @Test\n    fun testGetAndUpdate() = doTest { getAndUpdate { it + 1 } }\n\n    private fun doTest(increment: MutableStateFlow<Int>.() -> Unit) = runTest {\n        val flow = MutableStateFlow(0)\n        val j1 = launch(Dispatchers.Default) {\n            repeat(iterations / 2) {\n                flow.increment()\n            }\n        }\n\n        repeat(iterations / 2) {\n            flow.increment()\n        }\n\n        joinAll(j1)\n        assertEquals(iterations, flow.value)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/selects/SelectChannelStressTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass SelectChannelStressTest: TestBase() {\n\n    // Running less iterations on native platforms because of some performance regression\n    private val iterations = (if (isNative) 1_000 else 1_000_000) * stressTestMultiplier\n\n    @Test\n    fun testSelectSendResourceCleanupBufferedChannel() = runTest {\n        val channel = Channel<Int>(1)\n        expect(1)\n        channel.send(-1) // fill the buffer, so all subsequent sends cannot proceed\n        repeat(iterations) { i ->\n            select {\n                channel.onSend(i) { expectUnreached() }\n                default { expect(i + 2) }\n            }\n        }\n        finish(iterations + 2)\n    }\n\n    @Test\n    fun testSelectReceiveResourceCleanupBufferedChannel() = runTest {\n        val channel = Channel<Int>(1)\n        expect(1)\n        repeat(iterations) { i ->\n            select {\n                channel.onReceive { expectUnreached() }\n                default { expect(i + 2) }\n            }\n        }\n        finish(iterations + 2)\n    }\n\n    @Test\n    fun testSelectSendResourceCleanupRendezvousChannel() = runTest {\n        val channel = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        repeat(iterations) { i ->\n            select {\n                channel.onSend(i) { expectUnreached() }\n                default { expect(i + 2) }\n            }\n        }\n        finish(iterations + 2)\n    }\n\n    @Test\n    fun testSelectReceiveResourceRendezvousChannel() = runTest {\n        val channel = Channel<Int>(Channel.RENDEZVOUS)\n        expect(1)\n        repeat(iterations) { i ->\n            select {\n                channel.onReceive { expectUnreached() }\n                default { expect(i + 2) }\n            }\n        }\n        finish(iterations + 2)\n    }\n\n    internal fun <R> SelectBuilder<R>.default(block: suspend () -> R) = onTimeout(0, block)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/selects/SelectMutexStressTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.test.*\n\nclass SelectMutexStressTest : TestBase() {\n    @Test\n    fun testSelectCancelledResourceRelease() = runTest {\n        val n = 1_000 * stressTestMultiplier\n        val mutex = Mutex(true) as MutexImpl // locked\n        expect(1)\n        repeat(n) { i ->\n            val job = launch(kotlin.coroutines.coroutineContext) {\n                expect(i + 2)\n                select<Unit> {\n                    mutex.onLock {\n                        expectUnreached() // never able to lock\n                    }\n                }\n            }\n            yield() // to the launched job, so that it suspends\n            job.cancel() // cancel the job and select\n            yield() // so it can cleanup after itself\n        }\n        assertTrue(mutex.isLocked)\n        finish(n + 2)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/sync/MutexStressTest.kt",
        "content": "package kotlinx.coroutines.sync\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.exceptions.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.test.*\n\nclass MutexStressTest : TestBase() {\n\n    private val n = 1000 * stressTestMultiplier // It mostly stresses K/N as JVM Mutex is tested by lincheck\n\n    @Test\n    fun testDefaultDispatcher() = runTest { testBody(Dispatchers.Default) }\n\n    @Test\n    fun testSingleThreadContext() = runTest {\n        newSingleThreadContext(\"testSingleThreadContext\").use {\n            testBody(it)\n        }\n    }\n\n    @Test\n    fun testMultiThreadedContextWithSingleWorker() = runTest {\n        newFixedThreadPoolContext(1, \"testMultiThreadedContextWithSingleWorker\").use {\n            testBody(it)\n        }\n    }\n\n    @Test\n    fun testMultiThreadedContext() = runTest {\n       newFixedThreadPoolContext(8, \"testMultiThreadedContext\").use {\n            testBody(it)\n        }\n    }\n\n    @Suppress(\"SuspendFunctionOnCoroutineScope\")\n    private suspend fun CoroutineScope.testBody(dispatcher: CoroutineDispatcher) {\n        val k = 100\n        var shared = 0\n        val mutex = Mutex()\n        val jobs = List(n) {\n            launch(dispatcher) {\n                repeat(k) {\n                    mutex.lock()\n                    shared++\n                    mutex.unlock()\n                }\n            }\n        }\n        jobs.forEach { it.join() }\n        assertEquals(n * k, shared)\n    }\n\n    @Test\n    fun stressUnlockCancelRace() = runTest {\n        val n = 10_000 * stressTestMultiplier\n        val mutex = Mutex(true) // create a locked mutex\n        newSingleThreadContext(\"SemaphoreStressTest\").use { pool ->\n            repeat(n) {\n                // Initially, we hold the lock and no one else can `lock`,\n                // otherwise it's a bug.\n                assertTrue(mutex.isLocked)\n                var job1EnteredCriticalSection = false\n                val job1 = launch(start = CoroutineStart.UNDISPATCHED) {\n                    mutex.lock()\n                    job1EnteredCriticalSection = true\n                    mutex.unlock()\n                }\n                // check that `job1` didn't finish the call to `acquire()`\n                assertEquals(false, job1EnteredCriticalSection)\n                val job2 = launch(pool) {\n                    mutex.unlock()\n                }\n                // Because `job2` executes in a separate thread, this\n                // cancellation races with the call to `unlock()`.\n                job1.cancelAndJoin()\n                job2.join()\n                assertFalse(mutex.isLocked)\n                mutex.lock()\n            }\n        }\n    }\n\n    @Test\n    fun stressUnlockCancelRaceWithSelect() = runTest {\n        val n = 10_000 * stressTestMultiplier\n        val mutex = Mutex(true) // create a locked mutex\n        newSingleThreadContext(\"SemaphoreStressTest\").use { pool ->\n            repeat(n) {\n                // Initially, we hold the lock and no one else can `lock`,\n                // otherwise it's a bug.\n                assertTrue(mutex.isLocked)\n                var job1EnteredCriticalSection = false\n                val job1 = launch(start = CoroutineStart.UNDISPATCHED) {\n                    select<Unit> {\n                        mutex.onLock {\n                            job1EnteredCriticalSection = true\n                            mutex.unlock()\n                        }\n                    }\n                }\n                // check that `job1` didn't finish the call to `acquire()`\n                assertEquals(false, job1EnteredCriticalSection)\n                val job2 = launch(pool) {\n                    mutex.unlock()\n                }\n                // Because `job2` executes in a separate thread, this\n                // cancellation races with the call to `unlock()`.\n                job1.cancelAndJoin()\n                job2.join()\n                assertFalse(mutex.isLocked)\n                mutex.lock()\n            }\n        }\n    }\n\n    @Test\n    fun testShouldBeUnlockedOnCancellation() = runTest {\n        val mutex = Mutex()\n        val n = 1000 * stressTestMultiplier\n        repeat(n) {\n            val job = launch(Dispatchers.Default) {\n                mutex.lock()\n                mutex.unlock()\n            }\n            mutex.withLock {\n                job.cancel()\n            }\n            job.join()\n            assertFalse { mutex.isLocked }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/concurrent/test/sync/SemaphoreStressTest.kt",
        "content": "package kotlinx.coroutines.sync\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.exceptions.*\nimport kotlin.test.*\n\nclass SemaphoreStressTest : TestBase() {\n\n    private val iterations = (if (isNative) 1_000 else 10_000) * stressTestMultiplier\n\n    @Test\n    fun testStressTestAsMutex() = runTest {\n        val n = iterations\n        val k = 100\n        var shared = 0\n        val semaphore = Semaphore(1)\n        val jobs = List(n) {\n            launch(Dispatchers.Default) {\n                repeat(k) {\n                    semaphore.acquire()\n                    shared++\n                    semaphore.release()\n                }\n            }\n        }\n        jobs.forEach { it.join() }\n        assertEquals(n * k, shared)\n    }\n\n    @Test\n    fun testStress() = runTest {\n        val n = iterations\n        val k = 100\n        val semaphore = Semaphore(10)\n        val jobs = List(n) {\n            launch(Dispatchers.Default) {\n                repeat(k) {\n                    semaphore.acquire()\n                    semaphore.release()\n                }\n            }\n        }\n        jobs.forEach { it.join() }\n    }\n\n    @Test\n    fun testStressAsMutex() = runTest {\n        runBlocking(Dispatchers.Default) {\n            val n = iterations\n            val k = 100\n            var shared = 0\n            val semaphore = Semaphore(1)\n            val jobs = List(n) {\n                launch {\n                    repeat(k) {\n                        semaphore.acquire()\n                        shared++\n                        semaphore.release()\n                    }\n                }\n            }\n            jobs.forEach { it.join() }\n            assertEquals(n * k, shared)\n        }\n    }\n\n    @Test\n    fun testStressCancellation() = runTest {\n        val n = iterations\n        val semaphore = Semaphore(1)\n        semaphore.acquire()\n        repeat(n) {\n            val job = launch(Dispatchers.Default) {\n                semaphore.acquire()\n            }\n            yield()\n            job.cancelAndJoin()\n        }\n        assertEquals(0, semaphore.availablePermits)\n        semaphore.release()\n        assertEquals(1, semaphore.availablePermits)\n    }\n\n    /**\n     * This checks if repeated releases that race with cancellations put\n     * the semaphore into an incorrect state where permits are leaked.\n     */\n    @Test\n    fun testStressReleaseCancelRace() = runTest {\n        val n = iterations\n        val semaphore = Semaphore(1, 1)\n        newSingleThreadContext(\"SemaphoreStressTest\").use { pool ->\n            repeat (n) {\n                // Initially, we hold the permit and no one else can `acquire`,\n                // otherwise it's a bug.\n                assertEquals(0, semaphore.availablePermits)\n                var job1EnteredCriticalSection = false\n                val job1 = launch(start = CoroutineStart.UNDISPATCHED) {\n                    semaphore.acquire()\n                    job1EnteredCriticalSection = true\n                    semaphore.release()\n                }\n                // check that `job1` didn't finish the call to `acquire()`\n                assertEquals(false, job1EnteredCriticalSection)\n                val job2 = launch(pool) {\n                    semaphore.release()\n                }\n                // Because `job2` executes in a separate thread, this\n                // cancellation races with the call to `release()`.\n                job1.cancelAndJoin()\n                job2.join()\n                assertEquals(1, semaphore.availablePermits)\n                semaphore.acquire()\n            }\n        }\n    }\n\n    @Test\n    fun testShouldBeUnlockedOnCancellation() = runTest {\n        val semaphore = Semaphore(1)\n        val n = 1000 * stressTestMultiplier\n        repeat(n) {\n            val job = launch(Dispatchers.Default) {\n                semaphore.acquire()\n                semaphore.release()\n            }\n            semaphore.withPermit {\n                job.cancel()\n            }\n            job.join()\n            assertTrue { semaphore.availablePermits == 1 }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jdk8/src/future/Future.kt",
        "content": "package kotlinx.coroutines.future\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport java.util.concurrent.*\nimport java.util.function.*\nimport kotlin.coroutines.*\n\n/**\n * Starts a new coroutine and returns its result as an implementation of [CompletableFuture].\n * The running coroutine is cancelled when the resulting future is cancelled or otherwise completed.\n *\n * The coroutine context is inherited from a [CoroutineScope], additional context elements can be specified with the [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * The parent job is inherited from a [CoroutineScope] as well, but it can also be overridden\n * with corresponding [context] element.\n *\n * By default, the coroutine is immediately scheduled for execution.\n * Other options can be specified via `start` parameter. See [CoroutineStart] for details.\n * A value of [CoroutineStart.LAZY] is not supported\n * (since `CompletableFuture` framework does not provide the corresponding capability) and\n * produces [IllegalArgumentException].\n *\n * See [newCoroutineContext][CoroutineScope.newCoroutineContext] for a description of debugging facilities that are available for newly created coroutine.\n *\n * @param context additional to [CoroutineScope.coroutineContext] context of the coroutine.\n * @param start coroutine start option. The default value is [CoroutineStart.DEFAULT].\n * @param block the coroutine code.\n */\npublic fun <T> CoroutineScope.future(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -> T\n) : CompletableFuture<T> {\n    require(!start.isLazy) { \"$start start is not supported\" }\n    val newContext = this.newCoroutineContext(context)\n    val future = CompletableFuture<T>()\n    val coroutine = CompletableFutureCoroutine(newContext, future)\n    future.handle(coroutine) // Cancel coroutine if future was completed externally\n    coroutine.start(start, coroutine, block)\n    return future\n}\n\nprivate class CompletableFutureCoroutine<T>(\n    context: CoroutineContext,\n    private val future: CompletableFuture<T>\n) : AbstractCoroutine<T>(context, initParentJob = true, active = true), BiFunction<T?, Throwable?, Unit> {\n    override fun apply(value: T?, exception: Throwable?) {\n        cancel()\n    }\n\n    override fun onCompleted(value: T) {\n        future.complete(value)\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        /*\n         * Here we can potentially lose the cause if the failure is racing with future's\n         * external cancellation. We are consistent with other future implementations\n         * (LF, FT, CF) and give up on such exception.\n         */\n        future.completeExceptionally(cause)\n    }\n}\n\n/**\n * Converts this deferred value to the instance of [CompletableFuture].\n * The deferred value is cancelled when the resulting future is cancelled or otherwise completed.\n */\npublic fun <T> Deferred<T>.asCompletableFuture(): CompletableFuture<T> {\n    val future = CompletableFuture<T>()\n    setupCancellation(future)\n    invokeOnCompletion {\n        try {\n            future.complete(getCompleted())\n        } catch (t: Throwable) {\n            future.completeExceptionally(t)\n        }\n    }\n    return future\n}\n\n/**\n * Converts this job to the instance of [CompletableFuture].\n * The job is cancelled when the resulting future is cancelled or otherwise completed.\n */\npublic fun Job.asCompletableFuture(): CompletableFuture<Unit> {\n    val future = CompletableFuture<Unit>()\n    setupCancellation(future)\n    invokeOnCompletion { cause ->\n        if (cause === null) future.complete(Unit)\n        else future.completeExceptionally(cause)\n    }\n    return future\n}\n\nprivate fun Job.setupCancellation(future: CompletableFuture<*>) {\n    future.handle { _, exception ->\n        cancel(exception?.let {\n            it as? CancellationException ?: CancellationException(\"CompletableFuture was completed exceptionally\", it)\n        })\n    }\n}\n\n/**\n * Converts this [CompletionStage] to an instance of [Deferred].\n *\n * The [CompletableFuture] that corresponds to this [CompletionStage] (see [CompletionStage.toCompletableFuture])\n * is cancelled when the resulting deferred is cancelled.\n */\n@Suppress(\"DeferredIsResult\")\npublic fun <T> CompletionStage<T>.asDeferred(): Deferred<T> {\n    val future = toCompletableFuture() // retrieve the future\n    // Fast path if already completed\n    if (future.isDone) {\n        return try {\n            @Suppress(\"UNCHECKED_CAST\")\n            CompletableDeferred(future.get() as T)\n        } catch (e: Throwable) {\n            // unwrap original cause from ExecutionException\n            val original = (e as? ExecutionException)?.cause ?: e\n            CompletableDeferred<T>().also { it.completeExceptionally(original) }\n        }\n    }\n    val result = CompletableDeferred<T>()\n    handle { value, exception ->\n        try {\n            if (exception == null) {\n                // the future has completed normally\n                result.complete(value)\n            } else {\n                // the future has completed with an exception, unwrap it consistently with fast path\n                // Note: In the fast-path the implementation of CompletableFuture.get() does unwrapping\n                result.completeExceptionally((exception as? CompletionException)?.cause ?: exception)\n            }\n        } catch (e: Throwable) {\n            // We come here iff the internals of Deferred threw an exception during its completion\n            handleCoroutineException(EmptyCoroutineContext, e)\n        }\n    }\n    result.cancelFutureOnCompletion(future)\n    return result\n}\n\n/**\n * Awaits for completion of [CompletionStage] without blocking a thread.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function\n * stops waiting for the completion stage and immediately resumes with [CancellationException][kotlinx.coroutines.CancellationException].\n *\n * This method is intended to be used with one-shot futures, so on coroutine cancellation the [CompletableFuture] that\n * corresponds to this [CompletionStage] (see [CompletionStage.toCompletableFuture])\n * is cancelled. If cancelling the given stage is undesired, `stage.asDeferred().await()` should be used instead.\n */\npublic suspend fun <T> CompletionStage<T>.await(): T {\n    val future = toCompletableFuture() // retrieve the future\n    // fast path when CompletableFuture is already done (does not suspend)\n    if (future.isDone) {\n        try {\n            @Suppress(\"UNCHECKED_CAST\", \"BlockingMethodInNonBlockingContext\")\n            return future.get() as T\n        } catch (e: ExecutionException) {\n            throw e.cause ?: e // unwrap original cause from ExecutionException\n        }\n    }\n    // slow path -- suspend\n    return suspendCancellableCoroutine { cont: CancellableContinuation<T> ->\n        val consumer = ContinuationHandler(cont)\n        handle(consumer)\n        cont.invokeOnCancellation {\n            future.cancel(false)\n            consumer.cont = null // shall clear reference to continuation to aid GC\n        }\n    }\n}\n\nprivate class ContinuationHandler<T>(\n    @Volatile @JvmField var cont: Continuation<T>?\n) : BiFunction<T?, Throwable?, Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun apply(result: T?, exception: Throwable?) {\n        val cont = this.cont ?: return // atomically read current value unless null\n        if (exception == null) {\n            // the future has completed normally\n            cont.resume(result as T)\n        } else {\n            // the future has completed with an exception, unwrap it to provide consistent view of .await() result and to propagate only original exception\n            cont.resumeWithException((exception as? CompletionException)?.cause ?: exception)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jdk8/src/stream/Stream.kt",
        "content": "package kotlinx.coroutines.stream\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport java.util.stream.*\n\n/**\n * Represents the given stream as a flow and [closes][Stream.close] the stream afterwards.\n * The resulting flow can be [collected][Flow.collect] only once\n * and throws [IllegalStateException] when trying to collect it more than once.\n */\npublic fun <T> Stream<T>.consumeAsFlow(): Flow<T> = StreamFlow(this)\n\nprivate class StreamFlow<T>(private val stream: Stream<T>) : Flow<T> {\n    private val consumed = atomic(false)\n\n    override suspend fun collect(collector: FlowCollector<T>) {\n        if (!consumed.compareAndSet(false, true)) error(\"Stream.consumeAsFlow can be collected only once\")\n        try {\n            for (value in stream.iterator()) {\n                collector.emit(value)\n            }\n        } finally {\n            stream.close()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jdk8/src/time/Time.kt",
        "content": "@file:OptIn(ExperimentalContracts::class)\n\npackage kotlinx.coroutines.time\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.selects.*\nimport java.time.*\nimport java.time.temporal.*\nimport kotlin.contracts.*\n\n/**\n * \"java.time\" adapter method for [kotlinx.coroutines.delay].\n */\npublic suspend fun delay(duration: Duration): Unit = delay(duration.coerceToMillis())\n\n/**\n * \"java.time\" adapter method for [kotlinx.coroutines.flow.debounce].\n */\n@FlowPreview\npublic fun <T> Flow<T>.debounce(timeout: Duration): Flow<T> = debounce(timeout.coerceToMillis())\n\n/**\n * \"java.time\" adapter method for [kotlinx.coroutines.flow.sample].\n */\n@FlowPreview\npublic fun <T> Flow<T>.sample(period: Duration): Flow<T> = sample(period.coerceToMillis())\n\n/**\n * \"java.time\" adapter method for [SelectBuilder.onTimeout].\n */\npublic fun <R> SelectBuilder<R>.onTimeout(duration: Duration, block: suspend () -> R): Unit =\n        onTimeout(duration.coerceToMillis(), block)\n\n/**\n * \"java.time\" adapter method for [kotlinx.coroutines.withTimeout].\n */\npublic suspend fun <T> withTimeout(duration: Duration, block: suspend CoroutineScope.() -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return kotlinx.coroutines.withTimeout(duration.coerceToMillis(), block)\n}\n\n/**\n * \"java.time\" adapter method for [kotlinx.coroutines.withTimeoutOrNull].\n */\npublic suspend fun <T> withTimeoutOrNull(duration: Duration, block: suspend CoroutineScope.() -> T): T? =\n        kotlinx.coroutines.withTimeoutOrNull(duration.coerceToMillis(), block)\n\n/**\n * Coerces the given [Duration] to a millisecond delay.\n * Negative values are coerced to zero, values that cannot\n * be represented in milliseconds as long (\"infinite\" duration) are coerced to [Long.MAX_VALUE]\n * and durations lesser than a millisecond are coerced to 1 millisecond.\n *\n * The rationale of coercion:\n * 1) Too large durations typically indicate infinity and Long.MAX_VALUE is the\n *    best approximation of infinity we can provide.\n * 2) Coercing too small durations to 1 instead of 0 is crucial for two patterns:\n *    - Programming with deadlines and delays\n *    - Non-suspending fast-paths (e.g. `withTimeout(1 nanosecond) { 42 }` should not throw)\n */\nprivate fun Duration.coerceToMillis(): Long {\n    if (this <= Duration.ZERO) return 0\n    if (this <= ChronoUnit.MILLIS.duration) return 1\n\n    // Maximum scalar values of Duration.ofMillis(Long.MAX_VALUE)\n    val maxSeconds = 9223372036854775\n    val maxNanos = 807000000\n    return if (seconds < maxSeconds || seconds == maxSeconds && nano < maxNanos) toMillis()\n    else Long.MAX_VALUE\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/js/src/CoroutineContext.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.browser.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\nprivate external val navigator: dynamic\nprivate const val UNDEFINED = \"undefined\"\ninternal external val process: dynamic\n\ninternal actual fun createDefaultDispatcher(): CoroutineDispatcher = when {\n    // Check if we are running under jsdom. WindowDispatcher doesn't work under jsdom because it accesses MessageEvent#source.\n    // It is not implemented in jsdom, see https://github.com/jsdom/jsdom/blob/master/Changelog.md\n    // \"It's missing a few semantics, especially around origins, as well as MessageEvent source.\"\n    isJsdom() -> NodeDispatcher\n    // Check if we are in the browser and must use window.postMessage to avoid setTimeout throttling\n    jsTypeOf(window) != UNDEFINED && window.asDynamic() != null && jsTypeOf(window.asDynamic().addEventListener) != UNDEFINED ->\n        window.asCoroutineDispatcher()\n    // If process is undefined (e.g. in NativeScript, #1404), use SetTimeout-based dispatcher\n    jsTypeOf(process) == UNDEFINED || jsTypeOf(process.nextTick) == UNDEFINED -> SetTimeoutDispatcher\n    // Fallback to NodeDispatcher when browser environment is not detected\n    else -> NodeDispatcher\n}\n\nprivate fun isJsdom() = jsTypeOf(navigator) != UNDEFINED &&\n    navigator != null &&\n    navigator.userAgent != null &&\n    jsTypeOf(navigator.userAgent) != UNDEFINED &&\n    jsTypeOf(navigator.userAgent.match) != UNDEFINED &&\n    navigator.userAgent.match(\"\\\\bjsdom\\\\b\")\n\n@PublishedApi // Used from kotlinx-coroutines-test via suppress, not part of ABI\ninternal actual val DefaultDelay: Delay\n    get() = Dispatchers.Default as Delay\n\npublic actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {\n    val combined = coroutineContext + context\n    return if (combined !== Dispatchers.Default && combined[ContinuationInterceptor] == null)\n        combined + Dispatchers.Default else combined\n}\n\npublic actual fun CoroutineContext.newCoroutineContext(addedContext: CoroutineContext): CoroutineContext {\n    return this + addedContext\n}\n\n// No debugging facilities on JS\ninternal actual inline fun <T> withCoroutineContext(context: CoroutineContext, countOrElement: Any?, block: () -> T): T = block()\ninternal actual inline fun <T> withContinuationContext(continuation: Continuation<*>, countOrElement: Any?, block: () -> T): T = block()\ninternal actual fun Continuation<*>.toDebugString(): String = toString()\ninternal actual val CoroutineContext.coroutineName: String? get() = null // not supported on JS\n\ninternal actual class UndispatchedCoroutine<in T> actual constructor(\n    context: CoroutineContext,\n    uCont: Continuation<T>\n) : ScopeCoroutine<T>(context, uCont) {\n    override fun afterResume(state: Any?) = uCont.resumeWith(recoverResult(state, uCont))\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/js/src/Debug.kt",
        "content": "package kotlinx.coroutines\n\nprivate var counter = 0\n\ninternal actual val DEBUG: Boolean = false\n\ninternal actual val Any.hexAddress: String\n    get() {\n        var result = this.asDynamic().__debug_counter\n        if (jsTypeOf(result) !== \"number\") {\n            result = ++counter\n            this.asDynamic().__debug_counter = result\n\n        }\n        return (result as Int).toString()\n    }\n\ninternal actual val Any.classSimpleName: String get() = this::class.simpleName ?: \"Unknown\"\n\ninternal actual inline fun assert(value: () -> Boolean) {}\n"
    },
    {
        "path": "kotlinx-coroutines-core/js/src/JSDispatcher.kt",
        "content": "package kotlinx.coroutines\n\nimport org.w3c.dom.*\nimport kotlin.js.Promise\n\npublic actual typealias W3CWindow = Window\n\ninternal actual fun w3cSetTimeout(window: W3CWindow, handler: () -> Unit, timeout: Int): Int =\n    setTimeout(window, handler, timeout)\n\ninternal actual fun w3cSetTimeout(handler: () -> Unit, timeout: Int): Int =\n    setTimeout(handler, timeout)\n\ninternal actual fun w3cClearTimeout(window: W3CWindow, handle: Int) =\n    window.clearTimeout(handle)\n\ninternal actual fun w3cClearTimeout(handle: Int) =\n    clearTimeout(handle)\n\ninternal actual class ScheduledMessageQueue actual constructor(private val dispatcher: SetTimeoutBasedDispatcher) : MessageQueue() {\n    internal val processQueue: dynamic = { process() }\n\n    actual override fun schedule() {\n        dispatcher.scheduleQueueProcessing()\n    }\n\n    actual override fun reschedule() {\n        setTimeout(processQueue, 0)\n    }\n\n    internal actual fun setTimeout(timeout: Int) {\n        setTimeout(processQueue, timeout)\n    }\n}\n\ninternal object NodeDispatcher : SetTimeoutBasedDispatcher() {\n    override fun scheduleQueueProcessing() {\n        process.nextTick(messageQueue.processQueue)\n    }\n}\n\ninternal actual class WindowMessageQueue actual constructor(private val window: W3CWindow) : MessageQueue() {\n    private val messageName = \"dispatchCoroutine\"\n\n    init {\n        window.addEventListener(\"message\", { event: dynamic ->\n            if (event.source == window && event.data == messageName) {\n                event.stopPropagation()\n                process()\n            }\n        }, true)\n    }\n\n    actual override fun schedule() {\n        Promise.resolve(Unit).then({ process() })\n    }\n\n    actual override fun reschedule() {\n        window.postMessage(messageName, \"*\")\n    }\n}\n\n// We need to reference global setTimeout and clearTimeout so that it works on Node.JS as opposed to\n// using them via \"window\" (which only works in browser)\nprivate external fun setTimeout(handler: dynamic, timeout: Int = definedExternally): Int\n\nprivate external fun clearTimeout(handle: Int = definedExternally)\n\nprivate fun setTimeout(window: Window, handler: () -> Unit, timeout: Int): Int =\n    window.setTimeout(handler, timeout)\n"
    },
    {
        "path": "kotlinx-coroutines-core/js/src/Promise.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\nimport kotlin.js.*\n\n/**\n * Starts new coroutine and returns its result as an implementation of [Promise].\n *\n * Coroutine context is inherited from a [CoroutineScope], additional context elements can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * The parent job is inherited from a [CoroutineScope] as well, but it can also be overridden\n * with corresponding [context] element.\n *\n * By default, the coroutine is immediately scheduled for execution.\n * Other options can be specified via `start` parameter. See [CoroutineStart] for details.\n *\n * @param context additional to [CoroutineScope.coroutineContext] context of the coroutine.\n * @param start coroutine start option. The default value is [CoroutineStart.DEFAULT].\n * @param block the coroutine code.\n */\npublic fun <T> CoroutineScope.promise(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -> T\n): Promise<T> =\n    async(context, start, block).asPromise()\n\n/**\n * Converts this deferred value to the instance of [Promise].\n */\npublic fun <T> Deferred<T>.asPromise(): Promise<T> {\n    val promise = Promise<T> { resolve, reject ->\n        invokeOnCompletion {\n            val e = getCompletionExceptionOrNull()\n            if (e != null) {\n                reject(e)\n            } else {\n                resolve(getCompleted())\n            }\n        }\n    }\n    promise.asDynamic().deferred = this\n    return promise\n}\n\n/**\n * Converts this promise value to the instance of [Deferred].\n */\npublic fun <T> Promise<T>.asDeferred(): Deferred<T> {\n    val deferred = asDynamic().deferred\n    @Suppress(\"UnsafeCastFromDynamic\")\n    return deferred ?: GlobalScope.async(start = CoroutineStart.UNDISPATCHED) { await() }\n}\n\n/**\n * Awaits for completion of the promise without blocking.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting on the promise, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n */\npublic suspend fun <T> Promise<T>.await(): T = suspendCancellableCoroutine { cont: CancellableContinuation<T> ->\n    this@await.then(\n        onFulfilled = { cont.resume(it) },\n        onRejected = { cont.resumeWithException(it) })\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/js/src/Window.kt",
        "content": "package kotlinx.coroutines\n\nimport org.w3c.dom.Window\n\n/**\n * Converts an instance of [Window] to an implementation of [CoroutineDispatcher].\n */\npublic fun Window.asCoroutineDispatcher(): CoroutineDispatcher =\n    @Suppress(\"UnsafeCastFromDynamic\")\n    asDynamic().coroutineDispatcher ?: WindowDispatcher(this).also {\n        asDynamic().coroutineDispatcher = it\n    }\n\n/**\n * Suspends coroutine until next JS animation frame and returns frame time on resumption.\n * The time is consistent with [window.performance.now()][org.w3c.performance.Performance.now].\n * This function is cancellable. If the [Job] of the current coroutine is completed while this suspending\n * function is waiting, this function immediately resumes with [CancellationException].\n */\npublic suspend fun Window.awaitAnimationFrame(): Double = suspendCancellableCoroutine { cont ->\n    asWindowAnimationQueue().enqueue(cont)\n}\n\nprivate fun Window.asWindowAnimationQueue(): WindowAnimationQueue =\n    @Suppress(\"UnsafeCastFromDynamic\")\n    asDynamic().coroutineAnimationQueue ?: WindowAnimationQueue(this).also {\n        asDynamic().coroutineAnimationQueue = it\n    }\n\nprivate class WindowAnimationQueue(private val window: Window) {\n    private val dispatcher = window.asCoroutineDispatcher()\n    private var scheduled = false\n    private var current = ArrayDeque<CancellableContinuation<Double>>()\n    private var next = ArrayDeque<CancellableContinuation<Double>>()\n    private var timestamp = 0.0\n\n    fun enqueue(cont: CancellableContinuation<Double>) {\n        next.addLast(cont)\n        if (!scheduled) {\n            scheduled = true\n            window.requestAnimationFrame { ts ->\n                timestamp = ts\n                val prev = current\n                current = next\n                next = prev\n                scheduled = false\n                process()\n            }\n        }\n    }\n\n    fun process() {\n        while(true) {\n            val element = current.removeFirstOrNull() ?: return\n            with(element) { dispatcher.resumeUndispatched(timestamp) }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/js/src/internal/CopyOnWriteList.kt",
        "content": "package kotlinx.coroutines.internal\n\n/**\n * Analogue of java.util.concurrent.CopyOnWriteArrayList for JS.\n * Even though JS has no real concurrency, [CopyOnWriteList] is essential to manage any kinds\n * of callbacks or continuations.\n *\n * Implementation note: most of the methods fallbacks to [AbstractMutableList] (thus inefficient for CoW pattern)\n * and some methods are unsupported, because currently they are not required for this class consumers.\n */\ninternal class CopyOnWriteList<E>(private var array: Array<E> = emptyArray()) : AbstractMutableList<E>() {\n\n    override val size: Int get() = array.size\n\n    override fun add(element: E): Boolean {\n        val copy = array.asDynamic().slice()\n        copy.push(element)\n        array = copy as Array<E>\n        return true\n    }\n\n    override fun add(index: Int, element: E) {\n        val copy = array.asDynamic().slice()\n        copy.splice(insertionRangeCheck(index), 0, element)\n        array = copy as Array<E>\n    }\n\n    override fun remove(element: E): Boolean {\n        for (index in array.indices) {\n            if (array[index] == element) {\n                val copy = array.asDynamic().slice()\n                copy.splice(index, 1)\n                array = copy as Array<E>\n                return true\n            }\n        }\n\n        return false\n    }\n\n    override fun removeAt(index: Int): E {\n        rangeCheck(index)\n        val copy = array.asDynamic().slice()\n        val result = if (index == lastIndex) {\n            copy.pop()\n        } else {\n            copy.splice(index, 1)[0]\n        }\n\n        array = copy as Array<E>\n        return result as E\n    }\n\n    override fun iterator(): MutableIterator<E> = IteratorImpl(array)\n\n    override fun listIterator(): MutableListIterator<E> = throw UnsupportedOperationException(\"Operation is not supported\")\n\n    override fun listIterator(index: Int): MutableListIterator<E> = throw UnsupportedOperationException(\"Operation is not supported\")\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun set(index: Int, element: E): E = throw UnsupportedOperationException(\"Operation is not supported\")\n\n    override fun get(index: Int): E = array[rangeCheck(index)]\n\n    private class IteratorImpl<E>(private var array: Array<E>) : MutableIterator<E> {\n\n        private var current = 0\n\n        override fun hasNext(): Boolean = current != array.size\n\n        override fun next(): E {\n            if (!hasNext()) {\n                throw NoSuchElementException()\n            }\n\n            return array[current++]\n        }\n\n        override fun remove() = throw UnsupportedOperationException(\"Operation is not supported\")\n    }\n\n    private fun insertionRangeCheck(index: Int) {\n        if (index < 0 || index > size) {\n            throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n        }\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        if (index < 0 || index >= size) {\n            throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/js/src/internal/CoroutineExceptionHandlerImpl.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\n\ninternal actual fun propagateExceptionFinalResort(exception: Throwable) {\n    // log exception\n    console.error(exception.toString())\n}"
    },
    {
        "path": "kotlinx-coroutines-core/js/test/PromiseTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.js.*\nimport kotlin.test.*\n\nclass PromiseTest : TestBase() {\n    @Test\n    fun testPromiseResolvedAsDeferred() = GlobalScope.promise {\n        val promise = Promise<String> { resolve, _ ->\n            resolve(\"OK\")\n        }\n        val deferred = promise.asDeferred()\n        assertEquals(\"OK\", deferred.await())\n    }\n\n    @Test\n    fun testPromiseRejectedAsDeferred() = GlobalScope.promise {\n        lateinit var promiseReject: (Throwable) -> Unit\n        val promise = Promise<String> { _, reject ->\n            promiseReject = reject\n        }\n        val deferred = promise.asDeferred()\n        // reject after converting to deferred to avoid \"Unhandled promise rejection\" warnings\n        promiseReject(TestException(\"Rejected\"))\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: Throwable) {\n            assertIs<TestException>(e)\n            assertEquals(\"Rejected\", e.message)\n        }\n    }\n\n    @Test\n    fun testCompletedDeferredAsPromise() = GlobalScope.promise {\n        val deferred = async(start = CoroutineStart.UNDISPATCHED) {\n            // completed right away\n            \"OK\"\n        }\n        val promise = deferred.asPromise()\n        assertEquals(\"OK\", promise.await())\n    }\n\n    @Test\n    fun testWaitForDeferredAsPromise() = GlobalScope.promise {\n        val deferred = async {\n            // will complete later\n            \"OK\"\n        }\n        val promise = deferred.asPromise()\n        assertEquals(\"OK\", promise.await()) // await yields main thread to deferred coroutine\n    }\n\n    @Test\n    fun testCancellableAwaitPromise() = GlobalScope.promise {\n        lateinit var r: (String) -> Unit\n        val toAwait = Promise<String> { resolve, _ -> r = resolve }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            toAwait.await() // suspends\n        }\n        job.cancel() // cancel the job\n        r(\"fail\") // too late, the waiting job was already cancelled\n    }\n\n    @Test\n    fun testAsPromiseAsDeferred() = GlobalScope.promise {\n        val deferred = async { \"OK\" }\n        val promise = deferred.asPromise()\n        val d2 = promise.asDeferred()\n        assertSame(d2, deferred)\n        assertEquals(\"OK\", d2.await())\n    }\n\n    @Test\n    fun testLeverageTestResult(): TestResult {\n        // Cannot use expect(..) here\n        var seq = 0\n        val result = runTest {\n            ++seq\n        }\n        return result.then {\n            if (seq != 1) error(\"Unexpected result: $seq\")\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/CloseableCoroutineDispatcher.kt",
        "content": "package kotlinx.coroutines\n\npublic actual abstract class CloseableCoroutineDispatcher actual constructor() : CoroutineDispatcher() {\n    public actual abstract fun close()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/Dispatchers.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\n\ninternal expect fun createDefaultDispatcher(): CoroutineDispatcher\n\npublic actual object Dispatchers {\n    public actual val Default: CoroutineDispatcher = createDefaultDispatcher()\n    public actual val Main: MainCoroutineDispatcher\n        get() = injectedMainDispatcher ?: mainDispatcher\n    public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined\n\n    private val mainDispatcher = JsMainDispatcher(Default, false)\n    private var injectedMainDispatcher: MainCoroutineDispatcher? = null\n\n    @PublishedApi\n    internal fun injectMain(dispatcher: MainCoroutineDispatcher) {\n        injectedMainDispatcher = dispatcher\n    }\n}\n\nprivate class JsMainDispatcher(\n    val delegate: CoroutineDispatcher,\n    private val invokeImmediately: Boolean\n) : MainCoroutineDispatcher() {\n    override val immediate: MainCoroutineDispatcher =\n        if (invokeImmediately) this else JsMainDispatcher(delegate, true)\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = !invokeImmediately\n    override fun dispatch(context: CoroutineContext, block: Runnable) = delegate.dispatch(context, block)\n    override fun dispatchYield(context: CoroutineContext, block: Runnable) = delegate.dispatchYield(context, block)\n    override fun toString(): String = toStringInternalImpl() ?: delegate.toString()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/EventLoop.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\n\ninternal actual fun createEventLoop(): EventLoop = UnconfinedEventLoop()\n\ninternal actual fun nanoTime(): Long = unsupported()\n\ninternal class UnconfinedEventLoop : EventLoop() {\n    override fun dispatch(context: CoroutineContext, block: Runnable): Unit = unsupported()\n}\n\ninternal actual abstract class EventLoopImplPlatform : EventLoop() {\n    protected actual fun unpark(): Unit = unsupported()\n    protected actual fun reschedule(now: Long, delayedTask: EventLoopImplBase.DelayedTask): Unit = unsupported()\n}\n\ninternal actual object DefaultExecutor {\n    public actual fun enqueue(task: Runnable): Unit = unsupported()\n}\n\nprivate fun unsupported(): Nothing =\n    throw UnsupportedOperationException(\"runBlocking event loop is not supported\")\n\ninternal actual inline fun platformAutoreleasePool(crossinline block: () -> Unit) = block()\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/Exceptions.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * Thrown by cancellable suspending functions if the [Job] of the coroutine is cancelled while it is suspending.\n * It indicates _normal_ cancellation of a coroutine.\n * **It is not printed to console/log by default uncaught exception handler**.\n * (see [CoroutineExceptionHandler]).\n */\npublic actual typealias CancellationException = kotlin.coroutines.cancellation.CancellationException\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun CancellationException(message: String?, cause: Throwable?): CancellationException =\n    CancellationException(message, cause)\n\n/**\n * Thrown by cancellable suspending functions if the [Job] of the coroutine is cancelled or completed\n * without cause, or with a cause or exception that is not [CancellationException]\n * (see [Job.getCancellationException]).\n */\ninternal actual class JobCancellationException public actual constructor(\n    message: String,\n    cause: Throwable?,\n    internal actual val job: Job\n) : CancellationException(message, cause) {\n    override fun toString(): String = \"${super.toString()}; job=$job\"\n    override fun equals(other: Any?): Boolean =\n        other === this ||\n            other is JobCancellationException && other.message == message && other.job == job && other.cause == cause\n    override fun hashCode(): Int =\n        (message!!.hashCode() * 31 + job.hashCode()) * 31 + (cause?.hashCode() ?: 0)\n}\n\n// For use in tests\ninternal actual val RECOVER_STACK_TRACES: Boolean = false\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/Runnable.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * A runnable task for [CoroutineDispatcher.dispatch].\n */\npublic actual interface Runnable {\n    /**\n     * @suppress\n     */\n    public actual fun run()\n}\n\n/**\n * Creates [Runnable] task instance.\n */\n@Suppress(\"FunctionName\")\npublic actual inline fun Runnable(crossinline block: () -> Unit): Runnable =\n    object : Runnable {\n        override fun run() {\n            block()\n        }\n    }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/SchedulerTask.kt",
        "content": "package kotlinx.coroutines\n\ninternal actual abstract class SchedulerTask : Runnable\n\ninternal actual interface SchedulerTaskContext { }\n\nprivate object TaskContext: SchedulerTaskContext { }\n\ninternal actual val SchedulerTask.taskContext: SchedulerTaskContext get() = TaskContext\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun SchedulerTaskContext.afterTask() {}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/flow/internal/FlowExceptions.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\ninternal actual class AbortFlowException actual constructor(\n    actual val owner: Any\n) : CancellationException(\"Flow was aborted, no more elements needed\")\ninternal actual class ChildCancelledException : CancellationException(\"Child of the scoped flow was cancelled\")\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/flow/internal/SafeCollector.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.coroutines.*\n\ninternal actual class SafeCollector<T> actual constructor(\n    internal actual val collector: FlowCollector<T>,\n    internal actual val collectContext: CoroutineContext\n) : FlowCollector<T> {\n\n    // Note, it is non-capturing lambda, so no extra allocation during init of SafeCollector\n    internal actual val collectContextSize = collectContext.fold(0) { count, _ -> count + 1 }\n    private var lastEmissionContext: CoroutineContext? = null\n\n    actual override suspend fun emit(value: T) {\n        val currentContext = currentCoroutineContext()\n        currentContext.ensureActive()\n        if (lastEmissionContext !== currentContext) {\n            checkContext(currentContext)\n            lastEmissionContext = currentContext\n        }\n        collector.emit(value)\n    }\n\n    public actual fun releaseIntercepted() {\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/Concurrent.kt",
        "content": "package kotlinx.coroutines.internal\n\ninternal actual typealias ReentrantLock = NoOpLock\n\ninternal actual inline fun <T> ReentrantLock.withLock(action: () -> T) = action()\n\ninternal class NoOpLock {\n    fun tryLock() = true\n    fun unlock(): Unit {}\n}\n\ninternal actual fun <E> identitySet(expectedSize: Int): MutableSet<E> = HashSet(expectedSize)\n\ninternal actual class WorkaroundAtomicReference<T> actual constructor(private var value: T) {\n\n    public actual fun get(): T = value\n\n    public actual fun set(value: T) {\n        this.value = value\n    }\n\n    public actual fun getAndSet(value: T): T {\n        val prev = this.value\n        this.value = value\n        return prev\n    }\n\n    public actual fun compareAndSet(expected: T, value: T): Boolean {\n        if (this.value === expected) {\n            this.value = value\n            return true\n        }\n        return false\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/CoroutineExceptionHandlerImpl.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\nprivate val platformExceptionHandlers_ = mutableSetOf<CoroutineExceptionHandler>()\n\ninternal actual val platformExceptionHandlers: Collection<CoroutineExceptionHandler>\n    get() = platformExceptionHandlers_\n\ninternal actual fun ensurePlatformExceptionHandlerLoaded(callback: CoroutineExceptionHandler) {\n    platformExceptionHandlers_ += callback\n}\n\ninternal actual class DiagnosticCoroutineContextException actual constructor(context: CoroutineContext) :\n    RuntimeException(context.toString())\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/JSDispatcher.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\npublic expect abstract class W3CWindow\ninternal expect fun w3cSetTimeout(window: W3CWindow, handler: () -> Unit, timeout: Int): Int\ninternal expect fun w3cSetTimeout(handler: () -> Unit, timeout: Int): Int\ninternal expect fun w3cClearTimeout(handle: Int)\ninternal expect fun w3cClearTimeout(window: W3CWindow, handle: Int)\n\ninternal expect class ScheduledMessageQueue(dispatcher: SetTimeoutBasedDispatcher) : MessageQueue {\n    override fun schedule()\n    override fun reschedule()\n    internal fun setTimeout(timeout: Int)\n}\n\ninternal expect class WindowMessageQueue(window: W3CWindow) : MessageQueue {\n    override fun schedule()\n    override fun reschedule()\n}\n\nprivate const val MAX_DELAY = Int.MAX_VALUE.toLong()\n\nprivate fun delayToInt(timeMillis: Long): Int =\n    timeMillis.coerceIn(0, MAX_DELAY).toInt()\n\ninternal abstract class SetTimeoutBasedDispatcher: CoroutineDispatcher(), Delay {\n    internal val messageQueue = ScheduledMessageQueue(this)\n\n    abstract fun scheduleQueueProcessing()\n\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        parallelism.checkParallelism()\n        return this\n    }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        messageQueue.enqueue(block)\n    }\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        val handle = w3cSetTimeout({ block.run() }, delayToInt(timeMillis))\n        return ClearTimeout(handle)\n    }\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val handle = w3cSetTimeout({ with(continuation) { resumeUndispatched(Unit) } }, delayToInt(timeMillis))\n        continuation.invokeOnCancellation(handler = ClearTimeout(handle))\n    }\n}\n\ninternal class WindowDispatcher(private val window: W3CWindow) : CoroutineDispatcher(), Delay {\n    private val queue = WindowMessageQueue(window)\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) = queue.enqueue(block)\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val handle = w3cSetTimeout(window, { with(continuation) { resumeUndispatched(Unit) } }, delayToInt(timeMillis))\n        continuation.invokeOnCancellation(handler = WindowClearTimeout(handle))\n    }\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        val handle = w3cSetTimeout(window, block::run, delayToInt(timeMillis))\n        return WindowClearTimeout(handle)\n    }\n\n    private inner class WindowClearTimeout(handle: Int) : ClearTimeout(handle) {\n        override fun dispose() {\n            w3cClearTimeout(window, handle)\n        }\n    }\n}\n\ninternal object SetTimeoutDispatcher : SetTimeoutBasedDispatcher() {\n    override fun scheduleQueueProcessing() {\n        messageQueue.setTimeout(0)\n    }\n}\n\nprivate open class ClearTimeout(protected val handle: Int) : CancelHandler, DisposableHandle {\n    override fun dispose() {\n        w3cClearTimeout(handle)\n    }\n\n    override fun invoke(cause: Throwable?) {\n        dispose()\n    }\n\n    override fun toString(): String = \"ClearTimeout[$handle]\"\n}\n\n\n/**\n * An abstraction over JS scheduling mechanism that leverages micro-batching of dispatched blocks without\n * paying the cost of JS callbacks scheduling on every dispatch.\n *\n * Queue uses two scheduling mechanisms:\n * 1) [schedule] is used to schedule the initial processing of the message queue.\n *    JS engine-specific microtask mechanism is used in order to boost performance on short runs and a dispatch batch\n * 2) [reschedule] is used to schedule processing of the queue after yield to the JS event loop.\n *    JS engine-specific macrotask mechanism is used not to starve animations and non-coroutines macrotasks.\n *\n * Yet there could be a long tail of \"slow\" reschedules, but it should be amortized by the queue size.\n */\ninternal abstract class MessageQueue : MutableList<Runnable> by ArrayDeque() {\n    val yieldEvery = 16 // yield to JS macrotask event loop after this many processed messages\n    private var scheduled = false\n\n    abstract fun schedule()\n\n    abstract fun reschedule()\n\n    fun enqueue(element: Runnable) {\n        add(element)\n        if (!scheduled) {\n            scheduled = true\n            schedule()\n        }\n    }\n\n    fun process() {\n        try {\n            // limit number of processed messages\n            repeat(yieldEvery) {\n                val element = removeFirstOrNull() ?: return@process\n                element.run()\n            }\n        } finally {\n            if (isEmpty()) {\n                scheduled = false\n            } else {\n                reschedule()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/LinkedList.kt",
        "content": "@file:Suppress(\"unused\", \"NO_EXPLICIT_RETURN_TYPE_IN_API_MODE\", \"NO_EXPLICIT_VISIBILITY_IN_API_MODE\")\n\npackage kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\n\nprivate typealias Node = LinkedListNode\n\n/** @suppress **This is unstable API and it is subject to change.** */\npublic actual typealias LockFreeLinkedListNode = LinkedListNode\n\n/** @suppress **This is unstable API and it is subject to change.** */\npublic actual typealias LockFreeLinkedListHead = LinkedListHead\n\n/** @suppress **This is unstable API and it is subject to change.** */\npublic open class LinkedListNode : DisposableHandle {\n    @PublishedApi internal var _next = this\n    @PublishedApi internal var _prev = this\n    @PublishedApi internal var _removed: Boolean = false\n\n    public inline val nextNode get() = _next\n    public inline val prevNode get() = _prev\n    public inline val isRemoved get() = _removed\n\n    public fun addLast(node: Node) {\n        val prev = this._prev\n        node._next = this\n        node._prev = prev\n        prev._next = node\n        this._prev = node\n    }\n\n    /*\n     * Remove that is invoked as a virtual function with a\n     * potentially augmented behaviour.\n     * I.g. `LockFreeLinkedListHead` throws, while `SendElementWithUndeliveredHandler`\n     * invokes handler on remove\n     */\n    public open fun remove(): Boolean {\n        return removeImpl()\n    }\n\n    override fun dispose() {\n        remove()\n    }\n\n    @PublishedApi\n    internal fun removeImpl(): Boolean {\n        if (_removed) return false\n        val prev = this._prev\n        val next = this._next\n        prev._next = next\n        next._prev = prev\n        _removed = true\n        return true\n    }\n\n    public fun addOneIfEmpty(node: Node): Boolean {\n        if (_next !== this) return false\n        addLast(node)\n        return true\n    }\n\n    public inline fun addLastIf(node: Node, crossinline condition: () -> Boolean): Boolean {\n        if (!condition()) return false\n        addLast(node)\n        return true\n    }\n\n    public inline fun addLastIfPrev(node: Node, predicate: (Node) -> Boolean): Boolean {\n        if (!predicate(_prev)) return false\n        addLast(node)\n        return true\n    }\n\n    public inline fun addLastIfPrevAndIf(\n        node: Node,\n        predicate: (Node) -> Boolean, // prev node predicate\n        crossinline condition: () -> Boolean // atomically checked condition\n    ): Boolean {\n        if (!predicate(_prev)) return false\n        if (!condition()) return false\n        addLast(node)\n        return true\n    }\n\n    public fun helpRemove() {} // No concurrency on JS -> no removal\n\n    public fun removeFirstOrNull(): Node? {\n        val next = _next\n        if (next === this) return null\n        check(next.removeImpl()) { \"Should remove\" }\n        return next\n    }\n}\n\n/** @suppress **This is unstable API and it is subject to change.** */\npublic open class LinkedListHead : LinkedListNode() {\n    public val isEmpty get() = _next === this\n\n    /**\n     * Iterates over all elements in this list of a specified type.\n     */\n    public inline fun <reified T : Node> forEach(block: (T) -> Unit) {\n        var cur: Node = _next\n        while (cur != this) {\n            if (cur is T) block(cur)\n            cur = cur._next\n        }\n    }\n\n    // just a defensive programming -- makes sure that list head sentinel is never removed\n    public final override fun remove(): Nothing = throw UnsupportedOperationException()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/LocalAtomics.kt",
        "content": "package kotlinx.coroutines.internal\n\ninternal actual class LocalAtomicInt actual constructor(private var value: Int) {\n    actual fun set(value: Int) {\n        this.value = value\n    }\n\n    actual fun get(): Int = value\n\n    actual fun decrementAndGet(): Int = --value\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/ProbesSupport.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> probeCoroutineCreated(completion: Continuation<T>): Continuation<T> = completion\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/StackTraceRecovery.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\n\ninternal actual fun <E: Throwable> recoverStackTrace(exception: E, continuation: Continuation<*>): E = exception\ninternal actual fun <E: Throwable> recoverStackTrace(exception: E): E = exception\ninternal actual suspend inline fun recoverAndThrow(exception: Throwable): Nothing = throw exception\n\n@PublishedApi\ninternal actual fun <E : Throwable> unwrap(exception: E): E = exception\n\n@Suppress(\"UNUSED\")\ninternal actual interface CoroutineStackFrame {\n    public actual val callerFrame: CoroutineStackFrame?\n    public actual fun getStackTraceElement(): StackTraceElement?\n}\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\ninternal actual typealias StackTraceElement = Any\n\ninternal actual fun Throwable.initCause(cause: Throwable) {\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/Synchronized.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic actual open class SynchronizedObject\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic actual inline fun <T> synchronizedImpl(lock: SynchronizedObject, block: () -> T): T = block()\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/SystemProps.kt",
        "content": "package kotlinx.coroutines.internal\n\ninternal actual fun systemProp(propertyName: String): String? = null\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/ThreadContext.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\n\ninternal actual fun threadContextElements(context: CoroutineContext): Any = 0\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/src/internal/ThreadLocal.kt",
        "content": "package kotlinx.coroutines.internal\n\ninternal actual class CommonThreadLocal<T> {\n    private var value: T? = null\n    @Suppress(\"UNCHECKED_CAST\")\n    actual fun get(): T = value as T\n    actual fun set(value: T) { this.value = value }\n}\n\ninternal actual fun<T> commonThreadLocal(name: Symbol): CommonThreadLocal<T> = CommonThreadLocal()"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/test/ImmediateDispatcherTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ImmediateDispatcherTest : MainDispatcherTestBase.WithRealTimeDelay() {\n\n    /** Tests that [MainCoroutineDispatcher.immediate] doesn't require dispatches from the test context. */\n    @Test\n    fun testImmediate() = runTest {\n        expect(1)\n        val job = launch { expect(3) }\n        assertFalse(Dispatchers.Main.immediate.isDispatchNeeded(currentCoroutineContext()))\n        withContext(Dispatchers.Main.immediate) {\n            expect(2)\n        }\n        job.join()\n        finish(4)\n    }\n\n    @Test\n    fun testMain() = runTest {\n        expect(1)\n        val job = launch { expect(2) }\n        withContext(Dispatchers.Main) {\n            expect(3)\n        }\n        job.join()\n        finish(4)\n    }\n\n    override fun isMainThread(): Boolean? = null\n\n    override fun scheduleOnMainQueue(block: () -> Unit) {\n        Dispatchers.Default.dispatch(EmptyCoroutineContext, Runnable { block() })\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/test/MessageQueueTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.test.*\n\nclass MessageQueueTest {\n    private var scheduled = false\n    private val processed = mutableListOf<Int>()\n\n    private val queue = object : MessageQueue() {\n        override fun schedule() {\n            assertFalse(scheduled)\n            scheduled = true\n        }\n\n        override fun reschedule() {\n            schedule()\n        }\n    }\n\n    inner class Box(val i: Int): Runnable {\n        override fun run() {\n            processed += i\n        }\n    }\n\n    inner class ReBox(val i: Int): Runnable {\n        override fun run() {\n            processed += i\n            queue.enqueue(Box(10 + i))\n        }\n    }\n\n    @Test\n    fun testBasic() {\n        assertTrue(queue.isEmpty())\n        queue.enqueue(Box(1))\n        assertFalse(queue.isEmpty())\n        assertTrue(scheduled)\n        queue.enqueue(Box(2))\n        assertFalse(queue.isEmpty())\n        scheduled = false\n        queue.process()\n        assertEquals(listOf(1, 2), processed)\n        assertFalse(scheduled)\n        assertTrue(queue.isEmpty())\n    }\n\n    @Test fun testRescheduleFromProcess()  {\n        assertTrue(queue.isEmpty())\n        queue.enqueue(ReBox(1))\n        assertFalse(queue.isEmpty())\n        assertTrue(scheduled)\n        queue.enqueue(ReBox(2))\n        assertFalse(queue.isEmpty())\n        scheduled = false\n        queue.process()\n        assertEquals(listOf(1, 2, 11, 12), processed)\n        assertFalse(scheduled)\n        assertTrue(queue.isEmpty())\n    }\n\n    @Test\n    fun testResizeAndWrap() {\n        repeat(10) { phase ->\n            val n = 10 * (phase + 1)\n            assertTrue(queue.isEmpty())\n            repeat(n) {\n                queue.enqueue(Box(it))\n                assertFalse(queue.isEmpty())\n                assertTrue(scheduled)\n            }\n            var countYields = 0\n            while (scheduled) {\n                scheduled = false\n                queue.process()\n                countYields++\n            }\n            assertEquals(List(n) { it }, processed)\n            assertEquals((n + queue.yieldEvery - 1) / queue.yieldEvery, countYields)\n            processed.clear()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/test/SetTimeoutDispatcherTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass SetTimeoutDispatcherTest : TestBase() {\n    @Test\n    fun testDispatch() = runTest {\n        launch(SetTimeoutDispatcher) {\n            expect(1)\n            launch {\n                expect(3)\n            }\n            expect(2)\n            yield()\n            expect(4)\n        }.join()\n        finish(5)\n    }\n\n    @Test\n    fun testDelay() = runTest {\n        withContext(SetTimeoutDispatcher) {\n            val job = launch(SetTimeoutDispatcher) {\n                expect(2)\n                delay(100)\n                expect(4)\n            }\n            expect(1)\n            yield() // Yield uses microtask, so should be in the same context\n            expect(3)\n            job.join()\n            finish(5)\n        }\n    }\n\n    @Test\n    fun testWithTimeout() = runTest {\n        withContext(SetTimeoutDispatcher) {\n            val result = withTimeoutOrNull(10) {\n                expect(1)\n                delay(100)\n                expectUnreached()\n                42\n            }\n            assertNull(result)\n            finish(2)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jsAndWasmShared/test/internal/LinkedListTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\nimport kotlin.test.assertFalse\nimport kotlin.test.assertTrue\n\nclass LinkedListTest {\n    data class IntNode(val i: Int) : LinkedListNode()\n\n    @Test\n    fun testSimpleAddLastRemove() {\n        val list = LinkedListHead()\n        assertContents(list)\n        val n1 = IntNode(1).apply { list.addLast(this) }\n        assertContents(list, 1)\n        val n2 = IntNode(2).apply { list.addLast(this) }\n        assertContents(list, 1, 2)\n        val n3 = IntNode(3).apply { list.addLast(this) }\n        assertContents(list, 1, 2, 3)\n        val n4 = IntNode(4).apply { list.addLast(this) }\n        assertContents(list, 1, 2, 3, 4)\n        assertTrue(n1.remove())\n        assertContents(list, 2, 3, 4)\n        assertTrue(n3.remove())\n        assertContents(list, 2, 4)\n        assertTrue(n4.remove())\n        assertContents(list, 2)\n        assertTrue(n2.remove())\n        assertFalse(n2.remove())\n        assertContents(list)\n    }\n\n    private fun assertContents(list: LinkedListHead, vararg expected: Int) {\n        val n = expected.size\n        val actual = IntArray(n)\n        var index = 0\n        list.forEach<IntNode> { actual[index++] = it.i }\n        assertEquals(n, index)\n        for (i in 0 until n) assertEquals(expected[i], actual[i], \"item i\")\n        assertEquals(expected.isEmpty(), list.isEmpty)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/AbstractTimeSource.kt",
        "content": "// Need InlineOnly for efficient bytecode on Android\n@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\", \"NOTHING_TO_INLINE\")\n\npackage kotlinx.coroutines\n\nimport java.util.concurrent.locks.*\nimport kotlin.internal.InlineOnly\n\ninternal abstract class AbstractTimeSource {\n    abstract fun currentTimeMillis(): Long\n    abstract fun nanoTime(): Long\n    abstract fun wrapTask(block: Runnable): Runnable\n    abstract fun trackTask()\n    abstract fun unTrackTask()\n    abstract fun registerTimeLoopThread()\n    abstract fun unregisterTimeLoopThread()\n    abstract fun parkNanos(blocker: Any, nanos: Long) // should return immediately when nanos <= 0\n    abstract fun unpark(thread: Thread)\n}\n\n// For tests only\n// @JvmField: Don't use JvmField here to enable R8 optimizations via \"assumenosideeffects\"\nprivate var timeSource: AbstractTimeSource? = null\n\n// TODO: without this, there's a compilation error. Why?\ninternal inline fun mockTimeSource(source: AbstractTimeSource?) {\n    timeSource = source\n}\n\n@InlineOnly\ninternal inline fun currentTimeMillis(): Long =\n    timeSource?.currentTimeMillis() ?: System.currentTimeMillis()\n\n@InlineOnly\ninternal actual inline fun nanoTime(): Long =\n    timeSource?.nanoTime() ?: System.nanoTime()\n\n@InlineOnly\ninternal inline fun wrapTask(block: Runnable): Runnable =\n    timeSource?.wrapTask(block) ?: block\n\n@InlineOnly\ninternal inline fun trackTask() {\n    timeSource?.trackTask()\n}\n\n@InlineOnly\ninternal inline fun unTrackTask() {\n    timeSource?.unTrackTask()\n}\n\n@InlineOnly\ninternal inline fun registerTimeLoopThread() {\n    timeSource?.registerTimeLoopThread()\n}\n\n@InlineOnly\ninternal inline fun unregisterTimeLoopThread() {\n    timeSource?.unregisterTimeLoopThread()\n}\n\n@InlineOnly\ninternal inline fun parkNanos(blocker: Any, nanos: Long) {\n    timeSource?.parkNanos(blocker, nanos) ?: LockSupport.parkNanos(blocker, nanos)\n}\n\n@InlineOnly\ninternal inline fun unpark(thread: Thread) {\n    timeSource?.unpark(thread) ?: LockSupport.unpark(thread)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/Builders.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"BuildersKt\")\n@file:OptIn(ExperimentalContracts::class)\n\npackage kotlinx.coroutines\n\nimport java.util.concurrent.locks.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\n\n/**\n * Runs a new coroutine and **blocks** the current thread _interruptibly_ until its completion.\n *\n * It is designed to bridge regular blocking code to libraries that are written in suspending style, to be used in\n * `main` functions and in tests.\n *\n * Calling [runBlocking] from a suspend function is redundant.\n * For example, the following code is incorrect:\n * ```\n * suspend fun loadConfiguration() {\n *     // DO NOT DO THIS:\n *     val data = runBlocking { // <- redundant and blocks the thread, do not do that\n *         fetchConfigurationData() // suspending function\n *     }\n * ```\n *\n * Here, instead of releasing the thread on which `loadConfiguration` runs if `fetchConfigurationData` suspends, it will\n * block, potentially leading to thread starvation issues.\n *\n * The default [CoroutineDispatcher] for this builder is an internal implementation of event loop that processes continuations\n * in this blocked thread until the completion of this coroutine.\n * See [CoroutineDispatcher] for the other implementations that are provided by `kotlinx.coroutines`.\n *\n * When [CoroutineDispatcher] is explicitly specified in the [context], then the new coroutine runs in the context of\n * the specified dispatcher while the current thread is blocked. If the specified dispatcher is an event loop of another `runBlocking`,\n * then this invocation uses the outer event loop.\n *\n * If this blocked thread is interrupted (see [Thread.interrupt]), then the coroutine job is cancelled and\n * this `runBlocking` invocation throws [InterruptedException].\n *\n * See [newCoroutineContext][CoroutineScope.newCoroutineContext] for a description of debugging facilities that are available\n * for a newly created coroutine.\n *\n * @param context the context of the coroutine. The default value is an event loop on the current thread.\n * @param block the coroutine code.\n */\n@Throws(InterruptedException::class)\npublic actual fun <T> runBlocking(context: CoroutineContext, block: suspend CoroutineScope.() -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    val currentThread = Thread.currentThread()\n    val contextInterceptor = context[ContinuationInterceptor]\n    val eventLoop: EventLoop?\n    val newContext: CoroutineContext\n    if (contextInterceptor == null) {\n        // create or use private event loop if no dispatcher is specified\n        eventLoop = ThreadLocalEventLoop.eventLoop\n        newContext = GlobalScope.newCoroutineContext(context + eventLoop)\n    } else {\n        // See if context's interceptor is an event loop that we shall use (to support TestContext)\n        // or take an existing thread-local event loop if present to avoid blocking it (but don't create one)\n        eventLoop = (contextInterceptor as? EventLoop)?.takeIf { it.shouldBeProcessedFromContext() }\n            ?: ThreadLocalEventLoop.currentOrNull()\n        newContext = GlobalScope.newCoroutineContext(context)\n    }\n    val coroutine = BlockingCoroutine<T>(newContext, currentThread, eventLoop)\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n    return coroutine.joinBlocking()\n}\n\nprivate class BlockingCoroutine<T>(\n    parentContext: CoroutineContext,\n    private val blockedThread: Thread,\n    private val eventLoop: EventLoop?\n) : AbstractCoroutine<T>(parentContext, true, true) {\n\n    override val isScopedCoroutine: Boolean get() = true\n\n    override fun afterCompletion(state: Any?) {\n        // wake up blocked thread\n        if (Thread.currentThread() != blockedThread)\n            unpark(blockedThread)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun joinBlocking(): T {\n        registerTimeLoopThread()\n        try {\n            eventLoop?.incrementUseCount()\n            try {\n                while (true) {\n                    @Suppress(\"DEPRECATION\")\n                    if (Thread.interrupted()) throw InterruptedException().also { cancelCoroutine(it) }\n                    val parkNanos = eventLoop?.processNextEvent() ?: Long.MAX_VALUE\n                    // note: process next even may loose unpark flag, so check if completed before parking\n                    if (isCompleted) break\n                    parkNanos(this, parkNanos)\n                }\n            } finally { // paranoia\n                eventLoop?.decrementUseCount()\n            }\n        } finally { // paranoia\n            unregisterTimeLoopThread()\n        }\n        // now return result\n        val state = this.state.unboxState()\n        (state as? CompletedExceptionally)?.let { throw it.cause }\n        return state as T\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/CoroutineContext.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.jvm.internal.CoroutineStackFrame\n\n/**\n * Creates a context for a new coroutine. It installs [Dispatchers.Default] when no other dispatcher or\n * [ContinuationInterceptor] is specified and adds optional support for debugging facilities (when turned on)\n * and copyable-thread-local facilities on JVM.\n * See [DEBUG_PROPERTY_NAME] for description of debugging facilities on JVM.\n */\n@ExperimentalCoroutinesApi\npublic actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {\n    val combined = foldCopies(coroutineContext, context, true)\n    val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined\n    return if (combined !== Dispatchers.Default && combined[ContinuationInterceptor] == null)\n        debug + Dispatchers.Default else debug\n}\n\n/**\n * Creates a context for coroutine builder functions that do not launch a new coroutine, e.g. [withContext].\n * @suppress\n */\n@InternalCoroutinesApi\npublic actual fun CoroutineContext.newCoroutineContext(addedContext: CoroutineContext): CoroutineContext {\n    /*\n     * Fast-path: we only have to copy/merge if 'addedContext' (which typically has one or two elements)\n     * contains copyable elements.\n     */\n    if (!addedContext.hasCopyableElements()) return this + addedContext\n    return foldCopies(this, addedContext, false)\n}\n\nprivate fun CoroutineContext.hasCopyableElements(): Boolean =\n    fold(false) { result, it -> result || it is CopyableThreadContextElement<*> }\n\n/**\n * Folds two contexts properly applying [CopyableThreadContextElement] rules when necessary.\n * The rules are the following:\n * - If neither context has CTCE, the sum of two contexts is returned\n * - Every CTCE from the left-hand side context that does not have a matching (by key) element from right-hand side context\n *   is [copied][CopyableThreadContextElement.copyForChild] if [isNewCoroutine] is `true`.\n * - Every CTCE from the left-hand side context that has a matching element in the right-hand side context is [merged][CopyableThreadContextElement.mergeForChild]\n * - Every CTCE from the right-hand side context that hasn't been merged is copied\n * - Everything else is added to the resulting context as is.\n */\nprivate fun foldCopies(originalContext: CoroutineContext, appendContext: CoroutineContext, isNewCoroutine: Boolean): CoroutineContext {\n    // Do we have something to copy left-hand side?\n    val hasElementsLeft = originalContext.hasCopyableElements()\n    val hasElementsRight = appendContext.hasCopyableElements()\n\n    // Nothing to fold, so just return the sum of contexts\n    if (!hasElementsLeft && !hasElementsRight) {\n        return originalContext + appendContext\n    }\n\n    var leftoverContext = appendContext\n    val folded = originalContext.fold<CoroutineContext>(EmptyCoroutineContext) { result, element ->\n        if (element !is CopyableThreadContextElement<*>) return@fold result + element\n        // Will this element be overwritten?\n        val newElement = leftoverContext[element.key]\n        // No, just copy it\n        if (newElement == null) {\n            // For 'withContext'-like builders we do not copy as the element is not shared\n            return@fold result + if (isNewCoroutine) element.copyForChild() else element\n        }\n        // Yes, then first remove the element from append context\n        leftoverContext = leftoverContext.minusKey(element.key)\n        // Return the sum\n        @Suppress(\"UNCHECKED_CAST\")\n        return@fold result + (element as CopyableThreadContextElement<Any?>).mergeForChild(newElement)\n    }\n\n    if (hasElementsRight) {\n        leftoverContext = leftoverContext.fold<CoroutineContext>(EmptyCoroutineContext) { result, element ->\n            // We're appending new context element -- we have to copy it, otherwise it may be shared with others\n            if (element is CopyableThreadContextElement<*>) {\n                return@fold result + element.copyForChild()\n            }\n            return@fold result + element\n        }\n    }\n    return folded + leftoverContext\n}\n\n/**\n * Executes a block using a given coroutine context.\n */\ninternal actual inline fun <T> withCoroutineContext(context: CoroutineContext, countOrElement: Any?, block: () -> T): T {\n    val oldValue = updateThreadContext(context, countOrElement)\n    try {\n        return block()\n    } finally {\n        restoreThreadContext(context, oldValue)\n    }\n}\n\n/**\n * Executes a block using a context of a given continuation.\n */\ninternal actual inline fun <T> withContinuationContext(continuation: Continuation<*>, countOrElement: Any?, block: () -> T): T {\n    val context = continuation.context\n    val oldValue = updateThreadContext(context, countOrElement)\n    val undispatchedCompletion = if (oldValue !== NO_THREAD_ELEMENTS) {\n        // Only if some values were replaced we'll go to the slow path of figuring out where/how to restore them\n        continuation.updateUndispatchedCompletion(context, oldValue)\n    } else {\n        null // fast path -- don't even try to find undispatchedCompletion as there's nothing to restore in the context\n    }\n    try {\n        return block()\n    } finally {\n        if (undispatchedCompletion == null || undispatchedCompletion.clearThreadContext()) {\n            restoreThreadContext(context, oldValue)\n        }\n    }\n}\n\ninternal fun Continuation<*>.updateUndispatchedCompletion(context: CoroutineContext, oldValue: Any?): UndispatchedCoroutine<*>? {\n    if (this !is CoroutineStackFrame) return null\n    /*\n     * Fast-path to detect whether we have undispatched coroutine at all in our stack.\n     *\n     * Implementation note.\n     * If we ever find that stackwalking for thread-locals is way too slow, here is another idea:\n     * 1) Store undispatched coroutine right in the `UndispatchedMarker` instance\n     * 2) To avoid issues with cross-dispatch boundary, remove `UndispatchedMarker`\n     *    from the context when creating dispatched coroutine in `withContext`.\n     *    Another option is to \"unmark it\" instead of removing to save an allocation.\n     *    Both options should work, but it requires more careful studying of the performance\n     *    and, mostly, maintainability impact.\n     */\n    val potentiallyHasUndispatchedCoroutine = context[UndispatchedMarker] !== null\n    if (!potentiallyHasUndispatchedCoroutine) return null\n    val completion = undispatchedCompletion()\n    completion?.saveThreadContext(context, oldValue)\n    return completion\n}\n\ninternal tailrec fun CoroutineStackFrame.undispatchedCompletion(): UndispatchedCoroutine<*>? {\n    // Find direct completion of this continuation\n    val completion: CoroutineStackFrame = when (this) {\n        is DispatchedCoroutine<*> -> return null\n        else -> callerFrame ?: return null // something else -- not supported\n    }\n    if (completion is UndispatchedCoroutine<*>) return completion // found UndispatchedCoroutine!\n    return completion.undispatchedCompletion() // walk up the call stack with tail call\n}\n\n/**\n * Marker indicating that [UndispatchedCoroutine] exists somewhere up in the stack.\n * Used as a performance optimization to avoid stack walking where it is not necessary.\n */\nprivate object UndispatchedMarker: CoroutineContext.Element, CoroutineContext.Key<UndispatchedMarker> {\n    override val key: CoroutineContext.Key<*>\n        get() = this\n}\n\n// Used by withContext when context changes, but dispatcher stays the same\ninternal actual class UndispatchedCoroutine<in T>actual constructor (\n    context: CoroutineContext,\n    uCont: Continuation<T>\n) : ScopeCoroutine<T>(if (context[UndispatchedMarker] == null) context + UndispatchedMarker else context, uCont) {\n\n    /**\n     * The state of [ThreadContextElement]s associated with the current undispatched coroutine.\n     * It is stored in a thread local because this coroutine can be used concurrently in suspend-resume race scenario.\n     * See the followin, boiled down example with inlined `withContinuationContext` body:\n     * ```\n     * val state = saveThreadContext(ctx)\n     * try {\n     *     invokeSmthWithThisCoroutineAsCompletion() // Completion implies that 'afterResume' will be called\n     *     // COROUTINE_SUSPENDED is returned\n     * } finally {\n     *     thisCoroutine().clearThreadContext() // Concurrently the \"smth\" could've been already resumed on a different thread\n     *     // and it also calls saveThreadContext and clearThreadContext\n     * }\n     * ```\n     *\n     * Usage note:\n     *\n     * This part of the code is performance-sensitive.\n     * It is a well-established pattern to wrap various activities into system-specific undispatched\n     * `withContext` for the sake of logging, MDC, tracing etc., meaning that there exists thousands of\n     * undispatched coroutines.\n     * Each access to Java's [ThreadLocal] leaves a footprint in the corresponding Thread's `ThreadLocalMap`\n     * that is cleared automatically as soon as the associated thread-local (-> UndispatchedCoroutine) is garbage collected.\n     * When such coroutines are promoted to old generation, `ThreadLocalMap`s become bloated and an arbitrary accesses to thread locals\n     * start to consume significant amount of CPU because these maps are open-addressed and cleaned up incrementally on each access.\n     * (You can read more about this effect as \"GC nepotism\").\n     *\n     * To avoid that, we attempt to narrow down the lifetime of this thread local as much as possible:\n     * - It's never accessed when we are sure there are no thread context elements\n     * - It's cleaned up via [ThreadLocal.remove] as soon as the coroutine is suspended or finished.\n     */\n    private val threadStateToRecover = ThreadLocal<Pair<CoroutineContext, Any?>>()\n\n    /*\n     * Indicates that a coroutine has at least one thread context element associated with it\n     * and that 'threadStateToRecover' is going to be set in case of dispatchhing in order to preserve them.\n     * Better than nullable thread-local for easier debugging.\n     *\n     * It is used as a performance optimization to avoid 'threadStateToRecover' initialization\n     * (note: tl.get() initializes thread local),\n     * and is prone to false-positives as it is never reset: otherwise\n     * it may lead to logical data races between suspensions point where\n     * coroutine is yet being suspended in one thread while already being resumed\n     * in another.\n     */\n    @Volatile\n    private var threadLocalIsSet = false\n\n    init {\n        /*\n         * This is a hack for a very specific case in #2930 unless #3253 is implemented.\n         * 'ThreadLocalStressTest' covers this change properly.\n         *\n         * The scenario this change covers is the following:\n         * 1) The coroutine is being started as plain non kotlinx.coroutines related suspend function,\n         *    e.g. `suspend fun main` or, more importantly, Ktor `SuspendFunGun`, that is invoking\n         *    `withContext(tlElement)` which creates `UndispatchedCoroutine`.\n         * 2) It (original continuation) is then not wrapped into `DispatchedContinuation` via `intercept()`\n         *    and goes neither through `DC.run` nor through `resumeUndispatchedWith` that both\n         *    do thread context element tracking.\n         * 3) So thread locals never got chance to get properly set up via `saveThreadContext`,\n         *    but when `withContext` finishes, it attempts to recover thread locals in its `afterResume`.\n         *\n         * Here we detect precisely this situation and properly setup context to recover later.\n         *\n         */\n        if (uCont.context[ContinuationInterceptor] !is CoroutineDispatcher) {\n            /*\n             * We cannot just \"read\" the elements as there is no such API,\n             * so we update-restore it immediately and use the intermediate value\n             * as the initial state, leveraging the fact that thread context element\n             * is idempotent and such situations are increasingly rare.\n             */\n            val values = updateThreadContext(context, null)\n            restoreThreadContext(context, values)\n            saveThreadContext(context, values)\n        }\n    }\n\n    fun saveThreadContext(context: CoroutineContext, oldValue: Any?) {\n        threadLocalIsSet = true // Specify that thread-local is touched at all\n        threadStateToRecover.set(context to oldValue)\n    }\n\n    fun clearThreadContext(): Boolean {\n        return !(threadLocalIsSet && threadStateToRecover.get() == null).also {\n            threadStateToRecover.remove()\n        }\n    }\n\n    override fun afterResume(state: Any?) {\n        if (threadLocalIsSet) {\n            threadStateToRecover.get()?.let { (ctx, value) ->\n                restoreThreadContext(ctx, value)\n            }\n            threadStateToRecover.remove()\n        }\n        // resume undispatched -- update context but stay on the same dispatcher\n        val result = recoverResult(state, uCont)\n        withContinuationContext(uCont, null) {\n            uCont.resumeWith(result)\n        }\n    }\n}\n\ninternal actual val CoroutineContext.coroutineName: String? get() {\n    if (!DEBUG) return null\n    val coroutineId = this[CoroutineId] ?: return null\n    val coroutineName = this[CoroutineName]?.name ?: \"coroutine\"\n    return \"$coroutineName#${coroutineId.id}\"\n}\n\nprivate const val DEBUG_THREAD_NAME_SEPARATOR = \" @\"\n\n@IgnoreJreRequirement // desugared hashcode implementation\n@PublishedApi\ninternal data class CoroutineId(\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    val id: Long\n) : ThreadContextElement<String>, AbstractCoroutineContextElement(CoroutineId) {\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    companion object Key : CoroutineContext.Key<CoroutineId>\n    override fun toString(): String = \"CoroutineId($id)\"\n\n    override fun updateThreadContext(context: CoroutineContext): String {\n        val coroutineName = context[CoroutineName]?.name ?: \"coroutine\"\n        val currentThread = Thread.currentThread()\n        val oldName = currentThread.name\n        var lastIndex = oldName.lastIndexOf(DEBUG_THREAD_NAME_SEPARATOR)\n        if (lastIndex < 0) lastIndex = oldName.length\n        currentThread.name = buildString(lastIndex + coroutineName.length + 10) {\n            append(oldName.substring(0, lastIndex))\n            append(DEBUG_THREAD_NAME_SEPARATOR)\n            append(coroutineName)\n            append('#')\n            append(id)\n        }\n        return oldName\n    }\n\n    override fun restoreThreadContext(context: CoroutineContext, oldState: String) {\n        Thread.currentThread().name = oldState\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/Debug.kt",
        "content": "// Need InlineOnly for efficient bytecode on Android\n@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport java.util.concurrent.atomic.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Name of the property that controls coroutine debugging.\n *\n * ### Debugging facilities\n *\n * In debug mode every coroutine is assigned a unique consecutive identifier.\n * Every thread that executes a coroutine has its name modified to include the name and identifier of\n * the currently running coroutine.\n *\n * Enable debugging facilities with \"`kotlinx.coroutines.debug`\" ([DEBUG_PROPERTY_NAME]) system property,\n * use the following values:\n *\n * - \"`auto`\" (default mode, [DEBUG_PROPERTY_VALUE_AUTO]) -- enabled when assertions are enabled with \"`-ea`\" JVM option.\n * - \"`on`\" ([DEBUG_PROPERTY_VALUE_ON]) or empty string -- enabled.\n * - \"`off`\" ([DEBUG_PROPERTY_VALUE_OFF]) -- disabled.\n *\n * Coroutine name can be explicitly assigned using [CoroutineName] context element.\n * The string \"coroutine\" is used as a default name.\n *\n * Debugging facilities are implemented by [newCoroutineContext][CoroutineScope.newCoroutineContext] function that\n * is used in all coroutine builders to create context of a new coroutine.\n */\npublic const val DEBUG_PROPERTY_NAME: String = \"kotlinx.coroutines.debug\"\n\n/**\n * Name of the boolean property that controls stacktrace recovery (enabled by default) on JVM.\n * Stacktrace recovery is enabled if both debug and stacktrace recovery modes are enabled.\n *\n * Stacktrace recovery mode wraps every exception into the exception of the same type with original exception\n * as cause, but with stacktrace of the current coroutine.\n * Exception is instantiated using reflection by using no-arg, cause or cause and message constructor.\n *\n * This mechanism is currently supported for channels, [async], [launch], [coroutineScope], [supervisorScope]\n * and [withContext] builders.\n */\ninternal const val STACKTRACE_RECOVERY_PROPERTY_NAME = \"kotlinx.coroutines.stacktrace.recovery\"\n\n/**\n * Automatic debug configuration value for [DEBUG_PROPERTY_NAME].\n */\npublic const val DEBUG_PROPERTY_VALUE_AUTO: String = \"auto\"\n\n/**\n * Debug turned on value for [DEBUG_PROPERTY_NAME].\n */\npublic const val DEBUG_PROPERTY_VALUE_ON: String = \"on\"\n\n/**\n * Debug turned off value for [DEBUG_PROPERTY_NAME].\n */\npublic const val DEBUG_PROPERTY_VALUE_OFF: String = \"off\"\n\n// @JvmField: Don't use JvmField here to enable R8 optimizations via \"assumenosideeffects\"\ninternal val ASSERTIONS_ENABLED = CoroutineId::class.java.desiredAssertionStatus()\n\n// @JvmField: Don't use JvmField here to enable R8 optimizations via \"assumenosideeffects\"\ninternal actual val DEBUG = systemProp(DEBUG_PROPERTY_NAME).let { value ->\n    when (value) {\n        DEBUG_PROPERTY_VALUE_AUTO, null -> ASSERTIONS_ENABLED\n        DEBUG_PROPERTY_VALUE_ON, \"\" -> true\n        DEBUG_PROPERTY_VALUE_OFF -> false\n        else -> error(\"System property '$DEBUG_PROPERTY_NAME' has unrecognized value '$value'\")\n    }\n}\n\n// Note: stack-trace recovery is enabled only in debug mode\n// @JvmField: Don't use JvmField here to enable R8 optimizations via \"assumenosideeffects\"\n@PublishedApi\ninternal actual val RECOVER_STACK_TRACES: Boolean =\n    DEBUG && systemProp(STACKTRACE_RECOVERY_PROPERTY_NAME, true)\n\n// It is used only in debug mode\ninternal val COROUTINE_ID = AtomicLong(0)\n\n// for tests only\ninternal fun resetCoroutineId() {\n    COROUTINE_ID.set(0)\n}\n\n@InlineOnly\ninternal actual inline fun assert(value: () -> Boolean) {\n    if (ASSERTIONS_ENABLED && !value()) throw AssertionError()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/DebugStrings.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n// internal debugging tools for string representation\n\ninternal actual val Any.hexAddress: String\n    get() = Integer.toHexString(System.identityHashCode(this))\n\ninternal actual fun Continuation<*>.toDebugString(): String = when (this) {\n    is DispatchedContinuation -> toString()\n    // Workaround for #858\n    else -> runCatching { \"$this@$hexAddress\" }.getOrElse { \"${this::class.java.name}@$hexAddress\" }\n}\n\ninternal actual val Any.classSimpleName: String get() = this::class.java.simpleName\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/DefaultExecutor.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\nprivate val defaultMainDelayOptIn = systemProp(\"kotlinx.coroutines.main.delay\", false)\n\n@PublishedApi\ninternal actual val DefaultDelay: Delay = initializeDefaultDelay()\n\nprivate fun initializeDefaultDelay(): Delay {\n    // Opt-out flag\n    if (!defaultMainDelayOptIn) return DefaultExecutor\n    val main = Dispatchers.Main\n    /*\n     * When we already are working with UI and Main threads, it makes\n     * no sense to create a separate thread with timer that cannot be controller\n     * by the UI runtime.\n     */\n    return if (main.isMissing() || main !is Delay) DefaultExecutor else main\n}\n\n@Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\ninternal actual object DefaultExecutor : EventLoopImplBase(), Runnable {\n    const val THREAD_NAME = \"kotlinx.coroutines.DefaultExecutor\"\n\n    init {\n        incrementUseCount() // this event loop is never completed\n    }\n\n    private const val DEFAULT_KEEP_ALIVE_MS = 1000L // in milliseconds\n\n    private val KEEP_ALIVE_NANOS = TimeUnit.MILLISECONDS.toNanos(\n        try {\n            java.lang.Long.getLong(\"kotlinx.coroutines.DefaultExecutor.keepAlive\", DEFAULT_KEEP_ALIVE_MS)\n        } catch (e: SecurityException) {\n            DEFAULT_KEEP_ALIVE_MS\n        })\n\n    @Suppress(\"ObjectPropertyName\")\n    @Volatile\n    private var _thread: Thread? = null\n\n    override val thread: Thread\n        get() = _thread ?: createThreadSync()\n\n    private const val FRESH = 0\n    private const val ACTIVE = 1\n    private const val SHUTDOWN_REQ = 2\n    private const val SHUTDOWN_ACK = 3\n    private const val SHUTDOWN = 4\n\n    @Volatile\n    private var debugStatus: Int = FRESH\n\n    private val isShutDown: Boolean get() = debugStatus == SHUTDOWN\n\n    private val isShutdownRequested: Boolean get() {\n        val debugStatus = debugStatus\n        return debugStatus == SHUTDOWN_REQ || debugStatus == SHUTDOWN_ACK\n    }\n\n    actual override fun enqueue(task: Runnable) {\n        if (isShutDown) shutdownError()\n        super.enqueue(task)\n    }\n\n     override fun reschedule(now: Long, delayedTask: DelayedTask) {\n         // Reschedule on default executor can only be invoked after Dispatchers.shutdown\n         shutdownError()\n    }\n\n    private fun shutdownError() {\n        throw RejectedExecutionException(\"DefaultExecutor was shut down. \" +\n            \"This error indicates that Dispatchers.shutdown() was invoked prior to completion of exiting coroutines, leaving coroutines in incomplete state. \" +\n            \"Please refer to Dispatchers.shutdown documentation for more details\")\n    }\n\n    override fun shutdown() {\n        debugStatus = SHUTDOWN\n        super.shutdown()\n    }\n\n    /**\n     * All event loops are using DefaultExecutor#invokeOnTimeout to avoid livelock on\n     * ```\n     * runBlocking(eventLoop) { withTimeout { while(isActive) { ... } } }\n     * ```\n     *\n     * Livelock is possible only if `runBlocking` is called on internal default executed (which is used by default [delay]),\n     * but it's not exposed as public API.\n     */\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle =\n        scheduleInvokeOnTimeout(timeMillis, block)\n\n    override fun run() {\n        ThreadLocalEventLoop.setEventLoop(this)\n        registerTimeLoopThread()\n        try {\n            var shutdownNanos = Long.MAX_VALUE\n            if (!notifyStartup()) return\n            while (true) {\n                Thread.interrupted() // just reset interruption flag\n                var parkNanos = processNextEvent()\n                if (parkNanos == Long.MAX_VALUE) {\n                    // nothing to do, initialize shutdown timeout\n                    val now = nanoTime()\n                    if (shutdownNanos == Long.MAX_VALUE) shutdownNanos = now + KEEP_ALIVE_NANOS\n                    val tillShutdown = shutdownNanos - now\n                    if (tillShutdown <= 0) return // shut thread down\n                    parkNanos = parkNanos.coerceAtMost(tillShutdown)\n                } else\n                    shutdownNanos = Long.MAX_VALUE\n                if (parkNanos > 0) {\n                    // check if shutdown was requested and bail out in this case\n                    if (isShutdownRequested) return\n                    parkNanos(this, parkNanos)\n                }\n            }\n        } finally {\n            _thread = null // this thread is dead\n            acknowledgeShutdownIfNeeded()\n            unregisterTimeLoopThread()\n            // recheck if queues are empty after _thread reference was set to null (!!!)\n            if (!isEmpty) thread // recreate thread if it is needed\n        }\n    }\n\n    @Synchronized\n    private fun createThreadSync(): Thread {\n        return _thread ?: Thread(this, THREAD_NAME).apply {\n            _thread = this\n            /*\n             * `DefaultExecutor` is a global singleton that creates its thread lazily.\n             * To isolate the classloaders properly, we are inherting the context classloader from\n             * the singleton itself instead of using parent' thread one\n             * in order not to accidentally capture temporary application classloader.\n             */\n            contextClassLoader = this@DefaultExecutor.javaClass.classLoader\n            isDaemon = true\n            start()\n        }\n    }\n\n    // used for tests\n    @Synchronized\n    internal fun ensureStarted() {\n        assert { _thread == null } // ensure we are at a clean state\n        assert { debugStatus == FRESH || debugStatus == SHUTDOWN_ACK }\n        debugStatus = FRESH\n        createThreadSync() // create fresh thread\n        while (debugStatus == FRESH) (this as Object).wait()\n    }\n\n    @Synchronized\n    private fun notifyStartup(): Boolean {\n        if (isShutdownRequested) return false\n        debugStatus = ACTIVE\n        (this as Object).notifyAll()\n        return true\n    }\n\n    @Synchronized // used _only_ for tests\n    fun shutdownForTests(timeout: Long) {\n        val deadline = System.currentTimeMillis() + timeout\n        if (!isShutdownRequested) debugStatus = SHUTDOWN_REQ\n        // loop while there is anything to do immediately or deadline passes\n        while (debugStatus != SHUTDOWN_ACK && _thread != null) {\n            _thread?.let { unpark(it) } // wake up thread if present\n            val remaining = deadline - System.currentTimeMillis()\n            if (remaining <= 0) break\n            (this as Object).wait(timeout)\n        }\n        // restore fresh status\n        debugStatus = FRESH\n    }\n\n    @Synchronized\n    private fun acknowledgeShutdownIfNeeded() {\n        if (!isShutdownRequested) return\n        debugStatus = SHUTDOWN_ACK\n        resetAll() // clear queues\n        (this as Object).notifyAll()\n    }\n\n    internal val isThreadPresent\n        get() = _thread != null\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/Dispatchers.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.scheduling.*\nimport kotlin.coroutines.*\n\n/**\n * Name of the property that defines the maximal number of threads that are used by [Dispatchers.IO] coroutines dispatcher.\n */\npublic const val IO_PARALLELISM_PROPERTY_NAME: String = \"kotlinx.coroutines.io.parallelism\"\n\n/**\n * Groups various implementations of [CoroutineDispatcher].\n */\npublic actual object Dispatchers {\n    @JvmStatic\n    public actual val Default: CoroutineDispatcher = DefaultScheduler\n\n    @JvmStatic\n    public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher\n\n    @JvmStatic\n    public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined\n\n    /**\n     * The [CoroutineDispatcher] that is designed for offloading blocking IO tasks to a shared pool of threads.\n     *\n     * Additional threads in this pool are created and are shutdown on demand.\n     * The number of threads used by tasks in this dispatcher is limited by the value of\n     * \"`kotlinx.coroutines.io.parallelism`\" ([IO_PARALLELISM_PROPERTY_NAME]) system property.\n     * It defaults to the limit of 64 threads or the number of cores (whichever is larger).\n     *\n     * ### Elasticity for limited parallelism\n     *\n     * `Dispatchers.IO` has a unique property of elasticity: its views\n     * obtained with [CoroutineDispatcher.limitedParallelism] are\n     * not restricted by the `Dispatchers.IO` parallelism. Conceptually, there is\n     * a dispatcher backed by an unlimited pool of threads, and both `Dispatchers.IO`\n     * and views of `Dispatchers.IO` are actually views of that dispatcher. In practice\n     * this means that, despite not abiding by `Dispatchers.IO`'s parallelism\n     * restrictions, its views share threads and resources with it.\n     *\n     * In the following example\n     * ```\n     * // 100 threads for MySQL connection\n     * val myMysqlDbDispatcher = Dispatchers.IO.limitedParallelism(100)\n     * // 60 threads for MongoDB connection\n     * val myMongoDbDispatcher = Dispatchers.IO.limitedParallelism(60)\n     * ```\n     * the system may have up to `64 + 100 + 60` threads dedicated to blocking tasks during peak loads,\n     * but during its steady state there is only a small number of threads shared\n     * among `Dispatchers.IO`, `myMysqlDbDispatcher` and `myMongoDbDispatcher`.\n     *\n     * ### Implementation note\n     *\n     * This dispatcher and its views share threads with the [Default][Dispatchers.Default] dispatcher, so using\n     * `withContext(Dispatchers.IO) { ... }` when already running on the [Default][Dispatchers.Default]\n     * dispatcher typically does not lead to an actual switching to another thread. In such scenarios,\n     * the underlying implementation attempts to keep the execution on the same thread on a best-effort basis.\n     *\n     * As a result of thread sharing, more than 64 (default parallelism) threads can be created (but not used)\n     * during operations over IO dispatcher.\n     */\n    @JvmStatic\n    public val IO: CoroutineDispatcher = DefaultIoScheduler\n\n    /**\n     * Shuts down built-in dispatchers, such as [Default] and [IO],\n     * stopping all the threads associated with them and making them reject all new tasks.\n     * Dispatcher used as a fallback for time-related operations (`delay`, `withTimeout`)\n     * and to handle rejected tasks from other dispatchers is also shut down.\n     *\n     * This is a **delicate** API. It is not supposed to be called from a general\n     * application-level code and its invocation is irreversible.\n     * The invocation of shutdown affects most of the coroutines machinery and\n     * leaves the coroutines framework in an inoperable state.\n     * The shutdown method should only be invoked when there are no pending tasks or active coroutines.\n     * Otherwise, the behavior is unspecified: the call to `shutdown` may throw an exception without completing\n     * the shutdown, or it may finish successfully, but the remaining jobs will be in a permanent dormant state,\n     * never completing nor executing.\n     *\n     * The main goal of the shutdown is to stop all background threads associated with the coroutines\n     * framework in order to make kotlinx.coroutines classes unloadable by Java Virtual Machine.\n     * It is only recommended to be used in containerized environments (OSGi, Gradle plugins system,\n     * IDEA plugins) at the end of the container lifecycle.\n     */\n    @DelicateCoroutinesApi\n    public fun shutdown() {\n        DefaultExecutor.shutdown()\n        // Also shuts down Dispatchers.IO\n        DefaultScheduler.shutdown()\n    }\n}\n\n/**\n * `actual` counterpart of the corresponding `expect` declaration.\n * Should never be used directly from JVM sources, all accesses\n * to `Dispatchers.IO` should be resolved to the corresponding member of [Dispatchers] object.\n * @suppress\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(message = \"Should not be used directly\", level = DeprecationLevel.HIDDEN)\npublic actual val Dispatchers.IO: CoroutineDispatcher get() = Dispatchers.IO\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/EventLoop.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.Runnable\nimport kotlinx.coroutines.scheduling.*\nimport kotlinx.coroutines.scheduling.CoroutineScheduler\n\ninternal actual abstract class EventLoopImplPlatform: EventLoop() {\n\n    protected abstract val thread: Thread\n\n    protected actual fun unpark() {\n        val thread = thread // atomic read\n        if (Thread.currentThread() !== thread)\n            unpark(thread)\n    }\n\n    protected actual open fun reschedule(now: Long, delayedTask: EventLoopImplBase.DelayedTask) {\n        DefaultExecutor.schedule(now, delayedTask)\n    }\n}\n\ninternal class BlockingEventLoop(\n    override val thread: Thread\n) : EventLoopImplBase()\n\ninternal actual fun createEventLoop(): EventLoop = BlockingEventLoop(Thread.currentThread())\n\n/**\n * Processes next event in the current thread's event loop.\n *\n * The result of this function is to be interpreted like this:\n * - `<= 0` -- there are potentially more events for immediate processing;\n * - `> 0` -- a number of nanoseconds to wait for the next scheduled event;\n * - [Long.MAX_VALUE] -- no more events or no thread-local event loop.\n *\n * Sample usage of this function:\n *\n * ```\n * while (waitingCondition) {\n *     val time = processNextEventInCurrentThread()\n *     LockSupport.parkNanos(time)\n * }\n * ```\n *\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic fun processNextEventInCurrentThread(): Long =\n    // This API is used in Ktor for serverless integration where a single thread awaits a blocking call\n    // (and, to avoid actual blocking, does something via this call), see #850\n    ThreadLocalEventLoop.currentOrNull()?.processNextEvent() ?: Long.MAX_VALUE\n\ninternal actual inline fun platformAutoreleasePool(crossinline block: () -> Unit) = block()\n\n/**\n * Retrieves and executes a single task from the current system dispatcher ([Dispatchers.Default] or [Dispatchers.IO]).\n * Returns `0` if any task was executed, `>= 0` for number of nanoseconds to wait until invoking this method again\n * (implying that there will be a task to steal in N nanoseconds), `-1` if there is no tasks in the corresponding dispatcher at all.\n *\n * ### Invariants\n *\n *  - When invoked from [Dispatchers.Default] **thread** (even if the actual context is different dispatcher,\n *    [CoroutineDispatcher.limitedParallelism] or any in-place wrapper), it runs an arbitrary task that ended\n *    up being scheduled to [Dispatchers.Default] or its counterpart. Tasks scheduled to [Dispatchers.IO]\n *    **are not** executed[1].\n *  - When invoked from [Dispatchers.IO] thread, the same rules apply, but for blocking tasks only.\n *\n * [1] -- this is purely technical limitation: the scheduler does not have \"notify me when CPU token is available\" API,\n * and we cannot leave this method without leaving thread in its original state.\n *\n * ### Rationale\n *\n * This is an internal API that is intended to replace IDEA's core FJP decomposition.\n * The following API is provided by IDEA core:\n * ```\n * runDecomposedTaskAndJoinIt { // <- non-suspending call\n *     // spawn as many tasks as needed\n *     // these tasks can also invoke 'runDecomposedTaskAndJoinIt'\n * }\n * ```\n * The key observation here is that 'runDecomposedTaskAndJoinIt' can be invoked from `Dispatchers.Default` itself,\n * thus blocking at least one thread. To avoid deadlocks and starvation during large hierarchical decompositions,\n * 'runDecomposedTaskAndJoinIt' should not just block but also **help** execute the task or other tasks\n * until an arbitrary condition is satisfied.\n *\n * See #3439 for additional details.\n *\n * ### Limitations and caveats\n *\n * - Executes tasks in-place, thus potentially leaking irrelevant thread-locals from the current thread\n * - Is not 100% effective, because the caller should somehow \"wait\" (or do other work) for [Long] returned nanoseconds\n *   even when work arrives immediately after returning from this method.\n * - When there is no more work, it's up to the caller to decide what to do. It's important to remember that\n *   work to current dispatcher may arrive **later** from external sources [1]\n *\n * [1] -- this is also a technicality that can be solved in kotlinx.coroutines itself, but unfortunately requires\n *        a tremendous effort.\n *\n * @throws IllegalStateException if the current thread is not system dispatcher thread\n */\n@InternalCoroutinesApi\n@DelicateCoroutinesApi\n@PublishedApi\ninternal fun runSingleTaskFromCurrentSystemDispatcher(): Long {\n    val thread = Thread.currentThread()\n    if (thread !is CoroutineScheduler.Worker) throw IllegalStateException(\"Expected CoroutineScheduler.Worker, but got $thread\")\n    return thread.runSingleTask()\n}\n\n/**\n * Checks whether the given thread belongs to Dispatchers.IO.\n * Note that feature \"is part of the Dispatchers.IO\" is *dynamic*, meaning that the thread\n * may change this status when switching between tasks.\n *\n * This function is inteded to be used on the result of `Thread.currentThread()` for diagnostic\n * purposes, and is declared as an extension only to avoid top-level scope pollution.\n */\n@InternalCoroutinesApi\n@DelicateCoroutinesApi\n@PublishedApi\ninternal fun Thread.isIoDispatcherThread(): Boolean {\n    if (this !is CoroutineScheduler.Worker) return false\n    return isIo()\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/Exceptions.kt",
        "content": "@file:Suppress(\"FunctionName\")\n\npackage kotlinx.coroutines\n\n/**\n * Thrown by cancellable suspending functions if the [Job] of the coroutine is cancelled while it is suspending.\n * It indicates _normal_ cancellation of a coroutine.\n * **It is not printed to console/log by default uncaught exception handler**.\n * See [CoroutineExceptionHandler]\n*/\npublic actual typealias CancellationException = java.util.concurrent.CancellationException\n\n/**\n * Creates a cancellation exception with a specified message and [cause].\n */\npublic actual fun CancellationException(message: String?, cause: Throwable?) : CancellationException =\n    CancellationException(message).apply { initCause(cause) }\n\n/**\n * Thrown by cancellable suspending functions if the [Job] of the coroutine is cancelled or completed\n * without cause, or with a cause or exception that is not [CancellationException]\n * (see [Job.getCancellationException]).\n */\ninternal actual class JobCancellationException public actual constructor(\n    message: String,\n    cause: Throwable?,\n    @JvmField @Transient internal actual val job: Job\n) : CancellationException(message), CopyableThrowable<JobCancellationException> {\n\n    init {\n        if (cause != null) initCause(cause)\n    }\n\n    override fun fillInStackTrace(): Throwable {\n        if (DEBUG) {\n            return super.fillInStackTrace()\n        }\n        // Prevent Android <= 6.0 bug, #1866\n        stackTrace = emptyArray()\n        /*\n         * In non-debug mode we don't want to have a stacktrace on every cancellation/close,\n         * parent job reference is enough. Stacktrace of JCE is not needed most of the time (e.g., it is not logged)\n         * and hurts performance.\n         */\n        return this\n    }\n\n    override fun createCopy(): JobCancellationException? {\n        if (DEBUG) {\n            return JobCancellationException(message!!, this, job)\n        }\n\n        /*\n         * In non-debug mode we don't copy JCE for speed as it does not have the stack trace anyway.\n         */\n        return null\n    }\n\n    override fun toString(): String = \"${super.toString()}; job=$job\"\n\n    override fun equals(other: Any?): Boolean =\n        other === this ||\n            other is JobCancellationException && other.message == message && other.job == job && other.cause == cause\n    override fun hashCode(): Int =\n        (message!!.hashCode() * 31 + job.hashCode()) * 31 + (cause?.hashCode() ?: 0)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/Executors.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.internal.*\nimport java.io.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n/**\n * [CoroutineDispatcher] that has underlying [Executor] for dispatching tasks.\n * Instances of [ExecutorCoroutineDispatcher] should be closed by the owner of the dispatcher.\n *\n * This class is generally used as a bridge between coroutine-based API and\n * asynchronous API that requires an instance of the [Executor].\n */\npublic abstract class ExecutorCoroutineDispatcher: CoroutineDispatcher(), Closeable {\n    /** @suppress */\n    @ExperimentalStdlibApi\n    public companion object Key : AbstractCoroutineContextKey<CoroutineDispatcher, ExecutorCoroutineDispatcher>(\n        CoroutineDispatcher,\n        { it as? ExecutorCoroutineDispatcher })\n\n    /**\n     * Underlying executor of current [CoroutineDispatcher].\n     */\n    public abstract val executor: Executor\n\n    /**\n     * Closes this coroutine dispatcher and shuts down its executor.\n     *\n     * It may throw an exception if this dispatcher is global and cannot be closed.\n     */\n    public abstract override fun close()\n}\n\n@ExperimentalCoroutinesApi\npublic actual typealias CloseableCoroutineDispatcher = ExecutorCoroutineDispatcher\n\n/**\n * Converts an instance of [ExecutorService] to an implementation of [ExecutorCoroutineDispatcher].\n *\n * ## Interaction with [delay] and time-based coroutines.\n *\n * If the given [ExecutorService] is an instance of [ScheduledExecutorService], then all time-related\n * coroutine operations such as [delay], [withTimeout] and time-based [Flow] operators will be scheduled\n * on this executor using [schedule][ScheduledExecutorService.schedule] method. If the corresponding\n * coroutine is cancelled, [ScheduledFuture.cancel] will be invoked on the corresponding future.\n *\n * If the given [ExecutorService] is an instance of [ScheduledThreadPoolExecutor], then prior to any scheduling,\n * remove on cancel policy will be set via [ScheduledThreadPoolExecutor.setRemoveOnCancelPolicy] in order\n * to reduce the memory pressure of cancelled coroutines.\n *\n * If the executor service is neither of this types, the separate internal thread will be used to\n * _track_ the delay and time-related executions, but the coroutine itself will still be executed\n * on top of the given executor.\n *\n * ## Rejected execution\n * If the underlying executor throws [RejectedExecutionException] on\n * attempt to submit a continuation task (it happens when [closing][ExecutorCoroutineDispatcher.close] the\n * resulting dispatcher, on underlying executor [shutdown][ExecutorService.shutdown], or when it uses limited queues),\n * then the [Job] of the affected task is [cancelled][Job.cancel] and the task is submitted to the\n * [Dispatchers.IO], so that the affected coroutine can cleanup its resources and promptly complete.\n */\n@JvmName(\"from\") // this is for a nice Java API, see issue #255\npublic fun ExecutorService.asCoroutineDispatcher(): ExecutorCoroutineDispatcher =\n    ExecutorCoroutineDispatcherImpl(this)\n\n/**\n * Converts an instance of [Executor] to an implementation of [CoroutineDispatcher].\n *\n * ## Interaction with [delay] and time-based coroutines.\n *\n * If the given [Executor] is an instance of [ScheduledExecutorService], then all time-related\n * coroutine operations such as [delay], [withTimeout] and time-based [Flow] operators will be scheduled\n * on this executor using [schedule][ScheduledExecutorService.schedule] method. If the corresponding\n * coroutine is cancelled, [ScheduledFuture.cancel] will be invoked on the corresponding future.\n *\n * If the given [Executor] is an instance of [ScheduledThreadPoolExecutor], then prior to any scheduling,\n * remove on cancel policy will be set via [ScheduledThreadPoolExecutor.setRemoveOnCancelPolicy] in order\n * to reduce the memory pressure of cancelled coroutines.\n *\n * If the executor is neither of this types, the separate internal thread will be used to\n * _track_ the delay and time-related executions, but the coroutine itself will still be executed\n * on top of the given executor.\n *\n * ## Rejected execution\n *\n * If the underlying executor throws [RejectedExecutionException] on\n * attempt to submit a continuation task (it happens when [closing][ExecutorCoroutineDispatcher.close] the\n * resulting dispatcher, on underlying executor [shutdown][ExecutorService.shutdown], or when it uses limited queues),\n * then the [Job] of the affected task is [cancelled][Job.cancel] and the task is submitted to the\n * [Dispatchers.IO], so that the affected coroutine can cleanup its resources and promptly complete.\n */\n@JvmName(\"from\") // this is for a nice Java API, see issue #255\npublic fun Executor.asCoroutineDispatcher(): CoroutineDispatcher =\n    (this as? DispatcherExecutor)?.dispatcher ?: ExecutorCoroutineDispatcherImpl(this)\n\n/**\n * Converts an instance of [CoroutineDispatcher] to an implementation of [Executor].\n *\n * It returns the original executor when used on the result of [Executor.asCoroutineDispatcher] extensions.\n */\npublic fun CoroutineDispatcher.asExecutor(): Executor =\n    (this as? ExecutorCoroutineDispatcher)?.executor ?: DispatcherExecutor(this)\n\nprivate class DispatcherExecutor(@JvmField val dispatcher: CoroutineDispatcher) : Executor {\n    override fun execute(block: Runnable) {\n        if (dispatcher.isDispatchNeeded(EmptyCoroutineContext)) {\n            dispatcher.dispatch(EmptyCoroutineContext, block)\n        } else {\n            block.run()\n        }\n    }\n\n    override fun toString(): String = dispatcher.toString()\n}\n\ninternal class ExecutorCoroutineDispatcherImpl(override val executor: Executor) : ExecutorCoroutineDispatcher(), Delay {\n\n    /*\n     * Attempts to reflectively (to be Java 6 compatible) invoke\n     * ScheduledThreadPoolExecutor.setRemoveOnCancelPolicy in order to cleanup\n     * internal scheduler queue on cancellation.\n     */\n    init {\n        removeFutureOnCancel(executor)\n    }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        try {\n            executor.execute(wrapTask(block))\n        } catch (e: RejectedExecutionException) {\n            unTrackTask()\n            cancelJobOnRejection(context, e)\n            Dispatchers.IO.dispatch(context, block)\n        }\n    }\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val future = (executor as? ScheduledExecutorService)?.scheduleBlock(\n            ResumeUndispatchedRunnable(this, continuation),\n            continuation.context,\n            timeMillis\n        )\n        // If everything went fine and the scheduling attempt was not rejected -- use it\n        if (future != null) {\n            continuation.cancelFutureOnCancellation(future)\n            return\n        }\n        // Otherwise fallback to default executor\n        DefaultExecutor.scheduleResumeAfterDelay(timeMillis, continuation)\n    }\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        val future = (executor as? ScheduledExecutorService)?.scheduleBlock(block, context, timeMillis)\n        return when {\n            future != null -> DisposableFutureHandle(future)\n            else -> DefaultExecutor.invokeOnTimeout(timeMillis, block, context)\n        }\n    }\n\n    private fun ScheduledExecutorService.scheduleBlock(block: Runnable, context: CoroutineContext, timeMillis: Long): ScheduledFuture<*>? {\n        return try {\n            schedule(block, timeMillis, TimeUnit.MILLISECONDS)\n        } catch (e: RejectedExecutionException) {\n            cancelJobOnRejection(context, e)\n            null\n        }\n    }\n\n    private fun cancelJobOnRejection(context: CoroutineContext, exception: RejectedExecutionException) {\n        context.cancel(CancellationException(\"The task was rejected\", exception))\n    }\n\n    override fun close() {\n        (executor as? ExecutorService)?.shutdown()\n    }\n\n    override fun toString(): String = executor.toString()\n    override fun equals(other: Any?): Boolean = other is ExecutorCoroutineDispatcherImpl && other.executor === executor\n    override fun hashCode(): Int = System.identityHashCode(executor)\n}\n\nprivate class ResumeUndispatchedRunnable(\n    private val dispatcher: CoroutineDispatcher,\n    private val continuation: CancellableContinuation<Unit>\n) : Runnable {\n    override fun run() {\n        with(continuation) { dispatcher.resumeUndispatched(Unit) }\n    }\n}\n\n/**\n * An implementation of [DisposableHandle] that cancels the specified future on dispose.\n * @suppress **This is unstable API and it is subject to change.**\n */\nprivate class DisposableFutureHandle(private val future: Future<*>) : DisposableHandle {\n    override fun dispose() {\n        future.cancel(false)\n    }\n    override fun toString(): String = \"DisposableFutureHandle[$future]\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/Future.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"JobKt\")\n\npackage kotlinx.coroutines\n\nimport java.util.concurrent.*\n\n/**\n * Cancels a specified [future] when this job is cancelled.\n * This is a shortcut for the following code with slightly more efficient implementation (one fewer object created).\n * ```\n * invokeOnCompletion { if (it != null) future.cancel(false) }\n * ```\n *\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic fun Job.cancelFutureOnCompletion(future: Future<*>): DisposableHandle =\n    invokeOnCompletion(handler = CancelFutureOnCompletion(future))\n\n/**\n * Cancels a specified [future] when this job is cancelled.\n * This is a shortcut for the following code with slightly more efficient implementation (one fewer object created).\n * ```\n * invokeOnCancellation { if (it != null) future.cancel(false) }\n * ```\n */\npublic fun CancellableContinuation<*>.cancelFutureOnCancellation(future: Future<*>): Unit =\n    invokeOnCancellation(handler = CancelFutureOnCancel(future))\n\nprivate class CancelFutureOnCompletion(\n    private val future: Future<*>\n) : JobNode() {\n    override fun invoke(cause: Throwable?) {\n        // Don't interrupt when cancelling future on completion, because no one is going to reset this\n        // interruption flag and it will cause spurious failures elsewhere\n        if (cause != null) future.cancel(false)\n    }\n}\n\nprivate class CancelFutureOnCancel(private val future: Future<*>) : CancelHandler {\n    override fun invoke(cause: Throwable?) {\n        // Don't interrupt when cancelling future on completion, because no one is going to reset this\n        // interruption flag and it will cause spurious failures elsewhere\n        if (cause != null)  future.cancel(false)\n    }\n    override fun toString() = \"CancelFutureOnCancel[$future]\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/Interruptible.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlin.coroutines.*\n\n/**\n * Calls the specified [block] with a given coroutine context in\n * [an interruptible manner](https://docs.oracle.com/javase/tutorial/essential/concurrency/interrupt.html).\n * The blocking code block will be interrupted and this function will throw [CancellationException]\n * if the coroutine is cancelled.\n *\n * Example:\n *\n * ```\n * withTimeout(500L) {            // Cancels coroutine on timeout\n *     runInterruptible {         // Throws CancellationException if interrupted\n *         doSomethingBlocking()  // Interrupted on coroutines cancellation\n *     }\n * }\n * ```\n *\n * There is an optional [context] parameter to this function working just like [withContext].\n * It enables single-call conversion of interruptible Java methods into suspending functions.\n * With one call here we are moving the call to [Dispatchers.IO] and supporting interruption:\n *\n * ```\n * suspend fun <T> BlockingQueue<T>.awaitTake(): T =\n *         runInterruptible(Dispatchers.IO) { queue.take() }\n * ```\n *\n * `runInterruptible` uses [withContext] as an underlying mechanism for switching context,\n * meaning that the supplied [block] is invoked in an [undispatched][CoroutineStart.UNDISPATCHED]\n * manner directly by the caller if [CoroutineDispatcher] from the current [coroutineContext][currentCoroutineContext]\n * is the same as the one supplied in [context].\n */\npublic suspend fun <T> runInterruptible(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: () -> T\n): T = withContext(context) {\n    runInterruptibleInExpectedContext(coroutineContext, block)\n}\n\nprivate fun <T> runInterruptibleInExpectedContext(coroutineContext: CoroutineContext, block: () -> T): T {\n    try {\n        val threadState = ThreadState(coroutineContext.job)\n        threadState.setup()\n        try {\n            return block()\n        } finally {\n            threadState.clearInterrupt()\n        }\n    } catch (e: InterruptedException) {\n        throw CancellationException(\"Blocking call was interrupted due to parent cancellation\").initCause(e)\n    }\n}\n\nprivate const val WORKING = 0\nprivate const val FINISHED = 1\nprivate const val INTERRUPTING = 2\nprivate const val INTERRUPTED = 3\n\nprivate class ThreadState(private val job: Job) : InternalCompletionHandler {\n    /*\n       === States ===\n\n       WORKING: running normally\n       FINISH: complete normally\n       INTERRUPTING: canceled, going to interrupt this thread\n       INTERRUPTED: this thread is interrupted\n\n       === Possible Transitions ===\n\n       +----------------+         register job       +-------------------------+\n       |    WORKING     |   cancellation listener    |         WORKING         |\n       | (thread, null) | -------------------------> | (thread, cancel handle) |\n       +----------------+                            +-------------------------+\n               |                                                |   |\n               | cancel                                  cancel |   | complete\n               |                                                |   |\n               V                                                |   |\n       +---------------+                                        |   |\n       | INTERRUPTING  | <--------------------------------------+   |\n       +---------------+                                            |\n               |                                                    |\n               | interrupt                                          |\n               |                                                    |\n               V                                                    V\n       +---------------+                              +-------------------------+\n       |  INTERRUPTED  |                              |         FINISHED        |\n       +---------------+                              +-------------------------+\n    */\n    private val _state = atomic(WORKING)\n    private val targetThread = Thread.currentThread()\n\n    // Registered cancellation handler\n    private var cancelHandle: DisposableHandle? = null\n\n    fun setup() {\n        cancelHandle = job.invokeOnCompletion(onCancelling = true, invokeImmediately = true, handler = this)\n        // Either we successfully stored it or it was immediately cancelled\n        _state.loop { state ->\n            when (state) {\n                // Happy-path, move forward\n                WORKING -> if (_state.compareAndSet(state, WORKING)) return\n                // Immediately cancelled, just continue\n                INTERRUPTING, INTERRUPTED -> return\n                else -> invalidState(state)\n            }\n        }\n    }\n\n    fun clearInterrupt() {\n        /*\n         * Do not allow to untriggered interrupt to leak\n         */\n        _state.loop { state ->\n            when (state) {\n                WORKING -> if (_state.compareAndSet(state, FINISHED)) {\n                    cancelHandle?.dispose()\n                    return\n                }\n                INTERRUPTING -> {\n                   /*\n                    * Spin, cancellation mechanism is interrupting our thread right now\n                    * and we have to wait it and then clear interrupt status\n                    */\n                }\n                INTERRUPTED -> {\n                    // Clear it and bail out\n                    Thread.interrupted()\n                    return\n                }\n                else -> invalidState(state)\n            }\n        }\n    }\n\n    // Cancellation handler\n    override fun invoke(cause: Throwable?) {\n        _state.loop { state ->\n            when (state) {\n                // Working -> try to transite state and interrupt the thread\n                WORKING -> {\n                    if (_state.compareAndSet(state, INTERRUPTING)) {\n                        targetThread.interrupt()\n                        _state.value = INTERRUPTED\n                        return\n                    }\n                }\n                // Finished -- runInterruptible is already complete, INTERRUPTING - ignore\n                FINISHED, INTERRUPTING, INTERRUPTED -> return\n                else -> invalidState(state)\n            }\n        }\n    }\n\n    private fun invalidState(state: Int): Nothing = error(\"Illegal state $state\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/Runnable.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * A runnable task for [CoroutineDispatcher.dispatch].\n */\npublic actual typealias Runnable = java.lang.Runnable\n\n/**\n * Creates [Runnable] task instance.\n */\n@Suppress(\"FunctionName\")\npublic actual inline fun Runnable(crossinline block: () -> Unit): Runnable =\n    java.lang.Runnable { block() }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/SchedulerTask.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.scheduling.*\n\ninternal actual typealias SchedulerTask = Task\n\ninternal actual typealias SchedulerTaskContext = TaskContext\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\ninternal actual val SchedulerTask.taskContext: SchedulerTaskContext get() = taskContext\n\n@Suppress(\"NOTHING_TO_INLINE\", \"EXTENSION_SHADOWED_BY_MEMBER\")\ninternal actual inline fun SchedulerTaskContext.afterTask() =\n    afterTask()\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/ThreadContextElement.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n/**\n * Defines elements in [CoroutineContext] that are installed into thread context\n * every time the coroutine with this element in the context is resumed on a thread.\n *\n * Implementations of this interface define a type [S] of the thread-local state that they need to store on\n * resume of a coroutine and restore later on suspend. The infrastructure provides the corresponding storage.\n *\n * Example usage looks like this:\n *\n * ```\n * // Appends \"name\" of a coroutine to a current thread name when coroutine is executed\n * class CoroutineName(val name: String) : ThreadContextElement<String> {\n *     // declare companion object for a key of this element in coroutine context\n *     companion object Key : CoroutineContext.Key<CoroutineName>\n *\n *     // provide the key of the corresponding context element\n *     override val key: CoroutineContext.Key<CoroutineName>\n *         get() = Key\n *\n *     // this is invoked before coroutine is resumed on current thread\n *     override fun updateThreadContext(context: CoroutineContext): String {\n *         val previousName = Thread.currentThread().name\n *         Thread.currentThread().name = \"$previousName # $name\"\n *         return previousName\n *     }\n *\n *     // this is invoked after coroutine has suspended on current thread\n *     override fun restoreThreadContext(context: CoroutineContext, oldState: String) {\n *         Thread.currentThread().name = oldState\n *     }\n * }\n *\n * // Usage\n * launch(Dispatchers.Main + CoroutineName(\"Progress bar coroutine\")) { ... }\n * ```\n *\n * Every time this coroutine is resumed on a thread, UI thread name is updated to\n * \"UI thread original name # Progress bar coroutine\" and the thread name is restored to the original one when\n * this coroutine suspends.\n *\n * To use [ThreadLocal] variable within the coroutine use [ThreadLocal.asContextElement][asContextElement] function.\n *\n * ### Reentrancy and thread-safety\n *\n * Correct implementations of this interface must expect that calls to [restoreThreadContext]\n * may happen in parallel to the subsequent [updateThreadContext] and [restoreThreadContext] operations.\n * See [CopyableThreadContextElement] for advanced interleaving details.\n *\n * All implementations of [ThreadContextElement] should be thread-safe and guard their internal mutable state\n * within an element accordingly.\n */\npublic interface ThreadContextElement<S> : CoroutineContext.Element {\n    /**\n     * Updates context of the current thread.\n     * This function is invoked before the coroutine in the specified [context] is resumed in the current thread\n     * when the context of the coroutine this element.\n     * The result of this function is the old value of the thread-local state that will be passed to [restoreThreadContext].\n     * This method should handle its own exceptions and do not rethrow it. Thrown exceptions will leave coroutine which\n     * context is updated in an undefined state and may crash an application.\n     *\n     * @param context the coroutine context.\n     */\n    public fun updateThreadContext(context: CoroutineContext): S\n\n    /**\n     * Restores context of the current thread.\n     * This function is invoked after the coroutine in the specified [context] is suspended in the current thread\n     * if [updateThreadContext] was previously invoked on resume of this coroutine.\n     * The value of [oldState] is the result of the previous invocation of [updateThreadContext] and it should\n     * be restored in the thread-local state by this function.\n     * This method should handle its own exceptions and do not rethrow it. Thrown exceptions will leave coroutine which\n     * context is updated in an undefined state and may crash an application.\n     *\n     * @param context the coroutine context.\n     * @param oldState the value returned by the previous invocation of [updateThreadContext].\n     */\n    public fun restoreThreadContext(context: CoroutineContext, oldState: S)\n}\n\n/**\n * A [ThreadContextElement] copied whenever a child coroutine inherits a context containing it.\n *\n * When an API uses a _mutable_ [ThreadLocal] for consistency, a [CopyableThreadContextElement]\n * can give coroutines \"coroutine-safe\" write access to that `ThreadLocal`.\n *\n * A write made to a `ThreadLocal` with a matching [CopyableThreadContextElement] by a coroutine\n * will be visible to _itself_ and any child coroutine launched _after_ that write.\n *\n * Writes will not be visible to the parent coroutine, peer coroutines, or coroutines that happen\n * to use the same thread. Writes made to the `ThreadLocal` by the parent coroutine _after_\n * launching a child coroutine will not be visible to that child coroutine.\n *\n * This can be used to allow a coroutine to use a mutable ThreadLocal API transparently and\n * correctly, regardless of the coroutine's structured concurrency.\n *\n * This example adapts a `ThreadLocal` method trace to be \"coroutine local\" while the method trace\n * is in a coroutine:\n *\n * ```\n * class TraceContextElement(private val traceData: TraceData?) : CopyableThreadContextElement<TraceData?> {\n *     companion object Key : CoroutineContext.Key<TraceContextElement>\n *\n *     override val key: CoroutineContext.Key<TraceContextElement> = Key\n *\n *     override fun updateThreadContext(context: CoroutineContext): TraceData? {\n *         val oldState = traceThreadLocal.get()\n *         traceThreadLocal.set(traceData)\n *         return oldState\n *     }\n *\n *     override fun restoreThreadContext(context: CoroutineContext, oldState: TraceData?) {\n *         traceThreadLocal.set(oldState)\n *     }\n *\n *     override fun copyForChild(): TraceContextElement {\n *         // Copy from the ThreadLocal source of truth at child coroutine launch time. This makes\n *         // ThreadLocal writes between resumption of the parent coroutine and the launch of the\n *         // child coroutine visible to the child.\n *         return TraceContextElement(traceThreadLocal.get()?.copy())\n *     }\n *\n *     override fun mergeForChild(overwritingElement: CoroutineContext.Element): CoroutineContext {\n *         // Merge operation defines how to handle situations when both\n *         // the parent coroutine has an element in the context and\n *         // an element with the same key was also\n *         // explicitly passed to the child coroutine.\n *         // If merging does not require special behavior,\n *         // the copy of the element can be returned.\n *         return TraceContextElement(traceThreadLocal.get()?.copy())\n *     }\n * }\n * ```\n *\n * A coroutine using this mechanism can safely call Java code that assumes the corresponding thread local element's\n * value is installed into the target thread local.\n *\n * ### Reentrancy and thread-safety\n *\n * Correct implementations of this interface must expect that calls to [restoreThreadContext]\n * may happen in parallel to the subsequent [updateThreadContext] and [restoreThreadContext] operations.\n *\n * Even though an element is copied for each child coroutine, an implementation should be able to handle the following\n * interleaving when a coroutine with the corresponding element is launched on a multithreaded dispatcher:\n *\n * ```\n * coroutine.updateThreadContext() // Thread #1\n * ... coroutine body ...\n * // suspension + immediate dispatch happen here\n * coroutine.updateThreadContext() // Thread #2, coroutine is already resumed\n * // ... coroutine body after suspension point on Thread #2 ...\n * coroutine.restoreThreadContext() // Thread #1, is invoked late because Thread #1 is slow\n * coroutine.restoreThreadContext() // Thread #2, may happen in parallel with the previous restore\n * ```\n *\n * All implementations of [CopyableThreadContextElement] should be thread-safe and guard their internal mutable state\n * within an element accordingly.\n */\n@DelicateCoroutinesApi\n@ExperimentalCoroutinesApi\npublic interface CopyableThreadContextElement<S> : ThreadContextElement<S> {\n\n    /**\n     * Returns a [CopyableThreadContextElement] to replace `this` `CopyableThreadContextElement` in the child\n     * coroutine's context that is under construction if the added context does not contain an element with the same [key].\n     *\n     * This function is called on the element each time a new coroutine inherits a context containing it,\n     * and the returned value is folded into the context given to the child.\n     *\n     * Since this method is called whenever a new coroutine is launched in a context containing this\n     * [CopyableThreadContextElement], implementations are performance-sensitive.\n     */\n    public fun copyForChild(): CopyableThreadContextElement<S>\n\n    /**\n     * Returns a [CopyableThreadContextElement] to replace `this` `CopyableThreadContextElement` in the child\n     * coroutine's context that is under construction if the added context does contain an element with the same [key].\n     *\n     * This method is invoked on the original element, accepting as the parameter\n     * the element that is supposed to overwrite it.\n     */\n    public fun mergeForChild(overwritingElement: CoroutineContext.Element): CoroutineContext\n}\n\n/**\n * Wraps [ThreadLocal] into [ThreadContextElement]. The resulting [ThreadContextElement]\n * maintains the given [value] of the given [ThreadLocal] for coroutine regardless of the actual thread its is resumed on.\n * By default [ThreadLocal.get] is used as a value for the thread-local variable, but it can be overridden with [value] parameter.\n * Beware that context element **does not track** modifications of the thread-local and accessing thread-local from coroutine\n * without the corresponding context element returns **undefined** value. See the examples for a detailed description.\n *\n *\n * Example usage:\n * ```\n * val myThreadLocal = ThreadLocal<String?>()\n * ...\n * println(myThreadLocal.get()) // Prints \"null\"\n * launch(Dispatchers.Default + myThreadLocal.asContextElement(value = \"foo\")) {\n *   println(myThreadLocal.get()) // Prints \"foo\"\n *   withContext(Dispatchers.Main) {\n *     println(myThreadLocal.get()) // Prints \"foo\", but it's on UI thread\n *   }\n * }\n * println(myThreadLocal.get()) // Prints \"null\"\n * ```\n *\n * The context element does not track modifications of the thread-local variable, for example:\n *\n * ```\n * myThreadLocal.set(\"main\")\n * withContext(Dispatchers.Main) {\n *   println(myThreadLocal.get()) // Prints \"main\"\n *   myThreadLocal.set(\"UI\")\n * }\n * println(myThreadLocal.get()) // Prints \"main\", not \"UI\"\n * ```\n *\n * Use `withContext` to update the corresponding thread-local variable to a different value, for example:\n * ```\n * withContext(myThreadLocal.asContextElement(\"foo\")) {\n *     println(myThreadLocal.get()) // Prints \"foo\"\n * }\n * ```\n *\n * Accessing the thread-local without corresponding context element leads to undefined value:\n * ```\n * val tl = ThreadLocal.withInitial { \"initial\" }\n *\n * runBlocking {\n *   println(tl.get()) // Will print \"initial\"\n *   // Change context\n *   withContext(tl.asContextElement(\"modified\")) {\n *     println(tl.get()) // Will print \"modified\"\n *   }\n *   // Context is changed again\n *    println(tl.get()) // <- WARN: can print either \"modified\" or \"initial\"\n * }\n * ```\n * to fix this behaviour use `runBlocking(tl.asContextElement())`\n */\npublic fun <T> ThreadLocal<T>.asContextElement(value: T = get()): ThreadContextElement<T> =\n    ThreadLocalElement(value, this)\n\n/**\n * Return `true` when current thread local is present in the coroutine context, `false` otherwise.\n * Thread local can be present in the context only if it was added via [asContextElement] to the context.\n *\n * Example of usage:\n * ```\n * suspend fun processRequest() {\n *   if (traceCurrentRequestThreadLocal.isPresent()) { // Probabilistic tracing\n *      // Do some heavy-weight tracing\n *   }\n *   // Process request regularly\n * }\n * ```\n */\npublic suspend inline fun ThreadLocal<*>.isPresent(): Boolean = coroutineContext[ThreadLocalKey(this)] !== null\n\n/**\n * Checks whether current thread local is present in the coroutine context and throws [IllegalStateException] if it is not.\n * It is a good practice to validate that thread local is present in the context, especially in large code-bases,\n * to avoid stale thread-local values and to have a strict invariants.\n *\n * E.g. one may use the following method to enforce proper use of the thread locals with coroutines:\n * ```\n * public suspend inline fun <T> ThreadLocal<T>.getSafely(): T {\n *   ensurePresent()\n *   return get()\n * }\n *\n * // Usage\n * withContext(...) {\n *   val value = threadLocal.getSafely() // Fail-fast in case of improper context\n * }\n * ```\n */\npublic suspend inline fun ThreadLocal<*>.ensurePresent(): Unit =\n    check(isPresent()) { \"ThreadLocal $this is missing from context $coroutineContext\" }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/ThreadPoolDispatcher.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"ThreadPoolDispatcherKt\")\npackage kotlinx.coroutines\n\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.AtomicInteger\n\n@DelicateCoroutinesApi\npublic actual fun newFixedThreadPoolContext(nThreads: Int, name: String): ExecutorCoroutineDispatcher {\n    require(nThreads >= 1) { \"Expected at least one thread, but $nThreads specified\" }\n    val threadNo = AtomicInteger()\n    val executor = Executors.newScheduledThreadPool(nThreads) { runnable ->\n        val t = Thread(runnable, if (nThreads == 1) name else name + \"-\" + threadNo.incrementAndGet())\n        t.isDaemon = true\n        t\n    }\n    return executor.asCoroutineDispatcher()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/channels/Actor.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.intrinsics.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n/**\n * Scope for [actor][GlobalScope.actor] coroutine builder.\n *\n * **Note: This API will become obsolete in future updates with introduction of complex actors.**\n *           See [issue #87](https://github.com/Kotlin/kotlinx.coroutines/issues/87).\n */\n@ObsoleteCoroutinesApi\npublic interface ActorScope<E> : CoroutineScope, ReceiveChannel<E> {\n    /**\n     * A reference to the mailbox channel that this coroutine [receives][receive] messages from.\n     * It is provided for convenience, so that the code in the coroutine can refer\n     * to the channel as `channel` as apposed to `this`.\n     * All the [ReceiveChannel] functions on this interface delegate to\n     * the channel instance returned by this function.\n     */\n    public val channel: Channel<E>\n}\n\n/**\n * Launches new coroutine that is receiving messages from its mailbox channel\n * and returns a reference to its mailbox channel as a [SendChannel]. The resulting\n * object can be used to [send][SendChannel.send] messages to this coroutine.\n *\n * The scope of the coroutine contains [ActorScope] interface, which implements\n * both [CoroutineScope] and [ReceiveChannel], so that coroutine can invoke\n * [receive][ReceiveChannel.receive] directly. The channel is [closed][SendChannel.close]\n * when the coroutine completes.\n *\n * Coroutine context is inherited from a [CoroutineScope], additional context elements can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * The parent job is inherited from a [CoroutineScope] as well, but it can also be overridden\n * with corresponding [context] element.\n *\n * By default, the coroutine is immediately scheduled for execution.\n * Other options can be specified via `start` parameter. See [CoroutineStart] for details.\n * An optional [start] parameter can be set to [CoroutineStart.LAZY] to start coroutine _lazily_. In this case,\n * it will be started implicitly on the first message\n * [sent][SendChannel.send] to this actors's mailbox channel.\n *\n * Uncaught exceptions in this coroutine close the channel with this exception as a cause and\n * the resulting channel becomes _failed_, so that any attempt to send to such a channel throws exception.\n *\n * The kind of the resulting channel depends on the specified [capacity] parameter.\n * See [Channel] interface documentation for details.\n *\n * See [newCoroutineContext][CoroutineScope.newCoroutineContext] for a description of debugging facilities that are available for newly created coroutine.\n *\n * ### Using actors\n *\n * A typical usage of the actor builder looks like this:\n *\n * ```\n * val c = actor {\n *     // initialize actor's state\n *     for (msg in channel) {\n *         // process message here\n *     }\n * }\n * // send messages to the actor\n * c.send(...)\n * ...\n * // stop the actor when it is no longer needed\n * c.close()\n * ```\n *\n * ### Stopping and cancelling actors\n *\n * When the inbox channel of the actor is [closed][SendChannel.close] it sends a special \"close token\" to the actor.\n * The actor still processes all the messages that were already sent and then \"`for (msg in channel)`\" loop terminates\n * and the actor completes.\n *\n * If the actor needs to be aborted without processing all the messages that were already sent to it, then\n * it shall be created with a parent job:\n *\n * ```\n * val job = Job()\n * val c = actor(context = job) {  ... }\n * ...\n * // abort the actor\n * job.cancel()\n * ```\n *\n * When actor's parent job is [cancelled][Job.cancel], then actor's job becomes cancelled. It means that\n * \"`for (msg in channel)`\" and other cancellable suspending functions throw [CancellationException] and actor\n * completes without processing remaining messages.\n *\n * **Note: This API will become obsolete in future updates with introduction of complex actors.**\n *           See [issue #87](https://github.com/Kotlin/kotlinx.coroutines/issues/87).\n *\n * @param context additional to [CoroutineScope.coroutineContext] context of the coroutine.\n * @param capacity capacity of the channel's buffer (no buffer by default).\n * @param start coroutine start option. The default value is [CoroutineStart.DEFAULT].\n * @param onCompletion optional completion handler for the actor coroutine (see [Job.invokeOnCompletion])\n * @param block the coroutine code.\n */\n@ObsoleteCoroutinesApi\npublic fun <E> CoroutineScope.actor(\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = 0, // todo: Maybe Channel.DEFAULT here?\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    onCompletion: CompletionHandler? = null,\n    block: suspend ActorScope<E>.() -> Unit\n): SendChannel<E> {\n    val newContext = newCoroutineContext(context)\n    val channel = Channel<E>(capacity)\n    val coroutine = if (start.isLazy)\n        LazyActorCoroutine(newContext, channel, block) else\n        ActorCoroutine(newContext, channel, active = true)\n    if (onCompletion != null) coroutine.invokeOnCompletion(handler = onCompletion)\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n\nprivate open class ActorCoroutine<E>(\n    parentContext: CoroutineContext,\n    channel: Channel<E>,\n    active: Boolean\n) : ChannelCoroutine<E>(parentContext, channel, initParentJob = false, active = active), ActorScope<E> {\n\n    init {\n        initParentJob(parentContext[Job])\n    }\n\n    override fun onCancelling(cause: Throwable?) {\n        _channel.cancel(cause?.let {\n            it as? CancellationException ?: CancellationException(\"$classSimpleName was cancelled\", it)\n        })\n    }\n\n    override fun handleJobException(exception: Throwable): Boolean {\n        handleCoroutineException(context, exception)\n        return true\n    }\n}\n\nprivate class LazyActorCoroutine<E>(\n    parentContext: CoroutineContext,\n    channel: Channel<E>,\n    block: suspend ActorScope<E>.() -> Unit\n) : ActorCoroutine<E>(parentContext, channel, active = false) {\n\n    private var continuation = block.createCoroutineUnintercepted(this, this)\n\n    override fun onStart() {\n        continuation.startCoroutineCancellable(this)\n    }\n\n    override suspend fun send(element: E) {\n        start()\n        return super.send(element)\n    }\n\n    @Suppress(\"DEPRECATION_ERROR\")\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message = \"Deprecated in the favour of 'trySend' method\",\n        replaceWith = ReplaceWith(\"trySend(element).isSuccess\")\n    ) // See super()\n    override fun offer(element: E): Boolean {\n        start()\n        return super.offer(element)\n    }\n\n    override fun trySend(element: E): ChannelResult<Unit> {\n        start()\n        return super.trySend(element)\n    }\n\n    @Suppress(\"MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_DEPRECATION_WARNING\") // do not remove the MULTIPLE_DEFAULTS suppression: required in K2\n    override fun close(cause: Throwable?): Boolean {\n        // close the channel _first_\n        val closed = super.close(cause)\n        // then start the coroutine (it will promptly fail if it was not started yet)\n        start()\n        return closed\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override val onSend: SelectClause2<E, SendChannel<E>> get() = SelectClause2Impl(\n        clauseObject = this,\n        regFunc = LazyActorCoroutine<*>::onSendRegFunction as RegistrationFunction,\n        processResFunc = super.onSend.processResFunc\n    )\n\n    private fun onSendRegFunction(select: SelectInstance<*>, element: Any?) {\n        onStart()\n        super.onSend.regFunc(this, select, element)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/channels/TickerChannels.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Mode for [ticker] function.\n *\n * **Note: Ticker channels are not currently integrated with structured concurrency and their api will change in the future.**\n */\n@ObsoleteCoroutinesApi\npublic enum class TickerMode {\n    /**\n     * Adjust delay to maintain fixed period if consumer cannot keep up or is otherwise slow.\n     * **This is a default mode.**\n     *\n     * ```\n     * val channel = ticker(delay = 100)\n     * delay(350) // 250 ms late\n     * println(channel.tryReceive().getOrNull()) // prints Unit\n     * println(channel.tryReceive().getOrNull()) // prints null\n     *\n     * delay(50)\n     * println(channel.tryReceive().getOrNull()) // prints Unit, delay was adjusted\n     * delay(50)\n     * println(channel.tryReceive().getOrNull()) // prints null, we're not late relatively to previous element\n     * ```\n     */\n    FIXED_PERIOD,\n\n    /**\n     * Maintains fixed delay between produced elements if consumer cannot keep up or it otherwise slow.\n     */\n    FIXED_DELAY\n}\n\n/**\n * Creates a channel that produces the first item after the given initial delay and subsequent items with the\n * given delay between them.\n *\n * The resulting channel is a _rendezvous channel_. When receiver from this channel does not keep\n * up with receiving the elements from this channel, they are not being sent due to backpressure. The actual\n * timing behavior of ticker in this case is controlled by [mode] parameter which\n * is set to [TickerMode.FIXED_PERIOD] by default. See [TickerMode] for other details.\n *\n * This channel stops producing elements immediately after [ReceiveChannel.cancel] invocation.\n *\n * **Note** producer to this channel is dispatched via [Dispatchers.Unconfined] by default and started eagerly.\n *\n * **Note: Ticker channels are not currently integrated with structured concurrency and their api will change in the future.**\n *           \n * @param delayMillis delay between each element in milliseconds.\n * @param initialDelayMillis delay after which the first element will be produced (it is equal to [delayMillis] by default) in milliseconds.\n * @param context context of the producing coroutine.\n * @param mode specifies behavior when elements are not received ([FIXED_PERIOD][TickerMode.FIXED_PERIOD] by default).\n */\n@ObsoleteCoroutinesApi\npublic fun ticker(\n    delayMillis: Long,\n    initialDelayMillis: Long = delayMillis,\n    context: CoroutineContext = EmptyCoroutineContext,\n    mode: TickerMode = TickerMode.FIXED_PERIOD\n): ReceiveChannel<Unit> {\n    require(delayMillis >= 0) { \"Expected non-negative delay, but has $delayMillis ms\" }\n    require(initialDelayMillis >= 0) { \"Expected non-negative initial delay, but has $initialDelayMillis ms\" }\n    return GlobalScope.produce(Dispatchers.Unconfined + context, capacity = 0) {\n        when (mode) {\n            TickerMode.FIXED_PERIOD -> fixedPeriodTicker(delayMillis, initialDelayMillis, channel)\n            TickerMode.FIXED_DELAY -> fixedDelayTicker(delayMillis, initialDelayMillis, channel)\n        }\n    }\n}\n\nprivate suspend fun fixedPeriodTicker(\n    delayMillis: Long,\n    initialDelayMillis: Long,\n    channel: SendChannel<Unit>\n) {\n    var deadline = nanoTime() + delayToNanos(initialDelayMillis)\n    delay(initialDelayMillis)\n    val delayNs = delayToNanos(delayMillis)\n    while (true) {\n        deadline += delayNs\n        channel.send(Unit)\n        val now = nanoTime()\n        val nextDelay = (deadline - now).coerceAtLeast(0)\n        if (nextDelay == 0L && delayNs != 0L) {\n            val adjustedDelay = delayNs - (now - deadline) % delayNs\n            deadline = now + adjustedDelay\n            delay(delayNanosToMillis(adjustedDelay))\n        } else {\n            delay(delayNanosToMillis(nextDelay))\n        }\n    }\n}\n\nprivate suspend fun fixedDelayTicker(\n    delayMillis: Long,\n    initialDelayMillis: Long,\n    channel: SendChannel<Unit>\n) {\n    delay(initialDelayMillis)\n    while (true) {\n        channel.send(Unit)\n        delay(delayMillis)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/AgentPremain.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport android.annotation.*\nimport kotlinx.coroutines.debug.internal.*\nimport org.codehaus.mojo.animal_sniffer.*\nimport sun.misc.*\nimport java.lang.instrument.*\nimport java.lang.instrument.ClassFileTransformer\nimport java.security.*\n\n/*\n * This class is loaded if and only if kotlinx-coroutines-core was used as -javaagent argument,\n * but Android complains anyway (java.lang.instrument.*), so we suppress all lint checks here\n */\n@Suppress(\"unused\")\n@SuppressLint(\"all\")\n@IgnoreJRERequirement // Never touched on Android\ninternal object AgentPremain {\n\n    private val enableCreationStackTraces = runCatching {\n        System.getProperty(\"kotlinx.coroutines.debug.enable.creation.stack.trace\")?.toBoolean()\n    }.getOrNull() ?: DebugProbesImpl.enableCreationStackTraces\n\n    @JvmStatic\n    @Suppress(\"UNUSED_PARAMETER\")\n    fun premain(args: String?, instrumentation: Instrumentation) {\n        AgentInstallationType.isInstalledStatically = true\n        instrumentation.addTransformer(DebugProbesTransformer)\n        DebugProbesImpl.enableCreationStackTraces = enableCreationStackTraces\n        DebugProbesImpl.install()\n        installSignalHandler()\n    }\n\n    internal object DebugProbesTransformer : ClassFileTransformer {\n        override fun transform(\n            loader: ClassLoader?,\n            className: String,\n            classBeingRedefined: Class<*>?,\n            protectionDomain: ProtectionDomain,\n            classfileBuffer: ByteArray?\n        ): ByteArray? {\n            if (loader == null || className != \"kotlin/coroutines/jvm/internal/DebugProbesKt\") {\n               return null\n            }\n            /*\n             * DebugProbesKt.bin contains `kotlin.coroutines.jvm.internal.DebugProbesKt` class\n             * with method bodies that delegate all calls directly to their counterparts in\n             * kotlinx.coroutines.debug.DebugProbesImpl. This is done to avoid classfile patching\n             * on the fly (-> get rid of ASM dependency).\n             * You can verify its content either by using javap on it or looking at out integration test module.\n             */\n            AgentInstallationType.isInstalledStatically = true\n            return loader.getResourceAsStream(\"DebugProbesKt.bin\").readBytes()\n        }\n    }\n\n    private fun installSignalHandler() {\n        try {\n            Signal.handle(Signal(\"TRAP\")) { // kill -5\n                if (DebugProbesImpl.isInstalled) {\n                    // Case with 'isInstalled' changed between this check-and-act is not considered\n                    // a real debug probes use-case, thus is not guarded against.\n                    DebugProbesImpl.dumpCoroutines(System.out)\n                } else {\n                    println(\"Cannot perform coroutines dump, debug probes are disabled\")\n                }\n            }\n        } catch (t: Throwable) {\n            // Do nothing, signal cannot be installed, e.g. because we are on Windows\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/CoroutineDebugging.kt",
        "content": "/* This package name is like this so that\n1) the artificial stack frames look pretty, and\n2) the IDE reliably navigates to this file. */\npackage _COROUTINE\n\n/**\n * A collection of artificial stack trace elements to be included in stack traces by the coroutines machinery.\n *\n * There are typically two ways in which one can encounter an artificial stack frame:\n * 1. By using the debug mode, via the stacktrace recovery mechanism; see\n * [stacktrace recovery](https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/topics/debugging.md#stacktrace-recovery)\n * documentation. The usual way to enable the debug mode is with the [kotlinx.coroutines.DEBUG_PROPERTY_NAME] system\n * property.\n * 2. By looking at the output of DebugProbes; see the\n * [kotlinx-coroutines-debug](https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-debug) module.\n */\ninternal class ArtificialStackFrames {\n    /**\n     * Returns an artificial stack trace element denoting the boundary between coroutine creation and its execution.\n     *\n     * Appearance of this function in stack traces does not mean that it was called. Instead, it is used as a marker\n     * that separates the part of the stack trace with the code executed in a coroutine from the stack trace of the code\n     * that launched the coroutine.\n     *\n     * In earlier versions of kotlinx-coroutines, this was displayed as \"(Coroutine creation stacktrace)\", which caused\n     * problems for tooling that processes stack traces: https://github.com/Kotlin/kotlinx.coroutines/issues/2291\n     *\n     * Note that presence of this marker in a stack trace implies that coroutine creation stack traces were enabled.\n     */\n    fun coroutineCreation(): StackTraceElement = Exception().artificialFrame(_CREATION::class.java.simpleName)\n\n    /**\n     * Returns an artificial stack trace element denoting a coroutine boundary.\n     *\n     * Appearance of this function in stack traces does not mean that it was called. Instead, when one coroutine invokes\n     * another, this is used as a marker in the stack trace to denote where the execution of one coroutine ends and that\n     * of another begins.\n     *\n     * In earlier versions of kotlinx-coroutines, this was displayed as \"(Coroutine boundary)\", which caused\n     * problems for tooling that processes stack traces: https://github.com/Kotlin/kotlinx.coroutines/issues/2291\n     */\n    fun coroutineBoundary(): StackTraceElement = Exception().artificialFrame(_BOUNDARY::class.java.simpleName)\n}\n\n// These are needed for the IDE navigation to detect that this file does contain the definition.\nprivate class _CREATION\nprivate class _BOUNDARY\n\ninternal val ARTIFICIAL_FRAME_PACKAGE_NAME = \"_COROUTINE\"\n\n/**\n * Forms an artificial stack frame with the given class name.\n *\n * It consists of the following parts:\n * 1. The package name, it seems, is needed for the IDE to detect stack trace elements reliably. It is `_COROUTINE` since\n * this is a valid identifier.\n * 2. Class names represents what type of artificial frame this is.\n * 3. The method name is `_`. The methods not being present in class definitions does not seem to affect navigation.\n */\nprivate fun Throwable.artificialFrame(name: String): StackTraceElement =\n    with(stackTrace[0]) { StackTraceElement(ARTIFICIAL_FRAME_PACKAGE_NAME + \".\" + name, \"_\", fileName, lineNumber) }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/internal/AgentInstallationType.kt",
        "content": "package kotlinx.coroutines.debug.internal\n\n/**\n * Object used to differentiate between agent installed statically or dynamically.\n * This is done in a separate object so [DebugProbesImpl] can check for static installation\n * without having to depend on [kotlinx.coroutines.debug.AgentPremain], which is not compatible with Android.\n * Otherwise, access to `AgentPremain.isInstalledStatically` triggers the load of its internal `ClassFileTransformer`\n * that is not available on Android.\n */\ninternal object AgentInstallationType {\n    internal var isInstalledStatically = false\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/internal/ConcurrentWeakMap.kt",
        "content": "package kotlinx.coroutines.debug.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.internal.*\nimport java.lang.ref.*\n\n// This is very limited implementation, not suitable as a generic map replacement.\n// It has lock-free get and put with synchronized rehash for simplicity (and better CPU usage on contention)\n@Suppress(\"UNCHECKED_CAST\")\ninternal class ConcurrentWeakMap<K : Any, V: Any>(\n    /**\n     * Weak reference queue is needed when a small key is mapped to a large value, and we need to promptly release a\n     * reference to the value when the key was already disposed.\n     */\n    weakRefQueue: Boolean = false\n) : AbstractMutableMap<K, V>() {\n    private val _size = atomic(0)\n    private val core = atomic(Core(MIN_CAPACITY))\n    private val weakRefQueue: ReferenceQueue<K>? = if (weakRefQueue) ReferenceQueue() else null\n\n    override val size: Int\n        get() = _size.value\n\n    private fun decrementSize() { _size.decrementAndGet() }\n\n    override fun get(key: K): V? = core.value.getImpl(key)\n\n    override fun put(key: K, value: V): V? {\n        var oldValue = core.value.putImpl(key, value)\n        if (oldValue === REHASH) oldValue = putSynchronized(key, value)\n        if (oldValue == null) _size.incrementAndGet()\n        return oldValue as V?\n    }\n\n    override fun remove(key: K): V? {\n        var oldValue = core.value.putImpl(key, null)\n        if (oldValue === REHASH) oldValue = putSynchronized(key, null)\n        if (oldValue != null) _size.decrementAndGet()\n        return oldValue as V?\n    }\n\n    @Synchronized\n    private fun putSynchronized(key: K, value: V?): V? {\n        // Note: concurrent put leaves chance that we fail to put even after rehash, we retry until successful\n        var curCore = core.value\n        while (true) {\n            val oldValue = curCore.putImpl(key, value)\n            if (oldValue !== REHASH) return oldValue as V?\n            curCore = curCore.rehash()\n            core.value = curCore\n        }\n    }\n\n    override val keys: MutableSet<K>\n        get() = KeyValueSet { k, _ -> k }\n\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() = KeyValueSet { k, v -> Entry(k, v) }\n\n    // We don't care much about clear's efficiency\n    override fun clear() {\n        for (k in keys) remove(k)\n    }\n\n    fun runWeakRefQueueCleaningLoopUntilInterrupted() {\n        check(weakRefQueue != null) { \"Must be created with weakRefQueue = true\" }\n        try {\n            while (true) {\n                cleanWeakRef(weakRefQueue.remove() as HashedWeakRef<*>)\n            }\n        } catch (e: InterruptedException) {\n            Thread.currentThread().interrupt()\n        }\n    }\n\n    private fun cleanWeakRef(w: HashedWeakRef<*>) {\n        core.value.cleanWeakRef(w)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private inner class Core(private val allocated: Int) {\n        private val shift = allocated.countLeadingZeroBits() + 1\n        private val threshold = 2 * allocated / 3 // max fill factor at 66% to ensure speedy lookups\n        private val load = atomic(0) // counts how many slots are occupied in this core\n        private val keys = atomicArrayOfNulls<HashedWeakRef<K>?>(allocated)\n        private val values = atomicArrayOfNulls<Any?>(allocated)\n\n        private fun index(hash: Int) = (hash * MAGIC) ushr shift\n\n        // get is always lock-free, unwraps the value that was marked by concurrent rehash\n        fun getImpl(key: K): V? {\n            var index = index(key.hashCode())\n            while (true) {\n                val w = keys[index].value ?: return null // not found\n                val k = w.get()\n                if (key == k) {\n                    val value = values[index].value\n                    return (if (value is Marked) value.ref else value) as V?\n                }\n                if (k == null) removeCleanedAt(index) // weak ref was here, but collected\n                if (index == 0) index = allocated\n                index--\n            }\n        }\n\n        private fun removeCleanedAt(index: Int) {\n            while (true) {\n                val oldValue = values[index].value ?: return // return when already removed\n                if (oldValue is Marked) return // cannot remove marked (rehash is working on it, will not copy)\n                if (values[index].compareAndSet(oldValue, null)) { // removed\n                    decrementSize()\n                    return\n                }\n            }\n        }\n\n        // returns REHASH when rehash is needed (the value was not put)\n        fun putImpl(key: K, value: V?, weakKey0: HashedWeakRef<K>? = null): Any? {\n            var index = index(key.hashCode())\n            var loadIncremented = false\n            var weakKey: HashedWeakRef<K>? = weakKey0\n            while (true) {\n                val w = keys[index].value\n                if (w == null) { // slot empty => not found => try reserving slot\n                    if (value == null) return null // removing missing value, nothing to do here\n                    if (!loadIncremented) {\n                        // We must increment load before we even try to occupy a slot to avoid overfill during concurrent put\n                        load.update { n ->\n                            if (n >= threshold) return REHASH // the load is already too big -- rehash\n                            n + 1 // otherwise increment\n                        }\n                        loadIncremented = true\n                    }\n                    if (weakKey == null) weakKey = HashedWeakRef(key, weakRefQueue)\n                    if (keys[index].compareAndSet(null, weakKey)) break // slot reserved !!!\n                    continue // retry at this slot on CAS failure (somebody already reserved this slot)\n                }\n                val k = w.get()\n                if (key == k) { // found already reserved slot at index\n                    if (loadIncremented) load.decrementAndGet() // undo increment, because found a slot\n                    break\n                }\n                if (k == null) removeCleanedAt(index) // weak ref was here, but collected\n                if (index == 0) index = allocated\n                index--\n            }\n            // update value\n            var oldValue: Any?\n            while (true) {\n                oldValue = values[index].value\n                if (oldValue is Marked) return REHASH // rehash started, cannot work here\n                if (values[index].compareAndSet(oldValue, value)) break\n            }\n            return oldValue as V?\n        }\n\n        // only one thread can rehash, but may have concurrent puts/gets\n        fun rehash(): Core {\n            // use size to approximate new required capacity to have at least 25-50% fill factor,\n            // may fail due to concurrent modification, will retry\n            retry@while (true) {\n                val newCapacity = size.coerceAtLeast(MIN_CAPACITY / 4).takeHighestOneBit() * 4\n                val newCore = Core(newCapacity)\n                for (index in 0 until allocated) {\n                    // load the key\n                    val w = keys[index].value\n                    val k = w?.get()\n                    if (w != null && k == null) removeCleanedAt(index) // weak ref was here, but collected\n                    // mark value so that it cannot be changed while we rehash to new core\n                    var value: Any?\n                    while (true) {\n                        value = values[index].value\n                        if (value is Marked) { // already marked -- good\n                            value = value.ref\n                            break\n                        }\n                        // try mark\n                        if (values[index].compareAndSet(value, value.mark())) break\n                    }\n                    if (k != null && value != null) {\n                        val oldValue = newCore.putImpl(k, value as V, w)\n                        if (oldValue === REHASH) continue@retry // retry if we underestimated capacity\n                        assert(oldValue == null)\n                    }\n                }\n                return newCore // rehashed everything successfully\n            }\n        }\n\n        fun cleanWeakRef(weakRef: HashedWeakRef<*>) {\n            var index = index(weakRef.hash)\n            while (true) {\n                val w = keys[index].value ?: return // return when slots are over\n                if (w === weakRef) { // found\n                    removeCleanedAt(index)\n                    return\n                }\n                if (index == 0) index = allocated\n                index--\n            }\n        }\n\n        fun <E> keyValueIterator(factory: (K, V) -> E): MutableIterator<E> = KeyValueIterator(factory)\n\n        private inner class KeyValueIterator<E>(private val factory: (K, V) -> E) : MutableIterator<E> {\n            private var index = -1\n            private lateinit var key: K\n            private lateinit var value: V\n\n            init { findNext() }\n\n            private fun findNext() {\n                while (++index < allocated) {\n                    key = keys[index].value?.get() ?: continue\n                    var value = values[index].value\n                    if (value is Marked) value = value.ref\n                    if (value != null) {\n                        this.value = value as V\n                        return\n                    }\n                }\n            }\n\n            override fun hasNext(): Boolean = index < allocated\n\n            override fun next(): E {\n                if (index >= allocated) throw NoSuchElementException()\n                return factory(key, value).also { findNext() }\n            }\n\n            override fun remove() = noImpl()\n        }\n    }\n\n    private class Entry<K, V>(override val key: K, override val value: V) : MutableMap.MutableEntry<K, V> {\n        override fun setValue(newValue: V): V = noImpl()\n    }\n\n    private inner class KeyValueSet<E>(\n        private val factory: (K, V) -> E\n    ) : AbstractMutableSet<E>() {\n        override val size: Int get() = this@ConcurrentWeakMap.size\n        override fun add(element: E): Boolean = noImpl()\n        override fun iterator(): MutableIterator<E> = core.value.keyValueIterator(factory)\n    }\n}\n\nprivate const val MAGIC = 2654435769L.toInt() // golden ratio\nprivate const val MIN_CAPACITY = 16\nprivate val REHASH = Symbol(\"REHASH\")\nprivate val MARKED_NULL = Marked(null)\nprivate val MARKED_TRUE = Marked(true) // When using map as set \"true\" used as value, optimize its mark allocation\n\n/**\n * Weak reference that stores the original hash code so that we can use reference queue to promptly clean them up\n * from the hashtable even in the absence of ongoing modifications.\n */\ninternal class HashedWeakRef<T>(\n    ref: T, queue: ReferenceQueue<T>?\n) : WeakReference<T>(ref, queue) {\n    @JvmField\n    val hash = ref.hashCode()\n}\n\n/**\n * Marked values cannot be modified. The marking is performed when rehash has started to ensure that concurrent\n * modifications (that are lock-free) cannot perform any changes and are forced to synchronize with ongoing rehash.\n */\nprivate class Marked(@JvmField val ref: Any?)\n\nprivate fun Any?.mark(): Marked = when(this) {\n    null -> MARKED_NULL\n    true -> MARKED_TRUE\n    else -> Marked(this)\n}\n\nprivate fun noImpl(): Nothing {\n    throw UnsupportedOperationException(\"not implemented\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/internal/DebugCoroutineInfo.kt",
        "content": "package kotlinx.coroutines.debug.internal\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.jvm.internal.*\n\n/**\n * This class represents the data required by IDEA debugger.\n * IDEA debugger either directly reads data from the corresponding JVM fields of this class or calls the getters,\n * so we keep both for maximal flexibility for now.\n * **DO NOT MAKE BINARY-INCOMPATIBLE CHANGES TO THIS CLASS**.\n */\n@Suppress(\"unused\")\n@PublishedApi\ninternal class DebugCoroutineInfo internal constructor(\n    source: DebugCoroutineInfoImpl,\n    public val context: CoroutineContext // field is used as of 1.4-M3\n) {\n    internal val creationStackBottom: CoroutineStackFrame? = source.creationStackBottom // field is used as of 1.4-M3\n    public val sequenceNumber: Long = source.sequenceNumber // field is used as of 1.4-M3\n    public val creationStackTrace = source.creationStackTrace // getter is used as of 1.4-M3\n    public val state: String = source.state // getter is used as of 1.4-M3\n    public val lastObservedThread: Thread? = source.lastObservedThread // field is used as of 1.4-M3\n    public val lastObservedFrame: CoroutineStackFrame? = source.lastObservedFrame // field is used as of 1.4-M3\n    @get:JvmName(\"lastObservedStackTrace\") // method with this name is used as of 1.4-M3\n    public val lastObservedStackTrace: List<StackTraceElement> = source.lastObservedStackTrace()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/internal/DebugCoroutineInfoImpl.kt",
        "content": "package kotlinx.coroutines.debug.internal\n\nimport java.lang.ref.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.jvm.internal.*\n\ninternal const val CREATED = \"CREATED\"\ninternal const val RUNNING = \"RUNNING\"\ninternal const val SUSPENDED = \"SUSPENDED\"\n\n/**\n * Internal implementation class where debugger tracks details it knows about each coroutine.\n * Its mutable fields can be updated concurrently, thus marked with `@Volatile`\n */\n@PublishedApi\ninternal class DebugCoroutineInfoImpl internal constructor(\n    context: CoroutineContext?,\n    /**\n     * A reference to a stack-trace that is converted to a [StackTraceFrame] which implements [CoroutineStackFrame].\n     * The actual reference to the coroutine is not stored here, so we keep a strong reference.\n     */\n    internal val creationStackBottom: StackTraceFrame?,\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @JvmField public val sequenceNumber: Long\n) {\n    /**\n     * We cannot keep a strong reference to the context, because with the [Job] in the context it will indirectly\n     * keep a reference to the last frame of an abandoned coroutine which the debugger should not be preventing\n     * garbage-collection of. The reference to context will not disappear as long as the coroutine itself is not lost.\n     */\n    private val _context = WeakReference(context)\n    public val context: CoroutineContext? // can be null when the coroutine was already garbage-collected\n        get() = _context.get()\n\n    public val creationStackTrace: List<StackTraceElement> get() = creationStackTrace()\n\n    /**\n     * Last observed state of the coroutine.\n     * Can be CREATED, RUNNING, SUSPENDED.\n     */\n    internal val state: String get() = _state\n\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @Volatile\n    @JvmField\n    public var _state: String = CREATED\n\n    /*\n     * How many consecutive unmatched 'updateState(RESUMED)' this object has received.\n     * It can be `> 1` in two cases:\n     *\n     * - The coroutine is finishing and its state is being unrolled in BaseContinuationImpl, see comment to DebugProbesImpl#callerInfoCache\n     *   Such resumes are not expected to be matched and are ignored.\n     * - We encountered suspend-resume race explained above, and we do wait for a match.\n     */\n    private var unmatchedResume = 0\n\n    /**\n     * Here we orchestrate overlapping state updates that are coming asynchronously.\n     * In a nutshell, `probeCoroutineSuspended` can arrive **later** than its matching `probeCoroutineResumed`,\n     * e.g. for the following code:\n     * ```\n     * suspend fun foo() = yield()\n     * ```\n     *\n     * we have this sequence:\n     * ```\n     * fun foo(...) {\n     *     uCont.intercepted().dispatchUsingDispatcher() // 1\n     *     // Notify the debugger the coroutine is suspended\n     *     probeCoroutineSuspended() // 2\n     *     return COROUTINE_SUSPENDED // Unroll the stack\n     * }\n     * ```\n     * Nothing prevents coroutine to be dispatched and invoke `probeCoroutineResumed` right between '1' and '2'.\n     * See also: https://github.com/Kotlin/kotlinx.coroutines/issues/3193\n     *\n     * [shouldBeMatched] -- `false` if it is an expected consecutive `probeCoroutineResumed` from BaseContinuationImpl,\n     * `true` otherwise.\n     */\n    @Synchronized\n    internal fun updateState(state: String, frame: Continuation<*>, shouldBeMatched: Boolean) {\n        /**\n         * We observe consecutive resume that had to be matched, but it wasn't,\n         * increment\n         */\n        if (_state == RUNNING && state == RUNNING && shouldBeMatched) {\n            ++unmatchedResume\n        } else if (unmatchedResume > 0 && state == SUSPENDED) {\n            /*\n             * We received late 'suspend' probe for unmatched resume, skip it.\n             * Here we deliberately allow the very unlikely race;\n             * Consider the following scenario ('[r:a]' means \"probeCoroutineResumed at a()\"):\n             * ```\n             * [r:a] a() -> b() [s:b] [r:b] -> (back to a) a() -> c() [s:c]\n             * ```\n             * We can, in theory, observe the following probes interleaving:\n             * ```\n             * r:a\n             * r:b // Unmatched resume\n             * s:c // Matched suspend, discard\n             * s:b\n             * ```\n             * Thus mis-attributing 'lastObservedFrame' to a previously-observed.\n             * It is possible in theory (though I've failed to reproduce it), yet\n             * is more preferred than indefinitely mismatched state (-> mismatched real/enhanced stacktrace)\n             */\n            --unmatchedResume\n            return\n        }\n\n        // Propagate only non-duplicating transitions to running, see KT-29997\n        if (_state == state && state == SUSPENDED && lastObservedFrame != null) return\n\n        _state = state\n        lastObservedFrame = frame as? CoroutineStackFrame\n        lastObservedThread = if (state == RUNNING) {\n            Thread.currentThread()\n        } else {\n            null\n        }\n    }\n\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @JvmField\n    @Volatile\n    public var lastObservedThread: Thread? = null\n\n    /**\n     * We cannot keep a strong reference to the last observed frame of the coroutine, because this will\n     * prevent garbage-collection of a coroutine that was lost.\n     *\n     * Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n     */\n    @Volatile\n    @JvmField\n    public var _lastObservedFrame: WeakReference<CoroutineStackFrame>? = null\n    internal var lastObservedFrame: CoroutineStackFrame?\n        get() = _lastObservedFrame?.get()\n        set(value) {\n            _lastObservedFrame = value?.let { WeakReference(it) }\n        }\n\n    /**\n     * Last observed stacktrace of the coroutine captured on its suspension or resumption point.\n     * It means that for [running][State.RUNNING] coroutines resulting stacktrace is inaccurate and\n     * reflects stacktrace of the resumption point, not the actual current stacktrace.\n     */\n    internal fun lastObservedStackTrace(): List<StackTraceElement> {\n        var frame: CoroutineStackFrame? = lastObservedFrame ?: return emptyList()\n        val result = ArrayList<StackTraceElement>()\n        while (frame != null) {\n            frame.getStackTraceElement()?.let { result.add(it) }\n            frame = frame.callerFrame\n        }\n        return result\n    }\n\n    private fun creationStackTrace(): List<StackTraceElement> {\n        val bottom = creationStackBottom ?: return emptyList()\n        // Skip \"Coroutine creation stacktrace\" frame\n        return sequence { yieldFrames(bottom.callerFrame) }.toList()\n    }\n\n    private tailrec suspend fun SequenceScope<StackTraceElement>.yieldFrames(frame: CoroutineStackFrame?) {\n        if (frame == null) return\n        frame.getStackTraceElement()?.let { yield(it) }\n        val caller = frame.callerFrame\n        if (caller != null) {\n            yieldFrames(caller)\n        }\n    }\n\n    override fun toString(): String = \"DebugCoroutineInfo(state=$state,context=$context)\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/internal/DebugProbes.kt",
        "content": "@file:Suppress(\"unused\")\n\npackage kotlinx.coroutines.debug.internal\n\nimport kotlin.coroutines.*\n\n/*\n * This class is used by ByteBuddy from kotlinx-coroutines-debug as kotlin.coroutines.jvm.internal.DebugProbesKt replacement.\n * In theory, it should belong to kotlinx-coroutines-debug, but placing it here significantly simplifies the\n * Android AS debugger that does on-load DEX transformation\n */\n\n// Stubs which are injected as coroutine probes. Require direct match of signatures\ninternal fun probeCoroutineResumed(frame: Continuation<*>) = DebugProbesImpl.probeCoroutineResumed(frame)\n\ninternal fun probeCoroutineSuspended(frame: Continuation<*>) = DebugProbesImpl.probeCoroutineSuspended(frame)\ninternal fun <T> probeCoroutineCreated(completion: Continuation<T>): Continuation<T> =\n    DebugProbesImpl.probeCoroutineCreated(completion)\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/internal/DebugProbesImpl.kt",
        "content": "package kotlinx.coroutines.debug.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.ScopeCoroutine\nimport java.io.*\nimport java.lang.StackTraceElement\nimport java.text.*\nimport java.util.concurrent.locks.*\nimport kotlin.collections.ArrayList\nimport kotlin.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.jvm.internal.CoroutineStackFrame\nimport kotlin.synchronized\nimport _COROUTINE.ArtificialStackFrames\n\n@PublishedApi\ninternal object DebugProbesImpl {\n    private val ARTIFICIAL_FRAME = ArtificialStackFrames().coroutineCreation()\n    private val dateFormat = SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\")\n\n    private var weakRefCleanerThread: Thread? = null\n\n    // Values are boolean, so this map does not need to use a weak reference queue\n    private val capturedCoroutinesMap = ConcurrentWeakMap<CoroutineOwner<*>, Boolean>()\n    private val capturedCoroutines: Set<CoroutineOwner<*>> get() = capturedCoroutinesMap.keys\n\n    private val installations = atomic(0)\n\n    /**\n     * This internal method is used by the IDEA debugger under the JVM name\n     * \"isInstalled$kotlinx_coroutines_debug\" and must be kept binary-compatible, see KTIJ-24102\n     */\n    val isInstalled: Boolean\n        // IDEA depended on \"internal val isInstalled\", thus the mangling. Public + JvmName in order to make this getter part of the ABI\n        @JvmName(\"isInstalled\\$kotlinx_coroutines_debug\")\n        get() = installations.value > 0\n\n    // To sort coroutines by creation order, used as a unique id\n    private val sequenceNumber = atomic(0L)\n\n    internal var sanitizeStackTraces: Boolean = true\n    internal var enableCreationStackTraces: Boolean = false\n    public var ignoreCoroutinesWithEmptyContext: Boolean = true\n\n    /*\n     * Substitute for service loader, DI between core and debug modules.\n     * If the agent was installed via command line -javaagent parameter, do not use byte-buddy to avoid dynamic attach.\n     */\n    private val dynamicAttach = getDynamicAttach()\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun getDynamicAttach(): Function1<Boolean, Unit>? = runCatching {\n        val clz = Class.forName(\"kotlinx.coroutines.debug.internal.ByteBuddyDynamicAttach\")\n        val ctor = clz.constructors[0]\n        ctor.newInstance() as Function1<Boolean, Unit>\n    }.getOrNull()\n\n    /**\n     * Because `probeCoroutinesResumed` is called for every resumed continuation (see KT-29997 and the related code),\n     * we perform a performance optimization:\n     * Imagine a suspending call stack a()->b()->c(), where c() completes its execution and every call is\n     * \"almost\" in tail position.\n     *\n     * Then at least three RUNNING -> RUNNING transitions will occur consecutively, the complexity of each O(depth).\n     * To avoid this quadratic complexity, we are caching lookup result for such chains in this map and update it incrementally.\n     *\n     * [DebugCoroutineInfoImpl] keeps a lot of auxiliary information about a coroutine, so we use a weak reference queue\n     * to promptly release the corresponding memory when the reference to the coroutine itself was already collected.\n     */\n    private val callerInfoCache = ConcurrentWeakMap<CoroutineStackFrame, DebugCoroutineInfoImpl>(weakRefQueue = true)\n\n    internal fun install() {\n        if (installations.incrementAndGet() > 1) return\n        startWeakRefCleanerThread()\n        if (AgentInstallationType.isInstalledStatically) return\n        dynamicAttach?.invoke(true) // attach\n    }\n\n    internal fun uninstall() {\n        check(isInstalled) { \"Agent was not installed\" }\n        if (installations.decrementAndGet() != 0) return\n        stopWeakRefCleanerThread()\n        capturedCoroutinesMap.clear()\n        callerInfoCache.clear()\n        if (AgentInstallationType.isInstalledStatically) return\n        dynamicAttach?.invoke(false) // detach\n    }\n\n    private fun startWeakRefCleanerThread() {\n        weakRefCleanerThread = thread(isDaemon = true, name = \"Coroutines Debugger Cleaner\") {\n            callerInfoCache.runWeakRefQueueCleaningLoopUntilInterrupted()\n        }\n    }\n\n    private fun stopWeakRefCleanerThread() {\n        val thread = weakRefCleanerThread ?: return\n        weakRefCleanerThread = null\n        thread.interrupt()\n        thread.join()\n    }\n\n    internal fun hierarchyToString(job: Job): String {\n        check(isInstalled) { \"Debug probes are not installed\" }\n        val jobToStack = capturedCoroutines\n            .filter { it.delegate.context[Job] != null }\n            .associateBy({ it.delegate.context.job }, { it.info })\n        return buildString {\n            job.build(jobToStack, this, \"\")\n        }\n    }\n\n    private fun Job.build(map: Map<Job, DebugCoroutineInfoImpl>, builder: StringBuilder, indent: String) {\n        val info = map[this]\n        val newIndent: String\n        if (info == null) { // Append coroutine without stacktrace\n            // Do not print scoped coroutines and do not increase indentation level\n            @Suppress(\"INVISIBLE_REFERENCE\")\n            if (this !is ScopeCoroutine<*>) {\n                builder.append(\"$indent$debugString\\n\")\n                newIndent = indent + \"\\t\"\n            } else {\n                newIndent = indent\n            }\n        } else {\n            // Append coroutine with its last stacktrace element\n            val element = info.lastObservedStackTrace().firstOrNull()\n            val state = info.state\n            builder.append(\"$indent$debugString, continuation is $state at line $element\\n\")\n            newIndent = indent + \"\\t\"\n        }\n        // Append children with new indent\n        for (child in children) {\n            child.build(map, builder, newIndent)\n        }\n    }\n\n    @Suppress(\"DEPRECATION_ERROR\") // JobSupport\n    private val Job.debugString: String get() = if (this is JobSupport) toDebugString() else toString()\n\n    /**\n     * Private method that dumps coroutines so that different public-facing method can use\n     * to produce different result types.\n     */\n    private inline fun <R : Any> dumpCoroutinesInfoImpl(crossinline create: (CoroutineOwner<*>, CoroutineContext) -> R): List<R> {\n        check(isInstalled) { \"Debug probes are not installed\" }\n        return capturedCoroutines\n            .asSequence()\n            // Stable ordering of coroutines by their sequence number\n            .sortedBy { it.info.sequenceNumber }\n            // Leave in the dump only the coroutines that were not collected while we were dumping them\n            .mapNotNull { owner ->\n                // Fuse map and filter into one operation to save an inline\n                if (owner.isFinished()) null\n                else owner.info.context?.let { context -> create(owner, context) }\n            }.toList()\n    }\n\n    /*\n     * This method optimises the number of packages sent by the IDEA debugger\n     * to a client VM to speed up fetching of coroutine information.\n     *\n     * The return value is an array of objects, which consists of four elements:\n     * 1) A string in a JSON format that stores information that is needed to display\n     *    every coroutine in the coroutine panel in the IDEA debugger.\n     * 2) An array of last observed threads.\n     * 3) An array of last observed frames.\n     * 4) An array of DebugCoroutineInfo.\n     *\n     * ### Implementation note\n     * For methods like `dumpCoroutinesInfo` JDWP provides `com.sun.jdi.ObjectReference`\n     * that does a roundtrip to client VM for *each* field or property read.\n     * To avoid that, we serialize most of the critical for UI data into a primitives\n     * to save an exponential number of roundtrips.\n     *\n     * Internal (JVM-public) method used by IDEA debugger as of 1.6.0-RC.\n     * See KTIJ-24102.\n     */\n    @OptIn(ExperimentalStdlibApi::class)\n    fun dumpCoroutinesInfoAsJsonAndReferences(): Array<Any> {\n        val coroutinesInfo = dumpCoroutinesInfo()\n        val size = coroutinesInfo.size\n        val lastObservedThreads = ArrayList<Thread?>(size)\n        val lastObservedFrames = ArrayList<CoroutineStackFrame?>(size)\n        val coroutinesInfoAsJson = ArrayList<String>(size)\n        for (info in coroutinesInfo) {\n            val context = info.context\n            val name = context[CoroutineName.Key]?.name?.toStringRepr()\n            val dispatcher = context[CoroutineDispatcher.Key]?.toStringRepr()\n            coroutinesInfoAsJson.add(\n                \"\"\"\n                {\n                    \"name\": $name,\n                    \"id\": ${context[CoroutineId.Key]?.id},\n                    \"dispatcher\": $dispatcher,\n                    \"sequenceNumber\": ${info.sequenceNumber},\n                    \"state\": \"${info.state}\"\n                } \n                \"\"\".trimIndent()\n            )\n            lastObservedFrames.add(info.lastObservedFrame)\n            lastObservedThreads.add(info.lastObservedThread)\n        }\n\n        return arrayOf(\n            \"[${coroutinesInfoAsJson.joinToString()}]\",\n            lastObservedThreads.toTypedArray(),\n            lastObservedFrames.toTypedArray(),\n            coroutinesInfo.toTypedArray()\n        )\n    }\n\n    /*\n     * Internal (JVM-public) method used by IDEA debugger as of 1.6.0-RC, must be kept binary-compatible, see KTIJ-24102\n     */\n    fun enhanceStackTraceWithThreadDumpAsJson(info: DebugCoroutineInfo): String {\n        val stackTraceElements = enhanceStackTraceWithThreadDump(info, info.lastObservedStackTrace)\n        val stackTraceElementsInfoAsJson = mutableListOf<String>()\n        for (element in stackTraceElements) {\n            stackTraceElementsInfoAsJson.add(\n                \"\"\"\n                {\n                    \"declaringClass\": \"${element.className}\",\n                    \"methodName\": \"${element.methodName}\",\n                    \"fileName\": ${element.fileName?.toStringRepr()},\n                    \"lineNumber\": ${element.lineNumber}\n                }\n                \"\"\".trimIndent()\n            )\n        }\n\n        return \"[${stackTraceElementsInfoAsJson.joinToString()}]\"\n    }\n\n    private fun Any.toStringRepr() = toString().repr()\n\n    /*\n     * Internal (JVM-public) method used by IDEA debugger as of 1.4-M3. See KTIJ-24102\n     */\n    fun dumpCoroutinesInfo(): List<DebugCoroutineInfo> =\n        dumpCoroutinesInfoImpl { owner, context -> DebugCoroutineInfo(owner.info, context) }\n\n    /*\n     * Internal (JVM-public) method to be used by IDEA debugger in the future (not used as of 1.4-M3).\n     * It is equivalent to [dumpCoroutinesInfo], but returns serializable (and thus less typed) objects.\n     */\n    fun dumpDebuggerInfo(): List<DebuggerInfo> =\n        dumpCoroutinesInfoImpl { owner, context -> DebuggerInfo(owner.info, context) }\n\n    @JvmName(\"dumpCoroutines\")\n    internal fun dumpCoroutines(out: PrintStream): Unit = synchronized(out) {\n        /*\n         * This method synchronizes both on `out` and `this` for a reason:\n         * 1) Taking a write lock is required to have a consistent snapshot of coroutines.\n         * 2) Synchronization on `out` is not required, but prohibits interleaving with any other\n         *    (asynchronous) attempt to write to this `out` (System.out by default).\n         * Yet this prevents the progress of coroutines until they are fully dumped to the out which we find acceptable compromise.\n         */\n        dumpCoroutinesSynchronized(out)\n    }\n\n    /*\n     * Filters out coroutines that do not call probeCoroutineCompleted,\n     * are completed, but not yet garbage collected.\n     *\n     * Typically, we intercept completion of the coroutine so it invokes \"probeCoroutineCompleted\",\n     * but it's not the case for lazy coroutines that get cancelled before start.\n     */\n    private fun CoroutineOwner<*>.isFinished(): Boolean {\n        // Guarded by lock\n        val job = info.context?.get(Job) ?: return false\n        if (!job.isCompleted) return false\n        capturedCoroutinesMap.remove(this) // Clean it up by the way\n        return true\n    }\n\n    private fun dumpCoroutinesSynchronized(out: PrintStream) {\n        check(isInstalled) { \"Debug probes are not installed\" }\n        out.print(\"Coroutines dump ${dateFormat.format(System.currentTimeMillis())}\")\n        capturedCoroutines\n            .asSequence()\n            .filter { !it.isFinished() }\n            .sortedBy { it.info.sequenceNumber }\n            .forEach { owner ->\n                val info = owner.info\n                val observedStackTrace = info.lastObservedStackTrace()\n                val enhancedStackTrace = enhanceStackTraceWithThreadDumpImpl(info.state, info.lastObservedThread, observedStackTrace)\n                val state = if (info.state == RUNNING && enhancedStackTrace === observedStackTrace)\n                    \"${info.state} (Last suspension stacktrace, not an actual stacktrace)\"\n                else\n                    info.state\n                out.print(\"\\n\\nCoroutine ${owner.delegate}, state: $state\")\n                if (observedStackTrace.isEmpty()) {\n                    out.print(\"\\n\\tat $ARTIFICIAL_FRAME\")\n                    printStackTrace(out, info.creationStackTrace)\n                } else {\n                    printStackTrace(out, enhancedStackTrace)\n                }\n            }\n    }\n\n    private fun printStackTrace(out: PrintStream, frames: List<StackTraceElement>) {\n        frames.forEach { frame ->\n            out.print(\"\\n\\tat $frame\")\n        }\n    }\n\n    /*\n     * Internal (JVM-public) method used by IDEA debugger as of 1.4-M3, must be kept binary-compatible. See KTIJ-24102.\n     * It is similar to [enhanceStackTraceWithThreadDumpImpl], but uses debugger-facing [DebugCoroutineInfo] type.\n     */\n    @Suppress(\"unused\")\n    fun enhanceStackTraceWithThreadDump(\n        info: DebugCoroutineInfo,\n        coroutineTrace: List<StackTraceElement>\n    ): List<StackTraceElement> =\n        enhanceStackTraceWithThreadDumpImpl(info.state, info.lastObservedThread, coroutineTrace)\n\n    /**\n     * Tries to enhance [coroutineTrace] (obtained by call to [DebugCoroutineInfoImpl.lastObservedStackTrace]) with\n     * thread dump of [DebugCoroutineInfoImpl.lastObservedThread].\n     *\n     * Returns [coroutineTrace] if enhancement was unsuccessful or the enhancement result.\n     */\n    private fun enhanceStackTraceWithThreadDumpImpl(\n        state: String,\n        thread: Thread?,\n        coroutineTrace: List<StackTraceElement>\n    ): List<StackTraceElement> {\n        if (state != RUNNING || thread == null) return coroutineTrace\n        // Avoid security manager issues\n        val actualTrace = runCatching { thread.stackTrace }.getOrNull()\n            ?: return coroutineTrace\n\n        /*\n         * Here goes heuristic that tries to merge two stacktraces: real one\n         * (that has at least one but usually not so many suspend function frames)\n         * and coroutine one that has only suspend function frames.\n         *\n         * Heuristic:\n         * 1) Dump lastObservedThread\n         * 2) Find the next frame after BaseContinuationImpl.resumeWith (continuation machinery).\n         *   Invariant: this method is called under the lock, so such method **should** be present\n         *   in continuation stacktrace.\n         * 3) Find target method in continuation stacktrace (metadata-based)\n         * 4) Prepend dumped stacktrace (trimmed by target frame) to continuation stacktrace\n         *\n         * Heuristic may fail on recursion and overloads, but it will be automatically improved\n         * with KT-29997.\n         */\n        val indexOfResumeWith = actualTrace.indexOfFirst {\n            it.className == \"kotlin.coroutines.jvm.internal.BaseContinuationImpl\" &&\n                    it.methodName == \"resumeWith\" &&\n                    it.fileName == \"ContinuationImpl.kt\"\n        }\n\n        val (continuationStartFrame, delta) = findContinuationStartIndex(\n            indexOfResumeWith,\n            actualTrace,\n            coroutineTrace\n        )\n\n        if (continuationStartFrame == -1) return coroutineTrace\n\n        val expectedSize = indexOfResumeWith + coroutineTrace.size - continuationStartFrame - 1 - delta\n        val result = ArrayList<StackTraceElement>(expectedSize)\n        for (index in 0 until indexOfResumeWith - delta) {\n            result += actualTrace[index]\n        }\n\n        for (index in continuationStartFrame + 1 until coroutineTrace.size) {\n            result += coroutineTrace[index]\n        }\n\n        return result\n    }\n\n    /**\n     * Tries to find the lowest meaningful frame above `resumeWith` in the real stacktrace and\n     * its match in a coroutines stacktrace (steps 2-3 in heuristic).\n     *\n     * This method does more than just matching `realTrace.indexOf(resumeWith) - 1`:\n     * If method above `resumeWith` has no line number (thus it is `stateMachine.invokeSuspend`),\n     * it's skipped and attempt to match next one is made because state machine could have been missing in the original coroutine stacktrace.\n     *\n     * Returns index of such frame (or -1) and number of skipped frames (up to 2, for state machine and for access$).\n     */\n    private fun findContinuationStartIndex(\n        indexOfResumeWith: Int,\n        actualTrace: Array<StackTraceElement>,\n        coroutineTrace: List<StackTraceElement>\n    ): Pair<Int, Int> {\n        /*\n         * Since Kotlin 1.5.0 we have these access$ methods that we have to skip.\n         * So we have to test next frame for invokeSuspend, for $access and for actual suspending call.\n         */\n        repeat(3) {\n            val result = findIndexOfFrame(indexOfResumeWith - 1 - it, actualTrace, coroutineTrace)\n            if (result != -1) return result to it\n        }\n        return -1 to 0\n    }\n\n    private fun findIndexOfFrame(\n        frameIndex: Int,\n        actualTrace: Array<StackTraceElement>,\n        coroutineTrace: List<StackTraceElement>\n    ): Int {\n        val continuationFrame = actualTrace.getOrNull(frameIndex)\n            ?: return -1\n\n        return coroutineTrace.indexOfFirst {\n            it.fileName == continuationFrame.fileName &&\n                    it.className == continuationFrame.className &&\n                    it.methodName == continuationFrame.methodName\n        }\n    }\n\n    internal fun probeCoroutineResumed(frame: Continuation<*>) = updateState(frame, RUNNING)\n\n    internal fun probeCoroutineSuspended(frame: Continuation<*>) = updateState(frame, SUSPENDED)\n\n    private fun updateState(frame: Continuation<*>, state: String) {\n        if (!isInstalled) return\n        if (ignoreCoroutinesWithEmptyContext && frame.context === EmptyCoroutineContext) return // See ignoreCoroutinesWithEmptyContext\n        if (state == RUNNING) {\n            val stackFrame = frame as? CoroutineStackFrame ?: return\n            updateRunningState(stackFrame, state)\n            return\n        }\n\n        // Find ArtificialStackFrame of the coroutine\n        val owner = frame.owner() ?: return\n        updateState(owner, frame, state)\n    }\n\n    // See comment to callerInfoCache\n    private fun updateRunningState(frame: CoroutineStackFrame, state: String) {\n        if (!isInstalled) return\n        // Lookup coroutine info in cache or by traversing stack frame\n        val info: DebugCoroutineInfoImpl\n        val cached = callerInfoCache.remove(frame)\n        val shouldBeMatchedWithProbeSuspended: Boolean\n        if (cached != null) {\n            info = cached\n            shouldBeMatchedWithProbeSuspended = false\n        } else {\n            info = frame.owner()?.info ?: return\n            shouldBeMatchedWithProbeSuspended = true\n            // Guard against improper implementations of CoroutineStackFrame and bugs in the compiler\n            val realCaller = info.lastObservedFrame?.realCaller()\n            if (realCaller != null) callerInfoCache.remove(realCaller)\n        }\n        info.updateState(state, frame as Continuation<*>, shouldBeMatchedWithProbeSuspended)\n        // Do not cache it for proxy-classes such as ScopeCoroutines\n        val caller = frame.realCaller() ?: return\n        callerInfoCache[caller] = info\n    }\n\n    private tailrec fun CoroutineStackFrame.realCaller(): CoroutineStackFrame? {\n        val caller = callerFrame ?: return null\n        return if (caller.getStackTraceElement() != null) caller else caller.realCaller()\n    }\n\n    private fun updateState(owner: CoroutineOwner<*>, frame: Continuation<*>, state: String) {\n        if (!isInstalled) return\n        owner.info.updateState(state, frame, true)\n    }\n\n    private fun Continuation<*>.owner(): CoroutineOwner<*>? = (this as? CoroutineStackFrame)?.owner()\n\n    private tailrec fun CoroutineStackFrame.owner(): CoroutineOwner<*>? =\n        if (this is CoroutineOwner<*>) this else callerFrame?.owner()\n\n    // Not guarded by the lock at all, does not really affect consistency\n    internal fun <T> probeCoroutineCreated(completion: Continuation<T>): Continuation<T> {\n        if (!isInstalled) return completion\n        // See DebugProbes.ignoreCoroutinesWithEmptyContext for the additional details.\n        if (ignoreCoroutinesWithEmptyContext && completion.context === EmptyCoroutineContext) return completion\n        /*\n         * If completion already has an owner, it means that we are in scoped coroutine (coroutineScope, withContext etc.),\n         * then piggyback on its already existing owner and do not replace completion\n         */\n        val owner = completion.owner()\n        if (owner != null) return completion\n        /*\n         * Here we replace completion with a sequence of StackTraceFrame objects\n         * which represents creation stacktrace, thus making stacktrace recovery mechanism\n         * even more verbose (it will attach coroutine creation stacktrace to all exceptions),\n         * and then using CoroutineOwner completion as unique identifier of coroutineSuspended/resumed calls.\n         */\n        val frame = if (enableCreationStackTraces) {\n            sanitizeStackTrace(Exception()).toStackTraceFrame()\n        } else {\n            null\n        }\n        return createOwner(completion, frame)\n    }\n\n    private fun List<StackTraceElement>.toStackTraceFrame(): StackTraceFrame =\n        StackTraceFrame(\n            foldRight<StackTraceElement, StackTraceFrame?>(null) { frame, acc ->\n                StackTraceFrame(acc, frame)\n            }, ARTIFICIAL_FRAME\n        )\n\n    private fun <T> createOwner(completion: Continuation<T>, frame: StackTraceFrame?): Continuation<T> {\n        if (!isInstalled) return completion\n        val info = DebugCoroutineInfoImpl(completion.context, frame, sequenceNumber.incrementAndGet())\n        val owner = CoroutineOwner(completion, info)\n        capturedCoroutinesMap[owner] = true\n        if (!isInstalled) capturedCoroutinesMap.clear()\n        return owner\n    }\n\n    // Not guarded by the lock at all, does not really affect consistency\n    private fun probeCoroutineCompleted(owner: CoroutineOwner<*>) {\n        capturedCoroutinesMap.remove(owner)\n        /*\n         * This removal is a guard against improperly implemented CoroutineStackFrame\n         * and bugs in the compiler.\n         */\n        val caller = owner.info.lastObservedFrame?.realCaller() ?: return\n        callerInfoCache.remove(caller)\n    }\n\n    /**\n     * This class is injected as completion of all continuations in [probeCoroutineCompleted].\n     * It is owning the coroutine info and responsible for managing all its external info related to debug agent.\n     */\n    public class CoroutineOwner<T> internal constructor(\n        @JvmField internal val delegate: Continuation<T>,\n        // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n        @JvmField public val info: DebugCoroutineInfoImpl\n    ) : Continuation<T> by delegate, CoroutineStackFrame {\n        private val frame get() = info.creationStackBottom\n\n        override val callerFrame: CoroutineStackFrame?\n            get() = frame?.callerFrame\n\n        override fun getStackTraceElement(): StackTraceElement? = frame?.getStackTraceElement()\n\n        override fun resumeWith(result: Result<T>) {\n            probeCoroutineCompleted(this)\n            delegate.resumeWith(result)\n        }\n\n        override fun toString(): String = delegate.toString()\n    }\n\n    private fun <T : Throwable> sanitizeStackTrace(throwable: T): List<StackTraceElement> {\n        val stackTrace = throwable.stackTrace\n        val size = stackTrace.size\n        val traceStart = 1 + stackTrace.indexOfLast { it.className == \"kotlin.coroutines.jvm.internal.DebugProbesKt\" }\n\n        if (!sanitizeStackTraces) {\n            return List(size - traceStart) { stackTrace[it + traceStart] }\n        }\n\n        /*\n         * Trim intervals of internal methods from the stacktrace (bounds are excluded from trimming)\n         * E.g. for sequence [e, i1, i2, i3, e, i4, e, i5, i6, i7]\n         * output will be [e, i1, i3, e, i4, e, i5, i7]\n         *\n         * If an interval of internal methods ends in a synthetic method, the outermost non-synthetic method in that\n         * interval will also be included.\n         */\n        val result = ArrayList<StackTraceElement>(size - traceStart + 1)\n        var i = traceStart\n        while (i < size) {\n            if (stackTrace[i].isInternalMethod) {\n                result += stackTrace[i] // we include the boundary of the span in any case\n                // first index past the end of the span of internal methods that starts from `i`\n                var j = i + 1\n                while (j < size && stackTrace[j].isInternalMethod) {\n                    ++j\n                }\n                // index of the last non-synthetic internal methods in this span, or `i` if there are no such methods\n                var k = j - 1\n                while (k > i && stackTrace[k].fileName == null) {\n                    k -= 1\n                }\n                if (k > i && k < j - 1) {\n                    /* there are synthetic internal methods at the end of this span, but there is a non-synthetic method\n                    after `i`, so we include it. */\n                    result += stackTrace[k]\n                }\n                result += stackTrace[j - 1] // we include the other boundary of this span in any case, too\n                i = j\n            } else {\n                result += stackTrace[i]\n                ++i\n            }\n        }\n        return result\n    }\n\n    private val StackTraceElement.isInternalMethod: Boolean get() = className.startsWith(\"kotlinx.coroutines\")\n}\n\nprivate fun String.repr(): String = buildString {\n    append('\"')\n    for (c in this@repr) {\n        when (c) {\n            '\"' -> append(\"\\\\\\\"\")\n            '\\\\' -> append(\"\\\\\\\\\")\n            '\\b' -> append(\"\\\\b\")\n            '\\n' -> append(\"\\\\n\")\n            '\\r' -> append(\"\\\\r\")\n            '\\t' -> append(\"\\\\t\")\n            else -> append(c)\n        }\n    }\n    append('\"')\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/internal/DebuggerInfo.kt",
        "content": "@file:Suppress(\"UNUSED\")\n\npackage kotlinx.coroutines.debug.internal\n\nimport java.io.Serializable\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.*\n\n/*\n * This class represents all the data required by IDEA debugger.\n * It is serializable in order to speedup JDWP interactions.\n * **DO NOT MAKE BINARY-INCOMPATIBLE CHANGES TO THIS CLASS**.\n */\n@PublishedApi\ninternal class DebuggerInfo(source: DebugCoroutineInfoImpl, context: CoroutineContext) : Serializable {\n    public val coroutineId: Long? = context[CoroutineId]?.id\n    public val dispatcher: String? = context[ContinuationInterceptor]?.toString()\n    public val name: String? = context[CoroutineName]?.name\n    public val state: String = source.state\n    public val lastObservedThreadState: String? = source.lastObservedThread?.state?.toString()\n    public val lastObservedThreadName = source.lastObservedThread?.name\n    public val lastObservedStackTrace: List<StackTraceElement> = source.lastObservedStackTrace()\n    public val sequenceNumber: Long = source.sequenceNumber\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/debug/internal/StackTraceFrame.kt",
        "content": "package kotlinx.coroutines.debug.internal\n\nimport kotlin.coroutines.jvm.internal.*\n\n/**\n * A stack-trace represented as [CoroutineStackFrame].\n */\n@PublishedApi\ninternal class StackTraceFrame internal constructor(\n    override val callerFrame: CoroutineStackFrame?,\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @JvmField public val stackTraceElement: StackTraceElement\n) : CoroutineStackFrame {\n    override fun getStackTraceElement(): StackTraceElement = stackTraceElement\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/flow/internal/FlowExceptions.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\ninternal actual class AbortFlowException actual constructor(\n    @JvmField @Transient actual val owner: Any\n) : CancellationException(\"Flow was aborted, no more elements needed\") {\n\n    override fun fillInStackTrace(): Throwable {\n        if (DEBUG) return super.fillInStackTrace()\n        // Prevent Android <= 6.0 bug, #1866\n        stackTrace = emptyArray()\n        return this\n    }\n}\n\ninternal actual class ChildCancelledException : CancellationException(\"Child of the scoped flow was cancelled\") {\n    override fun fillInStackTrace(): Throwable {\n        if (DEBUG) return super.fillInStackTrace()\n        // Prevent Android <= 6.0 bug, #1866\n        stackTrace = emptyArray()\n        return this\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/flow/internal/SafeCollector.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.coroutines.jvm.internal.*\n\n@Suppress(\"UNCHECKED_CAST\")\nprivate val emitFun =\n    FlowCollector<Any?>::emit as Function3<FlowCollector<Any?>, Any?, Continuation<Unit>, Any?>\n\n/**\n * A safe collector is an instance of [FlowCollector] that ensures that neither context preservation\n * nor exception transparency invariants are broken. Instances of [SafeCollector] are used in flow\n * operators that provide raw access to the [FlowCollector] e.g. [Flow.transform].\n * Mechanically, each [emit] call captures [currentCoroutineContext], ensures it is not different from the\n * previously caught one and proceeds further. If an exception is thrown from the downstream,\n * it is caught, and any further attempts to [emit] lead to the [IllegalStateException].\n *\n * ### Performance hacks\n *\n * Implementor of [ContinuationImpl] (that will be preserved as ABI nearly forever)\n * in order to properly control `intercepted()` lifecycle.\n * The safe collector implements [ContinuationImpl] to pretend it *is* a state-machine of its own `emit` method.\n * It is [ContinuationImpl] and not any other [Continuation] subclass because only [ContinuationImpl] supports `intercepted()` caching.\n * This is the most performance-sensitive place in the overall flow pipeline, because otherwise safe collector is forced to allocate\n * a state machine on each element being emitted for each intermediate stage where the safe collector is present.\n *\n * See a comment to [emit] for the explanation of what and how is being optimized.\n */\n@Suppress(\"CANNOT_OVERRIDE_INVISIBLE_MEMBER\", \"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\", \"UNCHECKED_CAST\")\ninternal actual class SafeCollector<T> actual constructor(\n    @JvmField internal actual val collector: FlowCollector<T>,\n    @JvmField internal actual val collectContext: CoroutineContext\n) : FlowCollector<T>, ContinuationImpl(NoOpContinuation, EmptyCoroutineContext), CoroutineStackFrame {\n\n    override val callerFrame: CoroutineStackFrame? get() = completion_ as? CoroutineStackFrame\n\n    override fun getStackTraceElement(): StackTraceElement? = null\n\n    @JvmField // Note, it is non-capturing lambda, so no extra allocation during init of SafeCollector\n    internal actual val collectContextSize = collectContext.fold(0) { count, _ -> count + 1 }\n\n    // Either context of the last emission or wrapper 'DownstreamExceptionContext'\n    private var lastEmissionContext: CoroutineContext? = null\n    // Completion if we are currently suspended or within completion_ body or null otherwise\n    private var completion_: Continuation<Unit>? = null\n\n    /*\n     * This property is accessed in two places:\n     * - ContinuationImpl invokes this in its `releaseIntercepted` as `context[ContinuationInterceptor]!!`\n     * - When we are within a callee, it is used to create its continuation object with this collector as completion_\n     */\n    override val context: CoroutineContext\n        get() = lastEmissionContext ?: EmptyCoroutineContext\n\n    override fun invokeSuspend(result: Result<Any?>): Any {\n        result.onFailure { lastEmissionContext = DownstreamExceptionContext(it, context) }\n        completion_?.resumeWith(result as Result<Unit>)\n        return COROUTINE_SUSPENDED\n    }\n\n    // Escalate visibility to manually release intercepted continuation\n    public actual override fun releaseIntercepted() {\n        super.releaseIntercepted()\n    }\n\n    /**\n     * This is a crafty implementation of state-machine reusing.\n     *\n     * First it checks that it is not used concurrently (which we explicitly prohibit), and\n     * then just caches an instance of the completion_ in order to avoid extra allocation on each emit,\n     * making it effectively garbage-free on its hot-path.\n     *\n     * See `emit` overload.\n     */\n    actual override suspend fun emit(value: T) {\n        // NB: it is a tail-call, so we are sure `uCont` is the completion of the emit's **caller**.\n        return suspendCoroutineUninterceptedOrReturn sc@{ uCont ->\n            try {\n                emit(uCont, value)\n            } catch (e: Throwable) {\n                // Save the fact that exception from emit (or even check context) has been thrown\n                // Note, that this can the first emit and lastEmissionContext may not be saved yet,\n                // hence we use `uCont.context` here.\n                lastEmissionContext = DownstreamExceptionContext(e, uCont.context)\n                throw e\n            }\n        }\n    }\n\n    /**\n     * Here we use the following trick:\n     * - Perform all the required checks\n     * - Having a non-intercepted, non-cancellable caller's `uCont`, we leverage our implementation knowledge\n     *   and invoke `collector.emit(T)` as `collector.emit(value: T, completion: Continuation), passing `this`\n     *   as the completion. We also setup `this` state, so if the `completion.resume` is invoked, we are\n     *   invoking `uCont.resume` properly in accordance with `ContinuationImpl`/`BaseContinuationImpl` internal invariants.\n     *\n     * Note that in such scenarios, `collector.emit` completion is the current instance of SafeCollector and thus is reused.\n     */\n    private fun emit(uCont: Continuation<Unit>, value: T): Any? {\n        val currentContext = uCont.context\n        currentContext.ensureActive()\n        // This check is triggered once per flow on a happy path.\n        val previousContext = lastEmissionContext\n        if (previousContext !== currentContext) {\n            checkContext(currentContext, previousContext, value)\n            lastEmissionContext = currentContext\n        }\n        completion_ = uCont\n        val result = emitFun(collector as FlowCollector<Any?>, value, this as Continuation<Unit>)\n        /*\n         * If the callee hasn't suspended, that means that it won't (it's forbidden) call 'resumeWith` (-> `invokeSuspend`)\n         * and we don't have to retain a strong reference to it to avoid memory leaks.\n         */\n        if (result != COROUTINE_SUSPENDED) {\n            completion_ = null\n        }\n        return result\n    }\n\n    private fun checkContext(\n        currentContext: CoroutineContext,\n        previousContext: CoroutineContext?,\n        value: T\n    ) {\n        if (previousContext is DownstreamExceptionContext) {\n            exceptionTransparencyViolated(previousContext, value)\n        }\n        checkContext(currentContext)\n    }\n\n    private fun exceptionTransparencyViolated(exception: DownstreamExceptionContext, value: Any?) {\n        /*\n         * Exception transparency ensures that if a `collect` block or any intermediate operator\n         * throws an exception, then no more values will be received by it.\n         * For example, the following code:\n         * ```\n         * val flow = flow {\n         *     emit(1)\n         *     try {\n         *          emit(2)\n         *     } catch (e: Exception) {\n         *          emit(3)\n         *     }\n         * }\n         * // Collector\n         * flow.collect { value ->\n         *     if (value == 2) {\n         *         throw CancellationException(\"No more elements required, received enough\")\n         *     } else {\n         *         println(\"Collected $value\")\n         *     }\n         * }\n         * ```\n         * is expected to print \"Collected 1\" and then \"No more elements required, received enough\" exception,\n         * but if exception transparency wasn't enforced, \"Collected 1\" and \"Collected 3\" would be printed instead.\n         */\n        error(\"\"\"\n            Flow exception transparency is violated:\n                Previous 'emit' call has thrown exception ${exception.e}, but then emission attempt of value '$value' has been detected.\n                Emissions from 'catch' blocks are prohibited in order to avoid unspecified behaviour, 'Flow.catch' operator can be used instead.\n                For a more detailed explanation, please refer to Flow documentation.\n            \"\"\".trimIndent())\n    }\n}\n\ninternal class DownstreamExceptionContext(\n    @JvmField val e: Throwable,\n    originalContext: CoroutineContext\n) : CoroutineContext by originalContext\n\nprivate object NoOpContinuation : Continuation<Any?> {\n    override val context: CoroutineContext = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<Any?>) {\n        // Nothing\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/Concurrent.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport java.lang.reflect.*\nimport java.util.*\nimport java.util.concurrent.*\nimport kotlin.concurrent.withLock as withLockJvm\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\ninternal actual typealias ReentrantLock = java.util.concurrent.locks.ReentrantLock\n\ninternal actual inline fun <T> ReentrantLock.withLock(action: () -> T) = this.withLockJvm(action)\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\") // Visibility\ninternal actual typealias WorkaroundAtomicReference<T> = java.util.concurrent.atomic.AtomicReference<T>\n\n@Suppress(\"NOTHING_TO_INLINE\") // So that R8 can completely remove ConcurrentKt class\ninternal actual inline fun <E> identitySet(expectedSize: Int): MutableSet<E> =\n    Collections.newSetFromMap(IdentityHashMap(expectedSize))\n\nprivate val REMOVE_FUTURE_ON_CANCEL: Method? = try {\n    ScheduledThreadPoolExecutor::class.java.getMethod(\"setRemoveOnCancelPolicy\", Boolean::class.java)\n} catch (e: Throwable) {\n    null\n}\n\n@Suppress(\"NAME_SHADOWING\")\ninternal fun removeFutureOnCancel(executor: Executor): Boolean {\n    try {\n        val executor = executor as? ScheduledThreadPoolExecutor ?: return false\n        (REMOVE_FUTURE_ON_CANCEL ?: return false).invoke(executor, true)\n        return true\n    } catch (e: Throwable) {\n        return false // failed to setRemoveOnCancelPolicy, assume it does not removes future on cancel\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/CoroutineExceptionHandlerImpl.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport java.util.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * A list of globally installed [CoroutineExceptionHandler] instances.\n *\n * Note that Android may have dummy [Thread.contextClassLoader] which is used by one-argument [ServiceLoader.load] function,\n * see (https://stackoverflow.com/questions/13407006/android-class-loader-may-fail-for-processes-that-host-multiple-applications).\n * So here we explicitly use two-argument `load` with a class-loader of [CoroutineExceptionHandler] class.\n *\n * We are explicitly using the `ServiceLoader.load(MyClass::class.java, MyClass::class.java.classLoader).iterator()`\n * form of the ServiceLoader call to enable R8 optimization when compiled on Android.\n */\ninternal actual val platformExceptionHandlers: Collection<CoroutineExceptionHandler> = ServiceLoader.load(\n    CoroutineExceptionHandler::class.java,\n    CoroutineExceptionHandler::class.java.classLoader\n).iterator().asSequence().toList()\n\ninternal actual fun ensurePlatformExceptionHandlerLoaded(callback: CoroutineExceptionHandler) {\n    // we use JVM's mechanism of ServiceLoader, so this should be a no-op on JVM.\n    // The only thing we do is make sure that the ServiceLoader did work correctly.\n    check(callback in platformExceptionHandlers) { \"Exception handler was not found via a ServiceLoader\" }\n}\n\ninternal actual fun propagateExceptionFinalResort(exception: Throwable) {\n    // use the thread's handler\n    val currentThread = Thread.currentThread()\n    currentThread.uncaughtExceptionHandler.uncaughtException(currentThread, exception)\n}\n\n// This implementation doesn't store a stacktrace, which is good because a stacktrace doesn't make sense for this.\ninternal actual class DiagnosticCoroutineContextException actual constructor(@Transient private val context: CoroutineContext) : RuntimeException() {\n    override fun getLocalizedMessage(): String {\n        return context.toString()\n    }\n\n    override fun fillInStackTrace(): Throwable {\n        // Prevent Android <= 6.0 bug, #1866\n        stackTrace = emptyArray()\n        return this\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/ExceptionsConstructor.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport java.lang.reflect.*\nimport java.util.*\nimport java.util.concurrent.locks.*\nimport kotlin.concurrent.*\n\nprivate val throwableFields = Throwable::class.java.fieldsCountOrDefault(-1)\nprivate typealias Ctor = (Throwable) -> Throwable?\n\nprivate val ctorCache = try {\n    if (ANDROID_DETECTED) WeakMapCtorCache\n    else ClassValueCtorCache\n} catch (e: Throwable) {\n    // Fallback on Java 6 or exotic setups\n    WeakMapCtorCache\n}\n\n@Suppress(\"UNCHECKED_CAST\")\ninternal fun <E : Throwable> tryCopyException(exception: E): E? {\n    // Fast path for CopyableThrowable\n    if (exception is CopyableThrowable<*>) {\n        return runCatching { exception.createCopy() as E? }.getOrNull()\n    }\n    return ctorCache.get(exception.javaClass).invoke(exception) as E?\n}\n\nprivate fun <E : Throwable> createConstructor(clz: Class<E>): Ctor {\n    val nullResult: Ctor = { null } // Pre-cache class\n    // Skip reflective copy if an exception has additional fields (that are typically populated in user-defined constructors)\n    if (throwableFields != clz.fieldsCountOrDefault(0)) return nullResult\n    /*\n     * Try to reflectively find constructor(message, cause), constructor(message), constructor(cause), or constructor(),\n     * in that order of priority.\n     * Exceptions are shared among coroutines, so we should copy exception before recovering current stacktrace.\n     *\n     * By default, Java's reflection iterates over ctors in the source-code order and the sorting is stable, so we can\n     * not rely on the order of iteration. Instead, we assign a unique priority to each ctor type.\n     */\n    return clz.constructors.map { constructor ->\n        val p = constructor.parameterTypes\n        when (p.size) {\n            2 -> when {\n                p[0] == String::class.java && p[1] == Throwable::class.java ->\n                    safeCtor { e -> constructor.newInstance(e.message, e) as Throwable } to 3\n                else -> null to -1\n            }\n            1 -> when (p[0]) {\n                String::class.java ->\n                    safeCtor { e -> (constructor.newInstance(e.message) as Throwable).also { it.initCause(e) } } to 2\n                Throwable::class.java ->\n                    safeCtor { e -> constructor.newInstance(e) as Throwable } to 1\n                else -> null to -1\n            }\n            0 -> safeCtor { e -> (constructor.newInstance() as Throwable).also { it.initCause(e) } } to 0\n            else -> null to -1\n        }\n    }.maxByOrNull(Pair<*, Int>::second)?.first ?: nullResult\n}\n\nprivate fun safeCtor(block: (Throwable) -> Throwable): Ctor = { e ->\n    runCatching {\n        val result = block(e)\n        /*\n         * Verify that the new exception has the same message as the original one (bail out if not, see #1631)\n         * or if the new message complies the contract from `Throwable(cause).message` contract.\n         */\n        if (e.message != result.message && result.message != e.toString()) null\n        else result\n    }.getOrNull()\n}\n\nprivate fun Class<*>.fieldsCountOrDefault(defaultValue: Int) =\n    kotlin.runCatching { fieldsCount() }.getOrDefault(defaultValue)\n\nprivate tailrec fun Class<*>.fieldsCount(accumulator: Int = 0): Int {\n    val fieldsCount = declaredFields.count { !Modifier.isStatic(it.modifiers) }\n    val totalFields = accumulator + fieldsCount\n    val superClass = superclass ?: return totalFields\n    return superClass.fieldsCount(totalFields)\n}\n\ninternal abstract class CtorCache {\n    abstract fun get(key: Class<out Throwable>): Ctor\n}\n\nprivate object WeakMapCtorCache : CtorCache() {\n    private val cacheLock = ReentrantReadWriteLock()\n    private val exceptionCtors: WeakHashMap<Class<out Throwable>, Ctor> = WeakHashMap()\n\n    override fun get(key: Class<out Throwable>): Ctor {\n        cacheLock.read { exceptionCtors[key]?.let { return it } }\n        cacheLock.write {\n            exceptionCtors[key]?.let { return it }\n            return createConstructor(key).also { exceptionCtors[key] = it }\n        }\n    }\n}\n\n@IgnoreJreRequirement\nprivate object ClassValueCtorCache : CtorCache() {\n    private val cache = object : ClassValue<Ctor>() {\n        override fun computeValue(type: Class<*>?): Ctor {\n            @Suppress(\"UNCHECKED_CAST\")\n            return createConstructor(type as Class<out Throwable>)\n        }\n    }\n\n    override fun get(key: Class<out Throwable>): Ctor = cache.get(key)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/FastServiceLoader.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport java.io.*\nimport java.net.*\nimport java.util.*\nimport java.util.jar.*\nimport java.util.zip.*\nimport kotlin.collections.ArrayList\n\n/**\n * Don't use JvmField here to enable R8 optimizations via \"assumenosideeffects\"\n */\ninternal val ANDROID_DETECTED = runCatching { Class.forName(\"android.os.Build\") }.isSuccess\n\n/**\n * A simplified version of [ServiceLoader].\n * FastServiceLoader locates and instantiates all service providers named in configuration\n * files placed in the resource directory <tt>META-INF/services</tt>.\n *\n * The main difference between this class and classic service loader is in skipping\n * verification JARs. A verification requires reading the whole JAR (and it causes problems and ANRs on Android devices)\n * and prevents only trivial checksum issues. See #878.\n *\n * If any error occurs during loading, it fallbacks to [ServiceLoader], mostly to prevent R8 issues.\n */\ninternal object FastServiceLoader {\n    private const val PREFIX: String = \"META-INF/services/\"\n\n    /**\n     * This method attempts to load [MainDispatcherFactory] in Android-friendly way.\n     *\n     * If we are not on Android, this method fallbacks to a regular service loading,\n     * else we attempt to do `Class.forName` lookup for\n     * `AndroidDispatcherFactory` and `TestMainDispatcherFactory`.\n     * If lookups are successful, we return resultinAg instances because we know that\n     * `MainDispatcherFactory` API is internal and this is the only possible classes of `MainDispatcherFactory` Service on Android.\n     *\n     * Such intricate dance is required to avoid calls to `ServiceLoader.load` for multiple reasons:\n     * 1) It eliminates disk lookup on potentially slow devices on the Main thread.\n     * 2) Various Android toolchain versions by various vendors don't tend to handle ServiceLoader calls properly.\n     *    Sometimes META-INF is removed from the resulting APK, sometimes class names are mangled, etc.\n     *    While it is not the problem of `kotlinx.coroutines`, it significantly worsens user experience, thus we are workarounding it.\n     *    Examples of such issues are #932, #1072, #1557, #1567\n     *\n     * We also use SL for [CoroutineExceptionHandler], but we do not experience the same problems and CEH is a public API\n     * that may already be injected vis SL, so we are not using the same technique for it.\n     */\n    internal fun loadMainDispatcherFactory(): List<MainDispatcherFactory> {\n        val clz = MainDispatcherFactory::class.java\n        if (!ANDROID_DETECTED) {\n            return load(clz, clz.classLoader)\n        }\n\n        return try {\n            val result = ArrayList<MainDispatcherFactory>(2)\n            createInstanceOf(clz, \"kotlinx.coroutines.android.AndroidDispatcherFactory\")?.apply { result.add(this) }\n            createInstanceOf(clz, \"kotlinx.coroutines.test.internal.TestMainDispatcherFactory\")?.apply { result.add(this) }\n            result\n        } catch (e: Throwable) {\n            // Fallback to the regular SL in case of any unexpected exception\n            load(clz, clz.classLoader)\n        }\n    }\n\n    /*\n     * This method is inline to have a direct Class.forName(\"string literal\") in the byte code to avoid weird interactions with ProGuard/R8.\n     */\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun createInstanceOf(\n        baseClass: Class<MainDispatcherFactory>,\n        serviceClass: String\n    ): MainDispatcherFactory? {\n        return try {\n            val clz = Class.forName(serviceClass, true, baseClass.classLoader)\n            baseClass.cast(clz.getDeclaredConstructor().newInstance())\n        } catch (e: ClassNotFoundException) { // Do not fail if TestMainDispatcherFactory is not found\n            null\n        }\n    }\n\n    private fun <S> load(service: Class<S>, loader: ClassLoader): List<S> {\n        return try {\n            loadProviders(service, loader)\n        } catch (e: Throwable) {\n            // Fallback to default service loader\n            ServiceLoader.load(service, loader).toList()\n        }\n    }\n\n    // Visible for tests\n    internal fun <S> loadProviders(service: Class<S>, loader: ClassLoader): List<S> {\n        val fullServiceName = PREFIX + service.name\n        // Filter out situations when both JAR and regular files are in the classpath (e.g. IDEA)\n        val urls = loader.getResources(fullServiceName)\n        val providers = urls.toList().flatMap { parse(it) }.toSet()\n        require(providers.isNotEmpty()) { \"No providers were loaded with FastServiceLoader\" }\n        return providers.map { getProviderInstance(it, loader, service) }\n    }\n\n    private fun <S> getProviderInstance(name: String, loader: ClassLoader, service: Class<S>): S {\n        val clazz = Class.forName(name, false, loader)\n        require(service.isAssignableFrom(clazz)) { \"Expected service of class $service, but found $clazz\" }\n        return service.cast(clazz.getDeclaredConstructor().newInstance())\n    }\n\n    private fun parse(url: URL): List<String> {\n        val path = url.toString()\n        // Fast-path for JARs\n        if (path.startsWith(\"jar\")) {\n            val pathToJar = path.substringAfter(\"jar:file:\").substringBefore('!')\n            val entry = path.substringAfter(\"!/\")\n            // mind the verify = false flag!\n            (JarFile(pathToJar, false)).use { file ->\n                BufferedReader(InputStreamReader(file.getInputStream(ZipEntry(entry)), \"UTF-8\")).use { r ->\n                    return parseFile(r)\n                }\n            }\n        }\n        // Regular path for everything else\n        return BufferedReader(InputStreamReader(url.openStream())).use { reader ->\n            parseFile(reader)\n        }\n    }\n\n    // JarFile does no implement Closesable on Java 1.6\n    private inline fun <R> JarFile.use(block: (JarFile) -> R): R {\n        var cause: Throwable? = null\n        try {\n            return block(this)\n        } catch (e: Throwable) {\n            cause = e\n            throw e\n        } finally {\n            try {\n                close()\n            } catch (closeException: Throwable) {\n                if (cause === null) throw closeException\n                cause.addSuppressed(closeException)\n                throw cause\n            }\n        }\n    }\n\n    private fun parseFile(r: BufferedReader): List<String> {\n        val names = mutableSetOf<String>()\n        while (true) {\n            val line = r.readLine() ?: break\n            val serviceName = line.substringBefore(\"#\").trim()\n            require(serviceName.all { it == '.' || Character.isJavaIdentifierPart(it) }) { \"Illegal service provider class name: $serviceName\" }\n            if (serviceName.isNotEmpty()) {\n                names.add(serviceName)\n            }\n        }\n        return names.toList()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/InternalAnnotations.kt",
        "content": "package kotlinx.coroutines.internal\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\") // Not the same name to WA the bug in the compiler\ninternal actual typealias IgnoreJreRequirement = org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/LocalAtomics.kt",
        "content": "package kotlinx.coroutines.internal\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\ninternal actual typealias LocalAtomicInt = java.util.concurrent.atomic.AtomicInteger\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/MainDispatchers.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport java.util.*\nimport kotlin.coroutines.*\n\n/**\n * Name of the boolean property that enables using of [FastServiceLoader].\n */\nprivate const val FAST_SERVICE_LOADER_PROPERTY_NAME = \"kotlinx.coroutines.fast.service.loader\"\n\n// Lazy loader for the main dispatcher\ninternal object MainDispatcherLoader {\n\n    private val FAST_SERVICE_LOADER_ENABLED = systemProp(FAST_SERVICE_LOADER_PROPERTY_NAME, true)\n\n    @JvmField\n    val dispatcher: MainCoroutineDispatcher = loadMainDispatcher()\n\n    private fun loadMainDispatcher(): MainCoroutineDispatcher {\n        return try {\n            val factories = if (FAST_SERVICE_LOADER_ENABLED) {\n                FastServiceLoader.loadMainDispatcherFactory()\n            } else {\n                // We are explicitly using the\n                // `ServiceLoader.load(MyClass::class.java, MyClass::class.java.classLoader).iterator()`\n                // form of the ServiceLoader call to enable R8 optimization when compiled on Android.\n                ServiceLoader.load(\n                        MainDispatcherFactory::class.java,\n                        MainDispatcherFactory::class.java.classLoader\n                ).iterator().asSequence().toList()\n            }\n            @Suppress(\"ConstantConditionIf\")\n            factories.maxByOrNull { it.loadPriority }?.tryCreateDispatcher(factories)\n                ?: createMissingDispatcher()\n        } catch (e: Throwable) {\n            // Service loader can throw an exception as well\n            createMissingDispatcher(e)\n        }\n    }\n}\n\n/**\n * If anything goes wrong while trying to create main dispatcher (class not found,\n * initialization failed, etc), then replace the main dispatcher with a special\n * stub that throws an error message on any attempt to actually use it.\n *\n * @suppress internal API\n */\n@InternalCoroutinesApi\npublic fun MainDispatcherFactory.tryCreateDispatcher(factories: List<MainDispatcherFactory>): MainCoroutineDispatcher =\n    try {\n        createDispatcher(factories)\n    } catch (cause: Throwable) {\n        createMissingDispatcher(cause, hintOnError())\n    }\n\n/** @suppress */\n@InternalCoroutinesApi\npublic fun MainCoroutineDispatcher.isMissing(): Boolean =\n    // not checking `this`, as it may be wrapped in a `TestMainDispatcher`, whereas `immediate` never is.\n    this.immediate is MissingMainCoroutineDispatcher\n\n// R8 optimization hook, not const on purpose to enable R8 optimizations via \"assumenosideeffects\"\n@Suppress(\"MayBeConstant\")\nprivate val SUPPORT_MISSING = true\n\n@Suppress(\n    \"ConstantConditionIf\",\n    \"IMPLICIT_NOTHING_TYPE_ARGUMENT_AGAINST_NOT_NOTHING_EXPECTED_TYPE\" // KT-47626\n)\nprivate fun createMissingDispatcher(cause: Throwable? = null, errorHint: String? = null) =\n    if (SUPPORT_MISSING) MissingMainCoroutineDispatcher(cause, errorHint) else\n        cause?.let { throw it } ?: throwMissingMainDispatcherException()\n\ninternal fun throwMissingMainDispatcherException(): Nothing {\n    throw IllegalStateException(\n        \"Module with the Main dispatcher is missing. \" +\n            \"Add dependency providing the Main dispatcher, e.g. 'kotlinx-coroutines-android' \" +\n            \"and ensure it has the same version as 'kotlinx-coroutines-core'\"\n    )\n}\n\nprivate class MissingMainCoroutineDispatcher(\n    private val cause: Throwable?,\n    private val errorHint: String? = null\n) : MainCoroutineDispatcher(), Delay {\n\n    override val immediate: MainCoroutineDispatcher get() = this\n\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean =\n        missing()\n\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher =\n        missing()\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle =\n        missing()\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) =\n        missing()\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) =\n        missing()\n\n    private fun missing(): Nothing {\n        if  (cause == null) {\n            throwMissingMainDispatcherException()\n        } else {\n            val message = \"Module with the Main dispatcher had failed to initialize\" + (errorHint?.let { \". $it\" } ?: \"\")\n            throw IllegalStateException(message, cause)\n        }\n    }\n\n    override fun toString(): String = \"Dispatchers.Main[missing${if (cause != null) \", cause=$cause\" else \"\"}]\"\n}\n\n/**\n * @suppress\n */\n@InternalCoroutinesApi\npublic object MissingMainCoroutineDispatcherFactory : MainDispatcherFactory {\n    override val loadPriority: Int\n        get() = -1\n\n    override fun createDispatcher(allFactories: List<MainDispatcherFactory>): MainCoroutineDispatcher {\n        return MissingMainCoroutineDispatcher(null)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/ProbesSupport.kt",
        "content": "@file:Suppress(\"NOTHING_TO_INLINE\", \"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n\npackage kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.jvm.internal.probeCoroutineCreated as probe\n\ninternal actual inline fun <T> probeCoroutineCreated(completion: Continuation<T>): Continuation<T> = probe(completion)\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/ResizableAtomicArray.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport java.util.concurrent.atomic.*\n\n/**\n * Atomic array with lock-free reads and synchronized modifications. It logically has an unbounded size,\n * is implicitly filled with nulls, and is resized on updates as needed to grow.\n */\ninternal class ResizableAtomicArray<T>(initialLength: Int) {\n    @Volatile\n    private var array = AtomicReferenceArray<T>(initialLength)\n\n    // for debug output\n    public fun currentLength(): Int = array.length()\n\n    public operator fun get(index: Int): T? {\n        val array = this.array // volatile read\n        return if (index < array.length()) array[index] else null\n    }\n\n    // Must not be called concurrently, e.g. always use synchronized(this) to call this function\n    fun setSynchronized(index: Int, value: T?) {\n        val curArray = this.array\n        val curLen = curArray.length()\n        if (index < curLen) {\n            curArray[index] = value\n            return\n        }\n        // It would be nice to copy array in batch instead of 1 by 1, but it seems like Java has no API for that\n        val newArray = AtomicReferenceArray<T>((index + 1).coerceAtLeast(2 * curLen))\n        for (i in 0 until curLen) newArray[i] = curArray[i]\n        newArray[index] = value\n        array = newArray // copy done\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/StackTraceRecovery.kt",
        "content": "@file:Suppress(\"UNCHECKED_CAST\")\n\npackage kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport _COROUTINE.ARTIFICIAL_FRAME_PACKAGE_NAME\nimport _COROUTINE.ArtificialStackFrames\nimport java.util.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n/*\n * `Class.forName(name).canonicalName` instead of plain `name` is required to properly handle\n * Android's minifier that renames these classes and breaks our recovery heuristic without such lookup.\n */\nprivate const val baseContinuationImplClass = \"kotlin.coroutines.jvm.internal.BaseContinuationImpl\"\nprivate const val stackTraceRecoveryClass = \"kotlinx.coroutines.internal.StackTraceRecoveryKt\"\n\nprivate val ARTIFICIAL_FRAME = ArtificialStackFrames().coroutineBoundary()\n\nprivate val baseContinuationImplClassName = runCatching {\n    Class.forName(baseContinuationImplClass).canonicalName\n}.getOrElse { baseContinuationImplClass }\n\nprivate val stackTraceRecoveryClassName = runCatching {\n    Class.forName(stackTraceRecoveryClass).canonicalName\n}.getOrElse { stackTraceRecoveryClass }\n\ninternal actual fun <E : Throwable> recoverStackTrace(exception: E): E {\n    if (!RECOVER_STACK_TRACES) return exception\n    // No unwrapping on continuation-less path: exception is not reported multiple times via slow paths\n    val copy = tryCopyException(exception) ?: return exception\n    return copy.sanitizeStackTrace()\n}\n\nprivate fun <E : Throwable> E.sanitizeStackTrace(): E {\n    val stackTrace = stackTrace\n    val size = stackTrace.size\n    val lastIntrinsic = stackTrace.indexOfLast { stackTraceRecoveryClassName == it.className }\n    val startIndex = lastIntrinsic + 1\n    val endIndex = stackTrace.firstFrameIndex(baseContinuationImplClassName)\n    val adjustment = if (endIndex == -1) 0 else size - endIndex\n    val trace = Array(size - lastIntrinsic - adjustment) {\n        if (it == 0) {\n            ARTIFICIAL_FRAME\n        } else {\n            stackTrace[startIndex + it - 1]\n        }\n    }\n\n    setStackTrace(trace)\n    return this\n}\n\n@Suppress(\"NOTHING_TO_INLINE\") // Inline for better R8 optimization\ninternal actual inline fun <E : Throwable> recoverStackTrace(exception: E, continuation: Continuation<*>): E {\n    if (!RECOVER_STACK_TRACES || continuation !is CoroutineStackFrame) return exception\n    return recoverFromStackFrame(exception, continuation)\n}\n\nprivate fun <E : Throwable> recoverFromStackFrame(exception: E, continuation: CoroutineStackFrame): E {\n    /*\n    * Here we are checking whether exception has already recovered stacktrace.\n    * If so, we extract initial and merge recovered stacktrace and current one\n    */\n    val (cause, recoveredStacktrace) = exception.causeAndStacktrace()\n\n    // Try to create an exception of the same type and get stacktrace from continuation\n    val newException = tryCopyException(cause) ?: return exception\n    // Update stacktrace\n    val stacktrace = createStackTrace(continuation)\n    if (stacktrace.isEmpty()) return exception\n    // Merge if necessary\n    if (cause !== exception) {\n        mergeRecoveredTraces(recoveredStacktrace, stacktrace)\n    }\n    // Take recovered stacktrace, merge it with existing one if necessary and return\n    return createFinalException(cause, newException, stacktrace)\n}\n\n/*\n * Here we partially copy original exception stackTrace to make current one much prettier.\n * E.g. for\n * ```\n * fun foo() = async { error(...) }\n * suspend fun bar() = foo().await()\n * ```\n * we would like to produce following exception:\n * IllegalStateException\n *   at foo\n *   at kotlin.coroutines.resumeWith\n *   at _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\n *   at bar\n *   ...real stackTrace...\n * caused by \"IllegalStateException\" (original one)\n */\nprivate fun <E : Throwable> createFinalException(cause: E, result: E, resultStackTrace: ArrayDeque<StackTraceElement>): E {\n    resultStackTrace.addFirst(ARTIFICIAL_FRAME)\n    val causeTrace = cause.stackTrace\n    val size = causeTrace.firstFrameIndex(baseContinuationImplClassName)\n    if (size == -1) {\n        result.stackTrace = resultStackTrace.toTypedArray()\n        return result\n    }\n\n    val mergedStackTrace = arrayOfNulls<StackTraceElement>(resultStackTrace.size + size)\n    for (i in 0 until size) {\n        mergedStackTrace[i] = causeTrace[i]\n    }\n\n    for ((index, element) in resultStackTrace.withIndex()) {\n        mergedStackTrace[size + index] = element\n    }\n\n    result.stackTrace = mergedStackTrace\n    return result\n}\n\n/**\n * Find initial cause of the exception without restored stacktrace.\n * Returns intermediate stacktrace as well in order to avoid excess cloning of array as an optimization.\n */\nprivate fun <E : Throwable> E.causeAndStacktrace(): Pair<E, Array<StackTraceElement>> {\n    val cause = cause\n    return if (cause != null && cause.javaClass == javaClass) {\n        val currentTrace = stackTrace\n        if (currentTrace.any { it.isArtificial() })\n            cause as E to currentTrace\n        else this to emptyArray()\n    } else {\n        this to emptyArray()\n    }\n}\n\nprivate fun mergeRecoveredTraces(recoveredStacktrace: Array<StackTraceElement>, result: ArrayDeque<StackTraceElement>) {\n    // Merge two stacktraces and trim common prefix\n    val startIndex = recoveredStacktrace.indexOfFirst { it.isArtificial() } + 1\n    val lastFrameIndex = recoveredStacktrace.size - 1\n    for (i in lastFrameIndex downTo startIndex) {\n        val element = recoveredStacktrace[i]\n        if (element.elementWiseEquals(result.last)) {\n            result.removeLast()\n        }\n        result.addFirst(recoveredStacktrace[i])\n    }\n}\n\ninternal actual suspend inline fun recoverAndThrow(exception: Throwable): Nothing {\n    if (!RECOVER_STACK_TRACES) throw exception\n    suspendCoroutineUninterceptedOrReturn<Nothing> {\n        if (it !is CoroutineStackFrame) throw exception\n        throw recoverFromStackFrame(exception, it)\n    }\n}\n\n@PublishedApi\n@Suppress(\"NOTHING_TO_INLINE\") // Inline for better R8 optimizations\ninternal actual inline fun <E : Throwable> unwrap(exception: E): E =\n    if (!RECOVER_STACK_TRACES) exception else unwrapImpl(exception)\n\n@PublishedApi\ninternal fun <E : Throwable> unwrapImpl(exception: E): E {\n    val cause = exception.cause\n    // Fast-path to avoid array cloning\n    if (cause == null || cause.javaClass != exception.javaClass) {\n        return exception\n    }\n    // Slow path looks for artificial frames in a stack-trace\n    if (exception.stackTrace.any { it.isArtificial() }) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return cause as E\n    } else {\n        return exception\n    }\n}\n\nprivate fun createStackTrace(continuation: CoroutineStackFrame): ArrayDeque<StackTraceElement> {\n    val stack = ArrayDeque<StackTraceElement>()\n    continuation.getStackTraceElement()?.let { stack.add(it) }\n\n    var last = continuation\n    while (true) {\n        last = (last as? CoroutineStackFrame)?.callerFrame ?: break\n        last.getStackTraceElement()?.let { stack.add(it) }\n    }\n    return stack\n}\n\ninternal fun StackTraceElement.isArtificial() = className.startsWith(ARTIFICIAL_FRAME_PACKAGE_NAME)\nprivate fun Array<StackTraceElement>.firstFrameIndex(methodName: String) = indexOfFirst { methodName == it.className }\n\nprivate fun StackTraceElement.elementWiseEquals(e: StackTraceElement): Boolean {\n    /*\n     * In order to work on Java 9 where modules and classloaders of enclosing class\n     * are part of the comparison\n     */\n    return lineNumber == e.lineNumber && methodName == e.methodName\n            && fileName == e.fileName && className == e.className\n}\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\ninternal actual typealias CoroutineStackFrame = kotlin.coroutines.jvm.internal.CoroutineStackFrame\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\ninternal actual typealias StackTraceElement = java.lang.StackTraceElement\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\ninternal actual fun Throwable.initCause(cause: Throwable) {\n    // Resolved to member, verified by test\n    initCause(cause)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/Synchronized.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic actual typealias SynchronizedObject = Any\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic actual inline fun <T> synchronizedImpl(lock: SynchronizedObject, block: () -> T): T =\n    kotlin.synchronized(lock, block)\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/SystemProps.kt",
        "content": "@file:JvmName(\"SystemPropsKt\")\n@file:JvmMultifileClass\n\npackage kotlinx.coroutines.internal\n\n// number of processors at startup for consistent prop initialization\ninternal val AVAILABLE_PROCESSORS = Runtime.getRuntime().availableProcessors()\n\ninternal actual fun systemProp(\n    propertyName: String\n): String? =\n    try {\n        System.getProperty(propertyName)\n    } catch (e: SecurityException) {\n        null\n    }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/ThreadContext.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n@JvmField\ninternal val NO_THREAD_ELEMENTS = Symbol(\"NO_THREAD_ELEMENTS\")\n\n// Used when there are >= 2 active elements in the context\n@Suppress(\"UNCHECKED_CAST\")\nprivate class ThreadState(@JvmField val context: CoroutineContext, n: Int) {\n    private val values = arrayOfNulls<Any>(n)\n    private val elements = arrayOfNulls<ThreadContextElement<Any?>>(n)\n    private var i = 0\n\n    fun append(element: ThreadContextElement<*>, value: Any?) {\n        values[i] = value\n        elements[i++] = element as ThreadContextElement<Any?>\n    }\n\n    fun restore(context: CoroutineContext) {\n        for (i in elements.indices.reversed()) {\n            elements[i]!!.restoreThreadContext(context, values[i])\n        }\n    }\n}\n\n// Counts ThreadContextElements in the context\n// Any? here is Int | ThreadContextElement (when count is one)\nprivate val countAll =\n    fun (countOrElement: Any?, element: CoroutineContext.Element): Any? {\n        if (element is ThreadContextElement<*>) {\n            val inCount = countOrElement as? Int ?: 1\n            return if (inCount == 0) element else inCount + 1\n        }\n        return countOrElement\n    }\n\n// Find one (first) ThreadContextElement in the context, it is used when we know there is exactly one\nprivate val findOne =\n    fun (found: ThreadContextElement<*>?, element: CoroutineContext.Element): ThreadContextElement<*>? {\n        if (found != null) return found\n        return element as? ThreadContextElement<*>\n    }\n\n// Updates state for ThreadContextElements in the context using the given ThreadState\nprivate val updateState =\n    fun (state: ThreadState, element: CoroutineContext.Element): ThreadState {\n        if (element is ThreadContextElement<*>) {\n            state.append(element, element.updateThreadContext(state.context))\n        }\n        return state\n    }\n\ninternal actual fun threadContextElements(context: CoroutineContext): Any = context.fold(0, countAll)!!\n\n// countOrElement is pre-cached in dispatched continuation\n// returns NO_THREAD_ELEMENTS if the contest does not have any ThreadContextElements\ninternal fun updateThreadContext(context: CoroutineContext, countOrElement: Any?): Any? {\n    @Suppress(\"NAME_SHADOWING\")\n    val countOrElement = countOrElement ?: threadContextElements(context)\n    @Suppress(\"IMPLICIT_BOXING_IN_IDENTITY_EQUALS\")\n    return when {\n        countOrElement === 0 -> NO_THREAD_ELEMENTS // very fast path when there are no active ThreadContextElements\n        //    ^^^ identity comparison for speed, we know zero always has the same identity\n        countOrElement is Int -> {\n            // slow path for multiple active ThreadContextElements, allocates ThreadState for multiple old values\n            context.fold(ThreadState(context, countOrElement), updateState)\n        }\n        else -> {\n            // fast path for one ThreadContextElement (no allocations, no additional context scan)\n            @Suppress(\"UNCHECKED_CAST\")\n            val element = countOrElement as ThreadContextElement<Any?>\n            element.updateThreadContext(context)\n        }\n    }\n}\n\ninternal fun restoreThreadContext(context: CoroutineContext, oldState: Any?) {\n    when {\n        oldState === NO_THREAD_ELEMENTS -> return // very fast path when there are no ThreadContextElements\n        oldState is ThreadState -> {\n            // slow path with multiple stored ThreadContextElements\n            oldState.restore(context)\n        }\n        else -> {\n            // fast path for one ThreadContextElement, but need to find it\n            @Suppress(\"UNCHECKED_CAST\")\n            val element = context.fold(null, findOne) as ThreadContextElement<Any?>\n            element.restoreThreadContext(context, oldState)\n        }\n    }\n}\n\n// top-level data class for a nicer out-of-the-box toString representation and class name\n@PublishedApi\ninternal data class ThreadLocalKey(private val threadLocal: ThreadLocal<*>) : CoroutineContext.Key<ThreadLocalElement<*>>\n\ninternal class ThreadLocalElement<T>(\n    private val value: T,\n    private val threadLocal: ThreadLocal<T>\n) : ThreadContextElement<T> {\n    override val key: CoroutineContext.Key<*> = ThreadLocalKey(threadLocal)\n\n    override fun updateThreadContext(context: CoroutineContext): T {\n        val oldState = threadLocal.get()\n        threadLocal.set(value)\n        return oldState\n    }\n\n    override fun restoreThreadContext(context: CoroutineContext, oldState: T) {\n        threadLocal.set(oldState)\n    }\n\n    // this method is overridden to perform value comparison (==) on key\n    override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        return if (this.key == key) EmptyCoroutineContext else this\n    }\n\n    // this method is overridden to perform value comparison (==) on key\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? =\n        @Suppress(\"UNCHECKED_CAST\")\n        if (this.key == key) this as E else null\n\n    override fun toString(): String = \"ThreadLocal(value=$value, threadLocal = $threadLocal)\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/internal/ThreadLocal.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport java.lang.ThreadLocal\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\") // internal visibility\ninternal actual typealias CommonThreadLocal<T> = ThreadLocal<T>\n\ninternal actual fun<T> commonThreadLocal(name: Symbol): CommonThreadLocal<T> = ThreadLocal()\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/scheduling/CoroutineScheduler.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport java.io.*\nimport java.util.concurrent.*\nimport java.util.concurrent.locks.*\nimport kotlin.jvm.internal.Ref.ObjectRef\nimport kotlin.math.*\n\n/**\n * Coroutine scheduler (pool of shared threads) which primary target is to distribute dispatched coroutines\n * over worker threads, including both CPU-intensive and blocking tasks, in the most efficient manner.\n *\n * Current scheduler implementation has two optimization targets:\n * - Efficiency in the face of communication patterns (e.g. actors communicating via channel)\n * - Dynamic resizing to support blocking calls without re-dispatching coroutine to separate \"blocking\" thread pool.\n *\n * ### Structural overview\n *\n * Scheduler consists of [corePoolSize] worker threads to execute CPU-bound tasks and up to\n * [maxPoolSize] lazily created  threads to execute blocking tasks.\n * Every worker has a local queue in addition to a global scheduler queue\n * and the global queue has priority over local queue to avoid starvation of externally-submitted\n * (e.g. from Android UI thread) tasks.\n * Work-stealing is implemented on top of that queues to provide\n * even load distribution and illusion of centralized run queue.\n *\n * ### Scheduling policy\n *\n * When a coroutine is dispatched from within a scheduler worker, it's placed into the head of worker run queue.\n * If the head is not empty, the task from the head is moved to the tail. Though it is an unfair scheduling policy,\n * it effectively couples communicating coroutines into one and eliminates scheduling latency\n * that arises from placing tasks to the end of the queue.\n * Placing former head to the tail is necessary to provide semi-FIFO order, otherwise, queue degenerates to stack.\n * When a coroutine is dispatched from an external thread, it's put into the global queue.\n * The original idea with a single-slot LIFO buffer comes from Golang runtime scheduler by D. Vyukov.\n * It was proven to be \"fair enough\", performant and generally well accepted and initially was a significant inspiration\n * source for the coroutine scheduler.\n *\n * ### Work stealing and affinity\n *\n * To provide even tasks distribution worker tries to steal tasks from other workers queues\n * before parking when his local queue is empty.\n * A non-standard solution is implemented to provide tasks affinity: a task from FIFO buffer may be stolen\n * only if it is stale enough based on the value of [WORK_STEALING_TIME_RESOLUTION_NS].\n * For this purpose, monotonic global clock is used, and every task has associated with its submission time.\n * This approach shows outstanding results when coroutines are cooperative,\n * but as downside scheduler now depends on a high-resolution global clock,\n * which may limit scalability on NUMA machines. Tasks from LIFO buffer can be stolen on a regular basis.\n *\n * ### Thread management\n * One of the hardest parts of the scheduler is decentralized management of the threads with the progress guarantees\n * similar to the regular centralized executors.\n * The state of the threads consists of [controlState] and [parkedWorkersStack] fields.\n * The former field incorporates the amount of created threads, CPU-tokens and blocking tasks\n * that require a thread compensation,\n * while the latter represents intrusive versioned Treiber stack of idle workers.\n * When a worker cannot find any work, they first add themselves to the stack,\n * then re-scans the queue to avoid missing signals and then attempts to park\n * with additional rendezvous against unnecessary parking.\n * If a worker finds a task that it cannot yet steal due to time constraints, it stores this fact in its state\n * (to be uncounted when additional work is signalled) and parks for such duration.\n *\n * When a new task arrives in the scheduler (whether it is local or global queue),\n * either an idle worker is being signalled, or a new worker is attempted to be created.\n * (Only [corePoolSize] workers can be created for regular CPU tasks)\n *\n * ### Support for blocking tasks\n * The scheduler also supports the notion of [blocking][TASK_PROBABLY_BLOCKING] tasks.\n * When executing or enqueuing blocking tasks, the scheduler notifies or creates one more worker in\n * addition to core pool size, so at any given moment, it has [corePoolSize] threads (potentially not yet created)\n * to serve CPU-bound tasks. To properly guarantee liveness, the scheduler maintains\n * \"CPU permits\" -- [corePoolSize] special tokens that permit an arbitrary worker to execute and steal CPU-bound tasks.\n * When worker encounters blocking tasks, it basically hands off its permit to another thread (not directly though) to\n * keep invariant \"scheduler always has at least min(pending CPU tasks, core pool size)\n * and at most core pool size threads to execute CPU tasks\".\n * To avoid overprovision, workers without CPU permit are allowed to scan [globalBlockingQueue]\n * and steal **only** blocking tasks from other workers.\n *\n * The scheduler does not limit the count of pending blocking tasks, potentially creating up to [maxPoolSize] threads.\n * End users do not have access to the scheduler directly and can dispatch blocking tasks only with\n * [LimitingDispatcher] that does control concurrency level by its own mechanism.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal class CoroutineScheduler(\n    @JvmField val corePoolSize: Int,\n    @JvmField val maxPoolSize: Int,\n    @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,\n    @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME\n) : Executor, Closeable {\n    init {\n        require(corePoolSize >= MIN_SUPPORTED_POOL_SIZE) {\n            \"Core pool size $corePoolSize should be at least $MIN_SUPPORTED_POOL_SIZE\"\n        }\n        require(maxPoolSize >= corePoolSize) {\n            \"Max pool size $maxPoolSize should be greater than or equals to core pool size $corePoolSize\"\n        }\n        require(maxPoolSize <= MAX_SUPPORTED_POOL_SIZE) {\n            \"Max pool size $maxPoolSize should not exceed maximal supported number of threads $MAX_SUPPORTED_POOL_SIZE\"\n        }\n        require(idleWorkerKeepAliveNs > 0) {\n            \"Idle worker keep alive time $idleWorkerKeepAliveNs must be positive\"\n        }\n    }\n\n    @JvmField\n    val globalCpuQueue = GlobalQueue()\n\n    @JvmField\n    val globalBlockingQueue = GlobalQueue()\n\n    private fun addToGlobalQueue(task: Task): Boolean {\n        return if (task.isBlocking) {\n            globalBlockingQueue.addLast(task)\n        } else {\n            globalCpuQueue.addLast(task)\n        }\n    }\n\n    /**\n     * The stack of parker workers.\n     * Every worker registers itself in a stack before parking (if it was not previously registered),\n     * so it can be signalled when new tasks arrive.\n     * This is a form of intrusive garbage-free Treiber stack where [Worker] also is a stack node.\n     *\n     * The stack is better than a queue (even with the contention on top) because it unparks threads\n     * in most-recently used order, improving both performance and locality.\n     * Moreover, it decreases threads thrashing, if the pool has n threads when only n / 2 is required,\n     * the latter half will never be unparked and will terminate itself after [IDLE_WORKER_KEEP_ALIVE_NS].\n     *\n     * This long version consist of version bits with [PARKED_VERSION_MASK]\n     * and top worker thread index bits with [PARKED_INDEX_MASK].\n     */\n    private val parkedWorkersStack = atomic(0L)\n\n    /**\n     * Updates index of the worker at the top of [parkedWorkersStack].\n     * It always updates version to ensure interference with [parkedWorkersStackPop] operation\n     * that might have already decided to put this index to the top.\n     *\n     * Note, [newIndex] can be zero for the worker that is being terminated (removed from [workers]).\n     */\n    fun parkedWorkersStackTopUpdate(worker: Worker, oldIndex: Int, newIndex: Int) {\n        parkedWorkersStack.loop { top ->\n            val index = (top and PARKED_INDEX_MASK).toInt()\n            val updVersion = (top + PARKED_VERSION_INC) and PARKED_VERSION_MASK\n            val updIndex = if (index == oldIndex) {\n                if (newIndex == 0) {\n                    parkedWorkersStackNextIndex(worker)\n                } else {\n                    newIndex\n                }\n            } else {\n                index // no change to index, but update version\n            }\n            if (updIndex < 0) return@loop // retry\n            if (parkedWorkersStack.compareAndSet(top, updVersion or updIndex.toLong())) return\n        }\n    }\n\n    /**\n     * Pushes worker into [parkedWorkersStack].\n     * It does nothing is this worker is already physically linked to the stack.\n     * This method is invoked only from the worker thread itself.\n     * This invocation always precedes [LockSupport.parkNanos].\n     * See [Worker.tryPark].\n     *\n     * Returns `true` if worker was added to the stack by this invocation, `false` if it was already\n     * registered in the stack.\n     */\n    fun parkedWorkersStackPush(worker: Worker): Boolean {\n        if (worker.nextParkedWorker !== NOT_IN_STACK) return false // already in stack, bail out\n        /*\n         * The below loop can be entered only if this worker was not in the stack and, since no other thread\n         * can add it to the stack (only the worker itself), this invariant holds while this loop executes.\n         */\n        parkedWorkersStack.loop { top ->\n            val index = (top and PARKED_INDEX_MASK).toInt()\n            val updVersion = (top + PARKED_VERSION_INC) and PARKED_VERSION_MASK\n            val updIndex = worker.indexInArray\n            assert { updIndex != 0 } // only this worker can push itself, cannot be terminated\n            worker.nextParkedWorker = workers[index]\n            /*\n             * Other thread can be changing this worker's index at this point, but it\n             * also invokes parkedWorkersStackTopUpdate which updates version to make next CAS fail.\n             * Successful CAS of the stack top completes successful push.\n             */\n            if (parkedWorkersStack.compareAndSet(top, updVersion or updIndex.toLong())) return true\n        }\n    }\n\n    /**\n     * Pops worker from [parkedWorkersStack].\n     * It can be invoked concurrently from any thread that is looking for help and needs to unpark some worker.\n     * This invocation is always followed by an attempt to [LockSupport.unpark] resulting worker.\n     * See [tryUnpark].\n     */\n    private fun parkedWorkersStackPop(): Worker? {\n        parkedWorkersStack.loop { top ->\n            val index = (top and PARKED_INDEX_MASK).toInt()\n            val worker = workers[index] ?: return null // stack is empty\n            val updVersion = (top + PARKED_VERSION_INC) and PARKED_VERSION_MASK\n            val updIndex = parkedWorkersStackNextIndex(worker)\n            if (updIndex < 0) return@loop // retry\n            /*\n             * Other thread can be changing this worker's index at this point, but it\n             * also invokes parkedWorkersStackTopUpdate which updates version to make next CAS fail.\n             * Successful CAS of the stack top completes successful pop.\n             */\n            if (parkedWorkersStack.compareAndSet(top, updVersion or updIndex.toLong())) {\n                /*\n                 * We've just took worker out of the stack, but nextParkerWorker is not reset yet, so if a worker is\n                 * currently invoking parkedWorkersStackPush it would think it is in the stack and bail out without\n                 * adding itself again. It does not matter, since we are going it invoke unpark on the thread\n                 * that was popped out of parkedWorkersStack anyway.\n                 */\n                worker.nextParkedWorker = NOT_IN_STACK\n                return worker\n            }\n        }\n    }\n\n    /**\n     * Finds next usable index for [parkedWorkersStack]. The problem is that workers can\n     * be terminated at their [Worker.indexInArray] becomes zero, so they cannot be\n     * put at the top of the stack. In which case we are looking for next.\n     *\n     * Returns `index >= 0` or `-1` for retry.\n     */\n    private fun parkedWorkersStackNextIndex(worker: Worker): Int {\n        var next = worker.nextParkedWorker\n        findNext@ while (true) {\n            when {\n                next === NOT_IN_STACK -> return -1 // we are too late -- other thread popped this element, retry\n                next === null -> return 0 // stack becomes empty\n                else -> {\n                    val nextWorker = next as Worker\n                    val updIndex = nextWorker.indexInArray\n                    if (updIndex != 0) return updIndex // found good index for next worker\n                    // Otherwise, this worker was terminated and we cannot put it to top anymore, check next\n                    next = nextWorker.nextParkedWorker\n                }\n            }\n        }\n    }\n\n    /**\n     * State of worker threads.\n     * [workers] is a dynamic array of lazily created workers up to [maxPoolSize] workers.\n     * [createdWorkers] is count of already created workers (worker with index lesser than [createdWorkers] exists).\n     * [blockingTasks] is count of pending (either in the queue or being executed) blocking tasks.\n     *\n     * Workers array is also used as a lock for workers' creation and termination sequence.\n     *\n     * **NOTE**: `workers[0]` is always `null` (never used, works as sentinel value), so\n     * workers are 1-indexed, code path in [Worker.trySteal] is a bit faster and index swap during termination\n     * works properly.\n     *\n     * Initial size is `Dispatchers.Default` size * 2 to prevent unnecessary resizes for slightly or steadily loaded\n     * applications.\n     */\n    @JvmField\n    val workers = ResizableAtomicArray<Worker>((corePoolSize + 1) * 2)\n\n    /**\n     * The `Long` value describing the state of workers in this pool.\n     * Currently, includes created, CPU-acquired, and blocking workers, each occupying [BLOCKING_SHIFT] bits.\n     *\n     * State layout (highest to lowest bits):\n     * | --- number of cpu permits, 22 bits ---  | --- number of blocking tasks, 21 bits ---  | --- number of created threads, 21 bits ---  |\n     */\n    private val controlState = atomic(corePoolSize.toLong() shl CPU_PERMITS_SHIFT)\n\n    private val createdWorkers: Int inline get() = (controlState.value and CREATED_MASK).toInt()\n    private val availableCpuPermits: Int inline get() = availableCpuPermits(controlState.value)\n\n    private inline fun createdWorkers(state: Long): Int = (state and CREATED_MASK).toInt()\n    private inline fun blockingTasks(state: Long): Int = (state and BLOCKING_MASK shr BLOCKING_SHIFT).toInt()\n    inline fun availableCpuPermits(state: Long): Int = (state and CPU_PERMITS_MASK shr CPU_PERMITS_SHIFT).toInt()\n\n    // Guarded by synchronization\n    private inline fun incrementCreatedWorkers(): Int = createdWorkers(controlState.incrementAndGet())\n    private inline fun decrementCreatedWorkers(): Int = createdWorkers(controlState.getAndDecrement())\n\n    private inline fun incrementBlockingTasks() = controlState.addAndGet(1L shl BLOCKING_SHIFT)\n\n    private inline fun decrementBlockingTasks() {\n        controlState.addAndGet(-(1L shl BLOCKING_SHIFT))\n    }\n\n    private inline fun tryAcquireCpuPermit(): Boolean = controlState.loop { state ->\n        val available = availableCpuPermits(state)\n        if (available == 0) return false\n        val update = state - (1L shl CPU_PERMITS_SHIFT)\n        if (controlState.compareAndSet(state, update)) return true\n    }\n\n    private inline fun releaseCpuPermit() = controlState.addAndGet(1L shl CPU_PERMITS_SHIFT)\n\n    // This is used a \"stop signal\" for close and shutdown functions\n    private val _isTerminated = atomic(false)\n    val isTerminated: Boolean get() = _isTerminated.value\n\n    companion object {\n        // A symbol to mark workers that are not in parkedWorkersStack\n        @JvmField\n        val NOT_IN_STACK = Symbol(\"NOT_IN_STACK\")\n\n        // Worker ctl states\n        private const val PARKED = -1\n        private const val CLAIMED = 0\n        private const val TERMINATED = 1\n\n        // Masks of control state\n        private const val BLOCKING_SHIFT = 21 // 2M threads max\n        private const val CREATED_MASK: Long = (1L shl BLOCKING_SHIFT) - 1\n        private const val BLOCKING_MASK: Long = CREATED_MASK shl BLOCKING_SHIFT\n        private const val CPU_PERMITS_SHIFT = BLOCKING_SHIFT * 2\n        private const val CPU_PERMITS_MASK = CREATED_MASK shl CPU_PERMITS_SHIFT\n\n        internal const val MIN_SUPPORTED_POOL_SIZE = 1 // we support 1 for test purposes, but it is not usually used\n        internal const val MAX_SUPPORTED_POOL_SIZE = (1 shl BLOCKING_SHIFT) - 2\n\n        // Masks of parkedWorkersStack\n        private const val PARKED_INDEX_MASK = CREATED_MASK\n        private const val PARKED_VERSION_MASK = CREATED_MASK.inv()\n        private const val PARKED_VERSION_INC = 1L shl BLOCKING_SHIFT\n    }\n\n    override fun execute(command: Runnable) = dispatch(command)\n\n    override fun close() = shutdown(10_000L)\n\n    // Shuts down current scheduler and waits until all work is done and all threads are stopped.\n    fun shutdown(timeout: Long) {\n        // atomically set termination flag which is checked when workers are added or removed\n        if (!_isTerminated.compareAndSet(false, true)) return\n        // make sure we are not waiting for the current thread\n        val currentWorker = currentWorker()\n        // Capture # of created workers that cannot change anymore (mind the synchronized block!)\n        val created = synchronized(workers) { createdWorkers }\n        // Shutdown all workers with the only exception of the current thread\n        for (i in 1..created) {\n            val worker = workers[i]!!\n            if (worker !== currentWorker) {\n                // Note: this is java.lang.Thread.getState() of type java.lang.Thread.State\n                while (worker.getState() != Thread.State.TERMINATED) {\n                    LockSupport.unpark(worker)\n                    worker.join(timeout)\n                }\n                // Note: this is CoroutineScheduler.Worker.state of type CoroutineScheduler.WorkerState\n                assert { worker.state === WorkerState.TERMINATED } // Expected TERMINATED state\n                worker.localQueue.offloadAllWorkTo(globalBlockingQueue) // Doesn't actually matter which queue to use\n            }\n        }\n        // Make sure no more work is added to GlobalQueue from anywhere\n        globalBlockingQueue.close()\n        globalCpuQueue.close()\n        // Finish processing tasks from globalQueue and/or from this worker's local queue\n        while (true) {\n            val task = currentWorker?.findTask(true)\n                ?: globalCpuQueue.removeFirstOrNull()\n                ?: globalBlockingQueue.removeFirstOrNull()\n                ?: break\n            runSafely(task)\n        }\n        // Shutdown current thread\n        currentWorker?.tryReleaseCpu(WorkerState.TERMINATED)\n        // check & cleanup state\n        assert { availableCpuPermits == corePoolSize }\n        parkedWorkersStack.value = 0L\n        controlState.value = 0L\n    }\n\n    /**\n     * Dispatches execution of a runnable [block] with a hint to a scheduler whether\n     * this [block] may execute blocking operations (IO, system calls, locking primitives etc.)\n     *\n     * [taskContext] -- concurrency context of given [block].\n     * [tailDispatch] -- whether this [dispatch] call is the last action the (presumably) worker thread does in its current task.\n     * If `true`, then  the task will be dispatched in a FIFO manner and no additional workers will be requested,\n     * but only if the current thread is a corresponding worker thread.\n     * Note that caller cannot be ensured that it is being executed on worker thread for the following reasons:\n     *   - [CoroutineStart.UNDISPATCHED]\n     *   - Concurrent [close] that effectively shutdowns the worker thread\n     */\n    fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) {\n        trackTask() // this is needed for virtual time support\n        val task = createTask(block, taskContext)\n        val isBlockingTask = task.isBlocking\n        // Invariant: we increment counter **before** publishing the task\n        // so executing thread can safely decrement the number of blocking tasks\n        val stateSnapshot = if (isBlockingTask) incrementBlockingTasks() else 0\n        // try to submit the task to the local queue and act depending on the result\n        val currentWorker = currentWorker()\n        val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)\n        if (notAdded != null) {\n            if (!addToGlobalQueue(notAdded)) {\n                // Global queue is closed in the last step of close/shutdown -- no more tasks should be accepted\n                throw RejectedExecutionException(\"$schedulerName was terminated\")\n            }\n        }\n        val skipUnpark = tailDispatch && currentWorker != null\n        // Checking 'task' instead of 'notAdded' is completely okay\n        if (isBlockingTask) {\n            // Use state snapshot to better estimate the number of running threads\n            signalBlockingWork(stateSnapshot, skipUnpark = skipUnpark)\n        } else {\n            if (skipUnpark) return\n            signalCpuWork()\n        }\n    }\n\n    fun createTask(block: Runnable, taskContext: TaskContext): Task {\n        val nanoTime = schedulerTimeSource.nanoTime()\n        if (block is Task) {\n            block.submissionTime = nanoTime\n            block.taskContext = taskContext\n            return block\n        }\n        return TaskImpl(block, nanoTime, taskContext)\n    }\n\n    // NB: should only be called from 'dispatch' method due to blocking tasks increment\n    private fun signalBlockingWork(stateSnapshot: Long, skipUnpark: Boolean) {\n        if (skipUnpark) return\n        if (tryUnpark()) return\n        // Use state snapshot to avoid accidental thread overprovision\n        if (tryCreateWorker(stateSnapshot)) return\n        tryUnpark() // Try unpark again in case there was race between permit release and parking\n    }\n\n    fun signalCpuWork() {\n        if (tryUnpark()) return\n        if (tryCreateWorker()) return\n        tryUnpark()\n    }\n\n    private fun tryCreateWorker(state: Long = controlState.value): Boolean {\n        val created = createdWorkers(state)\n        val blocking = blockingTasks(state)\n        val cpuWorkers = (created - blocking).coerceAtLeast(0)\n        /*\n         * We check how many threads are there to handle non-blocking work,\n         * and create one more if we have not enough of them.\n         */\n        if (cpuWorkers < corePoolSize) {\n            val newCpuWorkers = createNewWorker()\n            // If we've created the first cpu worker and corePoolSize > 1 then create\n            // one more (second) cpu worker, so that stealing between them is operational\n            if (newCpuWorkers == 1 && corePoolSize > 1) createNewWorker()\n            if (newCpuWorkers > 0) return true\n        }\n        return false\n    }\n\n    private fun tryUnpark(): Boolean {\n        while (true) {\n            val worker = parkedWorkersStackPop() ?: return false\n            if (worker.workerCtl.compareAndSet(PARKED, CLAIMED)) {\n                LockSupport.unpark(worker)\n                return true\n            }\n        }\n    }\n\n    /**\n     * Returns the number of CPU workers after this function (including new worker) or\n     * 0 if no worker was created.\n     */\n    private fun createNewWorker(): Int {\n        val worker: Worker\n        return synchronized(workers) {\n            // Make sure we're not trying to resurrect terminated scheduler\n            if (isTerminated) return -1\n            val state = controlState.value\n            val created = createdWorkers(state)\n            val blocking = blockingTasks(state)\n            val cpuWorkers = (created - blocking).coerceAtLeast(0)\n            // Double check for overprovision\n            if (cpuWorkers >= corePoolSize) return 0\n            if (created >= maxPoolSize) return 0\n            // start & register new worker, commit index only after successful creation\n            val newIndex = createdWorkers + 1\n            require(newIndex > 0 && workers[newIndex] == null)\n            /*\n             * 1) Claim the slot (under a lock) by the newly created worker\n             * 2) Make it observable by increment created workers count\n             * 3) Only then start the worker, otherwise it may miss its own creation\n             */\n            worker = Worker(newIndex)\n            workers.setSynchronized(newIndex, worker)\n            require(newIndex == incrementCreatedWorkers())\n            cpuWorkers + 1\n        }.also { worker.start() } // Start worker when the lock is released to reduce contention, see #3652\n    }\n\n    /**\n     * Returns `null` if task was successfully added or an instance of the\n     * task that was not added or replaced (thus should be added to global queue).\n     */\n    private fun Worker?.submitToLocalQueue(task: Task, tailDispatch: Boolean): Task? {\n        if (this == null) return task\n        /*\n         * This worker could have been already terminated from this thread by close/shutdown and it should not\n         * accept any more tasks into its local queue.\n         */\n        if (state === WorkerState.TERMINATED) return task\n        // Do not add CPU tasks in local queue if we are not able to execute it\n        if (task.mode == TASK_NON_BLOCKING && state === WorkerState.BLOCKING) {\n            return task\n        }\n        mayHaveLocalTasks = true\n        return localQueue.add(task, fair = tailDispatch)\n    }\n\n    private fun currentWorker(): Worker? = (Thread.currentThread() as? Worker)?.takeIf { it.scheduler == this }\n\n    /**\n     * Returns a string identifying the state of this scheduler for nicer debugging.\n     * Note that this method is not atomic and represents rough state of pool.\n     *\n     * State of the queues:\n     * b for blocking, c for CPU, r for retiring.\n     * E.g. for [1b, 1b, 2c, 1d] means that pool has\n     * two blocking workers with queue size 1, one worker with CPU permit and queue size 1\n     * and one dormant (executing his local queue before parking) worker with queue size 1.\n     */\n    override fun toString(): String {\n        var parkedWorkers = 0\n        var blockingWorkers = 0\n        var cpuWorkers = 0\n        var dormant = 0\n        var terminated = 0\n        val queueSizes = arrayListOf<String>()\n        for (index in 1 until workers.currentLength()) {\n            val worker = workers[index] ?: continue\n            val queueSize = worker.localQueue.size\n            when (worker.state) {\n                WorkerState.PARKING -> ++parkedWorkers\n                WorkerState.BLOCKING -> {\n                    ++blockingWorkers\n                    queueSizes += queueSize.toString() + \"b\" // Blocking\n                }\n\n                WorkerState.CPU_ACQUIRED -> {\n                    ++cpuWorkers\n                    queueSizes += queueSize.toString() + \"c\" // CPU\n                }\n\n                WorkerState.DORMANT -> {\n                    ++dormant\n                    if (queueSize > 0) queueSizes += queueSize.toString() + \"d\" // Retiring\n                }\n\n                WorkerState.TERMINATED -> ++terminated\n            }\n        }\n        val state = controlState.value\n        return \"$schedulerName@$hexAddress[\" +\n            \"Pool Size {\" +\n            \"core = $corePoolSize, \" +\n            \"max = $maxPoolSize}, \" +\n            \"Worker States {\" +\n            \"CPU = $cpuWorkers, \" +\n            \"blocking = $blockingWorkers, \" +\n            \"parked = $parkedWorkers, \" +\n            \"dormant = $dormant, \" +\n            \"terminated = $terminated}, \" +\n            \"running workers queues = $queueSizes, \" +\n            \"global CPU queue size = ${globalCpuQueue.size}, \" +\n            \"global blocking queue size = ${globalBlockingQueue.size}, \" +\n            \"Control State {\" +\n            \"created workers= ${createdWorkers(state)}, \" +\n            \"blocking tasks = ${blockingTasks(state)}, \" +\n            \"CPUs acquired = ${corePoolSize - availableCpuPermits(state)}\" +\n            \"}]\"\n    }\n\n    fun runSafely(task: Task) {\n        try {\n            task.run()\n        } catch (e: Throwable) {\n            val thread = Thread.currentThread()\n            thread.uncaughtExceptionHandler.uncaughtException(thread, e)\n        } finally {\n            unTrackTask()\n        }\n    }\n\n    internal inner class Worker private constructor() : Thread() {\n        init {\n            isDaemon = true\n            /*\n             * `Dispatchers.Default` is used as *the* dispatcher in the containerized environments,\n             * isolated by their own classloaders. Workers are populated lazily, thus we are inheriting\n             * `Dispatchers.Default` context class loader here instead of using parent' thread one\n             * in order not to accidentally capture temporary application classloader.\n             */\n            contextClassLoader = this@CoroutineScheduler.javaClass.classLoader\n        }\n\n        // guarded by scheduler lock, index in workers array, 0 when not in array (terminated)\n        @Volatile // volatile for push/pop operation into parkedWorkersStack\n        var indexInArray = 0\n            set(index) {\n                name = \"$schedulerName-worker-${if (index == 0) \"TERMINATED\" else index.toString()}\"\n                field = index\n            }\n\n        constructor(index: Int) : this() {\n            indexInArray = index\n        }\n\n        inline val scheduler get() = this@CoroutineScheduler\n\n        @JvmField\n        val localQueue: WorkQueue = WorkQueue()\n\n        /**\n         * Slot that is used to steal tasks into to avoid re-adding them\n         * to the local queue. See [trySteal]\n         */\n        private val stolenTask: ObjectRef<Task?> = ObjectRef()\n\n        /**\n         * Worker state. **Updated only by this worker thread**.\n         * By default, worker is in DORMANT state in the case when it was created, but all CPU tokens or tasks were taken.\n         * Is used locally by the worker to maintain its own invariants.\n         */\n        @JvmField\n        var state = WorkerState.DORMANT\n\n        /**\n         * Worker control state responsible for worker claiming, parking and termination.\n         * List of states:\n         * [PARKED] -- worker is parked and can self-terminate after a termination deadline.\n         * [CLAIMED] -- worker is claimed by an external submitter.\n         * [TERMINATED] -- worker is terminated and no longer usable.\n         */\n        val workerCtl = atomic(CLAIMED)\n\n        /**\n         * It is set to the termination deadline when started doing [park] and it reset\n         * when there is a task. It serves as protection against spurious wakeups of parkNanos.\n         */\n        private var terminationDeadline = 0L\n\n        /**\n         * Reference to the next worker in the [parkedWorkersStack].\n         * It may be `null` if there is no next parked worker.\n         * This reference is set to [NOT_IN_STACK] when worker is physically not in stack.\n         */\n        @Volatile\n        var nextParkedWorker: Any? = NOT_IN_STACK\n\n        /*\n         * The delay until at least one task in other worker queues will become stealable.\n         */\n        private var minDelayUntilStealableTaskNs = 0L\n\n        /**\n         * The state of embedded Marsaglia xorshift random number generator, used for work-stealing purposes.\n         * It is initialized with a seed.\n         */\n        private var rngState: Int = run {\n            // This could've been Random.nextInt(), but we are shaving an extra initialization cost, see #4051\n            val seed = System.nanoTime().toInt()\n            // rngState shouldn't be zero, as required for the xorshift algorithm\n            if (seed != 0) return@run seed\n            42\n        }\n\n        /**\n         * Tries to acquire CPU token if worker doesn't have one\n         * @return whether worker acquired (or already had) CPU token\n         */\n        private fun tryAcquireCpuPermit(): Boolean = when {\n            state == WorkerState.CPU_ACQUIRED -> true\n            this@CoroutineScheduler.tryAcquireCpuPermit() -> {\n                state = WorkerState.CPU_ACQUIRED\n                true\n            }\n\n            else -> false\n        }\n\n        /**\n         * Releases CPU token if worker has any and changes state to [newState].\n         * Returns `true` if CPU permit was returned to the pool\n         */\n        fun tryReleaseCpu(newState: WorkerState): Boolean {\n            val previousState = state\n            val hadCpu = previousState == WorkerState.CPU_ACQUIRED\n            if (hadCpu) releaseCpuPermit()\n            if (previousState != newState) state = newState\n            return hadCpu\n        }\n\n        override fun run() = runWorker()\n\n        @JvmField\n        var mayHaveLocalTasks = false\n\n        private fun runWorker() {\n            var rescanned = false\n            while (!isTerminated && state != WorkerState.TERMINATED) {\n                val task = findTask(mayHaveLocalTasks)\n                // Task found. Execute and repeat\n                if (task != null) {\n                    rescanned = false\n                    minDelayUntilStealableTaskNs = 0L\n                    executeTask(task)\n                    continue\n                } else {\n                    mayHaveLocalTasks = false\n                }\n                /*\n                 * No tasks were found:\n                 * 1) Either at least one of the workers has stealable task in its FIFO-buffer with a stealing deadline.\n                 *    Then its deadline is stored in [minDelayUntilStealableTask]\n                 * // '2)' can be found below\n                 *\n                 * Then just park for that duration (ditto re-scanning).\n                 * While it could potentially lead to short (up to WORK_STEALING_TIME_RESOLUTION_NS ns) starvations,\n                 * excess unparks and managing \"one unpark per signalling\" invariant become unfeasible, instead we are going to resolve\n                 * it with \"spinning via scans\" mechanism.\n                 * NB: this short potential parking does not interfere with `tryUnpark`\n                 */\n                if (minDelayUntilStealableTaskNs != 0L) {\n                    if (!rescanned) {\n                        rescanned = true\n                    } else {\n                        rescanned = false\n                        tryReleaseCpu(WorkerState.PARKING)\n                        interrupted()\n                        LockSupport.parkNanos(minDelayUntilStealableTaskNs)\n                        minDelayUntilStealableTaskNs = 0L\n                    }\n                    continue\n                }\n                /*\n                 * 2) Or no tasks available, time to park and, potentially, shut down the thread.\n                 * Add itself to the stack of parked workers, re-scans all the queues\n                 * to avoid missing wake-up (requestCpuWorker) and either starts executing discovered tasks or parks itself awaiting for new tasks.\n                 */\n                tryPark()\n            }\n            tryReleaseCpu(WorkerState.TERMINATED)\n        }\n\n        /**\n         * See [runSingleTaskFromCurrentSystemDispatcher] for rationale and details.\n         * This is a fine-tailored method for a specific use-case not expected to be used widely.\n         */\n        fun runSingleTask(): Long {\n            val stateSnapshot = state\n            val isCpuThread = state == WorkerState.CPU_ACQUIRED\n            val task = if (isCpuThread) {\n                findCpuTask()\n            } else {\n                findBlockingTask()\n            }\n            if (task == null) {\n                if (minDelayUntilStealableTaskNs == 0L) return -1L\n                return minDelayUntilStealableTaskNs\n            }\n            runSafely(task)\n            if (!isCpuThread) decrementBlockingTasks()\n            assert { state == stateSnapshot }\n            return 0L\n        }\n\n        fun isIo() = state == WorkerState.BLOCKING\n\n        // Counterpart to \"tryUnpark\"\n        private fun tryPark() {\n            if (!inStack()) {\n                parkedWorkersStackPush(this)\n                return\n            }\n            workerCtl.value = PARKED // Update value once\n            /*\n             * inStack() prevents spurious wakeups, while workerCtl.value == PARKED\n             * prevents the following race:\n             *\n             * - T2 scans the queue, adds itself to the stack, goes to rescan\n             * - T2 suspends in 'workerCtl.value = PARKED' line\n             * - T1 pops T2 from the stack, claims workerCtl, suspends\n             * - T2 fails 'while (inStack())' check, goes to full rescan\n             * - T2 adds itself to the stack, parks\n             * - T1 unparks T2, bails out with success\n             * - T2 unparks and loops in 'while (inStack())'\n             */\n            while (inStack() && workerCtl.value == PARKED) { // Prevent spurious wakeups\n                if (isTerminated || state == WorkerState.TERMINATED) break\n                tryReleaseCpu(WorkerState.PARKING)\n                interrupted() // Cleanup interruptions\n                park()\n            }\n        }\n\n        private fun inStack(): Boolean = nextParkedWorker !== NOT_IN_STACK\n\n        private fun executeTask(task: Task) {\n            val taskMode = task.mode\n            idleReset(taskMode)\n            beforeTask(taskMode)\n            runSafely(task)\n            afterTask(taskMode)\n        }\n\n        private fun beforeTask(taskMode: Int) {\n            if (taskMode == TASK_NON_BLOCKING) return\n            // Always notify about new work when releasing CPU-permit to execute some blocking task\n            if (tryReleaseCpu(WorkerState.BLOCKING)) {\n                signalCpuWork()\n            }\n        }\n\n        private fun afterTask(taskMode: Int) {\n            if (taskMode == TASK_NON_BLOCKING) return\n            decrementBlockingTasks()\n            val currentState = state\n            // Shutdown sequence of blocking dispatcher\n            if (currentState !== WorkerState.TERMINATED) {\n                assert { currentState == WorkerState.BLOCKING } // \"Expected BLOCKING state, but has $currentState\"\n                state = WorkerState.DORMANT\n            }\n        }\n\n        /*\n         * Marsaglia xorshift RNG with period 2^32-1 for work stealing purposes.\n         * ThreadLocalRandom cannot be used to support Android and ThreadLocal<Random> is up to 15% slower on Ktor benchmarks\n         */\n        fun nextInt(upperBound: Int): Int {\n            var r = rngState\n            r = r xor (r shl 13)\n            r = r xor (r shr 17)\n            r = r xor (r shl 5)\n            rngState = r\n            val mask = upperBound - 1\n            // Fast path for power of two bound\n            if (mask and upperBound == 0) {\n                return r and mask\n            }\n            return (r and Int.MAX_VALUE) % upperBound\n        }\n\n        private fun park() {\n            // set termination deadline the first time we are here (it is reset in idleReset)\n            if (terminationDeadline == 0L) terminationDeadline = System.nanoTime() + idleWorkerKeepAliveNs\n            // actually park\n            LockSupport.parkNanos(idleWorkerKeepAliveNs)\n            // try terminate when we are idle past termination deadline\n            // note that comparison is written like this to protect against potential nanoTime wraparound\n            if (System.nanoTime() - terminationDeadline >= 0) {\n                terminationDeadline = 0L // if attempt to terminate worker fails we'd extend deadline again\n                tryTerminateWorker()\n            }\n        }\n\n        /**\n         * Stops execution of current thread and removes it from [createdWorkers].\n         */\n        private fun tryTerminateWorker() {\n            synchronized(workers) {\n                // Make sure we're not trying race with termination of scheduler\n                if (isTerminated) return\n                // Someone else terminated, bail out\n                if (createdWorkers <= corePoolSize) return\n                /*\n                 * See tryUnpark for state reasoning.\n                 * If this CAS fails, then we were successfully unparked by other worker and cannot terminate.\n                 */\n                if (!workerCtl.compareAndSet(PARKED, TERMINATED)) return\n                /*\n                 * At this point this thread is no longer considered as usable for scheduling.\n                 * We need multi-step choreography to reindex workers.\n                 *\n                 * 1) Read current worker's index and reset it to zero.\n                 */\n                val oldIndex = indexInArray\n                indexInArray = 0\n                /*\n                 * Now this worker cannot become the top of parkedWorkersStack, but it can\n                 * still be at the stack top via oldIndex.\n                 *\n                 * 2) Update top of stack if it was pointing to oldIndex and make sure no\n                 *    pending push/pop operation that might have already retrieved oldIndex could complete.\n                 */\n                parkedWorkersStackTopUpdate(this, oldIndex, 0)\n                /*\n                 * 3) Move last worker into an index in array that was previously occupied by this worker,\n                 *    if last worker was a different one (sic!).\n                 */\n                val lastIndex = decrementCreatedWorkers()\n                if (lastIndex != oldIndex) {\n                    val lastWorker = workers[lastIndex]!!\n                    workers.setSynchronized(oldIndex, lastWorker)\n                    lastWorker.indexInArray = oldIndex\n                    /*\n                     * Now lastWorker is available at both indices in the array, but it can\n                     * still be at the stack top on via its lastIndex\n                     *\n                     * 4) Update top of stack lastIndex -> oldIndex and make sure no\n                     *    pending push/pop operation that might have already retrieved lastIndex could complete.\n                     */\n                    parkedWorkersStackTopUpdate(lastWorker, lastIndex, oldIndex)\n                }\n                /*\n                 * 5) It is safe to clear reference from workers array now.\n                 */\n                workers.setSynchronized(lastIndex, null)\n            }\n            state = WorkerState.TERMINATED\n        }\n\n        // It is invoked by this worker when it finds a task\n        private fun idleReset(mode: Int) {\n            terminationDeadline = 0L // reset deadline for termination\n            if (state == WorkerState.PARKING) {\n                assert { mode == TASK_PROBABLY_BLOCKING }\n                state = WorkerState.BLOCKING\n            }\n        }\n\n        fun findTask(mayHaveLocalTasks: Boolean): Task? {\n            if (tryAcquireCpuPermit()) return findAnyTask(mayHaveLocalTasks)\n            /*\n             * If we can't acquire a CPU permit, attempt to find blocking task:\n             * - Check if our queue has one (maybe mixed in with CPU tasks)\n             * - Poll global and try steal\n             */\n            return findBlockingTask()\n        }\n\n        // NB: ONLY for runSingleTask method\n        private fun findBlockingTask(): Task? {\n            return localQueue.pollBlocking()\n                ?: globalBlockingQueue.removeFirstOrNull()\n                ?: trySteal(STEAL_BLOCKING_ONLY)\n        }\n\n        // NB: ONLY for runSingleTask method\n        private fun findCpuTask(): Task? {\n            return localQueue.pollCpu()\n                ?: globalBlockingQueue.removeFirstOrNull()\n                ?: trySteal(STEAL_CPU_ONLY)\n        }\n\n        private fun findAnyTask(scanLocalQueue: Boolean): Task? {\n            /*\n             * Anti-starvation mechanism: probabilistically poll either local\n             * or global queue to ensure progress for both external and internal tasks.\n             */\n            if (scanLocalQueue) {\n                val globalFirst = nextInt(2 * corePoolSize) == 0\n                if (globalFirst) pollGlobalQueues()?.let { return it }\n                localQueue.poll()?.let { return it }\n                if (!globalFirst) pollGlobalQueues()?.let { return it }\n            } else {\n                pollGlobalQueues()?.let { return it }\n            }\n            return trySteal(STEAL_ANY)\n        }\n\n        private fun pollGlobalQueues(): Task? {\n            if (nextInt(2) == 0) {\n                globalCpuQueue.removeFirstOrNull()?.let { return it }\n                return globalBlockingQueue.removeFirstOrNull()\n            } else {\n                globalBlockingQueue.removeFirstOrNull()?.let { return it }\n                return globalCpuQueue.removeFirstOrNull()\n            }\n        }\n\n        private fun trySteal(stealingMode: StealingMode): Task? {\n            val created = createdWorkers\n            // 0 to await an initialization and 1 to avoid excess stealing on single-core machines\n            if (created < 2) {\n                return null\n            }\n\n            var currentIndex = nextInt(created)\n            var minDelay = Long.MAX_VALUE\n            repeat(created) {\n                ++currentIndex\n                if (currentIndex > created) currentIndex = 1\n                val worker = workers[currentIndex]\n                if (worker !== null && worker !== this) {\n                    val stealResult = worker.localQueue.trySteal(stealingMode, stolenTask)\n                    if (stealResult == TASK_STOLEN) {\n                        val result = stolenTask.element\n                        stolenTask.element = null\n                        return result\n                    } else if (stealResult > 0) {\n                        minDelay = min(minDelay, stealResult)\n                    }\n                }\n            }\n            minDelayUntilStealableTaskNs = if (minDelay != Long.MAX_VALUE) minDelay else 0\n            return null\n        }\n    }\n\n    enum class WorkerState {\n        /**\n         * Has CPU token and either executes [TASK_NON_BLOCKING] task or tries to find one.\n         */\n        CPU_ACQUIRED,\n\n        /**\n         * Executing task with [TASK_PROBABLY_BLOCKING].\n         */\n        BLOCKING,\n\n        /**\n         * Currently parked.\n         */\n        PARKING,\n\n        /**\n         * Tries to execute its local work and then goes to infinite sleep as no longer needed worker.\n         */\n        DORMANT,\n\n        /**\n         * Terminal state, will no longer be used\n         */\n        TERMINATED\n    }\n}\n\n/**\n * Checks if the thread is part of a thread pool that supports coroutines.\n * This function is needed for integration with BlockHound.\n */\n@JvmName(\"isSchedulerWorker\")\ninternal fun isSchedulerWorker(thread: Thread) = thread is CoroutineScheduler.Worker\n\n/**\n * Checks if the thread is running a CPU-bound task.\n * This function is needed for integration with BlockHound.\n */\n@JvmName(\"mayNotBlock\")\ninternal fun mayNotBlock(thread: Thread) = thread is CoroutineScheduler.Worker &&\n    thread.state == CoroutineScheduler.WorkerState.CPU_ACQUIRED\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/scheduling/Deprecated.kt",
        "content": "@file:Suppress(\"unused\")\n\npackage kotlinx.coroutines.scheduling\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n/**\n * This API was \"public @InternalApi\" and leaked into Ktor enabled-by-default sources.\n * Since then, we refactored scheduler sources and its API and decided to get rid of it in\n * its current shape.\n *\n * To preserve backwards compatibility with Ktor 1.x, previous version of the code is\n * extracted here as is and isolated from the rest of code base, so R8 can get rid of it.\n *\n * It should be removed after Ktor 3.0.0 (EOL of Ktor 1.x) around 2022.\n */\n@PublishedApi\ninternal open class ExperimentalCoroutineDispatcher(\n    private val corePoolSize: Int,\n    private val maxPoolSize: Int,\n    private val idleWorkerKeepAliveNs: Long,\n    private val schedulerName: String = \"CoroutineScheduler\"\n) : ExecutorCoroutineDispatcher() {\n    public constructor(\n        corePoolSize: Int = CORE_POOL_SIZE,\n        maxPoolSize: Int = MAX_POOL_SIZE,\n        schedulerName: String = DEFAULT_SCHEDULER_NAME\n    ) : this(corePoolSize, maxPoolSize, IDLE_WORKER_KEEP_ALIVE_NS, schedulerName)\n\n    @Deprecated(message = \"Binary compatibility for Ktor 1.0-beta\", level = DeprecationLevel.HIDDEN)\n    public constructor(\n        corePoolSize: Int = CORE_POOL_SIZE,\n        maxPoolSize: Int = MAX_POOL_SIZE\n    ) : this(corePoolSize, maxPoolSize, IDLE_WORKER_KEEP_ALIVE_NS)\n\n    override val executor: Executor\n        get() = coroutineScheduler\n\n    // This is variable for test purposes, so that we can reinitialize from clean state\n    private var coroutineScheduler = createScheduler()\n\n    override fun dispatch(context: CoroutineContext, block: Runnable): Unit =\n        try {\n            coroutineScheduler.dispatch(block)\n        } catch (e: RejectedExecutionException) {\n            // CoroutineScheduler only rejects execution when it is being closed and this behavior is reserved\n            // for testing purposes, so we don't have to worry about cancelling the affected Job here.\n            DefaultExecutor.dispatch(context, block)\n        }\n\n    override fun dispatchYield(context: CoroutineContext, block: Runnable): Unit =\n        try {\n            coroutineScheduler.dispatch(block, tailDispatch = true)\n        } catch (e: RejectedExecutionException) {\n            // CoroutineScheduler only rejects execution when it is being closed and this behavior is reserved\n            // for testing purposes, so we don't have to worry about cancelling the affected Job here.\n            DefaultExecutor.dispatchYield(context, block)\n        }\n\n    override fun close(): Unit = coroutineScheduler.close()\n\n    override fun toString(): String {\n        return \"${super.toString()}[scheduler = $coroutineScheduler]\"\n    }\n\n    /**\n     * Creates a coroutine execution context with limited parallelism to execute tasks which may potentially block.\n     * Resulting [CoroutineDispatcher] doesn't own any resources (its threads) and provides a view of the original [ExperimentalCoroutineDispatcher],\n     * giving it additional hints to adjust its behaviour.\n     *\n     * @param parallelism parallelism level, indicating how many threads can execute tasks in the resulting dispatcher parallel.\n     */\n    fun blocking(parallelism: Int = 16): CoroutineDispatcher {\n        require(parallelism > 0) { \"Expected positive parallelism level, but have $parallelism\" }\n        return LimitingDispatcher(this, parallelism, null, TASK_PROBABLY_BLOCKING)\n    }\n\n    /**\n     * Creates a coroutine execution context with limited parallelism to execute CPU-intensive tasks.\n     * Resulting [CoroutineDispatcher] doesn't own any resources (its threads) and provides a view of the original [ExperimentalCoroutineDispatcher],\n     * giving it additional hints to adjust its behaviour.\n     *\n     * @param parallelism parallelism level, indicating how many threads can execute tasks in the resulting dispatcher parallel.\n     */\n    fun limited(parallelism: Int): CoroutineDispatcher {\n        require(parallelism > 0) { \"Expected positive parallelism level, but have $parallelism\" }\n        require(parallelism <= corePoolSize) { \"Expected parallelism level lesser than core pool size ($corePoolSize), but have $parallelism\" }\n        return LimitingDispatcher(this, parallelism, null, TASK_NON_BLOCKING)\n    }\n\n    internal fun dispatchWithContext(block: Runnable, context: TaskContext, tailDispatch: Boolean) {\n        try {\n            coroutineScheduler.dispatch(block, context, tailDispatch)\n        } catch (e: RejectedExecutionException) {\n            // CoroutineScheduler only rejects execution when it is being closed and this behavior is reserved\n            // for testing purposes, so we don't have to worry about cancelling the affected Job here.\n            // TaskContext shouldn't be lost here to properly invoke before/after task\n            DefaultExecutor.enqueue(coroutineScheduler.createTask(block, context))\n        }\n    }\n\n    private fun createScheduler() = CoroutineScheduler(corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName)\n}\n\nprivate class LimitingDispatcher(\n    private val dispatcher: ExperimentalCoroutineDispatcher,\n    private val parallelism: Int,\n    private val name: String?,\n    override val taskMode: Int\n) : ExecutorCoroutineDispatcher(), TaskContext, Executor {\n\n    private val queue = ConcurrentLinkedQueue<Runnable>()\n    private val inFlightTasks = atomic(0)\n\n    override val executor: Executor\n        get() = this\n\n    override fun execute(command: Runnable) = dispatch(command, false)\n\n    override fun close(): Unit = error(\"Close cannot be invoked on LimitingBlockingDispatcher\")\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) = dispatch(block, false)\n\n    private fun dispatch(block: Runnable, tailDispatch: Boolean) {\n        var taskToSchedule = block\n        while (true) {\n            // Commit in-flight tasks slot\n            val inFlight = inFlightTasks.incrementAndGet()\n\n            // Fast path, if parallelism limit is not reached, dispatch task and return\n            if (inFlight <= parallelism) {\n                dispatcher.dispatchWithContext(taskToSchedule, this, tailDispatch)\n                return\n            }\n\n            // Parallelism limit is reached, add task to the queue\n            queue.add(taskToSchedule)\n\n            /*\n             * We're not actually scheduled anything, so rollback committed in-flight task slot:\n             * If the amount of in-flight tasks is still above the limit, do nothing\n             * If the amount of in-flight tasks is lesser than parallelism, then\n             * it's a race with a thread which finished the task from the current context, we should resubmit the first task from the queue\n             * to avoid starvation.\n             *\n             * Race example #1 (TN is N-th thread, R is current in-flight tasks number), execution is sequential:\n             *\n             * T1: submit task, start execution, R == 1\n             * T2: commit slot for next task, R == 2\n             * T1: finish T1, R == 1\n             * T2: submit next task to local queue, decrement R, R == 0\n             * Without retries, task from T2 will be stuck in the local queue\n             */\n            if (inFlightTasks.decrementAndGet() >= parallelism) {\n                return\n            }\n\n            taskToSchedule = queue.poll() ?: return\n        }\n    }\n\n    override fun dispatchYield(context: CoroutineContext, block: Runnable) {\n        dispatch(block, tailDispatch = true)\n    }\n\n    override fun toString(): String {\n        return name ?: \"${super.toString()}[dispatcher = $dispatcher]\"\n    }\n\n    /**\n     * Tries to dispatch tasks which were blocked due to reaching parallelism limit if there is any.\n     *\n     * Implementation note: blocking tasks are scheduled in a fair manner (to local queue tail) to avoid\n     * non-blocking continuations starvation.\n     * E.g. for\n     * ```\n     * foo()\n     * blocking()\n     * bar()\n     * ```\n     * it's more profitable to execute bar at the end of `blocking` rather than pending blocking task\n     */\n    override fun afterTask() {\n        var next = queue.poll()\n        // If we have pending tasks in current blocking context, dispatch first\n        if (next != null) {\n            dispatcher.dispatchWithContext(next, this, true)\n            return\n        }\n        inFlightTasks.decrementAndGet()\n\n        /*\n         * Re-poll again and try to submit task if it's required otherwise tasks may be stuck in the local queue.\n         * Race example #2 (TN is N-th thread, R is current in-flight tasks number), execution is sequential:\n         * T1: submit task, start execution, R == 1\n         * T2: commit slot for next task, R == 2\n         * T1: finish T1, poll queue (it's still empty), R == 2\n         * T2: submit next task to the local queue, decrement R, R == 1\n         * T1: decrement R, finish. R == 0\n         *\n         * The task from T2 is stuck is the local queue\n         */\n        next = queue.poll() ?: return\n        dispatch(next, true)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/scheduling/Dispatcher.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n// Instance of Dispatchers.Default\ninternal object DefaultScheduler : SchedulerCoroutineDispatcher(\n    CORE_POOL_SIZE, MAX_POOL_SIZE,\n    IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME\n) {\n\n    @ExperimentalCoroutinesApi\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        parallelism.checkParallelism()\n        if (parallelism >= CORE_POOL_SIZE) return this\n        return super.limitedParallelism(parallelism)\n    }\n\n    // Shuts down the dispatcher, used only by Dispatchers.shutdown()\n    internal fun shutdown() {\n        super.close()\n    }\n\n    // Overridden in case anyone writes (Dispatchers.Default as ExecutorCoroutineDispatcher).close()\n    override fun close() {\n        throw UnsupportedOperationException(\"Dispatchers.Default cannot be closed\")\n    }\n\n    override fun toString(): String = \"Dispatchers.Default\"\n}\n\n// The unlimited instance of Dispatchers.IO that utilizes all the threads CoroutineScheduler provides\nprivate object UnlimitedIoScheduler : CoroutineDispatcher() {\n\n    @InternalCoroutinesApi\n    override fun dispatchYield(context: CoroutineContext, block: Runnable) {\n        DefaultScheduler.dispatchWithContext(block, BlockingContext, true)\n    }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        DefaultScheduler.dispatchWithContext(block, BlockingContext, false)\n    }\n\n    @ExperimentalCoroutinesApi\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        parallelism.checkParallelism()\n        if (parallelism >= MAX_POOL_SIZE) return this\n        return super.limitedParallelism(parallelism)\n    }\n}\n\n// Dispatchers.IO\ninternal object DefaultIoScheduler : ExecutorCoroutineDispatcher(), Executor {\n\n    private val default = UnlimitedIoScheduler.limitedParallelism(\n        systemProp(\n            IO_PARALLELISM_PROPERTY_NAME,\n            64.coerceAtLeast(AVAILABLE_PROCESSORS)\n        )\n    )\n\n    override val executor: Executor\n        get() = this\n\n    override fun execute(command: java.lang.Runnable) = dispatch(EmptyCoroutineContext, command)\n\n    @ExperimentalCoroutinesApi\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        // See documentation to Dispatchers.IO for the rationale\n        return UnlimitedIoScheduler.limitedParallelism(parallelism)\n    }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        default.dispatch(context, block)\n    }\n\n    @InternalCoroutinesApi\n    override fun dispatchYield(context: CoroutineContext, block: Runnable) {\n        default.dispatchYield(context, block)\n    }\n\n    override fun close() {\n        error(\"Cannot be invoked on Dispatchers.IO\")\n    }\n\n    override fun toString(): String = \"Dispatchers.IO\"\n}\n\n// Instantiated in tests so we can test it in isolation\ninternal open class SchedulerCoroutineDispatcher(\n    private val corePoolSize: Int = CORE_POOL_SIZE,\n    private val maxPoolSize: Int = MAX_POOL_SIZE,\n    private val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,\n    private val schedulerName: String = \"CoroutineScheduler\",\n) : ExecutorCoroutineDispatcher() {\n\n    override val executor: Executor\n        get() = coroutineScheduler\n\n    // This is variable for test purposes, so that we can reinitialize from clean state\n    private var coroutineScheduler = createScheduler()\n\n    private fun createScheduler() =\n        CoroutineScheduler(corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName)\n\n    override fun dispatch(context: CoroutineContext, block: Runnable): Unit = coroutineScheduler.dispatch(block)\n\n    override fun dispatchYield(context: CoroutineContext, block: Runnable): Unit =\n        coroutineScheduler.dispatch(block, tailDispatch = true)\n\n    internal fun dispatchWithContext(block: Runnable, context: TaskContext, tailDispatch: Boolean) {\n        coroutineScheduler.dispatch(block, context, tailDispatch)\n    }\n\n    override fun close() {\n        coroutineScheduler.close()\n    }\n\n    // fot tests only\n    @Synchronized\n    internal fun usePrivateScheduler() {\n        coroutineScheduler.shutdown(1_000L)\n        coroutineScheduler = createScheduler()\n    }\n\n    // for tests only\n    @Synchronized\n    internal fun shutdown(timeout: Long) {\n        coroutineScheduler.shutdown(timeout)\n    }\n\n    // for tests only\n    internal fun restore() = usePrivateScheduler() // recreate scheduler\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/scheduling/Tasks.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport java.util.concurrent.*\n\n\n/**\n * The name of the default scheduler. The names of the worker threads of [Dispatchers.Default] have it as their prefix.\n */\n@JvmField\ninternal val DEFAULT_SCHEDULER_NAME = systemProp(\n    \"kotlinx.coroutines.scheduler.default.name\", \"DefaultDispatcher\"\n)\n\n// 100us as default\n@JvmField\ninternal val WORK_STEALING_TIME_RESOLUTION_NS = systemProp(\n    \"kotlinx.coroutines.scheduler.resolution.ns\", 100000L\n)\n\n/**\n * The maximum number of threads allocated for CPU-bound tasks at the default set of dispatchers.\n *\n * NOTE: we coerce default to at least two threads to give us chances that multi-threading problems\n * get reproduced even on a single-core machine, but support explicit setting of 1 thread scheduler if needed\n */\n@JvmField\ninternal val CORE_POOL_SIZE = systemProp(\n    \"kotlinx.coroutines.scheduler.core.pool.size\",\n    AVAILABLE_PROCESSORS.coerceAtLeast(2),\n    minValue = CoroutineScheduler.MIN_SUPPORTED_POOL_SIZE\n)\n\n/** The maximum number of threads allocated for blocking tasks at the default set of dispatchers. */\n@JvmField\ninternal val MAX_POOL_SIZE = systemProp(\n    \"kotlinx.coroutines.scheduler.max.pool.size\",\n    CoroutineScheduler.MAX_SUPPORTED_POOL_SIZE,\n    maxValue = CoroutineScheduler.MAX_SUPPORTED_POOL_SIZE\n)\n\n@JvmField\ninternal val IDLE_WORKER_KEEP_ALIVE_NS = TimeUnit.SECONDS.toNanos(\n    systemProp(\"kotlinx.coroutines.scheduler.keep.alive.sec\", 60L)\n)\n\n@JvmField\ninternal var schedulerTimeSource: SchedulerTimeSource = NanoTimeSource\n\n/**\n * Marker indicating that task is CPU-bound and will not block\n */\ninternal const val TASK_NON_BLOCKING = 0\n\n/**\n * Marker indicating that task may potentially block, thus giving scheduler a hint that additional thread may be required\n */\ninternal const val TASK_PROBABLY_BLOCKING = 1\n\ninternal interface TaskContext {\n    val taskMode: Int // TASK_XXX\n    fun afterTask()\n}\n\nprivate class TaskContextImpl(override val taskMode: Int): TaskContext {\n    override fun afterTask() {\n        // Nothing for non-blocking context\n    }\n}\n\n@JvmField\ninternal val NonBlockingContext: TaskContext = TaskContextImpl(TASK_NON_BLOCKING)\n\n@JvmField\ninternal val BlockingContext: TaskContext = TaskContextImpl(TASK_PROBABLY_BLOCKING)\n\n@PublishedApi\ninternal abstract class Task internal constructor(\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @JvmField var submissionTime: Long,\n    // Used by the IDEA debugger via reflection and must be kept binary-compatible, see KTIJ-24102\n    @JvmField internal var taskContext: TaskContext\n) : Runnable {\n    internal constructor() : this(0, NonBlockingContext)\n    internal inline val mode: Int get() = taskContext.taskMode // TASK_XXX\n}\n\ninternal inline val Task.isBlocking get() = taskContext.taskMode == TASK_PROBABLY_BLOCKING\n\n// Non-reusable Task implementation to wrap Runnable instances that do not otherwise implement task\ninternal class TaskImpl(\n    @JvmField val block: Runnable,\n    submissionTime: Long,\n    taskContext: TaskContext\n) : Task(submissionTime, taskContext) {\n    override fun run() {\n        try {\n            block.run()\n        } finally {\n            taskContext.afterTask()\n        }\n    }\n\n    override fun toString(): String =\n        \"Task[${block.classSimpleName}@${block.hexAddress}, $submissionTime, $taskContext]\"\n}\n\n// Open for tests\ninternal class GlobalQueue : LockFreeTaskQueue<Task>(singleConsumer = false)\n\n// Was previously TimeSource, renamed due to KT-42625 and KT-23727\ninternal abstract class SchedulerTimeSource {\n    abstract fun nanoTime(): Long\n}\n\ninternal object NanoTimeSource : SchedulerTimeSource() {\n    override fun nanoTime() = System.nanoTime()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/src/scheduling/WorkQueue.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport java.util.concurrent.atomic.*\nimport kotlin.jvm.internal.Ref.ObjectRef\n\ninternal const val BUFFER_CAPACITY_BASE = 7\ninternal const val BUFFER_CAPACITY = 1 shl BUFFER_CAPACITY_BASE\ninternal const val MASK = BUFFER_CAPACITY - 1 // 128 by default\n\ninternal const val TASK_STOLEN = -1L\ninternal const val NOTHING_TO_STEAL = -2L\n\ninternal typealias StealingMode = Int\ninternal const val STEAL_ANY: StealingMode = 3\ninternal const val STEAL_CPU_ONLY: StealingMode = 2\ninternal const val STEAL_BLOCKING_ONLY: StealingMode = 1\n\ninternal inline val Task.maskForStealingMode: Int\n    get() = if (isBlocking) STEAL_BLOCKING_ONLY else STEAL_CPU_ONLY\n\n/**\n * Tightly coupled with [CoroutineScheduler] queue of pending tasks, but extracted to separate file for simplicity.\n * At any moment queue is used only by [CoroutineScheduler.Worker] threads, has only one producer (worker owning this queue)\n * and any amount of consumers, other pool workers which are trying to steal work.\n *\n * ### Fairness\n *\n * [WorkQueue] provides semi-FIFO order, but with priority for most recently submitted task assuming\n * that these two (current one and submitted) are communicating and sharing state thus making such communication extremely fast.\n * E.g. submitted jobs [1, 2, 3, 4] will be executed in [4, 1, 2, 3] order.\n *\n * ### Algorithm and implementation details\n * This is a regular SPMC bounded queue with the additional property that tasks can be removed from the middle of the queue\n * (scheduler workers without a CPU permit steal blocking tasks via this mechanism). Such property enforces us to use CAS in\n * order to properly claim value from the buffer.\n * Moreover, [Task] objects are reusable, so it may seem that this queue is prone to ABA problem.\n * Indeed, it formally has ABA-problem, but the whole processing logic is written in the way that such ABA is harmless.\n * I have discovered a truly marvelous proof of this, which this KDoc is too narrow to contain.\n */\ninternal class WorkQueue {\n\n    /*\n     * We read two independent counter here.\n     * Producer index is incremented only by owner\n     * Consumer index is incremented both by owner and external threads\n     *\n     * The only harmful race is:\n     * [T1] readProducerIndex (1) preemption(2) readConsumerIndex(5)\n     * [T2] changeProducerIndex (3)\n     * [T3] changeConsumerIndex (4)\n     *\n     * Which can lead to resulting size being negative or bigger than actual size at any moment of time.\n     * This is in general harmless because steal will be blocked by timer.\n     * Negative sizes can be observed only when non-owner reads the size, which happens only\n     * for diagnostic toString().\n     */\n    private val bufferSize: Int get() = producerIndex.value - consumerIndex.value\n    internal val size: Int get() = if (lastScheduledTask.value != null) bufferSize + 1 else bufferSize\n    private val buffer: AtomicReferenceArray<Task?> = AtomicReferenceArray(BUFFER_CAPACITY)\n    private val lastScheduledTask = atomic<Task?>(null)\n\n    private val producerIndex = atomic(0)\n    private val consumerIndex = atomic(0)\n    // Shortcut to avoid scanning queue without blocking tasks\n    private val blockingTasksInBuffer = atomic(0)\n\n    /**\n     * Retrieves and removes task from the head of the queue\n     * Invariant: this method is called only by the owner of the queue.\n     */\n    fun poll(): Task? = lastScheduledTask.getAndSet(null) ?: pollBuffer()\n\n    /**\n     * Invariant: Called only by the owner of the queue, returns\n     * `null` if task was added, task that wasn't added otherwise.\n     */\n    fun add(task: Task, fair: Boolean = false): Task? {\n        if (fair) return addLast(task)\n        val previous = lastScheduledTask.getAndSet(task) ?: return null\n        return addLast(previous)\n    }\n\n    /**\n     * Invariant: Called only by the owner of the queue, returns\n     * `null` if task was added, task that wasn't added otherwise.\n     */\n    private fun addLast(task: Task): Task? {\n        if (bufferSize == BUFFER_CAPACITY - 1) return task\n        if (task.isBlocking) blockingTasksInBuffer.incrementAndGet()\n        val nextIndex = producerIndex.value and MASK\n        /*\n         * If current element is not null then we're racing with a really slow consumer that committed the consumer index,\n         * but hasn't yet nulled out the slot, effectively preventing us from using it.\n         * Such situations are very rare in practise (although possible) and we decided to give up a progress guarantee\n         * to have a stronger invariant \"add to queue with bufferSize == 0 is always successful\".\n         * This algorithm can still be wait-free for add, but if and only if tasks are not reusable, otherwise\n         * nulling out the buffer wouldn't be possible.\n         */\n        while (buffer[nextIndex] != null) {\n            Thread.yield()\n        }\n        buffer.lazySet(nextIndex, task)\n        producerIndex.incrementAndGet()\n        return null\n    }\n\n    /**\n     * Tries stealing from this queue into the [stolenTaskRef] argument.\n     *\n     * Returns [NOTHING_TO_STEAL] if queue has nothing to steal, [TASK_STOLEN] if at least task was stolen\n     * or positive value of how many nanoseconds should pass until the head of this queue will be available to steal.\n     *\n     * [StealingMode] controls what tasks to steal:\n     * - [STEAL_ANY] is default mode for scheduler, task from the head (in FIFO order) is stolen\n     * - [STEAL_BLOCKING_ONLY] is mode for stealing *an arbitrary* blocking task, which is used by the scheduler when helping in Dispatchers.IO mode\n     * - [STEAL_CPU_ONLY] is a kludge for `runSingleTaskFromCurrentSystemDispatcher`\n     */\n    fun trySteal(stealingMode: StealingMode, stolenTaskRef: ObjectRef<Task?>): Long {\n        val task = when (stealingMode) {\n            STEAL_ANY -> pollBuffer()\n            else -> stealWithExclusiveMode(stealingMode)\n        }\n\n        if (task != null) {\n            stolenTaskRef.element = task\n            return TASK_STOLEN\n        }\n        return tryStealLastScheduled(stealingMode, stolenTaskRef)\n    }\n\n    // Steal only tasks of a particular kind, potentially invoking full queue scan\n    private fun stealWithExclusiveMode(stealingMode: StealingMode): Task? {\n        var start = consumerIndex.value\n        val end = producerIndex.value\n        val onlyBlocking = stealingMode == STEAL_BLOCKING_ONLY\n        // Bail out if there is no blocking work for us\n        while (start != end) {\n            if (onlyBlocking && blockingTasksInBuffer.value == 0) return null\n            return tryExtractFromTheMiddle(start++, onlyBlocking) ?: continue\n        }\n\n        return null\n    }\n\n    // Polls for blocking task, invoked only by the owner\n    // NB: ONLY for runSingleTask method\n    fun pollBlocking(): Task? = pollWithExclusiveMode(onlyBlocking = true /* only blocking */)\n\n    // Polls for CPU task, invoked only by the owner\n    // NB: ONLY for runSingleTask method\n    fun pollCpu(): Task? = pollWithExclusiveMode(onlyBlocking = false /* only cpu */)\n\n    private fun pollWithExclusiveMode(/* Only blocking OR only CPU */ onlyBlocking: Boolean): Task? {\n        while (true) { // Poll the slot\n            val lastScheduled = lastScheduledTask.value ?: break\n            if (lastScheduled.isBlocking != onlyBlocking) break\n            if (lastScheduledTask.compareAndSet(lastScheduled, null)) {\n                return lastScheduled\n            } // Failed -> someone else stole it\n        }\n\n        // Failed to poll the slot, scan the queue\n        val start = consumerIndex.value\n        var end = producerIndex.value\n        // Bail out if there is no blocking work for us\n        while (start != end) {\n            if (onlyBlocking && blockingTasksInBuffer.value == 0) return null\n            val task = tryExtractFromTheMiddle(--end, onlyBlocking)\n            if (task != null) {\n                return task\n            }\n        }\n        return null\n    }\n\n    private fun tryExtractFromTheMiddle(index: Int, onlyBlocking: Boolean): Task? {\n        val arrayIndex = index and MASK\n        val value = buffer[arrayIndex]\n        if (value != null && value.isBlocking == onlyBlocking && buffer.compareAndSet(arrayIndex, value, null)) {\n            if (onlyBlocking) blockingTasksInBuffer.decrementAndGet()\n            return value\n        }\n        return null\n    }\n\n    fun offloadAllWorkTo(globalQueue: GlobalQueue) {\n        lastScheduledTask.getAndSet(null)?.let { globalQueue.addLast(it) }\n        while (pollTo(globalQueue)) {\n            // Steal everything\n        }\n    }\n\n    /**\n     * Contract on return value is the same as for [trySteal]\n     */\n    private fun tryStealLastScheduled(stealingMode: StealingMode, stolenTaskRef: ObjectRef<Task?>): Long {\n        while (true) {\n            val lastScheduled = lastScheduledTask.value ?: return NOTHING_TO_STEAL\n            if ((lastScheduled.maskForStealingMode and stealingMode) == 0) {\n                return NOTHING_TO_STEAL\n            }\n\n            // TODO time wraparound ?\n            val time = schedulerTimeSource.nanoTime()\n            val staleness = time - lastScheduled.submissionTime\n            if (staleness < WORK_STEALING_TIME_RESOLUTION_NS) {\n                return WORK_STEALING_TIME_RESOLUTION_NS - staleness\n            }\n\n            /*\n             * If CAS has failed, either someone else had stolen this task or the owner executed this task\n             * and dispatched another one. In the latter case we should retry to avoid missing task.\n             */\n            if (lastScheduledTask.compareAndSet(lastScheduled, null)) {\n                stolenTaskRef.element = lastScheduled\n                return TASK_STOLEN\n            }\n            continue\n        }\n    }\n\n    private fun pollTo(queue: GlobalQueue): Boolean {\n        val task = pollBuffer() ?: return false\n        queue.addLast(task)\n        return true\n    }\n\n    private fun pollBuffer(): Task? {\n        while (true) {\n            val tailLocal = consumerIndex.value\n            if (tailLocal - producerIndex.value == 0) return null\n            val index = tailLocal and MASK\n            if (consumerIndex.compareAndSet(tailLocal, tailLocal + 1)) {\n                // Nulls are allowed when blocking tasks are stolen from the middle of the queue.\n                val value = buffer.getAndSet(index, null) ?: continue\n                value.decrementIfBlocking()\n                return value\n            }\n        }\n    }\n\n    private fun Task?.decrementIfBlocking() {\n        if (this != null && isBlocking) {\n            val value = blockingTasksInBuffer.decrementAndGet()\n            assert { value >= 0 }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/AbstractLincheckTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.jetbrains.kotlinx.lincheck.*\nimport org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*\nimport org.jetbrains.kotlinx.lincheck.strategy.stress.*\nimport org.junit.*\n\nabstract class AbstractLincheckTest {\n    open fun <O: Options<O, *>> O.customize(isStressTest: Boolean): O = this\n    open fun ModelCheckingOptions.customize(isStressTest: Boolean): ModelCheckingOptions = this\n    open fun StressOptions.customize(isStressTest: Boolean): StressOptions = this\n\n    @Test\n    fun modelCheckingTest() = ModelCheckingOptions()\n        .iterations(20 * stressTestMultiplierSqrt)\n        .invocationsPerIteration(1_000 * stressTestMultiplierSqrt)\n        .commonConfiguration()\n        .customize(isStressTest)\n        .check(this::class)\n\n    @Test\n    fun stressTest() = StressOptions()\n        .iterations(20 * stressTestMultiplierSqrt)\n        .invocationsPerIteration(1_000 * stressTestMultiplierSqrt)\n        .commonConfiguration()\n        .customize(isStressTest)\n        .check(this::class)\n\n    private fun <O : Options<O, *>> O.commonConfiguration(): O = this\n        .actorsBefore(if (isStressTest) 3 else 1)\n        // All the bugs we have discovered so far\n        // were reproducible on at most 3 threads\n        .threads(3)\n        // 3 operations per thread is sufficient,\n        // while increasing this number declines\n        // the model checking coverage.\n        .actorsPerThread(if (isStressTest) 3 else 2)\n        .actorsAfter(if (isStressTest) 3 else 0)\n        .customize(isStressTest)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/AsyncJvmTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\n\nclass AsyncJvmTest : TestBase() {\n    // We have the same test in common module, but the maintainer uses this particular file\n    // and semi-automatically types cmd+N + AsyncJvm in order to duck-tape any JVM samples/repros,\n    // please do not remove this test\n\n    @Test\n    fun testAsyncWithFinally() = runTest {\n        expect(1)\n\n        @Suppress(\"UNREACHABLE_CODE\")\n        val d = async {\n            expect(3)\n            try {\n                yield() // to main, will cancel\n            } finally {\n                expect(6) // will go there on await\n                return@async \"Fail\" // result will not override cancellation\n            }\n            expectUnreached()\n            \"Fail2\"\n        }\n        expect(2)\n        yield() // to async\n        expect(4)\n        check(d.isActive && !d.isCompleted && !d.isCancelled)\n        d.cancel()\n        check(!d.isActive && !d.isCompleted && d.isCancelled)\n        check(!d.isActive && !d.isCompleted && d.isCancelled)\n        expect(5)\n        try {\n            d.await() // awaits\n            expectUnreached() // does not complete normally\n        } catch (e: Throwable) {\n            expect(7)\n            check(e is CancellationException)\n        }\n        check(!d.isActive && d.isCompleted && d.isCancelled)\n        finish(8)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/AwaitJvmTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\n\nclass AwaitJvmTest : TestBase() {\n    @Test\n    public fun testSecondLeak() = runTest {\n        // This test is to make sure that handlers installed on the second deferred do not leak\n        val d1 = CompletableDeferred<Int>()\n        val d2 = CompletableDeferred<Int>()\n        d1.completeExceptionally(TestException()) // first is crashed\n        val iterations = 3_000_000 * stressTestMultiplier\n        for (iter in 1..iterations) {\n            try {\n                awaitAll(d1, d2)\n                expectUnreached()\n            } catch (e: TestException) {\n                expect(iter)\n            }\n        }\n        finish(iterations + 1)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/AwaitStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\n\nclass AwaitStressTest : TestBase() {\n\n    private val iterations = 50_000 * stressTestMultiplier\n    @get:Rule\n    public val pool =  ExecutorRule(4)\n\n    @Test\n    fun testMultipleExceptions() = runTest {\n        val ctx = pool + NonCancellable\n        repeat(iterations) {\n            val barrier = CyclicBarrier(4)\n            val d1 = async(ctx) {\n                barrier.await()\n                throw TestException()\n            }\n            val d2 = async(ctx) {\n                barrier.await()\n                throw TestException()\n            }\n            val d3 = async(ctx) {\n                barrier.await()\n                1L\n            }\n            try {\n                barrier.await()\n                awaitAll(d1, d2, d3)\n                expectUnreached()\n            } catch (e: TestException) {\n                // Expected behaviour\n            }\n\n            barrier.reset()\n        }\n    }\n\n    @Test\n    fun testAwaitAll() = runTest {\n        val barrier = CyclicBarrier(3)\n        repeat(iterations) {\n            val d1 = async(pool) {\n                barrier.await()\n                1L\n            }\n            val d2 = async(pool) {\n                barrier.await()\n                2L\n            }\n            barrier.await()\n            awaitAll(d1, d2)\n            require(d1.isCompleted && d2.isCompleted)\n            barrier.reset()\n        }\n    }\n\n    @Test\n    fun testConcurrentCancellation() = runTest {\n        var cancelledOnce = false\n        repeat(iterations) {\n            val barrier = CyclicBarrier(3)\n\n            val d1 = async(pool) {\n                barrier.await()\n                delay(10_000)\n                yield()\n            }\n\n            val d2 = async(pool) {\n                barrier.await()\n                d1.cancel()\n            }\n\n            barrier.await()\n            try {\n                awaitAll(d1, d2)\n            } catch (e: CancellationException) {\n                cancelledOnce = true\n            }\n        }\n\n        require(cancelledOnce) { \"Cancellation exception wasn't properly caught\" }\n    }\n\n    @Test\n    fun testMutatingCollection() = runTest {\n        val barrier = CyclicBarrier(4)\n\n        repeat(iterations) {\n            // thread-safe collection that we are going to modify\n            val deferreds = CopyOnWriteArrayList<Deferred<Long>>()\n\n            deferreds += async(pool) {\n                barrier.await()\n                1L\n            }\n\n            deferreds += async(pool) {\n                barrier.await()\n                2L\n            }\n\n            deferreds += async(pool) {\n                barrier.await()\n                deferreds.removeAt(2)\n                3L\n            }\n\n            val allJobs = ArrayList(deferreds)\n            barrier.await()\n            val results = deferreds.awaitAll() // shouldn't hang\n            check(results == listOf(1L, 2L, 3L) || results == listOf(1L, 2L))\n            allJobs.awaitAll()\n            barrier.reset()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/CancellableContinuationJvmTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass CancellableContinuationJvmTest : TestBase() {\n    @Test\n    fun testToString() = runTest {\n        checkToString()\n    }\n\n    private suspend fun checkToString() {\n        suspendCancellableCoroutine<Unit> {\n            it.resume(Unit)\n            assertTrue(it.toString().contains(\"kotlinx.coroutines.CancellableContinuationJvmTest.checkToString(CancellableContinuationJvmTest.kt\"))\n        }\n        suspend {}() // Eliminate tail-call optimization\n    }\n\n    @Test\n    fun testExceptionIsNotReported() = runTest({ it is CancellationException }) {\n        val ctx = coroutineContext\n        suspendCancellableCoroutine<Unit> {\n            ctx.cancel()\n            it.resumeWith(Result.failure(TestException()))\n        }\n    }\n\n    @Test\n    fun testBlockingIntegration() = runTest {\n        val source = BlockingSource()\n        val job = launch(Dispatchers.Default) {\n            source.await()\n        }\n        source.cancelAndJoin(job)\n    }\n\n    @Test\n    fun testBlockingIntegrationAlreadyCancelled() = runTest {\n        val source = BlockingSource()\n        val job = launch(Dispatchers.Default) {\n            cancel()\n            source.await()\n        }\n        source.cancelAndJoin(job)\n    }\n\n    private suspend fun BlockingSource.cancelAndJoin(job: Job) {\n        while (!hasSubscriber) {\n            Thread.sleep(10)\n        }\n        job.cancelAndJoin()\n    }\n\n    private suspend fun BlockingSource.await() = suspendCancellableCoroutine<Unit> {\n        it.invokeOnCancellation { this.cancel() }\n        subscribe()\n    }\n\n    private class BlockingSource {\n        @Volatile\n        private var isCancelled = false\n\n        @Volatile\n        public var hasSubscriber = false\n\n        public fun subscribe() {\n            hasSubscriber = true\n            while (!isCancelled) {\n                Thread.sleep(10)\n            }\n        }\n\n        public fun cancel() {\n            isCancelled = true\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/CancellableContinuationResumeCloseStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport org.junit.*\nimport java.util.concurrent.*\nimport kotlin.test.*\nimport kotlin.test.Test\n\nclass CancellableContinuationResumeCloseStressTest : TestBase() {\n    @get:Rule\n    public val dispatcher = ExecutorRule(2)\n\n    private val startBarrier = CyclicBarrier(3)\n    private val doneBarrier = CyclicBarrier(2)\n    private val nRepeats = 1_000 * stressTestMultiplier\n\n    private val closed = atomic(false)\n    private var returnedOk = false\n\n    @Test\n    @Suppress(\"BlockingMethodInNonBlockingContext\")\n    fun testStress() = runTest {\n        repeat(nRepeats) {\n            closed.value = false\n            returnedOk = false\n            val job = testJob()\n            startBarrier.await()\n            job.cancel() // (1) cancel job\n            job.join()\n            // check consistency\n            doneBarrier.await()\n            if (returnedOk) {\n                assertFalse(closed.value, \"should not have closed resource -- returned Ok\")\n            } else {\n                assertTrue(closed.value, \"should have closed resource -- was cancelled\")\n            }\n        }\n    }\n\n    private fun CoroutineScope.testJob(): Job = launch(dispatcher, start = CoroutineStart.ATOMIC) {\n        val ok = resumeClose() // might be cancelled\n        assertEquals(\"OK\", ok)\n        returnedOk = true\n    }\n\n    private suspend fun resumeClose() = suspendCancellableCoroutine<String> { cont ->\n        dispatcher.executor.execute {\n            startBarrier.await() // (2) resume at the same time\n            cont.resume(\"OK\") {\n                close()\n            }\n            doneBarrier.await()\n        }\n        startBarrier.await() // (3) return at the same time\n    }\n\n    fun close() {\n        assertFalse(closed.getAndSet(true))\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/CancelledAwaitStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\n\nclass CancelledAwaitStressTest : TestBase() {\n    private val n = 1000 * stressTestMultiplier\n\n    /**\n     * Tests that memory does not leak from cancelled [Deferred.await]\n     */\n    @Test\n    fun testCancelledAwait() = runTest {\n        val d = async {\n            delay(Long.MAX_VALUE)\n        }\n        repeat(n) {\n            val waiter = launch(start = CoroutineStart.UNDISPATCHED) {\n                val a = ByteArray(10000000) // allocate 10M of memory here\n                d.await()\n                keepMe(a) // make sure it is kept in state machine\n            }\n            waiter.cancel() // cancel await\n            yield() // complete the waiter job, release its memory\n        }\n        d.cancel() // done test\n    }\n\n    /**\n     * Tests that memory does not leak from cancelled [Job.join]\n     */\n    @Test\n    fun testCancelledJoin() = runTest {\n        val j = launch {\n            delay(Long.MAX_VALUE)\n        }\n        repeat(n) {\n            val joiner = launch(start = CoroutineStart.UNDISPATCHED) {\n                val a = ByteArray(10000000) // allocate 10M of memory here\n                j.join()\n                keepMe(a) // make sure it is kept in state machine\n            }\n            joiner.cancel() // cancel join\n            yield() // complete the joiner job, release its memory\n        }\n        j.cancel() // done test\n    }\n\n    private fun keepMe(a: ByteArray) {\n        // does nothing, makes sure the variable is kept in state-machine\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ConcurrentTestUtilities.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nactual inline fun yieldThread() { Thread.yield() }\n\nactual fun currentThreadName(): String = Thread.currentThread().name\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/CoroutinesJvmTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass CoroutinesJvmTest : TestBase() {\n    @Test\n    fun testNotCancellableCodeWithExceptionCancelled() = runTest(expected = {e -> e is TestException}) {\n        expect(1)\n        // CoroutineStart.ATOMIC makes sure it will not get cancelled for it starts executing\n        val job = launch(start = CoroutineStart.ATOMIC) {\n            Thread.sleep(100) // cannot be cancelled\n            throwTestException() // will throw\n            expectUnreached()\n        }\n        expect(2)\n        job.cancel()\n        finish(3)\n    }\n\n    @Test\n    fun testCancelManyCompletedAttachedChildren() = runTest {\n        val parent = launch { /* do nothing */ }\n        val n = 10_000 * stressTestMultiplier\n        repeat(n) {\n            // create a child that already completed\n            val child = launch(start = CoroutineStart.UNDISPATCHED) { /* do nothing */ }\n            // attach it manually via internal API\n            @Suppress(\"DEPRECATION_ERROR\")\n            parent.attachChild(child as ChildJob)\n        }\n        parent.cancelAndJoin() // cancel parent, make sure no stack overflow\n    }\n\n    private fun throwTestException(): Unit = throw TestException()\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/DebugThreadNameTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass DebugThreadNameTest : TestBase() {\n    @BeforeTest\n    fun resetName() {\n        resetCoroutineId()\n    }\n\n    @Test\n    fun testLaunchId() = runTest {\n        assertName(\"coroutine#1\")\n        launch {\n            assertName(\"coroutine#2\")\n            yield()\n            assertName(\"coroutine#2\")\n        }\n        assertName(\"coroutine#1\")\n    }\n\n    @Test\n    fun testLaunchIdUndispatched() = runTest {\n        assertName(\"coroutine#1\")\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            assertName(\"coroutine#2\")\n            yield()\n            assertName(\"coroutine#2\")\n        }\n        assertName(\"coroutine#1\")\n    }\n\n    @Test\n    fun testLaunchName() = runTest {\n        assertName(\"coroutine#1\")\n        launch(CoroutineName(\"TEST\")) {\n            assertName(\"TEST#2\")\n            yield()\n            assertName(\"TEST#2\")\n        }\n        assertName(\"coroutine#1\")\n    }\n\n    @Test\n    fun testWithContext() = runTest {\n        assertName(\"coroutine#1\")\n        withContext(Dispatchers.Default) {\n            assertName(\"coroutine#1\")\n            yield()\n            assertName(\"coroutine#1\")\n            withContext(CoroutineName(\"TEST\")) {\n                assertName(\"TEST#1\")\n                yield()\n                assertName(\"TEST#1\")\n            }\n            assertName(\"coroutine#1\")\n            yield()\n            assertName(\"coroutine#1\")\n        }\n        assertName(\"coroutine#1\")\n    }\n\n    private fun assertName(expected: String) {\n        val name = Thread.currentThread().name\n        val split = name.split(Regex(\" @\"))\n        assertEquals(2, split.size, \"Thread name '$name' is expected to contain one coroutine name\")\n        assertEquals(expected, split[1], \"Thread name '$name' is expected to end with coroutine name '$expected'\")\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/DefaultExecutorStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass DefaultExecutorStressTest : TestBase() {\n    @Test\n    fun testDelay() = runTest {\n        val iterations = 100_000 * stressTestMultiplier\n        withContext(DefaultExecutor) {\n            expect(1)\n            var expected = 1\n            repeat(iterations) {\n                expect(++expected)\n                val deferred = async {\n                    expect(++expected)\n                    val largeArray = IntArray(10_000) { it }\n                    delay(Long.MAX_VALUE)\n                    println(largeArray) // consume to avoid DCE, actually unreachable\n                }\n\n                expect(++expected)\n                yield()\n                deferred.cancel()\n                try {\n                    deferred.await()\n                } catch (e: CancellationException) {\n                    expect(++expected)\n                }\n            }\n\n        }\n        finish(2 + iterations * 4)\n    }\n\n    @Test\n    fun testWorkerShutdown() = withVirtualTimeSource {\n        val iterations = 1_000 * stressTestMultiplier\n        // wait for the worker to shut down\n        suspend fun awaitWorkerShutdown() {\n            val executorTimeoutMs = 1000L\n            delay(executorTimeoutMs)\n            while (DefaultExecutor.isThreadPresent) { delay(10) } // hangs if the thread refuses to stop\n            assertFalse(DefaultExecutor.isThreadPresent) // just to make sure\n        }\n        runTest {\n            awaitWorkerShutdown() // so that the worker shuts down after the initial launch\n            repeat (iterations) {\n                val job = launch(Dispatchers.Unconfined) {\n                    // this line runs in the main thread\n                    delay(1)\n                    // this line runs in the DefaultExecutor worker\n                }\n                delay(100) // yield the execution, allow the worker to spawn\n                assertTrue(DefaultExecutor.isThreadPresent) // the worker spawned\n                job.join()\n                awaitWorkerShutdown()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/DelayJvmTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.test.assertEquals\n\nclass DelayJvmTest : TestBase() {\n    /**\n     * Test that delay works properly in contexts with custom [ContinuationInterceptor]\n     */\n    @Test\n    fun testDelayInArbitraryContext() = runBlocking {\n        var thread: Thread? = null\n        val pool = Executors.newFixedThreadPool(1) { runnable ->\n            Thread(runnable).also { thread = it }\n        }\n        val context = CustomInterceptor(pool)\n        val c = async(context) {\n            assertEquals(thread, Thread.currentThread())\n            delay(100)\n            assertEquals(thread, Thread.currentThread())\n            42\n        }\n        assertEquals(42, c.await())\n        pool.shutdown()\n    }\n\n    @Test\n    fun testDelayWithoutDispatcher() = runBlocking(CoroutineName(\"testNoDispatcher.main\")) {\n        // launch w/o a specified dispatcher\n        val c = async(CoroutineName(\"testNoDispatcher.inner\")) {\n            delay(100)\n            42\n        }\n        assertEquals(42, c.await())\n    }\n\n    @Test\n    fun testNegativeDelay() = runBlocking {\n        expect(1)\n        val job = async {\n            expect(3)\n            delay(0)\n            expect(4)\n        }\n\n        delay(-1)\n        expect(2)\n        job.await()\n        finish(5)\n    }\n\n    class CustomInterceptor(val pool: Executor) : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n        override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =\n            Wrapper(pool, continuation)\n    }\n\n    class Wrapper<T>(val pool: Executor, private val cont: Continuation<T>) : Continuation<T> {\n        override val context: CoroutineContext\n            get() = cont.context\n\n        override fun resumeWith(result: Result<T>) {\n            pool.execute { cont.resumeWith(result) }\n        }\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/DispatcherKeyTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@OptIn(ExperimentalStdlibApi::class)\nclass DispatcherKeyTest : TestBase() {\n\n    companion object CustomInterceptor : AbstractCoroutineContextElement(ContinuationInterceptor),\n        ContinuationInterceptor {\n        override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> {\n            return continuation\n        }\n    }\n\n    private val name = CoroutineName(\"test\")\n\n    @Test\n    fun testDispatcher() {\n        val context = name + CustomInterceptor\n        assertNull(context[CoroutineDispatcher])\n        assertSame(CustomInterceptor, context[ContinuationInterceptor])\n\n        val updated = context + Dispatchers.Main\n        val result: CoroutineDispatcher? = updated[CoroutineDispatcher]\n        assertSame(Dispatchers.Main, result)\n        assertSame(Dispatchers.Main, updated[ContinuationInterceptor])\n        assertEquals(name, updated.minusKey(CoroutineDispatcher))\n        assertEquals(name, updated.minusKey(ContinuationInterceptor))\n    }\n\n    @Test\n    fun testExecutorCoroutineDispatcher() {\n        val context = name + CustomInterceptor\n        assertNull(context[ExecutorCoroutineDispatcher])\n        val updated = context + Dispatchers.Main\n        assertNull(updated[ExecutorCoroutineDispatcher])\n        val executor = Dispatchers.Default\n        val updated2 = updated + executor\n        assertSame(Dispatchers.Default, updated2[ContinuationInterceptor])\n        assertSame(Dispatchers.Default, updated2[CoroutineDispatcher])\n        assertSame(Dispatchers.Default as ExecutorCoroutineDispatcher, updated2[ExecutorCoroutineDispatcher])\n        assertEquals(name, updated2.minusKey(ContinuationInterceptor))\n        assertEquals(name, updated2.minusKey(CoroutineDispatcher))\n        assertEquals(name, updated2.minusKey(ExecutorCoroutineDispatcher))\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/DispatchersToStringTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.test.*\n\nclass DispatchersToStringTest {\n    @Test\n    fun testStrings() {\n        assertEquals(\"Dispatchers.Unconfined\", Dispatchers.Unconfined.toString())\n        assertEquals(\"Dispatchers.Default\", Dispatchers.Default.toString())\n        assertEquals(\"Dispatchers.IO\", Dispatchers.IO.toString())\n        assertEquals(\"Dispatchers.Main[missing]\", Dispatchers.Main.toString())\n        assertEquals(\"Dispatchers.Main[missing]\", Dispatchers.Main.immediate.toString())\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/EventLoopsTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.Test\nimport java.util.concurrent.locks.*\nimport kotlin.concurrent.*\nimport kotlin.test.*\n\n/**\n * Tests event loops integration.\n * See [https://github.com/Kotlin/kotlinx.coroutines/issues/860].\n */\nclass EventLoopsTest : TestBase() {\n    @Test\n    fun testNestedRunBlocking() {\n        runBlocking { // outer event loop\n            // Produce string \"OK\"\n            val ch = produce { send(\"OK\") }\n            // try receive this string in a blocking way:\n            assertEquals(\"OK\", runBlocking { ch.receive() }) // it should not hang here\n        }\n    }\n\n    @Test\n    fun testUnconfinedInRunBlocking() {\n        var completed = false\n        runBlocking {\n            launch(Dispatchers.Unconfined) {\n                completed = true\n            }\n            // should not go into runBlocking loop, but complete here\n            assertTrue(completed)\n        }\n    }\n\n    @Test\n    fun testNestedUnconfined() {\n        expect(1)\n        GlobalScope.launch(Dispatchers.Unconfined) {\n            expect(2)\n            GlobalScope.launch(Dispatchers.Unconfined) {\n                // this gets scheduled into outer unconfined loop\n                expect(4)\n            }\n            expect(3) // ^^ executed before the above unconfined\n        }\n        finish(5)\n    }\n\n    @Test\n    fun testEventLoopInDefaultExecutor() = runTest {\n        expect(1)\n        withContext(Dispatchers.Unconfined) {\n            delay(1)\n            assertTrue(Thread.currentThread().name.startsWith(DefaultExecutor.THREAD_NAME))\n            expect(2)\n            // now runBlocking inside default executor thread --> should use outer event loop\n            DefaultExecutor.enqueue(Runnable {\n                expect(4) // will execute when runBlocking runs loop\n            })\n            expect(3)\n            runBlocking {\n                expect(5)\n            }\n        }\n        finish(6)\n    }\n\n    /**\n     * Simple test for [processNextEventInCurrentThread] API use-case.\n     */\n    @Test\n    fun testProcessNextEventInCurrentThreadSimple() = runTest {\n        expect(1)\n        val event = EventSync()\n        // this coroutine fires event\n        launch {\n            expect(3)\n            event.fireEvent()\n        }\n        // main coroutine waits for event (same thread!)\n        expect(2)\n        event.blockingAwait()\n        finish(4)\n    }\n\n    @Test\n    fun testSecondThreadRunBlocking() = runTest {\n        val testThread = Thread.currentThread()\n        val testContext = coroutineContext\n        val event = EventSync() // will signal completion\n        var thread = thread {\n            runBlocking { // outer event loop\n                // Produce string \"OK\"\n                val ch = produce { send(\"OK\") }\n                // try receive this string in a blocking way using test context (another thread)\n                assertEquals(\"OK\", runBlocking(testContext) {\n                    assertEquals(testThread, Thread.currentThread())\n                    ch.receive() // it should not hang here\n                })\n            }\n            event.fireEvent() // done thread\n        }\n        event.blockingAwait() // wait for thread to complete\n        thread.join() // it is safe to join thread now\n    }\n\n    /**\n     * Test for [processNextEventInCurrentThread] API use-case with delay.\n     */\n    @Test\n    fun testProcessNextEventInCurrentThreadDelay() = runTest {\n        expect(1)\n        val event = EventSync()\n        // this coroutine fires event\n        launch {\n            expect(3)\n            delay(100)\n            event.fireEvent()\n        }\n        // main coroutine waits for event (same thread!)\n        expect(2)\n        event.blockingAwait()\n        finish(4)\n    }\n\n    class EventSync {\n        private val waitingThread = atomic<Thread?>(null)\n        private val fired = atomic(false)\n\n        fun fireEvent() {\n            fired.value = true\n            waitingThread.value?.let { LockSupport.unpark(it) }\n        }\n\n        fun blockingAwait() {\n            check(waitingThread.getAndSet(Thread.currentThread()) == null)\n            while (!fired.getAndSet(false)) {\n                val time = processNextEventInCurrentThread()\n                LockSupport.parkNanos(time)\n            }\n            waitingThread.value = null\n        }\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ExecutorAsCoroutineDispatcherDelayTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport java.lang.Runnable\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass ExecutorAsCoroutineDispatcherDelayTest : TestBase() {\n\n    private var callsToSchedule = 0\n\n    private inner class STPE : ScheduledThreadPoolExecutor(1) {\n        override fun schedule(command: Runnable, delay: Long, unit: TimeUnit): ScheduledFuture<*> {\n            if (delay != 0L) ++callsToSchedule\n            return super.schedule(command, delay, unit)\n        }\n    }\n\n    private inner class SES : ScheduledExecutorService by STPE()\n\n    @Test\n    fun testScheduledThreadPool() = runTest {\n        val executor = STPE()\n        withContext(executor.asCoroutineDispatcher()) {\n            delay(100)\n        }\n        executor.shutdown()\n        assertEquals(1, callsToSchedule)\n    }\n\n    @Test\n    fun testScheduledExecutorService() = runTest {\n        val executor = SES()\n        withContext(executor.asCoroutineDispatcher()) {\n            delay(100)\n        }\n        executor.shutdown()\n        assertEquals(1, callsToSchedule)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ExecutorsTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ExecutorsTest : TestBase() {\n    private fun checkThreadName(prefix: String) {\n        val name = Thread.currentThread().name\n        check(name.startsWith(prefix)) { \"Expected thread name to start with '$prefix', found: '$name'\" }\n    }\n\n    @Test\n    fun testSingleThread() {\n        val context = newSingleThreadContext(\"TestThread\")\n        runBlocking(context) {\n            checkThreadName(\"TestThread\")\n        }\n        context.close()\n    }\n\n    @Test\n    fun testFixedThreadPool() {\n        val context = newFixedThreadPoolContext(2, \"TestPool\")\n        runBlocking(context) {\n            checkThreadName(\"TestPool\")\n            delay(10)\n            checkThreadName(\"TestPool\") // should dispatch on the right thread\n        }\n        context.close()\n    }\n\n    @Test\n    fun testExecutorToDispatcher() {\n        val executor = Executors.newSingleThreadExecutor { r -> Thread(r, \"TestExecutor\") }\n        runBlocking(executor.asCoroutineDispatcher()) {\n            checkThreadName(\"TestExecutor\")\n            delay(10)\n            checkThreadName(\"TestExecutor\") // should dispatch on the right thread\n        }\n        executor.shutdown()\n    }\n\n    @Test\n    fun testConvertedDispatcherToExecutor() {\n        val executor: ExecutorService = Executors.newSingleThreadExecutor { r -> Thread(r, \"TestExecutor\") }\n        val dispatcher: CoroutineDispatcher = executor.asCoroutineDispatcher()\n        assertSame(executor, dispatcher.asExecutor())\n        executor.shutdown()\n    }\n\n    @Test\n    fun testDefaultDispatcherToExecutor() {\n        val latch = CountDownLatch(1)\n        Dispatchers.Default.asExecutor().execute {\n            checkThreadName(\"DefaultDispatcher\")\n            latch.countDown()\n        }\n        latch.await()\n    }\n\n    @Test\n    fun testCustomDispatcherToExecutor() {\n        expect(1)\n        val dispatcher = object : CoroutineDispatcher() {\n            override fun dispatch(context: CoroutineContext, block: Runnable) {\n                expect(2)\n                block.run()\n            }\n        }\n        val executor = dispatcher.asExecutor()\n        assertSame(dispatcher, executor.asCoroutineDispatcher())\n        executor.execute {\n            expect(3)\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testCustomDispatcherToExecutorDispatchNotNeeded() {\n        expect(1)\n        val dispatcher = object : CoroutineDispatcher() {\n            override fun isDispatchNeeded(context: CoroutineContext) = false\n\n            override fun dispatch(context: CoroutineContext, block: Runnable) {\n                fail(\"should not dispatch\")\n            }\n        }\n        dispatcher.asExecutor().execute {\n            expect(2)\n        }\n        finish(3)\n    }\n\n    @Test\n    fun testTwoThreads() {\n        val ctx1 = newSingleThreadContext(\"Ctx1\")\n        val ctx2 = newSingleThreadContext(\"Ctx2\")\n        runBlocking(ctx1) {\n            checkThreadName(\"Ctx1\")\n            withContext(ctx2) {\n                checkThreadName(\"Ctx2\")\n            }\n            checkThreadName(\"Ctx1\")\n        }\n        ctx1.close()\n        ctx2.close()\n    }\n\n    @Test\n    fun testShutdownExecutorService() {\n        val executorService = Executors.newSingleThreadExecutor { r -> Thread(r, \"TestExecutor\") }\n        val dispatcher = executorService.asCoroutineDispatcher()\n        runBlocking (dispatcher) {\n            checkThreadName(\"TestExecutor\")\n        }\n        dispatcher.close()\n        check(executorService.isShutdown)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/FailFastOnStartTest.kt",
        "content": "@file:Suppress(\"DeferredResultUnused\")\n\npackage kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.*\nimport org.junit.Test\nimport org.junit.rules.*\nimport kotlin.test.*\n\nclass FailFastOnStartTest : TestBase() {\n\n    @Rule\n    @JvmField\n    public val timeout: Timeout = Timeout.seconds(5)\n\n    @Test\n    fun testLaunch() = runTest(expected = ::mainException) {\n        launch(Dispatchers.Main) {}\n    }\n\n    @Test\n    fun testLaunchLazy() = runTest(expected = ::mainException) {\n        val job = launch(Dispatchers.Main, start = CoroutineStart.LAZY) { fail() }\n        job.join()\n    }\n\n    @Test\n    fun testLaunchUndispatched() = runTest(expected = ::mainException) {\n        launch(Dispatchers.Main, start = CoroutineStart.UNDISPATCHED) {\n            yield()\n            fail()\n        }\n    }\n\n    @Test\n    fun testAsync() = runTest(expected = ::mainException) {\n        async(Dispatchers.Main) {}\n    }\n\n    @Test\n    fun testAsyncLazy() = runTest(expected = ::mainException) {\n        val job = async(Dispatchers.Main, start = CoroutineStart.LAZY) { fail() }\n        job.await()\n    }\n\n    @Test\n    fun testWithContext() = runTest(expected = ::mainException) {\n        withContext(Dispatchers.Main) {\n            fail()\n        }\n    }\n\n    @Test\n    fun testProduce() = runTest(expected = ::mainException) {\n        produce<Int>(Dispatchers.Main) { fail() }\n    }\n\n    @Test\n    fun testActor() = runTest(expected = ::mainException) {\n        actor<Int>(Dispatchers.Main) { fail() }\n    }\n\n    @Test\n    fun testActorLazy() = runTest(expected = ::mainException) {\n        val actor = actor<Int>(Dispatchers.Main, start = CoroutineStart.LAZY) { fail() }\n        actor.send(1)\n    }\n\n    private fun mainException(e: Throwable): Boolean {\n        return e is IllegalStateException && e.message?.contains(\"Module with the Main dispatcher is missing\") ?: false\n    }\n\n    @Test\n    fun testProduceNonChild() = runTest(expected = ::mainException) {\n        produce<Int>(Job() + Dispatchers.Main) { fail() }\n    }\n\n    @Test\n    fun testAsyncNonChild() = runTest(expected = ::mainException) {\n        async<Int>(Job() + Dispatchers.Main) { fail() }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/FailingCoroutinesMachineryTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass FailingCoroutinesMachineryTest(\n    private val element: CoroutineContext.Element,\n    private val dispatcher: TestDispatcher\n) : TestBase() {\n    class TestDispatcher(val name: String, val block: () -> CoroutineDispatcher) {\n        private var _value: CoroutineDispatcher? = null\n\n        val value: CoroutineDispatcher\n            get() = _value ?: block().also { _value = it }\n\n        override fun toString(): String = name\n\n        fun reset() {\n            runCatching { (_value as? ExecutorCoroutineDispatcher)?.close() }\n            _value = null\n        }\n    }\n\n    private var caught: Throwable? = null\n    private val latch = CountDownLatch(1)\n    private var exceptionHandler = CoroutineExceptionHandler { _, t -> caught = t; latch.countDown() }\n    private val lazyOuterDispatcher = lazy { newFixedThreadPoolContext(1, \"\") }\n\n    private object FailingUpdate : ThreadContextElement<Unit> {\n        private object Key : CoroutineContext.Key<MyElement>\n\n        override val key: CoroutineContext.Key<*> get() = Key\n\n        override fun restoreThreadContext(context: CoroutineContext, oldState: Unit) {\n        }\n\n        override fun updateThreadContext(context: CoroutineContext) {\n            throw TestException(\"Prevent a coroutine from starting right here for some reason\")\n        }\n\n        override fun toString() = \"FailingUpdate\"\n    }\n\n    private object FailingRestore : ThreadContextElement<Unit> {\n        private object Key : CoroutineContext.Key<MyElement>\n\n        override val key: CoroutineContext.Key<*> get() = Key\n\n        override fun restoreThreadContext(context: CoroutineContext, oldState: Unit) {\n            throw TestException(\"Prevent a coroutine from starting right here for some reason\")\n        }\n\n        override fun updateThreadContext(context: CoroutineContext) {\n        }\n\n        override fun toString() = \"FailingRestore\"\n    }\n\n    private object ThrowingDispatcher : CoroutineDispatcher() {\n        override fun dispatch(context: CoroutineContext, block: Runnable) {\n            throw TestException()\n        }\n\n        override fun toString() = \"ThrowingDispatcher\"\n    }\n\n    private object ThrowingDispatcher2 : CoroutineDispatcher() {\n        override fun dispatch(context: CoroutineContext, block: Runnable) {\n            block.run()\n        }\n\n        override fun isDispatchNeeded(context: CoroutineContext): Boolean {\n            throw TestException()\n        }\n\n        override fun toString() = \"ThrowingDispatcher2\"\n    }\n\n    @After\n    fun tearDown() {\n        dispatcher.reset()\n        if (lazyOuterDispatcher.isInitialized()) lazyOuterDispatcher.value.close()\n    }\n\n    companion object {\n        @JvmStatic\n        @Parameterized.Parameters(name = \"Element: {0}, dispatcher: {1}\")\n        fun dispatchers(): List<Array<Any>> {\n            val elements = listOf<Any>(FailingRestore, FailingUpdate)\n            val dispatchers = listOf<TestDispatcher>(\n                TestDispatcher(\"Dispatchers.Unconfined\") { Dispatchers.Unconfined },\n                TestDispatcher(\"Dispatchers.Default\") { Dispatchers.Default },\n                TestDispatcher(\"Executors.newFixedThreadPool(1)\") { Executors.newFixedThreadPool(1).asCoroutineDispatcher() },\n                TestDispatcher(\"Executors.newScheduledThreadPool(1)\") { Executors.newScheduledThreadPool(1).asCoroutineDispatcher() },\n                TestDispatcher(\"ThrowingDispatcher\") { ThrowingDispatcher },\n                TestDispatcher(\"ThrowingDispatcher2\") { ThrowingDispatcher2 }\n            )\n            return elements.flatMap { element ->\n                dispatchers.map { dispatcher ->\n                    arrayOf(element, dispatcher)\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testElement() = runTest {\n        // Top-level throwing dispatcher may rethrow an exception right here\n        runCatching {\n            launch(NonCancellable + dispatcher.value + exceptionHandler + element) {}\n        }\n        checkException()\n    }\n\n    @Test\n    fun testNestedElement() = runTest {\n        // Top-level throwing dispatcher may rethrow an exception right here\n        runCatching {\n            launch(NonCancellable + dispatcher.value + exceptionHandler) {\n                launch(element) { }\n            }\n        }\n        checkException()\n    }\n\n    @Test\n    fun testNestedDispatcherAndElement() = runTest {\n        launch(lazyOuterDispatcher.value + NonCancellable + exceptionHandler) {\n            launch(element + dispatcher.value) {  }\n        }\n        checkException()\n    }\n\n    private fun checkException() {\n        latch.await(2, TimeUnit.SECONDS)\n        val e = caught\n        assertNotNull(e)\n        // First condition -- failure in context element\n        val firstCondition = e is CoroutinesInternalError && e.cause is TestException\n        // Second condition -- failure from isDispatchNeeded (#880)\n        val secondCondition = e is TestException\n        assertTrue(firstCondition xor secondCondition)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/IODispatcherTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass IODispatcherTest : TestBase() {\n    @Test\n    fun testWithIOContext() = runTest {\n        // just a very basic test that is dispatcher works and indeed uses background thread\n        val mainThread = Thread.currentThread()\n        expect(1)\n        withContext(Dispatchers.IO) {\n            expect(2)\n            assertNotSame(mainThread, Thread.currentThread())\n        }\n\n        expect(3)\n        assertSame(mainThread, Thread.currentThread())\n        finish(4)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/IntellijIdeaDebuggerEvaluatorCompatibilityTest.kt",
        "content": "package kotlinx.coroutines\n\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass IntellijIdeaDebuggerEvaluatorCompatibilityTest {\n\n    /*\n     * This test verifies that our CoroutineScope is accessible to IDEA debugger.\n     *\n     * Consider the following scenario:\n     * ```\n     * runBlocking<Unit> { // this: CoroutineScope\n     *     println(\"runBlocking\")\n     * }\n     * ```\n     * user puts breakpoint to `println` line, opens \"Evaluate\" window\n     * and executes `launch { println(\"launch\") }`. They (obviously) expect it to work, but\n     * it won't: `{}` in `runBlocking` is `SuspendLambda` and `this` is an unused implicit receiver\n     * that is removed by the compiler (because it's unused).\n     *\n     * But we still want to provide consistent user experience for functions with `CoroutineScope` receiver,\n     * for that IDEA debugger tries to retrieve the scope via `kotlin.coroutines.coroutineContext[Job] as? CoroutineScope`\n     * and with this test we're fixing this behaviour.\n     *\n     * Note that this behaviour is not carved in stone: IDEA fallbacks to `kotlin.coroutines.coroutineContext` for the context if necessary.\n     */\n\n    @Test\n    fun testScopeIsAccessible() = runBlocking<Unit> {\n        verify()\n\n        withContext(Job()) {\n            verify()\n        }\n\n        coroutineScope {\n            verify()\n        }\n\n        supervisorScope {\n            verify()\n        }\n\n    }\n\n    private suspend fun verify() {\n        val ctx = coroutineContext\n        assertTrue { ctx.job is CoroutineScope }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/JobActivationStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass JobActivationStressTest : TestBase() {\n    private val N_ITERATIONS = 10_000 * stressTestMultiplier\n    private val pool = newFixedThreadPoolContext(3, \"JobActivationStressTest\")\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    /**\n     * Perform concurrent start & cancel of a job with prior installed completion handlers\n     */\n    @Test\n    @Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n    fun testActivation() = runTest {\n        val barrier = CyclicBarrier(3)\n        val scope = CoroutineScope(pool)\n        repeat(N_ITERATIONS) {\n            var wasStarted = false\n            val d = scope.async(NonCancellable, start = CoroutineStart.LAZY) {\n                wasStarted = true\n                throw TestException()\n            }\n            // need to add on completion handler\n            val causeHolder = object {\n                var cause: Throwable? = null\n            }\n            // we use synchronization on causeHolder to work around the fact that completion listeners\n            // are invoked after the job is in the final state, so when \"d.join()\" completes there is\n            // no guarantee that this listener was already invoked\n            d.invokeOnCompletion {\n                synchronized(causeHolder) {\n                    causeHolder.cause = it ?: Error(\"Empty cause\")\n                    (causeHolder as Object).notifyAll()\n                }\n            }\n            // concurrent cancel\n            val canceller = scope.launch {\n                barrier.await()\n                d.cancel()\n            }\n            // concurrent cancel\n            val starter = scope.launch {\n                barrier.await()\n                d.start()\n            }\n            barrier.await()\n            joinAll(d, canceller, starter)\n            if (wasStarted) {\n                val exception = d.getCompletionExceptionOrNull()\n                assertIs<TestException>(exception, \"exception=$exception\")\n                val cause = synchronized(causeHolder) {\n                    while (causeHolder.cause == null) (causeHolder as Object).wait()\n                    causeHolder.cause\n                }\n                assertIs<TestException>(cause, \"cause=$cause\")\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/JobCancellationExceptionSerializerTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport java.io.*\n\n\n@Suppress(\"BlockingMethodInNonBlockingContext\")\nclass JobCancellationExceptionSerializerTest : TestBase() {\n\n    @Test\n    fun testSerialization() = runTest {\n        try {\n            coroutineScope {\n                expect(1)\n\n                launch {\n                    expect(2)\n                    try {\n                        hang {}\n                    } catch (e: CancellationException) {\n                        throw RuntimeException(\"RE2\", e)\n                    }\n                }\n\n                launch {\n                    expect(3)\n                    throw RuntimeException(\"RE1\")\n                }\n            }\n        } catch (e: Throwable) {\n            // Should not fail\n            ObjectOutputStream(ByteArrayOutputStream()).use {\n                it.writeObject(e)\n            }\n            finish(4)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/JobChildStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass JobChildStressTest : TestBase() {\n    private val N_ITERATIONS = 10_000 * stressTestMultiplier\n    private val pool = newFixedThreadPoolContext(3, \"JobChildStressTest\")\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    /**\n     * Perform concurrent launch of a child job & cancellation of the explicit parent job\n     */\n    @Test\n    @Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n    fun testChild() = runTest {\n        val barrier = CyclicBarrier(3)\n        repeat(N_ITERATIONS) {\n            var wasLaunched = false\n            var unhandledException: Throwable? = null\n            val handler = CoroutineExceptionHandler { _, ex ->\n                unhandledException = ex\n            }\n            val scope = CoroutineScope(pool + handler)\n            val parent = CompletableDeferred<Unit>()\n            // concurrent child launcher\n            val launcher = scope.launch {\n                barrier.await()\n                // A: launch child for a parent job\n                launch(parent) {\n                    wasLaunched = true\n                    throw TestException()\n                }\n            }\n            // concurrent cancel\n            val canceller = scope.launch {\n                barrier.await()\n                // B: cancel parent job of a child\n                parent.cancel()\n            }\n            barrier.await()\n            joinAll(launcher, canceller, parent)\n            assertNull(unhandledException)\n            if (wasLaunched) {\n                val exception = parent.getCompletionExceptionOrNull()\n                assertIs<TestException>(exception, \"exception=$exception\")\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/JobDisposeStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.concurrent.thread\n\n/**\n * Tests concurrent cancel & dispose of the jobs.\n */\nclass JobDisposeStressTest: TestBase() {\n    private val TEST_DURATION = 3 * stressTestMultiplier // seconds\n\n    @Volatile\n    private var done = false\n    @Volatile\n    private var job: TestJob? = null\n    @Volatile\n    private var handle: DisposableHandle? = null\n\n    @Volatile\n    private var exception: Throwable? = null\n\n    private fun testThread(name: String, block: () -> Unit): Thread =\n        thread(start = false, name = name, block = block).apply {\n            setUncaughtExceptionHandler { t, e ->\n                exception = e\n                println(\"Exception in ${t.name}: $e\")\n                e.printStackTrace()\n            }\n        }\n\n    @Test\n    fun testConcurrentDispose() {\n        // create threads\n        val threads = mutableListOf<Thread>()\n        threads += testThread(\"creator\") {\n            while (!done) {\n                val job = TestJob()\n                val handle = job.invokeOnCompletion(onCancelling = true) { /* nothing */ }\n                this.job = job // post job to cancelling thread\n                this.handle = handle // post handle to concurrent disposer thread\n                handle.dispose() // dispose of handle from this thread (concurrently with other disposer)\n            }\n        }\n\n        threads += testThread(\"canceller\") {\n            while (!done) {\n                val job = this.job ?: continue\n                job.cancel()\n                // Always returns true, TestJob never completes\n            }\n        }\n\n        threads += testThread(\"disposer\") {\n            while (!done) {\n                handle?.dispose()\n            }\n        }\n\n        // start threads\n        threads.forEach { it.start() }\n        // wait\n        for (i in 1..TEST_DURATION) {\n            println(\"$i: Running\")\n            Thread.sleep(1000)\n            if (exception != null) break\n        }\n        // done\n        done = true\n        // join threads\n        threads.forEach { it.join() }\n        // rethrow exception if any\n    }\n\n    @Suppress(\"DEPRECATION_ERROR\")\n    private class TestJob : JobSupport(active = true)\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/JobHandlersUpgradeStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport java.util.*\nimport java.util.concurrent.*\nimport kotlin.concurrent.*\nimport kotlin.test.*\n\nclass JobHandlersUpgradeStressTest : TestBase() {\n    private val nSeconds = 3 * stressTestMultiplier\n    private val nThreads = 4\n\n    private val cyclicBarrier = CyclicBarrier(1 + nThreads)\n    private val threads = mutableListOf<Thread>()\n\n    private val inters = atomic(0)\n    private val removed = atomic(0)\n    private val fired = atomic(0)\n\n    private val sink = atomic(0)\n\n    @Volatile\n    private var done = false\n\n    @Volatile\n    private var job: Job? = null\n\n    internal class State {\n        val state = atomic(0)\n    }\n\n    @Test\n    fun testStress() {\n        println(\"--- JobHandlersUpgradeStressTest\")\n        threads += thread(name = \"creator\", start = false) {\n            val rnd = Random()\n            while (true) {\n                job = if (done) null else Job()\n                cyclicBarrier.await()\n                val job = job ?: break\n                // burn some time\n                repeat(rnd.nextInt(3000)) { sink.incrementAndGet() }\n                // cancel job\n                job.cancel()\n                cyclicBarrier.await()\n                inters.incrementAndGet()\n            }\n        }\n        threads += List(nThreads) { threadId ->\n            thread(name = \"handler-$threadId\", start = false) {\n                val rnd = Random()\n                while (true) {\n                    val onCancelling = rnd.nextBoolean()\n                    val invokeImmediately: Boolean = rnd.nextBoolean()\n                    cyclicBarrier.await()\n                    val job = job ?: break\n                    val state = State()\n                    // burn some time\n                    repeat(rnd.nextInt(1000)) { sink.incrementAndGet() }\n                    val handle =\n                        job.invokeOnCompletion(onCancelling = onCancelling, invokeImmediately = invokeImmediately) {\n                            if (!state.state.compareAndSet(0, 1))\n                                error(\"Fired more than once or too late: state=${state.state.value}\")\n                        }\n                    // burn some time\n                    repeat(rnd.nextInt(1000)) { sink.incrementAndGet() }\n                    // dispose\n                    handle.dispose()\n                    cyclicBarrier.await()\n                    val resultingState = state.state.value\n                    when (resultingState) {\n                        0 -> removed.incrementAndGet()\n                        1 -> fired.incrementAndGet()\n                        else -> error(\"Cannot happen\")\n                    }\n                    if (!state.state.compareAndSet(resultingState, 2))\n                        error(\"Cannot fire late: resultingState=$resultingState\")\n                }\n            }\n        }\n        threads.forEach { it.start() }\n        repeat(nSeconds) { second ->\n            Thread.sleep(1000)\n            println(\"${second + 1}: ${inters.value} iterations\")\n        }\n        done = true\n        threads.forEach { it.join() }\n        println(\"        Completed ${inters.value} iterations\")\n        println(\"  Removed handler ${removed.value} times\")\n        println(\"    Fired handler ${fired.value} times\")\n\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/JobStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass JobStressTest : TestBase() {\n    @Test\n    fun testMemoryRelease() {\n        val job = Job()\n        val n = 10_000_000 * stressTestMultiplier\n        var fireCount = 0\n        for (i in 0 until n) job.invokeOnCompletion { fireCount++ }.dispose()\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/JoinStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass JoinStressTest : TestBase() {\n\n    private val iterations = 50_000 * stressTestMultiplier\n    private val pool = newFixedThreadPoolContext(3, \"JoinStressTest\")\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    @Test\n    fun testExceptionalJoinWithCancellation() = runBlocking {\n        val results = IntArray(2)\n\n        repeat(iterations) {\n            val barrier = CyclicBarrier(3)\n            val exceptionalJob = async(pool + NonCancellable) {\n                barrier.await()\n                throw TestException()\n            }\n\n\n            val awaiterJob = async(pool) {\n                barrier.await()\n                try {\n                    exceptionalJob.await()\n                } catch (e: TestException) {\n                    0\n                } catch (e: CancellationException) {\n                    1\n                }\n            }\n\n            barrier.await()\n            exceptionalJob.cancel()\n            ++results[awaiterJob.await()]\n        }\n\n        // Check that concurrent cancellation of job which throws TestException without suspends doesn't suppress TestException\n        assertEquals(iterations, results[0], results.toList().toString())\n        assertEquals(0, results[1], results.toList().toString())\n    }\n\n    @Test\n    fun testExceptionalJoinWithMultipleCancellations() = runBlocking {\n        val results = IntArray(2)\n\n        repeat(iterations) {\n            val barrier = CyclicBarrier(4)\n            val exceptionalJob = async<Unit>(pool + NonCancellable) {\n                barrier.await()\n                throw TestException()\n            }\n\n            val awaiterJob = async(pool) {\n                barrier.await()\n                try {\n                    exceptionalJob.await()\n                    2\n                } catch (e: TestException) {\n                    0\n                } catch (e: TestException1) {\n                    1\n                }\n            }\n\n            val canceller = async(pool + NonCancellable) {\n                barrier.await()\n                // cast for test purposes only\n                (exceptionalJob as AbstractCoroutine<*>).cancelInternal(TestException1())\n            }\n\n            barrier.await()\n            val awaiterResult = awaiterJob.await()\n            canceller.await()\n            ++results[awaiterResult]\n        }\n\n        assertTrue(results[0] > 0, results.toList().toString())\n        assertTrue(results[1] > 0, results.toList().toString())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/LimitedParallelismStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass LimitedParallelismStressTest(private val targetParallelism: Int) : TestBase() {\n\n    companion object {\n        @Parameterized.Parameters(name = \"{0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = listOf(1, 2, 3, 4).map { arrayOf(it) }\n    }\n\n    @get:Rule\n    val executor = ExecutorRule(targetParallelism * 2)\n    private val iterations = 100_000\n\n    private val parallelism = AtomicInteger(0)\n\n    private fun checkParallelism() {\n        val value = parallelism.incrementAndGet()\n        Thread.yield()\n        assertTrue { value <= targetParallelism }\n        parallelism.decrementAndGet()\n    }\n\n    @Test\n    fun testLimitedExecutor() = runTest {\n        val view = executor.limitedParallelism(targetParallelism)\n        doStress {\n            repeat(iterations) {\n                launch(view) {\n                    checkParallelism()\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testLimitedDispatchersIo() = runTest {\n        val view = Dispatchers.IO.limitedParallelism(targetParallelism)\n        doStress {\n            repeat(iterations) {\n                launch(view) {\n                    checkParallelism()\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testLimitedDispatchersIoDispatchYield() = runTest {\n        val view = Dispatchers.IO.limitedParallelism(targetParallelism)\n        doStress {\n            launch(view) {\n                yield()\n                checkParallelism()\n            }\n        }\n    }\n\n    @Test\n    fun testLimitedExecutorReachesTargetParallelism() = runTest {\n        val view = executor.limitedParallelism(targetParallelism)\n        doStress {\n            repeat(iterations) {\n                val barrier = CyclicBarrier(targetParallelism + 1)\n                repeat(targetParallelism) {\n                    launch(view) {\n                        barrier.await()\n                    }\n                }\n                // Successfully awaited parallelism + 1\n                barrier.await()\n                coroutineContext.job.children.toList().joinAll()\n            }\n        }\n    }\n\n    private suspend inline fun doStress(crossinline block: suspend CoroutineScope.() -> Unit) {\n        repeat(stressTestMultiplier) {\n            coroutineScope {\n                block()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/LimitedParallelismUnhandledExceptionTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass LimitedParallelismUnhandledExceptionTest : TestBase() {\n\n    @Test\n    fun testUnhandledException() = runTest {\n        var caughtException: Throwable? = null\n        val executor = Executors.newFixedThreadPool(\n            1\n        ) {\n            Thread(it).also {\n                it.uncaughtExceptionHandler = Thread.UncaughtExceptionHandler { _, e -> caughtException = e }\n            }\n        }.asCoroutineDispatcher()\n        val view = executor.limitedParallelism(1)\n        view.dispatch(EmptyCoroutineContext, Runnable { throw TestException() })\n        withContext(view) {\n            // Verify it is in working state and establish happens-before\n        }\n        assertTrue { caughtException is TestException }\n        executor.close()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/MemoryFootprintTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport org.openjdk.jol.info.ClassLayout\nimport kotlin.test.*\n\n\nclass MemoryFootprintTest : TestBase(true) {\n\n    @Test\n    fun testJobLayout() = assertLayout(Job().javaClass, 24)\n\n    @Test\n    fun testCancellableContinuationFootprint() = assertLayout(CancellableContinuationImpl::class.java, 48)\n\n    private fun assertLayout(clz: Class<*>, expectedSize: Int) {\n        val size = ClassLayout.parseClass(clz).instanceSize()\n//        println(ClassLayout.parseClass(clz).toPrintable())\n        assertEquals(expectedSize.toLong(), size)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/MutexCancellationStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlinx.coroutines.sync.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.atomic.AtomicInteger\nimport kotlin.test.*\n\nclass MutexCancellationStressTest : TestBase() {\n    @Test\n    fun testStressCancellationDoesNotBreakMutex() = runTest {\n        val mutex = Mutex()\n        val mutexJobNumber = 3\n        val mutexOwners = Array(mutexJobNumber) { \"$it\" }\n        val dispatcher = Executors.newFixedThreadPool(mutexJobNumber + 2).asCoroutineDispatcher()\n        var counter = 0\n        val counterLocal = Array(mutexJobNumber) { AtomicInteger(0) }\n        val completed = AtomicBoolean(false)\n        val mutexJobLauncher: (jobNumber: Int) -> Job = { jobId ->\n            val coroutineName = \"MutexJob-$jobId\"\n            // ATOMIC to always have a chance to proceed\n            launch(dispatcher + CoroutineName(coroutineName), CoroutineStart.ATOMIC) {\n                while (!completed.get()) {\n                    // Stress out holdsLock\n                    mutex.holdsLock(mutexOwners[(jobId + 1) % mutexJobNumber])\n                    // Stress out lock-like primitives\n                    if (mutex.tryLock(mutexOwners[jobId])) {\n                        counterLocal[jobId].incrementAndGet()\n                        counter++\n                        mutex.unlock(mutexOwners[jobId])\n                    }\n                    mutex.withLock(mutexOwners[jobId]) {\n                        counterLocal[jobId].incrementAndGet()\n                        counter++\n                    }\n                    select<Unit> {\n                        mutex.onLock(mutexOwners[jobId]) {\n                            counterLocal[jobId].incrementAndGet()\n                            counter++\n                            mutex.unlock(mutexOwners[jobId])\n                        }\n                    }\n                }\n            }\n        }\n        val mutexJobs = (0 until mutexJobNumber).map { mutexJobLauncher(it) }.toMutableList()\n        val checkProgressJob = launch(dispatcher + CoroutineName(\"checkProgressJob\")) {\n            var lastCounterLocalSnapshot = (0 until mutexJobNumber).map { 0 }\n            while (!completed.get()) {\n                delay(500)\n                // If we've caught the completion after delay, then there is a chance no progress were made whatsoever, bail out\n                if (completed.get()) return@launch\n                val c = counterLocal.map { it.value }\n                for (i in 0 until mutexJobNumber) {\n                    assert(c[i] > lastCounterLocalSnapshot[i]) { \"No progress in MutexJob-$i, last observed state: ${c[i]}\" }\n                }\n                lastCounterLocalSnapshot = c\n            }\n        }\n        val cancellationJob = launch(dispatcher + CoroutineName(\"cancellationJob\")) {\n            var cancellingJobId = 0\n            while (!completed.get()) {\n                val jobToCancel = mutexJobs.removeFirst()\n                jobToCancel.cancelAndJoin()\n                mutexJobs += mutexJobLauncher(cancellingJobId)\n                cancellingJobId = (cancellingJobId + 1) % mutexJobNumber\n            }\n        }\n        delay(2000L * stressTestMultiplier)\n        completed.set(true)\n        cancellationJob.join()\n        mutexJobs.forEach { it.join() }\n        checkProgressJob.join()\n        assertEquals(counter, counterLocal.sumOf { it.value })\n        dispatcher.close()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/NoParamAssertionsTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\n\nclass NoParamAssertionsTest : TestBase() {\n    // These tests verify that we haven't omitted \"-Xno-param-assertions\" and \"-Xno-receiver-assertions\"\n\n    @Test\n    fun testNoReceiverAssertion() {\n        val function: (ThreadLocal<Int>, Int) -> ThreadContextElement<Int> = ThreadLocal<Int>::asContextElement\n        @Suppress(\"UNCHECKED_CAST\")\n        val unsafeCasted = function as ((ThreadLocal<Int>?, Int) -> ThreadContextElement<Int>)\n        unsafeCasted(null, 42)\n    }\n\n    @Test\n    fun testNoParamAssertion() {\n        val function: (ThreadLocal<Any>, Any) -> ThreadContextElement<Any> = ThreadLocal<Any>::asContextElement\n        @Suppress(\"UNCHECKED_CAST\")\n        val unsafeCasted = function as ((ThreadLocal<Any?>?, Any?) -> ThreadContextElement<Any>)\n        unsafeCasted(ThreadLocal.withInitial { Any() }, null)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/RejectedExecutionTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.scheduling.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass RejectedExecutionTest : TestBase() {\n    private val threadName = \"RejectedExecutionTest\"\n    private val executor = RejectingExecutor()\n\n    @After\n    fun tearDown() {\n        executor.shutdown()\n        executor.awaitTermination(10, TimeUnit.SECONDS)\n    }\n\n    @Test\n    fun testRejectOnLaunch() = runTest {\n        expect(1)\n        val job = launch(executor.asCoroutineDispatcher()) {\n            expectUnreached()\n        }\n        assertEquals(1, executor.submittedTasks)\n        assertTrue(job.isCancelled)\n        finish(2)\n    }\n\n    @Test\n    fun testRejectOnLaunchAtomic() = runTest {\n        expect(1)\n        val job = launch(executor.asCoroutineDispatcher(), start = CoroutineStart.ATOMIC) {\n            expect(2)\n            assertEquals(true, coroutineContext[Job]?.isCancelled)\n            assertIoThread() // was rejected on start, but start was atomic\n        }\n        assertEquals(1, executor.submittedTasks)\n        job.join()\n        finish(3)\n    }\n\n    @Test\n    fun testRejectOnWithContext() = runTest {\n        expect(1)\n        assertFailsWith<CancellationException> {\n            withContext(executor.asCoroutineDispatcher()) {\n                expectUnreached()\n            }\n        }\n        assertEquals(1, executor.submittedTasks)\n        finish(2)\n    }\n\n    @Test\n    fun testRejectOnResumeInContext() = runTest {\n        expect(1)\n        executor.acceptTasks = 1 // accept one task\n        assertFailsWith<CancellationException> {\n                withContext(executor.asCoroutineDispatcher()) {\n                    expect(2)\n                    assertExecutorThread()\n                    try {\n                        withContext(Dispatchers.Default) {\n                            expect(3)\n                            assertDefaultDispatcherThread()\n                            // We have to wait until caller executor thread had already suspended (if not running task),\n                            // so that we resume back to it a new task is posted\n                            executor.awaitNotRunningTask()\n                            expect(4)\n                            assertDefaultDispatcherThread()\n                        }\n                        // cancelled on resume back\n                    } finally {\n                        expect(5)\n                        assertIoThread()\n                    }\n                    expectUnreached()\n                }\n        }\n        assertEquals(2, executor.submittedTasks)\n        finish(6)\n    }\n\n    @Test\n    fun testRejectOnDelay() = runTest {\n        if (!removeFutureOnCancel(executor)) return@runTest // Skip this test on old JDKs\n        expect(1)\n        executor.acceptTasks = 1 // accept one task\n        assertFailsWith<CancellationException> {\n            withContext(executor.asCoroutineDispatcher()) {\n                expect(2)\n                assertExecutorThread()\n                try {\n                    delay(10) // cancelled\n                } finally {\n                    // Since it was cancelled on attempt to delay, it still stays on the same thread\n                    assertExecutorThread()\n                }\n                expectUnreached()\n            }\n        }\n        assertEquals(2, executor.submittedTasks)\n        finish(3)\n    }\n\n    @Test\n    fun testRejectWithTimeout() = runTest {\n        if (!removeFutureOnCancel(executor)) return@runTest // Skip this test on old JDKs\n        expect(1)\n        executor.acceptTasks = 1 // accept one task\n        assertFailsWith<CancellationException> {\n            withContext(executor.asCoroutineDispatcher()) {\n                expect(2)\n                assertExecutorThread()\n                withTimeout(1000) {\n                    expect(3) // atomic entry into the block (legacy behavior, it seem to be Ok with way)\n                    assertEquals(true, coroutineContext[Job]?.isCancelled) // but the job is already cancelled\n                }\n                expectUnreached()\n            }\n        }\n        assertEquals(2, executor.submittedTasks)\n        finish(4)\n    }\n\n    private inner class RejectingExecutor : ScheduledThreadPoolExecutor(1, { r -> Thread(r, threadName) }) {\n        var acceptTasks = 0\n        var submittedTasks = 0\n        val runningTask = MutableStateFlow(false)\n\n        override fun schedule(command: Runnable, delay: Long, unit: TimeUnit): ScheduledFuture<*> {\n            submittedTasks++\n            if (submittedTasks > acceptTasks) throw RejectedExecutionException()\n            val wrapper = Runnable {\n                runningTask.value = true\n                try {\n                    command.run()\n                } finally {\n                    runningTask.value = false\n                }\n            }\n            return super.schedule(wrapper, delay, unit)\n        }\n\n        suspend fun awaitNotRunningTask() = runningTask.first { !it }\n    }\n\n    private fun assertExecutorThread() {\n        val thread = Thread.currentThread()\n        if (!thread.name.startsWith(threadName)) error(\"Not an executor thread: $thread\")\n    }\n\n    private fun assertDefaultDispatcherThread() {\n        val thread = Thread.currentThread()\n        if (thread !is CoroutineScheduler.Worker) error(\"Not a thread from Dispatchers.Default: $thread\")\n        assertEquals(CoroutineScheduler.WorkerState.CPU_ACQUIRED, thread.state)\n    }\n\n    private fun assertIoThread() {\n        val thread = Thread.currentThread()\n        if (thread !is CoroutineScheduler.Worker) error(\"Not a thread from Dispatchers.IO: $thread\")\n        assertEquals(CoroutineScheduler.WorkerState.BLOCKING, thread.state)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ReusableCancellableContinuationInvariantStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicReference\nimport kotlin.coroutines.*\n\n// Stresses scenario from #3613\nclass ReusableCancellableContinuationInvariantStressTest : TestBase() {\n\n    // Tests have a timeout 10 sec because the bug they catch leads to an infinite spin-loop\n\n    @Test(timeout = 10_000)\n    fun testExceptionFromSuspendReusable() = doTest { /* nothing */ }\n\n\n    @Test(timeout = 10_000)\n    fun testExceptionFromCancelledSuspendReusable() = doTest { it.cancel() }\n\n\n    @Suppress(\"SuspendFunctionOnCoroutineScope\")\n    private inline fun doTest(crossinline block: (Job) -> Unit) {\n        runTest {\n            repeat(10_000) {\n                val latch = CountDownLatch(1)\n                val continuationToResume = AtomicReference<Continuation<Unit>?>(null)\n                val j1 = launch(Dispatchers.Default) {\n                    latch.await()\n                    suspendCancellableCoroutineReusable {\n                        continuationToResume.set(it)\n                        block(coroutineContext.job)\n                        throw CancellationException() // Don't let getResult() chance to execute\n                    }\n                }\n\n                val j2 = launch(Dispatchers.Default) {\n                    latch.await()\n                    while (continuationToResume.get() == null) {\n                        // spin\n                    }\n                    continuationToResume.get()!!.resume(Unit)\n                }\n\n                latch.countDown()\n                joinAll(j1, j2)\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ReusableCancellableContinuationLeakStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass ReusableCancellableContinuationLeakStressTest : TestBase() {\n\n    @Suppress(\"UnnecessaryVariable\")\n    private suspend fun <T : Any> ReceiveChannel<T>.receiveBatch(): T {\n        val r = receive() // DO NOT MERGE LINES, otherwise TCE will kick in\n        return r\n    }\n\n    private val iterations = 100_000 * stressTestMultiplier\n\n    class Leak(val i: Int)\n\n    @Test // Simplified version of #2564\n    fun testReusableContinuationLeak() = runTest {\n        val channel = produce(capacity = 1) { // from the main thread\n            (0 until iterations).forEach {\n                send(Leak(it))\n            }\n        }\n\n        launch(Dispatchers.Default) {\n            repeat (iterations) {\n                val value = channel.receiveBatch()\n                assertEquals(it, value.i)\n            }\n            (channel as Job).join()\n\n            FieldWalker.assertReachableCount(0, coroutineContext.job, false) { it is Leak }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ReusableCancellableContinuationTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ReusableCancellableContinuationTest : TestBase() {\n    @Test\n    fun testReusable() = runTest {\n        testContinuationsCount(10, 1, ::suspendCancellableCoroutineReusable)\n    }\n\n    @Test\n    fun testRegular() = runTest {\n        testContinuationsCount(10, 10, ::suspendCancellableCoroutine)\n    }\n\n    private suspend inline fun CoroutineScope.testContinuationsCount(\n        iterations: Int,\n        expectedInstances: Int,\n        suspender: suspend ((CancellableContinuation<Unit>) -> Unit) -> Unit\n    ) {\n        val result = mutableSetOf<CancellableContinuation<*>>()\n        val job = coroutineContext[Job]!!\n        val channel = Channel<Continuation<Unit>>(1)\n        launch {\n            channel.consumeEach {\n                val f = FieldWalker.walk(job)\n                result.addAll(f.filterIsInstance<CancellableContinuation<*>>())\n                it.resumeWith(Result.success(Unit))\n            }\n        }\n\n        repeat(iterations) {\n            suspender {\n                assertTrue(channel.trySend(it).isSuccess)\n            }\n        }\n        channel.close()\n        assertEquals(expectedInstances, result.size - 1)\n    }\n\n    @Test\n    fun testCancelledOnClaimedCancel() = runTest {\n        expect(1)\n        try {\n            suspendCancellableCoroutineReusable<Unit> {\n                it.cancel()\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testNotCancelledOnClaimedResume() = runTest({ it is CancellationException }) {\n        expect(1)\n        // Bind child at first\n        var continuation: Continuation<*>? = null\n        suspendCancellableCoroutineReusable<Unit> {\n            expect(2)\n            continuation = it\n            launch {  // Attach to the parent, avoid fast path\n                expect(3)\n                it.resume(Unit)\n            }\n        }\n        expect(4)\n        ensureActive()\n        // Verify child was bound\n        FieldWalker.assertReachableCount(1, coroutineContext[Job]) { it === continuation }\n        try {\n            suspendCancellableCoroutineReusable<Unit> {\n                expect(5)\n                coroutineContext[Job]!!.cancel()\n                it.resume(Unit) // will not dispatch, will get CancellationException\n            }\n        } catch (e: CancellationException) {\n            assertFalse(isActive)\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testResumeReusablePreservesReference() = runTest {\n        expect(1)\n        var cont: Continuation<Unit>? = null\n        launch {\n            cont!!.resumeWith(Result.success(Unit))\n        }\n        suspendCancellableCoroutineReusable<Unit> {\n            cont = it\n        }\n        ensureActive()\n        assertTrue { FieldWalker.walk(coroutineContext[Job]).contains(cont!!) }\n        finish(2)\n    }\n\n    @Test\n    fun testResumeRegularDoesntPreservesReference() = runTest {\n        expect(1)\n        var cont: Continuation<Unit>? = null\n        launch { // Attach to the parent, avoid fast path\n            cont!!.resumeWith(Result.success(Unit))\n        }\n        suspendCancellableCoroutine<Unit> {\n            cont = it\n        }\n        ensureActive()\n        FieldWalker.assertReachableCount(0, coroutineContext[Job]) { it === cont }\n        finish(2)\n    }\n\n    @Test\n    fun testDetachedOnCancel() = runTest {\n        expect(1)\n        var cont: Continuation<*>? = null\n        try {\n            suspendCancellableCoroutineReusable<Unit> {\n                cont = it\n                it.cancel()\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            FieldWalker.assertReachableCount(0, coroutineContext[Job]) { it === cont }\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testPropagatedCancel() = runTest({it is CancellationException}) {\n        val currentJob = coroutineContext[Job]!!\n        expect(1)\n        // Bind child at first\n        suspendCancellableCoroutineReusable<Unit> {\n            expect(2)\n            // Attach to the parent, avoid fast path\n            launch {\n                expect(3)\n                it.resume(Unit)\n            }\n        }\n        expect(4)\n        ensureActive()\n        // Verify child was bound\n        FieldWalker.assertReachableCount(1, currentJob) { it is CancellableContinuation<*> }\n        currentJob.cancel()\n        assertFalse(isActive)\n        // Child detached\n        FieldWalker.assertReachableCount(0, currentJob) { it is CancellableContinuation<*> }\n        expect(5)\n        try {\n            // Resume is non-atomic, so it throws cancellation exception\n            suspendCancellableCoroutineReusable<Unit> {\n                expect(6) // but the code inside the block is executed\n                it.resume(Unit)\n            }\n        } catch (e: CancellationException) {\n            FieldWalker.assertReachableCount(0, currentJob) { it is CancellableContinuation<*> }\n            expect(7)\n        }\n        try {\n            // No resume -- still cancellation exception\n            suspendCancellableCoroutineReusable<Unit> {}\n        } catch (e: CancellationException) {\n            FieldWalker.assertReachableCount(0, currentJob) { it is CancellableContinuation<*> }\n            finish(8)\n        }\n    }\n\n    @Test\n    fun testChannelMemoryLeak() = runTest {\n        val iterations = 100\n        val channel = Channel<Unit>()\n        launch {\n            repeat(iterations) {\n                select {\n                    channel.onSend(Unit) {}\n                }\n            }\n        }\n\n        val receiver = launch {\n            repeat(iterations) {\n                channel.receive()\n            }\n            expect(2)\n            val job = coroutineContext[Job]!!\n            // 1 for reusable CC, another one for outer joiner\n            FieldWalker.assertReachableCount(2, job) { it is CancellableContinuation<*> }\n        }\n        expect(1)\n        receiver.join()\n        // Reference should be claimed at this point\n        FieldWalker.assertReachableCount(0, receiver) { it is CancellableContinuation<*> }\n        finish(3)\n    }\n\n    @Test\n    fun testReusableAndRegularSuspendCancellableCoroutineMemoryLeak() = runTest {\n        val channel =  produce {\n            repeat(10) {\n                send(Unit)\n            }\n        }\n        for (value in channel) {\n            delay(1)\n        }\n        FieldWalker.assertReachableCount(1, coroutineContext[Job]) { it is ChildContinuation }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ReusableContinuationStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.*\n\nclass ReusableContinuationStressTest : TestBase() {\n\n    private val iterations = 1000 * stressTestMultiplierSqrt\n\n    @Test // Originally reported by @denis-bezrukov in #2736\n    fun testDebounceWithStateFlow() = runBlocking<Unit> {\n        withContext(Dispatchers.Default) {\n            repeat(iterations) {\n                launch { // <- load the dispatcher and OS scheduler\n                    runStressTestOnce(1, 1)\n                }\n            }\n        }\n    }\n\n    private suspend fun runStressTestOnce(delay: Int, debounce: Int) = coroutineScope {\n        val stateFlow = MutableStateFlow(0)\n        val emitter = launch {\n            repeat(1000) { i ->\n                stateFlow.emit(i)\n                delay(delay.toLong())\n            }\n        }\n        var last = 0\n        stateFlow.debounce(debounce.toLong()).take(100).collect { i ->\n            if (i - last > 100) {\n                last = i\n            }\n        }\n        emitter.cancel()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/RunBlockingJvmTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\n\nclass RunBlockingJvmTest : TestBase() {\n    @Test\n    fun testContract() {\n        val rb: Int\n        runBlocking {\n            rb = 42\n        }\n        rb.hashCode() // unused\n    }\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/RunInterruptibleStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\n/**\n * Stress test for [runInterruptible].\n * It does not pass on JDK 1.6 on Windows: [Thread.sleep] times out without being interrupted despite the\n * fact that thread interruption flag is set.\n */\nclass RunInterruptibleStressTest : TestBase() {\n    @get:Rule\n    val dispatcher = ExecutorRule(4)\n    private val repeatTimes = 1000 * stressTestMultiplier\n\n    @Test\n    fun testStress() = runTest {\n        val enterCount = AtomicInteger(0)\n        val interruptedCount = AtomicInteger(0)\n\n        repeat(repeatTimes) {\n            val job = launch(dispatcher) {\n                try {\n                    runInterruptible {\n                        enterCount.incrementAndGet()\n                        try {\n                            Thread.sleep(10_000)\n                            error(\"Sleep was not interrupted, Thread.isInterrupted=${Thread.currentThread().isInterrupted}\")\n                        } catch (e: InterruptedException) {\n                            interruptedCount.incrementAndGet()\n                            throw e\n                        }\n                    }\n                } catch (e: CancellationException) {\n                    // Expected\n                } finally {\n                    assertFalse(Thread.currentThread().isInterrupted, \"Interrupt flag should not leak\")\n                }\n            }\n            // Add dispatch delay\n            val cancelJob = launch(dispatcher) {\n                job.cancel()\n            }\n            joinAll(job, cancelJob)\n        }\n        println(\"Entered runInterruptible ${enterCount.get()} times\")\n        assertTrue(enterCount.get() > 0) // ensure timing is Ok and we don't cancel it all prematurely\n        assertEquals(enterCount.get(), interruptedCount.get())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/RunInterruptibleTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport java.io.*\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\nclass RunInterruptibleTest : TestBase() {\n\n    @Test\n    fun testNormalRun() = runTest {\n        val result = runInterruptible {\n            val x = 1\n            val y = 2\n            Thread.sleep(1)\n            x + y\n        }\n        assertEquals(3, result)\n    }\n\n    @Test\n    fun testExceptionalRun() = runTest {\n        try {\n            runInterruptible {\n                expect(1)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testInterrupt() = runTest {\n        val latch = Channel<Unit>(1)\n        val job = launch {\n            runInterruptible(Dispatchers.IO) {\n                expect(2)\n                latch.trySend(Unit)\n                try {\n                    Thread.sleep(10_000L)\n                    expectUnreached()\n                } catch (e: InterruptedException) {\n                    expect(4)\n                    assertFalse { Thread.currentThread().isInterrupted }\n                }\n            }\n        }\n\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(1)\n            latch.receive()\n            expect(3)\n            job.cancelAndJoin()\n        }.join()\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/TestBaseTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\n\nclass TestBaseTest : TestBase() {\n    @Test\n    fun testThreadsShutdown() {\n        repeat(1000 * stressTestMultiplier) { _ ->\n            initPoolsBeforeTest()\n            val threadsBefore = currentThreads()\n            runBlocking {\n                val sub = launch {\n                    delay(10000000L)\n                }\n                sub.cancel()\n                sub.join()\n            }\n            shutdownPoolsAfterTest()\n            checkTestThreads(threadsBefore)\n        }\n\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/TestSecurityManager.kt",
        "content": "package kotlinx.coroutines\n\nimport java.security.Permission\n\n@Suppress(\"unused\")\nclass TestSecurityManager : SecurityManager() {\n    override fun checkPropertyAccess(key: String?) {\n        if (key?.startsWith(\"kotlinx.\") == true)\n            throw SecurityException(\"'$key' property is not allowed\")\n    }\n\n    override fun checkPermission(perm: Permission?) {\n        /* allow everything else */\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ThreadContextElementRestoreTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ThreadContextElementRestoreTest : TestBase() {\n    private val tl = ThreadLocal<String?>()\n\n    // Checks that ThreadLocal context is properly restored after executing the given block inside\n    // withContext(tl.asContextElement(\"OK\")) code running in different outer contexts\n    private inline fun check(crossinline block: suspend () -> Unit) = runTest {\n        val mainDispatcher = coroutineContext[ContinuationInterceptor] as CoroutineDispatcher\n        // Scenario #1: withContext(ThreadLocal) direct from runTest\n        withContext(tl.asContextElement(\"OK\")) {\n            block()\n            assertEquals(\"OK\", tl.get())\n        }\n        assertEquals(null, tl.get())\n        // Scenario #2: withContext(ThreadLocal) from coroutineScope\n        coroutineScope {\n            withContext(tl.asContextElement(\"OK\")) {\n                block()\n                assertEquals(\"OK\", tl.get())\n            }\n            assertEquals(null, tl.get())\n        }\n        // Scenario #3: withContext(ThreadLocal) from undispatched withContext\n        withContext(CoroutineName(\"NAME\")) {\n            withContext(tl.asContextElement(\"OK\")) {\n                block()\n                assertEquals(\"OK\", tl.get())\n            }\n            assertEquals(null, tl.get())\n        }\n        // Scenario #4: withContext(ThreadLocal) from dispatched withContext\n        withContext(wrapperDispatcher()) {\n            withContext(tl.asContextElement(\"OK\")) {\n                block()\n                assertEquals(\"OK\", tl.get())\n            }\n            assertEquals(null, tl.get())\n        }\n        // Scenario #5: withContext(ThreadLocal) from withContext(ThreadLocal)\n        withContext(tl.asContextElement(null)) {\n            withContext(tl.asContextElement(\"OK\")) {\n                block()\n                assertEquals(\"OK\", tl.get())\n            }\n            assertEquals(null, tl.get())\n        }\n        // Scenario #6: withContext(ThreadLocal) from withTimeout\n        withTimeout(1000) {\n            withContext(tl.asContextElement(\"OK\")) {\n                block()\n                assertEquals(\"OK\", tl.get())\n            }\n            assertEquals(null, tl.get())\n        }\n        // Scenario #7: withContext(ThreadLocal) from withContext(Unconfined)\n        withContext(Dispatchers.Unconfined) {\n            withContext(tl.asContextElement(\"OK\")) {\n                block()\n                assertEquals(\"OK\", tl.get())\n            }\n            assertEquals(null, tl.get())\n        }\n        // Scenario #8: withContext(ThreadLocal) from withContext(Default)\n        withContext(Dispatchers.Default) {\n            withContext(tl.asContextElement(\"OK\")) {\n                block()\n                assertEquals(\"OK\", tl.get())\n            }\n            assertEquals(null, tl.get())\n        }\n        // Scenario #9: withContext(ThreadLocal) from withContext(mainDispatcher)\n        withContext(mainDispatcher) {\n            withContext(tl.asContextElement(\"OK\")) {\n                block()\n                assertEquals(\"OK\", tl.get())\n            }\n            assertEquals(null, tl.get())\n        }\n    }\n\n    @Test\n    fun testSimpleNoSuspend() =\n        check {}\n\n    @Test\n    fun testSimpleDelay() = check {\n        delay(1)\n    }\n\n    @Test\n    fun testSimpleYield() = check {\n        yield()\n    }\n\n    private suspend fun deepDelay() {\n        deepDelay2(); deepDelay2()\n    }\n\n    private suspend fun deepDelay2() {\n        delay(1); delay(1)\n    }\n\n    @Test\n    fun testDeepDelay() = check {\n        deepDelay()\n    }\n\n    private suspend fun deepYield() {\n        deepYield2(); deepYield2()\n    }\n\n    private suspend fun deepYield2() {\n        yield(); yield()\n    }\n\n    @Test\n    fun testDeepYield() = check {\n        deepYield()\n    }\n\n    @Test\n    fun testCoroutineScopeDelay() = check {\n        coroutineScope {\n            delay(1)\n        }\n    }\n\n    @Test\n    fun testCoroutineScopeYield() = check {\n        coroutineScope {\n            yield()\n        }\n    }\n\n    @Test\n    fun testWithContextUndispatchedDelay() = check {\n        withContext(CoroutineName(\"INNER\")) {\n            delay(1)\n        }\n    }\n\n    @Test\n    fun testWithContextUndispatchedYield() = check {\n        withContext(CoroutineName(\"INNER\")) {\n            yield()\n        }\n    }\n\n    @Test\n    fun testWithContextDispatchedDelay() = check {\n        withContext(wrapperDispatcher()) {\n            delay(1)\n        }\n    }\n\n    @Test\n    fun testWithContextDispatchedYield() = check {\n        withContext(wrapperDispatcher()) {\n            yield()\n        }\n    }\n\n    @Test\n    fun testWithTimeoutDelay() = check {\n        withTimeout(1000) {\n            delay(1)\n        }\n    }\n\n    @Test\n    fun testWithTimeoutYield() = check {\n        withTimeout(1000) {\n            yield()\n        }\n    }\n\n    @Test\n    fun testWithUnconfinedContextDelay() = check {\n        withContext(Dispatchers.Unconfined) {\n            delay(1)\n        }\n    }\n    @Test\n    fun testWithUnconfinedContextYield() = check {\n        withContext(Dispatchers.Unconfined) {\n            yield()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ThreadContextElementTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\nimport kotlinx.coroutines.flow.*\n\nclass ThreadContextElementTest : TestBase() {\n\n    @Test\n    fun testExample() = runTest {\n        val exceptionHandler = coroutineContext[CoroutineExceptionHandler]!!\n        val mainDispatcher = coroutineContext[ContinuationInterceptor]!!\n        val mainThread = Thread.currentThread()\n        val data = MyData()\n        val element = MyElement(data)\n        assertNull(myThreadLocal.get())\n        val job = GlobalScope.launch(element + exceptionHandler) {\n            assertTrue(mainThread != Thread.currentThread())\n            assertSame(element, coroutineContext[MyElement])\n            assertSame(data, myThreadLocal.get())\n            withContext(mainDispatcher) {\n                assertSame(mainThread, Thread.currentThread())\n                assertSame(element, coroutineContext[MyElement])\n                assertSame(data, myThreadLocal.get())\n            }\n            assertTrue(mainThread != Thread.currentThread())\n            assertSame(element, coroutineContext[MyElement])\n            assertSame(data, myThreadLocal.get())\n        }\n        assertNull(myThreadLocal.get())\n        job.join()\n        assertNull(myThreadLocal.get())\n    }\n\n    @Test\n    fun testUndispatched() = runTest {\n        val exceptionHandler = coroutineContext[CoroutineExceptionHandler]!!\n        val data = MyData()\n        val element = MyElement(data)\n        val job = GlobalScope.launch(\n            context = Dispatchers.Default + exceptionHandler + element,\n            start = CoroutineStart.UNDISPATCHED\n        ) {\n            assertSame(data, myThreadLocal.get())\n            yield()\n            assertSame(data, myThreadLocal.get())\n        }\n        assertNull(myThreadLocal.get())\n        job.join()\n        assertNull(myThreadLocal.get())\n    }\n\n    @Test\n    fun testWithContext() = runTest {\n        expect(1)\n        newSingleThreadContext(\"withContext\").use {\n            val data = MyData()\n            GlobalScope.async(Dispatchers.Default + MyElement(data)) {\n                assertSame(data, myThreadLocal.get())\n                expect(2)\n\n                val newData = MyData()\n                GlobalScope.async(it + MyElement(newData)) {\n                    assertSame(newData, myThreadLocal.get())\n                    expect(3)\n                }.await()\n\n                withContext(it + MyElement(newData)) {\n                    assertSame(newData, myThreadLocal.get())\n                    expect(4)\n                }\n\n                GlobalScope.async(it) {\n                    assertNull(myThreadLocal.get())\n                    expect(5)\n                }.await()\n\n                expect(6)\n            }.await()\n        }\n\n        finish(7)\n    }\n\n    @Test\n    fun testNonCopyableElementReferenceInheritedOnLaunch() = runTest {\n        var parentElement: MyElement? = null\n        var inheritedElement: MyElement? = null\n\n        newSingleThreadContext(\"withContext\").use {\n            withContext(it + MyElement(MyData())) {\n                parentElement = coroutineContext[MyElement.Key]\n                launch {\n                    inheritedElement = coroutineContext[MyElement.Key]\n                }\n            }\n        }\n\n        assertSame(inheritedElement, parentElement,\n            \"Inner and outer coroutines did not have the same object reference to a\" +\n                \" ThreadContextElement that did not override `copyForChildCoroutine()`\")\n    }\n\n    @Test\n    fun testCopyableElementCopiedOnLaunch() = runTest {\n        var parentElement: CopyForChildCoroutineElement? = null\n        var inheritedElement: CopyForChildCoroutineElement? = null\n\n        newSingleThreadContext(\"withContext\").use {\n            withContext(it + CopyForChildCoroutineElement(MyData())) {\n                parentElement = coroutineContext[CopyForChildCoroutineElement.Key]\n                launch {\n                    inheritedElement = coroutineContext[CopyForChildCoroutineElement.Key]\n                }\n            }\n        }\n\n        assertNotSame(inheritedElement, parentElement,\n            \"Inner coroutine did not copy its copyable ThreadContextElement.\")\n    }\n\n    @Test\n    fun testCopyableThreadContextElementImplementsWriteVisibility() = runTest {\n        newFixedThreadPoolContext(nThreads = 4, name = \"withContext\").use {\n            withContext(it + CopyForChildCoroutineElement(MyData())) {\n                val forBlockData = MyData()\n                myThreadLocal.setForBlock(forBlockData) {\n                    assertSame(myThreadLocal.get(), forBlockData)\n                    launch {\n                        assertSame(myThreadLocal.get(), forBlockData)\n                    }\n                    launch {\n                        assertSame(myThreadLocal.get(), forBlockData)\n                        // Modify value in child coroutine. Writes to the ThreadLocal and\n                        // the (copied) ThreadLocalElement's memory are not visible to peer or\n                        // ancestor coroutines, so this write is both threadsafe and coroutinesafe.\n                        val innerCoroutineData = MyData()\n                        myThreadLocal.setForBlock(innerCoroutineData) {\n                            assertSame(myThreadLocal.get(), innerCoroutineData)\n                        }\n                        assertSame(myThreadLocal.get(), forBlockData) // Asserts value was restored.\n                    }\n                    launch {\n                        val innerCoroutineData = MyData()\n                        myThreadLocal.setForBlock(innerCoroutineData) {\n                            assertSame(myThreadLocal.get(), innerCoroutineData)\n                        }\n                        assertSame(myThreadLocal.get(), forBlockData)\n                    }\n                }\n                assertNull(myThreadLocal.get()) // Asserts value was restored to its origin\n            }\n        }\n    }\n\n    class JobCaptor(val capturees: ArrayList<Job> = ArrayList()) : ThreadContextElement<Unit> {\n\n        companion object Key : CoroutineContext.Key<MyElement>\n\n        override val key: CoroutineContext.Key<*> get() = Key\n\n        override fun updateThreadContext(context: CoroutineContext) {\n            capturees.add(context.job)\n        }\n\n        override fun restoreThreadContext(context: CoroutineContext, oldState: Unit) {\n        }\n    }\n\n    @Test\n    fun testWithContextJobAccess() = runTest {\n        val captor = JobCaptor()\n        val manuallyCaptured = ArrayList<Job>()\n        runBlocking(captor) {\n            manuallyCaptured += coroutineContext.job\n            withContext(CoroutineName(\"undispatched\")) {\n                manuallyCaptured += coroutineContext.job\n                withContext(Dispatchers.IO) {\n                    manuallyCaptured += coroutineContext.job\n                }\n                // Context restored, captured again\n                manuallyCaptured += coroutineContext.job\n            }\n            // Context restored, captured again\n            manuallyCaptured += coroutineContext.job\n        }\n\n        assertEquals(manuallyCaptured, captor.capturees)\n    }\n\n    @Test\n    fun testThreadLocalFlowOn() = runTest {\n        val myData = MyData()\n        myThreadLocal.set(myData)\n        expect(1)\n        flow {\n            assertEquals(myData, myThreadLocal.get())\n            emit(1)\n        }\n            .flowOn(myThreadLocal.asContextElement() + Dispatchers.Default)\n            .single()\n        myThreadLocal.set(null)\n        finish(2)\n    }\n}\n\nclass MyData\n\n// declare thread local variable holding MyData\nprivate val myThreadLocal = ThreadLocal<MyData?>()\n\n// declare context element holding MyData\nclass MyElement(val data: MyData) : ThreadContextElement<MyData?> {\n    // declare companion object for a key of this element in coroutine context\n    companion object Key : CoroutineContext.Key<MyElement>\n\n    // provide the key of the corresponding context element\n    override val key: CoroutineContext.Key<MyElement>\n        get() = Key\n\n    // this is invoked before coroutine is resumed on current thread\n    override fun updateThreadContext(context: CoroutineContext): MyData? {\n        val oldState = myThreadLocal.get()\n        myThreadLocal.set(data)\n        return oldState\n    }\n\n    // this is invoked after coroutine has suspended on current thread\n    override fun restoreThreadContext(context: CoroutineContext, oldState: MyData?) {\n        myThreadLocal.set(oldState)\n    }\n}\n\n/**\n * A [ThreadContextElement] that implements copy semantics in [copyForChild].\n */\nclass CopyForChildCoroutineElement(val data: MyData?) : CopyableThreadContextElement<MyData?> {\n    companion object Key : CoroutineContext.Key<CopyForChildCoroutineElement>\n\n    override val key: CoroutineContext.Key<CopyForChildCoroutineElement>\n        get() = Key\n\n    override fun updateThreadContext(context: CoroutineContext): MyData? {\n        val oldState = myThreadLocal.get()\n        myThreadLocal.set(data)\n        return oldState\n    }\n\n    override fun mergeForChild(overwritingElement: CoroutineContext.Element): CopyForChildCoroutineElement {\n        TODO(\"Not used in tests\")\n    }\n\n    override fun restoreThreadContext(context: CoroutineContext, oldState: MyData?) {\n        myThreadLocal.set(oldState)\n    }\n\n    /**\n     * At coroutine launch time, the _current value of the ThreadLocal_ is inherited by the new\n     * child coroutine, and that value is copied to a new, unique, ThreadContextElement memory\n     * reference for the child coroutine to use uniquely.\n     *\n     * n.b. the value copied to the child must be the __current value of the ThreadLocal__ and not\n     * the value initially passed to the ThreadContextElement in order to reflect writes made to the\n     * ThreadLocal between coroutine resumption and the child coroutine launch point. Those writes\n     * will be reflected in the parent coroutine's [CopyForChildCoroutineElement] when it yields the\n     * thread and calls [restoreThreadContext].\n     */\n    override fun copyForChild(): CopyForChildCoroutineElement {\n        return CopyForChildCoroutineElement(myThreadLocal.get())\n    }\n}\n\n\n/**\n * Calls [block], setting the value of [this] [ThreadLocal] for the duration of [block].\n *\n * When a [CopyForChildCoroutineElement] for `this` [ThreadLocal] is used within a\n * [CoroutineContext], a ThreadLocal set this way will have the \"correct\" value expected lexically\n * at every statement reached, whether that statement is reached immediately, across suspend and\n * redispatch within one coroutine, or within a child coroutine. Writes made to the `ThreadLocal`\n * by child coroutines will not be visible to the parent coroutine. Writes made to the `ThreadLocal`\n * by the parent coroutine _after_ launching a child coroutine will not be visible to that child\n * coroutine.\n */\nprivate inline fun <ThreadLocalT, OutputT> ThreadLocal<ThreadLocalT>.setForBlock(\n    value: ThreadLocalT,\n    crossinline block: () -> OutputT\n) {\n    val priorValue = get()\n    set(value)\n    block()\n    set(priorValue)\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ThreadContextMutableCopiesTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ThreadContextMutableCopiesTest : TestBase() {\n    companion object {\n        val threadLocalData: ThreadLocal<MutableList<String>> = ThreadLocal.withInitial { ArrayList() }\n    }\n\n    class MyMutableElement(\n        val mutableData: MutableList<String>\n    ) : CopyableThreadContextElement<MutableList<String>> {\n\n        companion object Key : CoroutineContext.Key<MyMutableElement>\n\n        override val key: CoroutineContext.Key<*>\n            get() = Key\n\n        override fun updateThreadContext(context: CoroutineContext): MutableList<String> {\n            val st = threadLocalData.get()\n            threadLocalData.set(mutableData)\n            return st\n        }\n\n        override fun restoreThreadContext(context: CoroutineContext, oldState: MutableList<String>) {\n            threadLocalData.set(oldState)\n        }\n\n        override fun copyForChild(): MyMutableElement {\n            return MyMutableElement(ArrayList(mutableData))\n        }\n\n        override fun mergeForChild(overwritingElement: CoroutineContext.Element): MyMutableElement {\n            overwritingElement as MyMutableElement // <- app-specific, may be another subtype\n            return MyMutableElement((mutableData.toSet() + overwritingElement.mutableData).toMutableList())\n        }\n    }\n\n    @Test\n    fun testDataIsCopied() = runTest {\n        val root = MyMutableElement(ArrayList())\n        runBlocking(root) {\n            val data = threadLocalData.get()\n            expect(1)\n            launch(root) {\n                assertNotSame(data, threadLocalData.get())\n                assertEquals(data, threadLocalData.get())\n                finish(2)\n            }\n        }\n    }\n\n    @Test\n    fun testDataIsNotOverwritten() = runTest {\n        val root = MyMutableElement(ArrayList())\n        runBlocking(root) {\n            expect(1)\n            val originalData = threadLocalData.get()\n            threadLocalData.get().add(\"X\")\n            launch {\n                threadLocalData.get().add(\"Y\")\n                // Note here, +root overwrites the data\n                launch(Dispatchers.Default + root) {\n                    assertEquals(listOf(\"X\", \"Y\"), threadLocalData.get())\n                    assertNotSame(originalData, threadLocalData.get())\n                    finish(2)\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testDataIsMerged() = runTest {\n        val root = MyMutableElement(ArrayList())\n        runBlocking(root) {\n            expect(1)\n            val originalData = threadLocalData.get()\n            threadLocalData.get().add(\"X\")\n            launch {\n                threadLocalData.get().add(\"Y\")\n                // Note here, +root overwrites the data\n                launch(Dispatchers.Default + MyMutableElement(mutableListOf(\"Z\"))) {\n                    assertEquals(listOf(\"X\", \"Y\", \"Z\"), threadLocalData.get())\n                    assertNotSame(originalData, threadLocalData.get())\n                    finish(2)\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testDataIsNotOverwrittenWithContext() = runTest {\n        val root = MyMutableElement(ArrayList())\n        runBlocking(root) {\n            val originalData = threadLocalData.get()\n            threadLocalData.get().add(\"X\")\n            expect(1)\n            launch {\n                threadLocalData.get().add(\"Y\")\n                // Note here, +root overwrites the data\n                withContext(Dispatchers.Default + root) {\n                    assertEquals(listOf(\"X\", \"Y\"), threadLocalData.get())\n                    assertNotSame(originalData, threadLocalData.get())\n                    finish(2)\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testDataIsCopiedForRunBlocking() = runTest {\n        val root = MyMutableElement(ArrayList())\n        val originalData = root.mutableData\n        runBlocking(root) {\n            assertNotSame(originalData, threadLocalData.get())\n        }\n    }\n\n    @Test\n    fun testDataIsCopiedForCoroutine() = runTest {\n        val root = MyMutableElement(ArrayList())\n        val originalData = root.mutableData\n        expect(1)\n        launch(root) {\n            assertNotSame(originalData, threadLocalData.get())\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testDataIsCopiedThroughFlowOnUndispatched() = runTest {\n        expect(1)\n        val root = MyMutableElement(ArrayList())\n        val originalData = root.mutableData\n        flow {\n            assertNotSame(originalData, threadLocalData.get())\n            emit(1)\n        }\n            .flowOn(root)\n            .single()\n        finish(2)\n    }\n\n    @Test\n    fun testDataIsCopiedThroughFlowOnDispatched() = runTest {\n        expect(1)\n        val root = MyMutableElement(ArrayList())\n        val originalData = root.mutableData\n        flow {\n            assertNotSame(originalData, threadLocalData.get())\n            emit(1)\n        }\n            .flowOn(root + Dispatchers.Default)\n            .single()\n        finish(2)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ThreadContextOrderTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.internal.*\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ThreadContextOrderTest : TestBase() {\n    /*\n     * The test verifies that two thread context elements are correctly nested:\n     * The restoration order is the reverse of update order.\n     */\n    private val transactionalContext = ThreadLocal<String>()\n    private val loggingContext = ThreadLocal<String>()\n\n    private val transactionalElement = object : ThreadContextElement<String> {\n        override val key = ThreadLocalKey(transactionalContext)\n\n        override fun updateThreadContext(context: CoroutineContext): String {\n            assertEquals(\"test\", loggingContext.get())\n            val previous = transactionalContext.get()\n            transactionalContext.set(\"tr coroutine\")\n            return previous\n        }\n\n        override fun restoreThreadContext(context: CoroutineContext, oldState: String) {\n            assertEquals(\"test\", loggingContext.get())\n            assertEquals(\"tr coroutine\", transactionalContext.get())\n            transactionalContext.set(oldState)\n        }\n    }\n\n    private val loggingElement = object : ThreadContextElement<String> {\n        override val key = ThreadLocalKey(loggingContext)\n\n        override fun updateThreadContext(context: CoroutineContext): String {\n            val previous = loggingContext.get()\n            loggingContext.set(\"log coroutine\")\n            return previous\n        }\n\n        override fun restoreThreadContext(context: CoroutineContext, oldState: String) {\n            assertEquals(\"log coroutine\", loggingContext.get())\n            assertEquals(\"tr coroutine\", transactionalContext.get())\n            loggingContext.set(oldState)\n        }\n    }\n\n    @Test\n    fun testCorrectOrder() = runTest {\n        transactionalContext.set(\"test\")\n        loggingContext.set(\"test\")\n        launch(transactionalElement + loggingElement) {\n            assertEquals(\"log coroutine\", loggingContext.get())\n            assertEquals(\"tr coroutine\", transactionalContext.get())\n        }\n        assertEquals(\"test\", loggingContext.get())\n        assertEquals(\"test\", transactionalContext.get())\n\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ThreadLocalStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.sync.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.test.*\n\n\nclass ThreadLocalStressTest : TestBase() {\n\n    private val threadLocal = ThreadLocal<String>()\n\n    // See the comment in doStress for the machinery\n    @Test\n    fun testStress() = runTest {\n        repeat (100 * stressTestMultiplierSqrt) {\n            withContext(Dispatchers.Default) {\n                repeat(100) {\n                    launch {\n                        doStress(null)\n                    }\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testStressWithOuterValue() = runTest {\n        repeat (100 * stressTestMultiplierSqrt) {\n            withContext(Dispatchers.Default + threadLocal.asContextElement(\"bar\")) {\n                repeat(100) {\n                    launch {\n                        doStress(\"bar\")\n                    }\n                }\n            }\n        }\n    }\n\n    private suspend fun doStress(expectedValue: String?) {\n        assertEquals(expectedValue, threadLocal.get())\n        try {\n            /*\n             * Here we are using very specific code-path to trigger the execution we want to.\n             * The bug, in general, has a larger impact, but this particular code pinpoints it:\n             *\n             * 1) We use _undispatched_ withContext with thread element\n             * 2) We cancel the coroutine\n             * 3) We use 'suspendCancellableCoroutineReusable' that does _postponed_ cancellation check\n             *    which makes the reproduction of this race pretty reliable.\n             *\n             * Now the following code path is likely to be triggered:\n             *\n             * T1 from within 'withContinuationContext' method:\n             * Finds 'oldValue', finds undispatched completion, invokes its 'block' argument.\n             * 'block' is this coroutine, it goes to 'trySuspend', checks for postponed cancellation and *dispatches* it.\n             * The execution stops _right_ before 'undispatchedCompletion.clearThreadContext()'.\n             *\n             * T2 now executes the dispatched cancellation and concurrently mutates the state of the undispatched completion.\n             * All bets are off, now both threads can leave the thread locals state inconsistent.\n             */\n            withContext(threadLocal.asContextElement(\"foo\")) {\n                yield()\n                cancel()\n                suspendCancellableCoroutineReusable<Unit> { }\n            }\n        } finally {\n            assertEquals(expectedValue, threadLocal.get())\n        }\n    }\n\n    /*\n     * Another set of tests for undispatcheable continuations that do not require stress test multiplier.\n     * Also note that `uncaughtExceptionHandler` is used as the only available mechanism to propagate error from\n     * `resumeWith`\n     */\n\n    @Test\n    fun testNonDispatcheableLeak() {\n        repeat(100) {\n            doTestWithPreparation(\n                ::doTest,\n                { threadLocal.set(null) }) { threadLocal.get() == null }\n            assertNull(threadLocal.get())\n        }\n    }\n\n    @Test\n    fun testNonDispatcheableLeakWithInitial() {\n        repeat(100) {\n            doTestWithPreparation(::doTest, { threadLocal.set(\"initial\") }) { threadLocal.get() == \"initial\" }\n            assertEquals(\"initial\", threadLocal.get())\n        }\n    }\n\n    @Test\n    fun testNonDispatcheableLeakWithContextSwitch() {\n        repeat(100) {\n            doTestWithPreparation(\n                ::doTestWithContextSwitch,\n                { threadLocal.set(null) }) { threadLocal.get() == null }\n            assertNull(threadLocal.get())\n        }\n    }\n\n    @Test\n    fun testNonDispatcheableLeakWithInitialWithContextSwitch() {\n        repeat(100) {\n            doTestWithPreparation(\n                ::doTestWithContextSwitch,\n                { threadLocal.set(\"initial\") }) { true /* can randomly wake up on the non-main thread */ }\n            // Here we are always on the main thread\n            assertEquals(\"initial\", threadLocal.get())\n        }\n    }\n\n    private fun doTestWithPreparation(testBody: suspend () -> Unit, setup: () -> Unit, isValid: () -> Boolean) {\n        setup()\n        val latch = CountDownLatch(1)\n        testBody.startCoroutineUninterceptedOrReturn(Continuation(EmptyCoroutineContext) {\n            if (!isValid()) {\n                Thread.currentThread().uncaughtExceptionHandler.uncaughtException(\n                    Thread.currentThread(),\n                    IllegalStateException(\"Unexpected error: thread local was not cleaned\")\n                )\n            }\n            latch.countDown()\n        })\n        latch.await()\n    }\n\n    private suspend fun doTest() {\n        withContext(threadLocal.asContextElement(\"foo\")) {\n            try {\n                coroutineScope {\n                    val semaphore = Semaphore(1, 1)\n                    cancel()\n                    semaphore.acquire()\n                }\n            } catch (e: CancellationException) {\n                // Ignore cancellation\n            }\n        }\n    }\n\n    private suspend fun doTestWithContextSwitch() {\n        withContext(threadLocal.asContextElement(\"foo\")) {\n            try {\n                coroutineScope {\n                    val semaphore = Semaphore(1, 1)\n                    GlobalScope.launch { }.join()\n                    cancel()\n                    semaphore.acquire()\n                }\n            } catch (e: CancellationException) {\n                // Ignore cancellation\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/ThreadLocalTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport org.junit.Test\nimport java.lang.IllegalStateException\nimport kotlin.test.*\n\n@Suppress(\"RedundantAsync\")\nclass ThreadLocalTest : TestBase() {\n    private val stringThreadLocal = ThreadLocal<String?>()\n    private val intThreadLocal = ThreadLocal<Int?>()\n    private val executor = newFixedThreadPoolContext(1, \"threadLocalTest\")\n\n    @After\n    fun tearDown() {\n        executor.close()\n    }\n\n    @Test\n    fun testThreadLocal() = runTest {\n        assertNull(stringThreadLocal.get())\n        assertFalse(stringThreadLocal.isPresent())\n        val deferred = async(Dispatchers.Default + stringThreadLocal.asContextElement(\"value\")) {\n            assertEquals(\"value\", stringThreadLocal.get())\n            assertTrue(stringThreadLocal.isPresent())\n            withContext(executor) {\n                assertTrue(stringThreadLocal.isPresent())\n                assertFailsWith<IllegalStateException> { intThreadLocal.ensurePresent() }\n                assertEquals(\"value\", stringThreadLocal.get())\n            }\n            assertTrue(stringThreadLocal.isPresent())\n            assertEquals(\"value\", stringThreadLocal.get())\n        }\n\n        assertNull(stringThreadLocal.get())\n        deferred.await()\n        assertNull(stringThreadLocal.get())\n        assertFalse(stringThreadLocal.isPresent())\n    }\n\n    @Test\n    fun testThreadLocalInitialValue() = runTest {\n        intThreadLocal.set(42)\n        assertFalse(intThreadLocal.isPresent())\n        val deferred = async(Dispatchers.Default + intThreadLocal.asContextElement(239)) {\n            assertEquals(239, intThreadLocal.get())\n            withContext(executor) {\n                intThreadLocal.ensurePresent()\n                assertEquals(239, intThreadLocal.get())\n            }\n            assertEquals(239, intThreadLocal.get())\n        }\n\n        deferred.await()\n        assertEquals(42, intThreadLocal.get())\n    }\n\n    @Test\n    fun testMultipleThreadLocals() = runTest {\n        stringThreadLocal.set(\"test\")\n        intThreadLocal.set(314)\n\n        val deferred = async(Dispatchers.Default\n                + intThreadLocal.asContextElement(value = 239) + stringThreadLocal.asContextElement(value = \"pew\")) {\n            assertEquals(239, intThreadLocal.get())\n            assertEquals(\"pew\", stringThreadLocal.get())\n\n            withContext(executor) {\n                assertEquals(239, intThreadLocal.get())\n                assertEquals(\"pew\", stringThreadLocal.get())\n                intThreadLocal.ensurePresent()\n                stringThreadLocal.ensurePresent()\n            }\n\n            assertEquals(239, intThreadLocal.get())\n            assertEquals(\"pew\", stringThreadLocal.get())\n        }\n\n        deferred.await()\n        assertEquals(314, intThreadLocal.get())\n        assertEquals(\"test\", stringThreadLocal.get())\n    }\n\n    @Test\n    fun testConflictingThreadLocals() = runTest {\n        intThreadLocal.set(42)\n\n        val deferred = GlobalScope.async(intThreadLocal.asContextElement(1)) {\n            assertEquals(1, intThreadLocal.get())\n\n            withContext(executor + intThreadLocal.asContextElement(42)) {\n                assertEquals(42, intThreadLocal.get())\n            }\n\n            assertEquals(1, intThreadLocal.get())\n\n            val deferred = async(intThreadLocal.asContextElement(53)) {\n                assertEquals(53, intThreadLocal.get())\n            }\n\n            deferred.await()\n            assertEquals(1, intThreadLocal.get())\n\n            val deferred2 = GlobalScope.async(executor) {\n                assertNull(intThreadLocal.get())\n            }\n\n            deferred2.await()\n            assertEquals(1, intThreadLocal.get())\n        }\n\n        deferred.await()\n        assertEquals(42, intThreadLocal.get())\n    }\n\n    @Test\n    fun testThreadLocalModification() = runTest {\n        stringThreadLocal.set(\"main\")\n\n        val deferred = async(Dispatchers.Default\n                + stringThreadLocal.asContextElement(\"initial\")) {\n            assertEquals(\"initial\", stringThreadLocal.get())\n\n            stringThreadLocal.set(\"overridden\") // <- this value is not reflected in the context, so it's not restored\n\n            withContext(executor + stringThreadLocal.asContextElement(\"ctx\")) {\n                assertEquals(\"ctx\", stringThreadLocal.get())\n            }\n\n            val deferred = async(stringThreadLocal.asContextElement(\"async\")) {\n                assertEquals(\"async\", stringThreadLocal.get())\n            }\n\n            deferred.await()\n            assertEquals(\"initial\", stringThreadLocal.get()) // <- not restored\n        }\n\n        deferred.await()\n        assertFalse(stringThreadLocal.isPresent())\n        assertEquals(\"main\", stringThreadLocal.get())\n    }\n\n\n\n    private data class Counter(var cnt: Int)\n    private val myCounterLocal = ThreadLocal<Counter>()\n\n    @Test\n    fun testThreadLocalModificationMutableBox() = runTest {\n        myCounterLocal.set(Counter(42))\n\n        val deferred = async(Dispatchers.Default\n                + myCounterLocal.asContextElement(Counter(0))) {\n            assertEquals(0, myCounterLocal.get().cnt)\n\n            // Mutate\n            myCounterLocal.get().cnt = 71\n\n            withContext(executor + myCounterLocal.asContextElement(Counter(-1))) {\n                assertEquals(-1, myCounterLocal.get().cnt)\n                ++myCounterLocal.get().cnt\n            }\n\n            val deferred = async(myCounterLocal.asContextElement(Counter(31))) {\n                assertEquals(31, myCounterLocal.get().cnt)\n                ++myCounterLocal.get().cnt\n            }\n\n            deferred.await()\n            assertEquals(71, myCounterLocal.get().cnt)\n        }\n\n        deferred.await()\n        assertEquals(42, myCounterLocal.get().cnt)\n    }\n\n    @Test\n    fun testWithContext() = runTest {\n        expect(1)\n        newSingleThreadContext(\"withContext\").use {\n            val data = 42\n            GlobalScope.async(Dispatchers.Default + intThreadLocal.asContextElement(42)) {\n\n                assertEquals(data, intThreadLocal.get())\n                expect(2)\n\n                GlobalScope.async(it + intThreadLocal.asContextElement(31)) {\n                    assertEquals(31, intThreadLocal.get())\n                    expect(3)\n                }.await()\n\n                withContext(it + intThreadLocal.asContextElement(2)) {\n                    assertEquals(2, intThreadLocal.get())\n                    expect(4)\n                }\n\n                GlobalScope.async(it) {\n                    assertNull(intThreadLocal.get())\n                    expect(5)\n                }.await()\n\n                expect(6)\n            }.await()\n        }\n\n        finish(7)\n    }\n\n    @Test\n    fun testScope() = runTest {\n        intThreadLocal.set(42)\n        val mainThread = Thread.currentThread()\n        GlobalScope.async {\n          assertNull(intThreadLocal.get())\n            assertNotSame(mainThread, Thread.currentThread())\n        }.await()\n\n        GlobalScope.async(intThreadLocal.asContextElement()) {\n            assertEquals(42, intThreadLocal.get())\n            assertNotSame(mainThread, Thread.currentThread())\n        }.await()\n    }\n\n    @Test\n    fun testMissingThreadLocal() = runTest {\n        assertFailsWith<IllegalStateException> { stringThreadLocal.ensurePresent() }\n        assertFailsWith<IllegalStateException> { intThreadLocal.ensurePresent() }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/UnconfinedConcurrentStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass UnconfinedConcurrentStressTest : TestBase() {\n    private val threads = 4\n    private val executor = newFixedThreadPoolContext(threads, \"UnconfinedConcurrentStressTest\")\n    private val threadLocal = ThreadLocal<Int>()\n\n    @After\n    fun tearDown() {\n        executor.close()\n    }\n\n    @Test\n    fun testConcurrent() = runTest {\n        val iterations = 1_000 * stressTestMultiplier\n        val startBarrier = CyclicBarrier(threads + 1)\n        val finishLatch = CountDownLatch(threads)\n\n        repeat(threads) { id ->\n            launch(executor) {\n                startBarrier.await()\n                repeat(iterations) {\n                    threadLocal.set(0)\n                    launch(Dispatchers.Unconfined) {\n                        assertEquals(0, threadLocal.get())\n                        launch(Dispatchers.Unconfined) {\n                            assertEquals(id, threadLocal.get())\n                        }\n\n                        threadLocal.set(id)\n                    }\n                }\n\n                finishLatch.countDown()\n            }\n        }\n\n        startBarrier.await()\n        finishLatch.await()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/VirtualTimeSource.kt",
        "content": "package kotlinx.coroutines\n\nimport java.io.*\nimport java.util.concurrent.*\nimport java.util.concurrent.locks.*\n\nprivate const val SHUTDOWN_TIMEOUT = 1000L\n\ninternal inline fun withVirtualTimeSource(log: PrintStream? = null, block: () -> Unit) {\n    DefaultExecutor.shutdownForTests(SHUTDOWN_TIMEOUT) // shutdown execution with old time source (in case it was working)\n    val testTimeSource = VirtualTimeSource(log)\n    mockTimeSource(testTimeSource)\n    DefaultExecutor.ensureStarted() // should start with new time source\n    try {\n        block()\n    } finally {\n        DefaultExecutor.shutdownForTests(SHUTDOWN_TIMEOUT)\n        testTimeSource.shutdown()\n        mockTimeSource(null) // restore time source\n    }\n}\n\nprivate const val NOT_PARKED = -1L\n\nprivate class ThreadStatus {\n    @Volatile @JvmField\n    var parkedTill = NOT_PARKED\n    @Volatile @JvmField\n    var permit = false\n    var registered = 0\n    override fun toString(): String = \"parkedTill = ${TimeUnit.NANOSECONDS.toMillis(parkedTill)} ms, permit = $permit\"\n}\n\nprivate const val MAX_WAIT_NANOS = 10_000_000_000L // 10s\nprivate const val REAL_TIME_STEP_NANOS = 200_000_000L // 200 ms\nprivate const val REAL_PARK_NANOS = 10_000_000L // 10 ms -- park for a little to better track real-time\n\n@Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\ninternal class VirtualTimeSource(\n    private val log: PrintStream?\n) : AbstractTimeSource() {\n    private val mainThread: Thread = Thread.currentThread()\n    private var checkpointNanos: Long = System.nanoTime()\n\n    @Volatile\n    private var isShutdown = false\n\n    @Volatile\n    private var time: Long = 0\n\n    private var trackedTasks = 0\n\n    private val threads = ConcurrentHashMap<Thread, ThreadStatus>()\n\n    override fun currentTimeMillis(): Long = TimeUnit.NANOSECONDS.toMillis(time)\n    override fun nanoTime(): Long = time\n\n    override fun wrapTask(block: Runnable): Runnable {\n        trackTask()\n        return Runnable {\n            try { block.run() }\n            finally { unTrackTask() }\n        }\n    }\n\n    @Synchronized\n    override fun trackTask() {\n        trackedTasks++\n    }\n\n    @Synchronized\n    override fun unTrackTask() {\n        assert(trackedTasks > 0)\n        trackedTasks--\n    }\n\n    @Synchronized\n    override fun registerTimeLoopThread() {\n        val status = threads.getOrPut(Thread.currentThread()) { ThreadStatus() }!!\n        status.registered++\n    }\n\n    @Synchronized\n    override fun unregisterTimeLoopThread() {\n        val currentThread = Thread.currentThread()\n        val status = threads[currentThread]!!\n        if (--status.registered == 0) {\n            threads.remove(currentThread)\n            wakeupAll()\n        }\n    }\n\n    override fun parkNanos(blocker: Any, nanos: Long) {\n        if (nanos <= 0) return\n        val status = threads[Thread.currentThread()]!!\n        assert(status.parkedTill == NOT_PARKED)\n        status.parkedTill = time + nanos.coerceAtMost(MAX_WAIT_NANOS)\n        while (true) {\n            checkAdvanceTime()\n            if (isShutdown || time >= status.parkedTill || status.permit) {\n                status.parkedTill = NOT_PARKED\n                status.permit = false\n                break\n            }\n            LockSupport.parkNanos(blocker, REAL_PARK_NANOS)\n        }\n    }\n\n    override fun unpark(thread: Thread) {\n        val status = threads[thread] ?: return\n        status.permit = true\n        LockSupport.unpark(thread)\n    }\n\n    @Synchronized\n    private fun checkAdvanceTime() {\n        if (isShutdown) return\n        val realNanos = System.nanoTime()\n        if (realNanos > checkpointNanos + REAL_TIME_STEP_NANOS) {\n            checkpointNanos = realNanos\n            val minParkedTill = minParkedTill()\n            time = (time + REAL_TIME_STEP_NANOS).coerceAtMost(if (minParkedTill < 0) Long.MAX_VALUE else minParkedTill)\n            logTime(\"R\")\n            wakeupAll()\n            return\n        }\n        if (threads[mainThread] == null) return\n        if (trackedTasks != 0) return\n        val minParkedTill = minParkedTill()\n        if (minParkedTill <= time) return\n        time = minParkedTill\n        logTime(\"V\")\n        wakeupAll()\n    }\n\n    private fun logTime(s: String) {\n        log?.println(\"[$s: Time = ${TimeUnit.NANOSECONDS.toMillis(time)} ms]\")\n    }\n\n    private fun minParkedTill(): Long =\n        threads.values.map { if (it.permit) NOT_PARKED else it.parkedTill }.minOrNull() ?: NOT_PARKED\n\n    @Synchronized\n    fun shutdown() {\n        isShutdown = true\n        wakeupAll()\n        while (!threads.isEmpty()) (this as Object).wait()\n    }\n\n    private fun wakeupAll() {\n        threads.keys.forEach { LockSupport.unpark(it) }\n        (this as Object).notifyAll()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/WithDefaultContextTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass WithDefaultContextTest : TestBase() {\n    @Test\n    fun testNoSuspend() = runTest {\n        expect(1)\n        val result = withContext(Dispatchers.Default) {\n            expect(2)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(3)\n    }\n\n    @Test\n    fun testWithSuspend() = runTest {\n        expect(1)\n        val result = withContext(Dispatchers.Default) {\n            expect(2)\n            delay(100)\n            expect(3)\n            \"OK\"\n        }\n        assertEquals(\"OK\", result)\n        finish(4)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/WithTimeoutChildDipspatchStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass WithTimeoutChildDispatchStressTest : TestBase() {\n    private val N_REPEATS = 10_000 * stressTestMultiplier\n\n    /**\n     * This stress-test makes sure that dispatching resumption from within withTimeout\n     * works appropriately (without additional dispatch) despite the presence of\n     * children coroutine in a different dispatcher.\n     */\n    @Test\n    fun testChildDispatch() = runBlocking {\n        repeat(N_REPEATS) {\n            val result = withTimeout(5000) {\n                // child in different dispatcher\n                val job = launch(Dispatchers.Default) {\n                    // done nothing, but dispatches to join from another thread\n                }\n                job.join()\n                \"DONE\"\n            }\n            assertEquals(\"DONE\", result)\n        }\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/WithTimeoutOrNullJvmTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass WithTimeoutOrNullJvmTest : TestBase() {\n    @Test\n    fun testOuterTimeoutFiredBeforeInner() = runTest {\n        val result = withTimeoutOrNull(100) {\n            Thread.sleep(200) // wait enough for outer timeout to fire\n            withContext(NonCancellable) { yield() } // give an event loop a chance to run and process that cancellation\n            withTimeoutOrNull(100) {\n                yield() // will cancel because of outer timeout\n                expectUnreached()\n            }\n            expectUnreached() // should not be reached, because it is outer timeout\n        }\n        // outer timeout results in null\n        assertNull(result)\n    }\n\n    @Test\n    fun testIgnoredTimeout() = runTest {\n        val value = withTimeout(1) {\n            Thread.sleep(10)\n            42\n        }\n\n        assertEquals(42, value)\n    }\n\n    @Test\n    fun testIgnoredTimeoutOnNull() = runTest {\n        val value = withTimeoutOrNull(1) {\n            Thread.sleep(10)\n            42\n        }\n\n        assertEquals(42, value)\n    }\n\n    @Test\n    fun testIgnoredTimeoutOnNullThrowsCancellation() = runTest {\n        try {\n            withTimeoutOrNull(1) {\n                expect(1)\n                Thread.sleep(10)\n                throw CancellationException()\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testIgnoredTimeoutOnNullThrowsOnYield() = runTest {\n        val value = withTimeoutOrNull(1) {\n            Thread.sleep(75)\n            yield()\n        }\n        assertNull(value)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/WithTimeoutOrNullThreadDispatchTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\nimport java.util.concurrent.ExecutorService\nimport java.util.concurrent.Executors\nimport java.util.concurrent.ThreadFactory\nimport java.util.concurrent.atomic.AtomicInteger\nimport kotlin.coroutines.CoroutineContext\n\nclass WithTimeoutOrNullThreadDispatchTest : TestBase() {\n    var executor: ExecutorService? = null\n\n    @AfterTest\n    fun tearDown() {\n        executor?.shutdown()\n    }\n\n    @Test\n    fun testCancellationDispatchScheduled() {\n        checkCancellationDispatch {\n            executor = Executors.newScheduledThreadPool(1, it)\n            executor!!.asCoroutineDispatcher()\n        }\n    }\n\n    @Test\n    fun testCancellationDispatchNonScheduled() {\n        checkCancellationDispatch {\n            executor = Executors.newSingleThreadExecutor(it)\n            executor!!.asCoroutineDispatcher()\n        }\n    }\n\n    @Test\n    fun testCancellationDispatchCustomNoDelay() {\n        // it also checks that there is at most once scheduled request in flight (no spurious concurrency)\n        var error: String? = null\n        checkCancellationDispatch {\n            executor = Executors.newSingleThreadExecutor(it)\n            val scheduled = AtomicInteger(0)\n            object : CoroutineDispatcher() {\n                override fun dispatch(context: CoroutineContext, block: Runnable) {\n                    if (scheduled.incrementAndGet() > 1) error = \"Two requests are scheduled concurrently\"\n                    executor!!.execute {\n                        scheduled.decrementAndGet()\n                        block.run()\n                    }\n                }\n            }\n        }\n        error?.let { error(it) }\n    }\n\n    private fun checkCancellationDispatch(factory: (ThreadFactory) -> CoroutineDispatcher) = runBlocking {\n        expect(1)\n        var thread: Thread? = null\n        val dispatcher = factory(ThreadFactory { Thread(it).also { thread = it } })\n        withContext(dispatcher) {\n            expect(2)\n            assertEquals(thread, Thread.currentThread())\n            val result = withTimeoutOrNull(100) {\n                try {\n                    expect(3)\n                    delay(1000)\n                    expectUnreached()\n                } catch (e: CancellationException) {\n                    expect(4)\n                    assertEquals(thread, Thread.currentThread())\n                    throw e // rethrow\n                }\n            }\n            assertEquals(thread, Thread.currentThread())\n            assertNull(result)\n            expect(5)\n        }\n        finish(6)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/WithTimeoutThreadDispatchTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\nimport java.util.concurrent.ExecutorService\nimport java.util.concurrent.Executors\nimport java.util.concurrent.ThreadFactory\nimport java.util.concurrent.atomic.AtomicInteger\nimport kotlin.coroutines.CoroutineContext\n\nclass WithTimeoutThreadDispatchTest : TestBase() {\n    var executor: ExecutorService? = null\n\n    @AfterTest\n    fun tearDown() {\n        executor?.shutdown()\n    }\n\n    @Test\n    fun testCancellationDispatchScheduled() {\n        checkCancellationDispatch {\n            executor = Executors.newScheduledThreadPool(1, it)\n            executor!!.asCoroutineDispatcher()\n        }\n    }\n\n    @Test\n    fun testCancellationDispatchNonScheduled() {\n        checkCancellationDispatch {\n            executor = Executors.newSingleThreadExecutor(it)\n            executor!!.asCoroutineDispatcher()\n        }\n    }\n\n    @Test\n    fun testCancellationDispatchCustomNoDelay() {\n        // it also checks that there is at most once scheduled request in flight (no spurious concurrency)\n        var error: String? = null\n        checkCancellationDispatch {\n            executor = Executors.newSingleThreadExecutor(it)\n            val scheduled = AtomicInteger(0)\n            object : CoroutineDispatcher() {\n                override fun dispatch(context: CoroutineContext, block: Runnable) {\n                    if (scheduled.incrementAndGet() > 1) error = \"Two requests are scheduled concurrently\"\n                    executor!!.execute {\n                        scheduled.decrementAndGet()\n                        block.run()\n                    }\n                }\n            }\n        }\n        error?.let { error(it) }\n    }\n\n    private fun checkCancellationDispatch(factory: (ThreadFactory) -> CoroutineDispatcher) = runBlocking {\n        expect(1)\n        var thread: Thread? = null\n        val dispatcher = factory(ThreadFactory { Thread(it).also { thread = it } })\n        withContext(dispatcher) {\n            expect(2)\n            assertEquals(thread, Thread.currentThread())\n            try {\n                withTimeout(100) {\n                    try {\n                        expect(3)\n                        delay(1000)\n                        expectUnreached()\n                    } catch (e: CancellationException) {\n                        expect(4)\n                        assertEquals(thread, Thread.currentThread())\n                        throw e // rethrow\n                    }\n                }\n            } catch (e: CancellationException) {\n                expect(5)\n                assertEquals(thread, Thread.currentThread())\n            }\n            expect(6)\n        }\n        finish(7)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/ActorLazyTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass ActorLazyTest : TestBase() {\n    @Test\n    fun testEmptyStart() = runBlocking {\n        expect(1)\n        val actor = actor<String>(start = CoroutineStart.LAZY) {\n            expect(5)\n        }\n        actor as Job // type assertion\n        assertFalse(actor.isActive)\n        assertFalse(actor.isCompleted)\n        assertFalse(actor.isClosedForSend)\n        expect(2)\n        yield() // to actor code --> nothing happens (not started!)\n        assertFalse(actor.isActive)\n        assertFalse(actor.isCompleted)\n        assertFalse(actor.isClosedForSend)\n        expect(3)\n        // start actor explicitly\n        actor.start()\n        expect(4)\n        yield() // to started actor\n        assertFalse(actor.isActive)\n        assertTrue(actor.isCompleted)\n        assertTrue(actor.isClosedForSend)\n        finish(6)\n    }\n\n    @Test\n    fun testOne() = runBlocking {\n        expect(1)\n        val actor = actor<String>(start = CoroutineStart.LAZY) {\n            expect(4)\n            assertEquals(\"OK\", receive())\n            expect(5)\n        }\n        actor as Job // type assertion\n        assertFalse(actor.isActive)\n        assertFalse(actor.isCompleted)\n        assertFalse(actor.isClosedForSend)\n        expect(2)\n        yield() // to actor code --> nothing happens (not started!)\n        assertFalse(actor.isActive)\n        assertFalse(actor.isCompleted)\n        assertFalse(actor.isClosedForSend)\n        expect(3)\n        // send message to actor --> should start it\n        actor.send(\"OK\")\n        assertFalse(actor.isActive)\n        assertTrue(actor.isCompleted)\n        assertTrue(actor.isClosedForSend)\n        finish(6)\n    }\n\n    @Test\n    fun testCloseFreshActor() = runTest {\n        val job = launch {\n            expect(2)\n            val actor = actor<Int>(start = CoroutineStart.LAZY) {\n                expect(3)\n                for (i in channel) { }\n                expect(4)\n            }\n\n            actor.close()\n        }\n\n        expect(1)\n        job.join()\n        finish(5)\n    }\n\n    @Test\n    fun testCancelledParent() = runTest({ it is CancellationException }) {\n        cancel()\n        expect(1)\n        actor<Int>(start = CoroutineStart.LAZY) {\n            expectUnreached()\n        }\n        finish(2)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/ActorTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport java.io.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass ActorTest(private val capacity: Int) : TestBase() {\n\n    companion object {\n        @Parameterized.Parameters(name = \"Capacity: {0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = listOf(0, 1, Channel.UNLIMITED, Channel.CONFLATED).map { arrayOf<Any>(it) }\n    }\n\n    @Test\n    fun testEmpty() = runBlocking {\n        expect(1)\n        val actor = actor<String>(capacity = capacity) {\n            expect(3)\n        }\n        actor as Job // type assertion\n        assertTrue(actor.isActive)\n        assertFalse(actor.isCompleted)\n        assertFalse(actor.isClosedForSend)\n        expect(2)\n        yield() // to actor code\n        assertFalse(actor.isActive)\n        assertTrue(actor.isCompleted)\n        assertTrue(actor.isClosedForSend)\n        finish(4)\n    }\n\n    @Test\n    fun testOne() = runBlocking {\n        expect(1)\n        val actor = actor<String>(capacity = capacity) {\n            expect(3)\n            assertEquals(\"OK\", receive())\n            expect(6)\n        }\n        actor as Job // type assertion\n        assertTrue(actor.isActive)\n        assertFalse(actor.isCompleted)\n        assertFalse(actor.isClosedForSend)\n        expect(2)\n        yield() // to actor code\n        assertTrue(actor.isActive)\n        assertFalse(actor.isCompleted)\n        assertFalse(actor.isClosedForSend)\n        expect(4)\n        // send message to actor\n        actor.send(\"OK\")\n        expect(5)\n        yield() // to actor code\n        assertFalse(actor.isActive)\n        assertTrue(actor.isCompleted)\n        assertTrue(actor.isClosedForSend)\n        finish(7)\n    }\n\n    @Test\n    fun testCloseWithoutCause() = runTest {\n        val actor = actor<Int>(capacity = capacity) {\n            val element = channel.receive()\n            expect(2)\n            assertEquals(42, element)\n            val next = channel.receiveCatching()\n            assertNull(next.exceptionOrNull())\n            expect(3)\n        }\n\n        expect(1)\n        actor.send(42)\n        yield()\n        actor.close()\n        yield()\n        finish(4)\n    }\n\n    @Test\n    fun testCloseWithCause() = runTest {\n        val actor = actor<Int>(capacity = capacity) {\n            val element = channel.receive()\n            expect(2)\n            require(element == 42)\n            try {\n                channel.receive()\n            } catch (e: IOException) {\n                expect(3)\n            }\n        }\n\n        expect(1)\n        actor.send(42)\n        yield()\n        actor.close(IOException())\n        yield()\n        finish(4)\n    }\n\n    @Test\n    fun testCancelEnclosingJob() = runTest {\n        val job = async {\n            actor<Int>(capacity = capacity) {\n                expect(1)\n                channel.receive()\n                expectUnreached()\n            }\n        }\n\n        yield()\n        yield()\n\n        expect(2)\n        yield()\n        job.cancel()\n\n        try {\n            job.await()\n            expectUnreached()\n        } catch (e: CancellationException) {\n            assertTrue(e.message?.contains(\"DeferredCoroutine was cancelled\") ?: false)\n        }\n\n        finish(3)\n    }\n\n    @Test\n    fun testThrowingActor() = runTest(unhandled = listOf({e -> e is IllegalArgumentException})) {\n        val parent = Job()\n        val actor = actor<Int>(parent) {\n            channel.consumeEach {\n                expect(1)\n                throw IllegalArgumentException()\n            }\n        }\n\n        actor.send(1)\n        parent.cancel()\n        parent.join()\n        finish(2)\n    }\n\n    @Test\n    fun testChildJob() = runTest {\n        val parent = Job()\n        actor<Int>(parent) {\n            launch {\n                try {\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    expect(1)\n                }\n            }\n        }\n\n        yield()\n        yield()\n        parent.cancel()\n        parent.join()\n        finish(2)\n    }\n\n    @Test\n    fun testCloseFreshActor() = runTest {\n        for (start in CoroutineStart.values()) {\n            val job = launch {\n                val actor = actor<Int>(start = start) {\n                    for (i in channel) {\n                    }\n                }\n                actor.close()\n            }\n\n            job.join()\n        }\n    }\n\n    @Test\n    fun testCancelledParent() = runTest({ it is CancellationException }) {\n        cancel()\n        expect(1)\n        actor<Int> {\n            expectUnreached()\n        }\n        finish(2)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/BroadcastChannelLeakTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass BroadcastChannelLeakTest : TestBase() {\n    @Test\n    fun testBufferedBroadcastChannelSubscriptionLeak() {\n        checkLeak { BroadcastChannelImpl(1) }\n    }\n\n    @Test\n    fun testConflatedBroadcastChannelSubscriptionLeak() {\n        checkLeak { ConflatedBroadcastChannel() }\n    }\n\n    enum class TestKind { BROADCAST_CLOSE, SUB_CANCEL, BOTH }\n\n    private fun checkLeak(factory: () -> BroadcastChannel<String>) = runTest {\n        for (kind in TestKind.values()) {\n            val broadcast = factory()\n            val sub = broadcast.openSubscription()\n            broadcast.send(\"OK\")\n            assertEquals(\"OK\", sub.receive())\n            // now close broadcast\n            if (kind != TestKind.SUB_CANCEL) broadcast.close()\n            // and then cancel subscription\n            if (kind != TestKind.BROADCAST_CLOSE) sub.cancel()\n            // subscription should not be reachable from the channel anymore\n            FieldWalker.assertReachableCount(0, broadcast) { it === sub }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/BroadcastChannelMultiReceiveStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.*\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport java.util.concurrent.atomic.*\n\n/**\n * Tests delivery of events to multiple broadcast channel subscribers.\n */\n@RunWith(Parameterized::class)\nclass BroadcastChannelMultiReceiveStressTest(\n    private val kind: TestBroadcastChannelKind\n) : TestBase() {\n\n    // Stressed by lincheck\n    companion object {\n        @Parameterized.Parameters(name = \"{0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> =\n            TestBroadcastChannelKind.entries.map { arrayOf<Any>(it) }\n    }\n\n    private val nReceivers = if (isStressTest) 10 else 5\n    private val nSeconds = 3 * stressTestMultiplierSqrt\n\n    private val broadcast = kind.create<Long>()\n    private val pool = newFixedThreadPoolContext(nReceivers + 1, \"BroadcastChannelMultiReceiveStressTest\")\n\n    private val sentTotal = AtomicLong()\n    private val receivedTotal = AtomicLong()\n    private val stopOnReceive = AtomicLong(-1)\n    private val lastReceived = Array(nReceivers) { AtomicLong(-1) }\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    @Test\n    fun testStress() = runBlocking {\n        println(\"--- BroadcastChannelMultiReceiveStressTest $kind with nReceivers=$nReceivers\")\n        val sender =\n            launch(pool + CoroutineName(\"Sender\")) {\n                var i = 0L\n                while (isActive) {\n                    i++\n                    broadcast.send(i) // could be cancelled\n                    sentTotal.set(i) // only was for it if it was not cancelled\n                }\n            }\n        val receivers = mutableListOf<Job>()\n        fun printProgress() {\n            println(\"Sent ${sentTotal.get()}, received ${receivedTotal.get()}, receivers=${receivers.size}\")\n        }\n        // ramp up receivers\n        repeat(nReceivers) {\n            delay(100) // wait 0.1 sec\n            val receiverIndex = receivers.size\n            val name = \"Receiver$receiverIndex\"\n            println(\"Launching $name\")\n            receivers += launch(pool + CoroutineName(name)) {\n                val channel = broadcast.openSubscription()\n                when (receiverIndex % 5) {\n                    0 -> doReceive(channel, receiverIndex)\n                    1 -> doReceiveCatching(channel, receiverIndex)\n                    2 -> doIterator(channel, receiverIndex)\n                    3 -> doReceiveSelect(channel, receiverIndex)\n                    4 -> doReceiveCatchingSelect(channel, receiverIndex)\n                }\n                channel.cancel()\n            }\n            printProgress()\n        }\n        // wait\n        repeat(nSeconds) { _ ->\n            delay(1000)\n            printProgress()\n        }\n        sender.cancelAndJoin()\n        println(\"Tested $kind with nReceivers=$nReceivers\")\n        val total = sentTotal.get()\n        println(\"      Sent $total events, waiting for receivers\")\n        stopOnReceive.set(total)\n        try {\n            withTimeout(5000) {\n                receivers.forEachIndexed { index, receiver ->\n                    if (lastReceived[index].get() >= total) receiver.cancel()\n                    receiver.join()\n                }\n            }\n        } catch (e: Exception) {\n            println(\"Failed: $e\")\n            pool.dumpThreads(\"Threads in pool\")\n            receivers.indices.forEach { index ->\n                println(\"lastReceived[$index] = ${lastReceived[index].get()}\")\n            }\n            throw e\n        }\n        println(\"  Received ${receivedTotal.get()} events\")\n    }\n\n    private fun doReceived(receiverIndex: Int, i: Long): Boolean {\n        val last = lastReceived[receiverIndex].get()\n        check(i > last) { \"Last was $last, got $i\" }\n        if (last != -1L && !kind.isConflated)\n            check(i == last + 1) { \"Last was $last, got $i\" }\n        receivedTotal.incrementAndGet()\n        lastReceived[receiverIndex].set(i)\n        return i >= stopOnReceive.get()\n    }\n\n    private suspend fun doReceive(channel: ReceiveChannel<Long>, receiverIndex: Int) {\n        while (true) {\n            try {\n                val stop = doReceived(receiverIndex, channel.receive())\n                if (stop) break\n            } catch (ex: ClosedReceiveChannelException) {\n                break\n            }\n        }\n    }\n\n    private suspend fun doReceiveCatching(channel: ReceiveChannel<Long>, receiverIndex: Int) {\n        while (true) {\n            val stop = doReceived(receiverIndex, channel.receiveCatching().getOrNull() ?: break)\n            if (stop) break\n        }\n    }\n\n    private suspend fun doIterator(channel: ReceiveChannel<Long>, receiverIndex: Int) {\n        for (event in channel) {\n            val stop = doReceived(receiverIndex, event)\n            if (stop) break\n        }\n    }\n\n    private suspend fun doReceiveSelect(channel: ReceiveChannel<Long>, receiverIndex: Int) {\n        while (true) {\n            try {\n                val event = select<Long> { channel.onReceive { it } }\n                val stop = doReceived(receiverIndex, event)\n                if (stop) break\n            } catch (ex: ClosedReceiveChannelException) {\n                break\n            }\n        }\n    }\n\n    private suspend fun doReceiveCatchingSelect(channel: ReceiveChannel<Long>, receiverIndex: Int) {\n        while (true) {\n            val event = select<Long?> { channel.onReceiveCatching { it.getOrNull() } } ?: break\n            val stop = doReceived(receiverIndex, event)\n            if (stop) break\n        }\n    }\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun println(debugMessage: String) {\n        // Uncomment for local debugging\n        //println(debugMessage as Any?)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/BufferedChannelStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.runner.*\nimport org.junit.runners.*\n\n@RunWith(Parameterized::class)\nclass BufferedChannelStressTest(private val capacity: Int) : TestBase() {\n\n    companion object {\n        @Parameterized.Parameters(name = \"{0}, nSenders={1}, nReceivers={2}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = listOf(1, 10, 100, 100_000, 1_000_000).map { arrayOf<Any>(it) }\n    }\n\n    @Test\n    fun testStress() = runTest {\n        val n = 100_000 * stressTestMultiplier\n        val q = Channel<Int>(capacity)\n        val sender = launch {\n            for (i in 1..n) {\n                q.send(i)\n            }\n            expect(2)\n        }\n        val receiver = launch {\n            for (i in 1..n) {\n                val next = q.receive()\n                check(next == i)\n            }\n            expect(3)\n        }\n        expect(1)\n        sender.join()\n        receiver.join()\n        finish(4)\n    }\n\n    @Test\n    fun testBurst() = runTest {\n        Assume.assumeTrue(capacity < 100_000)\n        repeat(10_000 * stressTestMultiplier) {\n            val channel = Channel<Int>(capacity)\n            val sender = launch(Dispatchers.Default) {\n                for (i in 1..capacity * 2) {\n                    channel.send(i)\n                }\n            }\n            val receiver = launch(Dispatchers.Default) {\n                for (i in 1..capacity * 2) {\n                    val next = channel.receive()\n                    check(next == i)\n                }\n            }\n            sender.join()\n            receiver.join()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/ChannelMemoryLeakStressTest.kt",
        "content": "package channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.Test\n\nclass ChannelMemoryLeakStressTest : TestBase()  {\n    private val nRepeat = 1_000_000 * stressTestMultiplier\n\n    @Test\n    fun test() = runTest {\n        val c = Channel<Any>(1)\n        repeat(nRepeat) {\n            c.send(bigValue())\n            c.receive()\n        }\n    }\n\n    // capture big value for fast OOM in case of a bug\n    private fun bigValue(): ByteArray = ByteArray(4096)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/ChannelSelectStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.After\nimport org.junit.Test\nimport java.util.concurrent.atomic.AtomicLongArray\nimport kotlin.test.*\n\nclass ChannelSelectStressTest : TestBase() {\n    private val pairedCoroutines = 3\n    private val dispatcher = newFixedThreadPoolContext(pairedCoroutines * 2, \"ChannelSelectStressTest\")\n    private val elementsToSend = 20_000 * Long.SIZE_BITS * stressTestMultiplier\n    private val sent = atomic(0)\n    private val received = atomic(0)\n    private val receivedArray = AtomicLongArray(elementsToSend / Long.SIZE_BITS)\n    private val channel = Channel<Int>()\n\n    @After\n    fun tearDown() {\n        dispatcher.close()\n    }\n\n    @Test\n    fun testAtomicCancelStress() = runTest {\n        withContext(dispatcher) {\n            repeat(pairedCoroutines) { launchSender() }\n            repeat(pairedCoroutines) { launchReceiver() }\n        }\n        val missing = ArrayList<Int>()\n        for (i in 0 until receivedArray.length()) {\n            val bits = receivedArray[i]\n            if (bits != 0L.inv()) {\n                for (j in 0 until Long.SIZE_BITS) {\n                    val mask = 1L shl j\n                    if (bits and mask == 0L) missing += i * Long.SIZE_BITS + j\n                }\n            }\n        }\n        if (missing.isNotEmpty()) {\n            fail(\"Missed ${missing.size} out of $elementsToSend: $missing\")\n        }\n    }\n\n    private fun CoroutineScope.launchSender() {\n        launch {\n            while (sent.value < elementsToSend) {\n                val element = sent.getAndIncrement()\n                if (element >= elementsToSend) break\n                select<Unit> { channel.onSend(element) {} }\n            }\n            channel.close(CancellationException())\n        }\n    }\n\n    private fun CoroutineScope.launchReceiver() {\n        launch {\n            while (received.value != elementsToSend) {\n                val element = select<Int> { channel.onReceive { it } }\n                received.incrementAndGet()\n                val index = (element / Long.SIZE_BITS)\n                val mask = 1L shl (element % Long.SIZE_BITS.toLong()).toInt()\n                while (true) {\n                    val bits = receivedArray.get(index)\n                    if (bits and mask != 0L) {\n                        error(\"Detected duplicate\")\n                    }\n                    if (receivedArray.compareAndSet(index, bits, bits or mask)) break\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/ChannelSendReceiveStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.*\nimport org.junit.Ignore\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\n@Ignore\n@RunWith(Parameterized::class)\nclass ChannelSendReceiveStressTest(\n    private val kind: TestChannelKind,\n    private val nSenders: Int,\n    private val nReceivers: Int\n) : TestBase() {\n    companion object {\n        @Parameterized.Parameters(name = \"{0}, nSenders={1}, nReceivers={2}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> =\n                listOf(1, 2, 10).flatMap { nSenders ->\n                    listOf(1, 10).flatMap { nReceivers ->\n                        TestChannelKind.values().map { arrayOf(it, nSenders, nReceivers) }\n                    }\n                }\n    }\n\n    private val timeLimit = 30_000L * stressTestMultiplier // 30 sec\n    private val nEvents = 200_000 * stressTestMultiplier\n\n    private val maxBuffer = 10_000 // artificial limit for unlimited channel\n\n    val channel = kind.create<Int>()\n    private val sendersCompleted = AtomicInteger()\n    private val receiversCompleted = AtomicInteger()\n    private val dupes = AtomicInteger()\n    private val sentTotal = AtomicInteger()\n    val received = AtomicIntegerArray(nEvents)\n    private val receivedTotal = AtomicInteger()\n    private val receivedBy = IntArray(nReceivers)\n\n    private val pool =\n        newFixedThreadPoolContext(nSenders + nReceivers, \"ChannelSendReceiveStressTest\")\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    @Test\n    fun testSendReceiveStress() = runBlocking {\n        println(\"--- ChannelSendReceiveStressTest $kind with nSenders=$nSenders, nReceivers=$nReceivers\")\n        val receivers = List(nReceivers) { receiverIndex ->\n            // different event receivers use different code\n            launch(pool + CoroutineName(\"receiver$receiverIndex\")) {\n                when (receiverIndex % 5) {\n                    0 -> doReceive(receiverIndex)\n                    1 -> doReceiveCatching(receiverIndex)\n                    2 -> doIterator(receiverIndex)\n                    3 -> doReceiveSelect(receiverIndex)\n                    4 -> doReceiveCatchingSelect(receiverIndex)\n                }\n                receiversCompleted.incrementAndGet()\n            }\n        }\n        val senders = List(nSenders) { senderIndex ->\n            launch(pool + CoroutineName(\"sender$senderIndex\")) {\n                when (senderIndex % 2) {\n                    0 -> doSend(senderIndex)\n                    1 -> doSendSelect(senderIndex)\n                }\n                sendersCompleted.incrementAndGet()\n            }\n        }\n        // print progress\n        val progressJob = launch {\n            var seconds = 0\n            while (true) {\n                delay(1000)\n                println(\"${++seconds}: Sent ${sentTotal.get()}, received ${receivedTotal.get()}\")\n            }\n        }\n        try {\n            withTimeout(timeLimit) {\n                senders.forEach { it.join() }\n                channel.close()\n                receivers.forEach { it.join() }\n            }\n        } catch (e: CancellationException) {\n            println(\"!!! Test timed out $e\")\n        }\n        progressJob.cancel()\n        println(\"Tested $kind with nSenders=$nSenders, nReceivers=$nReceivers\")\n        println(\"Completed successfully ${sendersCompleted.get()} sender coroutines\")\n        println(\"Completed successfully ${receiversCompleted.get()} receiver coroutines\")\n        println(\"                  Sent ${sentTotal.get()} events\")\n        println(\"              Received ${receivedTotal.get()} events\")\n        println(\"        Received dupes ${dupes.get()}\")\n        repeat(nReceivers) { receiveIndex ->\n            println(\"        Received by #$receiveIndex ${receivedBy[receiveIndex]}\")\n        }\n        (channel as? BufferedChannel<*>)?.checkSegmentStructureInvariants()\n        assertEquals(nSenders, sendersCompleted.get())\n        assertEquals(nReceivers, receiversCompleted.get())\n        assertEquals(0, dupes.get())\n        assertEquals(nEvents, sentTotal.get())\n        if (!kind.isConflated) assertEquals(nEvents, receivedTotal.get())\n        repeat(nReceivers) { receiveIndex ->\n            assertTrue(receivedBy[receiveIndex] > 0, \"Each receiver should have received something\")\n        }\n    }\n\n    private suspend fun doSent() {\n        sentTotal.incrementAndGet()\n        if (!kind.isConflated) {\n            while (sentTotal.get() > receivedTotal.get() + maxBuffer)\n                yield() // throttle fast senders to prevent OOM with an unlimited channel\n        }\n    }\n\n    private suspend fun doSend(senderIndex: Int) {\n        for (i in senderIndex until nEvents step nSenders) {\n            channel.send(i)\n            doSent()\n        }\n    }\n\n    private suspend fun doSendSelect(senderIndex: Int) {\n        for (i in senderIndex until nEvents step nSenders) {\n            select<Unit> { channel.onSend(i) { Unit } }\n            doSent()\n        }\n    }\n\n    private fun doReceived(receiverIndex: Int, event: Int) {\n        if (!received.compareAndSet(event, 0, 1)) {\n            println(\"Duplicate event $event at $receiverIndex\")\n            dupes.incrementAndGet()\n        }\n        receivedTotal.incrementAndGet()\n        receivedBy[receiverIndex]++\n    }\n\n    private suspend fun doReceive(receiverIndex: Int) {\n        while (true) {\n            try { doReceived(receiverIndex, channel.receive()) }\n            catch (ex: ClosedReceiveChannelException) { break }\n        }\n    }\n\n    private suspend fun doReceiveCatching(receiverIndex: Int) {\n        while (true) {\n            doReceived(receiverIndex, channel.receiveCatching().getOrNull() ?: break)\n        }\n    }\n\n    private suspend fun doIterator(receiverIndex: Int) {\n        for (event in channel) {\n            doReceived(receiverIndex, event)\n        }\n    }\n\n    private suspend fun doReceiveSelect(receiverIndex: Int) {\n        while (true) {\n            try {\n                val event = select<Int> { channel.onReceive { it } }\n                doReceived(receiverIndex, event)\n            } catch (ex: ClosedReceiveChannelException) { break }\n        }\n    }\n\n    private suspend fun doReceiveCatchingSelect(receiverIndex: Int) {\n        while (true) {\n            val event = select<Int?> { channel.onReceiveCatching { it.getOrNull() } } ?: break\n            doReceived(receiverIndex, event)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/ChannelUndeliveredElementSelectOldStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.After\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.random.Random\nimport kotlin.test.*\n\n/**\n * Tests resource transfer via channel send & receive operations, including their select versions,\n * using `onUndeliveredElement` to detect lost resources and close them properly.\n */\n@RunWith(Parameterized::class)\nclass ChannelUndeliveredElementSelectOldStressTest(private val kind: TestChannelKind) : TestBase() {\n    companion object {\n        @Parameterized.Parameters(name = \"{0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> =\n            TestChannelKind.values()\n                .filter { !it.viaBroadcast }\n                .map { arrayOf<Any>(it) }\n    }\n\n    private val iterationDurationMs = 100L\n    private val testIterations = 20 * stressTestMultiplier // 2 sec\n\n    private val dispatcher = newFixedThreadPoolContext(2, \"ChannelAtomicCancelStressTest\")\n    private val scope = CoroutineScope(dispatcher)\n\n    private val channel = kind.create<Data> { it.failedToDeliver() }\n    private val senderDone = Channel<Boolean>(1)\n    private val receiverDone = Channel<Boolean>(1)\n\n    @Volatile\n    private var lastReceived = -1L\n\n    private var stoppedSender = 0L\n    private var stoppedReceiver = 0L\n\n    private var sentCnt = 0L // total number of send attempts\n    private var receivedCnt = 0L // actually received successfully\n    private var dupCnt = 0L // duplicates (should never happen)\n    private val failedToDeliverCnt = atomic(0L) // out of sent\n\n    private val modulo = 1 shl 25\n    private val mask = (modulo - 1).toLong()\n    private val sentStatus = ItemStatus() // 1 - send norm, 2 - send select, +2 - did not throw exception\n    private val receivedStatus = ItemStatus() // 1-6 received\n    private val failedStatus = ItemStatus() // 1 - failed\n\n    lateinit var sender: Job\n    lateinit var receiver: Job\n\n    @After\n    fun tearDown() {\n        dispatcher.close()\n    }\n\n    private inline fun cancellable(done: Channel<Boolean>, block: () -> Unit) {\n        try {\n            block()\n        } finally {\n            if (!done.trySend(true).isSuccess)\n                error(IllegalStateException(\"failed to offer to done channel\"))\n        }\n    }\n\n    @Test\n    fun testAtomicCancelStress() = runBlocking {\n        println(\"=== ChannelAtomicCancelStressTest $kind\")\n        var nextIterationTime = System.currentTimeMillis() + iterationDurationMs\n        var iteration = 0\n        launchSender()\n        launchReceiver()\n        while (!hasError()) {\n            if (System.currentTimeMillis() >= nextIterationTime) {\n                nextIterationTime += iterationDurationMs\n                iteration++\n                verify(iteration)\n                if (iteration % 10 == 0) printProgressSummary(iteration)\n                if (iteration >= testIterations) break\n                launchSender()\n                launchReceiver()\n            }\n            when (Random.nextInt(3)) {\n                0 -> { // cancel & restart sender\n                    stopSender()\n                    launchSender()\n                }\n                1 -> { // cancel & restart receiver\n                    stopReceiver()\n                    launchReceiver()\n                }\n                2 -> yield() // just yield (burn a little time)\n            }\n        }\n    }\n\n    private suspend fun verify(iteration: Int) {\n        stopSender()\n        drainReceiver()\n        stopReceiver()\n        try {\n            assertEquals(0, dupCnt)\n            assertEquals(sentCnt - failedToDeliverCnt.value, receivedCnt)\n        } catch (e: Throwable) {\n            printProgressSummary(iteration)\n            printErrorDetails()\n            throw e\n        }\n        sentStatus.clear()\n        receivedStatus.clear()\n        failedStatus.clear()\n    }\n\n    private fun printProgressSummary(iteration: Int) {\n        println(\"--- ChannelAtomicCancelStressTest $kind -- $iteration of $testIterations\")\n        println(\"              Sent $sentCnt times to channel\")\n        println(\"          Received $receivedCnt times from channel\")\n        println(\" Failed to deliver ${failedToDeliverCnt.value} times\")\n        println(\"    Stopped sender $stoppedSender times\")\n        println(\"  Stopped receiver $stoppedReceiver times\")\n        println(\"        Duplicated $dupCnt deliveries\")\n    }\n\n    private fun printErrorDetails() {\n        val min = minOf(sentStatus.min, receivedStatus.min, failedStatus.min)\n        val max = maxOf(sentStatus.max, receivedStatus.max, failedStatus.max)\n        for (x in min..max) {\n            val sentCnt = if (sentStatus[x] != 0) 1 else 0\n            val receivedCnt = if (receivedStatus[x] != 0) 1 else 0\n            val failedToDeliverCnt = failedStatus[x]\n            if (sentCnt - failedToDeliverCnt != receivedCnt) {\n                println(\"!!! Error for value $x: \" +\n                    \"sentStatus=${sentStatus[x]}, \" +\n                    \"receivedStatus=${receivedStatus[x]}, \" +\n                    \"failedStatus=${failedStatus[x]}\"\n                )\n            }\n        }\n    }\n\n\n    private fun launchSender() {\n        sender = scope.launch(start = CoroutineStart.ATOMIC) {\n            cancellable(senderDone) {\n                var counter = 0\n                while (true) {\n                    val trySendData = Data(sentCnt++)\n                    sentStatus[trySendData.x] = 1\n                    selectOld<Unit> { channel.onSend(trySendData) {} }\n                    sentStatus[trySendData.x] = 3\n                    when {\n                        // must artificially slow down LINKED_LIST sender to avoid overwhelming receiver and going OOM\n                        kind == TestChannelKind.UNLIMITED -> while (sentCnt > lastReceived + 100) yield()\n                        // yield periodically to check cancellation on conflated channels\n                        kind.isConflated -> if (counter++ % 100 == 0) yield()\n                    }\n                }\n            }\n        }\n    }\n\n    private suspend fun stopSender() {\n        stoppedSender++\n        sender.cancelAndJoin()\n        senderDone.receive()\n    }\n\n    private fun launchReceiver() {\n        receiver = scope.launch(start = CoroutineStart.ATOMIC) {\n            cancellable(receiverDone) {\n                while (true) {\n                   selectOld<Unit> {\n                        channel.onReceive { receivedData ->\n                            receivedData.onReceived()\n                            receivedCnt++\n                            val received = receivedData.x\n                            if (received <= lastReceived)\n                                dupCnt++\n                            lastReceived = received\n                            receivedStatus[received] = 1\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private suspend fun drainReceiver() {\n        while (!channel.isEmpty) yield() // burn time until receiver gets it all\n    }\n\n    private suspend fun stopReceiver() {\n        stoppedReceiver++\n        receiver.cancelAndJoin()\n        receiverDone.receive()\n    }\n\n    private inner class Data(val x: Long) {\n        private val firstFailedToDeliverOrReceivedCallTrace = atomic<Exception?>(null)\n\n        fun failedToDeliver() {\n            val trace = if (TRACING_ENABLED) Exception(\"First onUndeliveredElement() call\") else DUMMY_TRACE_EXCEPTION\n            if (firstFailedToDeliverOrReceivedCallTrace.compareAndSet(null, trace)) {\n                failedToDeliverCnt.incrementAndGet()\n                failedStatus[x] = 1\n                return\n            }\n            throw IllegalStateException(\"onUndeliveredElement()/onReceived() notified twice\", firstFailedToDeliverOrReceivedCallTrace.value!!)\n        }\n\n        fun onReceived() {\n            val trace = if (TRACING_ENABLED) Exception(\"First onReceived() call\") else DUMMY_TRACE_EXCEPTION\n            if (firstFailedToDeliverOrReceivedCallTrace.compareAndSet(null, trace)) return\n            throw IllegalStateException(\"onUndeliveredElement()/onReceived() notified twice\", firstFailedToDeliverOrReceivedCallTrace.value!!)\n        }\n    }\n\n    inner class ItemStatus {\n        private val a = ByteArray(modulo)\n        private val _min = atomic(Long.MAX_VALUE)\n        private val _max = atomic(-1L)\n\n        val min: Long get() = _min.value\n        val max: Long get() = _max.value\n\n        operator fun set(x: Long, value: Int) {\n            a[(x and mask).toInt()] = value.toByte()\n            _min.update { y -> minOf(x, y) }\n            _max.update { y -> maxOf(x, y) }\n        }\n\n        operator fun get(x: Long): Int = a[(x and mask).toInt()].toInt()\n\n        fun clear() {\n            if (_max.value < 0) return\n            for (x in _min.value.._max.value) a[(x and mask).toInt()] = 0\n            _min.value = Long.MAX_VALUE\n            _max.value = -1L\n        }\n    }\n}\n\nprivate const val TRACING_ENABLED = false // Change to `true` to enable the tracing\nprivate val DUMMY_TRACE_EXCEPTION = Exception(\"The tracing is disabled; please enable it by changing the `TRACING_ENABLED` constant to `true`.\")\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/ChannelUndeliveredElementStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.After\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.random.Random\nimport kotlin.test.*\n\n/**\n * Tests resource transfer via channel send & receive operations, including their select versions,\n * using `onUndeliveredElement` to detect lost resources and close them properly.\n */\n@RunWith(Parameterized::class)\nclass ChannelUndeliveredElementStressTest(private val kind: TestChannelKind) : TestBase() {\n    companion object {\n        @Parameterized.Parameters(name = \"{0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> =\n            TestChannelKind.values()\n                .filter { !it.viaBroadcast }\n                .map { arrayOf<Any>(it) }\n    }\n\n    private val iterationDurationMs = 100L\n    private val testIterations = 20 * stressTestMultiplier // 2 sec\n\n    private val dispatcher = newFixedThreadPoolContext(2, \"ChannelAtomicCancelStressTest\")\n    private val scope = CoroutineScope(dispatcher)\n\n    private val channel = kind.create<Data> { it.failedToDeliver() }\n    private val senderDone = Channel<Boolean>(1)\n    private val receiverDone = Channel<Boolean>(1)\n\n    @Volatile\n    private var lastReceived = -1L\n\n    private var stoppedSender = 0L\n    private var stoppedReceiver = 0L\n\n    private var sentCnt = 0L // total number of send attempts\n    private var receivedCnt = 0L // actually received successfully\n    private var dupCnt = 0L // duplicates (should never happen)\n    private val failedToDeliverCnt = atomic(0L) // out of sent\n\n    private val modulo = 1 shl 25\n    private val mask = (modulo - 1).toLong()\n    private val sentStatus = ItemStatus() // 1 - send norm, 2 - send select, +2 - did not throw exception\n    private val receivedStatus = ItemStatus() // 1-6 received\n    private val failedStatus = ItemStatus() // 1 - failed\n\n    lateinit var sender: Job\n    lateinit var receiver: Job\n\n    @After\n    fun tearDown() {\n        dispatcher.close()\n    }\n\n    private inline fun cancellable(done: Channel<Boolean>, block: () -> Unit) {\n        try {\n            block()\n        } finally {\n            if (!done.trySend(true).isSuccess)\n                error(IllegalStateException(\"failed to offer to done channel\"))\n        }\n    }\n\n    @Test\n    fun testAtomicCancelStress() = runBlocking {\n        println(\"=== ChannelAtomicCancelStressTest $kind\")\n        var nextIterationTime = System.currentTimeMillis() + iterationDurationMs\n        var iteration = 0\n        launchSender()\n        launchReceiver()\n        while (!hasError()) {\n            if (System.currentTimeMillis() >= nextIterationTime) {\n                nextIterationTime += iterationDurationMs\n                iteration++\n                verify(iteration)\n                if (iteration % 10 == 0) printProgressSummary(iteration)\n                if (iteration >= testIterations) break\n                launchSender()\n                launchReceiver()\n            }\n            when (Random.nextInt(3)) {\n                0 -> { // cancel & restart sender\n                    stopSender()\n                    launchSender()\n                }\n                1 -> { // cancel & restart receiver\n                    stopReceiver()\n                    launchReceiver()\n                }\n                2 -> yield() // just yield (burn a little time)\n            }\n        }\n    }\n\n    private suspend fun verify(iteration: Int) {\n        stopSender()\n        drainReceiver()\n        stopReceiver()\n        try {\n            assertEquals(0, dupCnt)\n            assertEquals(sentCnt - failedToDeliverCnt.value, receivedCnt)\n        } catch (e: Throwable) {\n            printProgressSummary(iteration)\n            printErrorDetails()\n            throw e\n        }\n        (channel as? BufferedChannel<*>)?.checkSegmentStructureInvariants()\n        sentStatus.clear()\n        receivedStatus.clear()\n        failedStatus.clear()\n    }\n\n    private fun printProgressSummary(iteration: Int) {\n        println(\"--- ChannelAtomicCancelStressTest $kind -- $iteration of $testIterations\")\n        println(\"              Sent $sentCnt times to channel\")\n        println(\"          Received $receivedCnt times from channel\")\n        println(\" Failed to deliver ${failedToDeliverCnt.value} times\")\n        println(\"    Stopped sender $stoppedSender times\")\n        println(\"  Stopped receiver $stoppedReceiver times\")\n        println(\"        Duplicated $dupCnt deliveries\")\n    }\n\n    private fun printErrorDetails() {\n        val min = minOf(sentStatus.min, receivedStatus.min, failedStatus.min)\n        val max = maxOf(sentStatus.max, receivedStatus.max, failedStatus.max)\n        for (x in min..max) {\n            val sentCnt = if (sentStatus[x] != 0) 1 else 0\n            val receivedCnt = if (receivedStatus[x] != 0) 1 else 0\n            val failedToDeliverCnt = failedStatus[x]\n            if (sentCnt - failedToDeliverCnt != receivedCnt) {\n                println(\"!!! Error for value $x: \" +\n                    \"sentStatus=${sentStatus[x]}, \" +\n                    \"receivedStatus=${receivedStatus[x]}, \" +\n                    \"failedStatus=${failedStatus[x]}\"\n                )\n            }\n        }\n    }\n\n\n    private fun launchSender() {\n        sender = scope.launch(start = CoroutineStart.ATOMIC) {\n            cancellable(senderDone) {\n                var counter = 0\n                while (true) {\n                    val trySendData = Data(sentCnt++)\n                    val sendMode = Random.nextInt(2) + 1\n                    sentStatus[trySendData.x] = sendMode\n                    when (sendMode) {\n                        1 -> channel.send(trySendData)\n                        2 -> select<Unit> { channel.onSend(trySendData) {} }\n                        else -> error(\"cannot happen\")\n                    }\n                    sentStatus[trySendData.x] = sendMode + 2\n                    when {\n                        // must artificially slow down LINKED_LIST sender to avoid overwhelming receiver and going OOM\n                        kind == TestChannelKind.UNLIMITED -> while (sentCnt > lastReceived + 100) yield()\n                        // yield periodically to check cancellation on conflated channels\n                        kind.isConflated -> if (counter++ % 100 == 0) yield()\n                    }\n                }\n            }\n        }\n    }\n\n    private suspend fun stopSender() {\n        stoppedSender++\n        sender.cancelAndJoin()\n        senderDone.receive()\n    }\n\n    private fun launchReceiver() {\n        receiver = scope.launch(start = CoroutineStart.ATOMIC) {\n            cancellable(receiverDone) {\n                while (true) {\n                    val receiveMode = Random.nextInt(6) + 1\n                    val receivedData = when (receiveMode) {\n                        1 -> channel.receive()\n                        2 -> select { channel.onReceive { it } }\n                        3 -> channel.receiveCatching().getOrElse { error(\"Should not be closed\") }\n                        4 -> select { channel.onReceiveCatching { it.getOrElse { error(\"Should not be closed\") } } }\n                        5 -> channel.receiveCatching().getOrThrow()\n                        6 -> {\n                            val iterator = channel.iterator()\n                            check(iterator.hasNext()) { \"Should not be closed\" }\n                            iterator.next()\n                        }\n                        else -> error(\"cannot happen\")\n                    }\n                    receivedData.onReceived()\n                    receivedCnt++\n                    val received = receivedData.x\n                    if (received <= lastReceived)\n                        dupCnt++\n                    lastReceived = received\n                    receivedStatus[received] = receiveMode\n                }\n            }\n        }\n    }\n\n    private suspend fun drainReceiver() {\n        while (!channel.isEmpty) yield() // burn time until receiver gets it all\n    }\n\n    private suspend fun stopReceiver() {\n        stoppedReceiver++\n        receiver.cancel()\n        receiverDone.receive()\n    }\n\n    private inner class Data(val x: Long) {\n        private val firstFailedToDeliverOrReceivedCallTrace = atomic<Exception?>(null)\n\n        fun failedToDeliver() {\n            val trace = if (TRACING_ENABLED) Exception(\"First onUndeliveredElement() call\") else DUMMY_TRACE_EXCEPTION\n            if (firstFailedToDeliverOrReceivedCallTrace.compareAndSet(null, trace)) {\n                failedToDeliverCnt.incrementAndGet()\n                failedStatus[x] = 1\n                return\n            }\n            throw IllegalStateException(\"onUndeliveredElement()/onReceived() notified twice\", firstFailedToDeliverOrReceivedCallTrace.value!!)\n        }\n\n        fun onReceived() {\n            val trace = if (TRACING_ENABLED) Exception(\"First onReceived() call\") else DUMMY_TRACE_EXCEPTION\n            if (firstFailedToDeliverOrReceivedCallTrace.compareAndSet(null, trace)) return\n            throw IllegalStateException(\"onUndeliveredElement()/onReceived() notified twice\", firstFailedToDeliverOrReceivedCallTrace.value!!)\n        }\n    }\n\n    inner class ItemStatus {\n        private val a = ByteArray(modulo)\n        private val _min = atomic(Long.MAX_VALUE)\n        private val _max = atomic(-1L)\n\n        val min: Long get() = _min.value\n        val max: Long get() = _max.value\n\n        operator fun set(x: Long, value: Int) {\n            a[(x and mask).toInt()] = value.toByte()\n            _min.update { y -> minOf(x, y) }\n            _max.update { y -> maxOf(x, y) }\n        }\n\n        operator fun get(x: Long): Int = a[(x and mask).toInt()].toInt()\n\n        fun clear() {\n            if (_max.value < 0) return\n            for (x in _min.value.._max.value) a[(x and mask).toInt()] = 0\n            _min.value = Long.MAX_VALUE\n            _max.value = -1L\n        }\n    }\n}\n\nprivate const val TRACING_ENABLED = false // Change to `true` to enable the tracing\nprivate val DUMMY_TRACE_EXCEPTION = Exception(\"The tracing is disabled; please enable it by changing the `TRACING_ENABLED` constant to `true`.\")\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/ConflatedChannelCloseStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.concurrent.atomic.*\n\nclass ConflatedChannelCloseStressTest : TestBase() {\n\n    private val nSenders = 2\n    private val testSeconds = 3 * stressTestMultiplier\n\n    private val curChannel = AtomicReference<Channel<Int>>(Channel(Channel.CONFLATED))\n    private val sent = AtomicInteger()\n    private val closed = AtomicInteger()\n    val received = AtomicInteger()\n\n    val pool = newFixedThreadPoolContext(nSenders + 2, \"TestStressClose\")\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    @Test\n    fun testStressClose() = runBlocking {\n        println(\"--- ConflatedChannelCloseStressTest with nSenders=$nSenders\")\n        val senderJobs = List(nSenders) { Job() }\n        val senders = List(nSenders) { senderId ->\n            launch(pool) {\n                var x = senderId\n                try {\n                    while (isActive) {\n                        curChannel.get().trySend(x).onSuccess {\n                            x += nSenders\n                            sent.incrementAndGet()\n                        }\n                    }\n                } finally {\n                    senderJobs[senderId].cancel()\n                }\n            }\n        }\n        val closerJob = Job()\n        val closer = launch(pool) {\n            try {\n                while (isActive) {\n                    flipChannel()\n                    closed.incrementAndGet()\n                    yield()\n                }\n            } finally {\n                closerJob.cancel()\n            }\n        }\n        val receiver = async(pool + NonCancellable) {\n            while (isActive) {\n                curChannel.get().receiveCatching().getOrElse {\n                    it?.let { throw it }\n                }\n                received.incrementAndGet()\n            }\n        }\n        // print stats while running\n        repeat(testSeconds) {\n            delay(1000)\n            printStats()\n        }\n        println(\"Stopping\")\n        senders.forEach { it.cancel() }\n        closer.cancel()\n        // wait them to complete\n        println(\"waiting for senders...\")\n        senderJobs.forEach { it.join() }\n        println(\"waiting for closer...\")\n        closerJob.join()\n        // close cur channel\n        println(\"Closing channel and signalling receiver...\")\n        flipChannel()\n        curChannel.get().close(StopException())\n        /// wait for receiver do complete\n        println(\"Waiting for receiver...\")\n        try {\n            receiver.await()\n            error(\"Receiver should not complete normally\")\n        } catch (e: StopException) {\n            // ok\n        }\n        // print stats\n        println(\"--- done\")\n        printStats()\n    }\n\n    private fun flipChannel() {\n        val oldChannel = curChannel.get()\n        val newChannel = Channel<Int>(Channel.CONFLATED)\n        curChannel.set(newChannel)\n        check(oldChannel.close())\n    }\n\n    private fun printStats() {\n        println(\"sent ${sent.get()}, closed ${closed.get()}, received ${received.get()}\")\n    }\n\n    class StopException : Exception()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/DoubleChannelCloseStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\n\nclass DoubleChannelCloseStressTest : TestBase() {\n    private val nTimes = 1000 * stressTestMultiplier\n\n    @Test\n    fun testDoubleCloseStress() {\n        repeat(nTimes) {\n            val actor = GlobalScope.actor<Int>(CoroutineName(\"actor\"), start = CoroutineStart.LAZY) {\n                // empty -- just closes channel\n            }\n            GlobalScope.launch(CoroutineName(\"sender\")) {\n                try {\n                    actor.send(1)\n                } catch (e: ClosedSendChannelException) {\n                    // ok -- closed before send\n                }\n            }\n            Thread.sleep(1)\n            actor.close()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/InvokeOnCloseStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass InvokeOnCloseStressTest : TestBase(), CoroutineScope {\n\n    private val iterations = 1000 * stressTestMultiplier\n\n    private val pool = newFixedThreadPoolContext(3, \"InvokeOnCloseStressTest\")\n    override val coroutineContext: CoroutineContext\n        get() = pool\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    @Test\n    fun testInvokedExactlyOnce() = runBlocking {\n        runStressTest(TestChannelKind.BUFFERED_1)\n    }\n\n    @Test\n    fun testInvokedExactlyOnceBroadcast() = runBlocking {\n        runStressTest(TestChannelKind.CONFLATED_BROADCAST)\n    }\n\n    private suspend fun runStressTest(kind: TestChannelKind) {\n        repeat(iterations) {\n            val counter = AtomicInteger(0)\n            val channel = kind.create<Int>()\n\n            val latch = CountDownLatch(1)\n            val j1 = async {\n                latch.await()\n                channel.close()\n            }\n\n            val j2 = async {\n                latch.await()\n                channel.invokeOnClose { counter.incrementAndGet() }\n            }\n\n            val j3 = async {\n                latch.await()\n                channel.invokeOnClose { counter.incrementAndGet() }\n            }\n\n            latch.countDown()\n            joinAll(j1, j2, j3)\n            assertEquals(1, counter.get())\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/ProduceConsumeJvmTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass ProduceConsumeJvmTest(\n    private val capacity: Int,\n    private val number: Int\n) : TestBase() {\n    companion object {\n        @Parameterized.Parameters(name = \"capacity={0}, number={1}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> =\n            listOf(0, 1, 10, 1000, Channel.UNLIMITED).flatMap { capacity ->\n                listOf(1, 10, 1000).map { number ->\n                    arrayOf<Any>(capacity, number)\n                }\n            }\n    }\n\n    @Test\n    fun testProducer() = runTest {\n        var sentAll = false\n        val producer = produce(capacity = capacity) {\n            for (i in 1..number) {\n                send(i)\n            }\n            sentAll = true\n        }\n        var consumed = 0\n        for (x in producer) {\n            consumed++\n        }\n        assertTrue(sentAll)\n        assertEquals(number, consumed)\n    }\n\n    @Test\n    fun testActor() = runTest {\n        val received = CompletableDeferred<Int>()\n        val actor = actor<Int>(capacity = capacity) {\n            var n = 0\n            for(i in channel) {\n                n++\n            }\n            received.complete(n)\n        }\n        for(i in 1..number) {\n            actor.send(i)\n        }\n        actor.close()\n        assertEquals(number, received.await())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/SendReceiveJvmStressTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass SendReceiveJvmStressTest(private val channel: Channel<Int>) : TestBase() {\n\n    companion object {\n        @Parameterized.Parameters(name = \"{0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = listOf(\n            Channel<Int>(1),\n            Channel (10),\n            Channel(1_000_000),\n            Channel(Channel.UNLIMITED),\n            Channel(Channel.RENDEZVOUS)\n        ).map { arrayOf<Any>(it) }\n    }\n\n    @Test\n    fun testStress() = runTest {\n        val n = 100_000 * stressTestMultiplier\n        val sender = launch {\n            for (i in 1..n) {\n                channel.send(i)\n            }\n            expect(2)\n        }\n        val receiver = launch {\n            for (i in 1..n) {\n                val next = channel.receive()\n                check(next == i)\n            }\n            expect(3)\n        }\n        expect(1)\n        sender.join()\n        receiver.join()\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/SimpleSendReceiveJvmTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass SimpleSendReceiveJvmTest(\n    private val kind: TestChannelKind,\n    val n: Int,\n    val concurrent: Boolean\n) : TestBase() {\n    companion object {\n        @Parameterized.Parameters(name = \"{0}, n={1}, concurrent={2}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = TestChannelKind.values().flatMap { kind ->\n            listOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000).flatMap { n ->\n                listOf(false, true).map { concurrent ->\n                    arrayOf<Any>(kind, n, concurrent)\n                }\n            }\n        }\n    }\n\n    val channel = kind.create<Int>()\n\n    @Test\n    fun testSimpleSendReceive() = runBlocking {\n        val ctx = if (concurrent) Dispatchers.Default else coroutineContext\n        launch(ctx) {\n            repeat(n) { channel.send(it) }\n            channel.close()\n        }\n        var expected = 0\n        for (x in channel) {\n            if (!kind.isConflated) {\n                assertEquals(expected++, x)\n            } else {\n                assertTrue(x >= expected)\n                expected = x + 1\n            }\n        }\n        if (!kind.isConflated) {\n            assertEquals(n, expected)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/TickerChannelCommonTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass TickerChannelCommonTest(private val channelFactory: Channel) : TestBase() {\n    companion object {\n        @Parameterized.Parameters(name = \"{0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> =\n            Channel.values().map { arrayOf<Any>(it) }\n    }\n\n    enum class Channel {\n        FIXED_PERIOD {\n            override fun invoke(delay: Long, initialDelay: Long) =\n                ticker(delay, initialDelayMillis = initialDelay, mode = TickerMode.FIXED_PERIOD)\n        },\n\n        FIXED_DELAY {\n            override fun invoke(delay: Long, initialDelay: Long) =\n                ticker(delay, initialDelayMillis = initialDelay, mode = TickerMode.FIXED_DELAY)\n        };\n\n        abstract operator fun invoke(delay: Long, initialDelay: Long = 0): ReceiveChannel<Unit>\n    }\n\n    @Test\n    fun testDelay() = withVirtualTimeSource {\n        runTest {\n            val delayChannel = channelFactory(delay = 10000)\n            delayChannel.checkNotEmpty()\n            delayChannel.checkEmpty()\n\n            delay(5000)\n            delayChannel.checkEmpty()\n            delay(5100)\n            delayChannel.checkNotEmpty()\n\n            delayChannel.cancel()\n            delay(5100)\n            assertFailsWith<CancellationException> { delayChannel.tryReceive().getOrThrow() }\n        }\n    }\n\n    @Test\n    fun testInitialDelay() = withVirtualTimeSource {\n        runTest {\n            val delayChannel = channelFactory(initialDelay = 750, delay = 1000)\n            delayChannel.checkEmpty()\n            delay(500)\n            delayChannel.checkEmpty()\n            delay(300)\n            delayChannel.checkNotEmpty()\n\n            // Regular delay\n            delay(750)\n            delayChannel.checkEmpty()\n            delay(260)\n            delayChannel.checkNotEmpty()\n            delayChannel.cancel()\n        }\n    }\n\n    @Test\n    fun testReceive() = withVirtualTimeSource {\n        runTest {\n            val delayChannel = channelFactory(delay = 1000)\n            delayChannel.checkNotEmpty()\n            var value = withTimeoutOrNull(750) {\n                delayChannel.receive()\n                1\n            }\n\n            assertNull(value)\n            value = withTimeoutOrNull(260) {\n                delayChannel.receive()\n                1\n            }\n\n            assertNotNull(value)\n            delayChannel.cancel()\n        }\n    }\n\n    @Test\n    fun testComplexOperator() = withVirtualTimeSource {\n        runTest {\n            val producer = GlobalScope.produce {\n                for (i in 1..7) {\n                    send(i)\n                    delay(1000)\n                }\n            }\n\n            val averages = producer.averageInTimeWindow(3000).toList()\n            assertEquals(listOf(2.0, 5.0, 7.0), averages)\n        }\n    }\n\n    private fun ReceiveChannel<Int>.averageInTimeWindow(timespan: Long) = GlobalScope.produce {\n        val delayChannel = channelFactory(delay = timespan, initialDelay = timespan)\n        var sum = 0\n        var n = 0\n        whileSelect {\n            this@averageInTimeWindow.onReceiveCatching {\n                if (it.isClosed) {\n                    // Send leftovers and bail out\n                    if (n != 0) send(sum / n.toDouble())\n                    false\n                } else {\n                    sum += it.getOrThrow()\n                    ++n\n                    true\n                }\n            }\n\n            // Timeout, send aggregated average and reset counters\n            delayChannel.onReceive {\n                send(sum / n.toDouble())\n                sum = 0\n                n = 0\n                true\n            }\n        }\n\n        delayChannel.cancel()\n    }\n\n    @Test\n    fun testStress() = runTest {\n        // No OOM/SOE\n        val iterations = 100_000 * stressTestMultiplier\n        val delayChannel = channelFactory(0)\n        repeat(iterations) {\n            delayChannel.receive()\n        }\n\n        delayChannel.cancel()\n    }\n\n    @Test(expected = IllegalArgumentException::class)\n    fun testNegativeDelay() {\n        channelFactory(-1)\n    }\n\n    @Test(expected = IllegalArgumentException::class)\n    fun testNegativeInitialDelay() {\n        channelFactory(initialDelay = -1, delay = 100)\n    }\n}\n\nfun ReceiveChannel<Unit>.checkEmpty() = assertNull(tryReceive().getOrNull())\n\nfun ReceiveChannel<Unit>.checkNotEmpty() {\n    assertNotNull(tryReceive().getOrNull())\n    assertNull(tryReceive().getOrNull())\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/channels/TickerChannelTest.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\n\nclass TickerChannelTest : TestBase() {\n    @Test\n    fun testFixedDelayChannelBackpressure() = withVirtualTimeSource {\n        runTest {\n            val delayChannel = ticker(delayMillis = 1000, initialDelayMillis = 0, mode = TickerMode.FIXED_DELAY)\n            delayChannel.checkNotEmpty()\n            delayChannel.checkEmpty()\n\n            delay(1500)\n            delayChannel.checkNotEmpty()\n            delay(500)\n            delayChannel.checkEmpty()\n            delay(520)\n            delayChannel.checkNotEmpty()\n            delayChannel.cancel()\n        }\n    }\n\n    @Test\n    fun testDelayChannelBackpressure() = withVirtualTimeSource {\n        runTest {\n            val delayChannel = ticker(delayMillis = 1000, initialDelayMillis = 0)\n            delayChannel.checkNotEmpty()\n            delayChannel.checkEmpty()\n\n            delay(1500)\n            delayChannel.checkNotEmpty()\n            delay(520)\n            delayChannel.checkNotEmpty()\n            delay(500)\n            delayChannel.checkEmpty()\n            delay(520)\n            delayChannel.checkNotEmpty()\n            delayChannel.cancel()\n        }\n    }\n\n    @Test\n    fun testDelayChannelBackpressure2() = withVirtualTimeSource {\n        runTest {\n            val delayChannel = ticker(delayMillis = 200, initialDelayMillis = 0)\n            delayChannel.checkNotEmpty()\n            delayChannel.checkEmpty()\n\n            delay(500)\n            delayChannel.checkNotEmpty()\n            delay(110)\n            delayChannel.checkNotEmpty()\n            delay(110)\n            delayChannel.checkEmpty()\n            delay(110)\n            delayChannel.checkNotEmpty()\n            delayChannel.cancel()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/examples/example-delay-01.kt",
        "content": "// This file was automatically generated from Delay.kt by Knit tool. Do not edit.\npackage kotlinx.coroutines.examples.exampleDelay01\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nfun main() = runBlocking {\n\nflow {\n    emit(1)\n    delay(90)\n    emit(2)\n    delay(90)\n    emit(3)\n    delay(1010)\n    emit(4)\n    delay(1010)\n    emit(5)\n}.debounce(1000)\n.toList().joinToString().let { println(it) } }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/examples/example-delay-02.kt",
        "content": "// This file was automatically generated from Delay.kt by Knit tool. Do not edit.\npackage kotlinx.coroutines.examples.exampleDelay02\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nfun main() = runBlocking {\n\nflow {\n    emit(1)\n    delay(90)\n    emit(2)\n    delay(90)\n    emit(3)\n    delay(1010)\n    emit(4)\n    delay(1010)\n    emit(5)\n}.debounce {\n    if (it == 1) {\n        0L\n    } else {\n        1000L\n    }\n}\n.toList().joinToString().let { println(it) } }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/examples/example-delay-03.kt",
        "content": "// This file was automatically generated from Delay.kt by Knit tool. Do not edit.\npackage kotlinx.coroutines.examples.exampleDelay03\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nfun main() = runBlocking {\n\nflow {\n    repeat(10) {\n        emit(it)\n        delay(110)\n    }\n}.sample(200)\n.toList().joinToString().let { println(it) } }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/examples/example-delay-duration-01.kt",
        "content": "// This file was automatically generated from Delay.kt by Knit tool. Do not edit.\npackage kotlinx.coroutines.examples.exampleDelayDuration01\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nfun main() = runBlocking {\n\nflow {\n    emit(1)\n    delay(90.milliseconds)\n    emit(2)\n    delay(90.milliseconds)\n    emit(3)\n    delay(1010.milliseconds)\n    emit(4)\n    delay(1010.milliseconds)\n    emit(5)\n}.debounce(1000.milliseconds)\n.toList().joinToString().let { println(it) } }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/examples/example-delay-duration-02.kt",
        "content": "// This file was automatically generated from Delay.kt by Knit tool. Do not edit.\npackage kotlinx.coroutines.examples.exampleDelayDuration02\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nfun main() = runBlocking {\n\nflow {\n    emit(1)\n    delay(90.milliseconds)\n    emit(2)\n    delay(90.milliseconds)\n    emit(3)\n    delay(1010.milliseconds)\n    emit(4)\n    delay(1010.milliseconds)\n    emit(5)\n}.debounce {\n    if (it == 1) {\n        0.milliseconds\n    } else {\n        1000.milliseconds\n    }\n}\n.toList().joinToString().let { println(it) } }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/examples/example-delay-duration-03.kt",
        "content": "// This file was automatically generated from Delay.kt by Knit tool. Do not edit.\npackage kotlinx.coroutines.examples.exampleDelayDuration03\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nfun main() = runBlocking {\n\nflow {\n    repeat(10) {\n        emit(it)\n        delay(110.milliseconds)\n    }\n}.sample(200.milliseconds)\n.toList().joinToString().let { println(it) } }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/examples/example-timeout-duration-01.kt",
        "content": "// This file was automatically generated from Delay.kt by Knit tool. Do not edit.\npackage kotlinx.coroutines.examples.exampleTimeoutDuration01\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nfun main() = runBlocking {\n\nflow {\n    emit(1)\n    delay(100)\n    emit(2)\n    delay(100)\n    emit(3)\n    delay(1000)\n    emit(4)\n}.timeout(100.milliseconds).catch { exception ->\n    if (exception is TimeoutCancellationException) {\n        // Catch the TimeoutCancellationException emitted above.\n        // Emit desired item on timeout.\n        emit(-1)\n    } else {\n        // Throw other exceptions.\n        throw exception\n    }\n}.onEach {\n    delay(300) // This will not cause a timeout\n}\n.toList().joinToString().let { println(it) } }\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/examples/test/FlowDelayTest.kt",
        "content": "// This file was automatically generated from Delay.kt by Knit tool. Do not edit.\npackage kotlinx.coroutines.examples.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass FlowDelayTest {\n    @Test\n    fun testExampleDelay01() {\n        test(\"ExampleDelay01\") { kotlinx.coroutines.examples.exampleDelay01.main() }.verifyLines(\n            \"3, 4, 5\"\n        )\n    }\n\n    @Test\n    fun testExampleDelay02() {\n        test(\"ExampleDelay02\") { kotlinx.coroutines.examples.exampleDelay02.main() }.verifyLines(\n            \"1, 3, 4, 5\"\n        )\n    }\n\n    @Test\n    fun testExampleDelayDuration01() {\n        test(\"ExampleDelayDuration01\") { kotlinx.coroutines.examples.exampleDelayDuration01.main() }.verifyLines(\n            \"3, 4, 5\"\n        )\n    }\n\n    @Test\n    fun testExampleDelayDuration02() {\n        test(\"ExampleDelayDuration02\") { kotlinx.coroutines.examples.exampleDelayDuration02.main() }.verifyLines(\n            \"1, 3, 4, 5\"\n        )\n    }\n\n    @Test\n    fun testExampleDelay03() {\n        test(\"ExampleDelay03\") { kotlinx.coroutines.examples.exampleDelay03.main() }.verifyLines(\n            \"1, 3, 5, 7, 9\"\n        )\n    }\n\n    @Test\n    fun testExampleDelayDuration03() {\n        test(\"ExampleDelayDuration03\") { kotlinx.coroutines.examples.exampleDelayDuration03.main() }.verifyLines(\n            \"1, 3, 5, 7, 9\"\n        )\n    }\n\n    @Test\n    fun testExampleTimeoutDuration01() {\n        test(\"ExampleTimeoutDuration01\") { kotlinx.coroutines.examples.exampleTimeoutDuration01.main() }.verifyLines(\n            \"1, 2, 3, -1\"\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/CoroutineExceptionHandlerJvmTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass CoroutineExceptionHandlerJvmTest : TestBase() {\n\n    private val exceptionHandler = Thread.getDefaultUncaughtExceptionHandler()\n    private lateinit var caughtException: Throwable\n\n    @Before\n    fun setUp() {\n        Thread.setDefaultUncaughtExceptionHandler({ _, e -> caughtException = e })\n    }\n\n    @After\n    fun tearDown() {\n        Thread.setDefaultUncaughtExceptionHandler(exceptionHandler)\n    }\n\n    @Test\n    fun testFailingHandler() = runBlocking {\n        expect(1)\n        val job = GlobalScope.launch(CoroutineExceptionHandler { _, _ -> throw AssertionError() }) {\n            expect(2)\n            throw TestException()\n        }\n\n        job.join()\n        assertIs<RuntimeException>(caughtException)\n        assertIs<AssertionError>(caughtException.cause)\n        assertIs<TestException>(caughtException.suppressed[0])\n\n        finish(3)\n    }\n\n    @Test\n    fun testLastDitchHandlerContainsContextualInformation() = runBlocking {\n        expect(1)\n        GlobalScope.launch(CoroutineName(\"last-ditch\")) {\n            expect(2)\n            throw TestException()\n        }.join()\n        assertIs<TestException>(caughtException)\n        assertContains(caughtException.suppressed[0].toString(), \"last-ditch\")\n        finish(3)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/FlowSuppressionTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass FlowSuppressionTest : TestBase() {\n    @Test\n    fun testSuppressionForPrimaryException() = runTest {\n        val flow = flow {\n            try {\n                emit(1)\n            } finally {\n                throw TestException()\n            }\n        }.catch { expectUnreached() }.onEach { throw TestException2() }\n\n        try {\n            flow.collect()\n        } catch (e: Throwable) {\n            assertIs<TestException>(e)\n            assertIs<TestException2>(e.suppressed[0])\n        }\n    }\n\n    @Test\n    fun testSuppressionForPrimaryExceptionRetry() = runTest {\n        val flow = flow {\n            try {\n                emit(1)\n            } finally {\n                throw TestException()\n            }\n        }.retry { expectUnreached(); true }.onEach { throw TestException2() }\n\n        try {\n            flow.collect()\n        } catch (e: Throwable) {\n            assertIs<TestException>(e)\n            assertIs<TestException2>(e.suppressed[0])\n\n        }\n    }\n\n    @Test\n    fun testCancellationSuppression() = runTest {\n        val flow = flow {\n            try {\n                expect(1)\n                emit(1)\n            } finally {\n                expect(3)\n                throw CancellationException(\"\")\n            }\n        }.catch { expectUnreached() }.onEach {\n            expect(2)\n            throw TestException(\"\")\n        }\n\n        try {\n            flow.collect()\n        } catch (e: Throwable) {\n            assertIs<TestException>(e)\n            assertIs<CancellationException>(e.suppressed[0])\n        }\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/JobBasicCancellationTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.io.*\nimport kotlin.test.*\n\n/*\n * Basic checks that check that cancellation more or less works,\n * parent is not cancelled on child cancellation and launch {}, Job(), async {} and\n * CompletableDeferred behave properly\n */\n\n@Suppress(\"DEPRECATION\") // cancel(cause)\nclass JobBasicCancellationTest : TestBase() {\n\n    @Test\n    fun testJobCancelChild() = runTest {\n        val parent = launch {\n            expect(1)\n            val child = launch {\n                expect(2)\n            }\n\n            yield()\n            expect(3)\n            child.cancel()\n            child.join()\n            expect(4)\n        }\n\n        parent.join()\n        finish(5)\n    }\n\n    @Test\n    fun testJobCancelChildAtomic() = runTest {\n        val parent = launch {\n            expect(1)\n            val child = launch(start = CoroutineStart.ATOMIC) {\n                expect(3)\n            }\n\n            expect(2)\n            child.cancel()\n            child.join()\n            yield()\n            expect(4)\n        }\n\n        parent.join()\n        assertTrue(parent.isCompleted)\n        assertFalse(parent.isCancelled)\n        finish(5)\n    }\n\n    @Test\n    fun testAsyncCancelChild() = runTest {\n        val parent = async {\n            expect(1)\n            val child = async {\n                expect(2)\n            }\n\n            yield()\n            expect(3)\n            child.cancel()\n            child.await()\n            expect(4)\n        }\n\n        parent.await()\n        finish(5)\n    }\n\n    @Test\n    fun testAsyncCancelChildAtomic() = runTest {\n        val parent = async {\n            expect(1)\n            val child = async(start = CoroutineStart.ATOMIC) {\n                expect(3)\n            }\n\n            expect(2)\n            child.cancel()\n            child.join()\n            expect(4)\n        }\n\n        parent.await()\n        finish(5)\n    }\n\n    @Test\n    fun testNestedAsyncFailure() = runTest {\n        val deferred = async(NonCancellable) {\n            val nested = async(NonCancellable) {\n                expect(3)\n                throw IOException()\n            }\n\n            expect(2)\n            yield()\n            expect(4)\n            nested.await()\n        }\n\n        expect(1)\n        try {\n            deferred.await()\n        } catch (e: IOException) {\n            finish(5)\n        }\n    }\n\n    @Test\n    fun testCancelJobImpl() = runTest {\n        val parent = launch {\n            expect(1)\n            val child = Job(coroutineContext[Job])\n            expect(2)\n            child.cancel() // cancel without cause -- should not cancel us (parent)\n            child.join()\n            expect(3)\n        }\n        parent.join()\n        finish(4)\n    }\n\n    @Test\n    fun cancelCompletableDeferred() = runTest {\n        val parent = launch {\n            expect(1)\n            val child = CompletableDeferred<Unit>(coroutineContext[Job])\n            expect(2)\n            child.cancel() // cancel without cause -- should not cancel us (parent)\n            child.join()\n            expect(3)\n        }\n\n        parent.join()\n        finish(4)\n    }\n\n    @Test\n    fun testConsecutiveCancellation() {\n        val deferred = CompletableDeferred<Int>()\n        assertTrue(deferred.completeExceptionally(IndexOutOfBoundsException()))\n        assertFalse(deferred.completeExceptionally(AssertionError())) // second is too late\n        val cause = deferred.getCancellationException().cause!!\n        assertIs<IndexOutOfBoundsException>(cause)\n        assertNull(cause.cause)\n        assertTrue(cause.suppressed.isEmpty())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/JobExceptionHandlingTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CoroutineStart.*\nimport kotlinx.coroutines.testing.exceptions.*\nimport org.junit.Test\nimport java.io.*\nimport kotlin.test.*\n\n@Suppress(\"DEPRECATION\") // cancel(cause)\nclass JobExceptionHandlingTest : TestBase() {\n\n    @Test\n    fun testChildException() {\n        /*\n         * Root parent: JobImpl()\n         * Child: throws ISE\n         * Result: ISE in exception handler\n         */\n        val exception = captureExceptionsRun {\n            val job = Job()\n            launch(job, start = ATOMIC) {\n                expect(2)\n                throw IllegalStateException()\n            }\n\n            expect(1)\n            job.join()\n            finish(3)\n        }\n\n        checkException<IllegalStateException>(exception)\n    }\n\n    @Test\n    fun testAsyncCancellationWithCauseAndParent() = runTest {\n        val parent = Job()\n        val deferred = async(parent) {\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n\n        expect(1)\n        yield()\n        parent.completeExceptionally(IOException())\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: CancellationException) {\n            assertTrue(e.suppressed.isEmpty())\n            assertTrue(e.cause?.suppressed?.isEmpty() ?: false)\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testAsyncCancellationWithCauseAndParentDoesNotTriggerHandling() = runTest {\n        val parent = Job()\n        val job = launch(parent) {\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n\n        expect(1)\n        yield()\n        parent.completeExceptionally(IOException())\n        job.join()\n        finish(3)\n    }\n\n    @Test\n    fun testExceptionDuringCancellation() {\n        /*\n         * Root parent: JobImpl()\n         * Launcher: cancels job\n         * Child: throws ISE\n         * Result: ISE in exception handler\n         *\n         * Github issue #354\n         */\n        val exception = captureExceptionsRun {\n            val job = Job()\n            val child = launch(job, start = ATOMIC) {\n                expect(2)\n                throw IllegalStateException()\n            }\n\n            expect(1)\n            job.cancelAndJoin()\n            assert(child.isCompleted && !child.isActive)\n            finish(3)\n        }\n\n        checkException<IllegalStateException>(exception)\n    }\n\n    @Test\n    fun testExceptionOnChildCancellation() {\n        /*\n         * Root parent: JobImpl()\n         * Child: launch inner child and cancels parent\n         * Inner child: throws AE\n         * Result: AE in exception handler\n         */\n        val exception = captureExceptionsRun {\n            val job = Job()\n            launch(job) {\n                expect(2) // <- child is launched successfully\n\n                launch {\n                    expect(3) // <- child's child is launched successfully\n                    try {\n                        yield()\n                    } catch (e: CancellationException) {\n                        throw ArithmeticException()\n                    }\n                }\n\n                yield()\n                expect(4)\n                job.cancel()\n            }\n\n            expect(1)\n            job.join()\n            finish(5)\n        }\n\n        checkException<ArithmeticException>(exception)\n    }\n\n    @Test\n    fun testInnerChildException() {\n        /*\n        * Root parent: JobImpl()\n        * Launcher: launch child and cancel root\n        * Child: launch nested child atomically and yields\n        * Inner child: throws AE\n        * Result: AE\n        */\n        val exception = captureExceptionsRun {\n            val job = Job()\n            launch(job, start = ATOMIC) {\n                expect(2)\n                launch(start = ATOMIC) {\n                    expect(3) // <- child's child is launched successfully\n                    throw ArithmeticException()\n                }\n\n                yield() // will throw cancellation exception\n            }\n\n            expect(1)\n            job.cancelAndJoin()\n            finish(4)\n        }\n\n        checkException<ArithmeticException>(exception)\n    }\n\n    @Test\n    fun testExceptionOnChildCancellationWithCause() {\n        /*\n         * Root parent: JobImpl()\n         * Child: launch inner child and cancels parent with IOE\n         * Inner child: throws AE\n         * Result: IOE with suppressed AE\n         */\n        val exception = captureExceptionsRun {\n            val job = Job()\n            launch(job) {\n                expect(2) // <- child is launched successfully\n                launch {\n                    expect(3) // <- child's child is launched successfully\n                    try {\n                        yield()\n                    } catch (e: CancellationException) {\n                        throw ArithmeticException()\n                    }\n                }\n\n                yield()\n                expect(4)\n                job.completeExceptionally(IOException())\n            }\n\n            expect(1)\n            job.join()\n            finish(5)\n        }\n\n        checkException<ArithmeticException>(exception)\n    }\n\n    @Test\n    fun testMultipleChildrenThrowAtomically() {\n        /*\n          * Root parent: JobImpl()\n          * Launcher: launches child\n          * Child: launch 3 children, each of them throws an exception (AE, IOE, IAE) and calls delay()\n          * Result: AE with suppressed IOE and IAE\n          */\n        val exception = captureExceptionsRun {\n            val job = Job()\n            launch(job, start = ATOMIC) {\n                expect(2)\n                launch(start = ATOMIC) {\n                    expect(3)\n                    throw ArithmeticException()\n                }\n\n                launch(start = ATOMIC) {\n                    expect(4)\n                    throw IOException()\n                }\n\n                launch(start = ATOMIC) {\n                    expect(5)\n                    throw IllegalArgumentException()\n                }\n\n                delay(Long.MAX_VALUE)\n            }\n\n            expect(1)\n            job.join()\n            finish(6)\n        }\n\n        assertIs<ArithmeticException>(exception)\n        assertNull(exception.cause)\n        val suppressed = exception.suppressed\n        assertEquals(2, suppressed.size)\n        assertIs<IOException>(suppressed[0])\n        assertIs<IllegalArgumentException>(suppressed[1])\n    }\n\n    @Test\n    fun testMultipleChildrenAndParentThrowsAtomic() {\n        /*\n         * Root parent: JobImpl()\n         * Launcher: launches child\n         * Child: launch 2 children (each of them throws an exception (IOE, IAE)), throws AE\n         * Result: AE with suppressed IOE and IAE\n         */\n        val exception = captureExceptionsRun {\n            val job = Job()\n            launch(job, start = ATOMIC) {\n                expect(2)\n                launch(start = ATOMIC) {\n                    expect(3)\n                    throw IOException()\n                }\n\n                launch(start = ATOMIC) {\n                    expect(4)\n                    throw IllegalArgumentException()\n                }\n\n                throw AssertionError()\n            }\n\n            expect(1)\n            job.join()\n            finish(5)\n        }\n\n        assertIs<AssertionError>(exception)\n        val suppressed = exception.suppressed\n        assertEquals(2, suppressed.size)\n        assertIs<IOException>(suppressed[0])\n        assertIs<IllegalArgumentException>(suppressed[1])\n    }\n\n    @Test\n    fun testExceptionIsHandledOnce() = runTest(unhandled = listOf { e -> e is TestException }) {\n        val job = Job()\n        val j1 = launch(job) {\n            expect(1)\n            delay(Long.MAX_VALUE)\n        }\n\n        val j2 = launch(job) {\n            expect(2)\n            throw TestException()\n        }\n\n        joinAll(j1 ,j2)\n        finish(3)\n    }\n\n    @Test\n    fun testCancelledParent() = runTest {\n        expect(1)\n        val parent = Job()\n        parent.completeExceptionally(TestException())\n        launch(parent) {\n            expectUnreached()\n        }.join()\n        finish(2)\n    }\n\n    @Test\n    fun testExceptionIsNotReported() = runTest {\n        try {\n            expect(1)\n            coroutineScope {\n                val job = Job(coroutineContext[Job])\n                launch(job) {\n                    throw TestException()\n                }\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testExceptionIsNotReportedTripleChain() = runTest {\n        try {\n            expect(1)\n            coroutineScope {\n                val job = Job(Job(Job(coroutineContext[Job])))\n                launch(job) {\n                    throw TestException()\n                }\n            }\n            expectUnreached()\n        } catch (e: TestException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testAttachToCancelledJob() = runTest(unhandled = listOf({ e -> e is TestException })) {\n        val parent = launch(Job()) {\n            throw TestException()\n        }.apply { join() }\n\n        launch(parent) { expectUnreached() }\n        launch(Job(parent)) { expectUnreached() }\n    }\n\n    @Test\n    fun testBadException() = runTest(unhandled = listOf({e -> e is BadException})) {\n        val job = launch(Job()) {\n            expect(2)\n            launch {\n                expect(3)\n                throw BadException()\n            }\n\n            launch(start = ATOMIC) {\n                expect(4)\n                throw BadException()\n            }\n\n            yield()\n            BadException()\n        }\n\n        expect(1)\n        yield()\n        yield()\n        expect(5)\n        job.join()\n        finish(6)\n    }\n\n    private class BadException : Exception() {\n        override fun hashCode(): Int {\n            throw AssertionError()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/JobExceptionsStressTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.exceptions.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass JobExceptionsStressTest : TestBase() {\n\n    private val executor = newFixedThreadPoolContext(5, \"JobExceptionsStressTest\")\n\n    @After\n    fun tearDown() {\n        executor.close()\n    }\n\n    @Test\n    fun testMultipleChildrenThrows() {\n        /*\n         * Root parent: launched job\n         * Owner: launch 3 children, every of it throws an exception, and then call delay()\n         * Result: one of the exceptions with the rest two as suppressed\n         */\n        repeat(1000 * stressTestMultiplier) {\n            val exception = captureExceptionsRun(executor) {\n                val barrier = CyclicBarrier(4)\n                val job = launch(NonCancellable) {\n                    launch(start = CoroutineStart.ATOMIC) {\n                        barrier.await()\n                        throw TestException1()\n                    }\n                    launch(start = CoroutineStart.ATOMIC) {\n                        barrier.await()\n                        throw TestException2()\n                    }\n                    launch(start = CoroutineStart.ATOMIC) {\n                        barrier.await()\n                        throw TestException3()\n                    }\n                    delay(1000) // to avoid OutOfMemory errors....\n                }\n                barrier.await()\n                job.join()\n            }\n            val classes = mutableSetOf(\n                TestException1::class,\n                TestException2::class,\n                TestException3::class\n            )\n            val suppressedExceptions = exception.suppressed.toSet()\n            assertTrue(classes.remove(exception::class),\n                \"Failed to remove ${exception::class} from $suppressedExceptions\"\n            )\n            for (throwable in suppressedExceptions.toSet()) { // defensive copy\n                assertTrue(classes.remove(throwable::class),\n                    \"Failed to remove ${throwable::class} from $suppressedExceptions\")\n            }\n            assertTrue(classes.isEmpty(), \"Expected all exception to be present, but following exceptions are missing: $classes\")\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/JobNestedExceptionsTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.exceptions.*\nimport org.junit.Test\nimport java.io.*\nimport kotlin.test.*\n\nclass JobNestedExceptionsTest : TestBase() {\n\n    @Test\n    fun testExceptionUnwrapping() {\n        val exception = captureExceptionsRun {\n            val job = Job()\n            launch(job) {\n                expect(2)\n                launch {\n                    launch {\n                        launch {\n                            throw IllegalStateException()\n                        }\n                    }\n                }\n            }\n\n            expect(1)\n            job.join()\n            finish(3)\n        }\n\n        checkException<IllegalStateException>(exception)\n        checkCycles(exception)\n    }\n\n    @Test\n    fun testExceptionUnwrappingWithSuspensions() {\n        val exception = captureExceptionsRun {\n            val job = Job()\n            launch(job) {\n                expect(2)\n                launch {\n                    launch {\n                        launch {\n                            launch {\n                                throw IOException()\n                            }\n                            yield()\n                        }\n                        delay(Long.MAX_VALUE)\n                    }\n                    delay(Long.MAX_VALUE)\n                }\n                delay(Long.MAX_VALUE)\n            }\n\n            expect(1)\n            job.join()\n            finish(3)\n        }\n\n        assertIs<IOException>(exception)\n    }\n\n    @Test\n    fun testNestedAtomicThrow() {\n        val exception = captureExceptionsRun {\n            expect(1)\n            val job = launch(NonCancellable + CoroutineName(\"outer\"), start = CoroutineStart.ATOMIC) {\n                expect(2)\n                launch(CoroutineName(\"nested\"), start = CoroutineStart.ATOMIC) {\n                    expect(4)\n                    throw IOException()\n                }\n                expect(3)\n                throw ArithmeticException()\n            }\n            job.join()\n            finish(5)\n        }\n        assertIs<ArithmeticException>(exception, \"Found $exception\")\n        checkException<IOException>(exception.suppressed[0])\n    }\n\n    @Test\n    fun testChildThrowsDuringCompletion() {\n        val exception = captureExceptionsRun {\n            expect(1)\n            val job = launch(NonCancellable + CoroutineName(\"outer\"), start = CoroutineStart.ATOMIC) {\n                expect(2)\n                launch(CoroutineName(\"nested\"), start = CoroutineStart.ATOMIC) {\n                    expect(4)\n                    launch(CoroutineName(\"nested2\"), start = CoroutineStart.ATOMIC) {\n                        // This child attaches to the parent and throws after parent completion\n                        expect(6)\n                        throw NullPointerException()\n                    }\n                    expect(5)\n                    throw IOException()\n                }\n                expect(3)\n                throw ArithmeticException()\n            }\n\n            job.join()\n            finish(7)\n        }\n\n        assertIs<ArithmeticException>(exception, \"Exception is $exception\")\n        val suppressed = exception.suppressed\n        val ioe = suppressed[0]\n        assertIs<IOException>(ioe)\n        checkException<NullPointerException>(ioe.suppressed[0])\n        checkCycles(exception)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/ProduceExceptionsTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass ProduceExceptionsTest : TestBase() {\n\n    @Test\n    fun testFailingProduce() = runTest(unhandled = listOf({ e -> e is TestException })) {\n        expect(1)\n        val producer = produce<Int>(Job()) {\n            expect(2)\n            try {\n                yield()\n            } finally {\n                expect(3)\n                throw TestException()\n\n            }\n        }\n\n        yield()\n        producer.cancel()\n        yield()\n        finish(4)\n    }\n\n    @Test\n    fun testSuppressedExceptionUncaught() =\n        runTest(unhandled = listOf({ e -> e is TestException && e.suppressed[0] is TestException2 })) {\n            val produce = produce<Int>(Job()) {\n                launch(start = CoroutineStart.ATOMIC) {\n                    throw TestException()\n                }\n                try {\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    throw TestException2()\n                }\n            }\n\n            yield()\n            produce.cancel()\n        }\n\n    @Test\n    fun testSuppressedException() = runTest {\n        val produce = produce<Int>(NonCancellable) {\n            launch(start = CoroutineStart.ATOMIC) {\n                throw TestException() // child coroutine fails\n            }\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException2() // but parent throws another exception while cleaning up\n            }\n        }\n        try {\n            produce.receive()\n            expectUnreached()\n        } catch (e: TestException) {\n            assertIs<TestException2>(e.suppressed[0])\n        }\n    }\n\n    @Test\n    fun testCancelProduceChannel() = runTest {\n        var channel: ReceiveChannel<Int>? = null\n        channel = produce {\n            expect(2)\n            channel!!.cancel()\n            try {\n                send(1)\n            } catch (e: CancellationException) {\n                expect(3)\n                throw e\n            }\n        }\n\n        expect(1)\n        yield()\n        try {\n            channel.receive()\n        } catch (e: CancellationException) {\n            assertTrue(e.suppressed.isEmpty())\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testCancelProduceChannelWithException() = runTest {\n        var channel: ReceiveChannel<Int>? = null\n        channel = produce(NonCancellable) {\n            expect(2)\n            channel!!.cancel(TestCancellationException())\n            try {\n                send(1)\n                // Not a ClosedForSendException\n            } catch (e: TestCancellationException) {\n                expect(3)\n                throw e\n            }\n        }\n\n        expect(1)\n        yield()\n        try {\n            channel.receive()\n        } catch (e: TestCancellationException) {\n            assertTrue(e.suppressed.isEmpty())\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testCancelChannelWithJob() = runTest {\n        val job = Job()\n        val channel = produce(job) {\n            expect(2)\n            job.cancel()\n            try {\n                send(1)\n            } catch (e: CancellationException) {\n                expect(3)\n                throw e\n            }\n        }\n\n        expect(1)\n        yield()\n        try {\n            channel.receive()\n        } catch (e: CancellationException) {\n            assertTrue(e.suppressed.isEmpty())\n            finish(4)\n        }\n    }\n\n    @Test\n    fun testCancelChannelWithJobWithException() = runTest {\n        val job = Job()\n        val channel = produce(job) {\n            expect(2)\n            job.completeExceptionally(TestException2())\n            try {\n                send(1)\n            } catch (e: CancellationException) { // Not a TestException2\n                expect(3)\n                throw e\n            }\n        }\n\n        expect(1)\n        yield()\n        try {\n            channel.receive()\n        } catch (e: CancellationException) {\n            // RECOVER_STACK_TRACES\n            assertIs<TestException2>(e.cause?.cause)\n            finish(4)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/StackTraceRecoveryChannelsTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.*\nimport org.junit.rules.*\nimport kotlin.coroutines.*\n\nclass StackTraceRecoveryChannelsTest : TestBase() {\n\n    @get:Rule\n    val name = TestName()\n\n    @Test\n    fun testReceiveFromChannel() = runTest {\n        val channel = Channel<Int>()\n        val job = launch {\n            expect(2)\n            channel.close(RecoverableTestException())\n        }\n\n        expect(1)\n        channelReceive(channel)\n        expect(3)\n        job.join()\n        finish(4)\n    }\n\n    @Test\n    fun testReceiveFromClosedChannel() = runTest {\n        val channel = Channel<Int>()\n        channel.close(RecoverableTestException())\n        channelReceive(channel)\n    }\n\n    @Test\n    fun testSendToClosedChannel() = runTest {\n        val channel = Channel<Int>()\n        channel.close(RecoverableTestException())\n        channelSend(channel)\n    }\n\n    @Test\n    fun testSendToChannel() = runTest {\n        val channel = Channel<Int>()\n        val job = launch {\n            expect(2)\n            channel.cancel()\n        }\n\n        expect(1)\n        channelSend(channel)\n        expect(3)\n        job.join()\n        finish(4)\n    }\n\n    private suspend fun channelReceive(channel: Channel<Int>) = channelOp { channel.receive() }\n\n    private suspend inline fun channelOp(block: () -> Unit) {\n        try {\n            yield()\n            block()\n            expectUnreached()\n        } catch (e: RecoverableTestException) {\n            verifyStackTrace(\"channels/${name.methodName}\", e)\n        }\n    }\n\n    private suspend fun channelSend(channel: Channel<Int>) {\n        try {\n            yield()\n            channel.send(1)\n            expectUnreached()\n        } catch (e: Exception) {\n            verifyStackTrace(\"channels/${name.methodName}\", e)\n        }\n    }\n\n    @Test\n    fun testOfferWithCurrentContext() = runTest {\n        val channel = Channel<Int>()\n        channel.close(RecoverableTestException())\n\n        try {\n            channel.sendWithContext(coroutineContext)\n        } catch (e: RecoverableTestException) {\n            verifyStackTrace(\"channels/${name.methodName}\", e)\n        }\n    }\n\n    @Test\n    fun testOfferWithContextWrapped() = runTest {\n        val channel = Channel<Int>()\n        channel.close(RecoverableTestException())\n        try {\n            channel.sendWithContext(wrapperDispatcher(coroutineContext))\n        } catch (e: Exception) {\n            verifyStackTrace(\"channels/${name.methodName}\", e)\n        }\n    }\n\n    @Test\n    fun testOfferFromScope() = runTest {\n        val channel = Channel<Int>()\n        channel.close(RecoverableTestException())\n\n        try {\n            channel.sendFromScope()\n        } catch (e: Exception) {\n            verifyStackTrace(\"channels/${name.methodName}\", e)\n        }\n    }\n\n    // Slow path via suspending send\n    @Test\n    fun testSendFromScope() = runTest {\n        val channel = Channel<Int>()\n        val deferred = async {\n            try {\n                expect(1)\n                channel.sendFromScope()\n            } catch (e: Exception) {\n                verifyStackTrace(\"channels/${name.methodName}\", e)\n            }\n        }\n\n        yield()\n        expect(2)\n        // Cancel is an analogue of `produce` failure, just a shorthand\n        channel.cancel(RecoverableTestCancellationException())\n        finish(3)\n        deferred.await()\n    }\n\n    private suspend fun Channel<Int>.sendWithContext(ctx: CoroutineContext) = withContext(ctx) {\n        sendInChannel()\n        yield() // TCE\n    }\n\n    private suspend fun Channel<Int>.sendInChannel() {\n        send(42)\n        yield() // TCE\n    }\n\n    private suspend fun Channel<Int>.sendFromScope() = coroutineScope {\n        sendWithContext(wrapperDispatcher(coroutineContext))\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/StackTraceRecoveryCustomExceptionsTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.Test\nimport kotlin.test.*\n\n@Suppress(\"UNREACHABLE_CODE\", \"UNUSED\", \"UNUSED_PARAMETER\")\nclass StackTraceRecoveryCustomExceptionsTest : TestBase() {\n\n    internal class NonCopyable(val customData: Int) : Throwable() {\n        // Bait\n        public constructor(cause: Throwable) : this(42)\n    }\n\n    internal class Copyable(val customData: Int) : Throwable(), CopyableThrowable<Copyable> {\n        // Bait\n        public constructor(cause: Throwable) : this(42)\n\n        override fun createCopy(): Copyable {\n            val copy = Copyable(customData)\n            copy.initCause(this)\n            return copy\n        }\n    }\n\n    @Test\n    fun testStackTraceNotRecovered() = runTest {\n        try {\n            withContext(wrapperDispatcher(coroutineContext)) {\n                throw NonCopyable(239)\n            }\n            expectUnreached()\n        } catch (e: NonCopyable) {\n            assertEquals(239, e.customData)\n            assertNull(e.cause)\n        }\n    }\n\n    @Test\n    fun testStackTraceRecovered() = runTest {\n        try {\n            withContext(wrapperDispatcher(coroutineContext)) {\n                throw Copyable(239)\n            }\n            expectUnreached()\n        } catch (e: Copyable) {\n            assertEquals(239, e.customData)\n            val cause = e.cause\n            assertIs<Copyable>(cause)\n            assertEquals(239, cause.customData)\n        }\n    }\n\n    internal class WithDefault(message: String = \"default\") : Exception(message)\n\n    @Test\n    fun testStackTraceRecoveredWithCustomMessage() = runTest {\n        try {\n            withContext(wrapperDispatcher(coroutineContext)) {\n                throw WithDefault(\"custom\")\n            }\n            expectUnreached()\n        } catch (e: WithDefault) {\n            assertEquals(\"custom\", e.message)\n            val cause = e.cause\n            assertIs<WithDefault>(cause)\n            assertEquals(\"custom\", cause.message)\n        }\n    }\n\n    class WrongMessageException(token: String) : RuntimeException(\"Token $token\")\n\n    @Test\n    fun testWrongMessageException() = runTest {\n        val result = runCatching {\n            coroutineScope<Unit> {\n                throw WrongMessageException(\"OK\")\n            }\n        }\n        val ex = result.exceptionOrNull() ?: error(\"Expected to fail\")\n        assertIs<WrongMessageException>(ex)\n        assertEquals(\"Token OK\", ex.message)\n    }\n\n    @Test\n    fun testNestedExceptionWithCause() = runTest {\n        val result = runCatching {\n            coroutineScope<Unit> {\n                throw NestedException(IllegalStateException(\"ERROR\"))\n            }\n        }\n        val ex = result.exceptionOrNull() ?: error(\"Expected to fail\")\n        assertIs<NestedException>(ex)\n        assertIs<NestedException>(ex.cause)\n        val originalCause = ex.cause?.cause\n        assertIs<IllegalStateException>(originalCause)\n        assertEquals(\"ERROR\", originalCause.message)\n    }\n\n    class NestedException : RuntimeException {\n        constructor(cause: Throwable) : super(cause)\n        constructor() : super()\n    }\n\n    @Test\n    fun testWrongMessageExceptionInChannel() = runTest {\n        val result = produce<Unit>(SupervisorJob() + Dispatchers.Unconfined) {\n            throw WrongMessageException(\"OK\")\n        }\n        val ex = runCatching {\n            @Suppress(\"ControlFlowWithEmptyBody\")\n            for (unit in result) {\n                // Iterator has a special code path\n            }\n        }.exceptionOrNull() ?: error(\"Expected to fail\")\n        assertIs<WrongMessageException>(ex)\n        assertEquals(\"Token OK\", ex.message)\n    }\n\n    class CopyableWithCustomMessage(\n        message: String?,\n        cause: Throwable? = null\n    ) : RuntimeException(message, cause),\n        CopyableThrowable<CopyableWithCustomMessage> {\n\n        override fun createCopy(): CopyableWithCustomMessage {\n            return CopyableWithCustomMessage(\"Recovered: [$message]\", cause)\n        }\n    }\n\n    @Test\n    fun testCustomCopyableMessage() = runTest {\n        val result = runCatching {\n            coroutineScope<Unit> {\n                throw CopyableWithCustomMessage(\"OK\")\n            }\n        }\n        val ex = result.exceptionOrNull() ?: error(\"Expected to fail\")\n        assertIs<CopyableWithCustomMessage>(ex)\n        assertEquals(\"Recovered: [OK]\", ex.message)\n    }\n\n    @Test\n    fun testTryCopyThrows() = runTest {\n        class FailingException : Exception(), CopyableThrowable<FailingException> {\n            override fun createCopy(): FailingException? {\n                TODO(\"Not yet implemented\")\n            }\n        }\n\n        val e = FailingException()\n        val result = runCatching {\n            coroutineScope<Unit> {\n                throw e\n            }\n        }\n\n        assertSame(e, result.exceptionOrNull())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/StackTraceRecoveryNestedScopesTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport kotlin.coroutines.*\n\nclass StackTraceRecoveryNestedScopesTest : TestBase() {\n\n    private val TEST_MACROS = \"TEST_NAME\"\n\n    private val expectedTrace = \"kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest.failure(StackTraceRecoveryNestedScopesTest.kt:9)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest.access\\$failure(StackTraceRecoveryNestedScopesTest.kt:7)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$createFailingAsync\\$1.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:12)\\n\" +\n            \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$callWithTimeout\\$2.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:23)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$callCoroutineScope\\$2.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:29)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$$TEST_MACROS\\$1.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:36)\\n\" +\n            \"Caused by: kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest.failure(StackTraceRecoveryNestedScopesTest.kt:9)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest.access\\$failure(StackTraceRecoveryNestedScopesTest.kt:7)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$createFailingAsync\\$1.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:12)\\n\" +\n            \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\"\n\n    private fun failure(): String = throw RecoverableTestException()\n\n    private fun CoroutineScope.createFailingAsync() = async {\n        failure()\n    }\n\n    private suspend fun callWithContext(doYield: Boolean) = withContext(wrapperDispatcher(coroutineContext)) {\n        if (doYield) yield()\n        createFailingAsync().await()\n        yield()\n    }\n\n    private suspend fun callWithTimeout(doYield: Boolean) = withTimeout(Long.MAX_VALUE) {\n        if (doYield) yield()\n        callWithContext(doYield)\n        yield()\n    }\n\n    private suspend fun callCoroutineScope(doYield: Boolean) = coroutineScope {\n        if (doYield) yield()\n        callWithTimeout(doYield)\n        yield()\n    }\n\n    @Test\n    fun testNestedScopes() = runTest {\n        try {\n            callCoroutineScope(false)\n        } catch (e: Exception) {\n            verifyStackTrace(e, expectedTrace.replace(TEST_MACROS, \"testNestedScopes\"))\n        }\n    }\n\n    @Test\n    fun testNestedScopesYield() = runTest {\n        try {\n            callCoroutineScope(true)\n        } catch (e: Exception) {\n            verifyStackTrace(e, expectedTrace.replace(TEST_MACROS, \"testNestedScopesYield\"))\n        }\n    }\n\n    @Test\n    fun testAwaitNestedScopes() = runTest {\n        val deferred = async(NonCancellable) {\n            callCoroutineScope(false)\n        }\n\n        verifyAwait(deferred)\n    }\n\n    private suspend fun verifyAwait(deferred: Deferred<Unit>) {\n        try {\n            deferred.await()\n        } catch (e: Exception) {\n            verifyStackTrace(e,\n                \"kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest.failure(StackTraceRecoveryNestedScopesTest.kt:23)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest.access\\$failure(StackTraceRecoveryNestedScopesTest.kt:7)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$createFailingAsync\\$1.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:26)\\n\" +\n                    \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$callWithTimeout\\$2.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:37)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$callCoroutineScope\\$2.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:43)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$testAwaitNestedScopes\\$1\\$deferred\\$1.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:68)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest.verifyAwait(StackTraceRecoveryNestedScopesTest.kt:76)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$testAwaitNestedScopes\\$1.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:71)\\n\" +\n                \"Caused by: kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest.failure(StackTraceRecoveryNestedScopesTest.kt:23)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest.access\\$failure(StackTraceRecoveryNestedScopesTest.kt:7)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryNestedScopesTest\\$createFailingAsync\\$1.invokeSuspend(StackTraceRecoveryNestedScopesTest.kt:26)\\n\" +\n                    \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\")\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/StackTraceRecoveryNestedTest.kt",
        "content": "@file:Suppress(\"DeferredResultUnused\")\n\npackage kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass StackTraceRecoveryNestedTest : TestBase() {\n\n    @Test\n    fun testNestedAsync() = runTest {\n        val rootAsync = async(NonCancellable) {\n            expect(1)\n\n            // Just a noise for unwrapping\n            async {\n                expect(2)\n                delay(Long.MAX_VALUE)\n            }\n\n            // Do not catch, fail on cancellation\n            async {\n                expect(3)\n                async {\n                    expect(4)\n                    delay(Long.MAX_VALUE)\n                }\n\n                async {\n                    expect(5)\n                    // 1) await(), catch, verify and rethrow\n                    try {\n                        val nested = async {\n                            expect(6)\n                            throw RecoverableTestException()\n                        }\n\n                        nested.awaitNested()\n                    } catch (e: RecoverableTestException) {\n                        expect(7)\n                        e.verifyException(\n                            \"await\\$suspendImpl\",\n                            \"awaitNested\",\n                            \"\\$testNestedAsync\\$1\\$rootAsync\\$1\\$2\\$2.invokeSuspend\"\n                        )\n                        // Just rethrow it\n                        throw e\n                    }\n                }\n            }\n        }\n\n        try {\n            rootAsync.awaitRootLevel()\n        } catch (e: RecoverableTestException) {\n            e.verifyException(\"awaitRootLevel\")\n            finish(8)\n        }\n    }\n\n    private suspend fun Deferred<*>.awaitRootLevel() {\n        await()\n        assertTrue(true)\n    }\n\n    private suspend fun Deferred<*>.awaitNested() {\n        await()\n        assertTrue(true)\n    }\n\n    private fun RecoverableTestException.verifyException(vararg expectedTraceElements: String) {\n        // It is \"recovered\" only once\n        assertEquals(1, depth())\n        val stacktrace = stackTrace.map { it.methodName }.toSet()\n        assertTrue(expectedTraceElements.all { stacktrace.contains(it) })\n    }\n\n    private fun Throwable.depth(): Int {\n        val cause = cause ?: return 0\n        return 1 + cause.depth()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/StackTraceRecoveryResumeModeTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.*\nimport kotlin.coroutines.*\nimport org.junit.rules.TestName\nimport org.junit.Rule\n\nclass StackTraceRecoveryResumeModeTest : TestBase() {\n\n    @get:Rule\n    val testName = TestName()\n\n    @Test\n    fun testUnconfined() = runTest {\n        testResumeModeFastPath(Dispatchers.Unconfined)\n    }\n\n    @Test\n    fun testNestedUnconfined() = runTest {\n        withContext(Dispatchers.Unconfined) {\n            testResumeModeFastPath(Dispatchers.Unconfined)\n        }\n    }\n\n    @Test\n    fun testNestedUnconfinedChangedContext() = runTest {\n        withContext(Dispatchers.Unconfined) {\n            testResumeModeFastPath(CoroutineName(\"Test\"))\n        }\n    }\n\n    @Test\n    fun testEventLoopDispatcher() = runTest {\n        testResumeModeFastPath(wrapperDispatcher())\n    }\n\n    @Test\n    fun testNestedEventLoopDispatcher() = runTest {\n        val dispatcher = wrapperDispatcher()\n        withContext(dispatcher) {\n            testResumeModeFastPath(dispatcher)\n        }\n    }\n\n    @Test\n    fun testNestedEventLoopChangedContext() = runTest {\n        withContext(wrapperDispatcher()) {\n            testResumeModeFastPath(CoroutineName(\"Test\"))\n        }\n    }\n\n    private suspend fun testResumeModeFastPath(context: CoroutineContext) {\n        try {\n            val channel = Channel<Int>()\n            channel.close(RecoverableTestException())\n            doFastPath(context, channel)\n        } catch (e: Throwable) {\n            verifyStackTrace(\"resume-mode/${testName.methodName}\", e)\n        }\n    }\n\n    private suspend fun doFastPath(context: CoroutineContext, channel: Channel<Int>) {\n        yield()\n        withContext(context, channel)\n    }\n\n    private suspend fun withContext(context: CoroutineContext, channel: Channel<Int>) {\n        withContext(context) {\n            channel.receive()\n            yield()\n        }\n    }\n\n    @Test\n    fun testUnconfinedSuspending() = runTest {\n        testResumeModeSuspending(Dispatchers.Unconfined)\n    }\n\n    @Test\n    fun testNestedUnconfinedSuspending() = runTest {\n        withContext(Dispatchers.Unconfined) {\n            testResumeModeSuspending(Dispatchers.Unconfined)\n        }\n    }\n\n    @Test\n    fun testNestedUnconfinedChangedContextSuspending() = runTest {\n        withContext(Dispatchers.Unconfined) {\n            testResumeModeSuspending(CoroutineName(\"Test\"))\n        }\n    }\n\n    @Test\n    fun testEventLoopDispatcherSuspending() = runTest {\n        testResumeModeSuspending(wrapperDispatcher())\n    }\n\n    @Test\n    fun testNestedEventLoopDispatcherSuspending() = runTest {\n        val dispatcher = wrapperDispatcher()\n        withContext(dispatcher) {\n            testResumeModeSuspending(dispatcher)\n        }\n    }\n\n    @Test\n    fun testNestedEventLoopChangedContextSuspending() = runTest {\n        withContext(wrapperDispatcher()) {\n            testResumeModeSuspending(CoroutineName(\"Test\"))\n        }\n    }\n\n    private suspend fun testResumeModeSuspending(context: CoroutineContext) {\n        try {\n            val channel = Channel<Int>()\n            val latch = Channel<Int>()\n            GlobalScope.launch(coroutineContext) {\n                latch.receive()\n                expect(3)\n                channel.close(RecoverableTestException())\n            }\n            doSuspendingPath(context, channel, latch)\n        } catch (e: Throwable) {\n            finish(4)\n            verifyStackTrace(\"resume-mode/${testName.methodName}\", e)\n        }\n    }\n\n    private suspend fun doSuspendingPath(context: CoroutineContext, channel: Channel<Int>, latch: Channel<Int>) {\n        yield()\n        withContext(context, channel, latch)\n    }\n\n    private suspend fun withContext(context: CoroutineContext, channel: Channel<Int>, latch: Channel<Int>) {\n        withContext(context) {\n            expect(1)\n            latch.send(1)\n            expect(2)\n            channel.receive()\n            yield()\n        }\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/StackTraceRecoverySelectTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.*\nimport org.junit.rules.*\n\nclass StackTraceRecoverySelectTest : TestBase() {\n\n    @get:Rule\n    val name = TestName()\n\n    @Test\n    fun testSelectJoin() = runTest {\n        expect(1)\n        val result = runCatching { doSelect() }\n        expect(3)\n        verifyStackTrace(\"select/${name.methodName}\", result.exceptionOrNull()!!)\n        finish(4)\n    }\n\n    private suspend fun doSelect(): Int {\n        val job = CompletableDeferred(Unit)\n        return select {\n            job.onJoin {\n                yield() // Hide the stacktrace\n                expect(2)\n                throw RecoverableTestException()\n            }\n        }\n    }\n\n    @Test\n    fun testSelectCompletedAwait() = runTest {\n        val deferred = CompletableDeferred<Unit>()\n        deferred.completeExceptionally(RecoverableTestException())\n        val result = runCatching { doSelectAwait(deferred) }\n        verifyStackTrace(\"select/${name.methodName}\", result.exceptionOrNull()!!)\n    }\n\n    private suspend fun doSelectAwait(deferred: Deferred<Unit>): Int {\n        return select {\n            deferred.onAwait {\n                yield() // Hide the frame\n                42\n            }\n        }\n    }\n\n    @Test\n    fun testSelectOnReceive() = runTest {\n        val c = Channel<Unit>()\n        c.close()\n        val result = kotlin.runCatching {  doSelectOnReceive(c) }\n        verifyStackTrace(\"select/${name.methodName}\", result.exceptionOrNull()!!)\n    }\n\n    private suspend fun doSelectOnReceive(c: Channel<Unit>) {\n        // The channel is closed, should throw an exception\n        select<Unit> {\n            c.onReceive {\n                expectUnreached()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/StackTraceRecoveryTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.intrinsics.*\nimport kotlinx.coroutines.testing.exceptions.*\nimport org.junit.Test\nimport java.lang.RuntimeException\nimport java.util.concurrent.*\nimport kotlin.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n/*\n * All stacktrace validation skips line numbers\n */\nclass StackTraceRecoveryTest : TestBase() {\n\n    @Test\n    fun testAsync() = runTest {\n        fun createDeferred(depth: Int): Deferred<*> {\n            return if (depth == 0) {\n                async<Unit>(coroutineContext + NonCancellable) {\n                    throw ExecutionException(null)\n                }\n            } else {\n                createDeferred(depth - 1)\n            }\n        }\n\n        val deferred = createDeferred(3)\n        val traces = listOf(\n            \"java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testAsync\\$1\\$createDeferred\\$1.invokeSuspend(StackTraceRecoveryTest.kt:99)\\n\" +\n                    \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.oneMoreNestedMethod(StackTraceRecoveryTest.kt:49)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.nestedMethod(StackTraceRecoveryTest.kt:44)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testAsync\\$1.invokeSuspend(StackTraceRecoveryTest.kt:17)\\n\",\n            \"Caused by: java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testAsync\\$1\\$createDeferred\\$1.invokeSuspend(StackTraceRecoveryTest.kt:21)\\n\" +\n                    \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\\n\"\n        )\n        nestedMethod(deferred, *traces.toTypedArray())\n        deferred.join()\n    }\n\n    @Test\n    fun testCompletedAsync() = runTest {\n        val deferred = async<Unit>(coroutineContext + NonCancellable) {\n            throw ExecutionException(null)\n        }\n\n        deferred.join()\n        val stacktrace = listOf(\n            \"java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testCompletedAsync\\$1\\$deferred\\$1.invokeSuspend(StackTraceRecoveryTest.kt:44)\\n\" +\n                    \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.oneMoreNestedMethod(StackTraceRecoveryTest.kt:81)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.nestedMethod(StackTraceRecoveryTest.kt:75)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testCompletedAsync\\$1.invokeSuspend(StackTraceRecoveryTest.kt:71)\",\n            \"Caused by: java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testCompletedAsync\\$1\\$deferred\\$1.invokeSuspend(StackTraceRecoveryTest.kt:44)\\n\" +\n                    \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\"\n        )\n        nestedMethod(deferred, *stacktrace.toTypedArray())\n    }\n\n    private suspend fun nestedMethod(deferred: Deferred<*>, vararg traces: String) {\n        oneMoreNestedMethod(deferred, *traces)\n        assertTrue(true) // Prevent tail-call optimization\n    }\n\n    private suspend fun oneMoreNestedMethod(deferred: Deferred<*>, vararg traces: String) {\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: ExecutionException) {\n            verifyStackTrace(e, *traces)\n        }\n    }\n\n    @Test\n    fun testWithContext() = runTest {\n        val deferred = async<Unit>(NonCancellable, start = CoroutineStart.LAZY) {\n            throw RecoverableTestException()\n        }\n\n        outerMethod(deferred,\n            \"kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n                \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testWithContext\\$1\\$deferred\\$1.invokeSuspend(StackTraceRecoveryTest.kt:143)\\n\" +\n                \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.innerMethod(StackTraceRecoveryTest.kt:158)\\n\" +\n                \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$outerMethod\\$2.invokeSuspend(StackTraceRecoveryTest.kt:151)\\n\" +\n                \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.outerMethod(StackTraceRecoveryTest.kt:150)\\n\" +\n                \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testWithContext\\$1.invokeSuspend(StackTraceRecoveryTest.kt:141)\\n\",\n            \"Caused by: kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n                \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testWithContext\\$1\\$deferred\\$1.invokeSuspend(StackTraceRecoveryTest.kt:143)\\n\" +\n                \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\\n\")\n        deferred.join()\n    }\n\n    private suspend fun outerMethod(deferred: Deferred<*>, vararg traces: String) {\n        withContext(Dispatchers.IO) {\n            innerMethod(deferred, *traces)\n        }\n\n        assertTrue(true)\n    }\n\n    private suspend fun innerMethod(deferred: Deferred<*>, vararg traces: String) {\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: RecoverableTestException) {\n            verifyStackTrace(e, *traces)\n        }\n    }\n\n    @Test\n    fun testCoroutineScope() = runTest {\n        val deferred = async<Unit>(NonCancellable, start = CoroutineStart.LAZY) {\n            throw RecoverableTestException()\n        }\n\n        outerScopedMethod(deferred,\n            \"kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testCoroutineScope\\$1\\$deferred\\$1.invokeSuspend(StackTraceRecoveryTest.kt:143)\\n\" +\n                    \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.innerMethod(StackTraceRecoveryTest.kt:158)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$outerScopedMethod\\$2\\$1.invokeSuspend(StackTraceRecoveryTest.kt:193)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$outerScopedMethod\\$2.invokeSuspend(StackTraceRecoveryTest.kt:151)\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testCoroutineScope\\$1.invokeSuspend(StackTraceRecoveryTest.kt:141)\\n\",\n            \"Caused by: kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n                    \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testCoroutineScope\\$1\\$deferred\\$1.invokeSuspend(StackTraceRecoveryTest.kt:143)\\n\" +\n                    \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\\n\")\n        deferred.join()\n    }\n\n    public class TrickyException() : Throwable() {\n        // To be sure ctor is never invoked\n        @Suppress(\"UNUSED\", \"UNUSED_PARAMETER\")\n        private constructor(message: String, cause: Throwable): this() {\n            error(\"Should never be called\")\n        }\n\n        override fun initCause(cause: Throwable?): Throwable {\n            error(\"Can't call initCause\")\n        }\n    }\n\n    @Test\n    fun testThrowingInitCause() = runTest {\n        val deferred = async<Unit>(NonCancellable) {\n            expect(2)\n            throw TrickyException()\n        }\n\n        try {\n            expect(1)\n            deferred.await()\n        } catch (e: TrickyException) {\n            assertNull(e.cause)\n            finish(3)\n        }\n    }\n\n    private suspend fun outerScopedMethod(deferred: Deferred<*>, vararg traces: String) = coroutineScope {\n        supervisorScope {\n            innerMethod(deferred, *traces)\n            assertTrue(true)\n        }\n        assertTrue(true)\n    }\n\n    @Test\n    fun testSelfSuppression() = runTest {\n        try {\n            runBlocking {\n                val job = launch {\n                    coroutineScope<Unit> {\n                        throw RecoverableTestException()\n                    }\n                }\n\n                job.join()\n                expectUnreached()\n            }\n            expectUnreached()\n        } catch (e: RecoverableTestException) {\n            checkCycles(e)\n        }\n    }\n\n\n    private suspend fun throws() {\n        yield() // TCE\n        throw RecoverableTestException()\n    }\n\n    private suspend fun awaiter() {\n        val task = GlobalScope.async(Dispatchers.Default, start = CoroutineStart.LAZY) { throws() }\n        task.await()\n        yield() // TCE\n    }\n\n    @Test\n    fun testNonDispatchedRecovery() {\n        val await = suspend { awaiter() }\n\n        val barrier = CyclicBarrier(2)\n        var exception: Throwable? = null\n\n        thread {\n            await.startCoroutineUnintercepted(Continuation(EmptyCoroutineContext) {\n                exception = it.exceptionOrNull()\n                barrier.await()\n            })\n        }\n\n        barrier.await()\n        val e = exception\n        assertNotNull(e)\n        verifyStackTrace(e, \"kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.throws(StackTraceRecoveryTest.kt:280)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.access\\$throws(StackTraceRecoveryTest.kt:20)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$throws\\$1.invokeSuspend(StackTraceRecoveryTest.kt)\\n\" +\n            \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.awaiter(StackTraceRecoveryTest.kt:285)\\n\" +\n            \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testNonDispatchedRecovery\\$await\\$1.invokeSuspend(StackTraceRecoveryTest.kt:291)\\n\" +\n            \"Caused by: kotlinx.coroutines.testing.RecoverableTestException\")\n    }\n\n    private class Callback(val cont: CancellableContinuation<*>)\n\n    @Test\n    fun testCancellableContinuation() = runTest {\n        val channel = Channel<Callback>(1)\n        launch {\n            try {\n                awaitCallback(channel)\n            } catch (e: Throwable) {\n                verifyStackTrace(e, \"kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n                        \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testCancellableContinuation\\$1.invokeSuspend(StackTraceRecoveryTest.kt:329)\\n\" +\n                        \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                        \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest.awaitCallback(StackTraceRecoveryTest.kt:348)\\n\" +\n                        \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testCancellableContinuation\\$1\\$1.invokeSuspend(StackTraceRecoveryTest.kt:322)\\n\" +\n                        \"Caused by: kotlinx.coroutines.testing.RecoverableTestException\\n\" +\n                        \"\\tat kotlinx.coroutines.exceptions.StackTraceRecoveryTest\\$testCancellableContinuation\\$1.invokeSuspend(StackTraceRecoveryTest.kt:329)\")\n            }\n        }\n        val callback = channel.receive()\n        callback.cont.resumeWithException(RecoverableTestException())\n    }\n\n    private suspend fun awaitCallback(channel: Channel<Callback>) {\n        suspendCancellableCoroutine<Unit> { cont ->\n            channel.trySend(Callback(cont))\n        }\n        yield() // nop to make sure it is not a tail call\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/StackTraceRecoveryWithTimeoutTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.rules.*\n\nclass StackTraceRecoveryWithTimeoutTest : TestBase() {\n\n    @get:Rule\n    val name = TestName()\n\n    @Test\n    fun testStacktraceIsRecoveredFromSuspensionPoint() = runTest {\n        try {\n            outerWithTimeout()\n        } catch (e: TimeoutCancellationException) {\n            verifyStackTrace(\"timeout/${name.methodName}\", e)\n        }\n    }\n\n    private suspend fun outerWithTimeout() {\n        withTimeout(200) {\n            suspendForever()\n        }\n        expectUnreached()\n    }\n\n    private suspend fun suspendForever() {\n        hang {  }\n        expectUnreached()\n    }\n\n    @Test\n    fun testStacktraceIsRecoveredFromLexicalBlockWhenTriggeredByChild() = runTest {\n        try {\n            outerChildWithTimeout()\n        } catch (e: TimeoutCancellationException) {\n            verifyStackTrace(\"timeout/${name.methodName}\", e)\n        }\n    }\n\n    private suspend fun outerChildWithTimeout() {\n        withTimeout(200) {\n            launch {\n                withTimeoutInChild()\n            }\n            yield()\n        }\n        expectUnreached()\n    }\n\n    private suspend fun withTimeoutInChild() {\n        withTimeout(300) {\n            hang {  }\n        }\n        expectUnreached()\n    }\n\n    @Test\n    fun testStacktraceIsRecoveredFromSuspensionPointWithChild() = runTest {\n        try {\n            outerChild()\n        } catch (e: TimeoutCancellationException) {\n            verifyStackTrace(\"timeout/${name.methodName}\", e)\n        }\n    }\n\n    private suspend fun outerChild() {\n        withTimeout(200) {\n            launch {\n                smallWithTimeout()\n            }\n            suspendForever()\n        }\n        expectUnreached()\n    }\n\n    private suspend fun smallWithTimeout() {\n        withTimeout(100) {\n            suspendForever()\n        }\n        expectUnreached()\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/Stacktraces.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.*\nimport java.io.*\nimport kotlin.test.*\n\npublic fun verifyStackTrace(e: Throwable, vararg traces: String) {\n    val stacktrace = toStackTrace(e)\n    val normalizedActual = stacktrace.normalizeStackTrace()\n    traces.forEach {\n        val normalizedExpected = it.normalizeStackTrace()\n        if (!normalizedActual.contains(normalizedExpected)) {\n            // A more readable error message would be produced by assertEquals\n            assertEquals(normalizedExpected, normalizedActual, \"Actual trace does not contain expected one\")\n        }\n    }\n    // Check \"Caused by\" counts\n    val causes = stacktrace.count(\"Caused by\")\n    assertNotEquals(0, causes)\n    assertEquals(traces.map { it.count(\"Caused by\") }.sum(), causes)\n}\n\npublic fun verifyStackTrace(path: String, e: Throwable) {\n    val resource = Job::class.java.classLoader.getResourceAsStream(\"stacktraces/$path.txt\")\n    val lines = resource.reader().readLines()\n    verifyStackTrace(e, *lines.toTypedArray())\n}\n\npublic fun toStackTrace(t: Throwable): String {\n    val sw = StringWriter() as Writer\n    t.printStackTrace(PrintWriter(sw))\n    return sw.toString()\n}\n\npublic fun String.normalizeStackTrace(): String =\n    replace(Regex(\":[0-9]+\"), \"\") // remove line numbers\n    .replace(\"kotlinx_coroutines_core_main\", \"\") // yay source sets\n    .replace(\"kotlinx_coroutines_core\", \"\")\n    .replace(Regex(\"@[0-9a-f]+\"), \"\") // remove hex addresses in debug toStrings\n    .lines().joinToString(\"\\n\") // normalize line separators\n\npublic fun String.count(substring: String): Int = split(substring).size - 1"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/SuppressionTests.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.testing.exceptions.*\nimport java.io.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@Suppress(\"DEPRECATION\")\nclass SuppressionTests : TestBase() {\n    @Test\n    fun testNotificationsWithException() = runTest {\n        expect(1)\n        val coroutineContext = kotlin.coroutines.coroutineContext + NonCancellable // workaround for KT-22984\n        val coroutine = object : AbstractCoroutine<String>(coroutineContext, true, false) {\n            override fun onStart() {\n                expect(3)\n            }\n\n            override fun onCancelling(cause: Throwable?) {\n                assertIs<ArithmeticException>(cause)\n                assertTrue(cause.suppressed.isEmpty())\n                expect(5)\n            }\n\n            override fun onCompleted(value: String) {\n                expectUnreached()\n            }\n\n            override fun onCancelled(cause: Throwable, handled: Boolean) {\n                assertIs<ArithmeticException>(cause)\n                checkException<IOException>(cause.suppressed[0])\n                expect(8)\n            }\n        }\n\n        coroutine.invokeOnCompletion(onCancelling = true) {\n            assertIs<ArithmeticException>(it)\n            assertTrue(it.suppressed.isEmpty())\n            expect(6)\n        }\n\n        coroutine.invokeOnCompletion {\n            assertIs<ArithmeticException>(it)\n            checkException<IOException>(it.suppressed[0])\n            expect(9)\n        }\n\n        expect(2)\n        coroutine.start()\n        expect(4)\n        coroutine.cancelInternal(ArithmeticException())\n        expect(7)\n        coroutine.resumeWithException(IOException())\n        finish(10)\n    }\n\n    @Test\n    fun testExceptionUnwrapping() = runTest {\n        val channel = Channel<Int>()\n\n        val deferred = async(NonCancellable) {\n            launch {\n                while (true) channel.send(1)\n            }\n\n            launch {\n                val exception = RecoverableTestCancellationException()\n                channel.cancel(exception)\n                throw exception\n            }\n        }\n\n        try {\n            deferred.await()\n        } catch (e: RecoverableTestException) {\n            assertTrue(e.suppressed.isEmpty())\n            assertTrue(e.cause!!.suppressed.isEmpty())\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/WithContextCancellationStressTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\nimport kotlin.time.Duration.Companion.minutes\n\nclass WithContextCancellationStressTest : TestBase() {\n\n    private val timeoutAfter = 1.minutes\n    private val pool = newFixedThreadPoolContext(3, \"WithContextCancellationStressTest\")\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    @Test\n    @Suppress(\"DEPRECATION\")\n    fun testConcurrentFailure() = runBlocking {\n        var eCnt = 0\n        var e1Cnt = 0\n        var e2Cnt = 0\n\n        withTimeout(timeoutAfter) {\n            while (eCnt == 0 || e1Cnt == 0 || e2Cnt == 0) {\n                val barrier = CyclicBarrier(4)\n                val ctx = pool + NonCancellable\n                var e1 = false\n                var e2 = false\n                val jobWithContext = async(ctx) {\n                    withContext(wrapperDispatcher(coroutineContext)) {\n                        launch {\n                            barrier.await()\n                            e1 = true\n                            throw TestException1()\n                        }\n\n                        launch {\n                            barrier.await()\n                            e2 = true\n                            throw TestException2()\n                        }\n\n                        barrier.await()\n                        throw TestException()\n                    }\n                }\n\n                barrier.await()\n\n                try {\n                    jobWithContext.await()\n                } catch (e: Throwable) {\n                    when (e) {\n                        is TestException -> {\n                            eCnt++\n                            e.checkSuppressed(e1 = e1, e2 = e2)\n                        }\n                        is TestException1 -> {\n                            e1Cnt++\n                            e.checkSuppressed(ex = true, e2 = e2)\n                        }\n                        is TestException2 -> {\n                            e2Cnt++\n                            e.checkSuppressed(ex = true, e1 = e1)\n                        }\n                        else -> error(\"Unexpected exception $e\")\n                    }\n                }\n            }\n        }\n    }\n\n    private fun wrapperDispatcher(context: CoroutineContext): CoroutineContext {\n        val dispatcher = context[ContinuationInterceptor] as CoroutineDispatcher\n        return object : CoroutineDispatcher() {\n            override fun dispatch(context: CoroutineContext, block: Runnable) {\n                dispatcher.dispatch(context, block)\n            }\n        }\n    }\n\n    private fun Throwable.checkSuppressed(\n        ex: Boolean = false,\n        e1: Boolean = false,\n        e2: Boolean = false\n    ) {\n        val suppressed: Array<Throwable> = suppressed\n        if (ex) {\n            assertTrue(suppressed.any { it is TestException }, \"TestException should be present: $this\")\n        }\n        if (e1) {\n            assertTrue(suppressed.any { it is TestException1 }, \"TestException1 should be present: $this\")\n        }\n        if (e2) {\n            assertTrue(suppressed.any { it is TestException2 }, \"TestException2 should be present: $this\")\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/exceptions/WithContextExceptionHandlingTest.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass WithContextExceptionHandlingTest(private val mode: Mode) : TestBase() {\n    enum class Mode { WITH_CONTEXT, ASYNC_AWAIT }\n\n    companion object {\n        @Parameterized.Parameters(name = \"mode={0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = Mode.values().map { arrayOf<Any>(it) }\n    }\n\n    @Test\n    fun testCancellation() = runTest {\n        /*\n         * context cancelled without cause\n         * code itself throws TE2\n         * Result: TE2\n         */\n        runCancellation(null, TestException2()) { e ->\n            assertIs<TestException2>(e)\n            assertNull(e.cause)\n            val suppressed = e.suppressed\n            assertTrue(suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testCancellationWithException() = runTest {\n        /*\n         * context cancelled with TCE\n         * block itself throws TE2\n         * Result: TE (CancellationException is always ignored)\n         */\n        val cancellationCause = TestCancellationException()\n        runCancellation(cancellationCause, TestException2()) { e ->\n            assertIs<TestException2>(e)\n            assertNull(e.cause)\n            val suppressed = e.suppressed\n            assertTrue(suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testSameException() = runTest {\n        /*\n         * context cancelled with TCE\n         * block itself throws the same TCE\n         * Result: TCE\n         */\n        val cancellationCause = TestCancellationException()\n        runCancellation(cancellationCause, cancellationCause) { e ->\n            assertIs<TestCancellationException>(e)\n            assertNull(e.cause)\n            val suppressed = e.suppressed\n            assertTrue(suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testSameCancellation() = runTest {\n        /*\n         * context cancelled with TestCancellationException\n         * block itself throws the same TCE\n         * Result: TCE\n         */\n        val cancellationCause = TestCancellationException()\n        runCancellation(cancellationCause, cancellationCause) { e ->\n            assertSame(e, cancellationCause)\n            assertNull(e.cause)\n            val suppressed = e.suppressed\n            assertTrue(suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testSameCancellationWithException() = runTest {\n        /*\n         * context cancelled with CancellationException(TE)\n         * block itself throws the same TE\n         * Result: TE\n         */\n        val cancellationCause = CancellationException()\n        val exception = TestException()\n        cancellationCause.initCause(exception)\n        runCancellation(cancellationCause, exception) { e ->\n            assertSame(exception, e)\n            assertNull(e.cause)\n            assertTrue(e.suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testConflictingCancellation() = runTest {\n        /*\n         * context cancelled with TCE\n         * block itself throws CE(TE)\n         * Result: TE (because cancellation exception is always ignored and not handled)\n         */\n        val cancellationCause = TestCancellationException()\n        val thrown = CancellationException()\n        thrown.initCause(TestException())\n        runCancellation(cancellationCause, thrown) { e ->\n            assertSame(cancellationCause, e)\n            assertTrue(e.suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testConflictingCancellation2() = runTest {\n        /*\n         * context cancelled with TE\n         * block itself throws CE\n         * Result: TE\n         */\n        val cancellationCause = TestCancellationException()\n        val thrown = CancellationException()\n        runCancellation(cancellationCause, thrown) { e ->\n            assertSame(cancellationCause, e)\n            val suppressed = e.suppressed\n            assertTrue(suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testConflictingCancellation3() = runTest {\n        /*\n         * context cancelled with TCE\n         * block itself throws TCE\n         * Result: TCE\n         */\n        val cancellationCause = TestCancellationException()\n        val thrown = TestCancellationException()\n        runCancellation(cancellationCause, thrown) { e ->\n            assertSame(cancellationCause, e)\n            assertNull(e.cause)\n            assertTrue(e.suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testThrowingCancellation() = runTest {\n        val thrown = TestCancellationException()\n        runThrowing(thrown) { e ->\n            assertSame(thrown, e)\n        }\n    }\n\n    @Test\n    fun testThrowingCancellationWithCause() = runTest {\n        // Exception are never unwrapped, so if CE(TE) is thrown then it is the cancellation cause\n        val thrown = TestCancellationException()\n        thrown.initCause(TestException())\n        runThrowing(thrown) { e ->\n           assertSame(thrown, e)\n        }\n    }\n\n    @Test\n    fun testCancel() = runTest {\n        runOnlyCancellation(null) { e ->\n            val cause = e.cause as JobCancellationException // shall be recovered JCE\n            assertNull(cause.cause)\n            assertTrue(e.suppressed.isEmpty())\n            assertTrue(cause.suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testCancelWithCause() = runTest {\n        val cause = TestCancellationException()\n        runOnlyCancellation(cause) { e ->\n            assertSame(cause, e)\n            assertTrue(e.suppressed.isEmpty())\n        }\n    }\n\n    @Test\n    fun testCancelWithCancellationException() = runTest {\n        val cause = TestCancellationException()\n        runThrowing(cause) { e ->\n            assertSame(cause, e)\n            assertNull(e.cause)\n            assertTrue(e.suppressed.isEmpty())\n        }\n    }\n\n    private fun wrapperDispatcher(context: CoroutineContext): CoroutineContext {\n        val dispatcher = context[ContinuationInterceptor] as CoroutineDispatcher\n        return object : CoroutineDispatcher() {\n            override fun dispatch(context: CoroutineContext, block: Runnable) {\n                dispatcher.dispatch(context, block)\n            }\n        }\n    }\n\n    private suspend fun runCancellation(\n        cancellationCause: CancellationException?,\n        thrownException: Throwable,\n        exceptionChecker: (Throwable) -> Unit\n    ) {\n        expect(1)\n\n        try {\n            withCtx(wrapperDispatcher(coroutineContext)) { job ->\n                require(isActive) // not cancelled yet\n                job.cancel(cancellationCause)\n                require(!isActive) // now cancelled\n                expect(2)\n                throw thrownException\n            }\n        } catch (e: Throwable) {\n            exceptionChecker(e)\n            finish(3)\n            return\n        }\n        fail()\n    }\n\n    private suspend fun runThrowing(\n        thrownException: Throwable,\n        exceptionChecker: (Throwable) -> Unit\n    ) {\n        expect(1)\n        try {\n            withCtx(wrapperDispatcher(coroutineContext).minusKey(Job)) {\n                require(isActive)\n                expect(2)\n                throw thrownException\n            }\n        } catch (e: Throwable) {\n            exceptionChecker(e)\n            finish(3)\n            return\n        }\n        fail()\n    }\n\n    private suspend fun withCtx(context: CoroutineContext, job: Job = Job(), block: suspend CoroutineScope.(Job) -> Nothing) {\n        when (mode) {\n            Mode.WITH_CONTEXT -> withContext(context + job) {\n                block(job)\n            }\n            Mode.ASYNC_AWAIT -> CoroutineScope(coroutineContext).async(context + job) {\n                block(job)\n            }.await()\n        }\n    }\n\n    private suspend fun runOnlyCancellation(\n        cancellationCause: CancellationException?,\n        exceptionChecker: (Throwable) -> Unit\n    ) {\n        expect(1)\n        val job = Job()\n        try {\n            withContext(wrapperDispatcher(coroutineContext) + job) {\n                require(isActive) // still active\n                job.cancel(cancellationCause)\n                require(!isActive) // is already cancelled\n                expect(2)\n            }\n        } catch (e: Throwable) {\n            exceptionChecker(e)\n            finish(3)\n            return\n        }\n        fail()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/CallbackFlowTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.testing.flow.*\nimport org.junit.Test\nimport kotlin.concurrent.*\nimport kotlin.test.*\n\nclass CallbackFlowTest : TestBase() {\n\n    private class CallbackApi(val block: (SendChannel<Int>) -> Unit) {\n        var started = false\n        @Volatile\n        var stopped = false\n        lateinit var thread: Thread\n\n        fun start(sink: SendChannel<Int>) {\n            started = true\n            thread = thread {\n                while (!stopped) {\n                    block(sink)\n                }\n            }\n        }\n\n        fun stop() {\n            stopped = true\n        }\n    }\n\n    @Test(timeout = 5_000L)\n    fun testThrowingConsumer() = runTest {\n        var i = 0\n        val api = CallbackApi {\n            it.trySend(++i)\n        }\n\n        val flow = callbackFlow<Int> {\n            api.start(channel)\n            awaitClose {\n                api.stop()\n            }\n        }\n\n        var receivedConsensus = 0\n        var isDone = false\n        var exception: Throwable? = null\n        val job = flow\n            .filter { it > 10 }\n            .launchIn(this) {\n                onEach {\n                    if (it == 11) {\n                        ++receivedConsensus\n                    } else {\n                        receivedConsensus = 42\n                    }\n                    throw RuntimeException()\n                }\n                catch<Throwable> { exception = it }\n                finally { isDone = true }\n            }\n        job.join()\n        assertEquals(1, receivedConsensus)\n        assertTrue(isDone)\n        assertTrue { exception is RuntimeException }\n        api.thread.join()\n        assertTrue(api.started)\n        assertTrue(api.stopped)\n    }\n\n    @Test(timeout = 5_000L)\n    fun testThrowingSource() = runBlocking {\n        var i = 0\n        val api = CallbackApi {\n            if (i < 5) {\n                it.trySend(++i)\n            } else {\n                it.close(RuntimeException())\n            }\n        }\n\n        val flow = callbackFlow<Int> {\n            api.start(channel)\n            awaitClose {\n                api.stop()\n            }\n        }\n\n        var received = 0\n        var isDone = false\n        var exception: Throwable? = null\n        val job = flow.launchIn(this) {\n            onEach { ++received }\n            catch<Throwable> { exception = it }\n            finally { isDone = true }\n        }\n\n        job.join()\n        assertTrue(isDone)\n        assertTrue { exception is RuntimeException }\n        api.thread.join()\n        assertTrue(api.started)\n        assertTrue(api.stopped)\n    }\n\n\n    @Test\n    fun testMergeExample() = runTest {\n        // Too slow on JS\n        withContext(Dispatchers.Default) {\n            val f1 = (1..10_000).asFlow()\n            val f2 = (10_001..20_000).asFlow()\n            assertEquals((1..20_000).toSet(), f1.merge(f2).toSet())\n        }\n    }\n\n    private fun Flow<Int>.merge(other: Flow<Int>): Flow<Int> = channelFlow {\n        launch {\n            collect { send(it) }\n        }\n        other.collect { send(it) }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/ExceptionTransparencyTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass ExceptionTransparencyTest : TestBase() {\n\n    @Test\n    fun testViolation() = runTest {\n        val flow = flow {\n            try {\n                expect(1)\n                emit(1)\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(3)\n                emit(2)\n            }\n        }.take(1)\n\n        assertFailsWith<IllegalStateException> { flow.collect { expect(2) } }\n        finish(4)\n    }\n\n    @Test\n    fun testViolationResumeWith() = runTest {\n        val flow = flow {\n            try {\n                expect(1)\n                emit(1)\n                yield()\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(3)\n                emit(2)\n            }\n        }.take(1)\n\n        assertFailsWith<IllegalStateException> {\n            flow.collect {\n                yield()\n                expect(2)\n            }\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testViolationAfterInvariantVariation() = runTest {\n        val flow = flow<Int> {\n            coroutineScope {\n                try {\n                    expect(1)\n                    launch {\n                        expect(2)\n                        emit(1)\n                    }.join()\n                    expectUnreached()\n                } catch (e: Throwable) {\n                    try {\n                        emit(2)\n                    } catch (e: IllegalStateException) {\n                        assertTrue { e.message!!.contains(\"exception transparency\") }\n                        emit(3)\n                    }\n                }\n            }\n        }\n        val e = assertFailsWith<IllegalStateException> { flow.collect { expectUnreached() } }\n        assertTrue { e.message!!.contains(\"channelFlow\") }\n        finish(3)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/FirstJvmTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass FirstJvmTest : TestBase() {\n\n    @Test\n    fun testTakeInterference() = runBlocking(Dispatchers.Default) {\n        /*\n         * This test tests a racy situation when outer channelFlow is being cancelled,\n         * inner flow starts atomically in \"CANCELLING\" state, sends one element and completes\n         * (=> cancels and drops element away), triggering NSEE in Flow.first operator\n         */\n        val values = (0..10000).asFlow().flatMapMerge(Int.MAX_VALUE) {\n            channelFlow {\n                val value = channelFlow { send(1) }.first()\n                send(value)\n            }\n        }.take(1).toList()\n        assertEquals(listOf(1), values)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/FlatMapStressTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlinx.coroutines.scheduling.*\nimport org.junit.Assume.*\nimport org.junit.Test\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\nclass FlatMapStressTest : TestBase() {\n\n    private val iterations = 2000 * stressTestMultiplier\n    private val expectedSum = iterations.toLong() * (iterations + 1) / 2\n\n    @Test\n    fun testConcurrencyLevel() = runTest {\n        withContext(Dispatchers.Default) {\n            testConcurrencyLevel(2)\n        }\n    }\n\n    @Test\n    fun testConcurrencyLevel2() = runTest {\n        withContext(Dispatchers.Default) {\n            testConcurrencyLevel(3)\n        }\n    }\n\n    @Test\n    fun testBufferSize() = runTest {\n        val bufferSize = 5\n        withContext(Dispatchers.Default) {\n            val inFlightElements = AtomicLong(0L)\n            var result = 0L\n            (1..iterations step 4).asFlow().flatMapMerge { value ->\n                unsafeFlow {\n                    repeat(4) {\n                        emit(value + it)\n                        inFlightElements.incrementAndGet()\n                    }\n                }\n            }.buffer(bufferSize).collect { value ->\n                val inFlight = inFlightElements.get()\n                assertTrue(inFlight <= bufferSize + 1,\n                    \"Expected less in flight elements than ${bufferSize + 1}, but had $inFlight\")\n                inFlightElements.decrementAndGet()\n                result += value\n            }\n\n            assertEquals(0, inFlightElements.get())\n            assertEquals(expectedSum, result)\n        }\n    }\n\n    @Test\n    fun testDelivery() = runTest {\n        withContext(Dispatchers.Default) {\n            val result = (1L..iterations step 4).asFlow().flatMapMerge { value ->\n                unsafeFlow {\n                    repeat(4) { emit(value + it) }\n                }\n            }.longSum()\n            assertEquals(expectedSum, result)\n        }\n    }\n\n    @Test\n    fun testIndependentShortBursts() = runTest {\n        withContext(Dispatchers.Default) {\n            repeat(iterations) {\n                val result = (1L..4L).asFlow().flatMapMerge { value ->\n                    unsafeFlow {\n                        emit(value)\n                        emit(value)\n                    }\n                }.longSum()\n                assertEquals(20, result)\n            }\n        }\n    }\n\n    private suspend fun testConcurrencyLevel(maxConcurrency: Int) {\n        assumeTrue(maxConcurrency <= CORE_POOL_SIZE)\n        val concurrency = AtomicLong()\n        val result = (1L..iterations).asFlow().flatMapMerge(concurrency = maxConcurrency) { value ->\n            unsafeFlow {\n                val current = concurrency.incrementAndGet()\n                assertTrue(current in 1..maxConcurrency)\n                emit(value)\n                concurrency.decrementAndGet()\n            }\n        }.longSum()\n\n        assertEquals(0, concurrency.get())\n        assertEquals(expectedSum, result)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/OnCompletionInterceptedReleaseTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass OnCompletionInterceptedReleaseTest : TestBase() {\n    @Test\n    fun testLeak() = runTest {\n        expect(1)\n        var cont: Continuation<Unit>? = null\n        val interceptor = CountingInterceptor()\n        val job = launch(interceptor, start = CoroutineStart.UNDISPATCHED) {\n            emptyFlow<Int>()\n                .onCompletion { emit(1) }\n                .collect { value ->\n                    expect(2)\n                    assertEquals(1, value)\n                    suspendCoroutine { cont = it }\n                }\n        }\n        cont!!.resume(Unit)\n        assertTrue(job.isCompleted)\n        assertEquals(interceptor.intercepted, interceptor.released)\n        finish(3)\n    }\n\n    class CountingInterceptor : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n        var intercepted = 0\n        var released = 0\n        override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> {\n            intercepted++\n            return Continuation(continuation.context) { continuation.resumeWith(it) }\n        }\n\n        override fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n            released++\n        }\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/SafeCollectorMemoryLeakTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\n\nclass SafeCollectorMemoryLeakTest : TestBase() {\n    // custom List.forEach impl to avoid using iterator (FieldWalker cannot scan it)\n    private inline fun <T> List<T>.listForEach(action: (T) -> Unit) {\n        for (i in indices) action(get(i))\n    }\n\n    @Test\n    fun testCompletionIsProperlyCleanedUp() = runBlocking {\n        val job = flow {\n            emit(listOf(239))\n            expect(2)\n            hang {}\n        }.transform { l -> l.listForEach { _ -> emit(42) } }\n            .onEach { expect(1) }\n            .launchIn(this)\n        yield()\n        expect(3)\n        FieldWalker.assertReachableCount(0, job) { it == 239 }\n        job.cancelAndJoin()\n        finish(4)\n    }\n\n    @Test\n    fun testCompletionIsNotCleanedUp() = runBlocking {\n        val job = flow {\n            emit(listOf(239))\n            hang {}\n        }.transform { l -> l.listForEach { _ -> emit(42) } }\n            .onEach {\n                expect(1)\n                hang { finish(3) }\n            }\n            .launchIn(this)\n        yield()\n        expect(2)\n        FieldWalker.assertReachableCount(1, job) { it == 239 }\n        job.cancelAndJoin()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/SharedFlowStressTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.collections.ArrayList\nimport kotlin.test.*\nimport kotlin.time.Duration.Companion.seconds\n\nclass SharedFlowStressTest : TestBase() {\n    private val nProducers = 5\n    private val nConsumers = 3\n    private val nSeconds = 3 * stressTestMultiplier\n\n    private lateinit var sf: MutableSharedFlow<Long>\n    private lateinit var view: SharedFlow<Long>\n\n    @get:Rule\n    val producerDispatcher = ExecutorRule(nProducers)\n    @get:Rule\n    val consumerDispatcher = ExecutorRule(nConsumers)\n\n    private val totalProduced = atomic(0L)\n    private val totalConsumed = atomic(0L)\n\n    @Test\n    fun testStressReplay1() =\n        testStress(1, 0)\n\n    @Test\n    fun testStressReplay1ExtraBuffer1() =\n        testStress(1, 1)\n\n    @Test\n    fun testStressReplay2ExtraBuffer1() =\n        testStress(2, 1)\n\n    private fun testStress(replay: Int, extraBufferCapacity: Int) = runTest {\n        sf = MutableSharedFlow(replay, extraBufferCapacity)\n        view = sf.asSharedFlow()\n        val jobs = ArrayList<Job>()\n        jobs += List(nProducers) { producerIndex ->\n            launch(producerDispatcher) {\n                var cur = producerIndex.toLong()\n                while (isActive) {\n                    sf.emit(cur)\n                    totalProduced.incrementAndGet()\n                    cur += nProducers\n                }\n            }\n        }\n        jobs += List(nConsumers) { consumerIndex ->\n            launch(consumerDispatcher) {\n                while (isActive) {\n                    view\n                        .dropWhile { it % nConsumers != consumerIndex.toLong() }\n                        .take(1)\n                        .collect {\n                            check(it % nConsumers == consumerIndex.toLong())\n                            totalConsumed.incrementAndGet()\n                        }\n                }\n            }\n        }\n        var lastProduced = 0L\n        var lastConsumed = 0L\n        for (sec in 1..nSeconds) {\n            delay(1.seconds)\n            val produced = totalProduced.value\n            val consumed = totalConsumed.value\n            println(\"$sec sec: produced = $produced; consumed = $consumed\")\n            assertNotEquals(lastProduced, produced)\n            assertNotEquals(lastConsumed, consumed)\n            lastProduced = produced\n            lastConsumed = consumed\n        }\n        jobs.forEach { it.cancel() }\n        jobs.forEach { it.join() }\n        println(\"total: produced = ${totalProduced.value}; consumed = ${totalConsumed.value}\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/SharingReferenceTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport org.junit.*\n\n/**\n * Tests that shared flows keep strong reference to their source flows.\n * See https://github.com/Kotlin/kotlinx.coroutines/issues/2557\n */\nclass SharingReferenceTest : TestBase() {\n    private val token = object {}\n\n    /*\n     * Single-threaded executor that we are using to ensure that the flow being sharing actually\n     * suspended (spilled its locals, attached to parent), so we can verify reachability.\n     * Without that, it's possible to have a situation where target flow is still\n     * being strongly referenced (by its dispatcher), but the test already tries to test reachability and fails.\n     */\n    @get:Rule\n    val executor = ExecutorRule(1)\n\n    private val weakEmitter = flow {\n        emit(null)\n        // suspend forever without keeping a strong reference to continuation -- this is a model of\n        // a callback API that does not keep a strong reference it is listeners, but works\n        suspendCancellableCoroutine<Unit> {  }\n        // using the token here to make it easily traceable\n        emit(token)\n    }\n\n    @Test\n    fun testShareInReference() {\n        val flow = weakEmitter.shareIn(ContextScope(executor), SharingStarted.Eagerly, 0)\n        linearize()\n        FieldWalker.assertReachableCount(1, flow) { it === token }\n    }\n\n    @Test\n    fun testStateInReference() {\n        val flow = weakEmitter.stateIn(ContextScope(executor), SharingStarted.Eagerly, null)\n        linearize()\n        FieldWalker.assertReachableCount(1, flow) { it === token }\n    }\n\n    @Test\n    fun testStateInSuspendingReference() = runTest {\n        val flow = weakEmitter.stateIn(ContextScope(executor))\n        linearize()\n        FieldWalker.assertReachableCount(1, flow) { it === token }\n    }\n\n    private fun linearize() {\n        runBlocking(executor) {  }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/SharingStressTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.*\nimport java.util.concurrent.atomic.*\nimport kotlin.random.*\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.TimeSource\n\nclass SharingStressTest : TestBase() {\n    private val testDuration = 1000L * stressTestMultiplier\n    private val nSubscribers = 5\n    private val testStarted = TimeSource.Monotonic.markNow()\n\n    @get:Rule\n    val emitterDispatcher = ExecutorRule(1)\n    \n    @get:Rule\n    val subscriberDispatcher = ExecutorRule(nSubscribers)\n\n    @Test\n    public fun testNoReplayLazy() =\n        testStress(0, started = SharingStarted.Lazily)\n\n    @Test\n    public fun testNoReplayWhileSubscribed() =\n        testStress(0, started = SharingStarted.WhileSubscribed())\n\n    @Test\n    public fun testNoReplayWhileSubscribedTimeout() =\n        testStress(0, started = SharingStarted.WhileSubscribed(stopTimeoutMillis = 50L))\n\n    @Test\n    public fun testReplay100WhileSubscribed() =\n        testStress(100, started = SharingStarted.WhileSubscribed())\n\n    @Test\n    public fun testReplay100WhileSubscribedReset() =                             \n        testStress(100, started = SharingStarted.WhileSubscribed(replayExpirationMillis = 0L))\n\n    @Test\n    public fun testReplay100WhileSubscribedTimeout() =\n        testStress(100, started = SharingStarted.WhileSubscribed(stopTimeoutMillis = 50L))\n\n    @Test\n    public fun testStateLazy() =\n        testStress(1, started = SharingStarted.Lazily)\n\n    @Test\n    public fun testStateWhileSubscribed() =\n        testStress(1, started = SharingStarted.WhileSubscribed())\n\n    @Test\n    public fun testStateWhileSubscribedReset() =\n        testStress(1, started = SharingStarted.WhileSubscribed(replayExpirationMillis = 0L))\n\n    private fun testStress(replay: Int, started: SharingStarted) = runTest {\n        log(\"-- Stress with replay=$replay, started=$started\")\n        val random = Random(1)\n        val emitIndex = AtomicLong()\n        val cancelledEmits = HashSet<Long>()\n        val missingCollects = Collections.synchronizedSet(LinkedHashSet<Long>())\n        // at most one copy of upstream can be running at any time\n        val isRunning = AtomicInteger(0)\n        val upstream = flow {\n            assertEquals(0, isRunning.getAndIncrement())\n            try {\n                while (true) {\n                    val value = emitIndex.getAndIncrement()\n                    try {\n                        emit(value)\n                    } catch (e: CancellationException) {\n                        // emission was cancelled -> could be missing\n                        cancelledEmits.add(value)\n                        throw e\n                    }\n                }\n            } finally {\n                assertEquals(1, isRunning.getAndDecrement())\n            }\n        }\n        val subCount = MutableStateFlow(0)\n        val sharingJob = Job()\n        val sharingScope = this + emitterDispatcher + sharingJob\n        val usingStateFlow = replay == 1\n        val sharedFlow = if (usingStateFlow)\n            upstream.stateIn(sharingScope, started, 0L)\n        else\n            upstream.shareIn(sharingScope, started, replay)\n        try {\n            val subscribers = ArrayList<SubJob>()\n            withTimeoutOrNull(testDuration) {\n                // start and stop subscribers\n                while (true) {\n                    log(\"Staring $nSubscribers subscribers\")\n                    repeat(nSubscribers) {\n                        subscribers += launchSubscriber(sharedFlow, usingStateFlow, subCount, missingCollects)\n                    }\n                    // wait until they all subscribed\n                    subCount.first { it == nSubscribers }\n                    // let them work a bit more & make sure emitter did not hang\n                    val fromEmitIndex = emitIndex.get()\n                    val waitEmitIndex = fromEmitIndex + 100 // wait until 100 emitted\n                    withTimeout(10000) { // wait for at most 10s for something to be emitted\n                        do {\n                            delay(random.nextLong(50L..100L))\n                        } while (emitIndex.get() < waitEmitIndex)  // Ok, enough was emitted, wait more if not\n                    }\n                    // Stop all subscribers and ensure they collected something\n                    log(\"Stopping subscribers (emitted = ${emitIndex.get() - fromEmitIndex})\")\n                    subscribers.forEach {\n                        it.job.cancelAndJoin()\n                        assertTrue { it.count > 0 } // something must be collected too\n                    }\n                    subscribers.clear()\n                    log(\"Intermission\")\n                    delay(random.nextLong(10L..100L)) // wait a bit before starting them again\n                }\n            }\n            if (!subscribers.isEmpty()) {\n                log(\"Stopping subscribers\")\n                subscribers.forEach { it.job.cancelAndJoin() }\n            }\n        } finally {\n            log(\"--- Finally: Cancelling sharing job\")\n            sharingJob.cancel()\n        }\n        sharingJob.join() // make sure sharing job did not hang\n        log(\"Emitter was cancelled ${cancelledEmits.size} times\")\n        log(\"Collectors missed ${missingCollects.size} values\")\n        for (value in missingCollects) {\n            assertTrue(value in cancelledEmits, \"Value $value is missing for no apparent reason\")\n        }\n    }\n\n    private fun CoroutineScope.launchSubscriber(\n        sharedFlow: SharedFlow<Long>,\n        usingStateFlow: Boolean,\n        subCount: MutableStateFlow<Int>,\n        missingCollects: MutableSet<Long>\n    ): SubJob {\n        val subJob = SubJob()\n        subJob.job = launch(subscriberDispatcher) {\n            var last = -1L\n            sharedFlow\n                .onSubscription {\n                    subCount.increment(1)\n                }\n                .onCompletion {\n                    subCount.increment(-1)\n                }\n                .collect { j ->\n                    subJob.count++\n                    // last must grow sequentially, no jumping or losses\n                    if (last == -1L) {\n                        last = j\n                    } else {\n                        val expected = last + 1\n                        if (usingStateFlow)\n                            assertTrue(expected <= j)\n                        else {\n                            if (expected != j) {\n                                if (j == expected + 1) {\n                                    // if missing just one -- could be race with cancelled emit\n                                    missingCollects.add(expected)\n                                } else {\n                                    // broken otherwise\n                                    assertEquals(expected, j)\n                                }\n                            }\n                        }\n                        last = j\n                    }\n                }\n        }\n        return subJob\n    }\n\n    private class SubJob {\n        lateinit var job: Job\n        var count = 0L\n    }\n\n    private fun log(msg: String) = println(\"${testStarted.elapsedNow().inWholeMilliseconds} ms: $msg\")\n\n    private fun MutableStateFlow<Int>.increment(delta: Int) {\n        update { it + delta }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/StateFlowCancellabilityTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\n@Suppress(\"BlockingMethodInNonBlockingContext\")\nclass StateFlowCancellabilityTest : TestBase() {\n    @Test\n    fun testCancellabilityNoConflation() = runTest {\n        expect(1)\n        val state = MutableStateFlow(0)\n        var subscribed = true\n        var lastReceived = -1\n        val barrier = CyclicBarrier(2)\n        val job = state\n            .onSubscription {\n                subscribed = true\n                barrier.await()\n            }\n            .onEach { i ->\n                when (i) {\n                    0 -> expect(2) // initial value\n                    1 -> expect(3)\n                    2 -> {\n                        expect(4)\n                        currentCoroutineContext().cancel()\n                    }\n                    else -> expectUnreached() // shall check for cancellation\n                }\n                lastReceived = i\n                barrier.await()\n                barrier.await()\n            }\n            .launchIn(this + Dispatchers.Default)\n        barrier.await()\n        assertTrue(subscribed) // should have subscribed in the first barrier\n        barrier.await()\n        assertEquals(0, lastReceived) // should get initial value, too\n        for (i in 1..3) { // emit after subscription\n            state.value = i\n            barrier.await() // let it go\n            if (i < 3) {\n                barrier.await() // wait for receive\n                assertEquals(i, lastReceived) // shall receive it\n            }\n        }\n        job.join()\n        finish(5)\n    }\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/StateFlowStressTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport kotlin.random.*\n\nclass StateFlowStressTest : TestBase() {\n    private val nSeconds = 3 * stressTestMultiplier\n    private val state = MutableStateFlow<Long>(0)\n    private lateinit var pool: ExecutorCoroutineDispatcher\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    fun stress(nEmitters: Int, nCollectors: Int) = runTest {\n        pool = newFixedThreadPoolContext(nEmitters + nCollectors, \"StateFlowStressTest\")\n        val collected = Array(nCollectors) { LongArray(nEmitters) }\n        val collectors = launch {\n            repeat(nCollectors) { collector ->\n                launch(pool) {\n                    val c = collected[collector]\n                    // collect, but abort and collect again after every 1000 values to stress allocation/deallocation\n                    do {\n                        val batchSize = Random.nextInt(1..1000)\n                        var index = 0\n                        val cnt = state.onEach { value ->\n                            val emitter = (value % nEmitters).toInt()\n                            val current = value / nEmitters\n                            // the first value in batch is allowed to repeat, but cannot go back\n                            val ok = if (index++ == 0) current >= c[emitter] else current > c[emitter]\n                            check(ok) {\n                                \"Values must be monotonic, but $current is not, \" +\n                                    \"was ${c[emitter]} in collector #$collector from emitter #$emitter\"\n                            }\n                            c[emitter] = current\n\n                        }.take(batchSize).map { 1 }.sum()\n                    } while (cnt == batchSize)\n                }\n            }\n        }\n        val emitted = LongArray(nEmitters)\n        val emitters = launch {\n            repeat(nEmitters) { emitter ->\n                launch(pool) {\n                    var current = 1L\n                    while (true) {\n                        state.value = current * nEmitters + emitter\n                        emitted[emitter] = current\n                        current++\n                        if (current % 1000 == 0L) yield() // make it cancellable\n                    }\n                }\n            }\n        }\n        for (second in 1..nSeconds) {\n            delay(1000)\n            val cs = collected.map { it.sum() }\n            println(\"$second: emitted=${emitted.sum()}, collected=${cs.minOrNull()}..${cs.maxOrNull()}\")\n        }\n        emitters.cancelAndJoin()\n        collectors.cancelAndJoin()\n        // make sure nothing hanged up\n        require(collected.all { c ->\n            c.withIndex().all { (emitter, current) -> current > emitted[emitter] / 2 }\n        })\n    }\n\n    @Test\n    fun testSingleEmitterAndCollector() = stress(1, 1)\n\n    @Test\n    fun testTenEmittersAndCollectors() = stress(10, 10)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/flow/StateFlowUpdateStressTest.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport kotlin.test.*\nimport kotlin.test.Test\n\nclass StateFlowUpdateStressTest : TestBase() {\n    private val iterations = 1_000_000 * stressTestMultiplier\n\n    @get:Rule\n    public val executor = ExecutorRule(2)\n\n    @Test\n    fun testUpdate() = doTest { update { it + 1 } }\n\n    @Test\n    fun testUpdateAndGet() = doTest { updateAndGet { it + 1 } }\n\n    @Test\n    fun testGetAndUpdate() = doTest { getAndUpdate { it + 1 } }\n\n    private fun doTest(increment: MutableStateFlow<Int>.() -> Unit) = runTest {\n        val flow = MutableStateFlow(0)\n        val j1 = launch(Dispatchers.Default) {\n            repeat(iterations / 2) {\n                flow.increment()\n            }\n        }\n\n        val j2 = launch(Dispatchers.Default) {\n            repeat(iterations / 2) {\n                flow.increment()\n            }\n        }\n\n        joinAll(j1, j2)\n        assertEquals(iterations, flow.value)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-basic-01.kt",
        "content": "// This file was automatically generated from coroutines-basics.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleBasic01\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { // launch a new coroutine and continue\n        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)\n        println(\"World!\") // print after delay\n    }\n    println(\"Hello\") // main coroutine continues while a previous one is delayed\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-basic-02.kt",
        "content": "// This file was automatically generated from coroutines-basics.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleBasic02\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { doWorld() }\n    println(\"Hello\")\n}\n\n// this is your first suspending function\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"World!\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-basic-03.kt",
        "content": "// This file was automatically generated from coroutines-basics.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleBasic03\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    doWorld()\n}\n\nsuspend fun doWorld() = coroutineScope {  // this: CoroutineScope\n    launch {\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-basic-04.kt",
        "content": "// This file was automatically generated from coroutines-basics.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleBasic04\n\nimport kotlinx.coroutines.*\n\n// Sequentially executes doWorld followed by \"Done\"\nfun main() = runBlocking {\n    doWorld()\n    println(\"Done\")\n}\n\n// Concurrently executes both sections\nsuspend fun doWorld() = coroutineScope { // this: CoroutineScope\n    launch {\n        delay(2000L)\n        println(\"World 2\")\n    }\n    launch {\n        delay(1000L)\n        println(\"World 1\")\n    }\n    println(\"Hello\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-basic-05.kt",
        "content": "// This file was automatically generated from coroutines-basics.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleBasic05\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val job = launch { // launch a new coroutine and keep a reference to its Job\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello\")\n    job.join() // wait until child coroutine completes\n    println(\"Done\") \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-basic-06.kt",
        "content": "// This file was automatically generated from coroutines-basics.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleBasic06\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    repeat(50_000) { // launch a lot of coroutines\n        launch {\n            delay(5000L)\n            print(\".\")\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-01.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel01\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val job = launch {\n        repeat(1000) { i ->\n            println(\"job: I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancel() // cancels the job\n    job.join() // waits for job's completion \n    println(\"main: Now I can quit.\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-02.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel02\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val startTime = currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (i < 5) { // computation loop, just wastes CPU\n            // print a message twice a second\n            if (currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-03.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel03\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val job = launch(Dispatchers.Default) {\n        repeat(5) { i ->\n            try {\n                // print a message twice a second\n                println(\"job: I'm sleeping $i ...\")\n                delay(500)\n            } catch (e: Exception) {\n                // log the exception\n                println(e)\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-04.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel04\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val startTime = currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (isActive) { // cancellable computation loop\n            // print a message twice a second\n            if (currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-05.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel05\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            println(\"job: I'm running finally\")\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-06.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel06\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            withContext(NonCancellable) {\n                println(\"job: I'm running finally\")\n                delay(1000L)\n                println(\"job: And I've just delayed for 1 sec because I'm non-cancellable\")\n            }\n        }\n    }\n    delay(1300L) // delay a bit\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // cancels the job and waits for its completion\n    println(\"main: Now I can quit.\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-07.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel07\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    withTimeout(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-08.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel08\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val result = withTimeoutOrNull(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n        \"Done\" // will get cancelled before it produces this result\n    }\n    println(\"Result is $result\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-09.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel09\n\nimport kotlinx.coroutines.*\n\nvar acquired = 0\n\nclass Resource {\n    init { acquired++ } // Acquire the resource\n    fun close() { acquired-- } // Release the resource\n}\n\nfun main() {\n    runBlocking {\n        repeat(10_000) { // Launch 10K coroutines\n            launch { \n                val resource = withTimeout(60) { // Timeout of 60 ms\n                    delay(50) // Delay for 50 ms\n                    Resource() // Acquire a resource and return it from withTimeout block     \n                }\n                resource.close() // Release the resource\n            }\n        }\n    }\n    // Outside of runBlocking all coroutines have completed\n    println(acquired) // Print the number of resources still acquired\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-cancel-10.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCancel10\n\nimport kotlinx.coroutines.*\n\nvar acquired = 0\n\nclass Resource {\n    init { acquired++ } // Acquire the resource\n    fun close() { acquired-- } // Release the resource\n}\n\nfun main() {\n    runBlocking {\n        repeat(10_000) { // Launch 10K coroutines\n            launch { \n                var resource: Resource? = null // Not acquired yet\n                try {\n                    withTimeout(60) { // Timeout of 60 ms\n                        delay(50) // Delay for 50 ms\n                        resource = Resource() // Store a resource to the variable if acquired      \n                    }\n                    // We can do something else with the resource here\n                } finally {  \n                    resource?.close() // Release the resource if it was acquired\n                }\n            }\n        }\n    }\n    // Outside of runBlocking all coroutines have completed\n    println(acquired) // Print the number of resources still acquired\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-01.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel01\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n    val channel = Channel<Int>()\n    launch {\n        // this might be heavy CPU-consuming computation or async logic, \n        // we'll just send five squares\n        for (x in 1..5) channel.send(x * x)\n    }\n    // here we print five received integers:\n    repeat(5) { println(channel.receive()) }\n    println(\"Done!\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-02.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel02\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n    val channel = Channel<Int>()\n    launch {\n        for (x in 1..5) channel.send(x * x)\n        channel.close() // we're done sending\n    }\n    // here we print received values using `for` loop (until the channel is closed)\n    for (y in channel) println(y)\n    println(\"Done!\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-03.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel03\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun CoroutineScope.produceSquares(): ReceiveChannel<Int> = produce {\n    for (x in 1..5) send(x * x)\n}\n\nfun main() = runBlocking {\n    val squares = produceSquares()\n    squares.consumeEach { println(it) }\n    println(\"Done!\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-04.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel04\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n    val numbers = produceNumbers() // produces integers from 1 and on\n    val squares = square(numbers) // squares integers\n    repeat(5) {\n        println(squares.receive()) // print first five\n    }\n    println(\"Done!\") // we are done\n    coroutineContext.cancelChildren() // cancel children coroutines\n}\n\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1\n    while (true) send(x++) // infinite stream of integers starting from 1\n}\n\nfun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {\n    for (x in numbers) send(x * x)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-05.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel05\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n    var cur = numbersFrom(2)\n    repeat(10) {\n        val prime = cur.receive()\n        println(prime)\n        cur = filter(cur, prime)\n    }\n    coroutineContext.cancelChildren() // cancel all children to let main finish\n}\n\nfun CoroutineScope.numbersFrom(start: Int) = produce<Int> {\n    var x = start\n    while (true) send(x++) // infinite stream of integers from start\n}\n\nfun CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {\n    for (x in numbers) if (x % prime != 0) send(x)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-06.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel06\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n    val producer = produceNumbers()\n    repeat(5) { launchProcessor(it, producer) }\n    delay(950)\n    producer.cancel() // cancel producer coroutine and thus kill them all\n}\n\nfun CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1 // start from 1\n    while (true) {\n        send(x++) // produce next\n        delay(100) // wait 0.1s\n    }\n}\n\nfun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel<Int>) = launch {\n    for (msg in channel) {\n        println(\"Processor #$id received $msg\")\n    }    \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-07.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel07\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking {\n    val channel = Channel<String>()\n    launch { sendString(channel, \"foo\", 200L) }\n    launch { sendString(channel, \"BAR!\", 500L) }\n    repeat(6) { // receive first six\n        println(channel.receive())\n    }\n    coroutineContext.cancelChildren() // cancel all children to let main finish\n}\n\nsuspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {\n    while (true) {\n        delay(time)\n        channel.send(s)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-08.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel08\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n    val channel = Channel<Int>(4) // create buffered channel\n    val sender = launch { // launch sender coroutine\n        repeat(10) {\n            println(\"Sending $it\") // print before sending each element\n            channel.send(it) // will suspend when buffer is full\n        }\n    }\n    // don't receive anything... just wait....\n    delay(1000)\n    sender.cancel() // cancel sender coroutine\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-09.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel09\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\ndata class Ball(var hits: Int)\n\nfun main() = runBlocking {\n    val table = Channel<Ball>() // a shared table\n    launch { player(\"ping\", table) }\n    launch { player(\"pong\", table) }\n    table.send(Ball(0)) // serve the ball\n    delay(1000) // delay 1 second\n    coroutineContext.cancelChildren() // game over, cancel them\n}\n\nsuspend fun player(name: String, table: Channel<Ball>) {\n    for (ball in table) { // receive the ball in a loop\n        ball.hits++\n        println(\"$name $ball\")\n        delay(300) // wait a bit\n        table.send(ball) // send the ball back\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-channel-10.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleChannel10\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\nfun main() = runBlocking<Unit> {\n    val tickerChannel = ticker(delayMillis = 200, initialDelayMillis = 0) // create a ticker channel\n    var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    println(\"Initial element is available immediately: $nextElement\") // no initial delay\n\n    nextElement = withTimeoutOrNull(100) { tickerChannel.receive() } // all subsequent elements have 200ms delay\n    println(\"Next element is not ready in 100 ms: $nextElement\")\n\n    nextElement = withTimeoutOrNull(120) { tickerChannel.receive() }\n    println(\"Next element is ready in 200 ms: $nextElement\")\n\n    // Emulate large consumption delays\n    println(\"Consumer pauses for 300ms\")\n    delay(300)\n    // Next element is available immediately\n    nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    println(\"Next element is available immediately after large consumer delay: $nextElement\")\n    // Note that the pause between `receive` calls is taken into account and next element arrives faster\n    nextElement = withTimeoutOrNull(120) { tickerChannel.receive() }\n    println(\"Next element is ready in 100ms after consumer pause in 300ms: $nextElement\")\n\n    tickerChannel.cancel() // indicate that no more elements are needed\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-compose-01.kt",
        "content": "// This file was automatically generated from composing-suspending-functions.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCompose01\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-compose-02.kt",
        "content": "// This file was automatically generated from composing-suspending-functions.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCompose02\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-compose-03.kt",
        "content": "// This file was automatically generated from composing-suspending-functions.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCompose03\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }\n        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }\n        // some computation\n        one.start() // start the first one\n        two.start() // start the second one\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-compose-04.kt",
        "content": "// This file was automatically generated from composing-suspending-functions.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCompose04\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\n// note that we don't have `runBlocking` to the right of `main` in this example\nfun main() {\n    val time = measureTimeMillis {\n        // we can initiate async actions outside of a coroutine\n        val one = somethingUsefulOneAsync()\n        val two = somethingUsefulTwoAsync()\n        // but waiting for a result must involve either suspending or blocking.\n        // here we use `runBlocking { ... }` to block the main thread while waiting for the result\n        runBlocking {\n            println(\"The answer is ${one.await() + two.await()}\")\n        }\n    }\n    println(\"Completed in $time ms\")\n}\n\n@OptIn(DelicateCoroutinesApi::class)\nfun somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n\n@OptIn(DelicateCoroutinesApi::class)\nfun somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-compose-05.kt",
        "content": "// This file was automatically generated from composing-suspending-functions.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCompose05\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        println(\"The answer is ${concurrentSum()}\")\n    }\n    println(\"Completed in $time ms\")\n}\n\nsuspend fun concurrentSum(): Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-compose-06.kt",
        "content": "// This file was automatically generated from composing-suspending-functions.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleCompose06\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    try {\n        failedConcurrentSum()\n    } catch(e: ArithmeticException) {\n        println(\"Computation failed with ArithmeticException\")\n    }\n}\n\nsuspend fun failedConcurrentSum(): Int = coroutineScope {\n    val one = async<Int> { \n        try {\n            delay(Long.MAX_VALUE) // Emulates very long computation\n            42\n        } finally {\n            println(\"First child was cancelled\")\n        }\n    }\n    val two = async<Int> { \n        println(\"Second child throws an exception\")\n        throw ArithmeticException()\n    }\n    one.await() + two.await()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-01.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext01\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    launch { // context of the parent, main runBlocking coroutine\n        println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n        println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher \n        println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // will get its own new thread\n        println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-02.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext02\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n        println(\"Unconfined      : I'm working in thread ${Thread.currentThread().name}\")\n        delay(500)\n        println(\"Unconfined      : After delay in thread ${Thread.currentThread().name}\")\n    }\n    launch { // context of the parent, main runBlocking coroutine\n        println(\"main runBlocking: I'm working in thread ${Thread.currentThread().name}\")\n        delay(1000)\n        println(\"main runBlocking: After delay in thread ${Thread.currentThread().name}\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-03.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext03\n\nimport kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking<Unit> {\n    val a = async {\n        log(\"I'm computing a piece of the answer\")\n        6\n    }\n    val b = async {\n        log(\"I'm computing another piece of the answer\")\n        7\n    }\n    log(\"The answer is ${a.await() * b.await()}\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-04.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext04\n\nimport kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() {\n    newSingleThreadContext(\"Ctx1\").use { ctx1 ->\n        newSingleThreadContext(\"Ctx2\").use { ctx2 ->\n            runBlocking(ctx1) {\n                log(\"Started in ctx1\")\n                withContext(ctx2) {\n                    log(\"Working in ctx2\")\n                }\n                log(\"Back to ctx1\")\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-05.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext05\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    println(\"My job is ${coroutineContext[Job]}\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-06.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext06\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    // launch a coroutine to process some kind of incoming request\n    val request = launch {\n        // it spawns two other jobs\n        launch(Job()) { \n            println(\"job1: I run in my own Job and execute independently!\")\n            delay(1000)\n            println(\"job1: I am not affected by cancellation of the request\")\n        }\n        // and the other inherits the parent context\n        launch {\n            delay(100)\n            println(\"job2: I am a child of the request coroutine\")\n            delay(1000)\n            println(\"job2: I will not execute this line if my parent request is cancelled\")\n        }\n    }\n    delay(500)\n    request.cancel() // cancel processing of the request\n    println(\"main: Who has survived request cancellation?\")\n    delay(1000) // delay the main thread for a second to see what happens\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-07.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext07\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    // launch a coroutine to process some kind of incoming request\n    val request = launch {\n        repeat(3) { i -> // launch a few children jobs\n            launch  {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms\n                println(\"Coroutine $i is done\")\n            }\n        }\n        println(\"request: I'm done and I don't explicitly join my children that are still active\")\n    }\n    request.join() // wait for completion of the request, including all its children\n    println(\"Now processing of the request is complete\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-08.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext08\n\nimport kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking(CoroutineName(\"main\")) {\n    log(\"Started main coroutine\")\n    // run two background value computations\n    val v1 = async(CoroutineName(\"v1coroutine\")) {\n        delay(500)\n        log(\"Computing v1\")\n        6\n    }\n    val v2 = async(CoroutineName(\"v2coroutine\")) {\n        delay(1000)\n        log(\"Computing v2\")\n        7\n    }\n    log(\"The answer for v1 * v2 = ${v1.await() * v2.await()}\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-09.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext09\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    launch(Dispatchers.Default + CoroutineName(\"test\")) {\n        println(\"I'm working in thread ${Thread.currentThread().name}\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-10.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext10\n\nimport kotlinx.coroutines.*\n\nclass Activity {\n    private val mainScope = CoroutineScope(Dispatchers.Default) // use Default for test purposes\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n\n    fun doSomething() {\n        // launch ten coroutines for a demo, each working for a different time\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // class Activity ends\n\nfun main() = runBlocking<Unit> {\n    val activity = Activity()\n    activity.doSomething() // run test function\n    println(\"Launched coroutines\")\n    delay(500L) // delay for half a second\n    println(\"Destroying activity!\")\n    activity.destroy() // cancels all coroutines\n    delay(1000) // visually confirm that they don't work\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-context-11.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleContext11\n\nimport kotlinx.coroutines.*\n\nval threadLocal = ThreadLocal<String?>() // declare thread-local variable\n\nfun main() = runBlocking<Unit> {\n    threadLocal.set(\"main\")\n    println(\"Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = \"launch\")) {\n        println(\"Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n        yield()\n        println(\"After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    }\n    job.join()\n    println(\"Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-exceptions-01.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleExceptions01\n\nimport kotlinx.coroutines.*\n\n@OptIn(DelicateCoroutinesApi::class)\nfun main() = runBlocking {\n    val job = GlobalScope.launch { // root coroutine with launch\n        println(\"Throwing exception from launch\")\n        throw IndexOutOfBoundsException() // Will be printed to the console by Thread.defaultUncaughtExceptionHandler\n    }\n    job.join()\n    println(\"Joined failed job\")\n    val deferred = GlobalScope.async { // root coroutine with async\n        println(\"Throwing exception from async\")\n        throw ArithmeticException() // Nothing is printed, relying on user to call await\n    }\n    try {\n        deferred.await()\n        println(\"Unreached\")\n    } catch (e: ArithmeticException) {\n        println(\"Caught ArithmeticException\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-exceptions-02.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleExceptions02\n\nimport kotlinx.coroutines.*\n\n@OptIn(DelicateCoroutinesApi::class)\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    val job = GlobalScope.launch(handler) { // root coroutine, running in GlobalScope\n        throw AssertionError()\n    }\n    val deferred = GlobalScope.async(handler) { // also root, but async instead of launch\n        throw ArithmeticException() // Nothing will be printed, relying on user to call deferred.await()\n    }\n    joinAll(job, deferred)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-exceptions-03.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleExceptions03\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val job = launch {\n        val child = launch {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                println(\"Child is cancelled\")\n            }\n        }\n        yield()\n        println(\"Cancelling child\")\n        child.cancel()\n        child.join()\n        yield()\n        println(\"Parent is not cancelled\")\n    }\n    job.join()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-exceptions-04.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleExceptions04\n\nimport kotlinx.coroutines.*\n\n@OptIn(DelicateCoroutinesApi::class)\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    val job = GlobalScope.launch(handler) {\n        launch { // the first child\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                withContext(NonCancellable) {\n                    println(\"Children are cancelled, but exception is not handled until all children terminate\")\n                    delay(100)\n                    println(\"The first child finished its non cancellable block\")\n                }\n            }\n        }\n        launch { // the second child\n            delay(10)\n            println(\"Second child throws an exception\")\n            throw ArithmeticException()\n        }\n    }\n    job.join()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-exceptions-05.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleExceptions05\n\nimport kotlinx.coroutines.exceptions.*\n\nimport kotlinx.coroutines.*\nimport java.io.*\n\n@OptIn(DelicateCoroutinesApi::class)\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception ->\n        println(\"CoroutineExceptionHandler got $exception with suppressed ${exception.suppressed.contentToString()}\")\n    }\n    val job = GlobalScope.launch(handler) {\n        launch {\n            try {\n                delay(Long.MAX_VALUE) // it gets cancelled when another sibling fails with IOException\n            } finally {\n                throw ArithmeticException() // the second exception\n            }\n        }\n        launch {\n            delay(100)\n            throw IOException() // the first exception\n        }\n        delay(Long.MAX_VALUE)\n    }\n    job.join()  \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-exceptions-06.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleExceptions06\n\nimport kotlinx.coroutines.*\nimport java.io.*\n\n@OptIn(DelicateCoroutinesApi::class)\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception ->\n        println(\"CoroutineExceptionHandler got $exception\")\n    }\n    val job = GlobalScope.launch(handler) {\n        val innerJob = launch { // all this stack of coroutines will get cancelled\n            launch {\n                launch {\n                    throw IOException() // the original exception\n                }\n            }\n        }\n        try {\n            innerJob.join()\n        } catch (e: CancellationException) {\n            println(\"Rethrowing CancellationException with original cause\")\n            throw e // cancellation exception is rethrown, yet the original IOException gets to the handler  \n        }\n    }\n    job.join()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-01.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow01\n\nfun simple(): List<Int> = listOf(1, 2, 3)\n \nfun main() {\n    simple().forEach { value -> println(value) } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-02.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow02\n\nfun simple(): Sequence<Int> = sequence { // sequence builder\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it\n        yield(i) // yield next value\n    }\n}\n\nfun main() {\n    simple().forEach { value -> println(value) } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-03.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow03\n\nimport kotlinx.coroutines.*                 \n                           \nsuspend fun simple(): List<Int> {\n    delay(1000) // pretend we are doing something asynchronous here\n    return listOf(1, 2, 3)\n}\n\nfun main() = runBlocking<Unit> {\n    simple().forEach { value -> println(value) } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-04.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow04\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = flow { // flow builder\n    for (i in 1..3) {\n        delay(100) // pretend we are doing something useful here\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // Launch a concurrent coroutine to check if the main thread is blocked\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // Collect the flow\n    simple().collect { value -> println(value) } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-05.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow05\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = flow { \n    println(\"Flow started\")\n    for (i in 1..3) {\n        delay(100)\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    println(\"Calling simple function...\")\n    val flow = simple()\n    println(\"Calling collect...\")\n    flow.collect { value -> println(value) } \n    println(\"Calling collect again...\")\n    flow.collect { value -> println(value) } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-06.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow06\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = flow { \n    for (i in 1..3) {\n        delay(100)          \n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    withTimeoutOrNull(250) { // Timeout after 250ms \n        simple().collect { value -> println(value) } \n    }\n    println(\"Done\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-07.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow07\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n    // Convert an integer range to a flow\n    (1..3).asFlow().collect { value -> println(value) }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-08.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow08\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nsuspend fun performRequest(request: Int): String {\n    delay(1000) // imitate long-running asynchronous work\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n    (1..3).asFlow() // a flow of requests\n        .map { request -> performRequest(request) }\n        .collect { response -> println(response) }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-09.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow09\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nsuspend fun performRequest(request: Int): String {\n    delay(1000) // imitate long-running asynchronous work\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n    (1..3).asFlow() // a flow of requests\n        .transform { request ->\n            emit(\"Making request $request\") \n            emit(performRequest(request)) \n        }\n        .collect { response -> println(response) }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-10.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow10\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun numbers(): Flow<Int> = flow {\n    try {                          \n        emit(1)\n        emit(2) \n        println(\"This line will not execute\")\n        emit(3)    \n    } finally {\n        println(\"Finally in numbers\")\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    numbers() \n        .take(2) // take only the first two\n        .collect { value -> println(value) }\n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-11.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow11\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n    val sum = (1..5).asFlow()\n        .map { it * it } // squares of numbers from 1 to 5                           \n        .reduce { a, b -> a + b } // sum them (terminal operator)\n    println(sum)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-12.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow12\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n    (1..5).asFlow()\n        .filter {\n            println(\"Filter $it\")\n            it % 2 == 0              \n        }              \n        .map { \n            println(\"Map $it\")\n            \"string $it\"\n        }.collect { \n            println(\"Collect $it\")\n        }    \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-13.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow13\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \nfun simple(): Flow<Int> = flow {\n    log(\"Started simple flow\")\n    for (i in 1..3) {\n        emit(i)\n    }\n}  \n\nfun main() = runBlocking<Unit> {\n    simple().collect { value -> log(\"Collected $value\") } \n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-14.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow14\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n                      \nfun simple(): Flow<Int> = flow {\n    // The WRONG way to change context for CPU-consuming code in flow builder\n    kotlinx.coroutines.withContext(Dispatchers.Default) {\n        for (i in 1..3) {\n            Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n            emit(i) // emit next value\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    simple().collect { value -> println(value) } \n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-15.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow15\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n        log(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder\n\nfun main() = runBlocking<Unit> {\n    simple().collect { value ->\n        log(\"Collected $value\") \n    } \n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-16.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow16\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple().collect { value -> \n            delay(300) // pretend we are processing it for 300 ms\n            println(value) \n        } \n    }   \n    println(\"Collected in $time ms\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-17.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow17\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple()\n            .buffer() // buffer emissions, don't wait\n            .collect { value -> \n                delay(300) // pretend we are processing it for 300 ms\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-18.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow18\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple()\n            .conflate() // conflate emissions, don't process each one\n            .collect { value -> \n                delay(300) // pretend we are processing it for 300 ms\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-19.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow19\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple()\n            .collectLatest { value -> // cancel & restart on the latest value\n                println(\"Collecting $value\") \n                delay(300) // pretend we are processing it for 300 ms\n                println(\"Done $value\") \n            } \n    }   \n    println(\"Collected in $time ms\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-20.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow20\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n    val nums = (1..3).asFlow() // numbers 1..3\n    val strs = flowOf(\"one\", \"two\", \"three\") // strings \n    nums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string\n        .collect { println(it) } // collect and print\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-21.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow21\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms\n    val startTime = currentTimeMillis() // remember the start time \n    nums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"zip\"\n        .collect { value -> // collect and print \n            println(\"$value at ${currentTimeMillis() - startTime} ms from start\") \n        } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-22.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow22\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms          \n    val startTime = currentTimeMillis() // remember the start time \n    nums.combine(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"combine\"\n        .collect { value -> // collect and print \n            println(\"$value at ${currentTimeMillis() - startTime} ms from start\") \n        } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-23.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow23\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n    val startTime = currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // emit a number every 100 ms \n        .flatMapConcat { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${currentTimeMillis() - startTime} ms from start\") \n        } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-24.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow24\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n    val startTime = currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapMerge { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${currentTimeMillis() - startTime} ms from start\") \n        } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-25.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow25\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n    val startTime = currentTimeMillis() // remember the start time \n    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n        .flatMapLatest { requestFlow(it) }                                                                           \n        .collect { value -> // collect and print \n            println(\"$value at ${currentTimeMillis() - startTime} ms from start\") \n        } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-26.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow26\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    try {\n        simple().collect { value ->         \n            println(value)\n            check(value <= 1) { \"Collected $value\" }\n        }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-27.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow27\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // emit next value\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n    try {\n        simple().collect { value -> println(value) }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-28.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow28\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // emit next value\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .catch { e -> emit(\"Caught $e\") } // emit on exception\n        .collect { value -> println(value) }\n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-29.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow29\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .catch { e -> println(\"Caught $e\") } // does not catch downstream exceptions\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-30.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow30\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .onEach { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n        .catch { e -> println(\"Caught $e\") }\n        .collect()\n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-31.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow31\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    try {\n        simple().collect { value -> println(value) }\n    } finally {\n        println(\"Done\")\n    }\n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-32.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow32\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .onCompletion { println(\"Done\") }\n        .collect { value -> println(value) }\n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-33.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow33\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = flow {\n    emit(1)\n    throw RuntimeException()\n}\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .onCompletion { cause -> if (cause != null) println(\"Flow completed exceptionally\") }\n        .catch { cause -> println(\"Caught exception\") }\n        .collect { value -> println(value) }\n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-34.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow34\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .onCompletion { cause -> println(\"Flow completed with $cause\") }\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-35.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow35\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n// Imitate a flow of events\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .collect() // <--- Collecting the flow waits\n    println(\"Done\")\n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-36.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow36\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n// Imitate a flow of events\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .launchIn(this) // <--- Launching the flow in a separate coroutine\n    println(\"Done\")\n}            \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-37.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow37\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = flow { \n    for (i in 1..5) {\n        println(\"Emitting $i\") \n        emit(i) \n    }\n}\n\nfun main() = runBlocking<Unit> {\n    foo().collect { value -> \n        if (value == 3) cancel()  \n        println(value)\n    } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-38.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow38\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n    (1..5).asFlow().collect { value -> \n        if (value == 3) cancel()  \n        println(value)\n    } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-flow-39.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleFlow39\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n    (1..5).asFlow().cancellable().collect { value -> \n        if (value == 3) cancel()  \n        println(value)\n    } \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-select-01.kt",
        "content": "// This file was automatically generated from select-expression.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSelect01\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nfun CoroutineScope.fizz() = produce<String> {\n    while (true) { // sends \"Fizz\" every 500 ms\n        delay(500)\n        send(\"Fizz\")\n    }\n}\n\nfun CoroutineScope.buzz() = produce<String> {\n    while (true) { // sends \"Buzz!\" every 1000 ms\n        delay(1000)\n        send(\"Buzz!\")\n    }\n}\n\nsuspend fun selectFizzBuzz(fizz: ReceiveChannel<String>, buzz: ReceiveChannel<String>) {\n    select<Unit> { // <Unit> means that this select expression does not produce any result \n        fizz.onReceive { value ->  // this is the first select clause\n            println(\"fizz -> '$value'\")\n        }\n        buzz.onReceive { value ->  // this is the second select clause\n            println(\"buzz -> '$value'\")\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    val fizz = fizz()\n    val buzz = buzz()\n    repeat(7) {\n        selectFizzBuzz(fizz, buzz)\n    }\n    coroutineContext.cancelChildren() // cancel fizz & buzz coroutines\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-select-02.kt",
        "content": "// This file was automatically generated from select-expression.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSelect02\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nsuspend fun selectAorB(a: ReceiveChannel<String>, b: ReceiveChannel<String>): String =\n    select<String> {\n        a.onReceiveCatching { it ->\n            val value = it.getOrNull()\n            if (value != null) {\n                \"a -> '$value'\"\n            } else {\n                \"Channel 'a' is closed\"\n            }\n        }\n        b.onReceiveCatching { it ->\n            val value = it.getOrNull()\n            if (value != null) {\n                \"b -> '$value'\"\n            } else {\n                \"Channel 'b' is closed\"\n            }\n        }\n    }\n    \nfun main() = runBlocking<Unit> {\n    val a = produce<String> {\n        repeat(4) { send(\"Hello $it\") }\n    }\n    val b = produce<String> {\n        repeat(4) { send(\"World $it\") }\n    }\n    repeat(8) { // print first eight results\n        println(selectAorB(a, b))\n    }\n    coroutineContext.cancelChildren()  \n}    \n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-select-03.kt",
        "content": "// This file was automatically generated from select-expression.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSelect03\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n\nfun CoroutineScope.produceNumbers(side: SendChannel<Int>) = produce<Int> {\n    for (num in 1..10) { // produce 10 numbers from 1 to 10\n        delay(100) // every 100 ms\n        select<Unit> {\n            onSend(num) {} // Send to the primary channel\n            side.onSend(num) {} // or to the side channel     \n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    val side = Channel<Int>() // allocate side channel\n    launch { // this is a very fast consumer for the side channel\n        side.consumeEach { println(\"Side channel has $it\") }\n    }\n    produceNumbers(side).consumeEach { \n        println(\"Consuming $it\")\n        delay(250) // let us digest the consumed number properly, do not hurry\n    }\n    println(\"Done consuming\")\n    coroutineContext.cancelChildren()  \n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-select-04.kt",
        "content": "// This file was automatically generated from select-expression.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSelect04\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport java.util.*\n    \nfun CoroutineScope.asyncString(time: Int) = async {\n    delay(time.toLong())\n    \"Waited for $time ms\"\n}\n\nfun CoroutineScope.asyncStringsList(): List<Deferred<String>> {\n    val random = Random(3)\n    return List(12) { asyncString(random.nextInt(1000)) }\n}\n\nfun main() = runBlocking<Unit> {\n    val list = asyncStringsList()\n    val result = select<String> {\n        list.withIndex().forEach { (index, deferred) ->\n            deferred.onAwait { answer ->\n                \"Deferred $index produced answer '$answer'\"\n            }\n        }\n    }\n    println(result)\n    val countActive = list.count { it.isActive }\n    println(\"$countActive coroutines are still active\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-select-05.kt",
        "content": "// This file was automatically generated from select-expression.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSelect05\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\n    \nfun CoroutineScope.switchMapDeferreds(input: ReceiveChannel<Deferred<String>>) = produce<String> {\n    var current = input.receive() // start with first received deferred value\n    while (isActive) { // loop while not cancelled/closed\n        val next = select<Deferred<String>?> { // return next deferred value from this select or null\n            input.onReceiveCatching { update ->\n                update.getOrNull()\n            }\n            current.onAwait { value ->\n                send(value) // send value that current deferred has produced\n                input.receiveCatching().getOrNull() // and use the next deferred from the input channel\n            }\n        }\n        if (next == null) {\n            println(\"Channel was closed\")\n            break // out of loop\n        } else {\n            current = next\n        }\n    }\n}\n\nfun CoroutineScope.asyncString(str: String, time: Long) = async {\n    delay(time)\n    str\n}\n\nfun main() = runBlocking<Unit> {\n    val chan = Channel<Deferred<String>>() // the channel for test\n    launch { // launch printing coroutine\n        for (s in switchMapDeferreds(chan)) \n            println(s) // print each received string\n    }\n    chan.send(asyncString(\"BEGIN\", 100))\n    delay(200) // enough time for \"BEGIN\" to be produced\n    chan.send(asyncString(\"Slow\", 500))\n    delay(100) // not enough time to produce slow\n    chan.send(asyncString(\"Replace\", 100))\n    delay(500) // give it time before the last one\n    chan.send(asyncString(\"END\", 500))\n    delay(1000) // give it time to process\n    chan.close() // close the channel ... \n    delay(500) // and wait some time to let it finish\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-supervision-01.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSupervision01\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val supervisor = SupervisorJob()\n    with(CoroutineScope(coroutineContext + supervisor)) {\n        // launch the first child -- its exception is ignored for this example (don't do this in practice!)\n        val firstChild = launch(CoroutineExceptionHandler { _, _ ->  }) {\n            println(\"The first child is failing\")\n            throw AssertionError(\"The first child is cancelled\")\n        }\n        // launch the second child\n        val secondChild = launch {\n            firstChild.join()\n            // Cancellation of the first child is not propagated to the second child\n            println(\"The first child is cancelled: ${firstChild.isCancelled}, but the second one is still active\")\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                // But cancellation of the supervisor is propagated\n                println(\"The second child is cancelled because the supervisor was cancelled\")\n            }\n        }\n        // wait until the first child fails & completes\n        firstChild.join()\n        println(\"Cancelling the supervisor\")\n        supervisor.cancel()\n        secondChild.join()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-supervision-02.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSupervision02\n\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    try {\n        supervisorScope {\n            val child = launch {\n                try {\n                    println(\"The child is sleeping\")\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    println(\"The child is cancelled\")\n                }\n            }\n            // Give our child a chance to execute and print using yield \n            yield()\n            println(\"Throwing an exception from the scope\")\n            throw AssertionError()\n        }\n    } catch(e: AssertionError) {\n        println(\"Caught an assertion error\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-supervision-03.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSupervision03\n\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception -> \n        println(\"CoroutineExceptionHandler got $exception\") \n    }\n    supervisorScope {\n        val child = launch(handler) {\n            println(\"The child throws an exception\")\n            throw AssertionError()\n        }\n        println(\"The scope is completing\")\n    }\n    println(\"The scope is completed\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-sync-01.kt",
        "content": "// This file was automatically generated from shared-mutable-state-and-concurrency.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSync01\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*    \n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-sync-02.kt",
        "content": "// This file was automatically generated from shared-mutable-state-and-concurrency.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSync02\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n@Volatile // in Kotlin `volatile` is an annotation \nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-sync-03.kt",
        "content": "// This file was automatically generated from shared-mutable-state-and-concurrency.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSync03\n\nimport kotlinx.coroutines.*\nimport java.util.concurrent.atomic.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\nval counter = AtomicInteger()\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.incrementAndGet()\n        }\n    }\n    println(\"Counter = $counter\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-sync-04.kt",
        "content": "// This file was automatically generated from shared-mutable-state-and-concurrency.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSync04\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\nval counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // confine each increment to a single-threaded context\n            withContext(counterContext) {\n                counter++\n            }\n        }\n    }\n    println(\"Counter = $counter\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-sync-05.kt",
        "content": "// This file was automatically generated from shared-mutable-state-and-concurrency.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSync05\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\nval counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n\nfun main() = runBlocking {\n    // confine everything to a single-threaded context\n    withContext(counterContext) {\n        massiveRun {\n            counter++\n        }\n    }\n    println(\"Counter = $counter\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-sync-06.kt",
        "content": "// This file was automatically generated from shared-mutable-state-and-concurrency.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSync06\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\nval mutex = Mutex()\nvar counter = 0\n\nfun main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // protect each increment with lock\n            mutex.withLock {\n                counter++\n            }\n        }\n    }\n    println(\"Counter = $counter\")\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/example-sync-07.kt",
        "content": "// This file was automatically generated from shared-mutable-state-and-concurrency.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.exampleSync07\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.system.*\n\nsuspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    println(\"Completed ${n * k} actions in $time ms\")    \n}\n\n// Message types for counterActor\nsealed class CounterMsg\nobject IncCounter : CounterMsg() // one-way message to increment counter\nclass GetCounter(val response: CompletableDeferred<Int>) : CounterMsg() // a request with reply\n\n// This function launches a new counter actor\nfun CoroutineScope.counterActor() = actor<CounterMsg> {\n    var counter = 0 // actor state\n    for (msg in channel) { // iterate over incoming messages\n        when (msg) {\n            is IncCounter -> counter++\n            is GetCounter -> msg.response.complete(counter)\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    val counter = counterActor() // create the actor\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.send(IncCounter)\n        }\n    }\n    // send a message to get a counter value from an actor\n    val response = CompletableDeferred<Int>()\n    counter.send(GetCounter(response))\n    println(\"Counter = ${response.await()}\")\n    counter.close() // shutdown the actor\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/test/BasicsGuideTest.kt",
        "content": "// This file was automatically generated from coroutines-basics.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass BasicsGuideTest {\n    @Test\n    fun testExampleBasic01() {\n        test(\"ExampleBasic01\") { kotlinx.coroutines.guide.exampleBasic01.main() }.verifyLines(\n            \"Hello\",\n            \"World!\"\n        )\n    }\n\n    @Test\n    fun testExampleBasic02() {\n        test(\"ExampleBasic02\") { kotlinx.coroutines.guide.exampleBasic02.main() }.verifyLines(\n            \"Hello\",\n            \"World!\"\n        )\n    }\n\n    @Test\n    fun testExampleBasic03() {\n        test(\"ExampleBasic03\") { kotlinx.coroutines.guide.exampleBasic03.main() }.verifyLines(\n            \"Hello\",\n            \"World!\"\n        )\n    }\n\n    @Test\n    fun testExampleBasic04() {\n        test(\"ExampleBasic04\") { kotlinx.coroutines.guide.exampleBasic04.main() }.verifyLines(\n            \"Hello\",\n            \"World 1\",\n            \"World 2\",\n            \"Done\"\n        )\n    }\n\n    @Test\n    fun testExampleBasic05() {\n        test(\"ExampleBasic05\") { kotlinx.coroutines.guide.exampleBasic05.main() }.verifyLines(\n            \"Hello\",\n            \"World!\",\n            \"Done\"\n        )\n    }\n\n    @Test\n    fun testExampleBasic06() {\n        test(\"ExampleBasic06\") { kotlinx.coroutines.guide.exampleBasic06.main() }.also { lines ->\n            check(lines.size == 1 && lines[0] == \".\".repeat(50_000))\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/test/CancellationGuideTest.kt",
        "content": "// This file was automatically generated from cancellation-and-timeouts.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass CancellationGuideTest {\n    @Test\n    fun testExampleCancel01() {\n        test(\"ExampleCancel01\") { kotlinx.coroutines.guide.exampleCancel01.main() }.verifyLines(\n            \"job: I'm sleeping 0 ...\",\n            \"job: I'm sleeping 1 ...\",\n            \"job: I'm sleeping 2 ...\",\n            \"main: I'm tired of waiting!\",\n            \"main: Now I can quit.\"\n        )\n    }\n\n    @Test\n    fun testExampleCancel02() {\n        test(\"ExampleCancel02\") { kotlinx.coroutines.guide.exampleCancel02.main() }.verifyLines(\n            \"job: I'm sleeping 0 ...\",\n            \"job: I'm sleeping 1 ...\",\n            \"job: I'm sleeping 2 ...\",\n            \"main: I'm tired of waiting!\",\n            \"job: I'm sleeping 3 ...\",\n            \"job: I'm sleeping 4 ...\",\n            \"main: Now I can quit.\"\n        )\n    }\n\n    @Test\n    fun testExampleCancel04() {\n        test(\"ExampleCancel04\") { kotlinx.coroutines.guide.exampleCancel04.main() }.verifyLines(\n            \"job: I'm sleeping 0 ...\",\n            \"job: I'm sleeping 1 ...\",\n            \"job: I'm sleeping 2 ...\",\n            \"main: I'm tired of waiting!\",\n            \"main: Now I can quit.\"\n        )\n    }\n\n    @Test\n    fun testExampleCancel05() {\n        test(\"ExampleCancel05\") { kotlinx.coroutines.guide.exampleCancel05.main() }.verifyLines(\n            \"job: I'm sleeping 0 ...\",\n            \"job: I'm sleeping 1 ...\",\n            \"job: I'm sleeping 2 ...\",\n            \"main: I'm tired of waiting!\",\n            \"job: I'm running finally\",\n            \"main: Now I can quit.\"\n        )\n    }\n\n    @Test\n    fun testExampleCancel06() {\n        test(\"ExampleCancel06\") { kotlinx.coroutines.guide.exampleCancel06.main() }.verifyLines(\n            \"job: I'm sleeping 0 ...\",\n            \"job: I'm sleeping 1 ...\",\n            \"job: I'm sleeping 2 ...\",\n            \"main: I'm tired of waiting!\",\n            \"job: I'm running finally\",\n            \"job: And I've just delayed for 1 sec because I'm non-cancellable\",\n            \"main: Now I can quit.\"\n        )\n    }\n\n    @Test\n    fun testExampleCancel07() {\n        test(\"ExampleCancel07\") { kotlinx.coroutines.guide.exampleCancel07.main() }.verifyLinesStartWith(\n            \"I'm sleeping 0 ...\",\n            \"I'm sleeping 1 ...\",\n            \"I'm sleeping 2 ...\",\n            \"Exception in thread \\\"main\\\" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleCancel08() {\n        test(\"ExampleCancel08\") { kotlinx.coroutines.guide.exampleCancel08.main() }.verifyLines(\n            \"I'm sleeping 0 ...\",\n            \"I'm sleeping 1 ...\",\n            \"I'm sleeping 2 ...\",\n            \"Result is null\"\n        )\n    }\n\n    @Test\n    fun testExampleCancel10() {\n        test(\"ExampleCancel10\") { kotlinx.coroutines.guide.exampleCancel10.main() }.verifyLines(\n            \"0\"\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/test/ChannelsGuideTest.kt",
        "content": "// This file was automatically generated from channels.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass ChannelsGuideTest {\n    @Test\n    fun testExampleChannel01() {\n        test(\"ExampleChannel01\") { kotlinx.coroutines.guide.exampleChannel01.main() }.verifyLines(\n            \"1\",\n            \"4\",\n            \"9\",\n            \"16\",\n            \"25\",\n            \"Done!\"\n        )\n    }\n\n    @Test\n    fun testExampleChannel02() {\n        test(\"ExampleChannel02\") { kotlinx.coroutines.guide.exampleChannel02.main() }.verifyLines(\n            \"1\",\n            \"4\",\n            \"9\",\n            \"16\",\n            \"25\",\n            \"Done!\"\n        )\n    }\n\n    @Test\n    fun testExampleChannel03() {\n        test(\"ExampleChannel03\") { kotlinx.coroutines.guide.exampleChannel03.main() }.verifyLines(\n            \"1\",\n            \"4\",\n            \"9\",\n            \"16\",\n            \"25\",\n            \"Done!\"\n        )\n    }\n\n    @Test\n    fun testExampleChannel04() {\n        test(\"ExampleChannel04\") { kotlinx.coroutines.guide.exampleChannel04.main() }.verifyLines(\n            \"1\",\n            \"4\",\n            \"9\",\n            \"16\",\n            \"25\",\n            \"Done!\"\n        )\n    }\n\n    @Test\n    fun testExampleChannel05() {\n        test(\"ExampleChannel05\") { kotlinx.coroutines.guide.exampleChannel05.main() }.verifyLines(\n            \"2\",\n            \"3\",\n            \"5\",\n            \"7\",\n            \"11\",\n            \"13\",\n            \"17\",\n            \"19\",\n            \"23\",\n            \"29\"\n        )\n    }\n\n    @Test\n    fun testExampleChannel06() {\n        test(\"ExampleChannel06\") { kotlinx.coroutines.guide.exampleChannel06.main() }.also { lines ->\n            check(lines.size == 10 && lines.withIndex().all { (i, line) -> line.startsWith(\"Processor #\") && line.endsWith(\" received ${i + 1}\") })\n        }\n    }\n\n    @Test\n    fun testExampleChannel07() {\n        test(\"ExampleChannel07\") { kotlinx.coroutines.guide.exampleChannel07.main() }.verifyLines(\n            \"foo\",\n            \"foo\",\n            \"BAR!\",\n            \"foo\",\n            \"foo\",\n            \"BAR!\"\n        )\n    }\n\n    @Test\n    fun testExampleChannel08() {\n        test(\"ExampleChannel08\") { kotlinx.coroutines.guide.exampleChannel08.main() }.verifyLines(\n            \"Sending 0\",\n            \"Sending 1\",\n            \"Sending 2\",\n            \"Sending 3\",\n            \"Sending 4\"\n        )\n    }\n\n    @Test\n    fun testExampleChannel09() {\n        test(\"ExampleChannel09\") { kotlinx.coroutines.guide.exampleChannel09.main() }.verifyLines(\n            \"ping Ball(hits=1)\",\n            \"pong Ball(hits=2)\",\n            \"ping Ball(hits=3)\",\n            \"pong Ball(hits=4)\"\n        )\n    }\n\n    @Test\n    fun testExampleChannel10() {\n        test(\"ExampleChannel10\") { kotlinx.coroutines.guide.exampleChannel10.main() }.verifyLines(\n            \"Initial element is available immediately: kotlin.Unit\",\n            \"Next element is not ready in 100 ms: null\",\n            \"Next element is ready in 200 ms: kotlin.Unit\",\n            \"Consumer pauses for 300ms\",\n            \"Next element is available immediately after large consumer delay: kotlin.Unit\",\n            \"Next element is ready in 100ms after consumer pause in 300ms: kotlin.Unit\"\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/test/ComposingGuideTest.kt",
        "content": "// This file was automatically generated from composing-suspending-functions.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass ComposingGuideTest {\n    @Test\n    fun testExampleCompose01() {\n        test(\"ExampleCompose01\") { kotlinx.coroutines.guide.exampleCompose01.main() }.verifyLinesArbitraryTime(\n            \"The answer is 42\",\n            \"Completed in 2017 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleCompose02() {\n        test(\"ExampleCompose02\") { kotlinx.coroutines.guide.exampleCompose02.main() }.verifyLinesArbitraryTime(\n            \"The answer is 42\",\n            \"Completed in 1017 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleCompose03() {\n        test(\"ExampleCompose03\") { kotlinx.coroutines.guide.exampleCompose03.main() }.verifyLinesArbitraryTime(\n            \"The answer is 42\",\n            \"Completed in 1017 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleCompose04() {\n        test(\"ExampleCompose04\") { kotlinx.coroutines.guide.exampleCompose04.main() }.verifyLinesArbitraryTime(\n            \"The answer is 42\",\n            \"Completed in 1085 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleCompose05() {\n        test(\"ExampleCompose05\") { kotlinx.coroutines.guide.exampleCompose05.main() }.verifyLinesArbitraryTime(\n            \"The answer is 42\",\n            \"Completed in 1017 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleCompose06() {\n        test(\"ExampleCompose06\") { kotlinx.coroutines.guide.exampleCompose06.main() }.verifyLines(\n            \"Second child throws an exception\",\n            \"First child was cancelled\",\n            \"Computation failed with ArithmeticException\"\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/test/DispatcherGuideTest.kt",
        "content": "// This file was automatically generated from coroutine-context-and-dispatchers.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass DispatcherGuideTest {\n    @Test\n    fun testExampleContext01() {\n        test(\"ExampleContext01\") { kotlinx.coroutines.guide.exampleContext01.main() }.verifyLinesStartUnordered(\n            \"Unconfined            : I'm working in thread main\",\n            \"Default               : I'm working in thread DefaultDispatcher-worker-1\",\n            \"newSingleThreadContext: I'm working in thread MyOwnThread\",\n            \"main runBlocking      : I'm working in thread main\"\n        )\n    }\n\n    @Test\n    fun testExampleContext02() {\n        test(\"ExampleContext02\") { kotlinx.coroutines.guide.exampleContext02.main() }.verifyLinesStart(\n            \"Unconfined      : I'm working in thread main\",\n            \"main runBlocking: I'm working in thread main\",\n            \"Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor\",\n            \"main runBlocking: After delay in thread main\"\n        )\n    }\n\n    @Test\n    fun testExampleContext03() {\n        test(\"ExampleContext03\") { kotlinx.coroutines.guide.exampleContext03.main() }.verifyLinesFlexibleThread(\n            \"[main @coroutine#2] I'm computing a piece of the answer\",\n            \"[main @coroutine#3] I'm computing another piece of the answer\",\n            \"[main @coroutine#1] The answer is 42\"\n        )\n    }\n\n    @Test\n    fun testExampleContext04() {\n        test(\"ExampleContext04\") { kotlinx.coroutines.guide.exampleContext04.main() }.verifyLines(\n            \"[Ctx1 @coroutine#1] Started in ctx1\",\n            \"[Ctx2 @coroutine#1] Working in ctx2\",\n            \"[Ctx1 @coroutine#1] Back to ctx1\"\n        )\n    }\n\n    @Test\n    fun testExampleContext05() {\n        test(\"ExampleContext05\") { kotlinx.coroutines.guide.exampleContext05.main() }.also { lines ->\n            check(lines.size == 1 && lines[0].startsWith(\"My job is \\\"coroutine#1\\\":BlockingCoroutine{Active}@\"))\n        }\n    }\n\n    @Test\n    fun testExampleContext06() {\n        test(\"ExampleContext06\") { kotlinx.coroutines.guide.exampleContext06.main() }.verifyLines(\n            \"job1: I run in my own Job and execute independently!\",\n            \"job2: I am a child of the request coroutine\",\n            \"main: Who has survived request cancellation?\",\n            \"job1: I am not affected by cancellation of the request\"\n        )\n    }\n\n    @Test\n    fun testExampleContext07() {\n        test(\"ExampleContext07\") { kotlinx.coroutines.guide.exampleContext07.main() }.verifyLines(\n            \"request: I'm done and I don't explicitly join my children that are still active\",\n            \"Coroutine 0 is done\",\n            \"Coroutine 1 is done\",\n            \"Coroutine 2 is done\",\n            \"Now processing of the request is complete\"\n        )\n    }\n\n    @Test\n    fun testExampleContext08() {\n        test(\"ExampleContext08\") { kotlinx.coroutines.guide.exampleContext08.main() }.verifyLinesFlexibleThread(\n            \"[main @main#1] Started main coroutine\",\n            \"[main @v1coroutine#2] Computing v1\",\n            \"[main @v2coroutine#3] Computing v2\",\n            \"[main @main#1] The answer for v1 * v2 = 42\"\n        )\n    }\n\n    @Test\n    fun testExampleContext09() {\n        test(\"ExampleContext09\") { kotlinx.coroutines.guide.exampleContext09.main() }.verifyLinesFlexibleThread(\n            \"I'm working in thread DefaultDispatcher-worker-1 @test#2\"\n        )\n    }\n\n    @Test\n    fun testExampleContext10() {\n        test(\"ExampleContext10\") { kotlinx.coroutines.guide.exampleContext10.main() }.verifyLines(\n            \"Launched coroutines\",\n            \"Coroutine 0 is done\",\n            \"Coroutine 1 is done\",\n            \"Destroying activity!\"\n        )\n    }\n\n    @Test\n    fun testExampleContext11() {\n        test(\"ExampleContext11\") { kotlinx.coroutines.guide.exampleContext11.main() }.verifyLinesFlexibleThread(\n            \"Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'\",\n            \"Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: 'launch'\",\n            \"After yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: 'launch'\",\n            \"Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'\"\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/test/ExceptionsGuideTest.kt",
        "content": "// This file was automatically generated from exception-handling.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass ExceptionsGuideTest {\n    @Test\n    fun testExampleExceptions01() {\n        test(\"ExampleExceptions01\") { kotlinx.coroutines.guide.exampleExceptions01.main() }.verifyExceptions(\n            \"Throwing exception from launch\",\n            \"Exception in thread \\\"DefaultDispatcher-worker-1 @coroutine#2\\\" java.lang.IndexOutOfBoundsException\",\n            \"Joined failed job\",\n            \"Throwing exception from async\",\n            \"Caught ArithmeticException\"\n        )\n    }\n\n    @Test\n    fun testExampleExceptions02() {\n        test(\"ExampleExceptions02\") { kotlinx.coroutines.guide.exampleExceptions02.main() }.verifyLines(\n            \"CoroutineExceptionHandler got java.lang.AssertionError\"\n        )\n    }\n\n    @Test\n    fun testExampleExceptions03() {\n        test(\"ExampleExceptions03\") { kotlinx.coroutines.guide.exampleExceptions03.main() }.verifyLines(\n            \"Cancelling child\",\n            \"Child is cancelled\",\n            \"Parent is not cancelled\"\n        )\n    }\n\n    @Test\n    fun testExampleExceptions04() {\n        test(\"ExampleExceptions04\") { kotlinx.coroutines.guide.exampleExceptions04.main() }.verifyLines(\n            \"Second child throws an exception\",\n            \"Children are cancelled, but exception is not handled until all children terminate\",\n            \"The first child finished its non cancellable block\",\n            \"CoroutineExceptionHandler got java.lang.ArithmeticException\"\n        )\n    }\n\n    @Test\n    fun testExampleExceptions05() {\n        test(\"ExampleExceptions05\") { kotlinx.coroutines.guide.exampleExceptions05.main() }.verifyLines(\n            \"CoroutineExceptionHandler got java.io.IOException with suppressed [java.lang.ArithmeticException]\"\n        )\n    }\n\n    @Test\n    fun testExampleExceptions06() {\n        test(\"ExampleExceptions06\") { kotlinx.coroutines.guide.exampleExceptions06.main() }.verifyLines(\n            \"Rethrowing CancellationException with original cause\",\n            \"CoroutineExceptionHandler got java.io.IOException\"\n        )\n    }\n\n    @Test\n    fun testExampleSupervision01() {\n        test(\"ExampleSupervision01\") { kotlinx.coroutines.guide.exampleSupervision01.main() }.verifyLines(\n            \"The first child is failing\",\n            \"The first child is cancelled: true, but the second one is still active\",\n            \"Cancelling the supervisor\",\n            \"The second child is cancelled because the supervisor was cancelled\"\n        )\n    }\n\n    @Test\n    fun testExampleSupervision02() {\n        test(\"ExampleSupervision02\") { kotlinx.coroutines.guide.exampleSupervision02.main() }.verifyLines(\n            \"The child is sleeping\",\n            \"Throwing an exception from the scope\",\n            \"The child is cancelled\",\n            \"Caught an assertion error\"\n        )\n    }\n\n    @Test\n    fun testExampleSupervision03() {\n        test(\"ExampleSupervision03\") { kotlinx.coroutines.guide.exampleSupervision03.main() }.verifyLines(\n            \"The scope is completing\",\n            \"The child throws an exception\",\n            \"CoroutineExceptionHandler got java.lang.AssertionError\",\n            \"The scope is completed\"\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/test/FlowGuideTest.kt",
        "content": "// This file was automatically generated from flow.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass FlowGuideTest {\n    @Test\n    fun testExampleFlow01() {\n        test(\"ExampleFlow01\") { kotlinx.coroutines.guide.exampleFlow01.main() }.verifyLines(\n            \"1\",\n            \"2\",\n            \"3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow02() {\n        test(\"ExampleFlow02\") { kotlinx.coroutines.guide.exampleFlow02.main() }.verifyLines(\n            \"1\",\n            \"2\",\n            \"3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow03() {\n        test(\"ExampleFlow03\") { kotlinx.coroutines.guide.exampleFlow03.main() }.verifyLines(\n            \"1\",\n            \"2\",\n            \"3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow04() {\n        test(\"ExampleFlow04\") { kotlinx.coroutines.guide.exampleFlow04.main() }.verifyLines(\n            \"I'm not blocked 1\",\n            \"1\",\n            \"I'm not blocked 2\",\n            \"2\",\n            \"I'm not blocked 3\",\n            \"3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow05() {\n        test(\"ExampleFlow05\") { kotlinx.coroutines.guide.exampleFlow05.main() }.verifyLines(\n            \"Calling simple function...\",\n            \"Calling collect...\",\n            \"Flow started\",\n            \"1\",\n            \"2\",\n            \"3\",\n            \"Calling collect again...\",\n            \"Flow started\",\n            \"1\",\n            \"2\",\n            \"3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow06() {\n        test(\"ExampleFlow06\") { kotlinx.coroutines.guide.exampleFlow06.main() }.verifyLines(\n            \"Emitting 1\",\n            \"1\",\n            \"Emitting 2\",\n            \"2\",\n            \"Done\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow07() {\n        test(\"ExampleFlow07\") { kotlinx.coroutines.guide.exampleFlow07.main() }.verifyLines(\n            \"1\",\n            \"2\",\n            \"3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow08() {\n        test(\"ExampleFlow08\") { kotlinx.coroutines.guide.exampleFlow08.main() }.verifyLines(\n            \"response 1\",\n            \"response 2\",\n            \"response 3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow09() {\n        test(\"ExampleFlow09\") { kotlinx.coroutines.guide.exampleFlow09.main() }.verifyLines(\n            \"Making request 1\",\n            \"response 1\",\n            \"Making request 2\",\n            \"response 2\",\n            \"Making request 3\",\n            \"response 3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow10() {\n        test(\"ExampleFlow10\") { kotlinx.coroutines.guide.exampleFlow10.main() }.verifyLines(\n            \"1\",\n            \"2\",\n            \"Finally in numbers\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow11() {\n        test(\"ExampleFlow11\") { kotlinx.coroutines.guide.exampleFlow11.main() }.verifyLines(\n            \"55\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow12() {\n        test(\"ExampleFlow12\") { kotlinx.coroutines.guide.exampleFlow12.main() }.verifyLines(\n            \"Filter 1\",\n            \"Filter 2\",\n            \"Map 2\",\n            \"Collect string 2\",\n            \"Filter 3\",\n            \"Filter 4\",\n            \"Map 4\",\n            \"Collect string 4\",\n            \"Filter 5\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow13() {\n        test(\"ExampleFlow13\") { kotlinx.coroutines.guide.exampleFlow13.main() }.verifyLinesFlexibleThread(\n            \"[main @coroutine#1] Started simple flow\",\n            \"[main @coroutine#1] Collected 1\",\n            \"[main @coroutine#1] Collected 2\",\n            \"[main @coroutine#1] Collected 3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow14() {\n        test(\"ExampleFlow14\") { kotlinx.coroutines.guide.exampleFlow14.main() }.verifyExceptions(\n            \"Exception in thread \\\"main\\\" java.lang.IllegalStateException: Flow invariant is violated:\",\n            \"\\t\\tFlow was collected in [CoroutineId(1), \\\"coroutine#1\\\":BlockingCoroutine{Active}@5511c7f8, BlockingEventLoop@2eac3323],\",\n            \"\\t\\tbut emission happened in [CoroutineId(1), \\\"coroutine#1\\\":DispatchedCoroutine{Active}@2dae0000, Dispatchers.Default].\",\n            \"\\t\\tPlease refer to 'flow' documentation or use 'flowOn' instead\",\n            \"\\tat ...\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow15() {\n        test(\"ExampleFlow15\") { kotlinx.coroutines.guide.exampleFlow15.main() }.verifyLinesFlexibleThread(\n            \"[DefaultDispatcher-worker-1 @coroutine#2] Emitting 1\",\n            \"[main @coroutine#1] Collected 1\",\n            \"[DefaultDispatcher-worker-1 @coroutine#2] Emitting 2\",\n            \"[main @coroutine#1] Collected 2\",\n            \"[DefaultDispatcher-worker-1 @coroutine#2] Emitting 3\",\n            \"[main @coroutine#1] Collected 3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow16() {\n        test(\"ExampleFlow16\") { kotlinx.coroutines.guide.exampleFlow16.main() }.verifyLinesArbitraryTime(\n            \"1\",\n            \"2\",\n            \"3\",\n            \"Collected in 1220 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow17() {\n        test(\"ExampleFlow17\") { kotlinx.coroutines.guide.exampleFlow17.main() }.verifyLinesArbitraryTime(\n            \"1\",\n            \"2\",\n            \"3\",\n            \"Collected in 1071 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow18() {\n        test(\"ExampleFlow18\") { kotlinx.coroutines.guide.exampleFlow18.main() }.verifyLinesArbitraryTime(\n            \"1\",\n            \"3\",\n            \"Collected in 758 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow19() {\n        test(\"ExampleFlow19\") { kotlinx.coroutines.guide.exampleFlow19.main() }.verifyLinesArbitraryTime(\n            \"Collecting 1\",\n            \"Collecting 2\",\n            \"Collecting 3\",\n            \"Done 3\",\n            \"Collected in 741 ms\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow20() {\n        test(\"ExampleFlow20\") { kotlinx.coroutines.guide.exampleFlow20.main() }.verifyLines(\n            \"1 -> one\",\n            \"2 -> two\",\n            \"3 -> three\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow21() {\n        test(\"ExampleFlow21\") { kotlinx.coroutines.guide.exampleFlow21.main() }.verifyLinesArbitraryTime(\n            \"1 -> one at 437 ms from start\",\n            \"2 -> two at 837 ms from start\",\n            \"3 -> three at 1243 ms from start\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow22() {\n        test(\"ExampleFlow22\") { kotlinx.coroutines.guide.exampleFlow22.main() }.verifyLinesArbitraryTime(\n            \"1 -> one at 452 ms from start\",\n            \"2 -> one at 651 ms from start\",\n            \"2 -> two at 854 ms from start\",\n            \"3 -> two at 952 ms from start\",\n            \"3 -> three at 1256 ms from start\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow23() {\n        test(\"ExampleFlow23\") { kotlinx.coroutines.guide.exampleFlow23.main() }.verifyLinesArbitraryTime(\n            \"1: First at 121 ms from start\",\n            \"1: Second at 622 ms from start\",\n            \"2: First at 727 ms from start\",\n            \"2: Second at 1227 ms from start\",\n            \"3: First at 1328 ms from start\",\n            \"3: Second at 1829 ms from start\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow24() {\n        test(\"ExampleFlow24\") { kotlinx.coroutines.guide.exampleFlow24.main() }.verifyLinesArbitraryTime(\n            \"1: First at 136 ms from start\",\n            \"2: First at 231 ms from start\",\n            \"3: First at 333 ms from start\",\n            \"1: Second at 639 ms from start\",\n            \"2: Second at 732 ms from start\",\n            \"3: Second at 833 ms from start\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow25() {\n        test(\"ExampleFlow25\") { kotlinx.coroutines.guide.exampleFlow25.main() }.verifyLinesArbitraryTime(\n            \"1: First at 142 ms from start\",\n            \"2: First at 322 ms from start\",\n            \"3: First at 425 ms from start\",\n            \"3: Second at 931 ms from start\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow26() {\n        test(\"ExampleFlow26\") { kotlinx.coroutines.guide.exampleFlow26.main() }.verifyLines(\n            \"Emitting 1\",\n            \"1\",\n            \"Emitting 2\",\n            \"2\",\n            \"Caught java.lang.IllegalStateException: Collected 2\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow27() {\n        test(\"ExampleFlow27\") { kotlinx.coroutines.guide.exampleFlow27.main() }.verifyLines(\n            \"Emitting 1\",\n            \"string 1\",\n            \"Emitting 2\",\n            \"Caught java.lang.IllegalStateException: Crashed on 2\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow28() {\n        test(\"ExampleFlow28\") { kotlinx.coroutines.guide.exampleFlow28.main() }.verifyLines(\n            \"Emitting 1\",\n            \"string 1\",\n            \"Emitting 2\",\n            \"Caught java.lang.IllegalStateException: Crashed on 2\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow29() {\n        test(\"ExampleFlow29\") { kotlinx.coroutines.guide.exampleFlow29.main() }.verifyExceptions(\n            \"Emitting 1\",\n            \"1\",\n            \"Emitting 2\",\n            \"Exception in thread \\\"main\\\" java.lang.IllegalStateException: Collected 2\",\n            \"\\tat ...\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow30() {\n        test(\"ExampleFlow30\") { kotlinx.coroutines.guide.exampleFlow30.main() }.verifyExceptions(\n            \"Emitting 1\",\n            \"1\",\n            \"Emitting 2\",\n            \"Caught java.lang.IllegalStateException: Collected 2\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow31() {\n        test(\"ExampleFlow31\") { kotlinx.coroutines.guide.exampleFlow31.main() }.verifyLines(\n            \"1\",\n            \"2\",\n            \"3\",\n            \"Done\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow32() {\n        test(\"ExampleFlow32\") { kotlinx.coroutines.guide.exampleFlow32.main() }.verifyLines(\n            \"1\",\n            \"2\",\n            \"3\",\n            \"Done\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow33() {\n        test(\"ExampleFlow33\") { kotlinx.coroutines.guide.exampleFlow33.main() }.verifyLines(\n            \"1\",\n            \"Flow completed exceptionally\",\n            \"Caught exception\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow34() {\n        test(\"ExampleFlow34\") { kotlinx.coroutines.guide.exampleFlow34.main() }.verifyExceptions(\n            \"1\",\n            \"Flow completed with java.lang.IllegalStateException: Collected 2\",\n            \"Exception in thread \\\"main\\\" java.lang.IllegalStateException: Collected 2\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow35() {\n        test(\"ExampleFlow35\") { kotlinx.coroutines.guide.exampleFlow35.main() }.verifyLines(\n            \"Event: 1\",\n            \"Event: 2\",\n            \"Event: 3\",\n            \"Done\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow36() {\n        test(\"ExampleFlow36\") { kotlinx.coroutines.guide.exampleFlow36.main() }.verifyLines(\n            \"Done\",\n            \"Event: 1\",\n            \"Event: 2\",\n            \"Event: 3\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow37() {\n        test(\"ExampleFlow37\") { kotlinx.coroutines.guide.exampleFlow37.main() }.verifyExceptions(\n            \"Emitting 1\",\n            \"1\",\n            \"Emitting 2\",\n            \"2\",\n            \"Emitting 3\",\n            \"3\",\n            \"Emitting 4\",\n            \"Exception in thread \\\"main\\\" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=\\\"coroutine#1\\\":BlockingCoroutine{Cancelled}@6d7b4f4c\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow38() {\n        test(\"ExampleFlow38\") { kotlinx.coroutines.guide.exampleFlow38.main() }.verifyExceptions(\n            \"1\",\n            \"2\",\n            \"3\",\n            \"4\",\n            \"5\",\n            \"Exception in thread \\\"main\\\" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=\\\"coroutine#1\\\":BlockingCoroutine{Cancelled}@3327bd23\"\n        )\n    }\n\n    @Test\n    fun testExampleFlow39() {\n        test(\"ExampleFlow39\") { kotlinx.coroutines.guide.exampleFlow39.main() }.verifyExceptions(\n            \"1\",\n            \"2\",\n            \"3\",\n            \"Exception in thread \\\"main\\\" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=\\\"coroutine#1\\\":BlockingCoroutine{Cancelled}@5ec0a365\"\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/test/SelectGuideTest.kt",
        "content": "// This file was automatically generated from select-expression.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass SelectGuideTest {\n    @Test\n    fun testExampleSelect01() {\n        test(\"ExampleSelect01\") { kotlinx.coroutines.guide.exampleSelect01.main() }.verifyLines(\n            \"fizz -> 'Fizz'\",\n            \"buzz -> 'Buzz!'\",\n            \"fizz -> 'Fizz'\",\n            \"fizz -> 'Fizz'\",\n            \"buzz -> 'Buzz!'\",\n            \"fizz -> 'Fizz'\",\n            \"fizz -> 'Fizz'\"\n        )\n    }\n\n    @Test\n    fun testExampleSelect02() {\n        test(\"ExampleSelect02\") { kotlinx.coroutines.guide.exampleSelect02.main() }.verifyLines(\n            \"a -> 'Hello 0'\",\n            \"a -> 'Hello 1'\",\n            \"b -> 'World 0'\",\n            \"a -> 'Hello 2'\",\n            \"a -> 'Hello 3'\",\n            \"b -> 'World 1'\",\n            \"Channel 'a' is closed\",\n            \"Channel 'a' is closed\"\n        )\n    }\n\n    @Test\n    fun testExampleSelect03() {\n        test(\"ExampleSelect03\") { kotlinx.coroutines.guide.exampleSelect03.main() }.verifyLines(\n            \"Consuming 1\",\n            \"Side channel has 2\",\n            \"Side channel has 3\",\n            \"Consuming 4\",\n            \"Side channel has 5\",\n            \"Side channel has 6\",\n            \"Consuming 7\",\n            \"Side channel has 8\",\n            \"Side channel has 9\",\n            \"Consuming 10\",\n            \"Done consuming\"\n        )\n    }\n\n    @Test\n    fun testExampleSelect04() {\n        test(\"ExampleSelect04\") { kotlinx.coroutines.guide.exampleSelect04.main() }.verifyLines(\n            \"Deferred 4 produced answer 'Waited for 128 ms'\",\n            \"11 coroutines are still active\"\n        )\n    }\n\n    @Test\n    fun testExampleSelect05() {\n        test(\"ExampleSelect05\") { kotlinx.coroutines.guide.exampleSelect05.main() }.verifyLines(\n            \"BEGIN\",\n            \"Replace\",\n            \"END\",\n            \"Channel was closed\"\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/guide/test/SharedStateGuideTest.kt",
        "content": "// This file was automatically generated from shared-mutable-state-and-concurrency.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.guide.test\n\nimport kotlinx.coroutines.knit.*\nimport org.junit.Test\n\nclass SharedStateGuideTest {\n    @Test\n    fun testExampleSync01() {\n        test(\"ExampleSync01\") { kotlinx.coroutines.guide.exampleSync01.main() }.verifyLinesStart(\n            \"Completed 100000 actions in\",\n            \"Counter =\"\n        )\n    }\n\n    @Test\n    fun testExampleSync02() {\n        test(\"ExampleSync02\") { kotlinx.coroutines.guide.exampleSync02.main() }.verifyLinesStart(\n            \"Completed 100000 actions in\",\n            \"Counter =\"\n        )\n    }\n\n    @Test\n    fun testExampleSync03() {\n        test(\"ExampleSync03\") { kotlinx.coroutines.guide.exampleSync03.main() }.verifyLinesArbitraryTime(\n            \"Completed 100000 actions in xxx ms\",\n            \"Counter = 100000\"\n        )\n    }\n\n    @Test\n    fun testExampleSync04() {\n        test(\"ExampleSync04\") { kotlinx.coroutines.guide.exampleSync04.main() }.verifyLinesArbitraryTime(\n            \"Completed 100000 actions in xxx ms\",\n            \"Counter = 100000\"\n        )\n    }\n\n    @Test\n    fun testExampleSync05() {\n        test(\"ExampleSync05\") { kotlinx.coroutines.guide.exampleSync05.main() }.verifyLinesArbitraryTime(\n            \"Completed 100000 actions in xxx ms\",\n            \"Counter = 100000\"\n        )\n    }\n\n    @Test\n    fun testExampleSync06() {\n        test(\"ExampleSync06\") { kotlinx.coroutines.guide.exampleSync06.main() }.verifyLinesArbitraryTime(\n            \"Completed 100000 actions in xxx ms\",\n            \"Counter = 100000\"\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/ConcurrentWeakMapCollectionStressTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.testing.*\nimport junit.framework.Assert.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\nimport org.junit.*\nimport kotlin.concurrent.*\n\nclass ConcurrentWeakMapCollectionStressTest : TestBase() {\n    private data class Key(val i: Int)\n    private val nElements = 100_000 * stressTestMultiplier\n    private val size = 100_000\n    \n    @Test\n    fun testCollected() {\n        // use very big arrays as values, we'll need a queue and a cleaner thread to handle them\n        val m = ConcurrentWeakMap<Key, ByteArray>(weakRefQueue = true)\n        val cleaner = thread(name = \"ConcurrentWeakMapCollectionStressTest-Cleaner\") {\n            m.runWeakRefQueueCleaningLoopUntilInterrupted()\n        }\n        for (i in 1..nElements) {\n            m.put(Key(i), ByteArray(size))\n        }\n        assertTrue(m.size < nElements) // some of it was collected for sure\n        cleaner.interrupt()\n        cleaner.join()\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/ConcurrentWeakMapOperationStressTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\nimport org.junit.Test\nimport kotlin.concurrent.*\nimport kotlin.test.*\n\n/**\n * Concurrent test for [ConcurrentWeakMap] that tests put/get/remove from concurrent threads and is\n * arranged so that concurrent rehashing is also happening.\n */\nclass ConcurrentWeakMapOperationStressTest : TestBase() {\n    private val nThreads = 10\n    private val batchSize = 1000\n    private val nSeconds = 3 * stressTestMultiplier\n\n    private val count = atomic(0L)\n    private val stop = atomic(false)\n\n    private data class Key(val i: Long)\n\n    @Test\n    fun testOperations() {\n        // We don't create queue here, because concurrent operations are enough to make it clean itself\n        val m = ConcurrentWeakMap<Key, Long>()\n        val threads = Array(nThreads) { index ->\n            thread(start = false, name = \"ConcurrentWeakMapOperationStressTest-$index\") {\n                var generationOffset = 0L\n                while (!stop.value) {\n                    val kvs = (generationOffset + batchSize * index until generationOffset + batchSize * (index + 1))\n                        .associateBy({ Key(it) }, { it * it })\n                    generationOffset += batchSize * nThreads\n                    for ((k, v) in kvs) {\n                        assertEquals(null, m.put(k, v))\n                    }\n                    for ((k, v) in kvs) {\n                        assertEquals(v, m[k])\n                    }\n                    for ((k, v) in kvs) {\n                        assertEquals(v, m.remove(k))\n                    }\n                    for ((k, _) in kvs) {\n                        assertEquals(null, m[k])\n                    }\n                    count.incrementAndGet()\n                }\n            }\n        }\n        val uncaughtExceptionHandler = Thread.UncaughtExceptionHandler { t, ex ->\n            ex.printStackTrace()\n            error(\"Error in thread $t\", ex)\n        }\n        threads.forEach { it.uncaughtExceptionHandler = uncaughtExceptionHandler }\n        threads.forEach { it.start() }\n        var lastCount = -1L\n        for (sec in 1..nSeconds) {\n            Thread.sleep(1000)\n            val count = count.value\n            println(\"$sec: done $count batches\")\n            assertTrue(count > lastCount) // ensure progress\n            lastCount = count\n        }\n        stop.value = true\n        threads.forEach { it.join() }\n        assertEquals(0, m.size, \"Unexpected map state: $m\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/ConcurrentWeakMapTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.testing.*\nimport junit.framework.Assert.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\nimport org.junit.*\n\nclass ConcurrentWeakMapTest : TestBase() {\n    @Test\n    fun testSimple() {\n        val expect = (1..1000).associate { it.toString().let { it to it } }\n        val m = ConcurrentWeakMap<String, String>()\n        // repeat adding/removing a few times\n        repeat(5) {\n            assertEquals(0, m.size)\n            assertEquals(emptySet<Int>(), m.keys)\n            assertEquals(emptyList<String>(), m.values.toList())\n            assertEquals(emptySet<Map.Entry<Int, String>>(), m.entries)\n            for ((k, v) in expect) {\n                assertNull(m.put(k, v))\n            }\n            assertEquals(expect.size, m.size)\n            assertEquals(expect.keys, m.keys)\n            assertEquals(expect.entries, m.entries)\n            for ((k, v) in expect) {\n                assertEquals(v, m[k])\n            }\n            assertEquals(expect.size, m.size)\n            if (it % 2 == 0) {\n                for ((k, v) in expect) {\n                    assertEquals(v, m.remove(k))\n                }\n            } else {\n                m.clear()\n            }\n            assertEquals(0, m.size)\n            for ((k, _) in expect) {\n                assertNull(m[k])\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/FastServiceLoaderTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass FastServiceLoaderTest : TestBase() {\n    @Test\n    fun testCrossModuleService() {\n        val providers = CoroutineScope::class.java.let { FastServiceLoader.loadProviders(it, it.classLoader) }\n        assertEquals(3, providers.size)\n        val className = \"kotlinx.coroutines.android.EmptyCoroutineScopeImpl\"\n        for (i in 1 .. 3) {\n            assert(providers[i - 1].javaClass.name == \"$className$i\")\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/LockFreeLinkedListLongStressTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.testing.TestBase\nimport org.junit.Test\nimport java.util.*\nimport java.util.concurrent.atomic.AtomicInteger\nimport kotlin.concurrent.thread\n\n/**\n * This stress test has 2 threads adding on one side on list, 2 more threads adding on the other,\n * and 6 threads iterating and concurrently removing items. The resulting list that is being\n * stressed is long.\n */\nclass LockFreeLinkedListLongStressTest : TestBase() {\n    data class IntNode(val i: Int) : LockFreeLinkedListNode()\n    val list = LockFreeLinkedListHead()\n\n    val threads = mutableListOf<Thread>()\n    private val nAdded = 10_000_000 // should not stress more, because that'll run out of memory\n    private val nAddThreads = 4 // must be power of 2 (!!!)\n    private val nRemoveThreads = 6\n    private val removeProbability = 0.2\n    private val workingAdders = AtomicInteger(nAddThreads)\n\n    private fun shallRemove(i: Int) = i and 63 != 42\n\n    @Test\n    fun testStress() {\n        println(\"--- LockFreeLinkedListLongStressTest\")\n        for (j in 0 until nAddThreads)\n            threads += thread(start = false, name = \"adder-$j\") {\n                for (i in j until nAdded step nAddThreads) {\n                    list.addLast(IntNode(i))\n                }\n                println(\"${Thread.currentThread().name} completed\")\n                workingAdders.decrementAndGet()\n            }\n        for (j in 0 until nRemoveThreads)\n            threads += thread(start = false, name = \"remover-$j\") {\n                val rnd = Random()\n                do {\n                    val lastTurn = workingAdders.get() == 0\n                    list.forEach<IntNode> { node ->\n                        if (shallRemove(node.i) && (lastTurn || rnd.nextDouble() < removeProbability))\n                            node.remove()\n                    }\n                } while (!lastTurn)\n                println(\"${Thread.currentThread().name} completed\")\n            }\n        println(\"Starting ${threads.size} threads\")\n        for (thread in threads)\n            thread.start()\n        println(\"Joining threads\")\n        for (thread in threads)\n            thread.join()\n        // verification\n        println(\"Verify result\")\n        list.validate()\n        val expected = iterator {\n            for (i in 0 until nAdded)\n                if (!shallRemove(i))\n                    yield(i)\n        }\n        list.forEach<IntNode> { node ->\n            require(node.i == expected.next())\n        }\n        require(!expected.hasNext())\n    }\n\n    private fun LockFreeLinkedListHead.validate() {\n        var prev: LockFreeLinkedListNode = this\n        var cur: LockFreeLinkedListNode = next as LockFreeLinkedListNode\n        while (cur != this) {\n            val next = cur.nextNode\n            cur.validateNode(prev, next)\n            prev = cur\n            cur = next\n        }\n        validateNode(prev, next as LockFreeLinkedListNode)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/LockFreeTaskQueueStressTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport java.util.concurrent.*\nimport kotlin.concurrent.*\nimport kotlin.test.*\n\n// Tests many short queues to stress copy/resize\n@RunWith(Parameterized::class)\nclass LockFreeTaskQueueStressTest(\n    private val nConsumers: Int\n) : TestBase() {\n    companion object {\n        @Parameterized.Parameters(name = \"nConsumers={0}\")\n        @JvmStatic\n        fun params(): Collection<Int> = listOf(1, 3)\n    }\n\n    private val singleConsumer = nConsumers == 1\n\n    private val nSeconds = 3 * stressTestMultiplier\n    private val nProducers = 4\n    private val batchSize = 100\n\n    private val batch = atomic(0)\n    private val produced = atomic(0L)\n    private val consumed = atomic(0L)\n    private var expected = LongArray(nProducers)\n\n    private val queue = atomic<LockFreeTaskQueue<Item>?>(null)\n    private val done = atomic(0)\n    private val doneProducers = atomic(0)\n\n    private val barrier = CyclicBarrier(nProducers + nConsumers + 1)\n\n    private class Item(val producer: Int, val index: Long)\n\n    @Test\n    fun testStress() {\n        val threads = mutableListOf<Thread>()\n        threads += thread(name = \"Pacer\", start = false) {\n            while (done.value == 0) {\n                queue.value = LockFreeTaskQueue(singleConsumer)\n                batch.value = 0\n                doneProducers.value = 0\n                barrier.await() // start consumers & producers\n                barrier.await() // await consumers & producers\n            }\n            queue.value = null\n            println(\"Pacer done\")\n            barrier.await() // wakeup the rest\n        }\n        threads += List(nConsumers) { consumer ->\n            thread(name = \"Consumer-$consumer\", start = false) {\n                while (true) {\n                    barrier.await()\n                    val queue = queue.value ?: break\n                    while (true) {\n                        val item = queue.removeFirstOrNull()\n                        if (item == null) {\n                            if (doneProducers.value == nProducers && queue.isEmpty) break // that's it\n                            continue // spin to retry\n                        }\n                        consumed.incrementAndGet()\n                        if (singleConsumer) {\n                            // This check only properly works in single-consumer case\n                            val eItem = expected[item.producer]++\n                            if (eItem != item.index) error(\"Expected $eItem but got ${item.index} from Producer-${item.producer}\")\n                        }\n                    }\n                    barrier.await()\n                }\n                println(\"Consumer-$consumer done\")\n            }\n        }\n        threads += List(nProducers) { producer ->\n            thread(name = \"Producer-$producer\", start = false) {\n                var index = 0L\n                while (true) {\n                    barrier.await()\n                    val queue = queue.value ?: break\n                    while (true) {\n                        if (batch.incrementAndGet() >= batchSize) break\n                        check(queue.addLast(Item(producer, index++))) // never closed\n                        produced.incrementAndGet()\n                    }\n                    doneProducers.incrementAndGet()\n                    barrier.await()\n                }\n                println(\"Producer-$producer done\")\n            }\n        }\n        threads.forEach {\n            it.setUncaughtExceptionHandler { t, e ->\n                System.err.println(\"Thread $t failed: $e\")\n                e.printStackTrace()\n                done.value = 1\n                error(\"Thread $t failed\", e)\n            }\n        }\n        threads.forEach { it.start() }\n        for (second in 1..nSeconds) {\n            Thread.sleep(1000)\n            println(\"$second: produced=${produced.value}, consumed=${consumed.value}\")\n            if (done.value == 1) break\n        }\n        done.value = 1\n        threads.forEach { it.join() }\n        println(\"T: produced=${produced.value}, consumed=${consumed.value}\")\n        assertEquals(produced.value, consumed.value)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/LockFreeTaskQueueTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass LockFreeTaskQueueTest(\n    private val singleConsumer: Boolean\n) : TestBase() {\n    companion object {\n        @Parameterized.Parameters(name = \"singleConsumer={0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = listOf(\n            arrayOf<Any>(false),\n            arrayOf<Any>(true)\n        )\n    }\n\n    @Test\n    fun testBasic() {\n        val q = LockFreeTaskQueue<Int>(singleConsumer)\n        assertTrue(q.isEmpty)\n        assertEquals(0, q.size)\n        assertTrue(q.addLast(1))\n        assertFalse(q.isEmpty)\n        assertEquals(1, q.size)\n        assertTrue(q.addLast(2))\n        assertFalse(q.isEmpty)\n        assertEquals(2, q.size)\n        assertTrue(q.addLast(3))\n        assertFalse(q.isEmpty)\n        assertEquals(3, q.size)\n        assertEquals(1, q.removeFirstOrNull())\n        assertFalse(q.isEmpty)\n        assertEquals(2, q.size)\n        assertEquals(2, q.removeFirstOrNull())\n        assertFalse(q.isEmpty)\n        assertEquals(1, q.size)\n        assertTrue(q.addLast(4))\n        assertFalse(q.isEmpty)\n        assertEquals(2, q.size)\n        q.close()\n        assertFalse(q.isEmpty)\n        assertEquals(2, q.size)\n        assertFalse(q.addLast(5))\n        assertFalse(q.isEmpty)\n        assertEquals(2, q.size)\n        assertEquals(3, q.removeFirstOrNull())\n        assertFalse(q.isEmpty)\n        assertEquals(1, q.size)\n        assertEquals(4, q.removeFirstOrNull())\n        assertTrue(q.isEmpty)\n        assertEquals(0, q.size)\n    }\n\n    @Test\n    fun testCopyGrow() {\n        val n = 1000 * stressTestMultiplier\n        val q = LockFreeTaskQueue<Int>(singleConsumer)\n        assertTrue(q.isEmpty)\n        repeat(n) { i ->\n            assertTrue(q.addLast(i))\n            assertFalse(q.isEmpty)\n        }\n        repeat(n) { i ->\n            assertEquals(i, q.removeFirstOrNull())\n        }\n        assertTrue(q.isEmpty)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/OnDemandAllocatingPoolLincheckTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport org.jetbrains.kotlinx.lincheck.*\nimport org.jetbrains.kotlinx.lincheck.annotations.*\n\n/**\n * Test that:\n * - All elements allocated in [OnDemandAllocatingPool] get returned when [close] is invoked.\n * - After reaching the maximum capacity, new elements are not added.\n * - After [close] is invoked, [OnDemandAllocatingPool.allocate] returns `false`.\n * - [OnDemandAllocatingPool.close] will return an empty list after the first invocation.\n */\nabstract class OnDemandAllocatingPoolLincheckTest(maxCapacity: Int) : AbstractLincheckTest() {\n    private val counter = atomic(0)\n    private val pool = OnDemandAllocatingPool(maxCapacity = maxCapacity, create = {\n        counter.getAndIncrement()\n    })\n\n    @Operation\n    fun allocate(): Boolean = pool.allocate()\n\n    @Operation\n    fun close(): String = pool.close().sorted().toString()\n}\n\nabstract class OnDemandAllocatingSequentialPool(private val maxCapacity: Int) {\n    var closed = false\n    var elements = 0\n\n    fun allocate() = if (closed) {\n        false\n    } else {\n        if (elements < maxCapacity) {\n            elements++\n        }\n        true\n    }\n\n    fun close(): String = if (closed) {\n        emptyList()\n    } else {\n        closed = true\n        (0 until elements)\n    }.sorted().toString()\n}\n\nclass OnDemandAllocatingPool3LincheckTest : OnDemandAllocatingPoolLincheckTest(3) {\n    override fun <O : Options<O, *>> O.customize(isStressTest: Boolean): O =\n        this.sequentialSpecification(OnDemandAllocatingSequentialPool3::class.java)\n}\n\nclass OnDemandAllocatingSequentialPool3 : OnDemandAllocatingSequentialPool(3)\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/ThreadSafeHeapStressTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport java.util.concurrent.*\nimport java.util.concurrent.CancellationException\nimport kotlin.test.*\n\nclass ThreadSafeHeapStressTest : TestBase() {\n    private class DisposableNode : EventLoopImplBase.DelayedTask(1L) {\n        override fun run() {\n        }\n    }\n\n    @Test\n    fun testConcurrentRemoveDispose() = runTest {\n        val heap = EventLoopImplBase.DelayedTaskQueue(1)\n        repeat(10_000 * stressTestMultiplierSqrt) {\n            withContext(Dispatchers.Default) {\n                val node = DisposableNode()\n                val barrier = CyclicBarrier(2)\n                launch {\n                    heap.addLast(node)\n                    barrier.await()\n                    heap.remove(node)\n                }\n                launch {\n                    barrier.await()\n                    Thread.yield()\n                    node.dispose()\n                }\n            }\n        }\n    }\n\n    @Test()\n    fun testConcurrentAddDispose() = runTest {\n        repeat(10_000 * stressTestMultiplierSqrt) {\n            val jobToCancel = Job()\n            val barrier = CyclicBarrier(2)\n            val jobToJoin = launch(Dispatchers.Default) {\n                barrier.await()\n                jobToCancel.cancelAndJoin()\n            }\n\n            try {\n                runBlocking { // Use event loop impl\n                    withContext(jobToCancel) {\n                        // This one is to work around heap allocation optimization\n                        launch(start = CoroutineStart.UNDISPATCHED) {\n                            delay(100_000)\n                        }\n                        barrier.await()\n                        delay(100_000)\n                    }\n                }\n            } catch (e: CancellationException) {\n                // Expected exception\n            }\n            jobToJoin.join()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/internal/ThreadSafeHeapTest.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\nimport java.util.*\n\nclass ThreadSafeHeapTest : TestBase() {\n    internal class Node(val value: Int) : ThreadSafeHeapNode, Comparable<Node> {\n        override var heap: ThreadSafeHeap<*>? = null\n        override var index = -1\n        override fun compareTo(other: Node): Int = value.compareTo(other.value)\n        override fun equals(other: Any?): Boolean = other is Node && other.value == value\n        override fun hashCode(): Int = value\n        override fun toString(): String = \"$value\"\n    }\n\n    @Test\n    fun testBasic() {\n        val h = ThreadSafeHeap<Node>()\n        assertNull(h.peek())\n        val n1 = Node(1)\n        h.addLast(n1)\n        assertEquals(n1, h.peek())\n        val n2 = Node(2)\n        h.addLast(n2)\n        assertEquals(n1, h.peek())\n        val n3 = Node(3)\n        h.addLast(n3)\n        assertEquals(n1, h.peek())\n        val n4 = Node(4)\n        h.addLast(n4)\n        assertEquals(n1, h.peek())\n        val n5 = Node(5)\n        h.addLast(n5)\n        assertEquals(n1, h.peek())\n        assertEquals(n1, h.removeFirstOrNull())\n        assertEquals(-1, n1.index)\n        assertEquals(n2, h.peek())\n        h.remove(n2)\n        assertEquals(n3, h.peek())\n        h.remove(n4)\n        assertEquals(n3, h.peek())\n        h.remove(n3)\n        assertEquals(n5, h.peek())\n        h.remove(n5)\n        assertNull(h.peek())\n    }\n\n    @Test\n    fun testRandomSort() {\n        val n = 1000 * stressTestMultiplier\n        val r = Random(1)\n        val h = ThreadSafeHeap<Node>()\n        val a = IntArray(n) { r.nextInt() }\n        repeat(n) { h.addLast(Node(a[it])) }\n        a.sort()\n        repeat(n) { assertEquals(Node(a[it]), h.removeFirstOrNull()) }\n        assertNull(h.peek())\n    }\n\n    @Test\n    fun testRandomRemove() {\n        val n = 1000 * stressTestMultiplier\n        check(n % 2 == 0) { \"Must be even\" }\n        val r = Random(1)\n        val h = ThreadSafeHeap<Node>()\n        val set = TreeSet<Node>()\n        repeat(n) {\n            val node = Node(r.nextInt())\n            h.addLast(node)\n            assertTrue(set.add(node))\n        }\n        while (!h.isEmpty) {\n            // pick random node to remove\n            val rndNode: Node\n            while (true) {\n                val tail = set.tailSet(Node(r.nextInt()))\n                if (!tail.isEmpty()) {\n                    rndNode = tail.first()\n                    break\n                }\n            }\n            assertTrue(set.remove(rndNode))\n            assertTrue(h.remove(rndNode))\n            // remove head and validate\n            val headNode = h.removeFirstOrNull()!! // must not be null!!!\n            assertSame(headNode, set.first(), \"Expected ${set.first()}, but found $headNode, remaining size ${h.size}\")\n            assertTrue(set.remove(headNode))\n            assertEquals(set.size, h.size)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/jdk8/future/AsFutureTest.kt",
        "content": "package kotlinx.coroutines.future\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport java.util.concurrent.CancellationException\nimport kotlin.test.*\n\nclass AsFutureTest : TestBase() {\n\n    @Test\n    fun testCompletedDeferredAsCompletableFuture() = runTest {\n        expect(1)\n        val deferred = async(start = CoroutineStart.UNDISPATCHED) {\n            expect(2) // completed right away\n            \"OK\"\n        }\n        expect(3)\n        val future = deferred.asCompletableFuture()\n        assertEquals(\"OK\", future.await())\n        finish(4)\n    }\n\n    @Test\n    fun testCompletedJobAsCompletableFuture() = runTest {\n        val job = Job().apply { complete() }\n        val future = job.asCompletableFuture()\n        assertEquals(Unit, future.await())\n    }\n\n    @Test\n    fun testWaitForDeferredAsCompletableFuture() = runTest {\n        expect(1)\n        val deferred = async {\n            expect(3) // will complete later\n            \"OK\"\n        }\n        expect(2)\n        val future = deferred.asCompletableFuture()\n        assertEquals(\"OK\", future.await()) // await yields main thread to deferred coroutine\n        finish(4)\n    }\n\n    @Test\n    fun testWaitForJobAsCompletableFuture() = runTest {\n        val job = Job()\n        val future = job.asCompletableFuture()\n        assertTrue(job.isActive)\n        job.complete()\n        assertFalse(job.isActive)\n        assertEquals(Unit, future.await())\n    }\n\n    @Test\n    fun testAsCompletableFutureThrowable() {\n        val deferred = GlobalScope.async<Unit> { throw OutOfMemoryError() }\n        val future = deferred.asCompletableFuture()\n        try {\n            expect(1)\n            future.get()\n            expectUnreached()\n        } catch (e: ExecutionException) {\n            assertTrue(future.isCompletedExceptionally)\n            assertIs<OutOfMemoryError>(e.cause)\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testJobAsCompletableFutureThrowable() {\n        val job = Job()\n        CompletableDeferred<Unit>(parent = job).apply { completeExceptionally(OutOfMemoryError()) }\n        val future = job.asCompletableFuture()\n        try {\n            expect(1)\n            future.get()\n            expectUnreached()\n        } catch (e: ExecutionException) {\n            assertTrue(future.isCompletedExceptionally)\n            assertIs<OutOfMemoryError>(e.cause)\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testJobAsCompletableFutureCancellation() {\n        val job = Job()\n        val future = job.asCompletableFuture()\n        job.cancel()\n        try {\n            expect(1)\n            future.get()\n            expectUnreached()\n        } catch (e: CancellationException) {\n            assertTrue(future.isCompletedExceptionally)\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testJobCancellation() {\n        val job = Job()\n        val future = job.asCompletableFuture()\n        future.cancel(true)\n        assertTrue(job.isCancelled)\n        assertTrue(job.isCompleted)\n        assertFalse(job.isActive)\n    }\n\n    @Test\n    fun testDeferredCancellation() {\n        val deferred = CompletableDeferred<Int>()\n        val future = deferred.asCompletableFuture()\n        future.cancel(true)\n        assertTrue(deferred.isCancelled)\n        assertTrue(deferred.isCompleted)\n        assertFalse(deferred.isActive)\n        assertIs<CancellationException>(deferred.getCompletionExceptionOrNull())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/jdk8/future/FutureAsDeferredUnhandledCompletionExceptionTest.kt",
        "content": "package kotlinx.coroutines.future\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.future.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass FutureAsDeferredUnhandledCompletionExceptionTest : TestBase() {\n\n    // This is a separate test in order to avoid interference with uncaught exception handlers in other tests\n    private val exceptionHandler = Thread.getDefaultUncaughtExceptionHandler()\n    private lateinit var caughtException: Throwable\n\n    @Before\n    fun setUp() {\n        Thread.setDefaultUncaughtExceptionHandler { _, e -> caughtException = e }\n    }\n\n    @After\n    fun tearDown() {\n        Thread.setDefaultUncaughtExceptionHandler(exceptionHandler)\n    }\n\n    @Test\n    fun testLostException() = runTest {\n        val future = CompletableFuture<Int>()\n        val deferred = future.asDeferred()\n        deferred.invokeOnCompletion { throw TestException() }\n        future.complete(1)\n        assertTrue { caughtException is CompletionHandlerException && caughtException.cause is TestException }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/jdk8/future/FutureExceptionsTest.kt",
        "content": "package kotlinx.coroutines.future\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.io.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass FutureExceptionsTest : TestBase() {\n\n    @Test\n    fun testAwait() {\n        testException(IOException(), { it is IOException })\n    }\n\n    @Test\n    fun testAwaitChained() {\n        testException(IOException(), { it is IOException }, { f -> f.thenApply { it + 1 } })\n    }\n\n    @Test\n    fun testAwaitDeepChain() {\n        testException(IOException(), { it is IOException },\n            { f -> f\n                .thenApply { it + 1 }\n                .thenApply { it + 2 } })\n    }\n\n    @Test\n    fun testAwaitCompletionException() {\n        testException(CompletionException(\"test\", IOException()), { it is IOException })\n    }\n\n    @Test\n    fun testAwaitChainedCompletionException() {\n        testException(CompletionException(\"test\", IOException()), { it is IOException }, { f -> f.thenApply { it + 1 } })\n    }\n\n    @Test\n    fun testAwaitTestException() {\n        testException(TestException(), { it is TestException })\n    }\n\n    @Test\n    fun testAwaitChainedTestException() {\n        testException(TestException(), { it is TestException }, { f -> f.thenApply { it + 1 } })\n    }\n\n    private fun testException(\n        exception: Throwable,\n        expected: ((Throwable) -> Boolean),\n        transformer: (CompletableFuture<Int>) -> CompletableFuture<Int> = { it }\n    ) {\n\n        // Fast path\n        runTest {\n            val future = CompletableFuture<Int>()\n            val chained = transformer(future)\n            future.completeExceptionally(exception)\n            try {\n                chained.await()\n            } catch (e: Throwable) {\n                assertTrue(expected(e))\n            }\n        }\n\n        // Slow path\n        runTest {\n            val future = CompletableFuture<Int>()\n            val chained = transformer(future)\n\n            launch {\n                future.completeExceptionally(exception)\n            }\n\n            try {\n                chained.await()\n            } catch (e: Throwable) {\n                assertTrue(expected(e))\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/jdk8/future/FutureTest.kt",
        "content": "package kotlinx.coroutines.future\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport org.junit.*\nimport org.junit.Test\nimport java.lang.IllegalArgumentException\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport java.util.concurrent.locks.*\nimport java.util.function.*\nimport kotlin.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.reflect.*\nimport kotlin.test.*\n\nclass FutureTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"ForkJoinPool.commonPool-worker-\")\n    }\n\n    @Test\n    fun testSimpleAwait() {\n        val future = GlobalScope.future {\n            CompletableFuture.supplyAsync {\n                \"O\"\n            }.await() + \"K\"\n        }\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testCompletedFuture() {\n        val toAwait = CompletableFuture<String>()\n        toAwait.complete(\"O\")\n        val future = GlobalScope.future {\n            toAwait.await() + \"K\"\n        }\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testCompletedCompletionStage() {\n        val completable = CompletableFuture<String>()\n        completable.complete(\"O\")\n        val toAwait: CompletionStage<String> = completable\n        val future = GlobalScope.future {\n            toAwait.await() + \"K\"\n        }\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testWaitForFuture() {\n        val toAwait = CompletableFuture<String>()\n        val future = GlobalScope.future {\n            toAwait.await() + \"K\"\n        }\n        assertFalse(future.isDone)\n        toAwait.complete(\"O\")\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testWaitForCompletionStage() {\n        val completable = CompletableFuture<String>()\n        val toAwait: CompletionStage<String> = completable\n        val future = GlobalScope.future {\n            toAwait.await() + \"K\"\n        }\n        assertFalse(future.isDone)\n        completable.complete(\"O\")\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testCompletedFutureExceptionally() {\n        val toAwait = CompletableFuture<String>()\n        toAwait.completeExceptionally(TestException(\"O\"))\n        val future = GlobalScope.future {\n            try {\n                toAwait.await()\n            } catch (e: TestException) {\n                e.message!!\n            } + \"K\"\n        }\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    // Test fast-path of CompletionStage.await() extension\n    fun testCompletedCompletionStageExceptionally() {\n        val completable = CompletableFuture<String>()\n        val toAwait: CompletionStage<String> = completable\n        completable.completeExceptionally(TestException(\"O\"))\n        val future = GlobalScope.future {\n            try {\n                toAwait.await()\n            } catch (e: TestException) {\n                e.message!!\n            } + \"K\"\n        }\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    // Test slow-path of CompletionStage.await() extension\n    fun testWaitForFutureWithException() = runTest {\n        expect(1)\n        val toAwait = CompletableFuture<String>()\n        val future = future(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                toAwait.await() // will suspend (slow path)\n            } catch (e: TestException) {\n                expect(4)\n                e.message!!\n            } + \"K\"\n        }\n        expect(3)\n        assertFalse(future.isDone)\n        toAwait.completeExceptionally(TestException(\"O\"))\n        yield() // to future coroutine\n        assertEquals(\"OK\", future.get())\n        finish(5)\n    }\n\n    @Test\n    fun testWaitForCompletionStageWithException() {\n        val completable = CompletableFuture<String>()\n        val toAwait: CompletionStage<String> = completable\n        val future = GlobalScope.future {\n            try {\n                toAwait.await()\n            } catch (e: TestException) {\n                e.message!!\n            } + \"K\"\n        }\n        assertFalse(future.isDone)\n        completable.completeExceptionally(TestException(\"O\"))\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testExceptionInsideCoroutine() {\n        val future = GlobalScope.future {\n            if (CompletableFuture.supplyAsync { true }.await()) {\n                throw IllegalStateException(\"OK\")\n            }\n            \"fail\"\n        }\n        try {\n            future.get()\n            fail(\"'get' should've throw an exception\")\n        } catch (e: ExecutionException) {\n            assertIs<IllegalStateException>(e.cause)\n            assertEquals(\"OK\", e.cause!!.message)\n        }\n    }\n\n    @Test\n    fun testCancellableAwaitFuture() = runBlocking {\n        expect(1)\n        val toAwait = CompletableFuture<String>()\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            try {\n                toAwait.await() // suspends\n            } catch (e: CancellationException) {\n                expect(5) // should throw cancellation exception\n                throw e\n            }\n        }\n        expect(3)\n        job.cancel() // cancel the job\n        toAwait.complete(\"fail\") // too late, the waiting job was already cancelled\n        expect(4) // job processing of cancellation was scheduled, not executed yet\n        yield() // yield main thread to job\n        finish(6)\n    }\n\n    @Test\n    fun testContinuationWrapped() {\n        val depth = AtomicInteger()\n        val future = GlobalScope.future(wrapContinuation {\n            depth.andIncrement\n            it()\n            depth.andDecrement\n        }) {\n            assertEquals(1, depth.get(), \"Part before first suspension must be wrapped\")\n            val result =\n                    CompletableFuture.supplyAsync {\n                        while (depth.get() > 0);\n                        assertEquals(0, depth.get(), \"Part inside suspension point should not be wrapped\")\n                        \"OK\"\n                    }.await()\n            assertEquals(1, depth.get(), \"Part after first suspension should be wrapped\")\n            CompletableFuture.supplyAsync {\n                while (depth.get() > 0);\n                assertEquals(0, depth.get(), \"Part inside suspension point should not be wrapped\")\n                \"ignored\"\n            }.await()\n            result\n        }\n        assertEquals(\"OK\", future.get())\n    }\n\n    @Test\n    fun testCompletableFutureStageAsDeferred() = runBlocking {\n        val lock = ReentrantLock().apply { lock() }\n\n        val deferred: Deferred<Int> = CompletableFuture.supplyAsync {\n            lock.withLock { 42 }\n        }.asDeferred()\n\n        assertFalse(deferred.isCompleted)\n        lock.unlock()\n\n        assertEquals(42, deferred.await())\n        assertTrue(deferred.isCompleted)\n    }\n\n    @Test\n    fun testCompletedFutureAsDeferred() = runBlocking {\n        val deferred: Deferred<Int> = CompletableFuture.completedFuture(42).asDeferred()\n        assertEquals(42, deferred.await())\n    }\n\n    @Test\n    fun testFailedFutureAsDeferred() = runBlocking {\n        val future = CompletableFuture<Int>().apply {\n            completeExceptionally(TestException(\"something went wrong\"))\n        }\n        val deferred = future.asDeferred()\n\n        assertTrue(deferred.isCancelled)\n        val completionException = deferred.getCompletionExceptionOrNull()!!\n        assertIs<TestException>(completionException)\n        assertEquals(\"something went wrong\", completionException.message)\n\n        try {\n            deferred.await()\n            fail(\"deferred.await() should throw an exception\")\n        } catch (e: Throwable) {\n            assertIs<TestException>(e)\n            assertEquals(\"something went wrong\", e.message)\n        }\n    }\n\n    @Test\n    fun testCompletableFutureWithExceptionAsDeferred() = runBlocking {\n        val lock = ReentrantLock().apply { lock() }\n\n        val deferred: Deferred<Int> = CompletableFuture.supplyAsync {\n            lock.withLock { throw TestException(\"something went wrong\") }\n        }.asDeferred()\n\n        assertFalse(deferred.isCompleted)\n        lock.unlock()\n        try {\n            deferred.await()\n            fail(\"deferred.await() should throw an exception\")\n        } catch (e: TestException) {\n            assertTrue(deferred.isCancelled)\n            assertEquals(\"something went wrong\", e.message)\n        }\n    }\n\n    private val threadLocal = ThreadLocal<String>()\n\n    @Test\n    fun testApiBridge() = runTest {\n        val result = newSingleThreadContext(\"ctx\").use {\n            val future = CompletableFuture.supplyAsync(Supplier { threadLocal.set(\"value\") }, it.executor)\n            val job = async(it) {\n                future.await()\n                threadLocal.get()\n            }\n\n            job.await()\n        }\n\n        assertEquals(\"value\", result)\n    }\n\n    @Test\n    fun testFutureCancellation() = runTest {\n        val future = awaitFutureWithCancel(true)\n        assertTrue(future.isCompletedExceptionally)\n        assertFailsWith<CancellationException> { future.get() }\n        finish(4)\n    }\n\n    @Test\n    fun testNoFutureCancellation() = runTest {\n        val future = awaitFutureWithCancel(false)\n        assertFalse(future.isCompletedExceptionally)\n        assertEquals(239, future.get())\n        finish(4)\n    }\n\n    private suspend fun CoroutineScope.awaitFutureWithCancel(cancellable: Boolean): CompletableFuture<Int> {\n        val latch = CountDownLatch(1)\n        val future = CompletableFuture.supplyAsync {\n            latch.await()\n            239\n        }\n\n        val deferred = async {\n            expect(2)\n            if (cancellable) future.await()\n            else future.asDeferred().await()\n        }\n        expect(1)\n        yield()\n        deferred.cancel()\n        expect(3)\n        latch.countDown()\n        return future\n    }\n\n    @Test\n    fun testStructuredException() = runTest(\n        expected = { it is TestException } // exception propagates to parent with structured concurrency\n    ) {\n        val result = future<Int>(Dispatchers.Unconfined) {\n            throw TestException(\"FAIL\")\n        }\n        result.checkFutureException<TestException>()\n    }\n\n    @Test\n    fun testChildException() = runTest(\n        expected = { it is TestException } // exception propagates to parent with structured concurrency\n    ) {\n        val result = future(Dispatchers.Unconfined) {\n            // child crashes\n            launch { throw TestException(\"FAIL\") }\n            42\n        }\n        result.checkFutureException<TestException>()\n    }\n\n    @Test\n    fun testExceptionAggregation() = runTest(\n        expected = { it is TestException } // exception propagates to parent with structured concurrency\n    ) {\n        val result = future(Dispatchers.Unconfined) {\n            // child crashes\n            launch(start = CoroutineStart.ATOMIC) { throw TestException1(\"FAIL\") }\n            launch(start = CoroutineStart.ATOMIC) { throw TestException2(\"FAIL\") }\n            throw TestException()\n        }\n        result.checkFutureException<TestException>(TestException1::class, TestException2::class)\n        finish(1)\n    }\n\n    @Test\n    fun testExternalCompletion() = runTest {\n        expect(1)\n        val result = future(Dispatchers.Unconfined) {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                expect(2)\n            }\n        }\n\n        result.complete(Unit)\n        finish(3)\n    }\n\n    @Test\n    fun testExceptionOnExternalCompletion() = runTest(\n        expected = { it is TestException } // exception propagates to parent with structured concurrency\n    ) {\n        expect(1)\n        val result = future(Dispatchers.Unconfined) {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                expect(2)\n                throw TestException()\n            }\n        }\n        result.complete(Unit)\n        finish(3)\n    }\n\n    @Test\n    fun testUnhandledExceptionOnExternalCompletionIsNotReported() = runTest {\n        expect(1)\n        // No parent here (NonCancellable), so nowhere to propagate exception\n        val result = future(NonCancellable + Dispatchers.Unconfined) {\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                expect(2)\n                throw TestException() // this exception cannot be handled\n            }\n        }\n        result.complete(Unit)\n        finish(3)\n    }\n\n    /**\n     * See [https://github.com/Kotlin/kotlinx.coroutines/issues/892]\n     */\n    @Test\n    fun testTimeoutCancellationFailRace() {\n        repeat(10 * stressTestMultiplier) {\n            runBlocking {\n                withTimeoutOrNull(10) {\n                    while (true) {\n                        var caught = false\n                        try {\n                            CompletableFuture.supplyAsync {\n                                throw TestException()\n                            }.await()\n                        } catch (ignored: TestException) {\n                            caught = true\n                        }\n                        assertTrue(caught) // should have caught TestException or timed out\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Tests that both [CompletionStage.await] and [CompletionStage.asDeferred] consistently unwrap\n     * [CompletionException] both in their slow and fast paths.\n     * See [issue #1479](https://github.com/Kotlin/kotlinx.coroutines/issues/1479).\n     */\n    @Test\n    fun testConsistentExceptionUnwrapping() = runTest {\n        expect(1)\n        // Check the fast path\n        val fFast = CompletableFuture.supplyAsync {\n            expect(2)\n            throw TestException()\n        }\n        fFast.checkFutureException<TestException>() // wait until it completes\n        // Fast path in await and asDeferred.await() shall produce TestException\n        expect(3)\n        val dFast = fFast.asDeferred()\n        assertFailsWith<TestException> { fFast.await() }\n        assertFailsWith<TestException> { dFast.await() }\n        // Same test, but future has not completed yet, check the slow path\n        expect(4)\n        val barrier = CyclicBarrier(2)\n        val fSlow = CompletableFuture.supplyAsync {\n            barrier.await()\n            expect(6)\n            throw TestException()\n        }\n        val dSlow = fSlow.asDeferred()\n        launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(5)\n            // Slow path on await shall produce TestException, too\n            assertFailsWith<TestException> { fSlow.await() } // will suspend here\n            assertFailsWith<TestException> { dSlow.await() }\n            finish(7)\n        }\n        barrier.await()\n        fSlow.checkFutureException<TestException>() // now wait until it completes\n    }\n\n    private inline fun <reified T: Throwable> CompletableFuture<*>.checkFutureException(vararg suppressed: KClass<out Throwable>) {\n        val e = assertFailsWith<ExecutionException> { get() }\n        val cause = e.cause!!\n        assertIs<T>(cause)\n        for ((index, clazz) in suppressed.withIndex()) {\n            assertTrue(clazz.isInstance(cause.suppressed[index]))\n        }\n    }\n\n    private fun wrapContinuation(wrapper: (() -> Unit) -> Unit): CoroutineDispatcher = object : CoroutineDispatcher() {\n        override fun dispatch(context: CoroutineContext, block: Runnable) {\n            wrapper {\n                block.run()\n            }\n        }\n    }\n\n    /**\n     * https://github.com/Kotlin/kotlinx.coroutines/issues/2456\n     */\n    @Test\n    fun testCompletedStageAwait() = runTest {\n        val stage = CompletableFuture.completedStage(\"OK\")\n        assertEquals(\"OK\", stage.await())\n    }\n\n    /**\n     * https://github.com/Kotlin/kotlinx.coroutines/issues/2456\n     */\n    @Test\n    fun testCompletedStageAsDeferredAwait() = runTest {\n        val stage = CompletableFuture.completedStage(\"OK\")\n        val deferred = stage.asDeferred()\n        assertEquals(\"OK\", deferred.await())\n    }\n\n    @Test\n    fun testCompletedStateThenApplyAwait() = runTest {\n        expect(1)\n        val cf = CompletableFuture<String>()\n        launch {\n            expect(3)\n            cf.complete(\"O\")\n        }\n        expect(2)\n        val stage = cf.thenApply { it + \"K\" }\n        assertEquals(\"OK\", stage.await())\n        finish(4)\n    }\n\n    @Test\n    fun testCompletedStateThenApplyAwaitCancel() = runTest {\n        expect(1)\n        val cf = CompletableFuture<String>()\n        launch {\n            expect(3)\n            cf.cancel(false)\n        }\n        expect(2)\n        val stage = cf.thenApply { it + \"K\" }\n        assertFailsWith<CancellationException> { stage.await() }\n        finish(4)\n    }\n\n    @Test\n    fun testCompletedStateThenApplyAsDeferredAwait() = runTest {\n        expect(1)\n        val cf = CompletableFuture<String>()\n        launch {\n            expect(3)\n            cf.complete(\"O\")\n        }\n        expect(2)\n        val stage = cf.thenApply { it + \"K\" }\n        val deferred = stage.asDeferred()\n        assertEquals(\"OK\", deferred.await())\n        finish(4)\n    }\n\n    @Test\n    fun testCompletedStateThenApplyAsDeferredAwaitCancel() = runTest {\n        expect(1)\n        val cf = CompletableFuture<String>()\n        expect(2)\n        val stage = cf.thenApply { it + \"K\" }\n        val deferred = stage.asDeferred()\n        launch {\n            expect(3)\n            deferred.cancel() // cancel the deferred!\n        }\n        assertFailsWith<CancellationException> { stage.await() }\n        finish(4)\n    }\n\n    @Test\n    fun testCancelledParent() = runTest({ it is java.util.concurrent.CancellationException }) {\n        cancel()\n        future { expectUnreached() }\n        future(start = CoroutineStart.ATOMIC) { }\n        future(start = CoroutineStart.UNDISPATCHED) { }\n    }\n\n    @Test\n    fun testStackOverflow() = runTest {\n        val future = CompletableFuture<Int>()\n        val completed = AtomicLong()\n        val count = 10000L\n        val children = ArrayList<Job>()\n        for (i in 0 until count) {\n            children += launch(Dispatchers.Default) {\n                future.asDeferred().await()\n                completed.incrementAndGet()\n            }\n        }\n        future.complete(1)\n        withTimeout(60_000) {\n            children.forEach { it.join() }\n            assertEquals(count, completed.get())\n        }\n    }\n\n    @Test\n    fun testFailsIfLazy() {\n        assertFailsWith<IllegalArgumentException> {\n            GlobalScope.future<Unit>(start = CoroutineStart.LAZY) {  }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/jdk8/stream/ConsumeAsFlowTest.kt",
        "content": "package kotlinx.coroutines.stream\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.Test\nimport java.lang.IllegalStateException\nimport kotlin.test.*\n\nclass ConsumeAsFlowTest : TestBase() {\n\n    @Test\n    fun testCollect() = runTest {\n        val list = listOf(1, 2, 3)\n        assertEquals(list, list.stream().consumeAsFlow().toList())\n    }\n\n    @Test\n    fun testCollectInvokesClose() = runTest {\n        val list = listOf(3, 4, 5)\n        expect(1)\n        assertEquals(list, list.stream().onClose { expect(2) }.consumeAsFlow().toList())\n        finish(3)\n    }\n\n    @Test\n    fun testCollectTwice() = runTest {\n        val list = listOf(2, 3, 9)\n        val flow = list.stream().onClose { expect(2) } .consumeAsFlow()\n        expect(1)\n        assertEquals(list, flow.toList())\n        assertFailsWith<IllegalStateException> { flow.collect() }\n        finish(3)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/jdk8/time/DurationOverflowTest.kt",
        "content": "package kotlinx.coroutines.time\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.Test\nimport java.time.*\nimport java.time.temporal.*\nimport kotlin.test.*\n\nclass DurationOverflowTest : TestBase() {\n\n    private val durations = ChronoUnit.values().map { it.duration }\n\n    @Test\n    fun testDelay() = runTest {\n        var counter = 0\n        for (duration in durations) {\n            expect(++counter)\n            delay(duration.negated()) // Instant bail out from negative values\n            launch(start = CoroutineStart.UNDISPATCHED) {\n                expect(++counter)\n                delay(duration)\n            }.cancelAndJoin()\n            expect(++counter)\n        }\n\n        finish(++counter)\n    }\n\n    @Test\n    fun testOnTimeout() = runTest {\n        for (duration in durations) {\n            // Does not crash on overflows\n            select<Unit> {\n                onTimeout(duration) {}\n                onTimeout(duration.negated()) {}\n            }\n        }\n    }\n\n    @Test\n    fun testWithTimeout() = runTest {\n        for (duration in durations) {\n            withTimeout(duration) {}\n        }\n    }\n\n    @Test\n    fun testWithTimeoutOrNull() = runTest {\n        for (duration in durations) {\n            withTimeoutOrNull(duration) {}\n        }\n    }\n\n    @Test\n    fun testWithTimeoutOrNullNegativeDuration() = runTest {\n        val result = withTimeoutOrNull(Duration.ofSeconds(1).negated()) {\n            1\n        }\n\n        assertNull(result)\n    }\n\n    @Test\n    fun testZeroDurationWithTimeout() = runTest {\n        assertFailsWith<TimeoutCancellationException> { withTimeout(0L) {} }\n        assertFailsWith<TimeoutCancellationException> { withTimeout(Duration.ZERO) {} }\n    }\n\n    @Test\n    fun testZeroDurationWithTimeoutOrNull() = runTest {\n        assertNull(withTimeoutOrNull(0L) {})\n        assertNull(withTimeoutOrNull(Duration.ZERO) {})\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/jdk8/time/FlowDebounceTest.kt",
        "content": "package kotlinx.coroutines.time\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.testing.TestBase\nimport kotlinx.coroutines.flow.flow\nimport kotlinx.coroutines.flow.toList\nimport kotlinx.coroutines.withVirtualTime\nimport org.junit.Test\nimport java.time.Duration\nimport kotlin.test.assertEquals\n\nclass FlowDebounceTest : TestBase() {\n    @Test\n    public fun testBasic() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(Duration.ofMillis(1500))\n            emit(\"B\")\n            delay(Duration.ofMillis(500))\n            emit(\"C\")\n            delay(Duration.ofMillis(250))\n            emit(\"D\")\n            delay(Duration.ofMillis(2000))\n            emit(\"E\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.debounce(Duration.ofMillis(1000)).toList()\n        assertEquals(listOf(\"A\", \"D\", \"E\"), result)\n        finish(5)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/jdk8/time/FlowSampleTest.kt",
        "content": "package kotlinx.coroutines.time\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.testing.TestBase\nimport kotlinx.coroutines.flow.flow\nimport kotlinx.coroutines.flow.toList\nimport kotlinx.coroutines.withVirtualTime\nimport org.junit.Test\nimport java.time.Duration\nimport kotlin.test.assertEquals\n\nclass FlowSampleTest : TestBase() {\n    @Test\n    public fun testBasic() = withVirtualTime {\n        expect(1)\n        val flow = flow {\n            expect(3)\n            emit(\"A\")\n            delay(Duration.ofMillis(1500))\n            emit(\"B\")\n            delay(Duration.ofMillis(500))\n            emit(\"C\")\n            delay(Duration.ofMillis(250))\n            emit(\"D\")\n            delay(Duration.ofMillis(2000))\n            emit(\"E\")\n            expect(4)\n        }\n\n        expect(2)\n        val result = flow.sample(Duration.ofMillis(1000)).toList()\n        assertEquals(listOf(\"A\", \"B\", \"D\"), result)\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/jdk8/time/WithTimeoutTest.kt",
        "content": "package kotlinx.coroutines.time\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.time.*\nimport kotlin.test.*\n\nclass WithTimeoutTest : TestBase() {\n\n    @Test\n    fun testWithTimeout() = runTest {\n        expect(1)\n        val result = withTimeout(Duration.ofMillis(10_000)) {\n            expect(2)\n            delay(Duration.ofNanos(1))\n            expect(3)\n            42\n        }\n\n        assertEquals(42, result)\n        finish(4)\n    }\n\n    @Test\n    fun testWithTimeoutOrNull() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(Duration.ofMillis(10_000)) {\n            expect(2)\n            delay(Duration.ofNanos(1))\n            expect(3)\n            42\n        }\n\n        assertEquals(42, result)\n        finish(4)\n    }\n\n    @Test\n    fun testWithTimeoutOrNullExceeded() = runTest {\n        expect(1)\n        val result = withTimeoutOrNull(Duration.ofMillis(3)) {\n            expect(2)\n            delay(Duration.ofSeconds(Long.MAX_VALUE))\n            expectUnreached()\n        }\n\n        assertNull(result)\n        finish(3)\n    }\n\n    @Test\n    fun testWithTimeoutExceeded() = runTest {\n        expect(1)\n        try {\n            withTimeout(Duration.ofMillis(3)) {\n                expect(2)\n                delay(Duration.ofSeconds(Long.MAX_VALUE))\n                expectUnreached()\n            }\n        } catch (e: TimeoutCancellationException) {\n            finish(3)\n        }\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/knit/ClosedAfterGuideTestExecutor.kt",
        "content": "package kotlinx.coroutines // Trick to make guide tests use these declarations with executors that can be closed on our side implicitly\n\nimport kotlinx.coroutines.testing.*\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport kotlin.coroutines.*\n\ninternal fun newSingleThreadContext(name: String): ExecutorCoroutineDispatcher = ClosedAfterGuideTestDispatcher(1, name)\n\ninternal fun newFixedThreadPoolContext(nThreads: Int, name: String): ExecutorCoroutineDispatcher =\n    ClosedAfterGuideTestDispatcher(nThreads, name)\n\nprivate class ClosedAfterGuideTestDispatcher(\n    private val nThreads: Int,\n    private val name: String\n) : ExecutorCoroutineDispatcher() {\n    private val threadNo = AtomicInteger()\n\n    override val executor: Executor =\n        Executors.newScheduledThreadPool(nThreads, object : ThreadFactory {\n            override fun newThread(target: java.lang.Runnable): Thread {\n                return PoolThread(\n                    this@ClosedAfterGuideTestDispatcher,\n                    target,\n                    if (nThreads == 1) name else name + \"-\" + threadNo.incrementAndGet()\n                )\n            }\n        })\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        executor.execute(wrapTask(block))\n    }\n\n    override fun close() {\n        (executor as ExecutorService).shutdown()\n    }\n\n    override fun toString(): String = \"ThreadPoolDispatcher[$nThreads, $name]\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/knit/TestUtil.kt",
        "content": "package kotlinx.coroutines.knit\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.scheduling.*\nimport kotlinx.coroutines.testing.*\nimport kotlinx.knit.test.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\n// helper function to dump exception to stdout for ease of debugging failed tests\nprivate inline fun <T> outputException(name: String, block: () -> T): T =\n    try { block() }\n    catch (e: Throwable) {\n        println(\"--- Failed test$name\")\n        e.printStackTrace(System.out)\n        throw e\n    }\n\nprivate const val SHUTDOWN_TIMEOUT = 5000L // 5 sec at most to wait\nprivate val OUT_ENABLED = systemProp(\"guide.tests.sout\", false)\n\nfun <R> test(name: String, block: () -> R): List<String> = outputException(name) {\n    try {\n        captureOutput(name, stdoutEnabled = OUT_ENABLED) { log ->\n            DefaultScheduler.usePrivateScheduler()\n            DefaultExecutor.shutdownForTests(SHUTDOWN_TIMEOUT)\n            resetCoroutineId()\n            val threadsBefore = currentThreads()\n            try {\n                withVirtualTimeSource(log) {\n                    val result = block()\n                    require(result === Unit) { \"Test 'main' shall return Unit\" }\n                }\n            } finally {\n                // the shutdown\n                log.println(\"--- shutting down\")\n                DefaultScheduler.shutdown(SHUTDOWN_TIMEOUT)\n                shutdownDispatcherPools(SHUTDOWN_TIMEOUT)\n                DefaultExecutor.shutdownForTests(SHUTDOWN_TIMEOUT) // the last man standing -- cleanup all pending tasks\n            }\n            checkTestThreads(threadsBefore) // check thread if the main completed successfully\n        }\n    } finally {\n        DefaultScheduler.restore()\n    }\n}\n\nprivate fun shutdownDispatcherPools(timeout: Long) {\n    val threads = arrayOfNulls<Thread>(Thread.activeCount())\n    val n = Thread.enumerate(threads)\n    for (i in 0 until n) {\n        val thread = threads[i]\n        if (thread is PoolThread)\n            (thread.dispatcher.executor as ExecutorService).apply {\n                shutdown()\n                awaitTermination(timeout, TimeUnit.MILLISECONDS)\n                shutdownNow().forEach { DefaultExecutor.enqueue(it) }\n            }\n    }\n}\n\nenum class SanitizeMode {\n    NONE,\n    ARBITRARY_TIME,\n    FLEXIBLE_THREAD\n}\n\nprivate fun sanitize(s: String, mode: SanitizeMode): String {\n    var res = s\n    when (mode) {\n        SanitizeMode.ARBITRARY_TIME -> {\n            res = res.replace(Regex(\" [0-9]+ ms\"), \" xxx ms\")\n        }\n        SanitizeMode.FLEXIBLE_THREAD -> {\n            res = res.replace(Regex(\"ForkJoinPool\\\\.commonPool-worker-[0-9]+\"), \"DefaultDispatcher\")\n            res = res.replace(Regex(\"ForkJoinPool-[0-9]+-worker-[0-9]+\"), \"DefaultDispatcher\")\n            res = res.replace(Regex(\"CommonPool-worker-[0-9]+\"), \"DefaultDispatcher\")\n            res = res.replace(Regex(\"DefaultDispatcher-worker-[0-9]+\"), \"DefaultDispatcher\")\n            res = res.replace(Regex(\"RxComputationThreadPool-[0-9]+\"), \"RxComputationThreadPool\")\n            res = res.replace(Regex(\"Test( worker)?\"), \"main\")\n            res = res.replace(Regex(\"@[0-9a-f]+\"), \"\") // drop hex address\n        }\n        SanitizeMode.NONE -> {}\n    }\n    return res\n}\n\nprivate fun List<String>.verifyCommonLines(expected: Array<out String>, mode: SanitizeMode = SanitizeMode.NONE) {\n    val n = minOf(size, expected.size)\n    for (i in 0 until n) {\n        val exp = sanitize(expected[i], mode)\n        val act = sanitize(get(i), mode)\n        assertEquals(exp, act, \"Line ${i + 1}\")\n    }\n}\n\nprivate fun List<String>.checkEqualNumberOfLines(expected: Array<out String>) {\n    if (size > expected.size)\n        error(\"Expected ${expected.size} lines, but found $size. Unexpected line '${get(expected.size)}'\")\n    else if (size < expected.size)\n        error(\"Expected ${expected.size} lines, but found $size\")\n}\n\nfun List<String>.verifyLines(vararg expected: String) = verify {\n    verifyCommonLines(expected)\n    checkEqualNumberOfLines(expected)\n}\n\nfun List<String>.verifyLinesStartWith(vararg expected: String) = verify {\n    verifyCommonLines(expected)\n    assertTrue(expected.size <= size, \"Number of lines\")\n}\n\nfun List<String>.verifyLinesArbitraryTime(vararg expected: String) = verify {\n    verifyCommonLines(expected, SanitizeMode.ARBITRARY_TIME)\n    checkEqualNumberOfLines(expected)\n}\n\nfun List<String>.verifyLinesFlexibleThread(vararg expected: String) = verify {\n    verifyCommonLines(expected, SanitizeMode.FLEXIBLE_THREAD)\n    checkEqualNumberOfLines(expected)\n}\n\nfun List<String>.verifyLinesStartUnordered(vararg expected: String) = verify {\n    val expectedSorted = expected.sorted().toTypedArray()\n    sorted().verifyLinesStart(*expectedSorted)\n}\n\nfun List<String>.verifyExceptions(vararg expected: String) {\n    val original = this\n    val actual = ArrayList<String>().apply {\n        var except = false\n        for (line in original) {\n            when {\n                !except && line.startsWith(\"\\tat\") -> except = true\n                except && !line.startsWith(\"\\t\") && !line.startsWith(\"Caused by: \") -> except = false\n            }\n            if (!except) add(line)\n        }\n    }\n    val n = minOf(actual.size, expected.size)\n    for (i in 0 until n) {\n        val exp = sanitize(expected[i], SanitizeMode.FLEXIBLE_THREAD)\n        val act = sanitize(actual[i], SanitizeMode.FLEXIBLE_THREAD)\n        assertEquals(exp, act, \"Line ${i + 1}\")\n    }\n}\n\n\nfun List<String>.verifyLinesStart(vararg expected: String) = verify {\n    val n = minOf(size, expected.size)\n    for (i in 0 until n) {\n        val exp = sanitize(expected[i], SanitizeMode.FLEXIBLE_THREAD)\n        val act = sanitize(get(i), SanitizeMode.FLEXIBLE_THREAD)\n        assertEquals(exp, act.substring(0, minOf(act.length, exp.length)), \"Line ${i + 1}\")\n    }\n    checkEqualNumberOfLines(expected)\n}\n\nprivate inline fun List<String>.verify(verification: () -> Unit) {\n    try {\n        verification()\n    } catch (t: Throwable) {\n        if (!OUT_ENABLED) {\n            println(\"Printing [delayed] test output\")\n            forEach { println(it) }\n        }\n        throw t\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/lincheck/ChannelsLincheckTest.kt",
        "content": "@file:Suppress(\"unused\", \"MemberVisibilityCanBePrivate\")\n\npackage kotlinx.coroutines.lincheck\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.channels.Channel.Factory.CONFLATED\nimport kotlinx.coroutines.channels.Channel.Factory.RENDEZVOUS\nimport kotlinx.coroutines.channels.Channel.Factory.UNLIMITED\nimport kotlinx.coroutines.selects.*\nimport org.jetbrains.kotlinx.lincheck.*\nimport org.jetbrains.kotlinx.lincheck.annotations.*\nimport org.jetbrains.kotlinx.lincheck.annotations.Operation\nimport org.jetbrains.kotlinx.lincheck.paramgen.*\nimport org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*\n\nclass RendezvousChannelLincheckTest : ChannelLincheckTestBaseWithOnSend(\n    c = Channel(RENDEZVOUS),\n    sequentialSpecification = SequentialRendezvousChannel::class.java\n)\nclass SequentialRendezvousChannel : SequentialIntChannelBase(RENDEZVOUS)\n\nclass Buffered1ChannelLincheckTest : ChannelLincheckTestBaseWithOnSend(\n    c = Channel(1),\n    sequentialSpecification = SequentialBuffered1Channel::class.java\n)\nclass Buffered1BroadcastChannelLincheckTest : ChannelLincheckTestBase(\n    c = ChannelViaBroadcast(BroadcastChannelImpl(1)),\n    sequentialSpecification = SequentialBuffered1Channel::class.java,\n    obstructionFree = false\n)\nclass SequentialBuffered1Channel : SequentialIntChannelBase(1)\n\nclass Buffered2ChannelLincheckTest : ChannelLincheckTestBaseWithOnSend(\n    c = Channel(2),\n    sequentialSpecification = SequentialBuffered2Channel::class.java\n)\nclass Buffered2BroadcastChannelLincheckTest : ChannelLincheckTestBase(\n    c = ChannelViaBroadcast(BroadcastChannelImpl(2)),\n    sequentialSpecification = SequentialBuffered2Channel::class.java,\n    obstructionFree = false\n)\nclass SequentialBuffered2Channel : SequentialIntChannelBase(2)\n\nclass UnlimitedChannelLincheckTest : ChannelLincheckTestBaseAll(\n    c = Channel(UNLIMITED),\n    sequentialSpecification = SequentialUnlimitedChannel::class.java\n)\nclass SequentialUnlimitedChannel : SequentialIntChannelBase(UNLIMITED)\n\nclass ConflatedChannelLincheckTest : ChannelLincheckTestBaseAll(\n    c = Channel(CONFLATED),\n    sequentialSpecification = SequentialConflatedChannel::class.java,\n    obstructionFree = false\n)\nclass ConflatedBroadcastChannelLincheckTest : ChannelLincheckTestBaseAll(\n    c = ChannelViaBroadcast(ConflatedBroadcastChannel()),\n    sequentialSpecification = SequentialConflatedChannel::class.java,\n    obstructionFree = false\n)\nclass SequentialConflatedChannel : SequentialIntChannelBase(CONFLATED)\n\nabstract class ChannelLincheckTestBaseAll(\n    c: Channel<Int>,\n    sequentialSpecification: Class<*>,\n    obstructionFree: Boolean = true\n) : ChannelLincheckTestBaseWithOnSend(c, sequentialSpecification, obstructionFree) {\n    @Operation\n    override fun trySend(value: Int) = super.trySend(value)\n    @Operation\n    override fun isClosedForReceive() = super.isClosedForReceive()\n    @Operation\n    override fun isEmpty() = super.isEmpty()\n}\n\nabstract class ChannelLincheckTestBaseWithOnSend(\n    c: Channel<Int>,\n    sequentialSpecification: Class<*>,\n    obstructionFree: Boolean = true\n) : ChannelLincheckTestBase(c, sequentialSpecification, obstructionFree) {\n    @Operation(allowExtraSuspension = true, blocking = true)\n    suspend fun sendViaSelect(@Param(name = \"value\") value: Int): Any = try {\n        select<Unit> { c.onSend(value) {} }\n    } catch (e: NumberedCancellationException) {\n        e.testResult\n    }\n}\n\n@Param.Params(\n    Param(name = \"value\", gen = IntGen::class, conf = \"1:9\"),\n    Param(name = \"closeToken\", gen = IntGen::class, conf = \"1:9\")\n)\nabstract class ChannelLincheckTestBase(\n    protected val c: Channel<Int>,\n    private val sequentialSpecification: Class<*>,\n    private val obstructionFree: Boolean = true\n) : AbstractLincheckTest() {\n\n    @Operation(allowExtraSuspension = true, blocking = true)\n    suspend fun send(@Param(name = \"value\") value: Int): Any = try {\n        c.send(value)\n    } catch (e: NumberedCancellationException) {\n        e.testResult\n    }\n\n    // @Operation TODO: `trySend()` is not linearizable as it can fail due to postponed buffer expansion\n    //            TODO: or make a rendezvous with `tryReceive`, which violates the sequential specification.\n    open fun trySend(@Param(name = \"value\") value: Int): Any = c.trySend(value)\n        .onSuccess { return true }\n        .onFailure {\n            return if (it is NumberedCancellationException) it.testResult\n            else false\n        }\n\n    @Operation(allowExtraSuspension = true, blocking = true)\n    suspend fun receive(): Any = try {\n        c.receive()\n    } catch (e: NumberedCancellationException) {\n        e.testResult\n    }\n\n    @Operation(allowExtraSuspension = true, blocking = true)\n    suspend fun receiveCatching(): Any = c.receiveCatching()\n        .onSuccess { return it }\n        .onClosed { e -> return (e as NumberedCancellationException).testResult }\n\n    @Operation(blocking = true)\n    fun tryReceive(): Any? =\n        c.tryReceive()\n            .onSuccess { return it }\n            .onFailure { return if (it is NumberedCancellationException) it.testResult else null }\n\n    @Operation(allowExtraSuspension = true, blocking = true)\n    suspend fun receiveViaSelect(): Any = try {\n        select<Int> { c.onReceive { it } }\n    } catch (e: NumberedCancellationException) {\n        e.testResult\n    }\n\n    @Operation(causesBlocking = true, blocking = true)\n    fun close(@Param(name = \"closeToken\") token: Int): Boolean = c.close(NumberedCancellationException(token))\n\n    @Operation(causesBlocking = true, blocking = true)\n    fun cancel(@Param(name = \"closeToken\") token: Int) = c.cancel(NumberedCancellationException(token))\n\n    // @Operation TODO non-linearizable in BufferedChannel\n    open fun isClosedForReceive() = c.isClosedForReceive\n\n    @Operation(blocking = true)\n    fun isClosedForSend() = c.isClosedForSend\n\n    // @Operation TODO non-linearizable in BufferedChannel\n    open fun isEmpty() = c.isEmpty\n\n    @StateRepresentation\n    fun state() = (c as? BufferedChannel<*>)?.toStringDebug() ?: c.toString()\n\n    @Validate\n    fun validate() {\n        (c as? BufferedChannel<*>)?.checkSegmentStructureInvariants()\n    }\n\n    override fun <O : Options<O, *>> O.customize(isStressTest: Boolean) =\n        actorsBefore(0).sequentialSpecification(sequentialSpecification)\n\n    override fun ModelCheckingOptions.customize(isStressTest: Boolean) =\n        checkObstructionFreedom(obstructionFree)\n}\n\nprivate class NumberedCancellationException(number: Int) : CancellationException() {\n    val testResult = \"Closed($number)\"\n}\n\n\nabstract class SequentialIntChannelBase(private val capacity: Int) {\n    private val senders   = ArrayList<Pair<CancellableContinuation<Any>, Int>>()\n    private val receivers = ArrayList<CancellableContinuation<Any>>()\n    private val buffer = ArrayList<Int>()\n    private var closedMessage: String? = null\n\n    suspend fun send(x: Int): Any = when (val offerRes = trySend(x)) {\n        true -> Unit\n        false -> suspendCancellableCoroutine { cont ->\n            senders.add(cont to x)\n        }\n        else -> offerRes\n    }\n\n    fun trySend(element: Int): Any {\n        if (closedMessage !== null) return closedMessage!!\n        if (capacity == CONFLATED) {\n            if (resumeFirstReceiver(element)) return true\n            buffer.clear()\n            buffer.add(element)\n            return true\n        }\n        if (resumeFirstReceiver(element)) return true\n        if (buffer.size < capacity) {\n            buffer.add(element)\n            return true\n        }\n        return false\n    }\n\n    private fun resumeFirstReceiver(element: Int): Boolean {\n        while (receivers.isNotEmpty()) {\n            val r = receivers.removeAt(0)\n            if (r.resume(element)) return true\n        }\n        return false\n    }\n\n    suspend fun receive(): Any = tryReceive() ?: suspendCancellableCoroutine { cont ->\n        receivers.add(cont)\n    }\n\n    suspend fun receiveCatching() = receive()\n\n    fun tryReceive(): Any? {\n        if (buffer.isNotEmpty()) {\n            val el = buffer.removeAt(0)\n            resumeFirstSender().also {\n                if (it !== null) buffer.add(it)\n            }\n            return el\n        }\n        resumeFirstSender()?.also { return it }\n        if (closedMessage !== null) return closedMessage\n        return null\n    }\n\n    private fun resumeFirstSender(): Int? {\n        while (senders.isNotEmpty()) {\n            val (s, el) = senders.removeAt(0)\n            if (s.resume(Unit)) return el\n        }\n        return null\n    }\n\n    suspend fun sendViaSelect(element: Int) = send(element)\n    suspend fun receiveViaSelect() = receive()\n\n    fun close(token: Int): Boolean {\n        if (closedMessage !== null) return false\n        closedMessage = \"Closed($token)\"\n        for (r in receivers) r.resume(closedMessage!!)\n        receivers.clear()\n        return true\n    }\n\n    fun cancel(token: Int) {\n        close(token)\n        for ((s, _) in senders) s.resume(closedMessage!!)\n        senders.clear()\n        buffer.clear()\n    }\n\n    fun isClosedForSend(): Boolean = closedMessage !== null\n    fun isClosedForReceive(): Boolean = isClosedForSend() && buffer.isEmpty() && senders.isEmpty()\n\n    fun isEmpty(): Boolean {\n        if (closedMessage !== null) return false\n        return buffer.isEmpty() && senders.isEmpty()\n    }\n}\n\nprivate fun <T> CancellableContinuation<T>.resume(res: T): Boolean {\n    val token = tryResume(res) ?: return false\n    completeResume(token)\n    return true\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/lincheck/LockFreeTaskQueueLincheckTest.kt",
        "content": "@file:Suppress(\"unused\")\n\npackage kotlinx.coroutines.lincheck\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport org.jetbrains.kotlinx.lincheck.*\nimport org.jetbrains.kotlinx.lincheck.annotations.*\nimport org.jetbrains.kotlinx.lincheck.annotations.Operation\nimport org.jetbrains.kotlinx.lincheck.paramgen.*\nimport org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*\nimport org.jetbrains.kotlinx.lincheck.verifier.quiescent.*\n\n@Param(name = \"value\", gen = IntGen::class, conf = \"1:3\")\ninternal abstract class AbstractLockFreeTaskQueueWithoutRemoveLincheckTest(\n    val singleConsumer: Boolean\n) : AbstractLincheckTest() {\n    @JvmField\n    protected val q = LockFreeTaskQueue<Int>(singleConsumer = singleConsumer)\n\n    @Operation\n    fun close() = q.close()\n\n    @Operation\n    fun addLast(@Param(name = \"value\") value: Int) = q.addLast(value)\n\n    override fun <O : Options<O, *>> O.customize(isStressTest: Boolean): O =\n        verifier(QuiescentConsistencyVerifier::class.java)\n\n    override fun ModelCheckingOptions.customize(isStressTest: Boolean) =\n        checkObstructionFreedom()\n}\n\ninternal class MCLockFreeTaskQueueWithRemoveLincheckTest : AbstractLockFreeTaskQueueWithoutRemoveLincheckTest(singleConsumer = false) {\n    @QuiescentConsistent\n    @Operation(blocking = true)\n    fun removeFirstOrNull() = q.removeFirstOrNull()\n}\n\ninternal class SCLockFreeTaskQueueWithRemoveLincheckTest : AbstractLockFreeTaskQueueWithoutRemoveLincheckTest(singleConsumer = true) {\n    @QuiescentConsistent\n    @Operation(nonParallelGroup = \"consumer\")\n    fun removeFirstOrNull() = q.removeFirstOrNull()\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/lincheck/MutexLincheckTest.kt",
        "content": "@file:Suppress(\"unused\")\npackage kotlinx.coroutines.lincheck\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport kotlinx.coroutines.sync.*\nimport org.jetbrains.kotlinx.lincheck.*\nimport org.jetbrains.kotlinx.lincheck.annotations.*\nimport org.jetbrains.kotlinx.lincheck.annotations.Operation\nimport org.jetbrains.kotlinx.lincheck.paramgen.*\n\n@Param(name = \"owner\", gen = IntGen::class, conf = \"0:2\")\nclass MutexLincheckTest : AbstractLincheckTest() {\n    private val mutex = Mutex()\n\n    @Operation(handleExceptionsAsResult = [IllegalStateException::class])\n    fun tryLock(@Param(name = \"owner\") owner: Int) = mutex.tryLock(owner.asOwnerOrNull)\n\n    // TODO: `lock()` with non-null owner is non-linearizable\n    @Operation(promptCancellation = true)\n    suspend fun lock() = mutex.lock(null)\n\n    // TODO: `onLock` with non-null owner is non-linearizable\n    // onLock may suspend in case of clause re-registration.\n    @Operation(allowExtraSuspension = true, promptCancellation = true)\n    suspend fun onLock() = select<Unit> { mutex.onLock(null) {} }\n\n    @Operation(handleExceptionsAsResult = [IllegalStateException::class])\n    fun unlock(@Param(name = \"owner\") owner: Int) = mutex.unlock(owner.asOwnerOrNull)\n\n    @Operation\n    fun isLocked() = mutex.isLocked\n\n    @Operation\n    fun holdsLock(@Param(name = \"owner\") owner: Int) = mutex.holdsLock(owner)\n\n    override fun <O : Options<O, *>> O.customize(isStressTest: Boolean): O =\n        actorsBefore(0)\n\n    private val Int.asOwnerOrNull get() = if (this == 0) null else this\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/lincheck/ResizableAtomicArrayLincheckTest.kt",
        "content": "package kotlinx.coroutines.lincheck\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport org.jetbrains.kotlinx.lincheck.annotations.*\nimport org.jetbrains.kotlinx.lincheck.paramgen.*\n\n@Param(name = \"index\", gen = IntGen::class, conf = \"0:4\")\n@Param(name = \"value\", gen = IntGen::class, conf = \"1:5\")\nclass ResizableAtomicArrayLincheckTest : AbstractLincheckTest() {\n    private val a = ResizableAtomicArray<Int>(2)\n\n    @Operation\n    fun get(@Param(name = \"index\") index: Int): Int? = a[index]\n\n    @Operation(nonParallelGroup = \"writer\")\n    fun set(@Param(name = \"index\") index: Int, @Param(name = \"value\") value: Int) {\n        a.setSynchronized(index, value)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/lincheck/SemaphoreLincheckTest.kt",
        "content": "@file:Suppress(\"unused\")\npackage kotlinx.coroutines.lincheck\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport org.jetbrains.kotlinx.lincheck.*\nimport org.jetbrains.kotlinx.lincheck.annotations.Operation\nimport org.jetbrains.kotlinx.lincheck.strategy.managed.modelchecking.*\n\nabstract class SemaphoreLincheckTestBase(permits: Int) : AbstractLincheckTest() {\n    private val semaphore = SemaphoreImpl(permits = permits, acquiredPermits = 0)\n\n    @Operation\n    fun tryAcquire() = semaphore.tryAcquire()\n\n    @Operation(promptCancellation = true, allowExtraSuspension = true)\n    suspend fun acquire() = semaphore.acquire()\n\n    @Operation(handleExceptionsAsResult = [IllegalStateException::class])\n    fun release() = semaphore.release()\n\n    override fun <O : Options<O, *>> O.customize(isStressTest: Boolean): O =\n        actorsBefore(0)\n\n    override fun ModelCheckingOptions.customize(isStressTest: Boolean) =\n        checkObstructionFreedom()\n}\n\nclass Semaphore1LincheckTest : SemaphoreLincheckTestBase(1)\nclass Semaphore2LincheckTest : SemaphoreLincheckTestBase(2)\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/BlockingCoroutineDispatcherLivenessStressTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\n/**\n * Test that ensures implementation correctness of [LimitingDispatcher] and\n * designed to stress its particular implementation details.\n */\nclass BlockingCoroutineDispatcherLivenessStressTest : SchedulerTestBase() {\n    private val concurrentWorkers = AtomicInteger(0)\n\n    @Before\n    fun setUp() {\n        // In case of starvation test will hang\n        idleWorkerKeepAliveNs = Long.MAX_VALUE\n    }\n\n    @Test\n    fun testAddPollRace() = runBlocking {\n        val limitingDispatcher = blockingDispatcher(1)\n        val iterations = 25_000 * stressTestMultiplier\n        // Stress test for specific case (race #2 from LimitingDispatcher). Shouldn't hang.\n        for (i in 1..iterations) {\n            val tasks = (1..2).map {\n                async(limitingDispatcher) {\n                    try {\n                        val currentlyExecuting = concurrentWorkers.incrementAndGet()\n                        assertEquals(1, currentlyExecuting)\n                    } finally {\n                        concurrentWorkers.decrementAndGet()\n                    }\n                }\n            }\n            tasks.forEach { it.await() }\n        }\n    }\n\n    @Test\n    fun testPingPongThreadsCount() = runBlocking {\n        corePoolSize = CORES_COUNT\n        val iterations = 100_000 * stressTestMultiplier\n        val completed = AtomicInteger(0)\n        for (i in 1..iterations) {\n            val tasks = (1..2).map {\n                async(dispatcher) {\n                    // Useless work\n                    concurrentWorkers.incrementAndGet()\n                    concurrentWorkers.decrementAndGet()\n                    completed.incrementAndGet()\n                }\n            }\n            tasks.forEach { it.await() }\n        }\n        assertEquals(2 * iterations, completed.get())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/BlockingCoroutineDispatcherMixedStealingStressTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.concurrent.*\n\n/**\n * Specific test that was designed to expose inference between stealing/polling of blocking and non-blocking tasks.RunningThreadStackMergeTest\n */\nclass BlockingCoroutineDispatcherMixedStealingStressTest : SchedulerTestBase() {\n\n    private val iterations = 10_000\n\n    @Before\n    fun setUp() {\n        idleWorkerKeepAliveNs = Long.MAX_VALUE\n    }\n\n    @Test\n    fun testBlockingProgressPreventedInternal()  {\n        val blocking = blockingDispatcher(corePoolSize).asExecutor()\n        val regular = dispatcher.asExecutor()\n        repeat(iterations * stressTestMultiplier) {\n            val cpuBlocker = CyclicBarrier(corePoolSize + 1)\n            val blockingBlocker = CyclicBarrier(2)\n            regular.execute(Runnable {\n                // Block all CPU cores except current one\n                repeat(corePoolSize - 1) {\n                    regular.execute(Runnable {\n                        cpuBlocker.await()\n                    })\n                }\n\n                blocking.execute(Runnable {\n                    blockingBlocker.await()\n                })\n\n                regular.execute(Runnable {\n                    blockingBlocker.await()\n                    cpuBlocker.await()\n                })\n            })\n            cpuBlocker.await()\n        }\n    }\n\n    @Test\n    fun testBlockingProgressPreventedExternal()  {\n        val blocking = blockingDispatcher(corePoolSize).asExecutor()\n        val regular = dispatcher.asExecutor()\n        repeat(iterations / 2 * stressTestMultiplier) {\n            val cpuBlocker = CyclicBarrier(corePoolSize + 1)\n            val blockingBlocker = CyclicBarrier(2)\n            repeat(corePoolSize) {\n                regular.execute(Runnable {\n                    cpuBlocker.await()\n                })\n            }\n            // Wait for all threads to park\n            while (true) {\n                val waiters = Thread.getAllStackTraces().keys.count { (it.state == Thread.State.TIMED_WAITING || it.state == Thread.State.WAITING)\n                        && it is CoroutineScheduler.Worker }\n                if (waiters >= corePoolSize) break\n                Thread.yield()\n            }\n            blocking.execute(Runnable {\n                blockingBlocker.await()\n            })\n            regular.execute(Runnable {\n            })\n\n            blockingBlocker.await()\n            cpuBlocker.await()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/BlockingCoroutineDispatcherTerminationStressTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.scheduling.*\nimport org.junit.*\nimport java.util.*\nimport java.util.concurrent.*\n\nclass BlockingCoroutineDispatcherTerminationStressTest : TestBase() {\n    private val baseDispatcher = SchedulerCoroutineDispatcher(\n        2, 20,\n        TimeUnit.MILLISECONDS.toNanos(10)\n    )\n    private val ioDispatcher = baseDispatcher.blocking()\n    private val TEST_SECONDS = 3L * stressTestMultiplier\n\n    @After\n    fun tearDown() {\n        baseDispatcher.close()\n    }\n\n    @Test\n    fun testTermination() {\n        val rnd = Random()\n        val deadline = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(TEST_SECONDS)\n        while (System.currentTimeMillis() < deadline) {\n            Thread.sleep(rnd.nextInt(30).toLong())\n            repeat(rnd.nextInt(5) + 1) {\n                GlobalScope.launch(ioDispatcher) {\n                    Thread.sleep(rnd.nextInt(5).toLong())\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/BlockingCoroutineDispatcherTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.rules.*\nimport java.util.concurrent.*\n\nclass BlockingCoroutineDispatcherTest : SchedulerTestBase() {\n\n    @get:Rule\n    val timeout = Timeout.seconds(10L)!!\n\n    @Test\n    fun testNonBlockingWithBlockingExternal() = runBlocking {\n        val barrier = CyclicBarrier(2)\n\n        val blockingJob = launch(blockingDispatcher.value) {\n            barrier.await()\n        }\n\n        val nonBlockingJob = launch(dispatcher) {\n            barrier.await()\n        }\n\n        nonBlockingJob.join()\n        blockingJob.join()\n        checkPoolThreadsCreated(2..3)\n    }\n\n    @Test\n    fun testNonBlockingFromBlocking() = runBlocking {\n        val barrier = CyclicBarrier(2)\n\n        val blocking = launch(blockingDispatcher.value) {\n            // This task will be stolen\n            launch(dispatcher) {\n                barrier.await()\n            }\n\n            barrier.await()\n        }\n\n        blocking.join()\n        checkPoolThreadsCreated(2..3)\n    }\n\n    @Test\n    fun testScheduleBlockingThreadCount() = runTest {\n        // After first iteration pool is idle, repeat, no new threads should be created\n        repeat(2) {\n            val blocking = launch(blockingDispatcher.value) {\n                launch(blockingDispatcher.value) {\n                }\n            }\n\n            blocking.join()\n            // Depends on how fast thread will be created\n            checkPoolThreadsCreated(2..3)\n        }\n    }\n\n    @Test\n    fun testNoCpuStarvation() = runBlocking {\n        val tasksNum = 100\n        val barrier = CyclicBarrier(tasksNum + 1)\n        val tasks = (1..tasksNum).map { launch(blockingDispatcher.value) { barrier.await() } }\n\n        val cpuTask = launch(dispatcher) {\n            // Do nothing, just complete\n        }\n\n        cpuTask.join()\n        tasks.forEach { require(it.isActive) }\n        barrier.await()\n        tasks.joinAll()\n    }\n\n    @Test\n    fun testNoCpuStarvationWithMultipleBlockingContexts() = runBlocking {\n        val firstBarrier = CyclicBarrier(11)\n        val secondBarrier = CyclicBarrier(11)\n        val blockingDispatcher = blockingDispatcher(10)\n        val blockingDispatcher2 = blockingDispatcher(10)\n\n        val blockingTasks = (1..10).flatMap {\n            listOf(launch(blockingDispatcher) { firstBarrier.await() }, launch(blockingDispatcher2) { secondBarrier.await() })\n        }\n\n        val cpuTasks = (1..100).map {\n            launch(dispatcher) {\n                // Do nothing, just complete\n            }\n        }.toList()\n\n        cpuTasks.joinAll()\n        blockingTasks.forEach { require(it.isActive) }\n        firstBarrier.await()\n        secondBarrier.await()\n        blockingTasks.joinAll()\n        checkPoolThreadsCreated(21 /* blocking tasks + 1 for CPU */..20 + CORES_COUNT)\n    }\n\n    @Test\n    fun testNoExcessThreadsCreated() = runBlocking {\n        corePoolSize = 4\n\n        val tasksNum = 100\n        val barrier = CyclicBarrier(tasksNum + 1)\n        val blockingTasks = (1..tasksNum).map { launch(blockingDispatcher.value) { barrier.await() } }\n\n        val nonBlockingTasks = (1..tasksNum).map {\n            launch(dispatcher) {\n                yield()\n            }\n        }\n\n        nonBlockingTasks.joinAll()\n        barrier.await()\n        blockingTasks.joinAll()\n        // There may be race when multiple CPU threads are trying to lazily created one more\n        checkPoolThreadsCreated(101..100 + CORES_COUNT)\n    }\n\n    @Test(timeout = 1_000)\n    fun testYield() = runBlocking {\n        corePoolSize = 1\n        maxPoolSize = 1\n        val bd = blockingDispatcher(1)\n        val outerJob = launch(bd) {\n            expect(1)\n            val innerJob = launch(bd) {\n                // Do nothing\n                expect(3)\n            }\n\n            expect(2)\n            while (innerJob.isActive) {\n                yield()\n            }\n\n            expect(4)\n            innerJob.join()\n        }\n\n        outerJob.join()\n        finish(5)\n    }\n\n    @Test\n    fun testUndispatchedYield() = runTest {\n        expect(1)\n        corePoolSize = 1\n        maxPoolSize = 1\n        val blockingDispatcher = blockingDispatcher(1)\n        val job = launch(blockingDispatcher, CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            yield()\n        }\n        expect(3)\n        job.join()\n        finish(4)\n    }\n\n    @Test(expected = IllegalArgumentException::class)\n    fun testNegativeParallelism() {\n        blockingDispatcher(-1)\n    }\n\n    @Test(expected = IllegalArgumentException::class)\n    fun testZeroParallelism() {\n        blockingDispatcher(0)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/BlockingCoroutineDispatcherThreadLimitStressTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Ignore\nimport org.junit.Test\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\nclass BlockingCoroutineDispatcherThreadLimitStressTest : SchedulerTestBase() {\n\n    init {\n        corePoolSize = CORES_COUNT\n    }\n\n    private val observedConcurrency = ConcurrentHashMap<Int, Boolean>()\n    private val concurrentWorkers = AtomicInteger(0)\n\n    @Test\n    fun testLimitParallelismToOne() = runTest {\n        val limitingDispatcher = blockingDispatcher(1)\n        // Do in bursts to avoid OOM\n        repeat(100 * stressTestMultiplierSqrt) {\n            val iterations = 1_000 * stressTestMultiplierSqrt\n            val tasks = (1..iterations).map {\n                async(limitingDispatcher) {\n                    try {\n                        val currentlyExecuting = concurrentWorkers.incrementAndGet()\n                        observedConcurrency[currentlyExecuting] = true\n                        assertTrue(currentlyExecuting <= CORES_COUNT)\n                    } finally {\n                        concurrentWorkers.decrementAndGet()\n                    }\n                }\n            }\n            tasks.forEach { it.await() }\n            for (i in CORES_COUNT + 1..CORES_COUNT * 2) {\n                require(i !in observedConcurrency.keys) { \"Unexpected state: $observedConcurrency\" }\n            }\n            checkPoolThreadsCreated(0..CORES_COUNT + 1)\n        }\n    }\n\n    @Test\n    @Ignore\n    fun testLimitParallelism() = runBlocking {\n        val limitingDispatcher = blockingDispatcher(CORES_COUNT)\n        val iterations = 50_000 * stressTestMultiplier\n        val tasks = (1..iterations).map {\n            async(limitingDispatcher) {\n                try {\n                    val currentlyExecuting = concurrentWorkers.incrementAndGet()\n                    observedConcurrency[currentlyExecuting] = true\n                    assertTrue(currentlyExecuting <= CORES_COUNT)\n                } finally {\n                    concurrentWorkers.decrementAndGet()\n                }\n            }\n        }\n        tasks.forEach { it.await() }\n        for (i in CORES_COUNT + 1..CORES_COUNT * 2) {\n            require(i !in observedConcurrency.keys) { \"Unexpected state: $observedConcurrency\" }\n        }\n        checkPoolThreadsCreated(CORES_COUNT..CORES_COUNT * 3)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/BlockingCoroutineDispatcherWorkSignallingStressTest.kt",
        "content": "@file:Suppress(\"DeferredResultUnused\")\n\npackage kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass BlockingCoroutineDispatcherWorkSignallingStressTest : SchedulerTestBase() {\n\n    @Test\n    fun testCpuTasksStarvation() = runBlocking {\n        val iterations = 1000 * stressTestMultiplier\n        repeat(iterations) {\n            // Create a dispatcher every iteration to increase probability of race\n            val dispatcher = SchedulerCoroutineDispatcher(CORES_COUNT)\n            val blockingDispatcher = dispatcher.blocking(100)\n\n            val blockingBarrier = CyclicBarrier(CORES_COUNT * 3 + 1)\n            val cpuBarrier = CyclicBarrier(CORES_COUNT + 1)\n\n            val cpuTasks = CopyOnWriteArrayList<Deferred<*>>()\n            val blockingTasks = CopyOnWriteArrayList<Deferred<*>>()\n\n            repeat(CORES_COUNT) {\n                async(dispatcher) {\n                    // These two will be stolen first\n                    blockingTasks += blockingAwait(blockingDispatcher, blockingBarrier)\n                    blockingTasks += blockingAwait(blockingDispatcher, blockingBarrier)\n                    // Empty on CPU job which should be executed while blocked tasks are waiting\n                    cpuTasks += cpuAwait(dispatcher, cpuBarrier)\n                    // Block with next task. Block cores * 3 threads in total\n                    blockingTasks += blockingAwait(blockingDispatcher, blockingBarrier)\n                }\n            }\n\n            cpuTasks.forEach { require(it.isActive) }\n            cpuBarrier.await()\n            cpuTasks.awaitAll()\n            blockingTasks.forEach { require(it.isActive) }\n            blockingBarrier.await()\n            blockingTasks.awaitAll()\n            dispatcher.close()\n        }\n    }\n\n    private fun CoroutineScope.blockingAwait(\n        blockingDispatcher: CoroutineDispatcher,\n        blockingBarrier: CyclicBarrier\n    ) = async(blockingDispatcher) { blockingBarrier.await() }\n\n\n    private fun CoroutineScope.cpuAwait(\n        blockingDispatcher: CoroutineDispatcher,\n        blockingBarrier: CyclicBarrier\n    ) = async(blockingDispatcher) { blockingBarrier.await() }\n\n    @Test\n    fun testBlockingTasksStarvation() = runBlocking {\n        corePoolSize = 2 // Easier to reproduce race with unparks\n        val iterations = 10_000 * stressTestMultiplier\n        val blockingLimit = 4 // CORES_COUNT * 3\n        val blocking = blockingDispatcher(blockingLimit)\n\n        repeat(iterations) {\n            val barrier = CyclicBarrier(blockingLimit + 1)\n            // Should eat all limit * 3 cpu without any starvation\n            val tasks = (1..blockingLimit).map { async(blocking) { barrier.await() } }\n            tasks.forEach { assertTrue(it.isActive) }\n            barrier.await()\n            tasks.joinAll()\n        }\n    }\n\n    @Test\n    fun testBlockingTasksStarvationWithCpuTasks() = runBlocking {\n        val iterations = 1000 * stressTestMultiplier\n        val blockingLimit = CORES_COUNT * 2\n        val blocking = blockingDispatcher(blockingLimit)\n\n        repeat(iterations) {\n            // Overwhelm global queue with external CPU tasks\n            val cpuTasks = (1..CORES_COUNT).map { async(dispatcher) { while (true) delay(1) } }\n            val barrier = CyclicBarrier(blockingLimit + 1)\n            // Should eat all limit * 3 cpu without any starvation\n            val tasks = (1..blockingLimit).map { async(blocking) { barrier.await() } }\n            tasks.forEach { assertTrue(it.isActive) }\n            barrier.await()\n            tasks.joinAll()\n            cpuTasks.forEach { it.cancelAndJoin() }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/CoroutineDispatcherTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\nclass CoroutineDispatcherTest : SchedulerTestBase() {\n\n    @After\n    fun tearDown() {\n        schedulerTimeSource = NanoTimeSource\n    }\n\n    @Test\n    fun testSingleThread() = runBlocking {\n        corePoolSize = 1\n        expect(1)\n        withContext(dispatcher) {\n            require(Thread.currentThread() is CoroutineScheduler.Worker)\n            expect(2)\n            val job = async {\n                expect(3)\n                delay(10)\n                expect(4)\n            }\n\n            job.await()\n            expect(5)\n        }\n\n        finish(6)\n        checkPoolThreadsCreated(1)\n    }\n\n    @Test\n    fun testFairScheduling() = runBlocking {\n        corePoolSize = 1\n        expect(1)\n        val outerJob = launch(dispatcher) {\n            val d1 = launch(dispatcher) { expect(3) }\n            val d2 = launch(dispatcher) { expect(4) }\n            val d3 = launch(dispatcher) { expect(2) }\n            listOf(d1, d2, d3).joinAll()\n        }\n        outerJob.join()\n        finish(5)\n    }\n\n    @Test\n    fun testStealing() = runBlocking {\n        corePoolSize = 2\n        val flag = AtomicBoolean(false)\n        val job = async(dispatcher) {\n            expect(1)\n            val innerJob = async {\n                expect(2)\n                flag.set(true)\n            }\n            while (!flag.get()) {\n                Thread.yield() // Block current thread, submitted inner job will be stolen\n            }\n\n            innerJob.await()\n            expect(3)\n        }\n        job.await()\n        finish(4)\n        checkPoolThreadsCreated(2)\n    }\n\n    @Test\n    fun testDelay() = runBlocking {\n        corePoolSize = 2\n        withContext(dispatcher) {\n            expect(1)\n            delay(10)\n            expect(2)\n        }\n        finish(3)\n        checkPoolThreadsCreated(2)\n    }\n\n    @Test\n    fun testMaxSize() = runBlocking {\n        corePoolSize = 1\n        maxPoolSize = 4\n        (1..10).map { launch(blockingDispatcher.value) { Thread.sleep(100) } }.joinAll()\n        checkPoolThreadsCreated(4)\n    }\n\n    @Test(timeout = 1_000)\n    fun testYield() = runBlocking {\n        corePoolSize = 1\n        maxPoolSize = 1\n        val outerJob = launch(dispatcher) {\n            expect(1)\n            val innerJob = launch(dispatcher) {\n                // Do nothing\n                expect(3)\n            }\n\n            expect(2)\n            while (innerJob.isActive) {\n                yield()\n            }\n\n            expect(4)\n            innerJob.join()\n        }\n        outerJob.join()\n        finish(5)\n    }\n\n    @Test\n    fun testUndispatchedYield() = runTest {\n        expect(1)\n        val job = launch(dispatcher, CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            yield()\n        }\n        expect(3)\n        job.join()\n        finish(4)\n    }\n\n    @Test\n    fun testThreadName() = runBlocking {\n        val initialCount = Thread.getAllStackTraces().keys.asSequence()\n            .count { it is CoroutineScheduler.Worker && it.name.contains(\"SomeTestName\") }\n        assertEquals(0, initialCount)\n        val dispatcher = SchedulerCoroutineDispatcher(1, 1, IDLE_WORKER_KEEP_ALIVE_NS, \"SomeTestName\")\n        dispatcher.use {\n            launch(dispatcher) {\n            }.join()\n\n            val count = Thread.getAllStackTraces().keys.asSequence()\n                .count { it is CoroutineScheduler.Worker && it.name.contains(\"SomeTestName\") }\n            assertEquals(1, count)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/CoroutineSchedulerCloseStressTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport java.util.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass CoroutineSchedulerCloseStressTest(private val mode: Mode) : TestBase() {\n    enum class Mode { CPU, BLOCKING, CPU_LIMITED }\n\n    companion object {\n        @Parameterized.Parameters(name = \"mode={0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = Mode.values().map { arrayOf<Any>(it) }\n    }\n\n    private val MAX_LEVEL = 5\n    private val N_COROS = (1 shl (MAX_LEVEL + 1)) - 1\n    private val N_THREADS = 4\n    private val rnd = Random()\n\n    private lateinit var closeableDispatcher: SchedulerCoroutineDispatcher\n    private lateinit var dispatcher: CoroutineDispatcher\n\n    private val started = atomic(0)\n    private val finished = atomic(0)\n\n    @Test\n    fun testNormalClose() {\n        try {\n            launchCoroutines()\n        } finally {\n            closeableDispatcher.close()\n        }\n    }\n\n    private fun launchCoroutines() = runBlocking {\n        closeableDispatcher = SchedulerCoroutineDispatcher(N_THREADS)\n        dispatcher = when (mode) {\n            Mode.CPU -> closeableDispatcher\n            Mode.CPU_LIMITED -> closeableDispatcher.limitedParallelism(N_THREADS)\n            Mode.BLOCKING -> closeableDispatcher.blocking(N_THREADS)\n        }\n        started.value = 0\n        finished.value = 0\n        withContext(dispatcher) {\n            launchChild(0, 0)\n        }\n        assertEquals(N_COROS, started.value)\n        assertEquals(N_COROS, finished.value)\n    }\n\n    // Index and level are used only for debugging purpose\n    private fun CoroutineScope.launchChild(index: Int, level: Int): Job = launch(start = CoroutineStart.ATOMIC) {\n        started.incrementAndGet()\n        try {\n            if (level < MAX_LEVEL) {\n                launchChild(2 * index + 1, level + 1)\n                launchChild(2 * index + 2, level + 1)\n            } else {\n                if (rnd.nextBoolean()) {\n                    delay(1000)\n                } else {\n                    yield()\n                }\n            }\n        } finally {\n            finished.incrementAndGet()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/CoroutineSchedulerInternalApiStressTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.AVAILABLE_PROCESSORS\nimport org.junit.Test\nimport java.util.*\nimport java.util.concurrent.ConcurrentHashMap\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.CyclicBarrier\nimport java.util.concurrent.atomic.AtomicInteger\nimport kotlin.random.*\nimport kotlin.random.Random\nimport kotlin.test.*\nimport kotlin.time.*\n\nclass CoroutineSchedulerInternalApiStressTest : TestBase() {\n\n    @Test(timeout = 120_000L)\n    fun testHelpDefaultIoIsIsolated() = repeat(100 * stressTestMultiplierSqrt) {\n        val ioTaskMarker = ThreadLocal.withInitial { false }\n        runTest {\n            val jobToComplete = Job()\n            val expectedIterations = 100\n            val completionLatch = CountDownLatch(1)\n            val tasksToCompleteJob = AtomicInteger(expectedIterations)\n            val observedIoThreads = Collections.newSetFromMap(ConcurrentHashMap<Thread, Boolean>())\n            val observedDefaultThreads = Collections.newSetFromMap(ConcurrentHashMap<Thread, Boolean>())\n\n            val barrier = CyclicBarrier(AVAILABLE_PROCESSORS)\n            val spawners = ArrayList<Job>()\n            repeat(AVAILABLE_PROCESSORS - 1) {\n                // Launch CORES - 1 spawners\n                spawners += launch(Dispatchers.Default) {\n                    barrier.await()\n                    repeat(expectedIterations) {\n                        launch {\n                            val tasksLeft = tasksToCompleteJob.decrementAndGet()\n                            if (tasksLeft < 0) return@launch // Leftovers are being executed all over the place\n                            observedDefaultThreads.add(Thread.currentThread())\n                            if (tasksLeft == 0) {\n                                // Verify threads first\n                                try {\n                                    assertFalse(observedIoThreads.containsAll(observedDefaultThreads))\n                                } finally {\n                                    jobToComplete.complete()\n                                }\n                            }\n                        }\n\n                        // Sometimes launch an IO task to mess with a scheduler\n                        if (Random.nextInt(0..9) == 0) {\n                            launch(Dispatchers.IO) {\n                                ioTaskMarker.set(true)\n                                observedIoThreads.add(Thread.currentThread())\n                                assertTrue(Thread.currentThread().isIoDispatcherThread())\n                            }\n                        }\n                    }\n                    completionLatch.await()\n                }\n            }\n\n            withContext(Dispatchers.Default) {\n                barrier.await()\n                var timesHelped = 0\n                while (!jobToComplete.isCompleted) {\n                    val result = runSingleTaskFromCurrentSystemDispatcher()\n                    assertFalse(ioTaskMarker.get())\n                    if (result == 0L) {\n                        ++timesHelped\n                        continue\n                    } else if (result >= 0L) {\n                        Thread.sleep(result.toDuration(DurationUnit.NANOSECONDS).toDelayMillis())\n                    } else {\n                        Thread.sleep(10)\n                    }\n                }\n                completionLatch.countDown()\n                assertEquals(100, timesHelped)\n                assertTrue(Thread.currentThread() in observedDefaultThreads, observedDefaultThreads.toString())\n            }\n        }\n    }\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/CoroutineSchedulerLivenessStressTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.scheduling.CoroutineScheduler.Companion.MAX_SUPPORTED_POOL_SIZE\nimport org.junit.*\nimport java.util.concurrent.*\n\nclass CoroutineSchedulerLivenessStressTest : TestBase() {\n    private val scheduler = lazy { CoroutineScheduler(CORE_POOL_SIZE, MAX_SUPPORTED_POOL_SIZE, Long.MAX_VALUE) }\n    private val iterations = 1000 * stressTestMultiplier\n\n    @After\n    fun tearDown() {\n        if (scheduler.isInitialized()) {\n            scheduler.value.close()\n        }\n    }\n\n    @Test\n    fun testInternalSubmissions() {\n        Assume.assumeTrue(CORE_POOL_SIZE >= 2)\n        repeat(iterations) {\n            val barrier = CyclicBarrier(CORE_POOL_SIZE + 1)\n            scheduler.value.execute {\n                repeat(CORE_POOL_SIZE) {\n                    scheduler.value.execute {\n                        barrier.await()\n                    }\n                }\n            }\n            barrier.await()\n        }\n    }\n\n    @Test\n    fun testExternalSubmissions() {\n        Assume.assumeTrue(CORE_POOL_SIZE >= 2)\n        repeat(iterations) {\n            val barrier = CyclicBarrier(CORE_POOL_SIZE + 1)\n            repeat(CORE_POOL_SIZE) {\n                scheduler.value.execute {\n                    barrier.await()\n                }\n            }\n            barrier.await()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/CoroutineSchedulerOversubscriptionTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.AtomicInteger\n\nclass CoroutineSchedulerOversubscriptionTest : TestBase() {\n\n    private val inDefault = AtomicInteger(0)\n\n    private fun CountDownLatch.runAndCheck() {\n        if (inDefault.incrementAndGet() > CORE_POOL_SIZE) {\n            error(\"Oversubscription detected\")\n        }\n\n        await()\n        inDefault.decrementAndGet()\n    }\n\n    @Test\n    fun testOverSubscriptionDeterministic() = runTest {\n        val barrier = CountDownLatch(1)\n        val threadsOccupiedBarrier = CyclicBarrier(CORE_POOL_SIZE)\n        // All threads but one\n        repeat(CORE_POOL_SIZE - 1) {\n            launch(Dispatchers.Default) {\n                threadsOccupiedBarrier.await()\n                barrier.runAndCheck()\n            }\n        }\n        threadsOccupiedBarrier.await()\n        withContext(Dispatchers.Default) {\n            // Put a task in a local queue, it will be stolen\n            launch(Dispatchers.Default) {\n                barrier.runAndCheck()\n            }\n            // Put one more task to trick the local queue check\n            launch(Dispatchers.Default) {\n                barrier.runAndCheck()\n            }\n\n            withContext(Dispatchers.IO) {\n                try {\n                    // Release the thread\n                    delay(100)\n                } finally {\n                    barrier.countDown()\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testOverSubscriptionStress() = repeat(1000 * stressTestMultiplierSqrt) {\n        inDefault.set(0)\n        runTest {\n            val barrier = CountDownLatch(1)\n            val threadsOccupiedBarrier = CyclicBarrier(CORE_POOL_SIZE)\n            // All threads but one\n            repeat(CORE_POOL_SIZE - 1) {\n                launch(Dispatchers.Default) {\n                    threadsOccupiedBarrier.await()\n                    barrier.runAndCheck()\n                }\n            }\n            threadsOccupiedBarrier.await()\n            withContext(Dispatchers.Default) {\n                // Put a task in a local queue\n                launch(Dispatchers.Default) {\n                    barrier.runAndCheck()\n                }\n                // Put one more task to trick the local queue check\n                launch(Dispatchers.Default) {\n                    barrier.runAndCheck()\n                }\n\n                withContext(Dispatchers.IO) {\n                    yield()\n                    barrier.countDown()\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/CoroutineSchedulerStressTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass CoroutineSchedulerStressTest : TestBase() {\n    private var dispatcher: SchedulerCoroutineDispatcher = SchedulerCoroutineDispatcher()\n    private val observedThreads = ConcurrentHashMap<Thread, Long>()\n    private val tasksNum = 500_000 * stressMemoryMultiplier()\n\n    private fun stressMemoryMultiplier(): Int {\n        return if (isStressTest) {\n            AVAILABLE_PROCESSORS * 4\n        } else {\n            1\n        }\n    }\n\n    private val processed = AtomicInteger(0)\n    private val finishLatch = CountDownLatch(1)\n\n    @After\n    fun tearDown() {\n        dispatcher.close()\n    }\n\n    @Test\n    fun testInternalTasksSubmissionProgress() {\n      /*\n       * Run a lot of tasks and validate that\n       * 1) All of them are completed successfully\n       * 2) Every thread executed task at least once\n       */\n        dispatcher.dispatch(EmptyCoroutineContext, Runnable {\n            for (i in 1..tasksNum) {\n                dispatcher.dispatch(EmptyCoroutineContext, ValidatingRunnable())\n            }\n        })\n\n        finishLatch.await()\n        val observed = observedThreads.size\n        // on slow machines not all threads can be observed\n        assertTrue(observed in (AVAILABLE_PROCESSORS - 1)..(AVAILABLE_PROCESSORS + 1), \"Observed $observed threads with $AVAILABLE_PROCESSORS available processors\")\n        validateResults()\n    }\n\n    @Test\n    fun testStealingFromNonProgressing() {\n        /*\n         * Work-stealing stress test,\n         * one thread submits pack of tasks, waits until they are completed (to avoid work offloading)\n         * and then repeats, thus never executing its own tasks and relying only on work stealing.\n         */\n        var blockingThread: Thread? = null\n        dispatcher.dispatch(EmptyCoroutineContext, Runnable {\n            // Submit million tasks\n            blockingThread = Thread.currentThread()\n            var submittedTasks = 0\n            while (submittedTasks < tasksNum) {\n\n                ++submittedTasks\n                dispatcher.dispatch(EmptyCoroutineContext, ValidatingRunnable())\n                while (submittedTasks - processed.get() > 100) {\n                    Thread.yield()\n                }\n            }\n            // Block current thread\n            finishLatch.await()\n        })\n\n        finishLatch.await()\n\n        assertFalse(observedThreads.containsKey(blockingThread!!))\n        validateResults()\n    }\n\n    private fun processTask() {\n        val counter = observedThreads[Thread.currentThread()] ?: 0L\n        observedThreads[Thread.currentThread()] = counter + 1\n        if (processed.incrementAndGet() == tasksNum) {\n            finishLatch.countDown()\n        }\n    }\n\n    private fun validateResults() {\n        val result = observedThreads.values.sum()\n        assertEquals(tasksNum.toLong(), result)\n    }\n\n    private inner class ValidatingRunnable : Runnable {\n        private val invoked = atomic(false)\n        override fun run() {\n            if (!invoked.compareAndSet(false, true)) error(\"The same runnable was invoked twice\")\n            processTask()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/CoroutineSchedulerTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.lang.Runnable\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass CoroutineSchedulerTest : TestBase() {\n    private val taskModes = listOf(TASK_NON_BLOCKING, TASK_PROBABLY_BLOCKING)\n\n    @Test\n    fun testModesExternalSubmission() { // Smoke\n        CoroutineScheduler(1, 1).use {\n            for (mode in taskModes) {\n                val latch = CountDownLatch(1)\n                it.dispatch(Runnable {\n                    latch.countDown()\n                }, TaskContextImpl(mode))\n\n                latch.await()\n            }\n        }\n    }\n\n    @Test\n    fun testModesInternalSubmission() { // Smoke\n        CoroutineScheduler(2, 2).use {\n            val latch = CountDownLatch(taskModes.size)\n            it.dispatch(Runnable {\n                for (mode in taskModes) {\n                    it.dispatch(Runnable {\n                        latch.countDown()\n                    }, TaskContextImpl(mode))\n                }\n            })\n\n            latch.await()\n        }\n    }\n\n    @Test\n    fun testNonFairSubmission() {\n        CoroutineScheduler(1, 1).use {\n            val startLatch = CountDownLatch(1)\n            val finishLatch = CountDownLatch(2)\n\n            it.dispatch(Runnable {\n                it.dispatch(Runnable {\n                    expect(2)\n                    finishLatch.countDown()\n                })\n\n                it.dispatch(Runnable {\n                    expect(1)\n                    finishLatch.countDown()\n                })\n            })\n\n            startLatch.countDown()\n            finishLatch.await()\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testFairSubmission() {\n        CoroutineScheduler(1, 1).use {\n            val startLatch = CountDownLatch(1)\n            val finishLatch = CountDownLatch(2)\n\n            it.dispatch(Runnable {\n                it.dispatch(Runnable {\n                    expect(1)\n                    finishLatch.countDown()\n                })\n\n                it.dispatch(Runnable {\n                    expect(2)\n                    finishLatch.countDown()\n                }, tailDispatch = true)\n            })\n\n            startLatch.countDown()\n            finishLatch.await()\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testRngUniformDistribution() {\n        CoroutineScheduler(1, 128).use { scheduler ->\n            val worker = scheduler.Worker(1)\n            testUniformDistribution(worker, 2)\n            testUniformDistribution(worker, 4)\n            testUniformDistribution(worker, 8)\n            testUniformDistribution(worker, 12)\n            testUniformDistribution(worker, 16)\n        }\n    }\n\n    @Test(expected = IllegalArgumentException::class)\n    fun testNegativeCorePoolSize() {\n        SchedulerCoroutineDispatcher(-1, 4)\n    }\n\n    @Test(expected = IllegalArgumentException::class)\n    fun testNegativeMaxPoolSize() {\n        SchedulerCoroutineDispatcher(1, -4)\n    }\n\n    @Test(expected = IllegalArgumentException::class)\n    fun testCorePoolSizeGreaterThanMaxPoolSize() {\n        SchedulerCoroutineDispatcher(4, 1)\n    }\n\n    @Test\n    fun testSelfClose() {\n        val dispatcher = SchedulerCoroutineDispatcher(1, 1)\n        val latch = CountDownLatch(1)\n        dispatcher.dispatch(EmptyCoroutineContext, Runnable {\n            dispatcher.close(); latch.countDown()\n        })\n        latch.await()\n    }\n\n    @Test\n    fun testInterruptionCleanup() {\n        SchedulerCoroutineDispatcher(1, 1).use {\n            val executor = it.executor\n            var latch = CountDownLatch(1)\n            executor.execute {\n                Thread.currentThread().interrupt()\n                latch.countDown()\n            }\n            latch.await()\n            Thread.sleep(100) // I am really sorry\n            latch = CountDownLatch(1)\n            executor.execute {\n                try {\n                    assertFalse(Thread.currentThread().isInterrupted)\n                } finally {\n                    latch.countDown()\n                }\n            }\n            latch.await()\n        }\n    }\n\n    private fun testUniformDistribution(worker: CoroutineScheduler.Worker, bound: Int) {\n        val result = IntArray(bound)\n        val iterations = 10_000_000\n        repeat(iterations) {\n            ++result[worker.nextInt(bound)]\n        }\n\n        val bucketSize = iterations / bound\n        for (i in result) {\n            val ratio = i.toDouble() / bucketSize\n            // 10% deviation\n            check(ratio <= 1.1)\n            check(ratio >= 0.9)\n        }\n    }\n\n    private class TaskContextImpl(override val taskMode: Int) : TaskContext {\n        override fun afterTask() {}\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/DefaultDispatchersTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport kotlin.test.*\n\nclass DefaultDispatchersTest : TestBase() {\n\n    private /*const*/ val EXPECTED_PARALLELISM = 64\n\n    @Test(timeout = 10_000L)\n    fun testLimitedParallelismIsSeparatedFromDefaultIo() = runTest {\n        val barrier = CyclicBarrier(EXPECTED_PARALLELISM + 1)\n        val ioBlocker = CountDownLatch(1)\n        repeat(EXPECTED_PARALLELISM) {\n            launch(Dispatchers.IO) {\n                barrier.await()\n                ioBlocker.await()\n            }\n        }\n\n        barrier.await() // Ensure all threads are occupied\n        barrier.reset()\n        val limited = Dispatchers.IO.limitedParallelism(EXPECTED_PARALLELISM)\n        repeat(EXPECTED_PARALLELISM) {\n            launch(limited) {\n                barrier.await()\n            }\n        }\n        barrier.await()\n        ioBlocker.countDown()\n    }\n\n    @Test(timeout = 10_000L)\n    fun testDefaultDispatcherIsSeparateFromIO() = runTest {\n        val ioBarrier = CyclicBarrier(EXPECTED_PARALLELISM + 1)\n        val ioBlocker = CountDownLatch(1)\n        repeat(EXPECTED_PARALLELISM) {\n            launch(Dispatchers.IO) {\n                ioBarrier.await()\n                ioBlocker.await()\n            }\n        }\n\n        ioBarrier.await() // Ensure all threads are occupied\n        val parallelism = Runtime.getRuntime().availableProcessors()\n        val defaultBarrier = CyclicBarrier(parallelism + 1)\n        repeat(parallelism) {\n            launch(Dispatchers.Default) {\n                defaultBarrier.await()\n            }\n        }\n        defaultBarrier.await()\n        ioBlocker.countDown()\n    }\n\n    @Test\n    fun testHardCapOnParallelism() = runTest {\n        val iterations = 100_000 * stressTestMultiplierSqrt\n        val concurrency = AtomicInteger()\n        repeat(iterations) {\n            launch(Dispatchers.IO) {\n                val c = concurrency.incrementAndGet()\n                assertTrue(\"Got: $c\") { c <= EXPECTED_PARALLELISM }\n                concurrency.decrementAndGet()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/LimitingCoroutineDispatcherStressTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass LimitingCoroutineDispatcherStressTest : SchedulerTestBase() {\n\n    init {\n        corePoolSize = 3\n    }\n\n    private val blocking = blockingDispatcher(2)\n    private val cpuView = view(2)\n    private val cpuView2 = view(2)\n    private val concurrentWorkers = atomic(0)\n    private val iterations = 25_000 * stressTestMultiplierSqrt\n\n    @Test\n    fun testCpuLimitNotExtended() = runBlocking<Unit> {\n        val tasks = ArrayList<Deferred<*>>(iterations * 2)\n        repeat(iterations) {\n            tasks += task(cpuView, 3)\n            tasks += task(cpuView2, 3)\n        }\n\n        tasks.awaitAll()\n    }\n\n    @Test\n    fun testCpuLimitWithBlocking() = runBlocking<Unit> {\n        val tasks = ArrayList<Deferred<*>>(iterations * 2)\n        repeat(iterations) {\n            tasks += task(cpuView, 4)\n            tasks += task(blocking, 4)\n        }\n\n        tasks.awaitAll()\n    }\n\n    private fun task(ctx: CoroutineContext, maxLimit: Int): Deferred<Unit> = GlobalScope.async(ctx) {\n        try {\n            val currentlyExecuting = concurrentWorkers.incrementAndGet()\n            assertTrue(currentlyExecuting <= maxLimit, \"Executing: $currentlyExecuting, max limit: $maxLimit\")\n        } finally {\n            concurrentWorkers.decrementAndGet()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/LimitingDispatcherTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.concurrent.*\n\nclass LimitingDispatcherTest : SchedulerTestBase() {\n\n    @Test(expected = IllegalArgumentException::class)\n    fun testNegativeView() {\n        view(-1)\n    }\n\n    @Test(expected = IllegalArgumentException::class)\n    fun testZeroView() {\n        view(0)\n    }\n\n    @Test(timeout = 10_000)\n    fun testBlockingInterleave() = runBlocking {\n        corePoolSize = 3\n        val view = view(2)\n        val blocking = blockingDispatcher(4)\n        val barrier = CyclicBarrier(6)\n        val tasks = ArrayList<Job>(6)\n        repeat(2) {\n            tasks += async(view) {\n                barrier.await()\n            }\n\n            repeat(2) {\n                tasks += async(blocking) {\n                    barrier.await()\n                }\n            }\n        }\n\n        tasks.joinAll()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/SchedulerTestBase.kt",
        "content": "@file:Suppress(\"UNUSED_VARIABLE\")\n\npackage kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport org.junit.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nabstract class SchedulerTestBase : TestBase() {\n    companion object {\n        val CORES_COUNT = AVAILABLE_PROCESSORS\n\n        /**\n         * Asserts that [expectedThreadsCount] pool worker threads were created.\n         * Note that 'created' doesn't mean 'exists' because pool supports dynamic shrinking\n         */\n        fun checkPoolThreadsCreated(expectedThreadsCount: Int = CORES_COUNT) {\n            val threadsCount = maxSequenceNumber()!!\n            assertEquals(expectedThreadsCount, threadsCount, \"Expected $expectedThreadsCount pool threads, but has $threadsCount\")\n        }\n\n        /**\n         * Asserts that any number of pool worker threads in [range] were created.\n         * Note that 'created' doesn't mean 'exists' because pool supports dynamic shrinking\n         */\n        fun checkPoolThreadsCreated(range: IntRange, base: Int = CORES_COUNT) {\n            val maxSequenceNumber = maxSequenceNumber()!!\n            val r = (range.first)..(range.last + base)\n            assertTrue(\n                maxSequenceNumber in r,\n                \"Expected pool threads to be in interval $r, but has $maxSequenceNumber\"\n            )\n        }\n\n        private fun maxSequenceNumber(): Int? {\n            return Thread.getAllStackTraces().keys.asSequence().filter { it is CoroutineScheduler.Worker }\n                .map { sequenceNumber(it.name) }.maxOrNull()\n        }\n\n        private fun sequenceNumber(threadName: String): Int {\n            val suffix = threadName.substring(threadName.lastIndexOf(\"-\") + 1)\n            val separatorIndex = suffix.indexOf(' ')\n            if (separatorIndex == -1) {\n                return suffix.toInt()\n            }\n\n            return suffix.substring(0, separatorIndex).toInt()\n        }\n\n        suspend fun Iterable<Job>.joinAll() = forEach { it.join() }\n    }\n\n    protected var corePoolSize = CORES_COUNT\n    protected var maxPoolSize = 1024\n    protected var idleWorkerKeepAliveNs = IDLE_WORKER_KEEP_ALIVE_NS\n\n    private var _dispatcher: SchedulerCoroutineDispatcher? = null\n    protected val dispatcher: CoroutineDispatcher\n        get() {\n            if (_dispatcher == null) {\n                _dispatcher = SchedulerCoroutineDispatcher(\n                    corePoolSize,\n                    maxPoolSize,\n                    idleWorkerKeepAliveNs\n                )\n            }\n\n            return _dispatcher!!\n        }\n\n    protected var blockingDispatcher = lazy {\n        blockingDispatcher(1000)\n    }\n\n    protected fun blockingDispatcher(parallelism: Int): CoroutineDispatcher {\n        val intitialize = dispatcher\n        return _dispatcher!!.blocking(parallelism)\n    }\n\n    protected fun view(parallelism: Int): CoroutineDispatcher {\n        val intitialize = dispatcher\n        return _dispatcher!!.limitedParallelism(parallelism)\n    }\n\n    @After\n    fun after() {\n        runBlocking {\n            withTimeout(5_000) {\n                _dispatcher?.close()\n            }\n        }\n    }\n}\n\ninternal fun SchedulerCoroutineDispatcher.blocking(parallelism: Int = 16): CoroutineDispatcher {\n    return object : CoroutineDispatcher() {\n\n        @InternalCoroutinesApi\n        override fun dispatchYield(context: CoroutineContext, block: Runnable) {\n            this@blocking.dispatchWithContext(block, BlockingContext, true)\n        }\n\n        override fun dispatch(context: CoroutineContext, block: Runnable) {\n            this@blocking.dispatchWithContext(block, BlockingContext, false)\n        }\n    }.limitedParallelism(parallelism)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/SharingWorkerClassTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass SharingWorkerClassTest : SchedulerTestBase() {\n    private val threadLocal = ThreadLocal<Int?>()\n\n    @Test\n    fun testSharedThread() = runTest {\n        val dispatcher = SchedulerCoroutineDispatcher(1, schedulerName = \"first\")\n        val dispatcher2 = SchedulerCoroutineDispatcher(1, schedulerName = \"second\")\n\n        try {\n            withContext(dispatcher) {\n                assertNull(threadLocal.get())\n                threadLocal.set(239)\n                withContext(dispatcher2) {\n                    assertNull(threadLocal.get())\n                    threadLocal.set(42)\n                }\n\n                assertEquals(239, threadLocal.get())\n            }\n        } finally {\n            dispatcher.close()\n            dispatcher2.close()\n        }\n    }\n\n    @Test(timeout = 5000L)\n    fun testProgress() = runTest {\n        // See #990\n        val cores = Runtime.getRuntime().availableProcessors()\n        repeat(cores + 1) {\n            CoroutineScope(Dispatchers.Default).launch {\n                SchedulerCoroutineDispatcher(1).close()\n            }.join()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/TestTimeSource.kt",
        "content": "package kotlinx.coroutines.scheduling\n\n\ninternal class TestTimeSource(var time: Long) : SchedulerTimeSource() {\n\n    override fun nanoTime() = time\n\n    fun step(delta: Long = WORK_STEALING_TIME_RESOLUTION_NS) {\n        time += delta\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/WorkQueueStressTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.concurrent.*\nimport kotlin.jvm.internal.*\nimport kotlin.test.*\n\nclass WorkQueueStressTest : TestBase() {\n\n    private val threads = mutableListOf<Thread>()\n    private val offerIterations = 100_000 * stressTestMultiplierSqrt // memory pressure, not CPU time\n    private val stealersCount = 6\n    private val stolenTasks = Array(stealersCount) { GlobalQueue() }\n    private val globalQueue = GlobalQueue() // only producer will use it\n    private val producerQueue = WorkQueue()\n\n    @Volatile\n    private var producerFinished = false\n\n    @Before\n    fun setUp() {\n        schedulerTimeSource = TestTimeSource(Long.MAX_VALUE) // always steal\n    }\n\n    @After\n    fun tearDown() {\n        schedulerTimeSource = NanoTimeSource\n    }\n\n    @Test\n    fun testStealing() {\n        val startLatch = CountDownLatch(1)\n\n        threads += thread(name = \"producer\") {\n            startLatch.await()\n            for (i in 1..offerIterations) {\n                while (producerQueue.size > BUFFER_CAPACITY / 2) {\n                    Thread.yield()\n                }\n\n                producerQueue.add(task(i.toLong()))?.let { globalQueue.addLast(it) }\n            }\n\n            producerFinished = true\n        }\n\n        for (i in 0 until stealersCount) {\n            threads += thread(name = \"stealer $i\") {\n                val ref = Ref.ObjectRef<Task?>()\n                val myQueue = WorkQueue()\n                startLatch.await()\n                while (!producerFinished || producerQueue.size != 0) {\n                    stolenTasks[i].addAll(myQueue.drain(ref).map { task(it) })\n                    producerQueue.trySteal(ref)\n                }\n\n                // Drain last element which is not counted in buffer\n                stolenTasks[i].addAll(myQueue.drain(ref).map { task(it) })\n                producerQueue.trySteal(ref)\n                stolenTasks[i].addAll(myQueue.drain(ref).map { task(it) })\n            }\n        }\n\n        startLatch.countDown()\n        threads.forEach { it.join() }\n        validate()\n    }\n\n    @Test\n    fun testSingleProducerSingleStealer() {\n        val startLatch = CountDownLatch(1)\n        threads += thread(name = \"producer\") {\n            startLatch.await()\n            for (i in 1..offerIterations) {\n                while (producerQueue.size == BUFFER_CAPACITY - 1) {\n                    Thread.yield()\n                }\n\n                // No offloading to global queue here\n                producerQueue.add(task(i.toLong()))\n            }\n        }\n\n        val stolen = GlobalQueue()\n        threads += thread(name = \"stealer\") {\n            val myQueue = WorkQueue()\n            val ref = Ref.ObjectRef<Task?>()\n            startLatch.await()\n            while (stolen.size != offerIterations) {\n                if (producerQueue.trySteal(ref) != NOTHING_TO_STEAL) {\n                    stolen.addAll(myQueue.drain(ref).map { task(it) })\n                }\n            }\n            stolen.addAll(myQueue.drain(ref).map { task(it) })\n        }\n\n        startLatch.countDown()\n        threads.forEach { it.join() }\n        assertEquals((1L..offerIterations).toSet(), stolen.map { it.submissionTime }.toSet())\n    }\n\n    private fun validate() {\n        val result = mutableSetOf<Long>()\n        for (stolenTask in stolenTasks) {\n            assertEquals(stolenTask.size, stolenTask.map { it }.toSet().size)\n            result += stolenTask.map { it.submissionTime }\n        }\n\n        result += globalQueue.map { it.submissionTime }\n        val expected = (1L..offerIterations).toSet()\n        assertEquals(expected, result, \"Following elements are missing: ${(expected - result)}\")\n    }\n\n    private fun GlobalQueue.addAll(tasks: Collection<Task>) {\n        tasks.forEach { addLast(it) }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/scheduling/WorkQueueTest.kt",
        "content": "package kotlinx.coroutines.scheduling\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.jvm.internal.Ref.ObjectRef\nimport kotlin.test.*\n\nclass WorkQueueTest : TestBase() {\n\n    private val timeSource = TestTimeSource(0)\n\n    @Before\n    fun setUp() {\n        schedulerTimeSource = timeSource\n    }\n\n    @After\n    fun tearDown() {\n        schedulerTimeSource = NanoTimeSource\n    }\n\n    @Test\n    fun testLastScheduledComesFirst() {\n        val queue = WorkQueue()\n        (1L..4L).forEach { queue.add(task(it)) }\n        assertEquals(listOf(4L, 1L, 2L, 3L), queue.drain(ObjectRef()))\n    }\n\n    @Test\n    fun testAddWithOffload() {\n        val queue = WorkQueue()\n        val size = 130L\n        val offload = GlobalQueue()\n        (0 until size).forEach { queue.add(task(it))?.let { t -> offload.addLast(t) } }\n\n        val expectedResult = listOf(129L) + (0L..126L).toList()\n        val actualResult = queue.drain(ObjectRef())\n        assertEquals(expectedResult, actualResult)\n        assertEquals((0L until size).toSet().minus(expectedResult.toSet()), offload.drain().toSet())\n    }\n\n    @Test\n    fun testWorkOffloadPrecision() {\n        val queue = WorkQueue()\n        val globalQueue = GlobalQueue()\n        repeat(128) { assertNull(queue.add(task(it.toLong()))) }\n        assertTrue(globalQueue.isEmpty)\n        assertEquals(127L, queue.add(task(0))?.submissionTime)\n    }\n\n    @Test\n    fun testStealingFromHead() {\n        val victim = WorkQueue()\n        victim.add(task(1L))\n        victim.add(task(2L))\n        timeSource.step()\n        timeSource.step(3)\n\n        val stealer = WorkQueue()\n        val ref = ObjectRef<Task?>()\n        assertEquals(TASK_STOLEN, victim.trySteal(ref))\n        assertEquals(arrayListOf(1L), stealer.drain(ref))\n\n        assertEquals(TASK_STOLEN, victim.trySteal(ref))\n        assertEquals(arrayListOf(2L), stealer.drain(ref))\n    }\n\n    @Test\n    fun testPollBlocking() {\n        val queue = WorkQueue()\n        assertNull(queue.pollBlocking())\n        val blockingTask = blockingTask(1L)\n        queue.add(blockingTask)\n        queue.add(task(1L))\n        assertSame(blockingTask, queue.pollBlocking())\n    }\n}\n\ninternal fun task(n: Long) = TaskImpl(Runnable {}, n, NonBlockingContext)\ninternal fun blockingTask(n: Long) = TaskImpl(Runnable {}, n, BlockingContext)\n\ninternal fun WorkQueue.drain(ref: ObjectRef<Task?>): List<Long> {\n    var task: Task? = poll()\n    val result = arrayListOf<Long>()\n    while (task != null) {\n        result += task.submissionTime\n        task = poll()\n    }\n    if (ref.element != null) {\n        result += ref.element!!.submissionTime\n        ref.element = null\n    }\n    return result\n}\n\ninternal fun GlobalQueue.drain(): List<Long> {\n    var task: Task? = removeFirstOrNull()\n    val result = arrayListOf<Long>()\n    while (task != null) {\n        result += task.submissionTime\n        task = removeFirstOrNull()\n    }\n    return result\n}\n\ninternal fun WorkQueue.trySteal(stolenTaskRef: ObjectRef<Task?>): Long = trySteal(STEAL_ANY, stolenTaskRef)\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/selects/SelectDeadlockStressTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\n/**\n * A simple stress-test that does select sending/receiving into opposite channels to ensure that they\n * don't deadlock. See https://github.com/Kotlin/kotlinx.coroutines/issues/504\n */\nclass SelectDeadlockStressTest : TestBase() {\n    private val pool = newFixedThreadPoolContext(2, \"SelectDeadlockStressTest\")\n    private val nSeconds = 3 * stressTestMultiplier\n\n    @After\n    fun tearDown() {\n        pool.close()\n    }\n\n    @Test\n    fun testStress() = runTest {\n        val c1 = Channel<Long>()\n        val c2 = Channel<Long>()\n        val s1 = Stats()\n        val s2 = Stats()\n        launchSendReceive(c1, c2, s1)\n        launchSendReceive(c2, c1, s2)\n        for (i in 1..nSeconds) {\n            delay(1000)\n            println(\"$i: First: $s1; Second: $s2\")\n        }\n        coroutineContext.cancelChildren()\n    }\n\n    private class Stats {\n        var sendIndex = 0L\n        var receiveIndex = 0L\n\n        override fun toString(): String = \"send=$sendIndex, received=$receiveIndex\"\n    }\n\n    private fun CoroutineScope.launchSendReceive(c1: Channel<Long>, c2: Channel<Long>, s: Stats) = launch(pool) {\n        while (true) {\n            if (s.sendIndex % 1000 == 0L) yield()\n            select<Unit> {\n                c1.onSend(s.sendIndex) {\n                    s.sendIndex++\n                }\n                c2.onReceive { i ->\n                    assertEquals(s.receiveIndex, i)\n                    s.receiveIndex++\n                }\n            }\n        }\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/selects/SelectMemoryLeakStressTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.test.*\n\nclass SelectMemoryLeakStressTest : TestBase() {\n    private val nRepeat = 1_000_000 * stressTestMultiplier\n\n    @Test\n    fun testLeakRegisterSend() = runTest {\n        expect(1)\n        val leak = Channel<String>()\n        val data = Channel<Int>(1)\n        repeat(nRepeat) { value ->\n            data.send(value)\n            val bigValue = bigValue() // new instance\n            select {\n                leak.onSend(\"LEAK\") {\n                    println(\"Capture big value into this lambda: $bigValue\")\n                    expectUnreached()\n                }\n                data.onReceive { received ->\n                    assertEquals(value, received)\n                    expect(value + 2)\n                }\n            }\n        }\n        finish(nRepeat + 2)\n    }\n\n    @Test\n    fun testLeakRegisterReceive() = runTest {\n        expect(1)\n        val leak = Channel<String>()\n        val data = Channel<Int>(1)\n        repeat(nRepeat) { value ->\n            val bigValue = bigValue() // new instance\n            select {\n                leak.onReceive {\n                    println(\"Capture big value into this lambda: $bigValue\")\n                    expectUnreached()\n                }\n                data.onSend(value) {\n                    expect(value + 2)\n                }\n            }\n            assertEquals(value, data.receive())\n        }\n        finish(nRepeat + 2)\n    }\n\n    // capture big value for fast OOM in case of a bug\n    private fun bigValue(): ByteArray = ByteArray(4096)\n}"
    },
    {
        "path": "kotlinx-coroutines-core/jvm/test/selects/SelectPhilosophersStressTest.kt",
        "content": "package kotlinx.coroutines.selects\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass SelectPhilosophersStressTest : TestBase() {\n    private val TEST_DURATION = 3000L * stressTestMultiplierSqrt\n\n    val n = 10 // number of philosophers\n    private val forks = Array(n) { Mutex() }\n\n    private suspend fun eat(id: Int, desc: String) {\n        val left = forks[id]\n        val right = forks[(id + 1) % n]\n        while (true) {\n            val pair = selectUnbiased<Pair<Mutex, Mutex>> {\n                left.onLock(desc) { left to right }\n                right.onLock(desc) { right to left }\n            }\n            if (pair.second.tryLock(desc)) break\n            pair.first.unlock(desc)\n            pair.second.lock(desc)\n            if (pair.first.tryLock(desc)) break\n            pair.second.unlock(desc)\n        }\n        assertTrue(left.isLocked && right.isLocked)\n        // om, nom, nom --> eating!!!\n        right.unlock(desc)\n        left.unlock(desc)\n    }\n\n    @Test\n    fun testPhilosophers() = runBlocking<Unit> {\n        val timeLimit = System.currentTimeMillis() + TEST_DURATION\n        val philosophers = List<Deferred<Int>>(n) { id ->\n            async {\n                val desc = \"Philosopher $id\"\n                var eatsCount = 0\n                while (System.currentTimeMillis() < timeLimit) {\n                    eat(id, desc)\n                    eatsCount++\n                    yield()\n                }\n                println(\"Philosopher $id done, eats $eatsCount times\")\n                eatsCount\n            }\n        }\n        val debugJob = launch {\n            delay(3 * TEST_DURATION)\n            println(\"Test is failing. Lock states are:\")\n            forks.withIndex().forEach { (id, mutex) -> println(\"$id: $mutex\") }\n        }\n        val eats = withTimeout(5 * TEST_DURATION) { philosophers.map { it.await() } }\n        debugJob.cancel()\n        eats.withIndex().forEach { (id, eats) ->\n            assertTrue(eats > 0, \"$id shall not starve\")\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvmBenchmark/kotlin/kotlinx/coroutines/BenchmarkUtils.kt",
        "content": "package kotlinx.coroutines\n\nimport java.util.concurrent.*\n\npublic fun doGeomDistrWork(work: Int) {\n    // We use geometric distribution here. We also checked on macbook pro 13\" (2017) that the resulting work times\n    // are distributed geometrically, see https://github.com/Kotlin/kotlinx.coroutines/pull/1464#discussion_r355705325\n    val p = 1.0 / work\n    val r = ThreadLocalRandom.current()\n    while (true) {\n        if (r.nextDouble() < p) break\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvmBenchmark/kotlin/kotlinx/coroutines/SemaphoreBenchmark.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.scheduling.*\nimport kotlinx.coroutines.sync.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MICROSECONDS)\n@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MICROSECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class SemaphoreBenchmark {\n    @Param\n    private var _1_dispatcher: SemaphoreBenchDispatcherCreator = SemaphoreBenchDispatcherCreator.DEFAULT\n\n    @Param(\"0\", \"1000\")\n    private var _2_coroutines: Int = 0\n\n    @Param(\"1\", \"2\", \"4\", \"8\", \"32\", \"128\", \"100000\")\n    private var _3_maxPermits: Int = 0\n\n    @Param(\"1\", \"2\", \"4\", \"8\", \"16\") // local machine\n//    @Param(\"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\") // Server\n    private var _4_parallelism: Int = 0\n\n    private lateinit var dispatcher: CoroutineDispatcher\n    private var coroutines = 0\n\n    @InternalCoroutinesApi\n    @Setup\n    fun setup() {\n        dispatcher = _1_dispatcher.create(_4_parallelism)\n        coroutines = if (_2_coroutines == 0) _4_parallelism else _2_coroutines\n    }\n\n    @Benchmark\n    fun semaphore() = runBlocking {\n        val n = BATCH_SIZE / coroutines\n        val semaphore = Semaphore(_3_maxPermits)\n        val jobs = ArrayList<Job>(coroutines)\n        repeat(coroutines) {\n            jobs += GlobalScope.launch {\n                repeat(n) {\n                    semaphore.withPermit {\n                        doGeomDistrWork(WORK_INSIDE)\n                    }\n                    doGeomDistrWork(WORK_OUTSIDE)\n                }\n            }\n        }\n        jobs.forEach { it.join() }\n    }\n\n    @Benchmark\n    fun channelAsSemaphore() = runBlocking {\n        val n = BATCH_SIZE / coroutines\n        val semaphore = Channel<Unit>(_3_maxPermits)\n        val jobs = ArrayList<Job>(coroutines)\n        repeat(coroutines) {\n            jobs += GlobalScope.launch {\n                repeat(n) {\n                    semaphore.send(Unit) // acquire\n                    doGeomDistrWork(WORK_INSIDE)\n                    semaphore.receive() // release\n                    doGeomDistrWork(WORK_OUTSIDE)\n                }\n            }\n        }\n        jobs.forEach { it.join() }\n    }\n}\n\nenum class SemaphoreBenchDispatcherCreator(val create: (parallelism: Int) -> CoroutineDispatcher) {\n    FORK_JOIN({ parallelism -> ForkJoinPool(parallelism).asCoroutineDispatcher() }),\n    DEFAULT({ parallelism -> ExperimentalCoroutineDispatcher(corePoolSize = parallelism, maxPoolSize = parallelism) })\n}\n\nprivate const val WORK_INSIDE = 50\nprivate const val WORK_OUTSIDE = 50\nprivate const val BATCH_SIZE = 100000\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvmBenchmark/kotlin/kotlinx/coroutines/channels/ChannelProducerConsumerBenchmark.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.Channel\nimport kotlinx.coroutines.scheduling.*\nimport kotlinx.coroutines.selects.select\nimport org.openjdk.jmh.annotations.*\nimport java.lang.Integer.max\nimport java.util.concurrent.ForkJoinPool\nimport java.util.concurrent.Phaser\nimport java.util.concurrent.TimeUnit\n\n\n/**\n * Benchmark to measure channel algorithm performance in terms of average time per `send-receive` pair;\n * actually, it measures the time for a batch of such operations separated into the specified number of consumers/producers.\n * It uses different channels (rendezvous, buffered, unlimited; see [ChannelCreator]) and different dispatchers\n * (see [DispatcherCreator]). If the [_3_withSelect] property is set, it invokes `send` and\n * `receive` via [select], waiting on a local dummy channel simultaneously, simulating a \"cancellation\" channel.\n *\n * Please, be patient, this benchmark takes quite a lot of time to complete.\n */\n@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MICROSECONDS)\n@Measurement(iterations = 20, time = 500, timeUnit = TimeUnit.MICROSECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.Throughput)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\nopen class ChannelProducerConsumerBenchmark {\n    @Param\n    private var _0_dispatcher: DispatcherCreator = DispatcherCreator.DEFAULT\n\n    @Param\n    private var _1_channel: ChannelCreator = ChannelCreator.RENDEZVOUS\n\n    @Param(\"0\", \"1000\")\n    private var _2_coroutines: Int = 0\n\n    @Param(\"false\", \"true\")\n    private var _3_withSelect: Boolean = false\n\n    @Param(\"1\", \"2\", \"4\", \"8\", \"16\") // local machine\n//    @Param(\"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\") // Server\n    private var _4_parallelism: Int = 0\n\n    @Param(\"50\")\n    private var _5_workSize: Int = 0\n\n    private lateinit var dispatcher: CoroutineDispatcher\n    private lateinit var channel: Channel<Int>\n\n    @InternalCoroutinesApi\n    @Setup\n    fun setup() {\n        dispatcher = _0_dispatcher.create(_4_parallelism)\n        channel = _1_channel.create()\n    }\n\n    @Benchmark\n    fun mcsp() {\n        if (_2_coroutines != 0) return\n        val producers = max(1, _4_parallelism - 1)\n        val consumers = 1\n        run(producers, consumers)\n    }\n\n    @Benchmark\n    fun spmc() {\n        if (_2_coroutines != 0) return\n        val producers = 1\n        val consumers = max(1, _4_parallelism - 1)\n        run(producers, consumers)\n    }\n\n    @Benchmark\n    fun mpmc() {\n        val producers = if (_2_coroutines == 0) (_4_parallelism + 1) / 2 else _2_coroutines / 2\n        val consumers = producers\n        run(producers, consumers)\n    }\n\n    private fun run(producers: Int, consumers: Int) {\n        val n = (APPROX_BATCH_SIZE / producers * producers) / consumers * consumers\n        val phaser = Phaser(producers + consumers + 1)\n        // Run producers\n        repeat(producers) {\n            GlobalScope.launch(dispatcher) {\n                val dummy = if (_3_withSelect) _1_channel.create() else null\n                repeat(n / producers) {\n                    produce(it, dummy)\n                }\n                phaser.arrive()\n            }\n        }\n        // Run consumers\n        repeat(consumers) {\n            GlobalScope.launch(dispatcher) {\n                val dummy = if (_3_withSelect) _1_channel.create() else null\n                repeat(n / consumers) {\n                    consume(dummy)\n                }\n                phaser.arrive()\n            }\n        }\n        // Wait until work is done\n        phaser.arriveAndAwaitAdvance()\n    }\n\n    private suspend fun produce(element: Int, dummy: Channel<Int>?) {\n        if (_3_withSelect) {\n            select<Unit> {\n                channel.onSend(element) {}\n                dummy!!.onReceive {}\n            }\n        } else {\n            channel.send(element)\n        }\n        doWork(_5_workSize)\n    }\n\n    private suspend fun consume(dummy: Channel<Int>?) {\n        if (_3_withSelect) {\n            select<Unit> {\n                channel.onReceive {}\n                dummy!!.onReceive {}\n            }\n        } else {\n            channel.receive()\n        }\n        doWork(_5_workSize)\n    }\n}\n\nenum class DispatcherCreator(val create: (parallelism: Int) -> CoroutineDispatcher) {\n    FORK_JOIN({ parallelism ->  ForkJoinPool(parallelism).asCoroutineDispatcher() }),\n    DEFAULT({ parallelism -> ExperimentalCoroutineDispatcher(corePoolSize = parallelism, maxPoolSize = parallelism) })\n}\n\nenum class ChannelCreator(private val capacity: Int) {\n    RENDEZVOUS(Channel.RENDEZVOUS),\n    BUFFERED_16(16),\n    BUFFERED_64(64),\n    BUFFERED_UNLIMITED(Channel.UNLIMITED);\n\n    fun create(): Channel<Int> = Channel(capacity)\n}\n\nprivate fun doWork(workSize: Int): Unit = doGeomDistrWork(workSize)\n\nprivate const val APPROX_BATCH_SIZE = 100_000\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvmBenchmark/kotlin/kotlinx/coroutines/channels/SelectBenchmark.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n@Warmup(iterations = 8, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 8, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class SelectBenchmark {\n    // 450\n    private val iterations = 1000\n\n    @Benchmark\n    fun stressSelect() = runBlocking {\n        val pingPong = Channel<Unit>()\n        launch {\n            repeat(iterations) {\n                select {\n                    pingPong.onSend(Unit) {}\n                }\n            }\n        }\n\n        launch {\n            repeat(iterations) {\n                select {\n                    pingPong.onReceive() {}\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvmBenchmark/kotlin/kotlinx/coroutines/channels/SimpleChannel.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\npublic abstract class SimpleChannel {\n    companion object {\n        const val NULL_SURROGATE: Int = -1\n    }\n\n    @JvmField\n    protected var producer: Continuation<Unit>? = null\n    @JvmField\n    protected var enqueuedValue: Int = NULL_SURROGATE\n    @JvmField\n    protected var consumer: Continuation<Int>? = null\n\n    suspend fun send(element: Int) {\n        require(element != NULL_SURROGATE)\n        if (offer(element)) {\n            return\n        }\n\n        return suspendSend(element)\n    }\n\n    private fun offer(element: Int): Boolean {\n        if (consumer == null) {\n            return false\n        }\n\n        consumer!!.resume(element)\n        consumer = null\n        return true\n    }\n\n    suspend fun receive(): Int {\n        // Cached value\n        if (enqueuedValue != NULL_SURROGATE) {\n            val result = enqueuedValue\n            enqueuedValue = NULL_SURROGATE\n            producer!!.resume(Unit)\n            return result\n        }\n\n        return suspendReceive()\n    }\n\n    abstract suspend fun suspendReceive(): Int\n    abstract suspend fun suspendSend(element: Int)\n}\n\nclass NonCancellableChannel : SimpleChannel() {\n    override suspend fun suspendReceive(): Int = suspendCoroutineUninterceptedOrReturn {\n        consumer = it.intercepted()\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun suspendSend(element: Int) = suspendCoroutineUninterceptedOrReturn<Unit> {\n        enqueuedValue = element\n        producer = it.intercepted()\n        COROUTINE_SUSPENDED\n    }\n}\n\nclass CancellableChannel : SimpleChannel() {\n    override suspend fun suspendReceive(): Int = suspendCancellableCoroutine {\n        consumer = it.intercepted()\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun suspendSend(element: Int) = suspendCancellableCoroutine<Unit> {\n        enqueuedValue = element\n        producer = it.intercepted()\n        COROUTINE_SUSPENDED\n    }\n}\n\nclass CancellableReusableChannel : SimpleChannel() {\n    override suspend fun suspendReceive(): Int = suspendCancellableCoroutineReusable {\n        consumer = it.intercepted()\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun suspendSend(element: Int) = suspendCancellableCoroutineReusable<Unit> {\n        enqueuedValue = element\n        producer = it.intercepted()\n        COROUTINE_SUSPENDED\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvmBenchmark/kotlin/kotlinx/coroutines/channels/SimpleChannelBenchmark.kt",
        "content": "package kotlinx.coroutines.channels\n\nimport kotlinx.coroutines.*\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class SimpleChannelBenchmark {\n\n    private val iterations = 10_000\n\n    @Volatile\n    private var sink: Int = 0\n\n    @Benchmark\n    fun cancellable() = runBlocking {\n        val ch = CancellableChannel()\n        launch {\n            repeat(iterations) { ch.send(it) }\n        }\n\n        launch {\n            repeat(iterations) { sink = ch.receive() }\n        }\n    }\n\n    @Benchmark\n    fun cancellableReusable() = runBlocking {\n        val ch = CancellableReusableChannel()\n        launch {\n            repeat(iterations) { ch.send(it) }\n        }\n\n        launch {\n            repeat(iterations) { sink = ch.receive() }\n        }\n    }\n\n    @Benchmark\n    fun nonCancellable() = runBlocking {\n        val ch = NonCancellableChannel()\n        launch {\n            repeat(iterations) { ch.send(it) }\n        }\n\n        launch {\n            repeat(iterations) {\n                sink = ch.receive()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/jvmBenchmark/kotlin/kotlinx/coroutines/flow/TakeWhileBenchmark.kt",
        "content": "package kotlinx.coroutines.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlinx.coroutines.flow.internal.AbortFlowException\nimport kotlinx.coroutines.flow.internal.unsafeFlow\nimport org.openjdk.jmh.annotations.*\nimport java.util.concurrent.*\n\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(value = 1)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\n@State(Scope.Benchmark)\nopen class TakeWhileBenchmark {\n    @Param(\"1\", \"10\", \"100\", \"1000\")\n    private var size: Int = 0\n\n    private suspend inline fun Flow<Long>.consume() =\n        filter { it % 2L != 0L }\n            .map { it * it }.count()\n\n    @Benchmark\n    fun baseline() = runBlocking<Int> {\n        (0L until size).asFlow().consume()\n    }\n\n    @Benchmark\n    fun takeWhileDirect() = runBlocking<Int> {\n        (0L..Long.MAX_VALUE).asFlow().takeWhileDirect { it < size }.consume()\n    }\n\n    @Benchmark\n    fun takeWhileViaCollectWhile() = runBlocking<Int> {\n        (0L..Long.MAX_VALUE).asFlow().takeWhileViaCollectWhile { it < size }.consume()\n    }\n\n    // Direct implementation by checking predicate and throwing AbortFlowException\n    private fun <T> Flow<T>.takeWhileDirect(predicate: suspend (T) -> Boolean): Flow<T> = unsafeFlow {\n        try {\n            collect { value ->\n                if (predicate(value)) emit(value)\n                else throw AbortFlowException(this)\n            }\n        } catch (e: AbortFlowException) {\n            e.checkOwnership(owner = this)\n        }\n    }\n\n    // Essentially the same code, but reusing the logic via collectWhile function\n    private fun <T> Flow<T>.takeWhileViaCollectWhile(predicate: suspend (T) -> Boolean): Flow<T> = unsafeFlow {\n        // This return is needed to work around a bug in JS BE: KT-39227\n        return@unsafeFlow collectWhile { value ->\n            if (predicate(value)) {\n                emit(value)\n                true\n            } else {\n                false\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/Builders.kt",
        "content": "@file:OptIn(ExperimentalContracts::class, ObsoleteWorkersApi::class)\npackage kotlinx.coroutines\n\nimport kotlinx.cinterop.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.native.concurrent.*\n\n/**\n * Runs new coroutine and **blocks** current thread _interruptibly_ until its completion.\n *\n * It is designed to bridge regular blocking code to libraries that are written in suspending style, to be used in\n * `main` functions and in tests.\n *\n * Calling [runBlocking] from a suspend function is redundant.\n * For example, the following code is incorrect:\n * ```\n * suspend fun loadConfiguration() {\n *     // DO NOT DO THIS:\n *     val data = runBlocking { // <- redundant and blocks the thread, do not do that\n *         fetchConfigurationData() // suspending function\n *     }\n * ```\n *\n * Here, instead of releasing the thread on which `loadConfiguration` runs if `fetchConfigurationData` suspends, it will\n * block, potentially leading to thread starvation issues.\n *\n * The default [CoroutineDispatcher] for this builder in an implementation of [EventLoop] that processes continuations\n * in this blocked thread until the completion of this coroutine.\n * See [CoroutineDispatcher] for the other implementations that are provided by `kotlinx.coroutines`.\n *\n * When [CoroutineDispatcher] is explicitly specified in the [context], then the new coroutine runs in the context of\n * the specified dispatcher while the current thread is blocked. If the specified dispatcher implements [EventLoop]\n * interface and this `runBlocking` invocation is performed from inside of the this event loop's thread, then\n * this event loop is processed using its [processNextEvent][EventLoop.processNextEvent] method until coroutine completes.\n *\n * If this blocked thread is interrupted (see [Thread.interrupt]), then the coroutine job is cancelled and\n * this `runBlocking` invocation throws [InterruptedException].\n *\n * See [newCoroutineContext] for a description of debugging facilities that are available for newly created coroutine.\n *\n * @param context context of the coroutine. The default value is an implementation of [EventLoop].\n * @param block the coroutine code.\n */\npublic actual fun <T> runBlocking(context: CoroutineContext, block: suspend CoroutineScope.() -> T): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    val contextInterceptor = context[ContinuationInterceptor]\n    val eventLoop: EventLoop?\n    val newContext: CoroutineContext\n    if (contextInterceptor == null) {\n        // create or use private event loop if no dispatcher is specified\n        eventLoop = ThreadLocalEventLoop.eventLoop\n        newContext = GlobalScope.newCoroutineContext(context + eventLoop)\n    } else {\n        // See if context's interceptor is an event loop that we shall use (to support TestContext)\n        // or take an existing thread-local event loop if present to avoid blocking it (but don't create one)\n        eventLoop = (contextInterceptor as? EventLoop)?.takeIf { it.shouldBeProcessedFromContext() }\n            ?: ThreadLocalEventLoop.currentOrNull()\n        newContext = GlobalScope.newCoroutineContext(context)\n    }\n    val coroutine = BlockingCoroutine<T>(newContext, eventLoop)\n    var completed = false\n    ThreadLocalKeepAlive.addCheck { !completed }\n    try {\n        coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n        return coroutine.joinBlocking()\n    } finally {\n        completed = true\n    }\n}\n\n@ThreadLocal\nprivate object ThreadLocalKeepAlive {\n    /** If any of these checks passes, this means this [Worker] is still used. */\n    private var checks = mutableListOf<() -> Boolean>()\n\n    /** Whether the worker currently tries to keep itself alive. */\n    private var keepAliveLoopActive = false\n\n    /** Adds another stopgap that must be passed before the [Worker] can be terminated. */\n    fun addCheck(terminationForbidden: () -> Boolean) {\n        checks.add(terminationForbidden)\n        if (!keepAliveLoopActive) keepAlive()\n    }\n\n    /**\n     * Send a ping to the worker to prevent it from terminating while this coroutine is running,\n     * ensuring that continuations don't get dropped and forgotten.\n     */\n    private fun keepAlive() {\n        // only keep the checks that still forbid the termination\n        checks = checks.filter { it() }.toMutableList()\n        // if there are no checks left, we no longer keep the worker alive, it can be terminated\n        keepAliveLoopActive = checks.isNotEmpty()\n        if (keepAliveLoopActive) {\n            Worker.current.executeAfter(afterMicroseconds = 100_000) {\n                keepAlive()\n            }\n        }\n    }\n}\n\nprivate class BlockingCoroutine<T>(\n    parentContext: CoroutineContext,\n    private val eventLoop: EventLoop?\n) : AbstractCoroutine<T>(parentContext, true, true) {\n    private val joinWorker = Worker.current\n\n    override val isScopedCoroutine: Boolean get() = true\n\n    override fun afterCompletion(state: Any?) {\n        // wake up blocked thread\n        if (joinWorker != Worker.current) {\n            // Unpark waiting worker\n            joinWorker.executeAfter(0L, {}) // send an empty task to unpark the waiting event loop\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun joinBlocking(): T {\n        try {\n            eventLoop?.incrementUseCount()\n            while (true) {\n                var parkNanos: Long\n                // Workaround for bug in BE optimizer that cannot eliminate boxing here\n                if (eventLoop != null) {\n                    parkNanos = eventLoop.processNextEvent()\n                } else {\n                    parkNanos = Long.MAX_VALUE\n                }\n                // note: processNextEvent may lose unpark flag, so check if completed before parking\n                if (isCompleted) break\n                joinWorker.park(parkNanos / 1000L, true)\n            }\n        } finally { // paranoia\n            eventLoop?.decrementUseCount()\n        }\n        // now return result\n        val state = state.unboxState()\n        (state as? CompletedExceptionally)?.let { throw it.cause }\n        return state as T\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/CloseableCoroutineDispatcher.kt",
        "content": "package kotlinx.coroutines\n\npublic actual abstract class CloseableCoroutineDispatcher actual constructor() : CoroutineDispatcher() {\n    public actual abstract fun close()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/CoroutineContext.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\ninternal actual object DefaultExecutor : CoroutineDispatcher(), Delay {\n\n    private val delegate = WorkerDispatcher(name = \"DefaultExecutor\")\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        delegate.dispatch(context, block)\n    }\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        delegate.scheduleResumeAfterDelay(timeMillis, continuation)\n    }\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        return delegate.invokeOnTimeout(timeMillis, block, context)\n    }\n\n    actual fun enqueue(task: Runnable): Unit {\n        delegate.dispatch(EmptyCoroutineContext, task)\n    }\n}\n\ninternal expect fun createDefaultDispatcher(): CoroutineDispatcher\n\n@PublishedApi\ninternal actual val DefaultDelay: Delay = DefaultExecutor\n\npublic actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {\n    val combined = coroutineContext + context\n    return if (combined !== DefaultDelay && combined[ContinuationInterceptor] == null)\n        combined + (DefaultDelay as CoroutineContext.Element) else combined\n}\n\npublic actual fun CoroutineContext.newCoroutineContext(addedContext: CoroutineContext): CoroutineContext {\n    return this + addedContext\n}\n\n// No debugging facilities on native\ninternal actual inline fun <T> withCoroutineContext(context: CoroutineContext, countOrElement: Any?, block: () -> T): T = block()\ninternal actual inline fun <T> withContinuationContext(continuation: Continuation<*>, countOrElement: Any?, block: () -> T): T = block()\ninternal actual fun Continuation<*>.toDebugString(): String = toString()\ninternal actual val CoroutineContext.coroutineName: String? get() = null // not supported on native\n\ninternal actual class UndispatchedCoroutine<in T> actual constructor(\n    context: CoroutineContext,\n    uCont: Continuation<T>\n) : ScopeCoroutine<T>(context, uCont) {\n    override fun afterResume(state: Any?) = uCont.resumeWith(recoverResult(state, uCont))\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/Debug.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.math.*\nimport kotlin.native.*\n\ninternal actual val DEBUG: Boolean = false\n\ninternal actual val Any.hexAddress: String get() = identityHashCode().toUInt().toString(16)\n\ninternal actual val Any.classSimpleName: String get() = this::class.simpleName ?: \"Unknown\"\n\ninternal actual inline fun assert(value: () -> Boolean) {}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/Dispatchers.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n\npublic actual object Dispatchers {\n    public actual val Default: CoroutineDispatcher = createDefaultDispatcher()\n    public actual val Main: MainCoroutineDispatcher\n        get() = injectedMainDispatcher ?: mainDispatcher\n    public actual val Unconfined: CoroutineDispatcher get() = kotlinx.coroutines.Unconfined // Avoid freezing\n\n    private val mainDispatcher = createMainDispatcher(Default)\n\n    private var injectedMainDispatcher: MainCoroutineDispatcher? = null\n\n    @PublishedApi\n    internal fun injectMain(dispatcher: MainCoroutineDispatcher) {\n        injectedMainDispatcher = dispatcher\n    }\n\n    internal val IO: CoroutineDispatcher = DefaultIoScheduler\n}\n\ninternal object DefaultIoScheduler : CoroutineDispatcher() {\n    // 2048 is an arbitrary KMP-friendly constant\n    private val unlimitedPool = newFixedThreadPoolContext(2048, \"Dispatchers.IO\")\n    private val io = unlimitedPool.limitedParallelism(64) // Default JVM size\n\n    @ExperimentalCoroutinesApi\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        // See documentation to Dispatchers.IO for the rationale\n        return unlimitedPool.limitedParallelism(parallelism)\n    }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        io.dispatch(context, block)\n    }\n\n    @InternalCoroutinesApi\n    override fun dispatchYield(context: CoroutineContext, block: Runnable) {\n        io.dispatchYield(context, block)\n    }\n\n    override fun toString(): String = \"Dispatchers.IO\"\n}\n\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic actual val Dispatchers.IO: CoroutineDispatcher get() = IO\n\ninternal expect fun createMainDispatcher(default: CoroutineDispatcher): MainCoroutineDispatcher\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/EventLoop.kt",
        "content": "@file:OptIn(ObsoleteWorkersApi::class)\n\npackage kotlinx.coroutines\n\nimport kotlin.coroutines.*\nimport kotlin.native.concurrent.*\nimport kotlin.system.*\n\ninternal actual abstract class EventLoopImplPlatform : EventLoop() {\n\n    private val current = Worker.current\n\n    protected actual fun unpark() {\n        current.executeAfter(0L, {})// send an empty task to unpark the waiting event loop\n    }\n\n    protected actual fun reschedule(now: Long, delayedTask: EventLoopImplBase.DelayedTask) {\n        DefaultExecutor.invokeOnTimeout(now, delayedTask, EmptyCoroutineContext)\n    }\n}\n\ninternal class EventLoopImpl: EventLoopImplBase() {\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle =\n        DefaultDelay.invokeOnTimeout(timeMillis, block, context)\n}\n\ninternal actual fun createEventLoop(): EventLoop = EventLoopImpl()\n\n@Suppress(\"DEPRECATION\")\ninternal actual fun nanoTime(): Long = getTimeNanos()\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/Exceptions.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * Thrown by cancellable suspending functions if the [Job] of the coroutine is cancelled while it is suspending.\n * It indicates _normal_ cancellation of a coroutine.\n * **It is not printed to console/log by default uncaught exception handler**.\n * (see [CoroutineExceptionHandler]).\n */\npublic actual typealias CancellationException = kotlin.coroutines.cancellation.CancellationException\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun CancellationException(message: String?, cause: Throwable?): CancellationException =\n    CancellationException(message, cause)\n\n/**\n * Thrown by cancellable suspending functions if the [Job] of the coroutine is cancelled or completed\n * without cause, or with a cause or exception that is not [CancellationException]\n * (see [Job.getCancellationException]).\n */\ninternal actual class JobCancellationException public actual constructor(\n    message: String,\n    cause: Throwable?,\n    internal actual val job: Job\n) : CancellationException(message, cause) {\n    override fun toString(): String = \"${super.toString()}; job=$job\"\n    override fun equals(other: Any?): Boolean =\n        other === this ||\n            other is JobCancellationException && other.message == message && other.job == job && other.cause == cause\n    override fun hashCode(): Int =\n        (message!!.hashCode() * 31 + job.hashCode()) * 31 + (cause?.hashCode() ?: 0)\n}\n\n// For use in tests\ninternal actual val RECOVER_STACK_TRACES: Boolean = false\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/MultithreadedDispatchers.kt",
        "content": "@file:OptIn(ObsoleteWorkersApi::class)\n\npackage kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.concurrent.AtomicReference\nimport kotlin.native.concurrent.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\n\npublic actual fun newFixedThreadPoolContext(nThreads: Int, name: String): CloseableCoroutineDispatcher {\n    require(nThreads >= 1) { \"Expected at least one thread, but got: $nThreads\" }\n    return MultiWorkerDispatcher(name, nThreads)\n}\n\ninternal class WorkerDispatcher(name: String) : CloseableCoroutineDispatcher(), Delay {\n    private val worker = Worker.start(name = name)\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        worker.executeAfter(0L) { block.run() }\n    }\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val handle = schedule(timeMillis, Runnable {\n            with(continuation) { resumeUndispatched(Unit) }\n        })\n        continuation.disposeOnCancellation(handle)\n    }\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle =\n        schedule(timeMillis, block)\n\n    private fun schedule(timeMillis: Long, block: Runnable): DisposableHandle {\n        // Workers don't have an API to cancel sent \"executeAfter\" block, but we are trying\n        // to control the damage and reduce reachable objects by nulling out `block`\n        // that may retain a lot of references, and leaving only an empty shell after a timely disposal\n        // This is a class and not an object with `block` in a closure because that would defeat the purpose.\n        class DisposableBlock(block: Runnable) : DisposableHandle, Function0<Unit> {\n            private val disposableHolder = AtomicReference<Runnable?>(block)\n\n            override fun invoke() {\n                disposableHolder.value?.run()\n            }\n\n            override fun dispose() {\n                disposableHolder.value = null\n            }\n\n            fun isDisposed() = disposableHolder.value == null\n        }\n\n        fun Worker.runAfterDelay(block: DisposableBlock, targetMoment: TimeMark) {\n            if (block.isDisposed()) return\n            val durationUntilTarget = -targetMoment.elapsedNow()\n            val quantum = 100.milliseconds\n            if (durationUntilTarget > quantum) {\n                executeAfter(quantum.inWholeMicroseconds) { runAfterDelay(block, targetMoment) }\n            } else {\n                executeAfter(maxOf(0, durationUntilTarget.inWholeMicroseconds), block)\n            }\n        }\n\n        val disposableBlock = DisposableBlock(block)\n        val targetMoment = TimeSource.Monotonic.markNow() + timeMillis.milliseconds\n        worker.runAfterDelay(disposableBlock, targetMoment)\n        return disposableBlock\n    }\n\n    override fun close() {\n        worker.requestTermination().result // Note: calling \"result\" blocks\n    }\n}\n\nprivate class MultiWorkerDispatcher(\n    private val name: String,\n    workersCount: Int\n) : CloseableCoroutineDispatcher() {\n    private val tasksQueue = Channel<Runnable>(Channel.UNLIMITED)\n    private val availableWorkers = Channel<CancellableContinuation<Runnable>>(Channel.UNLIMITED)\n    private val workerPool = OnDemandAllocatingPool(workersCount) {\n        Worker.start(name = \"$name-$it\").apply {\n            executeAfter { workerRunLoop() }\n        }\n    }\n\n    /**\n     * (number of tasks - number of workers) * 2 + (1 if closed)\n     */\n    private val tasksAndWorkersCounter = atomic(0L)\n\n    private inline fun Long.isClosed() = this and 1L == 1L\n    private inline fun Long.hasTasks() = this >= 2\n    private inline fun Long.hasWorkers() = this < 0\n\n    private fun workerRunLoop() = runBlocking {\n        while (true) {\n            val state = tasksAndWorkersCounter.getAndUpdate {\n                if (it.isClosed() && !it.hasTasks()) return@runBlocking\n                it - 2\n            }\n            if (state.hasTasks()) {\n                // we promised to process a task, and there are some\n                tasksQueue.receive().run()\n            } else {\n                try {\n                    suspendCancellableCoroutine {\n                        val result = availableWorkers.trySend(it)\n                        checkChannelResult(result)\n                    }.run()\n                } catch (e: CancellationException) {\n                    /** we are cancelled from [close] and thus will never get back to this branch of code,\n                    but there may still be pending work, so we can't just exit here. */\n                }\n            }\n        }\n    }\n\n    // a worker that promised to be here and should actually arrive, so we wait for it in a blocking manner.\n    private fun obtainWorker(): CancellableContinuation<Runnable> =\n        availableWorkers.tryReceive().getOrNull() ?: runBlocking { availableWorkers.receive() }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        val state = tasksAndWorkersCounter.getAndUpdate {\n            if (it.isClosed())\n                throw IllegalStateException(\"Dispatcher $name was closed, attempted to schedule: $block\")\n            it + 2\n        }\n        if (state.hasWorkers()) {\n            // there are workers that have nothing to do, let's grab one of them\n            obtainWorker().resume(block)\n        } else {\n            workerPool.allocate()\n            // no workers are available, we must queue the task\n            val result = tasksQueue.trySend(block)\n            checkChannelResult(result)\n        }\n    }\n\n    override fun close() {\n        tasksAndWorkersCounter.getAndUpdate { if (it.isClosed()) it else it or 1L }\n        val workers = workerPool.close() // no new workers will be created\n        while (true) {\n            // check if there are workers that await tasks in their personal channels, we need to wake them up\n            val state = tasksAndWorkersCounter.getAndUpdate {\n                if (it.hasWorkers()) it + 2 else it\n            }\n            if (!state.hasWorkers())\n                break\n            obtainWorker().cancel()\n        }\n        /*\n         * Here we cannot avoid waiting on `.result`, otherwise it will lead\n         * to a native memory leak, including a pthread handle.\n         */\n        val requests = workers.map { it.requestTermination() }\n        requests.map { it.result }\n    }\n\n    private fun checkChannelResult(result: ChannelResult<*>) {\n        if (!result.isSuccess)\n            throw IllegalStateException(\n                \"Internal invariants of $this were violated, please file a bug to kotlinx.coroutines\",\n                result.exceptionOrNull()\n            )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/Runnable.kt",
        "content": "package kotlinx.coroutines\n\n/**\n * A runnable task for [CoroutineDispatcher.dispatch].\n */\npublic actual interface Runnable {\n    /**\n     * @suppress\n     */\n    public actual fun run()\n}\n\n/**\n * Creates [Runnable] task instance.\n */\n@Suppress(\"FunctionName\")\npublic actual inline fun Runnable(crossinline block: () -> Unit): Runnable =\n    object : Runnable {\n        override fun run() {\n            block()\n        }\n    }\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/SchedulerTask.kt",
        "content": "package kotlinx.coroutines\n\ninternal actual abstract class SchedulerTask : Runnable\n\ninternal actual interface SchedulerTaskContext { }\n\nprivate object TaskContext: SchedulerTaskContext { }\n\ninternal actual val SchedulerTask.taskContext: SchedulerTaskContext get() = TaskContext\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun SchedulerTaskContext.afterTask() {}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/flow/internal/FlowExceptions.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\ninternal actual class AbortFlowException actual constructor(\n    actual val owner: Any\n) : CancellationException(\"Flow was aborted, no more elements needed\")\ninternal actual class ChildCancelledException : CancellationException(\"Child of the scoped flow was cancelled\")\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/flow/internal/SafeCollector.kt",
        "content": "package kotlinx.coroutines.flow.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.coroutines.*\n\ninternal actual class SafeCollector<T> actual constructor(\n    internal actual val collector: FlowCollector<T>,\n    internal actual val collectContext: CoroutineContext\n) : FlowCollector<T> {\n\n    // Note, it is non-capturing lambda, so no extra allocation during init of SafeCollector\n    internal actual val collectContextSize = collectContext.fold(0) { count, _ -> count + 1 }\n    private var lastEmissionContext: CoroutineContext? = null\n\n    actual override suspend fun emit(value: T) {\n        val currentContext = currentCoroutineContext()\n        currentContext.ensureActive()\n        if (lastEmissionContext !== currentContext) {\n            checkContext(currentContext)\n            lastEmissionContext = currentContext\n        }\n        collector.emit(value)\n    }\n\n    public actual fun releaseIntercepted() {\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/Concurrent.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.cinterop.*\nimport kotlinx.atomicfu.locks.withLock as withLock2\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\ninternal actual typealias ReentrantLock = kotlinx.atomicfu.locks.SynchronizedObject\n\ninternal actual inline fun <T> ReentrantLock.withLock(action: () -> T): T = this.withLock2(action)\n\ninternal actual fun <E> identitySet(expectedSize: Int): MutableSet<E> = HashSet()\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\") // This suppress can be removed in 2.0: KT-59355\ninternal actual typealias BenignDataRace = kotlin.concurrent.Volatile\n\ninternal actual class WorkaroundAtomicReference<T> actual constructor(value: T) {\n\n    private val nativeAtomic = kotlin.concurrent.AtomicReference<T>(value)\n\n    public actual fun get(): T = nativeAtomic.value\n\n    public actual fun set(value: T) {\n        nativeAtomic.value = value\n    }\n\n    public actual fun getAndSet(value: T): T = nativeAtomic.getAndSet(value)\n\n    public actual fun compareAndSet(expected: T, value: T): Boolean = nativeAtomic.compareAndSet(expected, value)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/CopyOnWriteList.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\n\n@Suppress(\"UNCHECKED_CAST\")\ninternal class CopyOnWriteList<E> : AbstractMutableList<E>() {\n\n    private val _array = atomic(arrayOfNulls<Any?>(0))\n    private var array: Array<Any?>\n        get() = _array.value\n        set(value) { _array.value = value }\n\n    override val size: Int\n        get() = array.size\n\n    override fun add(element: E): Boolean {\n        val n = size\n        val update = array.copyOf(n + 1)\n        update[n] = element\n        array = update\n        return true\n    }\n\n    override fun add(index: Int, element: E) {\n        rangeCheck(index)\n        val n = size\n        val update = arrayOfNulls<Any?>(n + 1)\n        array.copyInto(destination = update, endIndex = index)\n        update[index] = element\n        array.copyInto(destination = update, destinationOffset = index + 1, startIndex = index, endIndex = n + 1)\n        array = update\n    }\n\n    override fun remove(element: E): Boolean {\n        val index = array.indexOf(element as Any)\n        if (index == -1) return false\n        removeAt(index)\n        return true\n    }\n\n    override fun removeAt(index: Int): E {\n        rangeCheck(index)\n        val n = size\n        val element = array[index]\n        val update = arrayOfNulls<Any>(n - 1)\n        array.copyInto(destination = update, endIndex = index)\n        array.copyInto(destination = update, destinationOffset = index, startIndex = index + 1, endIndex = n)\n        array = update\n        return element as E\n    }\n\n    override fun iterator(): MutableIterator<E> = IteratorImpl(array as Array<E>)\n    override fun listIterator(): MutableListIterator<E> = throw UnsupportedOperationException(\"Operation is not supported\")\n    override fun listIterator(index: Int): MutableListIterator<E> = throw UnsupportedOperationException(\"Operation is not supported\")\n    override fun isEmpty(): Boolean = size == 0\n    override fun set(index: Int, element: E): E = throw UnsupportedOperationException(\"Operation is not supported\")\n    override fun get(index: Int): E = array[rangeCheck(index)] as E\n\n    private class IteratorImpl<E>(private val array: Array<E>) : MutableIterator<E> {\n        private var current = 0\n\n        override fun hasNext(): Boolean = current != array.size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return array[current++]\n        }\n\n        override fun remove() = throw UnsupportedOperationException(\"Operation is not supported\")\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        if (index < 0 || index >= size) throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/CoroutineExceptionHandlerImpl.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.native.*\n\nprivate val lock = SynchronizedObject()\n\ninternal actual val platformExceptionHandlers: Collection<CoroutineExceptionHandler>\n    get() = synchronized(lock) { platformExceptionHandlers_ }\n\nprivate val platformExceptionHandlers_ = mutableSetOf<CoroutineExceptionHandler>()\n\ninternal actual fun ensurePlatformExceptionHandlerLoaded(callback: CoroutineExceptionHandler) {\n    synchronized(lock) {\n        platformExceptionHandlers_ += callback\n    }\n}\n\n@OptIn(ExperimentalStdlibApi::class)\ninternal actual fun propagateExceptionFinalResort(exception: Throwable) {\n    // log exception\n    processUnhandledException(exception)\n}\n\ninternal actual class DiagnosticCoroutineContextException actual constructor(context: CoroutineContext) :\n    RuntimeException(context.toString())\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/LocalAtomics.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.atomicfu.*\n\ninternal actual class LocalAtomicInt actual constructor(value: Int) {\n\n    private val iRef = atomic(value)\n\n    actual fun set(value: Int) {\n        iRef.value = value\n    }\n\n    actual fun get(): Int = iRef.value\n\n    actual fun decrementAndGet(): Int = iRef.decrementAndGet()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/ProbesSupport.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> probeCoroutineCreated(completion: Continuation<T>): Continuation<T> = completion\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/StackTraceRecovery.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\n\ninternal actual fun <E: Throwable> recoverStackTrace(exception: E, continuation: Continuation<*>): E = exception\ninternal actual fun <E: Throwable> recoverStackTrace(exception: E): E = exception\n\n@PublishedApi\ninternal actual fun <E : Throwable> unwrap(exception: E): E = exception\ninternal actual suspend inline fun recoverAndThrow(exception: Throwable): Nothing = throw exception\n\n@Suppress(\"UNUSED\")\ninternal actual interface CoroutineStackFrame {\n    public actual val callerFrame: CoroutineStackFrame?\n    public actual fun getStackTraceElement(): StackTraceElement?\n}\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\ninternal actual typealias StackTraceElement = Any\n\ninternal actual fun Throwable.initCause(cause: Throwable) {\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/Synchronized.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.cinterop.*\nimport kotlinx.coroutines.*\nimport kotlinx.atomicfu.locks.withLock as withLock2\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic actual typealias SynchronizedObject = kotlinx.atomicfu.locks.SynchronizedObject\n\n/**\n * @suppress **This an internal API and should not be used from general code.**\n */\n@InternalCoroutinesApi\npublic actual inline fun <T> synchronizedImpl(lock: SynchronizedObject, block: () -> T): T = lock.withLock2(block)\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/SystemProps.kt",
        "content": "package kotlinx.coroutines.internal\n\ninternal actual fun systemProp(propertyName: String): String? = null\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/ThreadContext.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.coroutines.*\n\ninternal actual fun threadContextElements(context: CoroutineContext): Any = 0\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/src/internal/ThreadLocal.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlin.native.concurrent.ThreadLocal\n\ninternal actual class CommonThreadLocal<T>(private val name: Symbol) {\n    @Suppress(\"UNCHECKED_CAST\")\n    actual fun get(): T = Storage[name] as T\n    actual fun set(value: T) { Storage[name] = value }\n}\n\ninternal actual fun <T> commonThreadLocal(name: Symbol): CommonThreadLocal<T> = CommonThreadLocal(name)\n\n@ThreadLocal\nprivate object Storage: MutableMap<Symbol, Any?> by mutableMapOf()\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/test/ConcurrentTestUtilities.kt",
        "content": "package kotlinx.coroutines.exceptions\n\nimport platform.posix.*\nimport kotlin.native.concurrent.*\n\nactual inline fun yieldThread() { sched_yield() }\n\nactual fun currentThreadName(): String = Worker.current.name\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/test/DelayExceptionTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass DelayExceptionTest : TestBase() {\n\n    @Test\n    fun testMaxDelay() = runBlocking {\n        expect(1)\n        val job = launch {\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n        yield()\n        job.cancel()\n        finish(3)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/test/MultithreadedDispatchersTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.native.concurrent.*\nimport kotlin.test.*\nimport kotlin.time.Duration.Companion.seconds\n\nprivate class BlockingBarrier(val n: Int) {\n    val counter = atomic(0)\n    val wakeUp = Channel<Unit>(n - 1)\n    fun await() {\n        val count = counter.addAndGet(1)\n        if (count == n) {\n            repeat(n - 1) {\n                runBlocking {\n                    wakeUp.send(Unit)\n                }\n            }\n        } else if (count < n) {\n            runBlocking {\n                wakeUp.receive()\n            }\n        }\n    }\n}\n\nclass MultithreadedDispatchersTest {\n    /**\n     * Test that [newFixedThreadPoolContext] does not allocate more dispatchers than it needs to.\n     * Incidentally also tests that it will allocate enough workers for its needs. Otherwise, the test will hang.\n     */\n    @Test\n    fun testNotAllocatingExtraDispatchers() {\n        val barrier = BlockingBarrier(2)\n        val lock = SynchronizedObject()\n        suspend fun spin(set: MutableSet<Worker>) {\n            repeat(100) {\n                synchronized(lock) { set.add(Worker.current) }\n                delay(1)\n            }\n        }\n        val dispatcher = newFixedThreadPoolContext(64, \"test\")\n        try {\n            runBlocking {\n                val encounteredWorkers = mutableSetOf<Worker>()\n                val coroutine1 = launch(dispatcher) {\n                    barrier.await()\n                    spin(encounteredWorkers)\n                }\n                val coroutine2 = launch(dispatcher) {\n                    barrier.await()\n                    spin(encounteredWorkers)\n                }\n                listOf(coroutine1, coroutine2).joinAll()\n                assertEquals(2, encounteredWorkers.size)\n            }\n        } finally {\n            dispatcher.close()\n        }\n    }\n\n    /**\n     * Test that [newSingleThreadContext] will not wait for the cancelled scheduled coroutines before closing.\n     */\n    @Test\n    fun timeoutsNotPreventingClosing(): Unit = runBlocking {\n        val dispatcher = WorkerDispatcher(\"test\")\n        withContext(dispatcher) {\n            withTimeout(5.seconds) {\n            }\n        }\n        withTimeout(1.seconds) {\n            dispatcher.close() // should not wait for the timeout\n            yield()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/native/test/WorkerTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.channels.*\nimport kotlin.coroutines.*\nimport kotlin.native.concurrent.*\nimport kotlin.test.*\n\nclass WorkerTest : TestBase() {\n\n    @Test\n    fun testLaunchInWorker() {\n        val worker = Worker.start()\n        worker.execute(TransferMode.SAFE, { }) {\n            runBlocking {\n                launch { }.join()\n                delay(1)\n            }\n        }.result\n        worker.requestTermination()\n    }\n\n    @Test\n    fun testLaunchInWorkerThroughGlobalScope() {\n        val worker = Worker.start()\n        worker.execute(TransferMode.SAFE, { }) {\n            runBlocking {\n                CoroutineScope(EmptyCoroutineContext).launch {\n                    delay(10)\n                }.join()\n            }\n        }.result\n        worker.requestTermination()\n    }\n\n    /**\n     * Test that [runBlocking] does not crash after [Worker.requestTermination] is called on the worker that runs it.\n     */\n    @Test\n    fun testRunBlockingInTerminatedWorker() {\n        val workerInRunBlocking = Channel<Unit>()\n        val workerTerminated = Channel<Unit>()\n        val checkResumption = Channel<Unit>()\n        val finished = Channel<Unit>()\n        val worker = Worker.start()\n        worker.executeAfter(0) {\n            runBlocking {\n                workerInRunBlocking.send(Unit)\n                workerTerminated.receive()\n                checkResumption.receive()\n                finished.send(Unit)\n            }\n        }\n        runBlocking {\n            workerInRunBlocking.receive()\n            worker.requestTermination()\n            workerTerminated.send(Unit)\n            checkResumption.send(Unit)\n            finished.receive()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/nativeDarwin/src/Dispatchers.kt",
        "content": "@file:OptIn(BetaInteropApi::class)\n\npackage kotlinx.coroutines\n\nimport kotlinx.cinterop.*\nimport platform.CoreFoundation.*\nimport platform.darwin.*\nimport kotlin.coroutines.*\nimport kotlin.concurrent.*\nimport kotlin.native.internal.NativePtr\n\ninternal fun isMainThread(): Boolean = CFRunLoopGetCurrent() == CFRunLoopGetMain()\n\ninternal actual fun createMainDispatcher(default: CoroutineDispatcher): MainCoroutineDispatcher = DarwinMainDispatcher(false)\n\ninternal actual fun createDefaultDispatcher(): CoroutineDispatcher = DarwinGlobalQueueDispatcher\n\nprivate object DarwinGlobalQueueDispatcher : CoroutineDispatcher() {\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        autoreleasepool {\n            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT.convert(), 0u)) {\n                block.run()\n            }\n        }\n    }\n}\n\nprivate class DarwinMainDispatcher(\n    private val invokeImmediately: Boolean\n) : MainCoroutineDispatcher(), Delay {\n    \n    override val immediate: MainCoroutineDispatcher =\n        if (invokeImmediately) this else DarwinMainDispatcher(true)\n\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = !(invokeImmediately && isMainThread())\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        autoreleasepool {\n            dispatch_async(dispatch_get_main_queue()) {\n                block.run()\n            }\n        }\n    }\n    \n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val timer = Timer()\n        val timerBlock: TimerBlock = {\n            timer.dispose()\n            continuation.resume(Unit)\n        }\n        timer.start(timeMillis, timerBlock)\n        continuation.disposeOnCancellation(timer)\n    }\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        val timer = Timer()\n        val timerBlock: TimerBlock = {\n            timer.dispose()\n            block.run()\n        }\n        timer.start(timeMillis, timerBlock)\n        return timer\n    }\n\n    override fun toString(): String =\n        if (invokeImmediately) \"Dispatchers.Main.immediate\" else \"Dispatchers.Main\"\n}\n\nprivate typealias TimerBlock = (CFRunLoopTimerRef?) -> Unit\n\nprivate val TIMER_NEW = NativePtr.NULL\nprivate val TIMER_DISPOSED = NativePtr.NULL.plus(1)\n\nprivate class Timer : DisposableHandle {\n    private val ref = AtomicNativePtr(TIMER_NEW)\n\n    fun start(timeMillis: Long, timerBlock: TimerBlock) {\n        val fireDate = CFAbsoluteTimeGetCurrent() + timeMillis / 1000.0\n        val timer = CFRunLoopTimerCreateWithHandler(null, fireDate, 0.0, 0u, 0, timerBlock)\n        CFRunLoopAddTimer(CFRunLoopGetMain(), timer, kCFRunLoopCommonModes)\n        if (!ref.compareAndSet(TIMER_NEW, timer.rawValue)) {\n            // dispose was already called concurrently\n            release(timer)\n        }\n    }\n\n    override fun dispose() {\n        while (true) {\n            val ptr = ref.value\n            if (ptr == TIMER_DISPOSED) return\n            if (ref.compareAndSet(ptr, TIMER_DISPOSED)) {\n                if (ptr != TIMER_NEW) release(interpretCPointer(ptr))\n                return\n            }\n        }\n    }\n\n    private fun release(timer: CFRunLoopTimerRef?) {\n        CFRunLoopRemoveTimer(CFRunLoopGetMain(), timer, kCFRunLoopCommonModes)\n        CFRelease(timer)\n    }\n}\n\ninternal actual inline fun platformAutoreleasePool(crossinline block: () -> Unit): Unit = autoreleasepool { block() }\n"
    },
    {
        "path": "kotlinx-coroutines-core/nativeDarwin/test/Launcher.kt",
        "content": "package kotlinx.coroutines\n\nimport platform.CoreFoundation.*\nimport kotlin.native.concurrent.*\nimport kotlin.native.internal.test.*\nimport kotlin.system.*\n\n// This is a separate entry point for tests in background\nfun mainBackground(args: Array<String>) {\n    val worker = Worker.start(name = \"main-background\")\n    worker.execute(TransferMode.SAFE, { args }) {\n        val result = testLauncherEntryPoint(it)\n        exitProcess(result)\n    }\n    CFRunLoopRun()\n    error(\"CFRunLoopRun should never return\")\n}\n\n"
    },
    {
        "path": "kotlinx-coroutines-core/nativeDarwin/test/MainDispatcherTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.cinterop.*\nimport kotlinx.coroutines.testing.*\nimport platform.CoreFoundation.*\nimport platform.darwin.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass MainDispatcherTest : MainDispatcherTestBase.WithRealTimeDelay() {\n\n    override fun isMainThread(): Boolean = CFRunLoopGetCurrent() == CFRunLoopGetMain()\n\n    // skip if already on the main thread, run blocking doesn't really work well with that\n    override fun shouldSkipTesting(): Boolean = isMainThread()\n\n    override fun scheduleOnMainQueue(block: () -> Unit) {\n        autoreleasepool {\n            dispatch_async(dispatch_get_main_queue()) {\n                block()\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/nativeOther/src/Dispatchers.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\nimport kotlin.native.*\n\ninternal actual fun createMainDispatcher(default: CoroutineDispatcher): MainCoroutineDispatcher =\n    MissingMainDispatcher\n\ninternal actual fun createDefaultDispatcher(): CoroutineDispatcher = DefaultDispatcher\n\nprivate object DefaultDispatcher : CoroutineDispatcher() {\n    // Be consistent with JVM -- at least 2 threads to provide some liveness guarantees in case of improper uses\n    @OptIn(ExperimentalStdlibApi::class)\n    private val ctx = newFixedThreadPoolContext(Platform.getAvailableProcessors().coerceAtLeast(2), \"Dispatchers.Default\")\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        ctx.dispatch(context, block)\n    }\n}\n\nprivate object MissingMainDispatcher : MainCoroutineDispatcher() {\n    override val immediate: MainCoroutineDispatcher\n        get() = notImplemented()\n    override fun dispatch(context: CoroutineContext, block: Runnable) = notImplemented()\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = notImplemented()\n    override fun dispatchYield(context: CoroutineContext, block: Runnable) = notImplemented()\n\n    private fun notImplemented(): Nothing = TODO(\"Dispatchers.Main is missing on the current platform\")\n}\n\ninternal actual inline fun platformAutoreleasePool(crossinline block: () -> Unit) = block()\n"
    },
    {
        "path": "kotlinx-coroutines-core/nativeOther/test/Launcher.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.native.concurrent.*\nimport kotlin.native.internal.test.*\nimport kotlin.system.*\n\n// This is a separate entry point for tests in background\nfun mainBackground(args: Array<String>) {\n    val worker = Worker.start(name = \"main-background\")\n    worker.execute(TransferMode.SAFE, { args }) {\n        val result = testLauncherEntryPoint(it)\n        exitProcess(result)\n    }.result // block main thread\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/wasmJs/src/CoroutineContext.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.internal.*\nimport org.w3c.dom.*\nimport kotlin.coroutines.*\n\ninternal external interface JsProcess : JsAny {\n    fun nextTick(handler: () -> Unit)\n}\n\ninternal fun tryGetProcess(): JsProcess? =\n    js(\"(typeof(process) !== 'undefined' && typeof(process.nextTick) === 'function') ? process : null\")\n\ninternal fun tryGetWindow(): Window? =\n    js(\"(typeof(window) !== 'undefined' && window != null && typeof(window.addEventListener) === 'function') ? window : null\")\n\ninternal actual fun createDefaultDispatcher(): CoroutineDispatcher =\n    tryGetProcess()?.let(::NodeDispatcher)\n        ?: tryGetWindow()?.let(::WindowDispatcher)\n        ?: SetTimeoutDispatcher\n\n@PublishedApi // Used from kotlinx-coroutines-test via suppress, not part of ABI\ninternal actual val DefaultDelay: Delay\n    get() = Dispatchers.Default as Delay\n\npublic actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {\n    val combined = coroutineContext + context\n    return if (combined !== Dispatchers.Default && combined[ContinuationInterceptor] == null)\n        combined + Dispatchers.Default else combined\n}\n\npublic actual fun CoroutineContext.newCoroutineContext(addedContext: CoroutineContext): CoroutineContext {\n    return this + addedContext\n}\n\n// No debugging facilities on Wasm\ninternal actual inline fun <T> withCoroutineContext(context: CoroutineContext, countOrElement: Any?, block: () -> T): T = block()\ninternal actual inline fun <T> withContinuationContext(continuation: Continuation<*>, countOrElement: Any?, block: () -> T): T = block()\ninternal actual fun Continuation<*>.toDebugString(): String = toString()\ninternal actual val CoroutineContext.coroutineName: String? get() = null // not supported on Wasm\n\ninternal actual class UndispatchedCoroutine<in T> actual constructor(\n    context: CoroutineContext,\n    uCont: Continuation<T>\n) : ScopeCoroutine<T>(context, uCont) {\n    override fun afterResume(state: Any?) = uCont.resumeWith(recoverResult(state, uCont))\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/wasmJs/src/Debug.kt",
        "content": "package kotlinx.coroutines\n\ninternal actual val DEBUG: Boolean = false\n\ninternal actual val Any.hexAddress: String\n    get() = this.hashCode().toString()\n\ninternal actual val Any.classSimpleName: String get() = this::class.simpleName ?: \"Unknown\"\n\ninternal actual inline fun assert(value: () -> Boolean) {}\n\ninternal external interface Console {\n    fun error(s: String)\n}\n\ninternal external val console: Console"
    },
    {
        "path": "kotlinx-coroutines-core/wasmJs/src/JSDispatcher.kt",
        "content": "package kotlinx.coroutines\n\nimport org.w3c.dom.Window\nimport kotlin.js.*\n\npublic actual typealias W3CWindow = Window\n\ninternal actual fun w3cSetTimeout(window: W3CWindow, handler: () -> Unit, timeout: Int): Int =\n    setTimeout(window, handler, timeout)\n\ninternal actual fun w3cSetTimeout(handler: () -> Unit, timeout: Int): Int =\n    setTimeout(handler, timeout)\n\ninternal actual fun w3cClearTimeout(window: W3CWindow, handle: Int) =\n    window.clearTimeout(handle)\n\ninternal actual fun w3cClearTimeout(handle: Int) =\n    clearTimeout(handle)\n\ninternal actual class ScheduledMessageQueue actual constructor(private val dispatcher: SetTimeoutBasedDispatcher) : MessageQueue() {\n    internal val processQueue: () -> Unit = ::process\n\n    actual override fun schedule() {\n        dispatcher.scheduleQueueProcessing()\n    }\n\n    actual override fun reschedule() {\n        setTimeout(processQueue, 0)\n    }\n\n    internal actual fun setTimeout(timeout: Int) {\n        setTimeout(processQueue, timeout)\n    }\n}\n\ninternal class NodeDispatcher(private val process: JsProcess) : SetTimeoutBasedDispatcher() {\n    override fun scheduleQueueProcessing() {\n        process.nextTick(messageQueue.processQueue)\n    }\n}\n\n@Suppress(\"UNUSED_PARAMETER\")\nprivate fun subscribeToWindowMessages(window: Window, process: () -> Unit): Unit = js(\"\"\"{\n    const handler = (event) => {\n        if (event.source == window && event.data == 'dispatchCoroutine') {\n            event.stopPropagation();\n            process();\n        }\n    }\n    window.addEventListener('message', handler, true);\n}\"\"\")\n\n@Suppress(\"UNUSED_PARAMETER\")\nprivate fun createRescheduleMessagePoster(window: Window): () -> Unit =\n    js(\"() => window.postMessage('dispatchCoroutine', '*')\")\n\n@Suppress(\"UNUSED_PARAMETER\")\nprivate fun createScheduleMessagePoster(process: () -> Unit): () -> Unit =\n    js(\"() => Promise.resolve(0).then(process)\")\n\ninternal actual class WindowMessageQueue actual constructor(window: W3CWindow) : MessageQueue() {\n    private val scheduleMessagePoster = createScheduleMessagePoster(::process)\n    private val rescheduleMessagePoster = createRescheduleMessagePoster(window)\n    init {\n        subscribeToWindowMessages(window, ::process)\n    }\n\n    actual override fun schedule() {\n        scheduleMessagePoster()\n    }\n\n    actual override fun reschedule() {\n        rescheduleMessagePoster()\n    }\n}\n\n// We need to reference global setTimeout and clearTimeout so that it works on Node.JS as opposed to\n// using them via \"window\" (which only works in browser)\nprivate external fun setTimeout(handler: () -> Unit, timeout: Int): Int\n\n// d8 doesn't have clearTimeout\n@Suppress(\"UNUSED_PARAMETER\")\nprivate fun clearTimeout(handle: Int): Unit =\n    js(\"{ if (typeof clearTimeout !== 'undefined') clearTimeout(handle); }\")\n\n@Suppress(\"UNUSED_PARAMETER\")\nprivate fun setTimeout(window: Window, handler: () -> Unit, timeout: Int): Int =\n    js(\"window.setTimeout(handler, timeout)\")\n"
    },
    {
        "path": "kotlinx-coroutines-core/wasmJs/src/Promise.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlin.coroutines.*\nimport kotlin.js.*\n\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun promiseSetDeferred(promise: Promise<JsAny?>, deferred: JsAny): Unit =\n    js(\"promise.deferred = deferred\")\n\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun promiseGetDeferred(promise: Promise<JsAny?>): JsAny? = js(\"\"\"{\n    console.assert(promise instanceof Promise, \"promiseGetDeferred must receive a promise, but got \", promise);\n    return promise.deferred == null ? null : promise.deferred; \n}\"\"\")\n\n\n/**\n * Starts new coroutine and returns its result as an implementation of [Promise].\n *\n * Coroutine context is inherited from a [CoroutineScope], additional context elements can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * The parent job is inherited from a [CoroutineScope] as well, but it can also be overridden\n * with corresponding [context] element.\n *\n * By default, the coroutine is immediately scheduled for execution.\n * Other options can be specified via `start` parameter. See [CoroutineStart] for details.\n *\n * @param context additional to [CoroutineScope.coroutineContext] context of the coroutine.\n * @param start coroutine start option. The default value is [CoroutineStart.DEFAULT].\n * @param block the coroutine code.\n */\npublic fun <T> CoroutineScope.promise(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -> T\n): Promise<JsAny?> =\n    async(context, start, block).asPromise()\n\n/**\n * Converts this deferred value to the instance of [Promise<JsAny?>].\n */\npublic fun <T> Deferred<T>.asPromise(): Promise<JsAny?> {\n    val promise = Promise<JsAny?> { resolve, reject ->\n        invokeOnCompletion {\n            val e = getCompletionExceptionOrNull()\n            if (e != null) {\n                reject(e.toJsReference())\n            } else {\n                resolve(getCompleted()?.toJsReference())\n            }\n        }\n    }\n    promiseSetDeferred(promise, this.toJsReference())\n    return promise\n}\n\n/**\n * Converts this promise value to the instance of [Deferred].\n */\n@Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\", \"UNCHECKED_CAST\")\npublic fun <T> Promise<JsAny?>.asDeferred(): Deferred<T> {\n    val deferred = promiseGetDeferred(this) as? JsReference<Deferred<T>>\n    return deferred?.get() ?: GlobalScope.async(start = CoroutineStart.UNDISPATCHED) { await() }\n}\n\n/**\n * Awaits for completion of the promise without blocking.\n *\n * This suspending function is cancellable: if the [Job] of the current coroutine is cancelled while this\n * suspending function is waiting on the promise, this function immediately resumes with [CancellationException].\n * There is a **prompt cancellation guarantee**: even if this function is ready to return the result, but was cancelled\n * while suspended, [CancellationException] will be thrown. See [suspendCancellableCoroutine] for low-level details.\n */\n@Suppress(\"UNCHECKED_CAST\")\npublic suspend fun <T> Promise<JsAny?>.await(): T = suspendCancellableCoroutine { cont: CancellableContinuation<T> ->\n    this@await.then(\n        onFulfilled = { cont.resume(it as T); null },\n        onRejected = { cont.resumeWithException(it.toThrowableOrNull() ?: error(\"Unexpected non-Kotlin exception $it\")); null }\n    )\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/wasmJs/src/internal/CopyOnWriteList.kt",
        "content": "package kotlinx.coroutines.internal\n\n@Suppress(\"UNCHECKED_CAST\")\ninternal class CopyOnWriteList<E> : AbstractMutableList<E>() {\n    private var array: Array<Any?> = arrayOfNulls<Any?>(0)\n\n    override val size: Int\n        get() = array.size\n\n    override fun add(element: E): Boolean {\n        val n = size\n        val update = array.copyOf(n + 1)\n        update[n] = element\n        array = update\n        return true\n    }\n\n    override fun add(index: Int, element: E) {\n        rangeCheck(index)\n        val n = size\n        val update = arrayOfNulls<Any?>(n + 1)\n        array.copyInto(destination = update, endIndex = index)\n        update[index] = element\n        array.copyInto(destination = update, destinationOffset = index + 1, startIndex = index, endIndex = n + 1)\n        array = update\n    }\n\n    override fun remove(element: E): Boolean {\n        val index = array.indexOf(element as Any)\n        if (index == -1) return false\n        removeAt(index)\n        return true\n    }\n\n    override fun removeAt(index: Int): E {\n        rangeCheck(index)\n        val n = size\n        val element = array[index]\n        val update = arrayOfNulls<Any>(n - 1)\n        array.copyInto(destination = update, endIndex = index)\n        array.copyInto(destination = update, destinationOffset = index, startIndex = index + 1, endIndex = n)\n        array = update\n        return element as E\n    }\n\n    override fun iterator(): MutableIterator<E> = IteratorImpl(array as Array<E>)\n    override fun listIterator(): MutableListIterator<E> = throw UnsupportedOperationException(\"Operation is not supported\")\n    override fun listIterator(index: Int): MutableListIterator<E> = throw UnsupportedOperationException(\"Operation is not supported\")\n    override fun isEmpty(): Boolean = size == 0\n    override fun set(index: Int, element: E): E = throw UnsupportedOperationException(\"Operation is not supported\")\n    override fun get(index: Int): E = array[rangeCheck(index)] as E\n\n    private class IteratorImpl<E>(private val array: Array<E>) : MutableIterator<E> {\n        private var current = 0\n\n        override fun hasNext(): Boolean = current != array.size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return array[current++]\n        }\n\n        override fun remove() = throw UnsupportedOperationException(\"Operation is not supported\")\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        if (index < 0 || index >= size) throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-core/wasmJs/src/internal/CoroutineExceptionHandlerImpl.kt",
        "content": "package kotlinx.coroutines.internal\n\nimport kotlinx.coroutines.*\n\ninternal actual fun propagateExceptionFinalResort(exception: Throwable) {\n    // log exception\n    console.error(exception.toString())\n}"
    },
    {
        "path": "kotlinx-coroutines-core/wasmJs/test/PromiseTest.kt",
        "content": "package kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlin.js.*\nimport kotlin.test.*\n\nclass PromiseTest : TestBase() {\n    @Test\n    fun testPromiseResolvedAsDeferred() = GlobalScope.promise {\n        val promise = Promise<JsReference<String>> { resolve, _ ->\n            resolve(\"OK\".toJsReference())\n        }\n        val deferred = promise.asDeferred<JsReference<String>>()\n        assertEquals(\"OK\", deferred.await().get())\n    }\n\n    @Test\n    fun testPromiseRejectedAsDeferred() = GlobalScope.promise {\n        lateinit var promiseReject: (JsAny) -> Unit\n        val promise = Promise<JsAny?> { _, reject ->\n            promiseReject = reject\n        }\n        val deferred = promise.asDeferred<JsReference<String>>()\n        // reject after converting to deferred to avoid \"Unhandled promise rejection\" warnings\n        promiseReject(TestException(\"Rejected\").toJsReference())\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: Throwable) {\n            assertIs<TestException>(e)\n            assertEquals(\"Rejected\", e.message)\n        }\n    }\n\n    @Test\n    fun testCompletedDeferredAsPromise() = GlobalScope.promise {\n        val deferred = async(start = CoroutineStart.UNDISPATCHED) {\n            // completed right away\n            \"OK\"\n        }\n        val promise = deferred.asPromise()\n        assertEquals(\"OK\", promise.await())\n    }\n\n    @Test\n    fun testWaitForDeferredAsPromise() = GlobalScope.promise {\n        val deferred = async {\n            // will complete later\n            \"OK\"\n        }\n        val promise = deferred.asPromise()\n        assertEquals(\"OK\", promise.await()) // await yields main thread to deferred coroutine\n    }\n\n    @Test\n    fun testCancellableAwaitPromise() = GlobalScope.promise {\n        lateinit var r: (JsAny) -> Unit\n        val toAwait = Promise<JsAny?> { resolve, _ -> r = resolve }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            toAwait.await() // suspends\n        }\n        job.cancel() // cancel the job\n        r(\"fail\".toJsString()) // too late, the waiting job was already cancelled\n    }\n\n    @Test\n    fun testAsPromiseAsDeferred() = GlobalScope.promise {\n        val deferred = async { \"OK\" }\n        val promise = deferred.asPromise()\n        val d2 = promise.asDeferred<String>()\n        assertSame(d2, deferred)\n        assertEquals(\"OK\", d2.await())\n    }\n\n    @Test\n    fun testLeverageTestResult(): TestResult {\n        // Cannot use expect(..) here\n        var seq = 0\n        val result = runTest {\n            ++seq\n        }\n        return result.then {\n            if (seq != 1) error(\"Unexpected result: $seq\")\n            null\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/build.gradle.kts",
        "content": "import com.github.jengelman.gradle.plugins.shadow.tasks.*\nimport java.net.*\nimport java.nio.file.*\n\nplugins {\n    id(\"com.github.johnrengelman.shadow\")\n    id(\"org.jetbrains.kotlinx.kover\") // apply plugin to use autocomplete for Kover DSL\n}\n\nconfigurations {\n    val shadowDeps by creating\n    compileOnly.configure {\n        extendsFrom(shadowDeps)\n    }\n    runtimeOnly.configure {\n        extendsFrom(shadowDeps)\n    }\n}\n\nval junit_version by properties\nval junit5_version by properties\nval byte_buddy_version by properties\nval blockhound_version by properties\nval jna_version by properties\n\ndependencies {\n    compileOnly(\"junit:junit:$junit_version\")\n    compileOnly(\"org.junit.jupiter:junit-jupiter-api:$junit5_version\")\n    testImplementation(\"org.junit.jupiter:junit-jupiter-engine:$junit5_version\")\n    testImplementation(\"org.junit.platform:junit-platform-testkit:1.7.0\")\n    add(\"shadowDeps\", \"net.bytebuddy:byte-buddy:$byte_buddy_version\")\n    add(\"shadowDeps\", \"net.bytebuddy:byte-buddy-agent:$byte_buddy_version\")\n    compileOnly(\"io.projectreactor.tools:blockhound:$blockhound_version\")\n    testImplementation(\"io.projectreactor.tools:blockhound:$blockhound_version\")\n    testImplementation(\"com.google.code.gson:gson:2.8.6\")\n    api(\"net.java.dev.jna:jna:$jna_version\")\n    api(\"net.java.dev.jna:jna-platform:$jna_version\")\n}\n\njava {\n    /* This is needed to be able to run JUnit5 tests. Otherwise, Gradle complains that it can't find the\n    JVM1.6-compatible version of the `junit-jupiter-api` artifact. */\n    disableAutoTargetJvm()\n}\n\n// This is required for BlockHound tests to work, see https://github.com/Kotlin/kotlinx.coroutines/issues/3701\ntasks.withType<Test>().configureEach {\n    if (JavaVersion.toVersion(jdkToolchainVersion).isCompatibleWith(JavaVersion.VERSION_13)) {\n        jvmArgs(\"-XX:+AllowRedefinitionToAddDeleteMethods\")\n    }\n}\n\nval jar by tasks.existing(Jar::class) {\n    enabled = false\n}\n\nval shadowJar by tasks.existing(ShadowJar::class) {\n    // Shadow only byte buddy, do not package kotlin stdlib\n    configurations = listOf(project.configurations[\"shadowDeps\"])\n    relocate(\"net.bytebuddy\", \"kotlinx.coroutines.repackaged.net.bytebuddy\")\n    /* These classifiers are both set to `null` to trick Gradle into thinking that this jar file is both the\n    artifact from the `jar` task and the one from `shadowJar`. Without this, Gradle complains that the artifact\n    from the `jar` task is not present when the compilaton finishes, even if the file with this name exists. */\n    archiveClassifier.convention(null as String?)\n    archiveClassifier = null\n    archiveBaseName = jar.flatMap { it.archiveBaseName }\n    archiveVersion = jar.flatMap { it.archiveVersion }\n    manifest {\n        attributes(\n            mapOf(\n                \"Premain-Class\" to \"kotlinx.coroutines.debug.AgentPremain\",\n                \"Can-Redefine-Classes\" to \"true\",\n                \"Multi-Release\" to \"true\"\n            )\n        )\n    }\n    // add module-info.class to the META-INF/versions/9/ directory.\n    dependsOn(tasks.compileModuleInfoJava)\n    doLast {\n        // We can't do that directly with the shadowJar task because it doesn't support replacing existing files.\n        val zipPath = this@existing.outputs.files.singleFile.toPath()\n        val zipUri = URI.create(\"jar:${zipPath.toUri()}\")\n        val moduleInfoFilePath = tasks.compileModuleInfoJava.get().outputs.files.asFileTree.matching {\n            include(\"module-info.class\")\n        }.singleFile.toPath()\n        FileSystems.newFileSystem(zipUri, emptyMap<String, String>()).use { fs ->\n            val moduleInfoFile = fs.getPath(\"META-INF/versions/9/module-info.class\")\n            Files.copy(moduleInfoFilePath, moduleInfoFile, StandardCopyOption.REPLACE_EXISTING)\n        }\n    }\n}\n\nconfigurations {\n    // shadowJar is already part of the `shadowRuntimeElements` and `shadowApiElements`, but the other subprojects\n    // that depend on `kotlinx-coroutines-debug` look at `runtimeElements` and `apiElements`.\n    artifacts {\n        add(\"apiElements\", shadowJar)\n        add(\"runtimeElements\", shadowJar)\n    }\n}\n\nkover {\n    reports {\n        filters {\n            excludes {\n                // Never used, safety mechanism\n                classes(\"kotlinx.coroutines.debug.internal.NoOpProbesKt\")\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/CoroutineInfo.kt",
        "content": "@file:Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\", \"UNUSED\")\npackage kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.jvm.internal.*\n\n/**\n * Class describing coroutine info such as its context, state and stacktrace.\n */\n@ExperimentalCoroutinesApi\npublic class CoroutineInfo internal constructor(delegate: DebugCoroutineInfo) {\n    /**\n     * [Coroutine context][coroutineContext] of the coroutine\n     */\n    public val context: CoroutineContext = delegate.context\n\n    /**\n     * Last observed state of the coroutine\n     */\n    public val state: State = State.valueOf(delegate.state)\n\n    private val creationStackBottom: CoroutineStackFrame? = delegate.creationStackBottom\n\n    /**\n     * [Job] associated with a current coroutine or null.\n     * May be later used in [DebugProbes.printJob].\n     */\n    public val job: Job? get() = context[Job]\n\n    /**\n     * Creation stacktrace of the coroutine.\n     * Can be empty if [DebugProbes.enableCreationStackTraces] is not set.\n     */\n    public val creationStackTrace: List<StackTraceElement> get() = creationStackTrace()\n\n    private val lastObservedFrame: CoroutineStackFrame? = delegate.lastObservedFrame\n\n    /**\n     * Last observed stacktrace of the coroutine captured on its suspension or resumption point.\n     * It means that for [running][State.RUNNING] coroutines resulting stacktrace is inaccurate and\n     * reflects stacktrace of the resumption point, not the actual current stacktrace.\n     */\n    public fun lastObservedStackTrace(): List<StackTraceElement> {\n        var frame: CoroutineStackFrame? = lastObservedFrame ?: return emptyList()\n        val result = ArrayList<StackTraceElement>()\n        while (frame != null) {\n            frame.getStackTraceElement()?.let { result.add(it) }\n            frame = frame.callerFrame\n        }\n        return result\n    }\n\n    private fun creationStackTrace(): List<StackTraceElement> {\n        val bottom = creationStackBottom ?: return emptyList()\n        // Skip \"Coroutine creation stacktrace\" frame\n        return sequence<StackTraceElement> { yieldFrames(bottom.callerFrame) }.toList()\n    }\n\n    private tailrec suspend fun SequenceScope<StackTraceElement>.yieldFrames(frame: CoroutineStackFrame?) {\n        if (frame == null) return\n        frame.getStackTraceElement()?.let { yield(it) }\n        val caller = frame.callerFrame\n        if (caller != null) {\n            yieldFrames(caller)\n        }\n    }\n\n    override fun toString(): String = \"CoroutineInfo(state=$state,context=$context)\"\n}\n\n/**\n * Current state of the coroutine.\n */\npublic enum class State {\n    /**\n     * Created, but not yet started.\n     */\n    CREATED,\n    /**\n     * Started and running.\n     */\n    RUNNING,\n    /**\n     * Suspended.\n     */\n    SUSPENDED\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/CoroutinesBlockHoundIntegration.kt",
        "content": "@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n\npackage kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.scheduling.*\nimport reactor.blockhound.*\nimport reactor.blockhound.integration.*\n\n/**\n * @suppress\n */\npublic class CoroutinesBlockHoundIntegration : BlockHoundIntegration {\n\n    override fun applyTo(builder: BlockHound.Builder): Unit = with(builder) {\n        allowBlockingCallsInPrimitiveImplementations()\n        allowBlockingWhenEnqueuingTasks()\n        allowServiceLoaderInvocationsOnInit()\n        allowBlockingCallsInReflectionImpl()\n        allowBlockingCallsInDebugProbes()\n        allowBlockingCallsInWorkQueue()\n        // Stacktrace recovery cache is guarded by lock\n        allowBlockingCallsInside(\"kotlinx.coroutines.internal.ExceptionsConstructorKt\", \"tryCopyException\")\n        /* The predicates that define that BlockHound should only report blocking calls from threads that are part of\n        the coroutine thread pool and currently execute a CPU-bound coroutine computation. */\n        addDynamicThreadPredicate { isSchedulerWorker(it) }\n        nonBlockingThreadPredicate { p -> p.or { mayNotBlock(it) } }\n    }\n\n    /**\n     * Allows blocking calls in various coroutine structures, such as flows and channels.\n     *\n     * They use locks in implementations, though only for protecting short pieces of fast and well-understood code, so\n     * locking in such places doesn't affect the program liveness.\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInPrimitiveImplementations() {\n        allowBlockingCallsInJobSupport()\n        allowBlockingCallsInThreadSafeHeap()\n        allowBlockingCallsInFlow()\n        allowBlockingCallsInChannels()\n    }\n\n    /**\n     * Allows blocking inside [kotlinx.coroutines.JobSupport].\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInJobSupport() {\n        for (method in listOf(\"finalizeFinishingState\", \"invokeOnCompletion\", \"makeCancelling\",\n            \"tryMakeCompleting\"))\n        {\n            allowBlockingCallsInside(\"kotlinx.coroutines.JobSupport\", method)\n        }\n    }\n\n    /**\n     * Allow blocking calls inside [kotlinx.coroutines.debug.internal.DebugProbesImpl].\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInDebugProbes() {\n        for (method in listOf(\"install\", \"uninstall\", \"hierarchyToString\", \"dumpCoroutinesInfo\", \"dumpDebuggerInfo\",\n            \"dumpCoroutinesSynchronized\", \"updateRunningState\", \"updateState\"))\n        {\n            allowBlockingCallsInside(\"kotlinx.coroutines.debug.internal.DebugProbesImpl\", method)\n        }\n    }\n\n    /**\n     * Allow blocking calls inside [kotlinx.coroutines.scheduling.WorkQueue]\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInWorkQueue() {\n        /** uses [Thread.yield] in a benign way. */\n        allowBlockingCallsInside(\"kotlinx.coroutines.scheduling.WorkQueue\", \"addLast\")\n    }\n\n    /**\n     * Allows blocking inside [kotlinx.coroutines.internal.ThreadSafeHeap].\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInThreadSafeHeap() {\n        for (method in listOf(\"clear\", \"peek\", \"removeFirstOrNull\", \"addLast\")) {\n            allowBlockingCallsInside(\"kotlinx.coroutines.internal.ThreadSafeHeap\", method)\n        }\n    }\n\n    private fun BlockHound.Builder.allowBlockingCallsInFlow() {\n        allowBlockingCallsInsideStateFlow()\n        allowBlockingCallsInsideSharedFlow()\n    }\n\n    /**\n     * Allows blocking inside the implementation of [kotlinx.coroutines.flow.StateFlow].\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInsideStateFlow() {\n        allowBlockingCallsInside(\"kotlinx.coroutines.flow.StateFlowImpl\", \"updateState\")\n    }\n\n    /**\n     * Allows blocking inside the implementation of [kotlinx.coroutines.flow.SharedFlow].\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInsideSharedFlow() {\n        for (method in listOf(\"emitSuspend\", \"awaitValue\", \"getReplayCache\", \"tryEmit\", \"cancelEmitter\",\n            \"tryTakeValue\", \"resetReplayCache\"))\n        {\n            allowBlockingCallsInside(\"kotlinx.coroutines.flow.SharedFlowImpl\", method)\n        }\n        for (method in listOf(\"getSubscriptionCount\", \"allocateSlot\", \"freeSlot\")) {\n            allowBlockingCallsInside(\"kotlinx.coroutines.flow.internal.AbstractSharedFlow\", method)\n        }\n    }\n\n    private fun BlockHound.Builder.allowBlockingCallsInChannels() {\n        allowBlockingCallsInBroadcastChannels()\n        allowBlockingCallsInConflatedChannels()\n    }\n\n    /**\n     * Allows blocking inside [kotlinx.coroutines.channels.BroadcastChannel].\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInBroadcastChannels() {\n        for (method in listOf(\"openSubscription\", \"removeSubscriber\", \"send\", \"trySend\", \"registerSelectForSend\",\n                              \"close\", \"cancelImpl\", \"isClosedForSend\", \"value\", \"valueOrNull\"))\n        {\n            allowBlockingCallsInside(\"kotlinx.coroutines.channels.BroadcastChannelImpl\", method)\n        }\n        for (method in listOf(\"cancelImpl\")) {\n            allowBlockingCallsInside(\"kotlinx.coroutines.channels.BroadcastChannelImpl\\$SubscriberConflated\", method)\n        }\n        for (method in listOf(\"cancelImpl\")) {\n            allowBlockingCallsInside(\"kotlinx.coroutines.channels.BroadcastChannelImpl\\$SubscriberBuffered\", method)\n        }\n    }\n\n    /**\n     * Allows blocking inside [kotlinx.coroutines.channels.ConflatedBufferedChannel].\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInConflatedChannels() {\n        for (method in listOf(\"receive\", \"receiveCatching\", \"tryReceive\", \"registerSelectForReceive\",\n                              \"send\", \"trySend\", \"sendBroadcast\", \"registerSelectForSend\",\n                              \"close\", \"cancelImpl\", \"isClosedForSend\", \"isClosedForReceive\", \"isEmpty\"))\n        {\n            allowBlockingCallsInside(\"kotlinx.coroutines.channels.ConflatedBufferedChannel\", method)\n        }\n        for (method in listOf(\"hasNext\")) {\n            allowBlockingCallsInside(\"kotlinx.coroutines.channels.ConflatedBufferedChannel\\$ConflatedChannelIterator\", method)\n        }\n    }\n\n    /**\n     * Allows blocking when enqueuing tasks into a thread pool.\n     *\n     * Without this, the following code breaks:\n     * ```\n     * withContext(Dispatchers.Default) {\n     *     withContext(newSingleThreadContext(\"singleThreadedContext\")) {\n     *     }\n     * }\n     * ```\n     */\n    private fun BlockHound.Builder.allowBlockingWhenEnqueuingTasks() {\n        /* This method may block as part of its implementation, but is probably safe. */\n        allowBlockingCallsInside(\"java.util.concurrent.ScheduledThreadPoolExecutor\", \"execute\")\n    }\n\n    /**\n     * Allows instances of [java.util.ServiceLoader] being called.\n     *\n     * Each instance is listed separately; another approach could be to generally allow the operations performed by\n     * service loaders, as they can generally be considered safe. This was not done here because ServiceLoader has a\n     * large API surface, with some methods being hidden as implementation details (in particular, the implementation of\n     * its iterator is completely opaque). Relying on particular names being used in ServiceLoader's implementation\n     * would be brittle, so here we only provide clearance rules for some specific instances.\n     */\n    private fun BlockHound.Builder.allowServiceLoaderInvocationsOnInit() {\n        allowBlockingCallsInside(\"kotlinx.coroutines.reactive.ReactiveFlowKt\", \"<clinit>\")\n        allowBlockingCallsInside(\"kotlinx.coroutines.CoroutineExceptionHandlerImplKt\", \"<clinit>\")\n        // not part of the coroutines library, but it would be nice if reflection also wasn't considered blocking\n        allowBlockingCallsInside(\"kotlin.reflect.jvm.internal.impl.resolve.OverridingUtil\", \"<clinit>\")\n    }\n\n    /**\n     * Allows some blocking calls from the reflection API.\n     *\n     * The API is big, so surely some other blocking calls will show up, but with these rules in place, at least some\n     * simple examples work without problems.\n     */\n    private fun BlockHound.Builder.allowBlockingCallsInReflectionImpl() {\n        allowBlockingCallsInside(\"kotlin.reflect.jvm.internal.impl.builtins.jvm.JvmBuiltInsPackageFragmentProvider\", \"findPackage\")\n    }\n\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/DebugProbes.kt",
        "content": "@file:Suppress(\"UNUSED\", \"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n\npackage kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\nimport java.io.*\nimport java.lang.management.*\nimport kotlin.coroutines.*\n\n/**\n * Kotlin debug probes support.\n *\n * Debug probes is a dynamic attach mechanism which installs multiple hooks into coroutines machinery.\n * It slows down all coroutine-related code, but in return provides diagnostic information, including\n * asynchronous stacktraces, coroutine dumps (similar to [ThreadMXBean.dumpAllThreads] and `jstack`) via [DebugProbes.dumpCoroutines],\n * and programmatic introspection of all alive coroutines.\n * All introspecting methods throw [IllegalStateException] if debug probes were not installed.\n *\n * ### Consistency guarantees\n *\n * All snapshotting operations (e.g. [dumpCoroutines]) are *weakly-consistent*, meaning that they happen\n * concurrently with coroutines progressing their own state. These operations are guaranteed to observe\n * each coroutine's state exactly once, but the state is not guaranteed to be the most recent before the operation.\n * In practice, it means that for snapshotting operations in progress, for each concurrent coroutine either\n * the state prior to the operation or the state that was reached during the current operation is observed.\n *\n * ### Overhead\n *\n *  - Every created coroutine is stored in a concurrent hash map, and the hash map is looked up in and\n *    updated on each suspension and resumption.\n *  - If [DebugProbes.enableCreationStackTraces] is enabled, stack trace of the current thread is captured on\n *    each created coroutine that is a rough equivalent of throwing an exception per each created coroutine.\n *\n * ### Internal machinery and classloading.\n *\n * Under the hood, debug probes replace internal `kotlin.coroutines.jvm.internal.DebugProbesKt` class that has the following\n * empty static methods:\n *\n * - `probeCoroutineResumed` that is invoked on every [Continuation.resume].\n * - `probeCoroutineSuspended` that is invoked on every continuation suspension.\n * - `probeCoroutineCreated` that is invoked on every coroutine creation.\n *\n * with a `kotlinx-coroutines`-specific class to keep track of all the coroutines machinery.\n *\n * The new class is located in the `kotlinx-coroutines-core` module, meaning that all target application classes that use\n * coroutines and `suspend` functions have to be loaded by the classloader in which `kotlinx-coroutines-core` classes are available.\n */\n@ExperimentalCoroutinesApi\npublic object DebugProbes {\n\n    /**\n     * Whether coroutine creation stack traces should be sanitized.\n     * Sanitization removes all frames from `kotlinx.coroutines` package except\n     * the first one and the last one to simplify diagnostic.\n     *\n     * `true` by default.\n     */\n    public var sanitizeStackTraces: Boolean\n        get() = DebugProbesImpl.sanitizeStackTraces\n        @Suppress(\"INVISIBLE_SETTER\") // do not remove the INVISIBLE_SETTER suppression: required in k2\n        set(value) {\n            DebugProbesImpl.sanitizeStackTraces = value\n        }\n\n    /**\n     * Whether coroutine creation stack traces should be captured.\n     * When enabled, for each created coroutine a stack trace of the current thread is captured and attached to the coroutine.\n     * This option can be useful during local debug sessions, but is recommended\n     * to be disabled in production environments to avoid performance overhead of capturing real stacktraces.\n     *\n     * `false` by default.\n     */\n    public var enableCreationStackTraces: Boolean\n        get() = DebugProbesImpl.enableCreationStackTraces\n        @Suppress(\"INVISIBLE_SETTER\") // do not remove the INVISIBLE_SETTER suppression: required in k2\n        set(value) {\n            DebugProbesImpl.enableCreationStackTraces = value\n        }\n\n    /**\n     * Whether to ignore coroutines whose context is [EmptyCoroutineContext].\n     *\n     * Coroutines with empty context are considered to be irrelevant for the concurrent coroutines' observability:\n     * - They do not contribute to any concurrent executions\n     * - They do not contribute to the (concurrent) system's liveness and/or deadlocks, as no other coroutines might wait for them\n     * - The typical usage of such coroutines is a combinator/builder/lookahead parser that can be debugged using more convenient tools.\n     *\n     * `true` by default.\n     */\n    public var ignoreCoroutinesWithEmptyContext: Boolean\n        get() = DebugProbesImpl.ignoreCoroutinesWithEmptyContext\n        @Suppress(\"INVISIBLE_SETTER\") // do not remove the INVISIBLE_SETTER suppression: required in k2\n        set(value) {\n            DebugProbesImpl.ignoreCoroutinesWithEmptyContext = value\n        }\n\n    /**\n     * Determines whether debug probes were [installed][DebugProbes.install].\n     */\n    public val isInstalled: Boolean get() = DebugProbesImpl.isInstalled\n\n    /**\n     * Installs a [DebugProbes] instead of no-op stdlib probes by redefining\n     * debug probes class using the same class loader as one loaded [DebugProbes] class.\n     */\n    public fun install() {\n        DebugProbesImpl.install()\n    }\n\n    /**\n     * Uninstall debug probes.\n     */\n    public fun uninstall() {\n        DebugProbesImpl.uninstall()\n    }\n\n    /**\n     * Invokes given block of code with installed debug probes and uninstall probes in the end.\n     */\n    public inline fun withDebugProbes(block: () -> Unit) {\n        install()\n        try {\n            block()\n        } finally {\n            uninstall()\n        }\n    }\n\n    /**\n     * Returns string representation of the coroutines [job] hierarchy with additional debug information.\n     * Hierarchy is printed from the [job] as a root transitively to all children.\n     */\n    public fun jobToString(job: Job): String = DebugProbesImpl.hierarchyToString(job)\n\n    /**\n     * Returns string representation of all coroutines launched within the given [scope].\n     * Throws [IllegalStateException] if the scope has no a job in it.\n     */\n    public fun scopeToString(scope: CoroutineScope): String =\n        jobToString(scope.coroutineContext[Job] ?: error(\"Job is not present in the scope\"))\n\n    /**\n     * Prints [job] hierarchy representation from [jobToString] to the given [out].\n     */\n    public fun printJob(job: Job, out: PrintStream = System.out): Unit =\n        out.println(DebugProbesImpl.hierarchyToString(job))\n\n    /**\n     * Prints all coroutines launched within the given [scope].\n     * Throws [IllegalStateException] if the scope has no a job in it.\n     */\n    public fun printScope(scope: CoroutineScope, out: PrintStream = System.out): Unit =\n        printJob(scope.coroutineContext[Job] ?: error(\"Job is not present in the scope\"), out)\n\n    /**\n     * Returns all existing coroutines' info.\n     * The resulting collection represents a consistent snapshot of all existing coroutines at the moment of invocation.\n     */\n    public fun dumpCoroutinesInfo(): List<CoroutineInfo> =\n        DebugProbesImpl.dumpCoroutinesInfo().map { CoroutineInfo(it) }\n\n    /**\n     * Dumps all active coroutines into the given output stream, providing a consistent snapshot of all existing coroutines at the moment of invocation.\n     * The output of this method is similar to `jstack` or a full thread dump. It can be used as the replacement to\n     * \"Dump threads\" action.\n     *\n     * Example of the output:\n     * ```\n     * Coroutines dump 2018/11/12 19:45:14\n     *\n     * Coroutine \"coroutine#42\":StandaloneCoroutine{Active}@58fdd99, state: SUSPENDED\n     *     at MyClass$awaitData.invokeSuspend(MyClass.kt:37)\n     *     at _COROUTINE._CREATION._(CoroutineDebugging.kt)\n     *     at MyClass.createIoRequest(MyClass.kt:142)\n     *     at MyClass.fetchData(MyClass.kt:154)\n     *     at MyClass.showData(MyClass.kt:31)\n     * ...\n     * ```\n     */\n    public fun dumpCoroutines(out: PrintStream = System.out): Unit = DebugProbesImpl.dumpCoroutines(out)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/internal/Attach.kt",
        "content": "@file:Suppress(\"unused\")\npackage kotlinx.coroutines.debug.internal\n\nimport net.bytebuddy.*\nimport net.bytebuddy.agent.*\nimport net.bytebuddy.dynamic.loading.*\n\n/*\n * This class is used reflectively from kotlinx-coroutines-core when this module is present in the classpath.\n * It is a substitute for service loading.\n */\ninternal class ByteBuddyDynamicAttach : Function1<Boolean, Unit> {\n    override fun invoke(value: Boolean) {\n        if (value) attach() else detach()\n    }\n\n    private fun attach() {\n        ByteBuddyAgent.install(ByteBuddyAgent.AttachmentProvider.ForEmulatedAttachment.INSTANCE)\n        val cl = Class.forName(\"kotlin.coroutines.jvm.internal.DebugProbesKt\")\n        val cl2 = Class.forName(\"kotlinx.coroutines.debug.internal.DebugProbesKt\")\n\n        ByteBuddy()\n            .redefine(cl2)\n            .name(cl.name)\n            .make()\n            .load(cl.classLoader, ClassReloadingStrategy.fromInstalledAgent())\n    }\n\n    private fun detach() {\n        val cl = Class.forName(\"kotlin.coroutines.jvm.internal.DebugProbesKt\")\n        val cl2 = Class.forName(\"kotlinx.coroutines.debug.internal.NoOpProbesKt\")\n        ByteBuddy()\n            .redefine(cl2)\n            .name(cl.name)\n            .make()\n            .load(cl.classLoader, ClassReloadingStrategy.fromInstalledAgent())\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/internal/NoOpProbes.kt",
        "content": "@file:Suppress(\"unused\", \"UNUSED_PARAMETER\")\n\npackage kotlinx.coroutines.debug.internal\n\nimport kotlin.coroutines.*\n\n/*\n * Empty class used to replace installed agent in the end of debug session\n */\n@JvmName(\"probeCoroutineResumed\")\ninternal fun probeCoroutineResumedNoOp(frame: Continuation<*>) = Unit\n@JvmName(\"probeCoroutineSuspended\")\ninternal fun probeCoroutineSuspendedNoOp(frame: Continuation<*>) = Unit\n@JvmName(\"probeCoroutineCreated\")\ninternal fun <T> probeCoroutineCreatedNoOp(completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<T> = completion\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/junit/CoroutinesTimeoutImpl.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport java.util.concurrent.*\n\n/**\n * Run [invocation] in a separate thread with the given timeout in ms, after which the coroutines info is dumped and, if\n * [cancelOnTimeout] is set, the execution is interrupted.\n *\n * Assumes that [DebugProbes] are installed. Does not deinstall them.\n */\ninternal inline fun <T : Any?> runWithTimeoutDumpingCoroutines(\n    methodName: String,\n    testTimeoutMs: Long,\n    cancelOnTimeout: Boolean,\n    initCancellationException: () -> Throwable,\n    crossinline invocation: () -> T\n): T {\n    val testStartedLatch = CountDownLatch(1)\n    val testResult = FutureTask {\n        testStartedLatch.countDown()\n        invocation()\n    }\n    /*\n     * We are using hand-rolled thread instead of single thread executor\n     * in order to be able to safely interrupt thread in the end of a test\n     */\n    val testThread = Thread(testResult, \"Timeout test thread\").apply { isDaemon = true }\n    try {\n        testThread.start()\n        // Await until test is started to take only test execution time into account\n        testStartedLatch.await()\n        return testResult.get(testTimeoutMs, TimeUnit.MILLISECONDS)\n    } catch (e: TimeoutException) {\n        handleTimeout(testThread, methodName, testTimeoutMs, cancelOnTimeout, initCancellationException())\n    } catch (e: ExecutionException) {\n        throw e.cause ?: e\n    }\n}\n\nprivate fun handleTimeout(testThread: Thread, methodName: String, testTimeoutMs: Long, cancelOnTimeout: Boolean,\n                          cancellationException: Throwable): Nothing {\n    val units =\n        if (testTimeoutMs % 1000 == 0L)\n            \"${testTimeoutMs / 1000} seconds\"\n        else \"$testTimeoutMs milliseconds\"\n\n    System.err.println(\"\\nTest $methodName timed out after $units\\n\")\n    System.err.flush()\n\n    DebugProbes.dumpCoroutines()\n    System.out.flush() // Synchronize serr/sout\n\n    /*\n     * Order is important:\n     * 1) Create exception with a stacktrace of hang test\n     * 2) Cancel all coroutines via debug agent API (changing system state!)\n     * 3) Throw created exception\n     */\n    cancellationException.attachStacktraceFrom(testThread)\n    testThread.interrupt()\n    cancelIfNecessary(cancelOnTimeout)\n    // If timed out test throws an exception, we can't do much except ignoring it\n    throw cancellationException\n}\n\nprivate fun cancelIfNecessary(cancelOnTimeout: Boolean) {\n    if (cancelOnTimeout) {\n        DebugProbes.dumpCoroutinesInfo().forEach {\n            it.job?.cancel()\n        }\n    }\n}\n\nprivate fun Throwable.attachStacktraceFrom(thread: Thread) {\n    val stackTrace = thread.stackTrace\n    this.stackTrace = stackTrace\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/junit/junit4/CoroutinesTimeout.kt",
        "content": "package kotlinx.coroutines.debug.junit4\n\nimport kotlinx.coroutines.debug.*\nimport org.junit.rules.*\nimport org.junit.runner.*\nimport org.junit.runners.model.*\nimport java.util.concurrent.*\n\n/**\n * Coroutines timeout rule for JUnit4 that is applied to all methods in the class.\n * This rule is very similar to [Timeout] rule: it runs tests in a separate thread,\n * fails tests after the given timeout and interrupts test thread.\n *\n * Additionally, this rule installs [DebugProbes] and dumps all coroutines at the moment of the timeout.\n * It may cancel coroutines on timeout if [cancelOnTimeout] set to `true`.\n * [enableCoroutineCreationStackTraces] controls the corresponding [DebugProbes.enableCreationStackTraces] property\n * and can be optionally enabled if the creation stack traces are necessary.\n *\n * Example of usage:\n * ```\n * class HangingTest {\n *     @get:Rule\n *     val timeout = CoroutinesTimeout.seconds(5)\n *\n *     @Test\n *     fun testThatHangs() = runBlocking {\n *          ...\n *          delay(Long.MAX_VALUE) // somewhere deep in the stack\n *          ...\n *     }\n * }\n * ```\n */\npublic class CoroutinesTimeout(\n    private val testTimeoutMs: Long,\n    private val cancelOnTimeout: Boolean = false,\n    private val enableCoroutineCreationStackTraces: Boolean = false\n) : TestRule {\n\n    @Suppress(\"UNUSED\") // Binary compatibility\n    public constructor(testTimeoutMs: Long, cancelOnTimeout: Boolean = false) : this(\n        testTimeoutMs,\n        cancelOnTimeout,\n        true\n    )\n\n    init {\n        require(testTimeoutMs > 0) { \"Expected positive test timeout, but had $testTimeoutMs\" }\n        /*\n         * Install probes in the constructor, so all the coroutines launched from within\n         * target test constructor will be captured\n         */\n        // Do not preserve previous state for unit-test environment\n        DebugProbes.enableCreationStackTraces = enableCoroutineCreationStackTraces\n        DebugProbes.install()\n    }\n\n    public companion object {\n        /**\n         * Creates [CoroutinesTimeout] rule with the given timeout in seconds.\n         */\n        @JvmOverloads\n        public fun seconds(\n            seconds: Int,\n            cancelOnTimeout: Boolean = false,\n            enableCoroutineCreationStackTraces: Boolean = true\n        ): CoroutinesTimeout =\n            seconds(seconds.toLong(), cancelOnTimeout, enableCoroutineCreationStackTraces)\n\n        /**\n         * Creates [CoroutinesTimeout] rule with the given timeout in seconds.\n         */\n        @JvmOverloads\n        public fun seconds(\n            seconds: Long,\n            cancelOnTimeout: Boolean = false,\n            enableCoroutineCreationStackTraces: Boolean = true\n        ): CoroutinesTimeout =\n            CoroutinesTimeout(\n                TimeUnit.SECONDS.toMillis(seconds),  // Overflow is properly handled by TimeUnit\n                cancelOnTimeout,\n                enableCoroutineCreationStackTraces\n            )\n    }\n\n    /**\n     * @suppress suppress from Dokka\n     */\n    override fun apply(base: Statement, description: Description): Statement =\n        CoroutinesTimeoutStatement(base, description, testTimeoutMs, cancelOnTimeout)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/junit/junit4/CoroutinesTimeoutStatement.kt",
        "content": "package kotlinx.coroutines.debug.junit4\n\nimport kotlinx.coroutines.debug.*\nimport org.junit.runner.*\nimport org.junit.runners.model.*\nimport java.util.concurrent.*\n\ninternal class CoroutinesTimeoutStatement(\n    private val testStatement: Statement,\n    private val testDescription: Description,\n    private val testTimeoutMs: Long,\n    private val cancelOnTimeout: Boolean = false\n) : Statement() {\n\n    override fun evaluate() {\n        try {\n            runWithTimeoutDumpingCoroutines(testDescription.methodName, testTimeoutMs, cancelOnTimeout,\n                { TestTimedOutException(testTimeoutMs, TimeUnit.MILLISECONDS) })\n            {\n                testStatement.evaluate()\n            }\n        } finally {\n            DebugProbes.uninstall()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/junit/junit5/CoroutinesTimeout.kt",
        "content": "package kotlinx.coroutines.debug.junit5\nimport kotlinx.coroutines.debug.*\nimport org.junit.jupiter.api.*\nimport org.junit.jupiter.api.extension.*\nimport org.junit.jupiter.api.parallel.*\nimport java.lang.annotation.*\n\n/**\n * Coroutines timeout annotation that is similar to JUnit5's [Timeout] annotation. It allows running test methods in a\n * separate thread, failing them after the provided time limit and interrupting the thread.\n *\n * Additionally, it installs [DebugProbes] and dumps all coroutines at the moment of the timeout. It also cancels\n * coroutines on timeout if [cancelOnTimeout] set to `true`. The dump contains the coroutine creation stack traces.\n *\n * This annotation has an effect on test, test factory, test template, and lifecycle methods and test classes that are\n * annotated with it.\n *\n * Annotating a class is the same as annotating every test, test factory, and test template method (but not lifecycle\n * methods) of that class and its inner test classes, unless any of them is annotated with [CoroutinesTimeout], in which\n * case their annotation overrides the one on the containing class.\n *\n * Declaring [CoroutinesTimeout] on a test factory checks that it finishes in the specified time, but does not check\n * whether the methods that it produces obey the timeout as well.\n *\n * Example usage:\n * ```\n * @CoroutinesTimeout(100)\n * class CoroutinesTimeoutSimpleTest {\n *     // does not time out, as the annotation on the method overrides the class-level one\n *     @CoroutinesTimeout(1000)\n *     @Test\n *     fun classTimeoutIsOverridden() {\n *         runBlocking {\n *             delay(150)\n *         }\n *     }\n *\n *     // times out in 100 ms, timeout value is taken from the class-level annotation\n *     @Test\n *     fun classTimeoutIsUsed() {\n *         runBlocking {\n *             delay(150)\n *         }\n *     }\n * }\n * ```\n *\n * @see Timeout\n */\n@ExtendWith(CoroutinesTimeoutExtension::class)\n@Inherited\n@MustBeDocumented\n@ResourceLock(\"coroutines timeout\", mode = ResourceAccessMode.READ)\n@Retention(value = AnnotationRetention.RUNTIME)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\npublic annotation class CoroutinesTimeout(\n    val testTimeoutMs: Long,\n    val cancelOnTimeout: Boolean = false\n)\n"
    },
    {
        "path": "kotlinx-coroutines-debug/src/junit/junit5/CoroutinesTimeoutExtension.kt",
        "content": "package kotlinx.coroutines.debug.junit5\n\nimport kotlinx.coroutines.debug.*\nimport kotlinx.coroutines.debug.runWithTimeoutDumpingCoroutines\nimport org.junit.jupiter.api.extension.*\nimport org.junit.platform.commons.support.AnnotationSupport\nimport java.lang.reflect.*\nimport java.util.*\nimport java.util.concurrent.atomic.*\n\ninternal class CoroutinesTimeoutException(val timeoutMs: Long): Exception(\"test timed out after $timeoutMs ms\")\n\n/**\n * This JUnit5 extension allows running test, test factory, test template, and lifecycle methods in a separate thread,\n * failing them after the provided time limit and interrupting the thread.\n *\n * Additionally, it installs [DebugProbes] and dumps all coroutines at the moment of the timeout. It also cancels\n * coroutines on timeout if [cancelOnTimeout] set to `true`.\n * [enableCoroutineCreationStackTraces] controls the corresponding [DebugProbes.enableCreationStackTraces] property\n * and can be optionally enabled if the creation stack traces are necessary.\n *\n * Beware that if several tests that use this extension set [enableCoroutineCreationStackTraces] to different values and\n * execute in parallel, the behavior is ill-defined. In order to avoid conflicts between different instances of this\n * extension when using JUnit5 in parallel, use [ResourceLock] with resource name `coroutines timeout` on tests that use\n * it. Note that the tests annotated with [CoroutinesTimeout] already use this [ResourceLock], so there is no need to\n * annotate them additionally.\n *\n * Note that while calls to test factories are verified to finish in the specified time, but the methods that they\n * produce are not affected by this extension.\n *\n * Beware that registering the extension via [CoroutinesTimeout] annotation conflicts with manually registering it on\n * the same tests via other methods (most notably, [RegisterExtension]) and is prohibited.\n *\n * Example of usage:\n * ```\n * class HangingTest {\n *     @JvmField\n *     @RegisterExtension\n *     val timeout = CoroutinesTimeoutExtension.seconds(5)\n *\n *     @Test\n *     fun testThatHangs() = runBlocking {\n *          ...\n *          delay(Long.MAX_VALUE) // somewhere deep in the stack\n *          ...\n *     }\n * }\n * ```\n *\n * @see [CoroutinesTimeout]\n * */\n// NB: the constructor is not private so that JUnit is able to call it via reflection.\ninternal class CoroutinesTimeoutExtension internal constructor(\n    private val enableCoroutineCreationStackTraces: Boolean = false,\n    private val timeoutMs: Long? = null,\n    private val cancelOnTimeout: Boolean? = null): InvocationInterceptor\n{\n    /**\n     * Creates the [CoroutinesTimeoutExtension] extension with the given timeout in milliseconds.\n     */\n    public constructor(timeoutMs: Long, cancelOnTimeout: Boolean = false,\n                       enableCoroutineCreationStackTraces: Boolean = true):\n        this(enableCoroutineCreationStackTraces, timeoutMs, cancelOnTimeout)\n\n    public companion object {\n        /**\n         * Creates the [CoroutinesTimeoutExtension] extension with the given timeout in seconds.\n         */\n        @JvmOverloads\n        public fun seconds(timeout: Int, cancelOnTimeout: Boolean = false,\n                           enableCoroutineCreationStackTraces: Boolean = true): CoroutinesTimeoutExtension =\n            CoroutinesTimeoutExtension(enableCoroutineCreationStackTraces, timeout.toLong() * 1000, cancelOnTimeout)\n    }\n\n    /** @see [initialize] */\n    private val debugProbesOwnershipPassed = AtomicBoolean(false)\n\n    private fun tryPassDebugProbesOwnership() = debugProbesOwnershipPassed.compareAndSet(false, true)\n\n    /* We install the debug probes early so that the coroutines launched from the test constructor are captured as well.\n    However, this is not enough as the same extension instance may be reused several times, even cleaning up its\n    resources from the store. */\n    init {\n        DebugProbes.enableCreationStackTraces = enableCoroutineCreationStackTraces\n        DebugProbes.install()\n    }\n\n    // This is needed so that a class with no tests still successfully passes the ownership of DebugProbes to JUnit5.\n    override fun <T : Any?> interceptTestClassConstructor(\n        invocation: InvocationInterceptor.Invocation<T>,\n        invocationContext: ReflectiveInvocationContext<Constructor<T>>,\n        extensionContext: ExtensionContext\n    ): T {\n        initialize(extensionContext)\n        return invocation.proceed()\n    }\n\n    /**\n     * Initialize this extension instance and/or the extension value store.\n     *\n     * It seems that the only way to reliably have JUnit5 clean up after its extensions is to put an instance of\n     * [ExtensionContext.Store.CloseableResource] into the value store corresponding to the extension instance, which\n     * means that [DebugProbes.uninstall] must be placed into the value store. [debugProbesOwnershipPassed] is `true`\n     * if the call to [DebugProbes.install] performed in the constructor of the extension instance was matched with a\n     * placing of [DebugProbes.uninstall] into the value store. We call the process of placing the cleanup procedure\n     * \"passing the ownership\", as now JUnit5 (and not our code) has to worry about uninstalling the debug probes.\n     *\n     * However, extension instances can be reused with different value stores, and value stores can be reused across\n     * extension instances. This leads to a tricky scheme of performing [DebugProbes.uninstall]:\n     *\n     * - If neither the ownership of this instance's [DebugProbes] was yet passed nor there is any cleanup procedure\n     *   stored, it means that we can just store our cleanup procedure, passing the ownership.\n     * - If the ownership was not yet passed, but a cleanup procedure is already stored, we can't just replace it with\n     *   another one, as this would lead to imbalance between [DebugProbes.install] and [DebugProbes.uninstall].\n     *   Instead, we know that this extension context will at least outlive this use of this instance, so some debug\n     *   probes other than the ones from our constructor are already installed and won't be uninstalled during our\n     *   operation. We simply uninstall the debug probes that were installed in our constructor.\n     * - If the ownership was passed, but the store is empty, it means that this test instance is reused and, possibly,\n     *   the debug probes installed in its constructor were already uninstalled. This means that we have to install them\n     *   anew and store an uninstaller.\n     */\n    private fun initialize(extensionContext: ExtensionContext) {\n        val store: ExtensionContext.Store = extensionContext.getStore(\n            ExtensionContext.Namespace.create(CoroutinesTimeoutExtension::class, extensionContext.uniqueId))\n        /** It seems that the JUnit5 documentation does not specify the relationship between the extension instances and\n         * the corresponding [ExtensionContext] (in which the value stores are managed), so it is unclear whether it's\n         * theoretically possible for two extension instances that run concurrently to share an extension context. So,\n         * just in case this risk exists, we synchronize here. */\n        synchronized(store) {\n            if (store[\"debugProbes\"] == null) {\n                if (!tryPassDebugProbesOwnership()) {\n                    /** This means that the [DebugProbes.install] call from the constructor of this extensions has\n                     * already been matched with a corresponding cleanup procedure for JUnit5, but then JUnit5 cleaned\n                     * everything up and later reused the same extension instance for other tests. Therefore, we need to\n                     * install the [DebugProbes] anew. */\n                    DebugProbes.enableCreationStackTraces = enableCoroutineCreationStackTraces\n                    DebugProbes.install()\n                }\n                /** put a fake resource into this extensions's store so that JUnit cleans it up, uninstalling the\n                 * [DebugProbes] after this extension instance is no longer needed. **/\n                store.put(\"debugProbes\", ExtensionContext.Store.CloseableResource { DebugProbes.uninstall() })\n            } else if (!debugProbesOwnershipPassed.get()) {\n                /** This instance shares its store with other ones. Because of this, there was no need to install\n                 * [DebugProbes], they are already installed, and this fact will outlive this use of this instance of\n                 * the extension. */\n                if (tryPassDebugProbesOwnership()) {\n                    // We successfully marked the ownership as passed and now may uninstall the extraneous debug probes.\n                    DebugProbes.uninstall()\n                }\n            }\n        }\n    }\n\n    override fun interceptTestMethod(\n        invocation: InvocationInterceptor.Invocation<Void>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ) {\n        interceptNormalMethod(invocation, invocationContext, extensionContext)\n    }\n\n    override fun interceptAfterAllMethod(\n        invocation: InvocationInterceptor.Invocation<Void>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ) {\n        interceptLifecycleMethod(invocation, invocationContext, extensionContext)\n    }\n\n    override fun interceptAfterEachMethod(\n        invocation: InvocationInterceptor.Invocation<Void>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ) {\n        interceptLifecycleMethod(invocation, invocationContext, extensionContext)\n    }\n\n    override fun interceptBeforeAllMethod(\n        invocation: InvocationInterceptor.Invocation<Void>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ) {\n        interceptLifecycleMethod(invocation, invocationContext, extensionContext)\n    }\n\n    override fun interceptBeforeEachMethod(\n        invocation: InvocationInterceptor.Invocation<Void>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ) {\n        interceptLifecycleMethod(invocation, invocationContext, extensionContext)\n    }\n\n    override fun <T : Any?> interceptTestFactoryMethod(\n        invocation: InvocationInterceptor.Invocation<T>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ): T = interceptNormalMethod(invocation, invocationContext, extensionContext)\n\n    override fun interceptTestTemplateMethod(\n        invocation: InvocationInterceptor.Invocation<Void>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ) {\n        interceptNormalMethod(invocation, invocationContext, extensionContext)\n    }\n\n    private fun<T> Class<T>.coroutinesTimeoutAnnotation(): Optional<CoroutinesTimeout> =\n        AnnotationSupport.findAnnotation(this, CoroutinesTimeout::class.java).or {\n            enclosingClass?.coroutinesTimeoutAnnotation() ?: Optional.empty()\n        }\n\n    private fun <T: Any?> interceptMethod(\n        useClassAnnotation: Boolean,\n        invocation: InvocationInterceptor.Invocation<T>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ): T {\n        initialize(extensionContext)\n        val testAnnotationOptional =\n            AnnotationSupport.findAnnotation(invocationContext.executable, CoroutinesTimeout::class.java)\n        val classAnnotationOptional = extensionContext.testClass.flatMap { it.coroutinesTimeoutAnnotation() }\n        if (timeoutMs != null && cancelOnTimeout != null) {\n            // this means we @RegisterExtension was used in order to register this extension.\n            if (testAnnotationOptional.isPresent || classAnnotationOptional.isPresent) {\n                /* Using annotations creates a separate instance of the extension, which composes in a strange way: both\n                timeouts are applied. This is at odds with the concept that method-level annotations override the outer\n                rules and may lead to unexpected outcomes, so we prohibit this. */\n                throw UnsupportedOperationException(\"Using CoroutinesTimeout along with instance field-registered CoroutinesTimeout is prohibited; please use either @RegisterExtension or @CoroutinesTimeout, but not both\")\n            }\n            return interceptInvocation(invocation, invocationContext.executable.name, timeoutMs, cancelOnTimeout)\n        }\n        /* The extension was registered via an annotation; check that we succeeded in finding the annotation that led to\n        the extension being registered and taking its parameters. */\n        if (testAnnotationOptional.isEmpty && classAnnotationOptional.isEmpty) {\n            throw UnsupportedOperationException(\"Timeout was registered with a CoroutinesTimeout annotation, but we were unable to find it. Please report this.\")\n        }\n        return when {\n            testAnnotationOptional.isPresent -> {\n                val annotation = testAnnotationOptional.get()\n                interceptInvocation(invocation, invocationContext.executable.name, annotation.testTimeoutMs,\n                    annotation.cancelOnTimeout)\n            }\n            useClassAnnotation && classAnnotationOptional.isPresent -> {\n                val annotation = classAnnotationOptional.get()\n                interceptInvocation(invocation, invocationContext.executable.name, annotation.testTimeoutMs,\n                    annotation.cancelOnTimeout)\n            }\n            else -> {\n                invocation.proceed()\n            }\n        }\n    }\n\n    private fun<T> interceptNormalMethod(\n        invocation: InvocationInterceptor.Invocation<T>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ): T = interceptMethod(true, invocation, invocationContext, extensionContext)\n\n    private fun interceptLifecycleMethod(\n        invocation: InvocationInterceptor.Invocation<Void>,\n        invocationContext: ReflectiveInvocationContext<Method>,\n        extensionContext: ExtensionContext\n    ) = interceptMethod(false, invocation, invocationContext, extensionContext)\n\n    private fun <T : Any?> interceptInvocation(\n        invocation: InvocationInterceptor.Invocation<T>,\n        methodName: String,\n        testTimeoutMs: Long,\n        cancelOnTimeout: Boolean\n    ): T =\n        runWithTimeoutDumpingCoroutines(methodName, testTimeoutMs, cancelOnTimeout,\n            { CoroutinesTimeoutException(testTimeoutMs) }, { invocation.proceed() })\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/BlockHoundTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.*\nimport reactor.blockhound.*\n\n@Suppress(\"UnusedEquals\", \"DeferredResultUnused\", \"BlockingMethodInNonBlockingContext\")\nclass BlockHoundTest : TestBase() {\n\n    @Before\n    fun init() {\n        BlockHound.install()\n    }\n\n    @Test(expected = BlockingOperationError::class)\n    fun testShouldDetectBlockingInDefault() = runTest {\n        withContext(Dispatchers.Default) {\n            Thread.sleep(1)\n        }\n    }\n\n    @Test\n    fun testShouldNotDetectBlockingInIO() = runTest {\n        withContext(Dispatchers.IO) {\n            Thread.sleep(1)\n        }\n    }\n\n    @Test\n    fun testShouldNotDetectNonblocking() = runTest {\n        withContext(Dispatchers.Default) {\n            val a = 1\n            val b = 2\n            assert(a + b == 3)\n        }\n    }\n\n    @Test\n    fun testReusingThreads() = runTest {\n        val n = 100\n        repeat(n) {\n            async(Dispatchers.IO) {\n                Thread.sleep(1)\n            }\n        }\n        repeat(n) {\n            async(Dispatchers.Default) {\n            }\n        }\n        repeat(n) {\n            async(Dispatchers.IO) {\n                Thread.sleep(1)\n            }\n        }\n    }\n\n    @Test\n    fun testBroadcastChannelNotBeingConsideredBlocking() = runTest {\n        withContext(Dispatchers.Default) {\n            // Copy of kotlinx.coroutines.channels.BufferedChannelTest.testSimple\n            val q = BroadcastChannel<Int>(1)\n            val s = q.openSubscription()\n            check(!q.isClosedForSend)\n            check(s.isEmpty)\n            check(!s.isClosedForReceive)\n            val sender = launch {\n                q.send(1)\n                q.send(2)\n            }\n            val receiver = launch {\n                s.receive() == 1\n                s.receive() == 2\n                s.cancel()\n            }\n            sender.join()\n            receiver.join()\n        }\n    }\n\n    @Test\n    fun testConflatedChannelNotBeingConsideredBlocking() = runTest {\n        withContext(Dispatchers.Default) {\n            val q = Channel<Int>(Channel.CONFLATED)\n            check(q.isEmpty)\n            check(!q.isClosedForReceive)\n            check(!q.isClosedForSend)\n            val sender = launch {\n                q.send(1)\n            }\n            val receiver = launch {\n                q.receive() == 1\n            }\n            sender.join()\n            receiver.join()\n        }\n    }\n\n    @Test(expected = BlockingOperationError::class)\n    fun testReusingThreadsFailure() = runTest {\n        val n = 100\n        repeat(n) {\n            async(Dispatchers.IO) {\n                Thread.sleep(1)\n            }\n        }\n        async(Dispatchers.Default) {\n            Thread.sleep(1)\n        }\n        repeat(n) {\n            async(Dispatchers.IO) {\n                Thread.sleep(1)\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/CoroutinesDumpTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass CoroutinesDumpTest : DebugTestBase() {\n    private val monitor = Any()\n    private var coroutineThread: Thread? = null // guarded by monitor\n\n    @Before\n    override fun setUp() {\n        super.setUp()\n        DebugProbes.enableCreationStackTraces = true\n    }\n\n    @Test\n    fun testSuspendedCoroutine() = runBlocking {\n        val deferred = async(Dispatchers.Default) {\n            sleepingOuterMethod()\n        }\n\n        awaitCoroutine()\n        val found = DebugProbes.dumpCoroutinesInfo().single { it.job === deferred }\n        verifyDump(\n            \"Coroutine \\\"coroutine#1\\\":DeferredCoroutine{Active}@1e4a7dd4, state: SUSPENDED\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest.sleepingNestedMethod(CoroutinesDumpTest.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest.sleepingOuterMethod(CoroutinesDumpTest.kt)\\n\" +\n                    \"\\tat _COROUTINE._CREATION._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable\\$default(Cancellable.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.CoroutineStart.invoke(CoroutineStart.kt)\\n\",\n            ignoredCoroutine = \"BlockingCoroutine\"\n        ) {\n            deferred.cancel()\n            coroutineThread!!.interrupt()\n        }\n        assertSame(deferred, found.job)\n    }\n\n    @Test\n    fun testRunningCoroutine() = runBlocking {\n        val deferred = async(Dispatchers.IO) {\n            activeMethod(shouldSuspend = false)\n            assertTrue(true)\n        }\n\n        awaitCoroutine()\n        verifyDump(\n            \"Coroutine \\\"coroutine#1\\\":DeferredCoroutine{Active}@227d9994, state: RUNNING\\n\" +\n                    \"\\tat java.lang.Thread.sleep(Native Method)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest.nestedActiveMethod(CoroutinesDumpTest.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest.activeMethod(CoroutinesDumpTest.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest.access\\$activeMethod(CoroutinesDumpTest.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest\\$testRunningCoroutine\\$1\\$deferred\\$1.invokeSuspend(CoroutinesDumpTest.kt)\\n\" +\n                    \"\\tat _COROUTINE._CREATION._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable\\$default(Cancellable.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.CoroutineStart.invoke(CoroutineStart.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.AbstractCoroutine.start(AbstractCoroutine.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt__Builders_commonKt.async(Builders.common.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt.async(Unknown Source)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt__Builders_commonKt.async\\$default(Builders.common.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt.async\\$default(Unknown Source)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest\\$testRunningCoroutine\\$1.invokeSuspend(CoroutinesDumpTest.kt)\",\n            ignoredCoroutine = \"BlockingCoroutine\"\n        ) {\n            deferred.cancel()\n            coroutineThread?.interrupt()\n        }\n    }\n\n    @Test\n    fun testRunningCoroutineWithSuspensionPoint() = runBlocking {\n        val deferred = async(Dispatchers.IO) {\n            activeMethod(shouldSuspend = true)\n            yield() // tail-call\n        }\n\n        awaitCoroutine()\n        verifyDump(\n            \"Coroutine \\\"coroutine#1\\\":DeferredCoroutine{Active}@1e4a7dd4, state: RUNNING\\n\" +\n                    \"\\tat java.lang.Thread.sleep(Native Method)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest.nestedActiveMethod(CoroutinesDumpTest.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest.activeMethod(CoroutinesDumpTest.kt)\\n\" +\n                    \"\\tat _COROUTINE._CREATION._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable\\$default(Cancellable.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.CoroutineStart.invoke(CoroutineStart.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.AbstractCoroutine.start(AbstractCoroutine.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt__Builders_commonKt.async(Builders.common.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt.async(Unknown Source)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt__Builders_commonKt.async\\$default(Builders.common.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt.async\\$default(Unknown Source)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.CoroutinesDumpTest\\$testRunningCoroutineWithSuspensionPoint\\$1.invokeSuspend(CoroutinesDumpTest.kt)\",\n            ignoredCoroutine = \"BlockingCoroutine\"\n        ) {\n            deferred.cancel()\n            coroutineThread!!.interrupt()\n        }\n    }\n\n    @Test\n    fun testCreationStackTrace() = runBlocking {\n        val deferred = async(Dispatchers.IO) {\n            activeMethod(shouldSuspend = true)\n        }\n\n        awaitCoroutine()\n        val coroutine = DebugProbes.dumpCoroutinesInfo().first { it.job is Deferred<*> }\n        val result = coroutine.creationStackTrace.fold(StringBuilder()) { acc, element ->\n            acc.append(element.toString())\n            acc.append('\\n')\n        }.toString().trimStackTrace()\n\n        deferred.cancel()\n        coroutineThread!!.interrupt()\n\n        val expected =\n            \"kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt)\\n\" +\n            \"kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt)\\n\" +\n            \"kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable\\$default(Cancellable.kt)\\n\" +\n            \"kotlinx.coroutines.CoroutineStart.invoke(CoroutineStart.kt)\\n\" +\n            \"kotlinx.coroutines.AbstractCoroutine.start(AbstractCoroutine.kt)\\n\" +\n            \"kotlinx.coroutines.BuildersKt__Builders_commonKt.async(Builders.common.kt)\\n\" +\n            \"kotlinx.coroutines.BuildersKt.async(Unknown Source)\\n\" +\n            \"kotlinx.coroutines.BuildersKt__Builders_commonKt.async\\$default(Builders.common.kt)\\n\" +\n            \"kotlinx.coroutines.BuildersKt.async\\$default(Unknown Source)\\n\" +\n            \"kotlinx.coroutines.debug.CoroutinesDumpTest\\$testCreationStackTrace\\$1.invokeSuspend(CoroutinesDumpTest.kt)\"\n        if (!result.startsWith(expected)) {\n            error(\"\"\"\n                |Does not start with expected lines\n                |=== Actual result:\n                |$result\n                \"\"\".trimMargin()\n            )\n        }\n\n    }\n\n    @Test\n    fun testFinishedCoroutineRemoved() = runBlocking {\n        val deferred = async(Dispatchers.IO) {\n            activeMethod(shouldSuspend = true)\n        }\n\n        awaitCoroutine()\n        deferred.cancel()\n        coroutineThread!!.interrupt()\n        deferred.join()\n        verifyDump(ignoredCoroutine = \"BlockingCoroutine\")\n    }\n\n    private suspend fun activeMethod(shouldSuspend: Boolean) {\n        nestedActiveMethod(shouldSuspend)\n        assertTrue(true) // tail-call\n    }\n\n    private suspend fun nestedActiveMethod(shouldSuspend: Boolean) {\n        if (shouldSuspend) yield()\n        notifyCoroutineStarted()\n        while (coroutineContext[Job]!!.isActive) {\n            try {\n                Thread.sleep(60_000)\n            } catch (_ : InterruptedException) {\n            }\n        }\n    }\n\n    private suspend fun sleepingOuterMethod() {\n        sleepingNestedMethod()\n        yield() // TCE\n    }\n\n    private suspend fun sleepingNestedMethod() {\n        yield() // Suspension point\n        notifyCoroutineStarted()\n        delay(Long.MAX_VALUE)\n    }\n\n    private fun awaitCoroutine() = synchronized(monitor) {\n        while (coroutineThread == null) (monitor as Object).wait()\n        while (coroutineThread!!.state != Thread.State.TIMED_WAITING) {\n            // Wait until thread sleeps to have a consistent stacktrace\n        }\n    }\n\n    private fun notifyCoroutineStarted() {\n        synchronized(monitor) {\n            coroutineThread = Thread.currentThread()\n            (monitor as Object).notifyAll()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/DebugLeaksTest.kt",
        "content": "import kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.*\nimport kotlinx.coroutines.debug.internal.*\nimport org.junit.*\n\n/**\n * This is fast but fragile version of [DebugLeaksStressTest] that check reachability of a captured object\n * in [DebugProbesImpl] via [FieldWalker].\n */\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nclass DebugLeaksTest : DebugTestBase() {\n    private class Captured\n\n    @Test\n    fun testIteratorLeak() {\n        val captured = Captured()\n        iterator { yield(captured) }\n        assertNoCapturedReference()\n    }\n\n    @Test\n    fun testLazyGlobalCoroutineLeak() {\n        val captured = Captured()\n        GlobalScope.launch(start = CoroutineStart.LAZY) { println(captured) }\n        assertNoCapturedReference()\n    }\n\n    @Test\n    fun testLazyCancelledChildCoroutineLeak() = runTest {\n        val captured = Captured()\n        coroutineScope {\n            val child = launch(start = CoroutineStart.LAZY) { println(captured) }\n            child.cancel()\n        }\n        assertNoCapturedReference()\n    }\n\n    @Test\n    fun testAbandonedGlobalCoroutineLeak() {\n        val captured = Captured()\n        GlobalScope.launch {\n            suspendForever()\n            println(captured)\n        }\n        assertNoCapturedReference()\n    }\n\n    private suspend fun suspendForever() = suspendCancellableCoroutine<Unit> {  }\n\n    private fun assertNoCapturedReference() {\n        FieldWalker.assertReachableCount(0, DebugProbesImpl, rootStatics = true) { it is Captured }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/DebugProbesTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.AtomicBoolean\nimport kotlin.test.*\n\nclass DebugProbesTest : DebugTestBase() {\n\n    private fun CoroutineScope.createDeferred(): Deferred<*> = async(NonCancellable) {\n        throw ExecutionException(null)\n    }\n\n    @Test\n    fun testAsync() = runTest {\n        val deferred = createDeferred()\n        val traces = listOf(\n            \"java.util.concurrent.ExecutionException\\n\" +\n                \"\\tat kotlinx.coroutines.debug.DebugProbesTest\\$createDeferred\\$1.invokeSuspend(DebugProbesTest.kt:14)\\n\" +\n                \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.DebugProbesTest.oneMoreNestedMethod(DebugProbesTest.kt:49)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.DebugProbesTest.nestedMethod(DebugProbesTest.kt:44)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.DebugProbesTest\\$testAsync\\$1.invokeSuspend(DebugProbesTest.kt:17)\\n\",\n            \"Caused by: java.util.concurrent.ExecutionException\\n\" +\n                \"\\tat kotlinx.coroutines.debug.DebugProbesTest\\$createDeferred\\$1.invokeSuspend(DebugProbesTest.kt:14)\\n\" +\n                \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\"\n        )\n        nestedMethod(deferred, traces)\n        deferred.join()\n    }\n\n    @Test\n    fun testAsyncWithProbes() = DebugProbes.withDebugProbes {\n        DebugProbes.sanitizeStackTraces = false\n        runTest {\n            val deferred = createDeferred()\n            val traces = listOf(\n                \"java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest\\$createDeferred\\$1.invokeSuspend(DebugProbesTest.kt)\\n\" +\n                    \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest.oneMoreNestedMethod(DebugProbesTest.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest.nestedMethod(DebugProbesTest.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest\\$testAsyncWithProbes\\$1\\$1.invokeSuspend(DebugProbesTest.kt:62)\",\n                \"Caused by: java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest\\$createDeferred\\$1.invokeSuspend(DebugProbesTest.kt)\\n\" +\n                    \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt)\\n\"\n            )\n            nestedMethod(deferred, traces)\n            deferred.join()\n        }\n    }\n\n    @Test\n    fun testAsyncWithSanitizedProbes() = DebugProbes.withDebugProbes {\n        DebugProbes.sanitizeStackTraces = true\n        runTest {\n            val deferred = createDeferred()\n            val traces = listOf(\n                \"java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest\\$createDeferred\\$1.invokeSuspend(DebugProbesTest.kt:16)\\n\" +\n                    \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest.oneMoreNestedMethod(DebugProbesTest.kt:71)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest.nestedMethod(DebugProbesTest.kt:66)\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest\\$testAsyncWithSanitizedProbes\\$1\\$1.invokeSuspend(DebugProbesTest.kt:87)\",\n                \"Caused by: java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat kotlinx.coroutines.debug.DebugProbesTest\\$createDeferred\\$1.invokeSuspend(DebugProbesTest.kt:16)\\n\" +\n                    \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\\n\"\n            )\n            nestedMethod(deferred, traces)\n            deferred.join()\n        }\n    }\n\n    private suspend fun nestedMethod(deferred: Deferred<*>, traces: List<String>) {\n        oneMoreNestedMethod(deferred, traces)\n        assertTrue(true) // Prevent tail-call optimization\n    }\n\n    private suspend fun oneMoreNestedMethod(deferred: Deferred<*>, traces: List<String>) {\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: ExecutionException) {\n            verifyStackTrace(e, traces)\n        }\n    }\n\n    @Test\n    fun testMultipleConsecutiveProbeResumed() = runTest {\n        val job = launch {\n            expect(1)\n            foo()\n            expect(4)\n            delay(Long.MAX_VALUE)\n            expectUnreached()\n        }\n        yield()\n        yield()\n        expect(5)\n        val infos = DebugProbes.dumpCoroutinesInfo()\n        assertEquals(2, infos.size)\n        assertEquals(setOf(State.RUNNING, State.SUSPENDED), infos.map { it.state }.toSet())\n        job.cancel()\n        finish(6)\n    }\n\n    @Test\n    fun testMultipleConsecutiveProbeResumedAndLaterRunning() = runTest {\n        val reachedActiveStage = AtomicBoolean(false)\n        val job = launch(Dispatchers.Default) {\n            expect(1)\n            foo()\n            expect(4)\n            yield()\n            reachedActiveStage.set(true)\n            while (isActive) {\n                // Spin until test is done\n            }\n        }\n        while (!reachedActiveStage.get()) {\n            delay(10)\n        }\n        expect(5)\n        val infos = DebugProbes.dumpCoroutinesInfo()\n        assertEquals(2, infos.size)\n        assertEquals(setOf(State.RUNNING, State.RUNNING), infos.map { it.state }.toSet())\n        job.cancel()\n        finish(6)\n    }\n\n    private suspend fun foo() {\n        bar()\n        // Kill TCO\n        expect(3)\n    }\n\n\n    private suspend fun bar() {\n        yield()\n        expect(2)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/DebugTestBase.kt",
        "content": "package kotlinx.coroutines.debug\n\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.junit4.*\nimport org.junit.*\n\nopen class DebugTestBase : TestBase() {\n\n    @JvmField\n    @Rule\n    val timeout = CoroutinesTimeout.seconds(60)\n\n    @Before\n    open fun setUp() {\n        before()\n        DebugProbes.sanitizeStackTraces = false\n        DebugProbes.enableCreationStackTraces = false\n        DebugProbes.install()\n    }\n\n    @After\n    fun tearDown() {\n        try {\n            DebugProbes.uninstall()\n        } finally {\n            onCompletion()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/DumpCoroutineInfoAsJsonAndReferencesTest.kt",
        "content": "@file:Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npackage kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport com.google.gson.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\nimport org.junit.Test\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@ExperimentalStdlibApi\nclass DumpCoroutineInfoAsJsonAndReferencesTest : DebugTestBase() {\n    private data class CoroutineInfoFromJson(\n        val name: String?,\n        val id: Long?,\n        val dispatcher: String?,\n        val sequenceNumber: Long?,\n        val state: String?\n    )\n\n    @Test\n    fun testDumpOfUnnamedCoroutine() =\n        runTestWithNamedDeferred(name = null)\n\n    @Test\n    fun testDumpOfNamedCoroutine() =\n        runTestWithNamedDeferred(\"Name\")\n\n    @Test\n    fun testDumpOfNamedCoroutineWithSpecialCharacters() =\n        runTestWithNamedDeferred(\"Name with\\n \\\"special\\\" characters\\\\/\\t\\b\")\n\n    @Test\n    fun testDumpWithNoCoroutines() {\n        val dumpResult = DebugProbesImpl.dumpCoroutinesInfoAsJsonAndReferences()\n        assertEquals(dumpResult.size, 4)\n        assertIsEmptyArray(dumpResult[1])\n        assertIsEmptyArray(dumpResult[2])\n        assertIsEmptyArray(dumpResult[3])\n    }\n\n    private fun assertIsEmptyArray(obj: Any) =\n        assertTrue(obj is Array<*> && obj.isEmpty())\n\n    private fun runTestWithNamedDeferred(name: String?) = runTest {\n        val context = if (name == null) EmptyCoroutineContext else CoroutineName(name)\n        val deferred = async(context) {\n            suspendingMethod()\n            assertTrue(true)\n        }\n        yield()\n        verifyDump()\n        deferred.cancelAndJoin()\n    }\n\n    private suspend fun suspendingMethod() {\n        delay(Long.MAX_VALUE)\n    }\n\n    private fun verifyDump() {\n        val dumpResult = DebugProbesImpl.dumpCoroutinesInfoAsJsonAndReferences()\n\n        assertEquals(dumpResult.size, 4)\n\n        val coroutinesInfoAsJsonString = dumpResult[0]\n        val lastObservedThreads = dumpResult[1]\n        val lastObservedFrames = dumpResult[2]\n        val coroutinesInfo = dumpResult[3]\n\n        assertIs<String>(coroutinesInfoAsJsonString)\n        assertIs<Array<*>>(lastObservedThreads)\n        assertIs<Array<*>>(lastObservedFrames)\n        assertIs<Array<*>>(coroutinesInfo)\n\n        val coroutinesInfoFromJson =\n            Gson().fromJson(coroutinesInfoAsJsonString, Array<CoroutineInfoFromJson>::class.java)\n\n        val size = coroutinesInfo.size\n        assertTrue(size != 0)\n        assertEquals(size, coroutinesInfoFromJson.size)\n        assertEquals(size, lastObservedFrames.size)\n        assertEquals(size, lastObservedThreads.size)\n\n        for (i in 0 until size) {\n            val info = coroutinesInfo[i]\n            val infoFromJson = coroutinesInfoFromJson[i]\n            assertIs<DebugCoroutineInfo>(info)\n            assertEquals(info.lastObservedThread, lastObservedThreads[i])\n            assertEquals(info.lastObservedFrame, lastObservedFrames[i])\n            assertEquals(info.sequenceNumber, infoFromJson.sequenceNumber)\n            assertEquals(info.state, infoFromJson.state)\n            val context = info.context\n            assertEquals(context[CoroutineName.Key]?.name, infoFromJson.name)\n            assertEquals(context[CoroutineId.Key]?.id, infoFromJson.id)\n            assertEquals(context[CoroutineDispatcher.Key]?.toString(), infoFromJson.dispatcher)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/DumpWithCreationStackTraceTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass DumpWithCreationStackTraceTest : DebugTestBase() {\n    @Before\n    override fun setUp() {\n        super.setUp()\n        DebugProbes.enableCreationStackTraces = true\n    }\n\n    @Test\n    fun testCoroutinesDump() = runTest {\n        val deferred = createActiveDeferred()\n        yield()\n        verifyDump(\n            \"Coroutine \\\"coroutine#1\\\":BlockingCoroutine{Active}@70d1cb56, state: RUNNING\\n\" +\n                \"\\tat java.lang.Thread.getStackTrace(Thread.java)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.internal.DebugProbesImpl.enhanceStackTraceWithThreadDumpImpl(DebugProbesImpl.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.internal.DebugProbesImpl.dumpCoroutinesSynchronized(DebugProbesImpl.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.internal.DebugProbesImpl.dumpCoroutines(DebugProbesImpl.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.DebugProbes.dumpCoroutines(DebugProbes.kt:182)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.StacktraceUtilsKt.verifyDump(StacktraceUtils.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.StacktraceUtilsKt.verifyDump\\$default(StacktraceUtils.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.DumpWithCreationStackTraceTest\\$testCoroutinesDump\\$1.invokeSuspend(DumpWithCreationStackTraceTest.kt)\\n\" +\n                \"\\tat _COROUTINE._CREATION._(CoroutineDebugging.kt)\\n\" +\n                \"\\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt)\",\n\n            \"Coroutine \\\"coroutine#2\\\":DeferredCoroutine{Active}@383fa309, state: SUSPENDED\\n\" +\n                \"\\tat kotlinx.coroutines.debug.DumpWithCreationStackTraceTest\\$createActiveDeferred\\$1.invokeSuspend(DumpWithCreationStackTraceTest.kt)\"\n        )\n        deferred.cancelAndJoin()\n    }\n\n\n    private fun CoroutineScope.createActiveDeferred(): Deferred<*> = async {\n        suspendingMethod()\n        assertTrue(true)\n    }\n\n    private suspend fun suspendingMethod() {\n        delay(Long.MAX_VALUE)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/EnhanceStackTraceWithTreadDumpAsJsonTest.kt",
        "content": "@file:Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\npackage kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport com.google.gson.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass EnhanceStackTraceWithTreadDumpAsJsonTest : DebugTestBase() {\n    private data class StackTraceElementInfoFromJson(\n        val declaringClass: String,\n        val methodName: String,\n        val fileName: String?,\n        val lineNumber: Int\n    )\n\n    @Test\n    fun testEnhancedStackTraceFormatWithDeferred() = runTest {\n        val deferred = async {\n            suspendingMethod()\n            assertTrue(true)\n        }\n        yield()\n\n        val coroutineInfo = DebugProbesImpl.dumpCoroutinesInfo()\n        assertEquals(coroutineInfo.size, 2)\n        val info = coroutineInfo[1]\n        val enhancedStackTraceAsJsonString = DebugProbesImpl.enhanceStackTraceWithThreadDumpAsJson(info)\n        val enhancedStackTraceFromJson = Gson().fromJson(enhancedStackTraceAsJsonString, Array<StackTraceElementInfoFromJson>::class.java)\n        val enhancedStackTrace = DebugProbesImpl.enhanceStackTraceWithThreadDump(info, info.lastObservedStackTrace)\n        assertEquals(enhancedStackTrace.size, enhancedStackTraceFromJson.size)\n        for ((frame, frameFromJson) in enhancedStackTrace.zip(enhancedStackTraceFromJson)) {\n            assertEquals(frame.className, frameFromJson.declaringClass)\n            assertEquals(frame.methodName, frameFromJson.methodName)\n            assertEquals(frame.fileName, frameFromJson.fileName)\n            assertEquals(frame.lineNumber, frameFromJson.lineNumber)\n        }\n\n        deferred.cancelAndJoin()\n    }\n\n    private suspend fun suspendingMethod() {\n        delay(Long.MAX_VALUE)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/Example.kt",
        "content": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.*\n\nsuspend fun computeValue(): String = coroutineScope {\n    val one = async { computeOne() }\n    val two = async { computeTwo() }\n    combineResults(one, two)\n}\n\nsuspend fun combineResults(one: Deferred<String>, two: Deferred<String>): String =\n    one.await() + two.await()\n\nsuspend fun computeOne(): String {\n    delay(5000)\n    return \"4\"\n}\n\nsuspend fun computeTwo(): String {\n    delay(5000)\n    return \"2\"\n}\n\nfun main() = runBlocking {\n    DebugProbes.install()\n    val deferred = async { computeValue() }\n    // Delay for some time\n    delay(1000)\n    // Dump running coroutines\n    DebugProbes.dumpCoroutines()\n    println(\"\\nDumping only deferred\")\n    DebugProbes.printJob(deferred)\n}"
    },
    {
        "path": "kotlinx-coroutines-debug/test/LazyCoroutineTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass LazyCoroutineTest : DebugTestBase() {\n\n    @Test\n    fun testLazyCompletedCoroutine() = runTest {\n        val job = launch(start = CoroutineStart.LAZY) {}\n        job.invokeOnCompletion { expect(2) }\n        expect(1)\n        job.cancelAndJoin()\n        expect(3)\n        assertEquals(1, DebugProbes.dumpCoroutinesInfo().size) // Outer runBlocking\n        verifyPartialDump(1, \"BlockingCoroutine{Active}\")\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/RecoveryExample.kt",
        "content": "@file:Suppress(\"PackageDirectoryMismatch\")\npackage example\n\nimport kotlinx.coroutines.*\n\nobject PublicApiImplementation : CoroutineScope by CoroutineScope(CoroutineName(\"Example\")) {\n\n    private fun doWork(): Int {\n        error(\"Internal invariant failed\")\n    }\n\n    private fun asynchronousWork(): Int {\n        return doWork() + 1\n    }\n\n    public suspend fun awaitAsynchronousWorkInMainThread() {\n        val task = async(Dispatchers.Default) {\n            asynchronousWork()\n        }\n\n        task.await()\n    }\n}\n\nsuspend fun main() {\n    // Try to switch debug mode on and off to see the difference\n    PublicApiImplementation.awaitAsynchronousWorkInMainThread()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/RunningThreadStackMergeTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass RunningThreadStackMergeTest : DebugTestBase() {\n\n    private val testMainBlocker = CountDownLatch(1) // Test body blocks on it\n    private val coroutineBlocker = CyclicBarrier(2) // Launched coroutine blocks on it\n\n    @Test\n    fun testStackMergeWithContext() = runTest {\n        launchCoroutine()\n        awaitCoroutineStarted()\n        verifyDump(\n            \"Coroutine \\\"coroutine#2\\\":StandaloneCoroutine{Active}@50284dc4, state: RUNNING\\n\" +\n                \"\\tat jdk.internal.misc.Unsafe.park(Native Method)\\n\" +\n                \"\\tat java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\\n\" +\n                \"\\tat java.util.concurrent.locks.AbstractQueuedSynchronizer\\$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\\n\" +\n                \"\\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:234)\\n\" +\n                \"\\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest.nonSuspendingFun(RunningThreadStackMergeTest.kt:86)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest.access\\$nonSuspendingFun(RunningThreadStackMergeTest.kt:12)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest\\$suspendingFunction\\$2.invokeSuspend(RunningThreadStackMergeTest.kt:77)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest.suspendingFunction(RunningThreadStackMergeTest.kt:75)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest\\$launchCoroutine\\$1.invokeSuspend(RunningThreadStackMergeTest.kt:68)\",\n            ignoredCoroutine = \"BlockingCoroutine\"\n        ) {\n            coroutineBlocker.await()\n        }\n    }\n\n    private fun awaitCoroutineStarted() {\n        testMainBlocker.await()\n        while (coroutineBlocker.numberWaiting != 1) {\n            Thread.sleep(10)\n        }\n    }\n\n    private fun CoroutineScope.launchCoroutine() {\n        launch(Dispatchers.Default) {\n            suspendingFunction()\n            assertTrue(true)\n        }\n    }\n\n    private suspend fun suspendingFunction() {\n        // Typical use-case\n        withContext(Dispatchers.IO) {\n            yield()\n            nonSuspendingFun()\n        }\n\n        assertTrue(true)\n    }\n\n    private fun nonSuspendingFun() {\n        testMainBlocker.countDown()\n        coroutineBlocker.await()\n    }\n\n    @Test\n    fun testStackMergeEscapeSuspendMethod() = runTest {\n        launchEscapingCoroutine()\n        awaitCoroutineStarted()\n        Thread.sleep(10)\n        verifyDump(\n            \"Coroutine \\\"coroutine#2\\\":StandaloneCoroutine{Active}@3aea3c67, state: RUNNING\\n\" +\n                \"\\tat jdk.internal.misc.Unsafe.park(Native Method)\\n\" +\n                \"\\tat java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\\n\" +\n                \"\\tat java.util.concurrent.locks.AbstractQueuedSynchronizer\\$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\\n\" +\n                \"\\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:234)\\n\" +\n                \"\\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest.nonSuspendingFun(RunningThreadStackMergeTest.kt:83)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest.access\\$nonSuspendingFun(RunningThreadStackMergeTest.kt:12)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest\\$suspendingFunctionWithContext\\$2.invokeSuspend(RunningThreadStackMergeTest.kt:124)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest.suspendingFunctionWithContext(RunningThreadStackMergeTest.kt:122)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest\\$launchEscapingCoroutine\\$1.invokeSuspend(RunningThreadStackMergeTest.kt:116)\",\n            ignoredCoroutine = \"BlockingCoroutine\"\n        ) {\n            coroutineBlocker.await()\n        }\n    }\n\n    private fun CoroutineScope.launchEscapingCoroutine() {\n        launch(Dispatchers.Default) {\n            suspendingFunctionWithContext()\n            assertTrue(true)\n        }\n    }\n\n    private suspend fun suspendingFunctionWithContext() {\n        withContext(Dispatchers.IO) {\n            actualSuspensionPoint()\n            nonSuspendingFun()\n        }\n\n        assertTrue(true)\n    }\n\n    @Test\n    fun testMergeThroughInvokeSuspend() = runTest {\n        launchEscapingCoroutineWithoutContext()\n        awaitCoroutineStarted()\n        verifyDump(\n            \"Coroutine \\\"coroutine#2\\\":StandaloneCoroutine{Active}@3aea3c67, state: RUNNING\\n\" +\n                \"\\tat jdk.internal.misc.Unsafe.park(Native Method)\\n\" +\n                \"\\tat java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\\n\" +\n                \"\\tat java.util.concurrent.locks.AbstractQueuedSynchronizer\\$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\\n\" +\n                \"\\tat java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:234)\\n\" +\n                \"\\tat java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest.nonSuspendingFun(RunningThreadStackMergeTest.kt:83)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest.suspendingFunctionWithoutContext(RunningThreadStackMergeTest.kt:160)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest\\$launchEscapingCoroutineWithoutContext\\$1.invokeSuspend(RunningThreadStackMergeTest.kt:153)\",\n            ignoredCoroutine = \"BlockingCoroutine\"\n        ) {\n            coroutineBlocker.await()\n        }\n    }\n\n    private fun CoroutineScope.launchEscapingCoroutineWithoutContext() {\n        launch(Dispatchers.IO) {\n            suspendingFunctionWithoutContext()\n            assertTrue(true)\n        }\n    }\n\n    private suspend fun suspendingFunctionWithoutContext() {\n        actualSuspensionPoint()\n        nonSuspendingFun()\n        assertTrue(true)\n    }\n\n    @Test\n    fun testRunBlocking() = runBlocking {\n        verifyDump(\n            \"Coroutine \\\"coroutine#1\\\":BlockingCoroutine{Active}@4bcd176c, state: RUNNING\\n\" +\n                \"\\tat java.lang.Thread.getStackTrace(Thread.java)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.internal.DebugProbesImpl.enhanceStackTraceWithThreadDumpImpl(DebugProbesImpl.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.internal.DebugProbesImpl.dumpCoroutinesSynchronized(DebugProbesImpl.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.internal.DebugProbesImpl.dumpCoroutines(DebugProbesImpl.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.DebugProbes.dumpCoroutines(DebugProbes.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.StacktraceUtilsKt.verifyDump(StacktraceUtils.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.StacktraceUtilsKt.verifyDump\\$default(StacktraceUtils.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.RunningThreadStackMergeTest\\$testRunBlocking\\$1.invokeSuspend(RunningThreadStackMergeTest.kt)\"\n        )\n    }\n\n\n    private suspend fun actualSuspensionPoint() {\n        nestedSuspensionPoint()\n        assertTrue(true)\n    }\n\n    private suspend fun nestedSuspensionPoint() {\n        yield()\n        assertTrue(true)\n    }\n\n    @Test // IDEA-specific debugger API test\n    @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n    fun testActiveThread() = runBlocking<Unit> {\n        launchCoroutine()\n        awaitCoroutineStarted()\n        val info = DebugProbesImpl.dumpDebuggerInfo().find { it.state == \"RUNNING\" }\n        assertNotNull(info)\n        assertNotNull(info.lastObservedThreadName)\n        coroutineBlocker.await()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/SanitizedProbesTest.kt",
        "content": "@file:Suppress(\"PackageDirectoryMismatch\")\npackage definitely.not.kotlinx.coroutines\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass SanitizedProbesTest : DebugTestBase() {\n    @Before\n    override fun setUp() {\n        super.setUp()\n        DebugProbes.sanitizeStackTraces = true\n        DebugProbes.enableCreationStackTraces = true\n    }\n\n    @Test\n    fun testRecoveredStackTrace() = runTest {\n        val deferred = createDeferred()\n        val traces = listOf(\n            \"java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest\\$createDeferredNested\\$1.invokeSuspend(SanitizedProbesTest.kt:97)\\n\" +\n                    \"\\tat _COROUTINE._BOUNDARY._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.oneMoreNestedMethod(SanitizedProbesTest.kt:67)\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.nestedMethod(SanitizedProbesTest.kt:61)\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest\\$testRecoveredStackTrace\\$1.invokeSuspend(SanitizedProbesTest.kt:50)\\n\" +\n                    \"\\tat _COROUTINE._CREATION._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt:116)\\n\" +\n                    \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt:23)\\n\" +\n                    \"\\tat kotlinx.coroutines.testing.TestBase.runTest\\$default(TestBase.kt:141)\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.testRecoveredStackTrace(SanitizedProbesTest.kt:33)\",\n            \"Caused by: java.util.concurrent.ExecutionException\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest\\$createDeferredNested\\$1.invokeSuspend(SanitizedProbesTest.kt:57)\\n\" +\n                    \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\\n\"\n        )\n        nestedMethod(deferred, traces)\n        deferred.join()\n    }\n\n    @Test\n    fun testCoroutinesDump() = runTest {\n        val deferred = createActiveDeferred()\n        yield()\n        verifyDump(\n            \"Coroutine \\\"coroutine#3\\\":BlockingCoroutine{Active}@7d68ef40, state: RUNNING\\n\" +\n                \"\\tat java.lang.Thread.getStackTrace(Thread.java)\\n\" +\n                \"\\tat _COROUTINE._CREATION._(CoroutineDebugging.kt)\\n\" +\n                \"\\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt:116)\\n\" +\n                \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt:23)\\n\" +\n                \"\\tat kotlinx.coroutines.testing.TestBase.runTest\\$default(TestBase.kt:141)\\n\" +\n                \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.testCoroutinesDump(SanitizedProbesTest.kt:56)\",\n\n            \"Coroutine \\\"coroutine#4\\\":DeferredCoroutine{Active}@75c072cb, state: SUSPENDED\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest\\$createActiveDeferred\\$1.invokeSuspend(SanitizedProbesTest.kt:63)\\n\" +\n                    \"\\tat _COROUTINE._CREATION._(CoroutineDebugging.kt)\\n\" +\n                    \"\\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt:116)\\n\" +\n                    \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt:23)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt__Builders_commonKt.async\\$default(Builders.common.kt)\\n\" +\n                    \"\\tat kotlinx.coroutines.BuildersKt.async\\$default(Unknown Source)\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.createActiveDeferred(SanitizedProbesTest.kt:62)\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.access\\$createActiveDeferred(SanitizedProbesTest.kt:16)\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest\\$testCoroutinesDump\\$1.invokeSuspend(SanitizedProbesTest.kt:57)\\n\" +\n                    \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\\n\" +\n                    \"\\tat kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:237)\\n\" +\n                    \"\\tat kotlinx.coroutines.testing.TestBase.runTest\\$default(TestBase.kt:141)\\n\" +\n                    \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.testCoroutinesDump(SanitizedProbesTest.kt:56)\"\n        )\n        deferred.cancelAndJoin()\n    }\n\n    @Test\n    fun testSelectBuilder() = runTest {\n        val selector = launchSelector()\n        expect(1)\n        yield()\n        expect(3)\n        verifyDump(\"Coroutine \\\"coroutine#1\\\":BlockingCoroutine{Active}@35fc6dc4, state: RUNNING\\n\" +\n                \"\\tat java.lang.Thread.getStackTrace(Thread.java:1552)\\n\" + // Skip the rest\n                \"\\tat _COROUTINE._CREATION._(CoroutineDebugging.kt)\\n\" +\n                \"\\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt:116)\",\n\n            \"Coroutine \\\"coroutine#2\\\":StandaloneCoroutine{Active}@1b68b9a4, state: SUSPENDED\\n\" +\n                \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest\\$launchSelector\\$1\\$1\\$1.invokeSuspend(SanitizedProbesTest.kt)\\n\" +\n                \"\\tat _COROUTINE._CREATION._(CoroutineDebugging.kt)\\n\" +\n                \"\\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.createCoroutineUnintercepted(IntrinsicsJvm.kt:116)\\n\" +\n                \"\\tat kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt:25)\\n\" +\n                \"\\tat kotlinx.coroutines.BuildersKt__Builders_commonKt.launch\\$default(Builders.common.kt)\\n\" +\n                \"\\tat kotlinx.coroutines.BuildersKt.launch\\$default(Unknown Source)\\n\" +\n                \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.launchSelector(SanitizedProbesTest.kt:100)\\n\" +\n                \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.access\\$launchSelector(SanitizedProbesTest.kt:16)\\n\" +\n                \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest\\$testSelectBuilder\\$1.invokeSuspend(SanitizedProbesTest.kt:89)\\n\" +\n                \"\\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)\\n\" +\n                \"\\tat kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:233)\\n\" +\n                \"\\tat kotlinx.coroutines.testing.TestBase.runTest\\$default(TestBase.kt:154)\\n\" +\n                \"\\tat definitely.not.kotlinx.coroutines.SanitizedProbesTest.testSelectBuilder(SanitizedProbesTest.kt:88)\")\n        finish(4)\n        selector.cancelAndJoin()\n    }\n\n    private fun CoroutineScope.launchSelector(): Job {\n        val job = CompletableDeferred(Unit)\n        return launch {\n            select<Int> {\n                job.onJoin {\n                    expect(2)\n                    delay(Long.MAX_VALUE)\n                    1\n                }\n            }\n        }\n    }\n\n    private fun CoroutineScope.createActiveDeferred(): Deferred<*> = async {\n        suspendingMethod()\n        assertTrue(true)\n    }\n\n    private suspend fun suspendingMethod() {\n        delay(Long.MAX_VALUE)\n    }\n\n    private fun CoroutineScope.createDeferred(): Deferred<*> = createDeferredNested()\n\n    private fun CoroutineScope.createDeferredNested(): Deferred<*> = async(NonCancellable) {\n        throw ExecutionException(null)\n    }\n\n    private suspend fun nestedMethod(deferred: Deferred<*>, traces: List<String>) {\n        oneMoreNestedMethod(deferred, traces)\n        assertTrue(true) // Prevent tail-call optimization\n    }\n\n    private suspend fun oneMoreNestedMethod(deferred: Deferred<*>, traces: List<String>) {\n        try {\n            deferred.await()\n            expectUnreached()\n        } catch (e: ExecutionException) {\n            verifyStackTrace(e, traces)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/ScopedBuildersTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport kotlin.coroutines.*\n\nclass ScopedBuildersTest : DebugTestBase() {\n\n    @Test\n    fun testNestedScopes() = runBlocking {\n        val job = launch { doInScope() }\n        yield()\n        yield()\n        verifyDump(\n            \"Coroutine \\\"coroutine#1\\\":BlockingCoroutine{Active}@16612a51, state: RUNNING\",\n\n            \"Coroutine \\\"coroutine#2\\\":StandaloneCoroutine{Active}@6b53e23f, state: SUSPENDED\\n\" +\n                \"\\tat kotlinx.coroutines.debug.ScopedBuildersTest\\$doWithContext\\$2.invokeSuspend(ScopedBuildersTest.kt:49)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.ScopedBuildersTest.doWithContext(ScopedBuildersTest.kt:47)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.ScopedBuildersTest\\$doInScope\\$2.invokeSuspend(ScopedBuildersTest.kt:41)\\n\" +\n                \"\\tat kotlinx.coroutines.debug.ScopedBuildersTest\\$testNestedScopes\\$1\\$job\\$1.invokeSuspend(ScopedBuildersTest.kt:30)\"\n        )\n        job.cancelAndJoin()\n        finish(4)\n    }\n\n    private suspend fun doInScope() = coroutineScope {\n        expect(1)\n        doWithContext()\n        expectUnreached()\n    }\n\n    private suspend fun doWithContext() {\n        expect(2)\n        withContext(wrapperDispatcher(coroutineContext)) {\n            expect(3)\n            delay(Long.MAX_VALUE)\n        }\n        expectUnreached()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/StacktraceUtils.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport java.io.*\nimport kotlin.test.*\n\npublic fun String.trimStackTrace(): String =\n    trimIndent()\n        // Remove source line\n        .replace(Regex(\":[0-9]+\"), \"\")\n        // Remove coroutine id\n        .replace(Regex(\"#[0-9]+\"), \"\")\n        // Remove trace prefix: \"java.base@11.0.16.1/java.lang.Thread.sleep\" => \"java.lang.Thread.sleep\"\n        .replace(Regex(\"(?<=\\tat )[^\\n]*/\"), \"\")\n        .replace(Regex(\"\\t\"), \"\")\n        .replace(\"sun.misc.Unsafe.\", \"jdk.internal.misc.Unsafe.\") // JDK8->JDK11\n\npublic fun verifyStackTrace(e: Throwable, traces: List<String>) {\n    val stacktrace = toStackTrace(e)\n    val trimmedStackTrace = stacktrace.trimStackTrace()\n    traces.forEach {\n        assertTrue(\n            trimmedStackTrace.contains(it.trimStackTrace()),\n            \"\\nExpected trace element:\\n$it\\n\\nActual stacktrace:\\n$stacktrace\"\n        )\n    }\n\n    val causes = stacktrace.count(\"Caused by\")\n    assertNotEquals(0, causes)\n    assertEquals(causes, traces.map { it.count(\"Caused by\") }.sum())\n}\n\npublic fun toStackTrace(t: Throwable): String {\n    val sw = StringWriter()\n    t.printStackTrace(PrintWriter(sw))\n    return sw.toString()\n}\n\npublic fun String.count(substring: String): Int = split(substring).size - 1\n\npublic fun verifyDump(vararg traces: String, ignoredCoroutine: String? = null, finally: () -> Unit) {\n    try {\n        verifyDump(*traces, ignoredCoroutine = ignoredCoroutine)\n    } finally {\n        finally()\n    }\n}\n\n/** Clean the stacktraces from artifacts of BlockHound instrumentation\n *\n * BlockHound works by switching a native call by a class generated with ByteBuddy, which, if the blocking\n * call is allowed in this context, in turn calls the real native call that is now available under a\n * different name.\n *\n * The traces thus undergo the following two changes when the execution is instrumented:\n *   - The original native call is replaced with a non-native one with the same FQN, and\n *   - An additional native call is placed on top of the stack, with the original name that also has\n *     `$$BlockHound$$_` prepended at the last component.\n */\nprivate fun cleanBlockHoundTraces(frames: List<String>): List<String> {\n    val result = mutableListOf<String>()\n    val blockHoundSubstr = \"\\$\\$BlockHound\\$\\$_\"\n    var i = 0\n    while (i < frames.size) {\n        result.add(frames[i].replace(blockHoundSubstr, \"\"))\n        if (frames[i].contains(blockHoundSubstr)) {\n            i += 1\n        }\n        i += 1\n    }\n    return result\n}\n\n/**\n * Removes all frames that contain \"java.util.concurrent\" in it.\n *\n * We do leverage Java's locks for proper rendezvous and to fix the coroutine stack's state,\n * but this API doesn't have (nor expected to) stable stacktrace, so we are filtering all such\n * frames out.\n *\n * See https://github.com/Kotlin/kotlinx.coroutines/issues/3700 for the example of failure\n */\nprivate fun removeJavaUtilConcurrentTraces(frames: List<String>): List<String> =\n    frames.filter { !it.contains(\"java.util.concurrent\") }\n\nprivate data class CoroutineDump(\n    val header: CoroutineDumpHeader,\n    val coroutineStackTrace: List<String>,\n    val threadStackTrace: List<String>,\n    val originDump: String,\n    val originHeader: String,\n) {\n    companion object {\n        private val COROUTINE_CREATION_FRAME_REGEX =\n            \"at _COROUTINE\\\\._CREATION\\\\._\\\\(.*\\\\)\".toRegex()\n\n        fun parse(dump: String, traceCleaner: ((List<String>) -> List<String>)? = null): CoroutineDump {\n            val lines = dump\n                .trimStackTrace()\n                .split(\"\\n\")\n            val header = CoroutineDumpHeader.parse(lines[0])\n            val traceLines = lines.slice(1 until lines.size)\n            val cleanedTraceLines = if (traceCleaner != null) {\n                traceCleaner(traceLines)\n            } else {\n                traceLines\n            }\n            val coroutineStackTrace = mutableListOf<String>()\n            val threadStackTrace = mutableListOf<String>()\n            var trace = coroutineStackTrace\n            for (line in cleanedTraceLines) {\n                if (line.isEmpty()) {\n                    continue\n                }\n                if (line.matches(COROUTINE_CREATION_FRAME_REGEX)) {\n                    require(trace !== threadStackTrace) {\n                        \"Found more than one coroutine creation frame\"\n                    }\n                    trace = threadStackTrace\n                    continue\n                }\n                trace.add(line)\n            }\n            return CoroutineDump(header, coroutineStackTrace, threadStackTrace, dump, lines[0])\n        }\n    }\n\n    fun verify(expected: CoroutineDump) {\n        assertEquals(\n            expected.header, header,\n            \"Coroutine stacktrace headers are not matched:\\n\\t- ${expected.originHeader}\\n\\t+ ${originHeader}\\n\"\n        )\n        verifyStackTrace(\"coroutine stack\", coroutineStackTrace, expected.coroutineStackTrace)\n        verifyStackTrace(\"thread stack\", threadStackTrace, expected.threadStackTrace)\n    }\n\n    private fun verifyStackTrace(traceName: String, actualStackTrace: List<String>, expectedStackTrace: List<String>) {\n        // It is possible there are more stack frames in a dump than we check\n        for ((ix, expectedLine) in expectedStackTrace.withIndex()) {\n            val actualLine = actualStackTrace[ix]\n            assertEquals(\n                expectedLine, actualLine,\n                \"Following lines from $traceName are not matched:\\n\\t- ${expectedLine}\\n\\t+ ${actualLine}\\nActual dump:\\n$originDump\\n\\n\"\n            )\n        }\n    }\n}\n\nprivate data class CoroutineDumpHeader(\n    val name: String?,\n    val className: String,\n    val state: String,\n) {\n    companion object {\n        /**\n         * Parses following strings:\n         *\n         * - Coroutine \"coroutine#10\":DeferredCoroutine{Active}@66d87651, state: RUNNING\n         * - Coroutine DeferredCoroutine{Active}@66d87651, state: RUNNING\n         *\n         * into:\n         *\n         * - `CoroutineDumpHeader(name = \"coroutine\", className = \"DeferredCoroutine\", state = \"RUNNING\")`\n         * - `CoroutineDumpHeader(name = null, className = \"DeferredCoroutine\", state = \"RUNNING\")`\n         */\n        fun parse(header: String): CoroutineDumpHeader {\n            val (identFull, stateFull) = header.split(\", \", limit = 2)\n            val nameAndClassName = identFull.removePrefix(\"Coroutine \").split('@', limit = 2)[0]\n            val (name, className) = nameAndClassName.split(':', limit = 2).let { parts ->\n                val (quotedName, classNameWithState) = if (parts.size == 1) {\n                    null to parts[0]\n                } else {\n                    parts[0] to parts[1]\n                }\n                val name = quotedName?.removeSurrounding(\"\\\"\")?.split('#', limit = 2)?.get(0)\n                val className = classNameWithState.replace(\"\\\\{.*\\\\}\".toRegex(), \"\")\n                name to className\n            }\n            val state = stateFull.removePrefix(\"state: \")\n            return CoroutineDumpHeader(name, className, state)\n        }\n    }\n}\n\npublic fun verifyDump(vararg expectedTraces: String, ignoredCoroutine: String? = null) {\n    val baos = ByteArrayOutputStream()\n    DebugProbes.dumpCoroutines(PrintStream(baos))\n    val wholeDump = baos.toString()\n    val traces = wholeDump.split(\"\\n\\n\")\n    assertTrue(traces[0].startsWith(\"Coroutines dump\"))\n\n    val dumps = traces\n        // Drop \"Coroutine dump\" line\n        .drop(1)\n        // Parse dumps and filter out ignored coroutines\n        .mapNotNull { trace ->\n            val dump = CoroutineDump.parse(trace, {\n                removeJavaUtilConcurrentTraces(cleanBlockHoundTraces(it))\n            })\n            if (dump.header.className == ignoredCoroutine) {\n                null\n            } else {\n                dump\n            }\n        }\n\n    assertEquals(expectedTraces.size, dumps.size)\n    dumps.zip(expectedTraces.map { CoroutineDump.parse(it, ::removeJavaUtilConcurrentTraces) })\n        .forEach { (dump, expectedDump) ->\n            dump.verify(expectedDump)\n        }\n}\n\npublic fun String.trimPackage() = replace(\"kotlinx.coroutines.debug.\", \"\")\n\npublic fun verifyPartialDump(createdCoroutinesCount: Int, vararg frames: String) {\n    val baos = ByteArrayOutputStream()\n    DebugProbes.dumpCoroutines(PrintStream(baos))\n    val dump = baos.toString()\n    val trace = dump.split(\"\\n\\n\")\n    val matches = frames.all { frame ->\n        trace.any { tr -> tr.contains(frame) }\n    }\n\n    assertEquals(createdCoroutinesCount, DebugProbes.dumpCoroutinesInfo().size)\n    assertTrue(matches)\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/StandardBuildersDebugTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass StandardBuildersDebugTest : DebugTestBase() {\n\n    @Test\n    fun testBuildersAreMissingFromDumpByDefault() = runTest {\n        val (b1, b2) = createBuilders()\n\n        val coroutines = DebugProbes.dumpCoroutinesInfo()\n        assertEquals(1, coroutines.size)\n        assertTrue { b1.hasNext() && b2.hasNext() } // Don't let GC collect our coroutines until the test is complete\n    }\n\n    @Test\n    fun testBuildersCanBeEnabled() = runTest {\n        try {\n            DebugProbes.ignoreCoroutinesWithEmptyContext = false\n            val (b1, b2) = createBuilders()\n            val coroutines = DebugProbes.dumpCoroutinesInfo()\n            assertEquals(3, coroutines.size)\n            assertTrue { b1.hasNext() && b2.hasNext() } // Don't let GC collect our coroutines until the test is complete\n        } finally {\n            DebugProbes.ignoreCoroutinesWithEmptyContext = true\n        }\n    }\n\n    private fun createBuilders(): Pair<Iterator<Int>, Iterator<Int>> {\n        val fromSequence = sequence {\n            while (true) {\n                yield(1)\n            }\n        }.iterator()\n\n        val fromIterator = iterator {\n            while (true) {\n                yield(1)\n            }\n        }\n        // Start coroutines\n        fromIterator.hasNext()\n        fromSequence.hasNext()\n        return fromSequence to fromIterator\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/StartModeProbesTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass StartModeProbesTest : DebugTestBase() {\n\n    @Test\n    fun testUndispatched() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            undispatchedSleeping()\n            assertTrue(true)\n        }\n\n        yield()\n        expect(3)\n        verifyPartialDump(2, \"StartModeProbesTest.undispatchedSleeping\")\n        job.cancelAndJoin()\n        verifyPartialDump(1, \"StartModeProbesTest\\$testUndispatched\")\n        finish(4)\n    }\n\n    private suspend fun undispatchedSleeping() {\n        delay(Long.MAX_VALUE)\n        assertTrue(true)\n    }\n\n    @Test\n    fun testWithTimeoutWithUndispatched() = runTest {\n        expect(1)\n        val job = launchUndispatched()\n\n        yield()\n        expect(3)\n        verifyPartialDump(\n            2,\n            \"StartModeProbesTest\\$launchUndispatched\\$1.invokeSuspend\",\n            \"StartModeProbesTest.withTimeoutHelper\",\n            \"StartModeProbesTest\\$withTimeoutHelper\\$2.invokeSuspend\"\n        )\n        job.cancelAndJoin()\n        verifyPartialDump(1, \"StartModeProbesTest\\$testWithTimeoutWithUndispatched\")\n        finish(4)\n    }\n\n    private fun CoroutineScope.launchUndispatched(): Job {\n        return launch(start = CoroutineStart.UNDISPATCHED) {\n            withTimeoutHelper()\n            assertTrue(true)\n        }\n    }\n\n    private suspend fun withTimeoutHelper() {\n        withTimeout(Long.MAX_VALUE) {\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n\n        assertTrue(true)\n    }\n\n    @Test\n    fun testWithTimeout() = runTest {\n        withTimeout(Long.MAX_VALUE) {\n            testActiveDump(\n                false,\n                \"StartModeProbesTest\\$testWithTimeout\\$1.invokeSuspend\",\n                \"state: RUNNING\"\n            )\n        }\n    }\n\n    @Test\n    fun testWithTimeoutAfterYield() = runTest {\n        withTimeout(Long.MAX_VALUE) {\n            testActiveDump(\n                true,\n                \"StartModeProbesTest\\$testWithTimeoutAfterYield\\$1.invokeSuspend\",\n                \"StartModeProbesTest\\$testWithTimeoutAfterYield\\$1\\$1.invokeSuspend\",\n                \"StartModeProbesTest.testActiveDump\",\n                \"state: RUNNING\"\n            )\n        }\n    }\n\n    private suspend fun testActiveDump(shouldYield: Boolean, vararg expectedFrames: String) {\n        if (shouldYield) yield()\n        verifyPartialDump(1, *expectedFrames)\n        assertTrue(true)\n    }\n\n    @Test\n    fun testWithTailCall() = runTest {\n        expect(1)\n        val job = tailCallMethod()\n        yield()\n        expect(3)\n        verifyPartialDump(2, \"StartModeProbesTest\\$launchFromTailCall\\$2\")\n        job.cancelAndJoin()\n        verifyPartialDump(1, \"StartModeProbesTest\\$testWithTailCall\")\n        finish(4)\n    }\n\n    private suspend fun CoroutineScope.tailCallMethod(): Job = launchFromTailCall()\n    private suspend fun CoroutineScope.launchFromTailCall(): Job = launch {\n        expect(2)\n        delay(Long.MAX_VALUE)\n    }\n\n    @Test\n    fun testCoroutineScope() = runTest {\n        expect(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            runScope()\n        }\n\n        yield()\n        expect(3)\n        verifyPartialDump(\n            2,\n            \"StartModeProbesTest\\$runScope\\$2.invokeSuspend\",\n            \"StartModeProbesTest\\$testCoroutineScope\\$1\\$job\\$1.invokeSuspend\")\n        job.cancelAndJoin()\n        finish(4)\n    }\n\n    private suspend fun runScope() {\n        coroutineScope {\n            expect(2)\n            delay(Long.MAX_VALUE)\n        }\n    }\n\n    @Test\n    fun testLazy() = runTest({ it is CancellationException }) {\n        launch(start = CoroutineStart.LAZY) {  }\n        actor<Int>(start = CoroutineStart.LAZY) {  }\n        broadcast<Int>(start = CoroutineStart.LAZY) {  }\n        async(start = CoroutineStart.LAZY) { 1 }\n        verifyPartialDump(5, \"BlockingCoroutine\",\n            \"LazyStandaloneCoroutine\", \"LazyActorCoroutine\",\n            \"LazyBroadcastCoroutine\", \"LazyDeferredCoroutine\")\n        cancel()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/TestRuleExample.kt",
        "content": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.junit4.*\nimport org.junit.*\n\n@Ignore // do not run it on CI\nclass TestRuleExample {\n\n    @JvmField\n    @Rule\n    public val timeout = CoroutinesTimeout.seconds(1)\n\n    private suspend fun someFunctionDeepInTheStack() {\n        withContext(Dispatchers.IO) {\n            delay(Long.MAX_VALUE)\n            println(\"This line is never executed\")\n        }\n\n        println(\"This line is never executed as well\")\n    }\n\n    @Test\n    fun hangingTest() = runBlocking {\n        val job = launch {\n            someFunctionDeepInTheStack()\n        }\n\n        println(\"Doing some work...\")\n        job.join()\n    }\n\n    @Test\n    fun successfulTest() = runBlocking {\n        launch {\n            delay(10)\n        }.join()\n    }\n\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/ToStringTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.junit.*\nimport org.junit.Test\nimport java.io.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass ToStringTest : TestBase() {\n\n    @Before\n    fun setUp() {\n        before()\n        DebugProbes.sanitizeStackTraces = false\n        DebugProbes.install()\n    }\n\n    @After\n    fun tearDown() {\n        try {\n            DebugProbes.uninstall()\n        } finally {\n            onCompletion()\n        }\n    }\n\n\n    private suspend fun CoroutineScope.launchNestedScopes(): Job {\n        return launch {\n            expect(1)\n            coroutineScope {\n                expect(2)\n                launchDelayed()\n\n                supervisorScope {\n                    expect(3)\n                    launchDelayed()\n                }\n            }\n        }\n    }\n\n    private fun CoroutineScope.launchDelayed(): Job {\n        return launch {\n            delay(Long.MAX_VALUE)\n        }\n    }\n\n    @Test\n    fun testPrintHierarchyWithScopes() = runBlocking {\n        val tab = '\\t'\n        val expectedString = \"\"\"\n          \"coroutine\":StandaloneCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchNestedScopes$2$1.invokeSuspend(ToStringTest.kt)\n          $tab\"coroutine\":StandaloneCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchDelayed$1.invokeSuspend(ToStringTest.kt)\n          $tab\"coroutine\":StandaloneCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchDelayed$1.invokeSuspend(ToStringTest.kt)\n            \"\"\".trimIndent()\n\n        val job = launchNestedScopes()\n        try {\n            repeat(5) { yield() }\n            val expected = expectedString.trimStackTrace().trimPackage()\n            expect(4)\n            assertEquals(expected, DebugProbes.jobToString(job).trimEnd().trimStackTrace().trimPackage())\n            assertEquals(expected, DebugProbes.scopeToString(CoroutineScope(job)).trimEnd().trimStackTrace().trimPackage())\n        } finally {\n            finish(5)\n            job.cancelAndJoin()\n        }\n    }\n\n    @Test\n    fun testCompletingHierarchy() = runBlocking {\n        val tab = '\\t'\n        val expectedString = \"\"\"\n            \"coroutine#2\":StandaloneCoroutine{Completing}\n            $tab\"foo#3\":DeferredCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchHierarchy${'$'}1${'$'}1.invokeSuspend(ToStringTest.kt:30)\n            $tab\"coroutine#4\":ActorCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchHierarchy${'$'}1${'$'}2${'$'}1.invokeSuspend(ToStringTest.kt:40)\n            $tab$tab\"coroutine#5\":StandaloneCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchHierarchy${'$'}1${'$'}2${'$'}job$1.invokeSuspend(ToStringTest.kt:37)\n            \"\"\".trimIndent()\n\n        checkHierarchy(isCompleting = true, expectedString = expectedString)\n    }\n\n    @Test\n    fun testActiveHierarchy() = runBlocking {\n        val tab = '\\t'\n        val expectedString = \"\"\"\n            \"coroutine#2\":StandaloneCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchHierarchy${'$'}1.invokeSuspend(ToStringTest.kt:94)\n            $tab\"foo#3\":DeferredCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchHierarchy${'$'}1${'$'}1.invokeSuspend(ToStringTest.kt:30)\n            $tab\"coroutine#4\":ActorCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchHierarchy${'$'}1${'$'}2${'$'}1.invokeSuspend(ToStringTest.kt:40)\n            $tab$tab\"coroutine#5\":StandaloneCoroutine{Active}, continuation is SUSPENDED at line ToStringTest${'$'}launchHierarchy${'$'}1${'$'}2${'$'}job$1.invokeSuspend(ToStringTest.kt:37)\n            \"\"\".trimIndent()\n        checkHierarchy(isCompleting = false, expectedString = expectedString)\n    }\n\n    private suspend fun CoroutineScope.checkHierarchy(isCompleting: Boolean, expectedString: String) {\n        val root = launchHierarchy(isCompleting)\n        repeat(4) { yield() }\n        val expected = expectedString.trimStackTrace().trimPackage()\n        expect(6)\n        assertEquals(expected, DebugProbes.jobToString(root).trimEnd().trimStackTrace().trimPackage())\n        assertEquals(expected, DebugProbes.scopeToString(CoroutineScope(root)).trimEnd().trimStackTrace().trimPackage())\n        assertEquals(expected, printToString { DebugProbes.printScope(CoroutineScope(root), it) }.trimEnd().trimStackTrace().trimPackage())\n        assertEquals(expected, printToString { DebugProbes.printJob(root, it) }.trimEnd().trimStackTrace().trimPackage())\n\n        root.cancelAndJoin()\n        finish(7)\n    }\n\n    private fun CoroutineScope.launchHierarchy(isCompleting: Boolean): Job {\n        return launch {\n            expect(1)\n            async(CoroutineName(\"foo\")) {\n                expect(2)\n                delay(Long.MAX_VALUE)\n            }\n\n            actor<Int> {\n                expect(3)\n                val job = launch {\n                    expect(4)\n                    delay(Long.MAX_VALUE)\n                }\n\n                withContext(wrapperDispatcher(coroutineContext)) {\n                    expect(5)\n                    job.join()\n                }\n            }\n\n            if (!isCompleting) {\n                delay(Long.MAX_VALUE)\n            }\n        }\n    }\n\n    private fun wrapperDispatcher(context: CoroutineContext): CoroutineContext {\n        val dispatcher = context[ContinuationInterceptor] as CoroutineDispatcher\n        return object : CoroutineDispatcher() {\n            override fun dispatch(context: CoroutineContext, block: Runnable) {\n                dispatcher.dispatch(context, block)\n            }\n        }\n    }\n\n    private inline fun printToString(block: (PrintStream) -> Unit): String {\n        val baos = ByteArrayOutputStream()\n        val ps = PrintStream(baos)\n        block(ps)\n        ps.close()\n        return baos.toString()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/WithContextUndispatchedTest.kt",
        "content": "package kotlinx.coroutines.debug\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.*\n\n// Test four our internal optimization \"withContextUndispatched\"\nclass WithContextUndispatchedTest : DebugTestBase() {\n\n    @Test\n    fun testZip() = runTest {\n        val f1 = flowOf(\"a\")\n        val f2 = flow {\n            nestedEmit()\n            yield()\n        }\n        f1.zip(f2) { i, j -> i + j }.collect {\n            bar(false)\n        }\n    }\n\n    private suspend fun FlowCollector<Int>.nestedEmit() {\n        emit(1)\n        emit(2)\n    }\n\n    @Test\n    fun testUndispatchedFlowOn() = runTest {\n        val flow = flowOf(1, 2, 3).flowOn(CoroutineName(\"...\"))\n        flow.collect {\n            bar(true)\n        }\n    }\n\n    @Test\n    fun testUndispatchedFlowOnWithNestedCaller() = runTest {\n        val flow = flow {\n            nestedEmit()\n        }.flowOn(CoroutineName(\"...\"))\n        flow.collect {\n            bar(true)\n        }\n    }\n\n    private suspend fun bar(forFlowOn: Boolean) {\n        yield()\n        if (forFlowOn) {\n            verifyFlowOn()\n        } else {\n            verifyZip()\n        }\n        yield()\n    }\n\n    private suspend fun verifyFlowOn() {\n        yield() // suspend\n        verifyPartialDump(1, \"verifyFlowOn\", \"bar\")\n    }\n\n    private suspend fun verifyZip() {\n        yield() // suspend\n        verifyPartialDump(2, \"verifyZip\", \"bar\", \"nestedEmit\")\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit4/CoroutinesTimeoutDisabledTracesTest.kt",
        "content": "package kotlinx.coroutines.debug.junit4\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.runners.model.*\n\nclass CoroutinesTimeoutDisabledTracesTest : TestBase(disableOutCheck = true) {\n\n    @Rule\n    @JvmField\n    public val validation = TestFailureValidation(\n        500, true, false,\n        TestResultSpec(\n            \"hangingTest\", expectedOutParts = listOf(\n                \"Coroutines dump\",\n                \"Test hangingTest timed out after 500 milliseconds\",\n                \"BlockingCoroutine{Active}\",\n                \"at kotlinx.coroutines.debug.junit4.CoroutinesTimeoutDisabledTracesTest.hangForever\",\n                \"at kotlinx.coroutines.debug.junit4.CoroutinesTimeoutDisabledTracesTest.waitForHangJob\"\n            ),\n            notExpectedOutParts = listOf(\"_COROUTINE._CREATION._\"),\n            error = TestTimedOutException::class.java\n        )\n    )\n\n    private val job = GlobalScope.launch(Dispatchers.Unconfined) { hangForever() }\n\n    private suspend fun hangForever() {\n        suspendCancellableCoroutine<Unit> {  }\n        expectUnreached()\n    }\n\n    @Test\n    fun hangingTest() = runBlocking<Unit> {\n        waitForHangJob()\n        expectUnreached()\n    }\n\n    private suspend fun waitForHangJob() {\n        job.join()\n        expectUnreached()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit4/CoroutinesTimeoutEagerTest.kt",
        "content": "package kotlinx.coroutines.debug.junit4\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.runners.model.*\n\nclass CoroutinesTimeoutEagerTest : TestBase(disableOutCheck = true) {\n\n    @Rule\n    @JvmField\n    public val validation = TestFailureValidation(\n        500, true, true,\n        TestResultSpec(\n            \"hangingTest\", expectedOutParts = listOf(\n                \"Coroutines dump\",\n                \"Test hangingTest timed out after 500 milliseconds\",\n                \"BlockingCoroutine{Active}\",\n                \"runBlocking\",\n                \"at kotlinx.coroutines.debug.junit4.CoroutinesTimeoutEagerTest.hangForever\",\n                \"at kotlinx.coroutines.debug.junit4.CoroutinesTimeoutEagerTest.waitForHangJob\"),\n            error = TestTimedOutException::class.java)\n    )\n\n    private val job = GlobalScope.launch(Dispatchers.Unconfined) { hangForever() }\n\n    private suspend fun hangForever() {\n        suspendCancellableCoroutine<Unit> {  }\n        expectUnreached()\n    }\n\n    @Test\n    fun hangingTest() = runBlocking<Unit> {\n        waitForHangJob()\n        expectUnreached()\n    }\n\n    private suspend fun waitForHangJob() {\n        job.join()\n        expectUnreached()\n    }\n\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit4/CoroutinesTimeoutTest.kt",
        "content": "package kotlinx.coroutines.debug.junit4\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.runners.model.*\n\nclass CoroutinesTimeoutTest : TestBase(disableOutCheck = true) {\n\n    @Rule\n    @JvmField\n    public val validation = TestFailureValidation(\n        1000, false, true,\n        TestResultSpec(\"throwingTest\", error = RuntimeException::class.java),\n        TestResultSpec(\"successfulTest\"),\n        TestResultSpec(\n            \"hangingTest\", expectedOutParts = listOf(\n                \"Coroutines dump\",\n                \"Test hangingTest timed out after 1 seconds\",\n                \"BlockingCoroutine{Active}\",\n                \"runBlocking\",\n                \"at kotlinx.coroutines.debug.junit4.CoroutinesTimeoutTest.suspendForever\",\n                \"at kotlinx.coroutines.debug.junit4.CoroutinesTimeoutTest\\$hangingTest\\$1.invokeSuspend\"),\n            notExpectedOutParts = listOf(\"delay\", \"throwingTest\"),\n            error = TestTimedOutException::class.java)\n    )\n\n    @Test\n    fun hangingTest() = runBlocking<Unit> {\n        suspendForever()\n        expectUnreached()\n    }\n\n    private suspend fun suspendForever() {\n        delay(Long.MAX_VALUE)\n        expectUnreached()\n    }\n\n    @Test\n    fun throwingTest() = runBlocking<Unit> {\n        throw RuntimeException()\n    }\n\n    @Test\n    fun successfulTest() = runBlocking {\n        val job = launch {\n            yield()\n        }\n\n        job.join()\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit4/TestFailureValidation.kt",
        "content": "package kotlinx.coroutines.debug.junit4\n\nimport kotlinx.coroutines.debug.*\nimport org.junit.rules.*\nimport org.junit.runner.*\nimport org.junit.runners.model.*\nimport java.io.*\nimport kotlin.test.*\n\ninternal fun TestFailureValidation(\n    timeoutMs: Long,\n    cancelOnTimeout: Boolean,\n    creationStackTraces: Boolean,\n    vararg specs: TestResultSpec\n): RuleChain =\n    RuleChain\n        .outerRule(TestFailureValidation(specs.associateBy { it.testName }))\n        .around(\n            CoroutinesTimeout(\n                timeoutMs,\n                cancelOnTimeout,\n                creationStackTraces\n            )\n        )\n\n/**\n * Rule that captures test result, serr and sout and validates it against provided [testsSpec]\n */\ninternal class TestFailureValidation(private val testsSpec: Map<String, TestResultSpec>) : TestRule {\n\n    companion object {\n        init {\n            DebugProbes.sanitizeStackTraces = false\n        }\n    }\n    override fun apply(base: Statement, description: Description): Statement {\n        return TestFailureStatement(base, description)\n    }\n\n    inner class TestFailureStatement(private val test: Statement, private val description: Description) : Statement() {\n        private lateinit var sout: PrintStream\n        private lateinit var serr: PrintStream\n        private val capturedOut = ByteArrayOutputStream()\n\n        override fun evaluate() {\n            try {\n                replaceOut()\n                test.evaluate()\n            } catch (e: Throwable) {\n                validateFailure(e)\n                return\n            } finally {\n                resetOut()\n            }\n\n            validateSuccess() // To avoid falling into catch\n        }\n\n        private fun validateSuccess() {\n            val spec = testsSpec[description.methodName] ?: error(\"Test spec not found: ${description.methodName}\")\n            require(spec.error == null) { \"Expected exception of type ${spec.error}, but test successfully passed\" }\n\n            val captured = capturedOut.toString()\n            assertFalse(captured.contains(\"Coroutines dump\"))\n            assertTrue(captured.isEmpty(), captured)\n        }\n\n        private fun validateFailure(e: Throwable) {\n            val spec = testsSpec[description.methodName] ?: error(\"Test spec not found: ${description.methodName}\")\n            if (spec.error == null || !spec.error.isInstance(e)) {\n                throw IllegalStateException(\"Unexpected failure, expected ${spec.error}, had ${e::class}\", e)\n            }\n\n            if (e !is TestTimedOutException) return\n\n            val captured = capturedOut.toString()\n            assertTrue(captured.contains(\"Coroutines dump\"))\n            for (part in spec.expectedOutParts) {\n                assertTrue(captured.contains(part), \"Expected $part to be part of the\\n$captured\")\n            }\n\n            for (part in spec.notExpectedOutParts) {\n                assertFalse(captured.contains(part), \"Expected $part not to be part of the\\n$captured\")\n            }\n        }\n\n        private fun replaceOut() {\n            sout = System.out\n            serr = System.err\n\n            System.setOut(PrintStream(capturedOut))\n            System.setErr(PrintStream(capturedOut))\n        }\n\n        private fun resetOut() {\n            System.setOut(sout)\n            System.setErr(serr)\n        }\n    }\n}\n\ndata class TestResultSpec(\n    val testName: String, val expectedOutParts: List<String> = listOf(),\n    val notExpectedOutParts: List<String> = listOf(), val error: Class<out Throwable>? = null\n)\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit5/CoroutinesTimeoutExtensionTest.kt",
        "content": "package kotlinx.coroutines.debug.junit5\n\nimport kotlinx.coroutines.*\nimport org.junit.jupiter.api.Test\nimport org.junit.jupiter.api.extension.*\nimport org.junit.jupiter.api.parallel.*\n\nclass CoroutinesTimeoutExtensionTest {\n\n    /**\n     * Tests that disabling coroutine creation stacktraces in [CoroutinesTimeoutExtension] does lead to them not being\n     * created.\n     *\n     * Adapted from [CoroutinesTimeoutDisabledTracesTest], an identical test for the JUnit4 rule.\n     *\n     * This test class is not intended to be run manually. Instead, use [CoroutinesTimeoutTest] as the entry point.\n     */\n    class DisabledStackTracesTest {\n        @JvmField\n        @RegisterExtension\n        internal val timeout = CoroutinesTimeoutExtension(500, true, false)\n\n        private val job = GlobalScope.launch(Dispatchers.Unconfined) { hangForever() }\n\n        private suspend fun hangForever() {\n            suspendCancellableCoroutine<Unit> {  }\n            expectUnreached()\n        }\n\n        @Test\n        fun hangingTest() = runBlocking<Unit> {\n            waitForHangJob()\n            expectUnreached()\n        }\n\n        private suspend fun waitForHangJob() {\n            job.join()\n            expectUnreached()\n        }\n    }\n\n    /**\n     * Tests that [CoroutinesTimeoutExtension] is installed eagerly and detects the coroutines that were launched before\n     * any test events start happening.\n     *\n     * Adapted from [CoroutinesTimeoutEagerTest], an identical test for the JUnit4 rule.\n     *\n     * This test class is not intended to be run manually. Instead, use [CoroutinesTimeoutTest] as the entry point.\n     */\n    class EagerTest {\n\n        @JvmField\n        @RegisterExtension\n        internal val timeout = CoroutinesTimeoutExtension(500)\n\n        private val job = GlobalScope.launch(Dispatchers.Unconfined) { hangForever() }\n\n        private suspend fun hangForever() {\n            suspendCancellableCoroutine<Unit> {  }\n            expectUnreached()\n        }\n\n        @Test\n        fun hangingTest() = runBlocking<Unit> {\n            waitForHangJob()\n            expectUnreached()\n        }\n\n        private suspend fun waitForHangJob() {\n            job.join()\n            expectUnreached()\n        }\n    }\n\n    /**\n     * Tests that [CoroutinesTimeoutExtension] performs sensibly in some simple scenarios.\n     *\n     * Adapted from [CoroutinesTimeoutTest], an identical test for the JUnit4 rule.\n     *\n     * This test class is not intended to be run manually. Instead, use [CoroutinesTimeoutTest] as the entry point.\n     */\n    class SimpleTest {\n\n        @JvmField\n        @RegisterExtension\n        internal val timeout = CoroutinesTimeoutExtension(1000, false, true)\n\n        @Test\n        fun hangingTest() = runBlocking<Unit> {\n            suspendForever()\n            expectUnreached()\n        }\n\n        private suspend fun suspendForever() {\n            delay(Long.MAX_VALUE)\n            expectUnreached()\n        }\n\n        @Test\n        fun throwingTest() = runBlocking<Unit> {\n            throw RuntimeException()\n        }\n\n        @Test\n        fun successfulTest() = runBlocking {\n            val job = launch {\n                yield()\n            }\n\n            job.join()\n        }\n    }\n}\n\nprivate fun expectUnreached(): Nothing {\n    error(\"Should not be reached\")\n}"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit5/CoroutinesTimeoutInheritanceTest.kt",
        "content": "package kotlinx.coroutines.debug.junit5\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.jupiter.api.*\n\n/**\n * Tests that [CoroutinesTimeout] is inherited.\n *\n * This test class is not intended to be run manually. Instead, use [CoroutinesTimeoutTest] as the entry point.\n */\nclass CoroutinesTimeoutInheritanceTest {\n\n    @CoroutinesTimeout(100)\n    open class Base\n\n    @TestMethodOrder(MethodOrderer.OrderAnnotation::class)\n    class InheritedWithNoTimeout: Base() {\n\n        @Test\n        @Order(1)\n        fun usesBaseClassTimeout() = runBlocking {\n            delay(1000)\n        }\n\n        @CoroutinesTimeout(300)\n        @Test\n        @Order(2)\n        fun methodOverridesBaseClassTimeoutWithGreaterTimeout() = runBlocking {\n            delay(200)\n        }\n\n        @CoroutinesTimeout(10)\n        @Test\n        @Order(3)\n        fun methodOverridesBaseClassTimeoutWithLesserTimeout() = runBlocking {\n            delay(50)\n        }\n\n    }\n\n    @CoroutinesTimeout(300)\n    class InheritedWithGreaterTimeout : TestBase() {\n\n        @Test\n        fun classOverridesBaseClassTimeout1() = runBlocking {\n            delay(200)\n        }\n\n        @Test\n        fun classOverridesBaseClassTimeout2() = runBlocking {\n            delay(400)\n        }\n\n    }\n\n}"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit5/CoroutinesTimeoutMethodTest.kt",
        "content": "package kotlinx.coroutines.debug.junit5\n\nimport kotlinx.coroutines.*\nimport org.junit.jupiter.api.*\n\n/**\n * Tests usage of [CoroutinesTimeout] on classes and test methods when only methods are annotated.\n *\n * This test class is not intended to be run manually. Instead, use [CoroutinesTimeoutTest] as the entry point.\n */\n@TestMethodOrder(MethodOrderer.OrderAnnotation::class)\nclass CoroutinesTimeoutMethodTest {\n\n    @Test\n    @Order(1)\n    fun noClassTimeout() {\n        runBlocking {\n            delay(150)\n        }\n    }\n\n    @CoroutinesTimeout(100)\n    @Test\n    @Order(2)\n    fun usesMethodTimeoutWithNoClassTimeout() {\n        runBlocking {\n            delay(1000)\n        }\n    }\n\n    @CoroutinesTimeout(1000)\n    @Test\n    @Order(3)\n    fun fitsInMethodTimeout() {\n        runBlocking {\n            delay(10)\n        }\n    }\n\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit5/CoroutinesTimeoutNestedTest.kt",
        "content": "package kotlinx.coroutines.debug.junit5\n\nimport kotlinx.coroutines.*\nimport org.junit.jupiter.api.*\n\n/**\n * This test checks that nested classes correctly recognize the [CoroutinesTimeout] annotation.\n *\n * This test class is not intended to be run manually. Instead, use [CoroutinesTimeoutTest] as the entry point.\n */\n@CoroutinesTimeout(200)\nclass CoroutinesTimeoutNestedTest {\n    @Nested\n    inner class NestedInInherited {\n        @Test\n        fun usesOuterClassTimeout() = runBlocking {\n            delay(1000)\n        }\n\n        @Test\n        fun fitsInOuterClassTimeout() = runBlocking {\n            delay(10)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit5/CoroutinesTimeoutSimpleTest.kt",
        "content": "package kotlinx.coroutines.debug.junit5\n\nimport kotlinx.coroutines.*\nimport org.junit.jupiter.api.*\n\n/**\n * Tests the basic usage of [CoroutinesTimeout] on classes and test methods.\n *\n * This test class is not intended to be run manually. Instead, use [CoroutinesTimeoutTest] as the entry point.\n */\n@TestMethodOrder(MethodOrderer.OrderAnnotation::class)\n@CoroutinesTimeout(100)\nclass CoroutinesTimeoutSimpleTest {\n\n    @Test\n    @Order(1)\n    fun usesClassTimeout1() {\n        runBlocking {\n            delay(150)\n        }\n    }\n\n    @CoroutinesTimeout(1000)\n    @Test\n    @Order(2)\n    fun ignoresClassTimeout() {\n        runBlocking {\n            delay(150)\n        }\n    }\n\n    @CoroutinesTimeout(200)\n    @Test\n    @Order(3)\n    fun usesMethodTimeout() {\n        runBlocking {\n            delay(300)\n        }\n    }\n\n    @Test\n    @Order(4)\n    fun fitsInClassTimeout() {\n        runBlocking {\n            delay(50)\n        }\n    }\n\n    @Test\n    @Order(5)\n    fun usesClassTimeout2() {\n        runBlocking {\n            delay(150)\n        }\n    }\n\n}\n"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit5/CoroutinesTimeoutTest.kt",
        "content": "package kotlinx.coroutines.debug.junit5\n\nimport org.assertj.core.api.*\nimport org.junit.Ignore\nimport org.junit.Assert.*\nimport org.junit.Test\nimport org.junit.platform.engine.*\nimport org.junit.platform.engine.discovery.DiscoverySelectors.*\nimport org.junit.platform.testkit.engine.*\nimport org.junit.platform.testkit.engine.EventConditions.*\nimport java.io.*\n\n// note that these tests are run using JUnit4 in order not to mix the testing systems.\nclass CoroutinesTimeoutTest {\n\n    // This test is ignored because it just checks an example.\n    @Test\n    @Ignore\n    fun testRegisterExtensionExample() {\n        val capturedOut = ByteArrayOutputStream()\n        eventsForSelector(selectClass(RegisterExtensionExample::class.java), capturedOut)\n            .testTimedOut(\"testThatHangs\", 5000)\n    }\n\n    @Test\n    fun testCoroutinesTimeoutSimple() {\n        val capturedOut = ByteArrayOutputStream()\n        eventsForSelector(selectClass(CoroutinesTimeoutSimpleTest::class.java), capturedOut)\n            .testFinishedSuccessfully(\"ignoresClassTimeout\")\n            .testFinishedSuccessfully(\"fitsInClassTimeout\")\n            .testTimedOut(\"usesClassTimeout1\", 100)\n            .testTimedOut(\"usesMethodTimeout\", 200)\n            .testTimedOut(\"usesClassTimeout2\", 100)\n        assertEquals(capturedOut.toString(), 3, countDumps(capturedOut))\n    }\n\n    @Test\n    fun testCoroutinesTimeoutMethod() {\n        val capturedOut = ByteArrayOutputStream()\n        eventsForSelector(selectClass(CoroutinesTimeoutMethodTest::class.java), capturedOut)\n            .testFinishedSuccessfully(\"fitsInMethodTimeout\")\n            .testFinishedSuccessfully(\"noClassTimeout\")\n            .testTimedOut(\"usesMethodTimeoutWithNoClassTimeout\", 100)\n        assertEquals(capturedOut.toString(), 1, countDumps(capturedOut))\n    }\n\n    @Test\n    fun testCoroutinesTimeoutNested() {\n        val capturedOut = ByteArrayOutputStream()\n        eventsForSelector(selectClass(CoroutinesTimeoutNestedTest::class.java), capturedOut)\n            .testFinishedSuccessfully(\"fitsInOuterClassTimeout\")\n            .testTimedOut(\"usesOuterClassTimeout\", 200)\n        assertEquals(capturedOut.toString(), 1, countDumps(capturedOut))\n    }\n\n    @Test\n    fun testCoroutinesTimeoutInheritanceWithNoTimeoutInDerived() {\n        val capturedOut = ByteArrayOutputStream()\n        eventsForSelector(selectClass(CoroutinesTimeoutInheritanceTest.InheritedWithNoTimeout::class.java), capturedOut)\n            .testFinishedSuccessfully(\"methodOverridesBaseClassTimeoutWithGreaterTimeout\")\n            .testTimedOut(\"usesBaseClassTimeout\", 100)\n            .testTimedOut(\"methodOverridesBaseClassTimeoutWithLesserTimeout\", 10)\n        assertEquals(capturedOut.toString(), 2, countDumps(capturedOut))\n    }\n\n    @Test\n    fun testCoroutinesTimeoutInheritanceWithGreaterTimeoutInDerived() {\n        val capturedOut = ByteArrayOutputStream()\n        eventsForSelector(\n            selectClass(CoroutinesTimeoutInheritanceTest.InheritedWithGreaterTimeout::class.java),\n            capturedOut\n        )\n            .testFinishedSuccessfully(\"classOverridesBaseClassTimeout1\")\n            .testTimedOut(\"classOverridesBaseClassTimeout2\", 300)\n        assertEquals(capturedOut.toString(), 1, countDumps(capturedOut))\n    }\n\n    /* Currently there's no ability to replicate [TestFailureValidation] as is for JUnit5:\n    https://github.com/junit-team/junit5/issues/506. So, the test mechanism is more ad-hoc. */\n\n    @Test\n    fun testCoroutinesTimeoutExtensionDisabledTraces() {\n        val capturedOut = ByteArrayOutputStream()\n        eventsForSelector(selectClass(CoroutinesTimeoutExtensionTest.DisabledStackTracesTest::class.java), capturedOut)\n            .testTimedOut(\"hangingTest\", 500)\n        assertEquals(false, capturedOut.toString().contains(\"Coroutine creation stacktrace\"))\n        assertEquals(capturedOut.toString(), 1, countDumps(capturedOut))\n    }\n\n    @Test\n    fun testCoroutinesTimeoutExtensionEager() {\n        val capturedOut = ByteArrayOutputStream()\n        eventsForSelector(selectClass(CoroutinesTimeoutExtensionTest.EagerTest::class.java), capturedOut)\n            .testTimedOut(\"hangingTest\", 500)\n        for (expectedPart in listOf(\"hangForever\", \"waitForHangJob\", \"BlockingCoroutine{Active}\")) {\n            assertEquals(expectedPart, true, capturedOut.toString().contains(expectedPart))\n        }\n        assertEquals(capturedOut.toString(), 1, countDumps(capturedOut))\n    }\n\n    @Test\n    fun testCoroutinesTimeoutExtensionSimple() {\n        val capturedOut = ByteArrayOutputStream()\n        eventsForSelector(selectClass(CoroutinesTimeoutExtensionTest.SimpleTest::class.java), capturedOut)\n            .testFinishedSuccessfully(\"successfulTest\")\n            .testTimedOut(\"hangingTest\", 1000)\n            .haveExactly(1, event(\n                test(\"throwingTest\"),\n                finishedWithFailure(Condition({ it is RuntimeException}, \"is RuntimeException\"))\n            ))\n        for (expectedPart in listOf(\"suspendForever\", \"invokeSuspend\", \"BlockingCoroutine{Active}\")) {\n            assertEquals(expectedPart, true, capturedOut.toString().contains(expectedPart))\n        }\n        for (nonExpectedPart in listOf(\"delay\", \"throwingTest\")) {\n            assertEquals(nonExpectedPart, false, capturedOut.toString().contains(nonExpectedPart))\n        }\n        assertEquals(capturedOut.toString(), 1, countDumps(capturedOut))\n    }\n}\n\nprivate fun eventsForSelector(selector: DiscoverySelector, capturedOut: OutputStream): ListAssert<Event> {\n    val systemOut: PrintStream = System.out\n    val systemErr: PrintStream = System.err\n    return try {\n        System.setOut(PrintStream(capturedOut))\n        System.setErr(PrintStream(capturedOut))\n        EngineTestKit.engine(\"junit-jupiter\")\n            .selectors(selector)\n            .execute()\n            .testEvents()\n            .assertThatEvents()\n    } finally {\n        System.setOut(systemOut)\n        System.setErr(systemErr)\n    }\n}\n\nprivate fun ListAssert<Event>.testFinishedSuccessfully(testName: String): ListAssert<Event> =\n    haveExactly(1, event(\n        test(testName),\n        finishedSuccessfully()\n    ))\n\nprivate fun ListAssert<Event>.testTimedOut(testName: String, after: Long): ListAssert<Event> =\n    haveExactly(1, event(\n        test(testName),\n        finishedWithFailure(Condition({ it is CoroutinesTimeoutException && it.timeoutMs == after },\n            \"is CoroutinesTimeoutException($after)\"))\n    ))\n\n/** Counts the number of occurrences of \"Coroutines dump\" in [capturedOut] */\nprivate fun countDumps(capturedOut: ByteArrayOutputStream): Int {\n    var result = 0\n    val outStr = capturedOut.toString()\n    val header = \"Coroutines dump\"\n    var i = 0\n    while (i < outStr.length - header.length) {\n        if (outStr.substring(i, i + header.length) == header) {\n            result += 1\n            i += header.length\n        } else {\n            i += 1\n        }\n    }\n    return result\n}"
    },
    {
        "path": "kotlinx-coroutines-debug/test/junit5/RegisterExtensionExample.kt",
        "content": "package kotlinx.coroutines.debug.junit5\n\nimport kotlinx.coroutines.*\nimport org.junit.jupiter.api.*\nimport org.junit.jupiter.api.extension.*\n\nclass RegisterExtensionExample {\n    @JvmField\n    @RegisterExtension\n    internal val timeout = CoroutinesTimeoutExtension.seconds(5)\n\n    @Test\n    fun testThatHangs() = runBlocking {\n        delay(Long.MAX_VALUE) // somewhere deep in the stack\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-test/build.gradle.kts",
        "content": "import org.jetbrains.kotlin.gradle.plugin.mpp.*\nimport org.jetbrains.kotlin.gradle.targets.js.dsl.*\n\nkotlin {\n    targets.withType(KotlinNativeTargetWithTests::class.java).configureEach {\n        binaries.getTest(\"DEBUG\").apply {\n            optimized = true\n        }\n    }\n\n    sourceSets {\n        jvmTest {\n            dependencies {\n                implementation(project(\":kotlinx-coroutines-debug\"))\n            }\n        }\n    }\n\n    @OptIn(ExperimentalWasmDsl::class)\n    wasmJs {\n        nodejs {\n            testTask {\n                filter.apply {\n                    // https://youtrack.jetbrains.com/issue/KT-61888\n                    excludeTest(\"TestDispatchersTest\", \"testMainMocking\")\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/src/TestBuilders.kt",
        "content": "@file:JvmName(\"TestBuildersKt\")\n@file:JvmMultifileClass\n\npackage kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\n/**\n * A test result.\n *\n * - On JVM and Native, this resolves to [Unit], representing the fact that tests are run in a blocking manner on these\n *   platforms: a call to a function returning a [TestResult] will simply execute the test inside it.\n * - On JS, this is a `Promise`, which reflects the fact that the test-running function does not wait for a test to\n *   finish. The JS test frameworks typically support returning `Promise` from a test and will correctly handle it.\n *\n * Because of the behavior on JS, extra care must be taken when writing multiplatform tests to avoid losing test errors:\n * - Don't do anything after running the functions returning a [TestResult]. On JS, this code will execute *before* the\n *   test finishes.\n * - As a corollary, don't run functions returning a [TestResult] more than once per test. The only valid thing to do\n *   with a [TestResult] is to immediately `return` it from a test.\n * - Don't nest functions returning a [TestResult].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect class TestResult\n\n/**\n * Executes [testBody] as a test in a new coroutine, returning [TestResult].\n *\n * On JVM and Native, this function behaves similarly to `runBlocking`, with the difference that the code that it runs\n * will skip delays. This allows to use [delay] in tests without causing them to take more time than necessary.\n * On JS, this function creates a `Promise` that executes the test body with the delay-skipping behavior.\n *\n * ```\n * @Test\n * fun exampleTest() = runTest {\n *     val deferred = async {\n *         delay(1.seconds)\n *         async {\n *             delay(1.seconds)\n *         }.await()\n *     }\n *\n *     deferred.await() // result available immediately\n * }\n * ```\n *\n * The platform difference entails that, in order to use this function correctly in common code, one must always\n * immediately return the produced [TestResult] from the test method, without doing anything else afterwards. See\n * [TestResult] for details on this.\n *\n * The test is run on a single thread, unless other [CoroutineDispatcher] are used for child coroutines.\n * Because of this, child coroutines are not executed in parallel to the test body.\n * In order for the spawned-off asynchronous code to actually be executed, one must either [yield] or suspend the\n * test body some other way, or use commands that control scheduling (see [TestCoroutineScheduler]).\n *\n * ```\n * @Test\n * fun exampleWaitingForAsyncTasks1() = runTest {\n *     // 1\n *     val job = launch {\n *         // 3\n *     }\n *     // 2\n *     job.join() // the main test coroutine suspends here, so the child is executed\n *     // 4\n * }\n *\n * @Test\n * fun exampleWaitingForAsyncTasks2() = runTest {\n *     // 1\n *     launch {\n *         // 3\n *     }\n *     // 2\n *     testScheduler.advanceUntilIdle() // runs the tasks until their queue is empty\n *     // 4\n * }\n * ```\n *\n * ### Task scheduling\n *\n * Delay skipping is achieved by using virtual time.\n * If [Dispatchers.Main] is set to a [TestDispatcher] via [Dispatchers.setMain] before the test,\n * then its [TestCoroutineScheduler] is used;\n * otherwise, a new one is automatically created (or taken from [context] in some way) and can be used to control\n * the virtual time, advancing it, running the tasks scheduled at a specific time etc.\n * The scheduler can be accessed via [TestScope.testScheduler].\n *\n * Delays in code that runs inside dispatchers that don't use a [TestCoroutineScheduler] don't get skipped:\n * ```\n * @Test\n * fun exampleTest() = runTest {\n *     val elapsed = TimeSource.Monotonic.measureTime {\n *         val deferred = async {\n *             delay(1.seconds) // will be skipped\n *             withContext(Dispatchers.Default) {\n *                 delay(5.seconds) // Dispatchers.Default doesn't know about TestCoroutineScheduler\n *             }\n *         }\n *         deferred.await()\n *     }\n *     println(elapsed) // about five seconds\n * }\n * ```\n *\n * ### Failures\n *\n * #### Test body failures\n *\n * If the created coroutine completes with an exception, then this exception will be thrown at the end of the test.\n *\n * #### Timing out\n *\n * There's a built-in timeout of 60 seconds for the test body. If the test body doesn't complete within this time,\n * then the test fails with an [AssertionError]. The timeout can be changed for each test separately by setting the\n * [timeout] parameter.\n *\n * Additionally, setting the `kotlinx.coroutines.test.default_timeout` system property on the\n * JVM to any string that can be parsed using [Duration.parse] (like `1m`, `30s` or `1500ms`) will change the default\n * timeout to that value for all tests whose [timeout] is not set explicitly; setting it to anything else will throw an\n * exception every time [runTest] is invoked.\n *\n * On timeout, the test body is cancelled so that the test finishes. If the code inside the test body does not\n * respond to cancellation, the timeout will not be able to make the test execution stop.\n * In that case, the test will hang despite the attempt to terminate it.\n *\n * On the JVM, if `DebugProbes` from the `kotlinx-coroutines-debug` module are installed, the current dump of the\n * coroutines' stack is printed to the console on timeout before the test body is cancelled.\n *\n * #### Reported exceptions\n *\n * Unhandled exceptions will be thrown at the end of the test.\n * If uncaught exceptions happen after the test finishes, they are propagated in a platform-specific manner:\n * see [handleCoroutineException] for details.\n * If the test coroutine completes with an exception, the unhandled exceptions are suppressed by it.\n *\n * #### Uncompleted coroutines\n *\n * Otherwise, the test will hang until all the coroutines launched inside [testBody] complete.\n * This may be an issue when there are some coroutines that are not supposed to complete, like infinite loops that\n * perform some background work and are supposed to outlive the test.\n * In that case, [TestScope.backgroundScope] can be used to launch such coroutines.\n * They will be cancelled automatically when the test finishes.\n *\n * ### Configuration\n *\n * [context] can be used to affect the environment of the code under test. Beside just being passed to the coroutine\n * scope created for the test, [context] also can be used to change how the test is executed.\n * See the [TestScope] constructor function documentation for details.\n *\n * @throws IllegalArgumentException if the [context] is invalid. See the [TestScope] constructor docs for details.\n */\npublic fun runTest(\n    context: CoroutineContext = EmptyCoroutineContext,\n    timeout: Duration = DEFAULT_TIMEOUT.getOrThrow(),\n    testBody: suspend TestScope.() -> Unit\n): TestResult {\n    check(context[RunningInRunTest] == null) {\n        \"Calls to `runTest` can't be nested. Please read the docs on `TestResult` for details.\"\n    }\n    return TestScope(context + RunningInRunTest).runTest(timeout, testBody)\n}\n\n/**\n * Executes [testBody] as a test in a new coroutine, returning [TestResult].\n *\n * On JVM and Native, this function behaves similarly to `runBlocking`, with the difference that the code that it runs\n * will skip delays. This allows to use [delay] in without causing the tests to take more time than necessary.\n * On JS, this function creates a `Promise` that executes the test body with the delay-skipping behavior.\n *\n * ```\n * @Test\n * fun exampleTest() = runTest {\n *     val deferred = async {\n *         delay(1.seconds)\n *         async {\n *             delay(1.seconds)\n *         }.await()\n *     }\n *\n *     deferred.await() // result available immediately\n * }\n * ```\n *\n * The platform difference entails that, in order to use this function correctly in common code, one must always\n * immediately return the produced [TestResult] from the test method, without doing anything else afterwards. See\n * [TestResult] for details on this.\n *\n * The test is run in a single thread, unless other [CoroutineDispatcher] are used for child coroutines.\n * Because of this, child coroutines are not executed in parallel to the test body.\n * In order for the spawned-off asynchronous code to actually be executed, one must either [yield] or suspend the\n * test body some other way, or use commands that control scheduling (see [TestCoroutineScheduler]).\n *\n * ```\n * @Test\n * fun exampleWaitingForAsyncTasks1() = runTest {\n *     // 1\n *     val job = launch {\n *         // 3\n *     }\n *     // 2\n *     job.join() // the main test coroutine suspends here, so the child is executed\n *     // 4\n * }\n *\n * @Test\n * fun exampleWaitingForAsyncTasks2() = runTest {\n *     // 1\n *     launch {\n *         // 3\n *     }\n *     // 2\n *     advanceUntilIdle() // runs the tasks until their queue is empty\n *     // 4\n * }\n * ```\n *\n * ### Task scheduling\n *\n * Delay-skipping is achieved by using virtual time.\n * If [Dispatchers.Main] is set to a [TestDispatcher] via [Dispatchers.setMain] before the test,\n * then its [TestCoroutineScheduler] is used;\n * otherwise, a new one is automatically created (or taken from [context] in some way) and can be used to control\n * the virtual time, advancing it, running the tasks scheduled at a specific time etc.\n * Some convenience methods are available on [TestScope] to control the scheduler.\n *\n * Delays in code that runs inside dispatchers that don't use a [TestCoroutineScheduler] don't get skipped:\n * ```\n * @Test\n * fun exampleTest() = runTest {\n *     val elapsed = TimeSource.Monotonic.measureTime {\n *         val deferred = async {\n *             delay(1.seconds) // will be skipped\n *             withContext(Dispatchers.Default) {\n *                 delay(5.seconds) // Dispatchers.Default doesn't know about TestCoroutineScheduler\n *             }\n *         }\n *         deferred.await()\n *     }\n *     println(elapsed) // about five seconds\n * }\n * ```\n *\n * ### Failures\n *\n * #### Test body failures\n *\n * If the created coroutine completes with an exception, then this exception will be thrown at the end of the test.\n *\n * #### Reported exceptions\n *\n * Unhandled exceptions will be thrown at the end of the test.\n * If the uncaught exceptions happen after the test finishes, the error is propagated in a platform-specific manner.\n * If the test coroutine completes with an exception, the unhandled exceptions are suppressed by it.\n *\n * #### Uncompleted coroutines\n *\n * This method requires that, after the test coroutine has completed, all the other coroutines launched inside\n * [testBody] also complete, or are cancelled.\n * Otherwise, the test will be failed (which, on JVM and Native, means that [runTest] itself will throw\n * [AssertionError], whereas on JS, the `Promise` will fail with it).\n *\n * In the general case, if there are active jobs, it's impossible to detect if they are going to complete eventually due\n * to the asynchronous nature of coroutines. In order to prevent tests hanging in this scenario, [runTest] will wait\n * for [dispatchTimeoutMs] from the moment when [TestCoroutineScheduler] becomes\n * idle before throwing [AssertionError]. If some dispatcher linked to [TestCoroutineScheduler] receives a\n * task during that time, the timer gets reset.\n *\n * ### Configuration\n *\n * [context] can be used to affect the environment of the code under test. Beside just being passed to the coroutine\n * scope created for the test, [context] also can be used to change how the test is executed.\n * See the [TestScope] constructor function documentation for details.\n *\n * @throws IllegalArgumentException if the [context] is invalid. See the [TestScope] constructor docs for details.\n */\n@Deprecated(\n    \"Define a total timeout for the whole test instead of using dispatchTimeoutMs. \" +\n        \"Warning: the proposed replacement is not identical as it uses 'dispatchTimeoutMs' as the timeout for the whole test!\",\n    ReplaceWith(\"runTest(context, timeout = dispatchTimeoutMs.milliseconds, testBody)\",\n        \"kotlin.time.Duration.Companion.milliseconds\"),\n    DeprecationLevel.WARNING\n) // Warning since 1.7.0, was experimental in 1.6.x\npublic fun runTest(\n    context: CoroutineContext = EmptyCoroutineContext,\n    dispatchTimeoutMs: Long,\n    testBody: suspend TestScope.() -> Unit\n): TestResult {\n    if (context[RunningInRunTest] != null)\n        throw IllegalStateException(\"Calls to `runTest` can't be nested. Please read the docs on `TestResult` for details.\")\n    @Suppress(\"DEPRECATION\")\n    return TestScope(context + RunningInRunTest).runTest(dispatchTimeoutMs = dispatchTimeoutMs, testBody)\n}\n\n/**\n * Performs [runTest] on an existing [TestScope]. See the documentation for [runTest] for details.\n */\npublic fun TestScope.runTest(\n    timeout: Duration = DEFAULT_TIMEOUT.getOrThrow(),\n    testBody: suspend TestScope.() -> Unit\n): TestResult = asSpecificImplementation().let { scope ->\n    scope.enter()\n    createTestResult {\n        /** TODO: moving this [AbstractCoroutine.start] call outside [createTestResult] fails on JS. */\n        scope.start(CoroutineStart.UNDISPATCHED, scope) {\n            /* we're using `UNDISPATCHED` to avoid the event loop, but we do want to set up the timeout machinery\n            before any code executes, so we have to park here. */\n            yield()\n            testBody()\n        }\n        var timeoutError: Throwable? = null\n        var cancellationException: CancellationException? = null\n        val workRunner = launch(CoroutineName(\"kotlinx.coroutines.test runner\")) {\n            while (true) {\n                val executedSomething = testScheduler.tryRunNextTaskUnless { !isActive }\n                if (executedSomething) {\n                    /** yield to check for cancellation. On JS, we can't use [ensureActive] here, as the cancellation\n                     * procedure needs a chance to run concurrently. */\n                    yield()\n                } else {\n                    // waiting for the next task to be scheduled, or for the test runner to be cancelled\n                    testScheduler.receiveDispatchEvent()\n                }\n            }\n        }\n        try {\n            withTimeout(timeout) {\n                coroutineContext.job.invokeOnCompletion(onCancelling = true) { exception ->\n                    if (exception is TimeoutCancellationException) {\n                        dumpCoroutines()\n                        val activeChildren = scope.children.filter(Job::isActive).toList()\n                        val completionCause = if (scope.isCancelled) scope.tryGetCompletionCause() else null\n                        var message = \"After waiting for $timeout\"\n                        if (completionCause == null)\n                            message += \", the test coroutine is not completing\"\n                        if (activeChildren.isNotEmpty())\n                            message += \", there were active child jobs: $activeChildren\"\n                        if (completionCause != null && activeChildren.isEmpty()) {\n                            message += if (scope.isCompleted)\n                                \", the test coroutine completed\"\n                            else\n                                \", the test coroutine was not completed\"\n                        }\n                        timeoutError = UncompletedCoroutinesError(message)\n                        cancellationException = CancellationException(\"The test timed out\")\n                        (scope as Job).cancel(cancellationException!!)\n                    }\n                }\n                scope.join()\n                workRunner.cancelAndJoin()\n            }\n        } catch (_: TimeoutCancellationException) {\n            scope.join()\n            val completion = scope.getCompletionExceptionOrNull()\n            if (completion != null && completion !== cancellationException) {\n                timeoutError!!.addSuppressed(completion)\n            }\n            workRunner.cancelAndJoin()\n        } finally {\n            backgroundScope.cancel()\n            testScheduler.advanceUntilIdleOr { false }\n            val uncaughtExceptions = scope.leave()\n            throwAll(timeoutError ?: scope.getCompletionExceptionOrNull(), uncaughtExceptions)\n        }\n    }\n}\n\n/**\n * Performs [runTest] on an existing [TestScope].\n *\n * In the general case, if there are active jobs, it's impossible to detect if they are going to complete eventually due\n * to the asynchronous nature of coroutines. In order to prevent tests hanging in this scenario, [runTest] will wait\n * for [dispatchTimeoutMs] from the moment when [TestCoroutineScheduler] becomes\n * idle before throwing [AssertionError]. If some dispatcher linked to [TestCoroutineScheduler] receives a\n * task during that time, the timer gets reset.\n */\n@Deprecated(\n    \"Define a total timeout for the whole test instead of using dispatchTimeoutMs. \" +\n        \"Warning: the proposed replacement is not identical as it uses 'dispatchTimeoutMs' as the timeout for the whole test!\",\n    ReplaceWith(\"this.runTest(timeout = dispatchTimeoutMs.milliseconds, testBody)\",\n        \"kotlin.time.Duration.Companion.milliseconds\"),\n    DeprecationLevel.WARNING\n) // Warning since 1.7.0, was experimental in 1.6.x\npublic fun TestScope.runTest(\n    dispatchTimeoutMs: Long,\n    testBody: suspend TestScope.() -> Unit\n): TestResult = asSpecificImplementation().let {\n    it.enter()\n    @Suppress(\"DEPRECATION\")\n    createTestResult {\n        runTestCoroutineLegacy(it, dispatchTimeoutMs.milliseconds, TestScopeImpl::tryGetCompletionCause, testBody) {\n            backgroundScope.cancel()\n            testScheduler.advanceUntilIdleOr { false }\n            it.legacyLeave()\n        }\n    }\n}\n\n/**\n * Runs [testProcedure], creating a [TestResult].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\") // actually suppresses `TestResult`\ninternal expect fun createTestResult(testProcedure: suspend CoroutineScope.() -> Unit): TestResult\n\n/** A coroutine context element indicating that the coroutine is running inside `runTest`. */\ninternal object RunningInRunTest : CoroutineContext.Key<RunningInRunTest>, CoroutineContext.Element {\n    override val key: CoroutineContext.Key<*>\n        get() = this\n\n    override fun toString(): String = \"RunningInRunTest\"\n}\n\n/** The default timeout to use when waiting for asynchronous completions of the coroutines managed by\n * a [TestCoroutineScheduler]. */\ninternal const val DEFAULT_DISPATCH_TIMEOUT_MS = 60_000L\n\n/**\n * The default timeout to use when running a test.\n *\n * It's not just a [Duration] but a [Result] so that every access to [runTest]\n * throws the same clear exception if parsing the environment variable failed.\n * Otherwise, the parsing error would only be thrown in one tests, while the\n * other ones would get an incomprehensible `NoClassDefFoundError`.\n */\nprivate val DEFAULT_TIMEOUT: Result<Duration> = runCatching {\n    systemProperty(\"kotlinx.coroutines.test.default_timeout\", Duration::parse, 60.seconds)\n}\n\n/**\n * Run the [body][testBody] of the [test coroutine][coroutine], waiting for asynchronous completions for at most\n * [dispatchTimeout] and performing the [cleanup] procedure at the end.\n *\n * [tryGetCompletionCause] is the [JobSupport.completionCause], which is passed explicitly because it is protected.\n *\n * The [cleanup] procedure may either throw [UncompletedCoroutinesError] to denote that child coroutines were leaked, or\n * return a list of uncaught exceptions that should be reported at the end of the test.\n */\n@Deprecated(\"Used for support of legacy behavior\")\ninternal suspend fun <T : AbstractCoroutine<Unit>> CoroutineScope.runTestCoroutineLegacy(\n    coroutine: T,\n    dispatchTimeout: Duration,\n    tryGetCompletionCause: T.() -> Throwable?,\n    testBody: suspend T.() -> Unit,\n    cleanup: () -> List<Throwable>,\n) {\n    val scheduler = coroutine.coroutineContext[TestCoroutineScheduler]!!\n    /** TODO: moving this [AbstractCoroutine.start] call outside [createTestResult] fails on JS. */\n    coroutine.start(CoroutineStart.UNDISPATCHED, coroutine) {\n        testBody()\n    }\n    /**\n     * This is the legacy behavior, kept for now for compatibility only.\n     *\n     * The general procedure here is as follows:\n     * 1. Try running the work that the scheduler knows about, both background and foreground.\n     *\n     * 2. Wait until we run out of foreground work to do. This could mean one of the following:\n     *    - The main coroutine is already completed. This is checked separately; then we leave the procedure.\n     *    - It's switched to another dispatcher that doesn't know about the [TestCoroutineScheduler].\n     *    - Generally, it's waiting for something external (like a network request, or just an arbitrary callback).\n     *    - The test simply hanged.\n     *    - The main coroutine is waiting for some background work.\n     *\n     * 3. We await progress from things that are not the code under test:\n     *    the background work that the scheduler knows about, the external callbacks,\n     *    the work on dispatchers not linked to the scheduler, etc.\n     *\n     *    When we observe that the code under test can proceed, we go to step 1 again.\n     *    If there is no activity for [dispatchTimeoutMs] milliseconds, we consider the test to have hanged.\n     *\n     *    The background work is not running on a dedicated thread.\n     *    Instead, the test thread itself is used, by spawning a separate coroutine.\n     */\n    var completed = false\n    while (!completed) {\n        scheduler.advanceUntilIdle()\n        if (coroutine.isCompleted) {\n            /* don't even enter `withTimeout`; this allows to use a timeout of zero to check that there are no\n           non-trivial dispatches. */\n            completed = true\n            continue\n        }\n        // in case progress depends on some background work, we need to keep spinning it.\n        val backgroundWorkRunner = launch(CoroutineName(\"background work runner\")) {\n            while (true) {\n                val executedSomething = scheduler.tryRunNextTaskUnless { !isActive }\n                if (executedSomething) {\n                    // yield so that the `select` below has a chance to finish successfully or time out\n                    yield()\n                } else {\n                    // no more tasks, we should suspend until there are some more.\n                    // this doesn't interfere with the `select` below, because different channels are used.\n                    scheduler.receiveDispatchEvent()\n                }\n            }\n        }\n        try {\n            select<Unit> {\n                coroutine.onJoin {\n                    // observe that someone completed the test coroutine and leave without waiting for the timeout\n                    completed = true\n                }\n                scheduler.onDispatchEventForeground {\n                    // we received knowledge that `scheduler` observed a dispatch event, so we reset the timeout\n                }\n                onTimeout(dispatchTimeout) {\n                    throw handleTimeout(coroutine, dispatchTimeout, tryGetCompletionCause, cleanup)\n                }\n            }\n        } finally {\n            backgroundWorkRunner.cancelAndJoin()\n        }\n    }\n    coroutine.getCompletionExceptionOrNull()?.let { exception ->\n        val exceptions = try {\n            cleanup()\n        } catch (e: UncompletedCoroutinesError) {\n            // it's normal that some jobs are not completed if the test body has failed, won't clutter the output\n            emptyList()\n        }\n        throwAll(exception, exceptions)\n    }\n    throwAll(null, cleanup())\n}\n\n/**\n * Invoked on timeout in [runTest]. Just builds a nice [UncompletedCoroutinesError] and returns it.\n */\nprivate inline fun <T : AbstractCoroutine<Unit>> handleTimeout(\n    coroutine: T,\n    dispatchTimeout: Duration,\n    tryGetCompletionCause: T.() -> Throwable?,\n    cleanup: () -> List<Throwable>,\n): AssertionError {\n    val uncaughtExceptions = try {\n        cleanup()\n    } catch (e: UncompletedCoroutinesError) {\n        // we expect these and will instead throw a more informative exception.\n        emptyList()\n    }\n    val activeChildren = coroutine.children.filter { it.isActive }.toList()\n    val completionCause = if (coroutine.isCancelled) coroutine.tryGetCompletionCause() else null\n    var message = \"After waiting for $dispatchTimeout\"\n    if (completionCause == null)\n        message += \", the test coroutine is not completing\"\n    if (activeChildren.isNotEmpty())\n        message += \", there were active child jobs: $activeChildren\"\n    if (completionCause != null && activeChildren.isEmpty()) {\n        message += if (coroutine.isCompleted)\n            \", the test coroutine completed\"\n        else\n            \", the test coroutine was not completed\"\n    }\n    val error = UncompletedCoroutinesError(message)\n    completionCause?.let { cause -> error.addSuppressed(cause) }\n    uncaughtExceptions.forEach { error.addSuppressed(it) }\n    return error\n}\n\ninternal fun throwAll(head: Throwable?, other: List<Throwable>) {\n    if (head != null) {\n        other.forEach { head.addSuppressed(it) }\n        throw head\n    } else {\n        with(other) {\n            firstOrNull()?.apply {\n                drop(1).forEach { addSuppressed(it) }\n                throw this\n            }\n        }\n    }\n}\n\ninternal expect fun dumpCoroutines()\n\nprivate fun <T: Any> systemProperty(\n    name: String,\n    parse: (String) -> T,\n    default: T,\n): T {\n    val value = systemPropertyImpl(name) ?: return default\n    return parse(value)\n}\n\ninternal expect fun systemPropertyImpl(name: String): String?\n\n@Deprecated(\n    \"This is for binary compatibility with the `runTest` overload that existed at some point\",\n    level = DeprecationLevel.HIDDEN\n)\n@JvmName(\"runTest\\$default\")\n@Suppress(\"DEPRECATION\", \"UNUSED_PARAMETER\")\npublic fun TestScope.runTestLegacy(\n    dispatchTimeoutMs: Long,\n    testBody: suspend TestScope.() -> Unit,\n    marker: Int,\n    unused2: Any?,\n): TestResult = runTest(dispatchTimeoutMs = if (marker and 1 != 0) dispatchTimeoutMs else 60_000L, testBody)\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/src/TestCoroutineDispatchers.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.test.internal.TestMainDispatcher\nimport kotlin.coroutines.*\n\n/**\n * Creates an instance of an unconfined [TestDispatcher].\n *\n * This dispatcher is similar to [Dispatchers.Unconfined]: the tasks that it executes are not confined to any particular\n * thread and form an event loop; it's different in that it skips delays, as all [TestDispatcher]s do.\n *\n * Like [Dispatchers.Unconfined], this one does not provide guarantees about the execution order when several coroutines\n * are queued in this dispatcher. However, we ensure that the [launch] and [async] blocks at the top level of [runTest]\n * are entered eagerly. This allows launching child coroutines and not calling [runCurrent] for them to start executing.\n *\n * ```\n * @Test\n * fun testEagerlyEnteringChildCoroutines() = runTest(UnconfinedTestDispatcher()) {\n *   var entered = false\n *   val deferred = CompletableDeferred<Unit>()\n *   var completed = false\n *   launch {\n *     entered = true\n *     deferred.await()\n *     completed = true\n *   }\n *   assertTrue(entered) // `entered = true` already executed.\n *   assertFalse(completed) // however, the child coroutine then suspended, so it is enqueued.\n *   deferred.complete(Unit) // resume the coroutine.\n *   assertTrue(completed) // now the child coroutine is immediately completed.\n * }\n * ```\n *\n * Using this [TestDispatcher] can greatly simplify writing tests where it's not important which thread is used when and\n * in which order the queued coroutines are executed.\n * Another typical use case for this dispatcher is launching child coroutines that are resumed immediately, without\n * going through a dispatch; this can be helpful for testing [Channel] and [StateFlow] usages.\n *\n * ```\n * @Test\n * fun testUnconfinedDispatcher() = runTest {\n *   val values = mutableListOf<Int>()\n *   val stateFlow = MutableStateFlow(0)\n *   val job = launch(UnconfinedTestDispatcher(testScheduler)) {\n *     stateFlow.collect {\n *       values.add(it)\n *     }\n *   }\n *   stateFlow.value = 1\n *   stateFlow.value = 2\n *   stateFlow.value = 3\n *   job.cancel()\n *   // each assignment will immediately resume the collecting child coroutine,\n *   // so no values will be skipped.\n *   assertEquals(listOf(0, 1, 2, 3), values)\n * }\n * ```\n *\n * Please be aware that, like [Dispatchers.Unconfined], this is a specific dispatcher with execution order\n * guarantees that are unusual and not shared by most other dispatchers, so it can only be used reliably for testing\n * functionality, not the specific order of actions.\n * See [Dispatchers.Unconfined] for a discussion of the execution order guarantees.\n *\n * In order to support delay skipping, this dispatcher is linked to a [TestCoroutineScheduler], which is used to control\n * the virtual time and can be shared among many test dispatchers.\n * If no [scheduler] is passed as an argument, [Dispatchers.Main] is checked, and if it was mocked with a\n * [TestDispatcher] via [Dispatchers.setMain], the [TestDispatcher.scheduler] of the mock dispatcher is used; if\n * [Dispatchers.Main] is not mocked with a [TestDispatcher], a new [TestCoroutineScheduler] is created.\n *\n * Additionally, [name] can be set to distinguish each dispatcher instance when debugging.\n *\n * @see StandardTestDispatcher for a more predictable [TestDispatcher].\n */\n@ExperimentalCoroutinesApi\n@Suppress(\"FunctionName\")\npublic fun UnconfinedTestDispatcher(\n    scheduler: TestCoroutineScheduler? = null,\n    name: String? = null\n): TestDispatcher = UnconfinedTestDispatcherImpl(\n    scheduler ?: TestMainDispatcher.currentTestScheduler ?: TestCoroutineScheduler(), name)\n\nprivate class UnconfinedTestDispatcherImpl(\n    override val scheduler: TestCoroutineScheduler,\n    private val name: String? = null\n) : TestDispatcher() {\n\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false\n\n    // do not remove the INVISIBLE_REFERENCE and INVISIBLE_SETTER suppressions: required in K2\n    @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\", \"INVISIBLE_SETTER\")\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        checkSchedulerInContext(scheduler, context)\n        scheduler.sendDispatchEvent(context)\n\n        /** copy-pasted from [kotlinx.coroutines.Unconfined.dispatch] */\n        /** It can only be called by the [yield] function. See also code of [yield] function. */\n        val yieldContext = context[YieldContext]\n        if (yieldContext !== null) {\n            // report to \"yield\" that it is an unconfined dispatcher and don't call \"block.run()\"\n            yieldContext.dispatcherWasUnconfined = true\n            return\n        }\n        throw UnsupportedOperationException(\n            \"Function UnconfinedTestCoroutineDispatcher.dispatch can only be used by \" +\n                \"the yield function. If you wrap Unconfined dispatcher in your code, make sure you properly delegate \" +\n                \"isDispatchNeeded and dispatch calls.\"\n        )\n    }\n\n    override fun toString(): String = \"${name ?: \"UnconfinedTestDispatcher\"}[scheduler=$scheduler]\"\n}\n\n/**\n * Creates an instance of a [TestDispatcher] whose tasks are run inside calls to the [scheduler].\n *\n * This [TestDispatcher] instance does not itself execute any of the tasks. Instead, it always sends them to its\n * [scheduler], which can then be accessed via [TestCoroutineScheduler.runCurrent],\n * [TestCoroutineScheduler.advanceUntilIdle], or [TestCoroutineScheduler.advanceTimeBy], which will then execute these\n * tasks in a blocking manner.\n *\n * In practice, this means that [launch] or [async] blocks will not be entered immediately (unless they are\n * parameterized with [CoroutineStart.UNDISPATCHED]), and one should either call [TestCoroutineScheduler.runCurrent] to\n * run these pending tasks, which will block until there are no more tasks scheduled at this point in time, or, when\n * inside [runTest], call [yield] to yield the (only) thread used by [runTest] to the newly-launched coroutines.\n *\n * If no [scheduler] is passed as an argument, [Dispatchers.Main] is checked, and if it was mocked with a\n * [TestDispatcher] via [Dispatchers.setMain], the [TestDispatcher.scheduler] of the mock dispatcher is used; if\n * [Dispatchers.Main] is not mocked with a [TestDispatcher], a new [TestCoroutineScheduler] is created.\n *\n * One can additionally pass a [name] in order to more easily distinguish this dispatcher during debugging.\n *\n * @see UnconfinedTestDispatcher for a dispatcher that is not confined to any particular thread.\n */\n@Suppress(\"FunctionName\")\npublic fun StandardTestDispatcher(\n    scheduler: TestCoroutineScheduler? = null,\n    name: String? = null\n): TestDispatcher = StandardTestDispatcherImpl(\n    scheduler ?: TestMainDispatcher.currentTestScheduler ?: TestCoroutineScheduler(), name)\n\nprivate class StandardTestDispatcherImpl(\n    override val scheduler: TestCoroutineScheduler = TestCoroutineScheduler(),\n    private val name: String? = null\n) : TestDispatcher() {\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        scheduler.registerEvent(this, 0, block, context) { false }\n    }\n\n    override fun toString(): String = \"${name ?: \"StandardTestDispatcher\"}[scheduler=$scheduler]\"\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/src/TestCoroutineScheduler.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.channels.Channel.Factory.CONFLATED\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\n\n/**\n * This is a scheduler for coroutines used in tests, providing the delay-skipping behavior.\n *\n * [Test dispatchers][TestDispatcher] are parameterized with a scheduler. Several dispatchers can share the\n * same scheduler, in which case their knowledge about the virtual time will be synchronized. When the dispatchers\n * require scheduling an event at a later point in time, they notify the scheduler, which will establish the order of\n * the tasks.\n *\n * The scheduler can be queried to advance the time (via [advanceTimeBy]), run all the scheduled tasks advancing the\n * virtual time as needed (via [advanceUntilIdle]), or run the tasks that are scheduled to run as soon as possible but\n * haven't yet been dispatched (via [runCurrent]).\n */\npublic class TestCoroutineScheduler : AbstractCoroutineContextElement(TestCoroutineScheduler),\n    CoroutineContext.Element {\n\n    /** @suppress */\n    public companion object Key : CoroutineContext.Key<TestCoroutineScheduler>\n\n    /** This heap stores the knowledge about which dispatchers are interested in which moments of virtual time. */\n    // TODO: all the synchronization is done via a separate lock, so a non-thread-safe priority queue can be used.\n    private val events = ThreadSafeHeap<TestDispatchEvent<Any>>()\n\n    /** Establishes that [currentTime] can't exceed the time of the earliest event in [events]. */\n    private val lock = SynchronizedObject()\n\n    /** This counter establishes some order on the events that happen at the same virtual time. */\n    private val count = atomic(0L)\n\n    /** The current virtual time in milliseconds. */\n    @ExperimentalCoroutinesApi\n    public var currentTime: Long = 0\n        get() = synchronized(lock) { field }\n        private set\n\n    /** A channel for notifying about the fact that a foreground work dispatch recently happened. */\n    private val dispatchEventsForeground: Channel<Unit> = Channel(CONFLATED)\n\n    /** A channel for notifying about the fact that a dispatch recently happened. */\n    private val dispatchEvents: Channel<Unit> = Channel(CONFLATED)\n\n    /**\n     * Registers a request for the scheduler to notify [dispatcher] at a virtual moment [timeDeltaMillis] milliseconds\n     * later via [TestDispatcher.processEvent], which will be called with the provided [marker] object.\n     *\n     * Returns the handler which can be used to cancel the registration.\n     */\n    internal fun <T : Any> registerEvent(\n        dispatcher: TestDispatcher,\n        timeDeltaMillis: Long,\n        marker: T,\n        context: CoroutineContext,\n        isCancelled: (T) -> Boolean\n    ): DisposableHandle {\n        require(timeDeltaMillis >= 0) { \"Attempted scheduling an event earlier in time (with the time delta $timeDeltaMillis)\" }\n        checkSchedulerInContext(this, context)\n        val count = count.getAndIncrement()\n        val isForeground = context[BackgroundWork] === null\n        return synchronized(lock) {\n            val time = addClamping(currentTime, timeDeltaMillis)\n            val event = TestDispatchEvent(dispatcher, count, time, marker as Any, isForeground) { isCancelled(marker) }\n            events.addLast(event)\n            /** can't be moved above: otherwise, [onDispatchEventForeground] or [onDispatchEvent] could consume the\n             * token sent here before there's actually anything in the event queue. */\n            sendDispatchEvent(context)\n            DisposableHandle {\n                synchronized(lock) {\n                    events.remove(event)\n                }\n            }\n        }\n    }\n\n    /**\n     * Runs the next enqueued task, advancing the virtual time to the time of its scheduled awakening,\n     * unless [condition] holds.\n     */\n    internal fun tryRunNextTaskUnless(condition: () -> Boolean): Boolean {\n        val event = synchronized(lock) {\n            if (condition()) return false\n            val event = events.removeFirstOrNull() ?: return false\n            if (currentTime > event.time)\n                currentTimeAheadOfEvents()\n            currentTime = event.time\n            event\n        }\n        event.dispatcher.processEvent(event.marker)\n        return true\n    }\n\n    /**\n     * Runs the enqueued tasks in the specified order, advancing the virtual time as needed until there are no more\n     * tasks associated with the dispatchers linked to this scheduler.\n     *\n     * A breaking change from `TestCoroutineDispatcher.advanceTimeBy` is that it no longer returns the total number of\n     * milliseconds by which the execution of this method has advanced the virtual time. If you want to recreate that\n     * functionality, query [currentTime] before and after the execution to achieve the same result.\n     */\n    public fun advanceUntilIdle(): Unit = advanceUntilIdleOr { events.none(TestDispatchEvent<*>::isForeground) }\n\n    /**\n     * [condition]: guaranteed to be invoked under the lock.\n     */\n    internal fun advanceUntilIdleOr(condition: () -> Boolean) {\n        while (true) {\n            if (!tryRunNextTaskUnless(condition))\n                return\n        }\n    }\n\n    /**\n     * Runs the tasks that are scheduled to execute at this moment of virtual time.\n     */\n    public fun runCurrent() {\n        val timeMark = synchronized(lock) { currentTime }\n        while (true) {\n            val event = synchronized(lock) {\n                events.removeFirstIf { it.time <= timeMark } ?: return\n            }\n            event.dispatcher.processEvent(event.marker)\n        }\n    }\n\n    /**\n     * Moves the virtual clock of this dispatcher forward by [the specified amount][delayTimeMillis], running the\n     * scheduled tasks in the meantime.\n     *\n     * Breaking changes from [TestCoroutineDispatcher.advanceTimeBy]:\n     * - Intentionally doesn't return a `Long` value, as its use cases are unclear. We may restore it in the future;\n     *   please describe your use cases at [the issue tracker](https://github.com/Kotlin/kotlinx.coroutines/issues/).\n     *   For now, it's possible to query [currentTime] before and after execution of this method, to the same effect.\n     * - It doesn't run the tasks that are scheduled at exactly [currentTime] + [delayTimeMillis]. For example,\n     *   advancing the time by one millisecond used to run the tasks at the current millisecond *and* the next\n     *   millisecond, but now will stop just before executing any task starting at the next millisecond.\n     * - Overflowing the target time used to lead to nothing being done, but will now run the tasks scheduled at up to\n     *   (but not including) [Long.MAX_VALUE].\n     *\n     * @throws IllegalArgumentException if passed a negative [delay][delayTimeMillis].\n     */\n    @ExperimentalCoroutinesApi\n    public fun advanceTimeBy(delayTimeMillis: Long): Unit = advanceTimeBy(delayTimeMillis.milliseconds)\n\n    /**\n     * Moves the virtual clock of this dispatcher forward by [the specified amount][delayTime], running the\n     * scheduled tasks in the meantime.\n     *\n     * @throws IllegalArgumentException if passed a negative [delay][delayTime].\n     */\n    public fun advanceTimeBy(delayTime: Duration) {\n        require(!delayTime.isNegative()) { \"Can not advance time by a negative delay: $delayTime\" }\n        val startingTime = currentTime\n        val targetTime = addClamping(startingTime, delayTime.inWholeMilliseconds)\n        while (true) {\n            val event = synchronized(lock) {\n                val timeMark = currentTime\n                val event = events.removeFirstIf { targetTime > it.time }\n                when {\n                    event == null -> {\n                        currentTime = targetTime\n                        return\n                    }\n                    timeMark > event.time -> currentTimeAheadOfEvents()\n                    else -> {\n                        currentTime = event.time\n                        event\n                    }\n                }\n            }\n            event.dispatcher.processEvent(event.marker)\n        }\n    }\n\n    /**\n     * Checks that the only tasks remaining in the scheduler are cancelled.\n     */\n    internal fun isIdle(strict: Boolean = true): Boolean =\n        synchronized(lock) {\n            if (strict) events.isEmpty else events.none { !it.isCancelled() }\n        }\n\n    /**\n     * Notifies this scheduler about a dispatch event.\n     *\n     * [context] is the context in which the task will be dispatched.\n     */\n    internal fun sendDispatchEvent(context: CoroutineContext) {\n        dispatchEvents.trySend(Unit)\n        if (context[BackgroundWork] !== BackgroundWork)\n            dispatchEventsForeground.trySend(Unit)\n    }\n\n    /**\n     * Waits for a notification about a dispatch event.\n     */\n    internal suspend fun receiveDispatchEvent() = dispatchEvents.receive()\n\n    /**\n     * Consumes the knowledge that a dispatch event happened recently.\n     */\n    internal val onDispatchEvent: SelectClause1<Unit> get() = dispatchEvents.onReceive\n\n    /**\n     * Consumes the knowledge that a foreground work dispatch event happened recently.\n     */\n    internal val onDispatchEventForeground: SelectClause1<Unit> get() = dispatchEventsForeground.onReceive\n\n    /**\n     * Returns the [TimeSource] representation of the virtual time of this scheduler.\n     */\n    public val timeSource: TimeSource.WithComparableMarks = object : AbstractLongTimeSource(DurationUnit.MILLISECONDS) {\n        override fun read(): Long = currentTime\n    }\n}\n\n// Some error-throwing functions for pretty stack traces\nprivate fun currentTimeAheadOfEvents(): Nothing = invalidSchedulerState()\n\nprivate fun invalidSchedulerState(): Nothing =\n    throw IllegalStateException(\"The test scheduler entered an invalid state. Please report this at https://github.com/Kotlin/kotlinx.coroutines/issues.\")\n\n/** [ThreadSafeHeap] node representing a scheduled task, ordered by the planned execution time. */\nprivate class TestDispatchEvent<T>(\n    @JvmField val dispatcher: TestDispatcher,\n    private val count: Long,\n    @JvmField val time: Long,\n    @JvmField val marker: T,\n    @JvmField val isForeground: Boolean,\n    // TODO: remove once the deprecated API is gone\n    @JvmField val isCancelled: () -> Boolean\n) : Comparable<TestDispatchEvent<*>>, ThreadSafeHeapNode {\n    override var heap: ThreadSafeHeap<*>? = null\n    override var index: Int = 0\n\n    override fun compareTo(other: TestDispatchEvent<*>) =\n        compareValuesBy(this, other, TestDispatchEvent<*>::time, TestDispatchEvent<*>::count)\n\n    override fun toString() = \"TestDispatchEvent(time=$time, dispatcher=$dispatcher${if (isForeground) \"\" else \", background\"})\"\n}\n\n// works with positive `a`, `b`\nprivate fun addClamping(a: Long, b: Long): Long = (a + b).let { if (it >= 0) it else Long.MAX_VALUE }\n\ninternal fun checkSchedulerInContext(scheduler: TestCoroutineScheduler, context: CoroutineContext) {\n    context[TestCoroutineScheduler]?.let {\n        check(it === scheduler) {\n            \"Detected use of different schedulers. If you need to use several test coroutine dispatchers, \" +\n                \"create one `TestCoroutineScheduler` and pass it to each of them.\"\n        }\n    }\n}\n\n/**\n * A coroutine context key denoting that the work is to be executed in the background.\n * @see [TestScope.backgroundScope]\n */\ninternal object BackgroundWork : CoroutineContext.Key<BackgroundWork>, CoroutineContext.Element {\n    override val key: CoroutineContext.Key<*>\n        get() = this\n\n    override fun toString(): String = \"BackgroundWork\"\n}\n\nprivate fun<T> ThreadSafeHeap<T>.none(predicate: (T) -> Boolean) where T: ThreadSafeHeapNode, T: Comparable<T> =\n    find(predicate) == null\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/src/TestDispatcher.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\nimport kotlin.time.*\n\n/**\n * A test dispatcher that can interface with a [TestCoroutineScheduler].\n *\n * The available implementations are:\n * - [StandardTestDispatcher] is a dispatcher that places new tasks into a queue.\n * - [UnconfinedTestDispatcher] is a dispatcher that behaves like [Dispatchers.Unconfined] while allowing to control\n *   the virtual time.\n */\n@Suppress(\"INVISIBLE_REFERENCE\")\npublic abstract class TestDispatcher internal constructor() : CoroutineDispatcher(), Delay, DelayWithTimeoutDiagnostics {\n    /** The scheduler that this dispatcher is linked to. */\n    public abstract val scheduler: TestCoroutineScheduler\n\n    /** Notifies the dispatcher that it should process a single event marked with [marker] happening at time [time]. */\n    internal fun processEvent(marker: Any) {\n        check(marker is Runnable)\n        marker.run()\n    }\n\n    /** @suppress */\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val timedRunnable = CancellableContinuationRunnable(continuation, this)\n        val handle = scheduler.registerEvent(\n            this,\n            timeMillis,\n            timedRunnable,\n            continuation.context,\n            ::cancellableRunnableIsCancelled\n        )\n        continuation.disposeOnCancellation(handle)\n    }\n\n    /** @suppress */\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle =\n        scheduler.registerEvent(this, timeMillis, block, context) { false }\n\n    /** @suppress */\n    @Suppress(\"CANNOT_OVERRIDE_INVISIBLE_MEMBER\")\n    @Deprecated(\"Is only needed internally\", level = DeprecationLevel.HIDDEN)\n    public override fun timeoutMessage(timeout: Duration): String =\n        \"Timed out after $timeout of _virtual_ (kotlinx.coroutines.test) time. \" +\n            \"To use the real time, wrap 'withTimeout' in 'withContext(Dispatchers.Default.limitedParallelism(1))'\"\n}\n\n/**\n * This class exists to allow cleanup code to avoid throwing for cancelled continuations scheduled\n * in the future.\n */\nprivate class CancellableContinuationRunnable(\n    @JvmField val continuation: CancellableContinuation<Unit>,\n    private val dispatcher: CoroutineDispatcher\n) : Runnable {\n    override fun run() = with(dispatcher) { with(continuation) { resumeUndispatched(Unit) } }\n}\n\nprivate fun cancellableRunnableIsCancelled(runnable: CancellableContinuationRunnable): Boolean =\n    !runnable.continuation.isActive\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/src/TestDispatchers.kt",
        "content": "@file:JvmName(\"TestDispatchers\")\n\npackage kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.test.internal.*\nimport kotlin.jvm.*\n\n/**\n * Sets the given [dispatcher] as an underlying dispatcher of [Dispatchers.Main].\n * All subsequent usages of [Dispatchers.Main] will use the given [dispatcher] under the hood.\n *\n * Using [TestDispatcher] as an argument has special behavior: subsequently-called [runTest], as well as\n * [TestScope] and test dispatcher constructors, will use the [TestCoroutineScheduler] of the provided dispatcher.\n *\n * It is unsafe to call this method if alive coroutines launched in [Dispatchers.Main] exist.\n */\n@ExperimentalCoroutinesApi\npublic fun Dispatchers.setMain(dispatcher: CoroutineDispatcher) {\n    require(dispatcher !is TestMainDispatcher) { \"Dispatchers.setMain(Dispatchers.Main) is prohibited, probably Dispatchers.resetMain() should be used instead\" }\n    getTestMainDispatcher().setDispatcher(dispatcher)\n}\n\n/**\n * Resets state of the [Dispatchers.Main] to the original main dispatcher.\n *\n * For example, in Android, the Main thread dispatcher will be set as [Dispatchers.Main].\n * This method undoes a dependency injection performed for tests, and so should be used in tear down (`@After`) methods.\n *\n * It is unsafe to call this method if alive coroutines launched in [Dispatchers.Main] exist.\n */\n@ExperimentalCoroutinesApi\npublic fun Dispatchers.resetMain() {\n    getTestMainDispatcher().resetDispatcher()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/src/TestScope.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.test.internal.*\nimport kotlin.coroutines.*\nimport kotlin.time.*\n\n/**\n * A coroutine scope that for launching test coroutines.\n *\n * The scope provides the following functionality:\n * - The [coroutineContext] includes a [coroutine dispatcher][TestDispatcher] that supports delay-skipping, using\n *   a [TestCoroutineScheduler] for orchestrating the virtual time.\n *   This scheduler is also available via the [testScheduler] property, and some helper extension\n *   methods are defined to more conveniently interact with it: see [TestScope.currentTime], [TestScope.runCurrent],\n *   [TestScope.advanceTimeBy], and [TestScope.advanceUntilIdle].\n * - When inside [runTest], uncaught exceptions from the child coroutines of this scope will be reported at the end of\n *   the test.\n *   It is invalid for child coroutines to throw uncaught exceptions when outside the call to [TestScope.runTest]:\n *   the only guarantee in this case is the best effort to deliver the exception.\n *\n * The usual way to access a [TestScope] is to call [runTest], but it can also be constructed manually, in order to\n * use it to initialize the components that participate in the test.\n *\n * #### Differences from the deprecated [TestCoroutineScope]\n *\n * - This doesn't provide an equivalent of [TestCoroutineScope.cleanupTestCoroutines], and so can't be used as a\n *   standalone mechanism for writing tests: it does require that [runTest] is eventually called.\n *   The reason for this is that a proper cleanup procedure that supports using non-test dispatchers and arbitrary\n *   coroutine suspensions would be equivalent to [runTest], but would also be more error-prone, due to the potential\n *   for forgetting to perform the cleanup.\n * - [TestCoroutineScope.advanceTimeBy] also calls [TestCoroutineScheduler.runCurrent] after advancing the virtual time.\n * - No support for dispatcher pausing, like [DelayController] allows. [TestCoroutineDispatcher], which supported\n *   pausing, is deprecated; now, instead of pausing a dispatcher, one can use [withContext] to run a dispatcher that's\n *   paused by default, like [StandardTestDispatcher].\n * - No access to the list of unhandled exceptions.\n */\npublic sealed interface TestScope : CoroutineScope {\n    /**\n     * The delay-skipping scheduler used by the test dispatchers running the code in this scope.\n     */\n    public val testScheduler: TestCoroutineScheduler\n\n    /**\n     * A scope for background work.\n     *\n     * This scope is automatically cancelled when the test finishes.\n     * The coroutines in this scope are run as usual when using [advanceTimeBy] and [runCurrent].\n     * [advanceUntilIdle], on the other hand, will stop advancing the virtual time once only the coroutines in this\n     * scope are left unprocessed.\n     *\n     * Failures in coroutines in this scope do not terminate the test.\n     * Instead, they are reported at the end of the test.\n     * Likewise, failure in the [TestScope] itself will not affect its [backgroundScope],\n     * because there's no parent-child relationship between them.\n     *\n     * A typical use case for this scope is to launch tasks that would outlive the tested code in\n     * the production environment.\n     *\n     * In this example, the coroutine that continuously sends new elements to the channel will get\n     * cancelled:\n     * ```\n     * @Test\n     * fun testExampleBackgroundJob() = runTest {\n     *   val channel = Channel<Int>()\n     *   backgroundScope.launch {\n     *     var i = 0\n     *     while (true) {\n     *       channel.send(i++)\n     *     }\n     *   }\n     *   repeat(100) {\n     *     assertEquals(it, channel.receive())\n     *   }\n     * }\n     * ```\n     */\n    public val backgroundScope: CoroutineScope\n}\n\n/**\n * The current virtual time on [testScheduler][TestScope.testScheduler].\n * @see TestCoroutineScheduler.currentTime\n */\n@ExperimentalCoroutinesApi\npublic val TestScope.currentTime: Long\n    get() = testScheduler.currentTime\n\n/**\n * Advances the [testScheduler][TestScope.testScheduler] to the point where there are no tasks remaining.\n * @see TestCoroutineScheduler.advanceUntilIdle\n */\n@ExperimentalCoroutinesApi\npublic fun TestScope.advanceUntilIdle(): Unit = testScheduler.advanceUntilIdle()\n\n/**\n * Run any tasks that are pending at the current virtual time, according to\n * the [testScheduler][TestScope.testScheduler].\n *\n * @see TestCoroutineScheduler.runCurrent\n */\n@ExperimentalCoroutinesApi\npublic fun TestScope.runCurrent(): Unit = testScheduler.runCurrent()\n\n/**\n * Moves the virtual clock of this dispatcher forward by [the specified amount][delayTimeMillis], running the\n * scheduled tasks in the meantime.\n *\n * In contrast with `TestCoroutineScope.advanceTimeBy`, this function does not run the tasks scheduled at the moment\n * [currentTime] + [delayTimeMillis].\n *\n * @throws IllegalStateException if passed a negative [delay][delayTimeMillis].\n * @see TestCoroutineScheduler.advanceTimeBy\n */\n@ExperimentalCoroutinesApi\npublic fun TestScope.advanceTimeBy(delayTimeMillis: Long): Unit = testScheduler.advanceTimeBy(delayTimeMillis)\n\n/**\n * Moves the virtual clock of this dispatcher forward by [the specified amount][delayTime], running the\n * scheduled tasks in the meantime.\n *\n * @throws IllegalStateException if passed a negative [delay][delayTime].\n * @see TestCoroutineScheduler.advanceTimeBy\n */\n@ExperimentalCoroutinesApi\npublic fun TestScope.advanceTimeBy(delayTime: Duration): Unit = testScheduler.advanceTimeBy(delayTime)\n\n/**\n * The [test scheduler][TestScope.testScheduler] as a [TimeSource].\n * @see TestCoroutineScheduler.timeSource\n */\n@ExperimentalCoroutinesApi\npublic val TestScope.testTimeSource: TimeSource.WithComparableMarks get() = testScheduler.timeSource\n\n/**\n * Creates a [TestScope].\n *\n * It ensures that all the test module machinery is properly initialized.\n * - If [context] doesn't provide a [TestCoroutineScheduler] for orchestrating the virtual time used for delay-skipping,\n *   a new one is created, unless either\n *   - a [TestDispatcher] is provided, in which case [TestDispatcher.scheduler] is used;\n *   - at the moment of the creation of the scope, [Dispatchers.Main] is delegated to a [TestDispatcher], in which case\n *     its [TestCoroutineScheduler] is used.\n * - If [context] doesn't have a [TestDispatcher], a [StandardTestDispatcher] is created.\n * - A [CoroutineExceptionHandler] is created that makes [TestCoroutineScope.cleanupTestCoroutines] throw if there were\n *   any uncaught exceptions, or forwards the exceptions further in a platform-specific manner if the cleanup was\n *   already performed when an exception happened. Passing a [CoroutineExceptionHandler] is illegal, unless it's an\n *   [UncaughtExceptionCaptor], in which case the behavior is preserved for the time being for backward compatibility.\n *   If you need to have a specific [CoroutineExceptionHandler], please pass it to [launch] on an already-created\n *   [TestCoroutineScope] and share your use case at\n *   [our issue tracker](https://github.com/Kotlin/kotlinx.coroutines/issues).\n * - If [context] provides a [Job], that job is used as a parent for the new scope.\n *\n * @throws IllegalArgumentException if [context] has both [TestCoroutineScheduler] and a [TestDispatcher] linked to a\n * different scheduler.\n * @throws IllegalArgumentException if [context] has a [ContinuationInterceptor] that is not a [TestDispatcher].\n * @throws IllegalArgumentException if [context] has an [CoroutineExceptionHandler] that is not an\n * [UncaughtExceptionCaptor].\n */\n@Suppress(\"FunctionName\")\npublic fun TestScope(context: CoroutineContext = EmptyCoroutineContext): TestScope {\n    val ctxWithDispatcher = context.withDelaySkipping()\n    var scope: TestScopeImpl? = null\n    val exceptionHandler = when (ctxWithDispatcher[CoroutineExceptionHandler]) {\n        null -> CoroutineExceptionHandler { _, exception ->\n            scope!!.reportException(exception)\n        }\n        else -> throw IllegalArgumentException(\n            \"A CoroutineExceptionHandler was passed to TestScope. \" +\n                \"Please pass it as an argument to a `launch` or `async` block on an already-created scope \" +\n                \"if uncaught exceptions require special treatment.\"\n        )\n    }\n    return TestScopeImpl(ctxWithDispatcher + exceptionHandler).also { scope = it }\n}\n\n/**\n * Adds a [TestDispatcher] and a [TestCoroutineScheduler] to the context if there aren't any already.\n *\n * @throws IllegalArgumentException if both a [TestCoroutineScheduler] and a [TestDispatcher] are passed.\n * @throws IllegalArgumentException if a [ContinuationInterceptor] is passed that is not a [TestDispatcher].\n */\ninternal fun CoroutineContext.withDelaySkipping(): CoroutineContext {\n    val dispatcher: TestDispatcher = when (val dispatcher = get(ContinuationInterceptor)) {\n        is TestDispatcher -> {\n            val ctxScheduler = get(TestCoroutineScheduler)\n            if (ctxScheduler != null) {\n                require(dispatcher.scheduler === ctxScheduler) {\n                    \"Both a TestCoroutineScheduler $ctxScheduler and TestDispatcher $dispatcher linked to \" +\n                        \"another scheduler were passed.\"\n                }\n            }\n            dispatcher\n        }\n        null -> StandardTestDispatcher(get(TestCoroutineScheduler))\n        else -> throw IllegalArgumentException(\"Dispatcher must implement TestDispatcher: $dispatcher\")\n    }\n    return this + dispatcher + dispatcher.scheduler\n}\n\ninternal class TestScopeImpl(context: CoroutineContext) :\n    AbstractCoroutine<Unit>(context, initParentJob = true, active = true), TestScope {\n\n    override val testScheduler get() = context[TestCoroutineScheduler]!!\n\n    private var entered = false\n    private var finished = false\n    private val uncaughtExceptions = mutableListOf<Throwable>()\n    private val lock = SynchronizedObject()\n\n    override val backgroundScope: CoroutineScope =\n        CoroutineScope(coroutineContext + BackgroundWork + ReportingSupervisorJob {\n            if (it !is CancellationException) reportException(it)\n        })\n\n    /** Called upon entry to [runTest]. Will throw if called more than once. */\n    fun enter() {\n        val exceptions = synchronized(lock) {\n            if (entered)\n                throw IllegalStateException(\"Only a single call to `runTest` can be performed during one test.\")\n            entered = true\n            check(!finished)\n            /** the order is important: [reportException] is only guaranteed not to throw if [entered] is `true` but\n             * [finished] is `false`.\n             * However, we also want [uncaughtExceptions] to be queried after the callback is registered,\n             * because the exception collector will be able to report the exceptions that arrived before this test but\n             * after the previous one, and learning about such exceptions as soon is possible is nice. */\n            @Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n            run { ensurePlatformExceptionHandlerLoaded(ExceptionCollector) }\n            if (catchNonTestRelatedExceptions) {\n                ExceptionCollector.addOnExceptionCallback(lock, this::reportException)\n            }\n            uncaughtExceptions\n        }\n        if (exceptions.isNotEmpty()) {\n            ExceptionCollector.removeOnExceptionCallback(lock)\n            throw UncaughtExceptionsBeforeTest().apply {\n                for (e in exceptions)\n                    addSuppressed(e)\n            }\n        }\n    }\n\n    /** Called at the end of the test. May only be called once. Returns the list of caught unhandled exceptions. */\n    fun leave(): List<Throwable> = synchronized(lock) {\n        check(entered && !finished)\n        /** After [finished] becomes `true`, it is no longer valid to have [reportException] as the callback. */\n        ExceptionCollector.removeOnExceptionCallback(lock)\n        finished = true\n        uncaughtExceptions\n    }\n\n    /** Called at the end of the test. May only be called once. */\n    fun legacyLeave(): List<Throwable> {\n        val exceptions = synchronized(lock) {\n            check(entered && !finished)\n            /** After [finished] becomes `true`, it is no longer valid to have [reportException] as the callback. */\n            ExceptionCollector.removeOnExceptionCallback(lock)\n            finished = true\n            uncaughtExceptions\n        }\n        val activeJobs = children.filter { it.isActive }.toList() // only non-empty if used with `runBlockingTest`\n        if (exceptions.isEmpty()) {\n            if (activeJobs.isNotEmpty())\n                throw UncompletedCoroutinesError(\n                    \"Active jobs found during the tear-down. \" +\n                        \"Ensure that all coroutines are completed or cancelled by your test. \" +\n                        \"The active jobs: $activeJobs\"\n                )\n            if (!testScheduler.isIdle())\n                throw UncompletedCoroutinesError(\n                    \"Unfinished coroutines found during the tear-down. \" +\n                        \"Ensure that all coroutines are completed or cancelled by your test.\"\n                )\n        }\n        return exceptions\n    }\n\n    /** Stores an exception to report after [runTest], or rethrows it if not inside [runTest]. */\n    fun reportException(throwable: Throwable) {\n        synchronized(lock) {\n            if (finished) {\n                throw throwable\n            } else {\n                @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n                for (existingThrowable in uncaughtExceptions) {\n                    // avoid reporting exceptions that already were reported.\n                    if (unwrap(throwable) == unwrap(existingThrowable))\n                        return\n                }\n                uncaughtExceptions.add(throwable)\n                if (!entered)\n                    throw UncaughtExceptionsBeforeTest().apply { addSuppressed(throwable) }\n            }\n        }\n    }\n\n    /** Throws an exception if the coroutine is not completing. */\n    fun tryGetCompletionCause(): Throwable? = completionCause\n\n    override fun toString(): String =\n        \"TestScope[\" + (if (finished) \"test ended\" else if (entered) \"test started\" else \"test not started\") + \"]\"\n}\n\n/** Use the knowledge that any [TestScope] that we receive is necessarily a [TestScopeImpl]. */\n@Suppress(\"NO_ELSE_IN_WHEN\") // TODO: a problem with `sealed` in MPP not allowing total pattern-matching\ninternal fun TestScope.asSpecificImplementation(): TestScopeImpl = when (this) {\n    is TestScopeImpl -> this\n}\n\ninternal class UncaughtExceptionsBeforeTest : IllegalStateException(\n    \"There were uncaught exceptions before the test started. Please avoid this,\" +\n        \" as such exceptions are also reported in a platform-dependent manner so that they are not lost.\"\n)\n\n/**\n * Thrown when a test has completed and there are tasks that are not completed or cancelled.\n */\n@ExperimentalCoroutinesApi\ninternal class UncompletedCoroutinesError(message: String) : AssertionError(message)\n\n/**\n * A flag that controls whether [TestScope] should attempt to catch arbitrary exceptions flying through the system.\n * If it is enabled, then any exception that is not caught by the user code will be reported as a test failure.\n * By default, it is enabled, but some tests may want to disable it to test the behavior of the system when they have\n * their own exception handling procedures.\n */\n@PublishedApi\ninternal var catchNonTestRelatedExceptions: Boolean = true\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/src/internal/ExceptionCollector.kt",
        "content": "package kotlinx.coroutines.test.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n/**\n * If [addOnExceptionCallback] is called, the provided callback will be evaluated each time\n * [handleCoroutineException] is executed and can't find a [CoroutineExceptionHandler] to\n * process the exception.\n *\n * When a callback is registered once, even if it's later removed, the system starts to assume that\n * other callbacks will eventually be registered, and so collects the exceptions.\n * Once a new callback is registered, the collected exceptions are used with it.\n *\n * The callbacks in this object are the last resort before relying on platform-dependent\n * ways to report uncaught exceptions from coroutines.\n */\ninternal object ExceptionCollector : AbstractCoroutineContextElement(CoroutineExceptionHandler), CoroutineExceptionHandler {\n    private val lock = SynchronizedObject()\n    private var enabled = false\n    private val unprocessedExceptions = mutableListOf<Throwable>()\n    private val callbacks = mutableMapOf<Any, (Throwable) -> Unit>()\n\n    /**\n     * Registers [callback] to be executed when an uncaught exception happens.\n     * [owner] is a key by which to distinguish different callbacks.\n     */\n    fun addOnExceptionCallback(owner: Any, callback: (Throwable) -> Unit) = synchronized(lock) {\n        enabled = true // never becomes `false` again\n        val previousValue = callbacks.put(owner, callback)\n        check(previousValue === null)\n        // try to process the exceptions using the newly-registered callback\n        unprocessedExceptions.forEach { reportException(it) }\n        unprocessedExceptions.clear()\n    }\n\n    /**\n     * Unregisters the callback associated with [owner].\n     */\n    fun removeOnExceptionCallback(owner: Any) = synchronized(lock) {\n        if (enabled) {\n            val existingValue = callbacks.remove(owner)\n            check(existingValue !== null)\n        }\n    }\n\n    /**\n     * Tries to handle the exception by propagating it to an interested consumer.\n     * Returns `true` if the exception does not need further processing.\n     *\n     * Doesn't throw.\n     */\n    fun handleException(exception: Throwable): Boolean = synchronized(lock) {\n        if (!enabled) return false\n        if (reportException(exception)) return true\n        /** we don't return the result of the `add` function because we don't have a guarantee\n         * that a callback will eventually appear and collect the unprocessed exceptions, so\n         * we can't consider [exception] to be properly handled. */\n        unprocessedExceptions.add(exception)\n        return false\n    }\n\n    /**\n     * Try to report [exception] to the existing callbacks.\n     */\n    private fun reportException(exception: Throwable): Boolean {\n        var executedACallback = false\n        for (callback in callbacks.values) {\n            callback(exception)\n            executedACallback = true\n            /** We don't leave the function here because we want to fan-out the exceptions to every interested consumer,\n             * it's not enough to have the exception processed by one of them.\n             * The reason is, it's less big of a deal to observe multiple concurrent reports of bad behavior than not\n             * to observe the report in the exact callback that is connected to that bad behavior. */\n        }\n        return executedACallback\n    }\n\n    @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n    override fun handleException(context: CoroutineContext, exception: Throwable) {\n        if (handleException(exception)) {\n            throw ExceptionSuccessfullyProcessed\n        }\n    }\n\n    override fun equals(other: Any?): Boolean = other is ExceptionCollector || other is ExceptionCollectorAsService\n}\n\n/**\n * A workaround for being unable to treat an object as a `ServiceLoader` service.\n */\ninternal class ExceptionCollectorAsService: CoroutineExceptionHandler by ExceptionCollector {\n    override fun equals(other: Any?): Boolean = other is ExceptionCollectorAsService || other is ExceptionCollector\n    override fun hashCode(): Int = ExceptionCollector.hashCode()\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/src/internal/ReportingSupervisorJob.kt",
        "content": "package kotlinx.coroutines.test.internal\n\nimport kotlinx.coroutines.*\n\n/**\n * A variant of [SupervisorJob] that additionally notifies about child failures via a callback.\n */\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\", \"CANNOT_OVERRIDE_INVISIBLE_MEMBER\")\ninternal class ReportingSupervisorJob(parent: Job? = null, val onChildCancellation: (Throwable) -> Unit) :\n    JobImpl(parent) {\n    override fun childCancelled(cause: Throwable): Boolean =\n        try {\n            onChildCancellation(cause)\n        } catch (e: Throwable) {\n            cause.addSuppressed(e)\n            /* the coroutine context does not matter here, because we're only interested in reporting this exception\n            to the platform-specific global handler, not to a [CoroutineExceptionHandler] of any sort. */\n            handleCoroutineException(this, cause)\n        }.let { false }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/src/internal/TestMainDispatcher.kt",
        "content": "package kotlinx.coroutines.test.internal\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.test.*\nimport kotlin.coroutines.*\n\n/**\n * The testable main dispatcher used by kotlinx-coroutines-test.\n * It is a [MainCoroutineDispatcher] that delegates all actions to a settable delegate.\n */\ninternal class TestMainDispatcher(delegate: CoroutineDispatcher):\n    MainCoroutineDispatcher(),\n    Delay\n{\n    private val mainDispatcher = delegate\n    private var delegate = NonConcurrentlyModifiable(mainDispatcher, \"Dispatchers.Main\")\n\n    private val delay\n        get() = delegate.value as? Delay ?: defaultDelay\n\n    override val immediate: MainCoroutineDispatcher\n        get() = (delegate.value as? MainCoroutineDispatcher)?.immediate ?: this\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) = delegate.value.dispatch(context, block)\n\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = delegate.value.isDispatchNeeded(context)\n\n    override fun dispatchYield(context: CoroutineContext, block: Runnable) = delegate.value.dispatchYield(context, block)\n\n    fun setDispatcher(dispatcher: CoroutineDispatcher) {\n        delegate.value = dispatcher\n    }\n\n    fun resetDispatcher() {\n        delegate.value = mainDispatcher\n    }\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) =\n        delay.scheduleResumeAfterDelay(timeMillis, continuation)\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle =\n        delay.invokeOnTimeout(timeMillis, block, context)\n\n    companion object {\n        internal val currentTestDispatcher\n            get() = (Dispatchers.Main as? TestMainDispatcher)?.delegate?.value as? TestDispatcher\n\n        internal val currentTestScheduler\n            get() = currentTestDispatcher?.scheduler\n    }\n\n    /**\n     * A wrapper around a value that attempts to throw when writing happens concurrently with reading.\n     *\n     * The read operations never throw. Instead, the failures detected inside them will be remembered and thrown on the\n     * next modification.\n     */\n    private class NonConcurrentlyModifiable<T>(initialValue: T, private val name: String) {\n        private val reader: AtomicRef<Throwable?> = atomic(null) // last reader to attempt access\n        private val readers = atomic(0) // number of concurrent readers\n        private val writer: AtomicRef<Throwable?> = atomic(null) // writer currently performing value modification\n        private val exceptionWhenReading: AtomicRef<Throwable?> = atomic(null) // exception from reading\n        private val _value = atomic(initialValue) // the backing field for the value\n\n        private fun concurrentWW(location: Throwable) = IllegalStateException(\"$name is modified concurrently\", location)\n        private fun concurrentRW(location: Throwable) = IllegalStateException(\"$name is used concurrently with setting it\", location)\n\n        var value: T\n            get() {\n                reader.value = Throwable(\"reader location\")\n                readers.incrementAndGet()\n                writer.value?.let { exceptionWhenReading.value = concurrentRW(it) }\n                val result = _value.value\n                readers.decrementAndGet()\n                return result\n            }\n            set(value) {\n                exceptionWhenReading.getAndSet(null)?.let { throw it }\n                if (readers.value != 0) reader.value?.let { throw concurrentRW(it) }\n                val writerLocation = Throwable(\"other writer location\")\n                writer.getAndSet(writerLocation)?.let { throw concurrentWW(it) }\n                _value.value = value\n                writer.compareAndSet(writerLocation, null)\n                if (readers.value != 0) reader.value?.let { throw concurrentRW(it) }\n            }\n    }\n}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\nprivate val defaultDelay\n    inline get() = DefaultDelay\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\ninternal expect fun Dispatchers.getTestMainDispatcher(): TestMainDispatcher\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/test/Helpers.kt",
        "content": "package kotlinx.coroutines.test\n\n/**\n * Runs [test], and then invokes [block], passing to it the lambda that functionally behaves\n * the same way [test] does.\n */\nfun testResultMap(block: (() -> Unit) -> Unit, test: () -> TestResult): TestResult = testResultChain(\n    block = test,\n    after = {\n        block { it.getOrThrow() }\n        createTestResult { }\n    }\n)\n\n/**\n * Chains together [block] and [after], passing the result of [block] to [after].\n */\nexpect fun testResultChain(block: () -> TestResult, after: (Result<Unit>) -> TestResult): TestResult\n\nfun testResultChain(vararg chained: (Result<Unit>) -> TestResult, initialResult: Result<Unit> = Result.success(Unit)): TestResult =\n    if (chained.isEmpty()) {\n        createTestResult {\n            initialResult.getOrThrow()\n        }\n    } else {\n        testResultChain(block = {\n            chained[0](initialResult)\n        }) {\n            testResultChain(*chained.drop(1).toTypedArray(), initialResult = it)\n        }\n    }\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/test/RunTestTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\nimport kotlin.test.assertFailsWith\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nclass RunTestTest {\n\n    /** Tests that [withContext] that sends work to other threads works in [runTest]. */\n    @Test\n    fun testWithContextDispatching() = runTest {\n        var counter = 0\n        withContext(Dispatchers.Default) {\n            counter += 1\n        }\n        assertEquals(counter, 1)\n    }\n\n    /** Tests that joining [GlobalScope.launch] works in [runTest]. */\n    @Test\n    fun testJoiningForkedJob() = runTest {\n        var counter = 0\n        val job = GlobalScope.launch {\n            counter += 1\n        }\n        job.join()\n        assertEquals(counter, 1)\n    }\n\n    /** Tests [suspendCoroutine] not failing [runTest]. */\n    @Test\n    fun testSuspendCoroutine() = runTest {\n        val answer = suspendCoroutine<Int> {\n            it.resume(42)\n        }\n        assertEquals(42, answer)\n    }\n\n    /** Tests that [runTest] attempts to detect it being run inside another [runTest] and failing in such scenarios. */\n    @Test\n    fun testNestedRunTestForbidden() = runTest {\n        assertFailsWith<IllegalStateException> {\n            runTest { }\n        }\n    }\n\n    /** Tests that even the dispatch timeout of `0` is fine if all the dispatches go through the same scheduler. */\n    @Test\n    fun testRunTestWithZeroDispatchTimeoutWithControlledDispatches() = runTest(dispatchTimeoutMs = 0) {\n        // below is some arbitrary concurrent code where all dispatches go through the same scheduler.\n        launch {\n            delay(2000)\n        }\n        val deferred = async {\n            val job = launch(StandardTestDispatcher(testScheduler)) {\n                launch {\n                    delay(500)\n                }\n                delay(1000)\n            }\n            job.join()\n        }\n        deferred.await()\n    }\n\n    /** Tests that too low of a dispatch timeout causes crashes. */\n    @Test\n    fun testRunTestWithSmallDispatchTimeout() = testResultMap({ fn ->\n        try {\n            fn()\n            fail(\"shouldn't be reached\")\n        } catch (e: Throwable) {\n            assertIs<UncompletedCoroutinesError>(e)\n        }\n    }) {\n        runTest(dispatchTimeoutMs = 100) {\n            withContext(Dispatchers.Default) {\n                delay(10000)\n                3\n            }\n            fail(\"shouldn't be reached\")\n        }\n    }\n\n    /**\n     * Tests that [runTest] times out after the specified time.\n     */\n    @Test\n    fun testRunTestWithSmallTimeout() = testResultMap({ fn ->\n        try {\n            fn()\n            fail(\"shouldn't be reached\")\n        } catch (e: Throwable) {\n            assertIs<UncompletedCoroutinesError>(e)\n        }\n    }) {\n        runTest(timeout = 100.milliseconds) {\n            withContext(Dispatchers.Default) {\n                delay(10000)\n                3\n            }\n            fail(\"shouldn't be reached\")\n        }\n    }\n\n    /** Tests that [runTest] times out after the specified time, even if the test framework always knows the test is\n     * still doing something. */\n    @Test\n    fun testRunTestWithSmallTimeoutAndManyDispatches() = testResultMap({ fn ->\n        try {\n            fn()\n            fail(\"shouldn't be reached\")\n        } catch (e: Throwable) {\n            assertIs<UncompletedCoroutinesError>(e)\n        }\n    }) {\n        runTest(timeout = 100.milliseconds) {\n            while (true) {\n                withContext(Dispatchers.Default) {\n                    delay(10)\n                    3\n                }\n            }\n        }\n    }\n\n    /** Tests that, on timeout, the names of the active coroutines are listed,\n     * whereas the names of the completed ones are not. */\n    @Test\n    @NoJs\n    @NoNative\n    fun testListingActiveCoroutinesOnTimeout(): TestResult {\n        val name1 = \"GoodUniqueName\"\n        val name2 = \"BadUniqueName\"\n        return testResultMap({\n            try {\n                it()\n                fail(\"unreached\")\n            } catch (e: UncompletedCoroutinesError) {\n                assertContains(e.message ?: \"\", name1)\n                assertFalse((e.message ?: \"\").contains(name2))\n            }\n        }) {\n            runTest(dispatchTimeoutMs = 10) {\n                launch(CoroutineName(name1)) {\n                    CompletableDeferred<Unit>().await()\n                }\n                launch(CoroutineName(name2)) {\n                }\n            }\n        }\n    }\n\n    /** Tests that the [UncompletedCoroutinesError] suppresses an exception with which the coroutine is completing. */\n    @Test\n    fun testFailureWithPendingCoroutine() = testResultMap({\n        try {\n            it()\n            fail(\"unreached\")\n        } catch (e: UncompletedCoroutinesError) {\n            @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n            val suppressed = unwrap(e).suppressedExceptions\n            assertEquals(1, suppressed.size, \"$suppressed\")\n            assertIs<TestException>(suppressed[0]).also {\n                assertEquals(\"A\", it.message)\n            }\n        }\n    }) {\n        runTest(timeout = 10.milliseconds) {\n            launch(start = CoroutineStart.UNDISPATCHED) {\n                withContext(NonCancellable + Dispatchers.Default) {\n                    delay(100.milliseconds)\n                }\n            }\n            throw TestException(\"A\")\n        }\n    }\n\n    /** Tests that real delays can be accounted for with a large enough dispatch timeout. */\n    @Test\n    fun testRunTestWithLargeDispatchTimeout() = runTest(dispatchTimeoutMs = 5000) {\n        withContext(Dispatchers.Default) {\n            delay(50)\n        }\n    }\n\n    /** Tests that delays can be accounted for with a large enough timeout. */\n    @Test\n    fun testRunTestWithLargeTimeout() = runTest(timeout = 5000.milliseconds) {\n        withContext(Dispatchers.Default) {\n            delay(50)\n        }\n    }\n\n    /** Tests uncaught exceptions being suppressed by the dispatch timeout error. */\n    @Test\n    fun testRunTestTimingOutAndThrowing() = testResultMap({ fn ->\n        try {\n            fn()\n            fail(\"unreached\")\n        } catch (e: UncompletedCoroutinesError) {\n            @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n            val suppressed = unwrap(e).suppressedExceptions\n            assertEquals(1, suppressed.size, \"$suppressed\")\n            assertIs<TestException>(suppressed[0]).also {\n                assertEquals(\"A\", it.message)\n            }\n        }\n    }) {\n        runTest(timeout = 100.milliseconds) {\n            coroutineContext[CoroutineExceptionHandler]!!.handleException(coroutineContext, TestException(\"A\"))\n            withContext(Dispatchers.Default) {\n                delay(10000)\n                3\n            }\n            fail(\"shouldn't be reached\")\n        }\n    }\n\n    /** Tests that passing invalid contexts to [runTest] causes it to fail (on JS, without forking). */\n    @Test\n    fun testRunTestWithIllegalContext() {\n        for (ctx in TestScopeTest.invalidContexts) {\n            assertFailsWith<IllegalArgumentException> {\n                runTest(ctx) { }\n            }\n        }\n    }\n\n    /** Tests that throwing exceptions in [runTest] fails the test with them. */\n    @Test\n    fun testThrowingInRunTestBody() = testResultMap({\n        assertFailsWith<RuntimeException> { it() }\n    }) {\n        runTest {\n            throw RuntimeException()\n        }\n    }\n\n    /** Tests that throwing exceptions in pending tasks [runTest] fails the test with them. */\n    @Test\n    fun testThrowingInRunTestPendingTask() = testResultMap({\n        assertFailsWith<RuntimeException> { it() }\n    }) {\n        runTest {\n            launch {\n                delay(SLOW)\n                throw RuntimeException()\n            }\n        }\n    }\n\n    @Test\n    fun reproducer2405() = runTest {\n        val dispatcher = StandardTestDispatcher(testScheduler)\n        var collectedError = false\n        withContext(dispatcher) {\n            flow { emit(1) }\n                .combine(\n                    flow<String> { throw IllegalArgumentException() }\n                ) { int, string -> int.toString() + string }\n                .catch { emit(\"error\") }\n                .collect {\n                    assertEquals(\"error\", it)\n                    collectedError = true\n                }\n        }\n        assertTrue(collectedError)\n    }\n\n    /** Tests that, once the test body has thrown, the child coroutines are cancelled. */\n    @Test\n    fun testChildrenCancellationOnTestBodyFailure(): TestResult {\n        var job: Job? = null\n        return testResultMap({\n            assertFailsWith<AssertionError> { it() }\n            assertTrue(job!!.isCancelled)\n        }) {\n            runTest {\n                job = launch {\n                    while (true) {\n                        delay(1000)\n                    }\n                }\n                throw AssertionError()\n            }\n        }\n    }\n\n    /** Tests that [runTest] reports [TimeoutCancellationException]. */\n    @Test\n    fun testTimeout() = testResultMap({\n        assertFailsWith<TimeoutCancellationException> { it() }\n    }) {\n        runTest {\n            withTimeout(50) {\n                launch {\n                    delay(1000)\n                }\n            }\n        }\n    }\n\n    /** Checks that [runTest] throws the root cause and not [JobCancellationException] when a child coroutine throws. */\n    @Test\n    fun testRunTestThrowsRootCause() = testResultMap({\n        assertFailsWith<TestException> { it() }\n    }) {\n        runTest {\n            launch {\n                throw TestException()\n            }\n        }\n    }\n\n    /** Tests that [runTest] completes its job. */\n    @Test\n    fun testCompletesOwnJob(): TestResult {\n        var handlerCalled = false\n        return testResultMap({\n            it()\n            assertTrue(handlerCalled)\n        }) {\n            runTest {\n                coroutineContext.job.invokeOnCompletion {\n                    handlerCalled = true\n                }\n            }\n        }\n    }\n\n    /** Tests that [runTest] doesn't complete the job that was passed to it as an argument. */\n    @Test\n    fun testDoesNotCompleteGivenJob(): TestResult {\n        var handlerCalled = false\n        val job = Job()\n        job.invokeOnCompletion {\n            handlerCalled = true\n        }\n        return testResultMap({\n            it()\n            assertFalse(handlerCalled)\n            assertEquals(0, job.children.filter { it.isActive }.count())\n        }) {\n            runTest(job) {\n                assertTrue(coroutineContext.job in job.children)\n            }\n        }\n    }\n\n    /** Tests that, when the test body fails, the reported exceptions are suppressed. */\n    @Test\n    fun testSuppressedExceptions() = testResultMap({\n        try {\n            it()\n            fail(\"should not be reached\")\n        } catch (e: TestException) {\n            assertEquals(\"w\", e.message)\n            val suppressed = e.suppressedExceptions +\n                (e.suppressedExceptions.firstOrNull()?.suppressedExceptions ?: emptyList())\n            assertEquals(3, suppressed.size)\n            assertEquals(\"x\", suppressed[0].message)\n            assertEquals(\"y\", suppressed[1].message)\n            assertEquals(\"z\", suppressed[2].message)\n        }\n    }) {\n        runTest {\n            launch(SupervisorJob()) { throw TestException(\"x\") }\n            launch(SupervisorJob()) { throw TestException(\"y\") }\n            launch(SupervisorJob()) { throw TestException(\"z\") }\n            throw TestException(\"w\")\n        }\n    }\n\n    /** Tests that [TestScope.runTest] does not inherit the exception handler and works. */\n    @Test\n    fun testScopeRunTestExceptionHandler(): TestResult {\n        val scope = TestScope()\n        return testResultMap({\n            try {\n                it()\n                fail(\"should not be reached\")\n            } catch (e: TestException) {\n                // expected\n            }\n        }) {\n            scope.runTest {\n                launch(SupervisorJob()) { throw TestException(\"x\") }\n            }\n        }\n    }\n\n    /**\n     * Tests that if the main coroutine is completed without a dispatch, [runTest] will not consider this to be\n     * inactivity.\n     *\n     * The test will hang if this is not the case.\n     */\n    @Test\n    fun testCoroutineCompletingWithoutDispatch() = runTest(timeout = Duration.INFINITE) {\n        launch(Dispatchers.Default) { delay(100) }\n    }\n\n    /**\n     * Tests that [runTest] cleans up the exception handler even if it threw on initialization.\n     *\n     * This test must be run manually, because it writes garbage to the log.\n     *\n     * The JVM-only source set contains a test equivalent to this one that isn't ignored.\n     */\n    @Test\n    @Ignore\n    fun testExceptionCaptorCleanedUpOnPreliminaryExit(): TestResult = testResultChain({\n        // step 1: installing the exception handler\n        println(\"step 1\")\n        runTest { }\n    }, {\n        it.getOrThrow()\n        // step 2: throwing an uncaught exception to be caught by the exception-handling system\n        println(\"step 2\")\n        createTestResult {\n            launch(NonCancellable) { throw TestException(\"A\") }\n        }\n    }, {\n        it.getOrThrow()\n        // step 3: trying to run a test should immediately fail, even before entering the test body\n        println(\"step 3\")\n        try {\n            runTest {\n                fail(\"unreached\")\n            }\n            fail(\"unreached\")\n        } catch (e: UncaughtExceptionsBeforeTest) {\n            val cause = e.suppressedExceptions.single()\n            assertIs<TestException>(cause)\n            assertEquals(\"A\", cause.message)\n        }\n        // step 4: trying to run a test again should not fail with an exception\n        println(\"step 4\")\n        runTest {\n        }\n    }, {\n        it.getOrThrow()\n        // step 5: throwing an uncaught exception to be caught by the exception-handling system, again\n        println(\"step 5\")\n        createTestResult {\n            launch(NonCancellable) { throw TestException(\"B\") }\n        }\n    }, {\n        it.getOrThrow()\n        // step 6: trying to run a test should immediately fail, again\n        println(\"step 6\")\n        try {\n            runTest {\n                fail(\"unreached\")\n            }\n            fail(\"unreached\")\n        } catch (e: Exception) {\n            val cause = e.suppressedExceptions.single()\n            assertIs<TestException>(cause)\n            assertEquals(\"B\", cause.message)\n        }\n        // step 7: trying to run a test again should not fail with an exception, again\n        println(\"step 7\")\n        runTest {\n        }\n    })\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/test/StandardTestDispatcherTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\n\nclass StandardTestDispatcherTest: OrderedExecutionTestBase() {\n\n    private val scope = TestScope(StandardTestDispatcher())\n\n    @BeforeTest\n    fun init() {\n        scope.asSpecificImplementation().enter()\n    }\n\n    @AfterTest\n    fun cleanup() {\n        scope.runCurrent()\n        assertEquals(listOf(), scope.asSpecificImplementation().legacyLeave())\n    }\n\n    /** Tests that the [StandardTestDispatcher] follows an execution order similar to `runBlocking`. */\n    @Test\n    fun testFlowsNotSkippingValues() = scope.launch {\n        // https://github.com/Kotlin/kotlinx.coroutines/issues/1626#issuecomment-554632852\n        val list = flowOf(1).onStart { emit(0) }\n            .combine(flowOf(\"A\")) { int, str -> \"$str$int\" }\n            .toList()\n        assertEquals(list, listOf(\"A0\", \"A1\"))\n    }.void()\n\n    /** Tests that each [launch] gets dispatched. */\n    @Test\n    fun testLaunchDispatched() = scope.launch {\n        expect(1)\n        launch {\n            expect(3)\n        }\n        finish(2)\n    }.void()\n\n    /** Tests that dispatching is done in a predictable order and [yield] puts this task at the end of the queue. */\n    @Test\n    fun testYield() = scope.launch {\n        expect(1)\n        scope.launch {\n            expect(3)\n            yield()\n            expect(6)\n        }\n        scope.launch {\n            expect(4)\n            yield()\n            finish(7)\n        }\n        expect(2)\n        yield()\n        expect(5)\n    }.void()\n\n    /** Tests that the [TestCoroutineScheduler] used for [Dispatchers.Main] gets used by default. */\n    @Test\n    fun testSchedulerReuse() {\n        val dispatcher1 = StandardTestDispatcher()\n        Dispatchers.setMain(dispatcher1)\n        try {\n            val dispatcher2 = StandardTestDispatcher()\n            assertSame(dispatcher1.scheduler, dispatcher2.scheduler)\n        } finally {\n            Dispatchers.resetMain()\n        }\n    }\n\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/test/TestCoroutineSchedulerTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\nimport kotlin.test.assertFailsWith\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.seconds\nimport kotlin.time.Duration.Companion.milliseconds\n\nclass TestCoroutineSchedulerTest {\n    /** Tests that `TestCoroutineScheduler` attempts to detect if there are several instances of it. */\n    @Test\n    fun testContextElement() = runTest {\n        assertFailsWith<IllegalStateException> {\n            withContext(StandardTestDispatcher()) {\n            }\n        }\n    }\n\n    /** Tests that, as opposed to [DelayController.advanceTimeBy] or [TestCoroutineScope.advanceTimeBy],\n     * [TestCoroutineScheduler.advanceTimeBy] doesn't run the tasks scheduled at the target moment. */\n    @Test\n    fun testAdvanceTimeByDoesNotRunCurrent() = runTest {\n        var entered = false\n        launch {\n            delay(15)\n            entered = true\n        }\n        testScheduler.advanceTimeBy(15.milliseconds)\n        assertFalse(entered)\n        testScheduler.runCurrent()\n        assertTrue(entered)\n    }\n\n    /** Tests that [TestCoroutineScheduler.advanceTimeBy] doesn't accept negative delays. */\n    @Test\n    fun testAdvanceTimeByWithNegativeDelay() {\n        val scheduler = TestCoroutineScheduler()\n        assertFailsWith<IllegalArgumentException> {\n            scheduler.advanceTimeBy((-1).milliseconds)\n        }\n    }\n\n    /** Tests that if [TestCoroutineScheduler.advanceTimeBy] encounters an arithmetic overflow, all the tasks scheduled\n     * until the moment [Long.MAX_VALUE] get run. */\n    @Test\n    fun testAdvanceTimeByEnormousDelays() = forTestDispatchers {\n        assertRunsFast {\n            with (TestScope(it)) {\n                launch {\n                    val initialDelay = 10L\n                    delay(initialDelay)\n                    assertEquals(initialDelay, currentTime)\n                    var enteredInfinity = false\n                    launch {\n                        delay(Long.MAX_VALUE - 1) // delay(Long.MAX_VALUE) does nothing\n                        assertEquals(Long.MAX_VALUE, currentTime)\n                        enteredInfinity = true\n                    }\n                    var enteredNearInfinity = false\n                    launch {\n                        delay(Long.MAX_VALUE - initialDelay - 1)\n                        assertEquals(Long.MAX_VALUE - 1, currentTime)\n                        enteredNearInfinity = true\n                    }\n                    testScheduler.advanceTimeBy(Duration.INFINITE)\n                    assertFalse(enteredInfinity)\n                    assertTrue(enteredNearInfinity)\n                    assertEquals(Long.MAX_VALUE, currentTime)\n                    testScheduler.runCurrent()\n                    assertTrue(enteredInfinity)\n                }\n                testScheduler.advanceUntilIdle()\n            }\n        }\n    }\n\n    /** Tests the basic functionality of [TestCoroutineScheduler.advanceTimeBy]. */\n    @Test\n    fun testAdvanceTimeBy() = runTest {\n        assertRunsFast {\n            var stage = 1\n            launch {\n                delay(1_000)\n                assertEquals(1_000, currentTime)\n                stage = 2\n                delay(500)\n                assertEquals(1_500, currentTime)\n                stage = 3\n                delay(501)\n                assertEquals(2_001, currentTime)\n                stage = 4\n            }\n            assertEquals(1, stage)\n            assertEquals(0, currentTime)\n            advanceTimeBy(2.seconds)\n            assertEquals(3, stage)\n            assertEquals(2_000, currentTime)\n            advanceTimeBy(2.milliseconds)\n            assertEquals(4, stage)\n            assertEquals(2_002, currentTime)\n        }\n    }\n\n    /** Tests the basic functionality of [TestCoroutineScheduler.runCurrent]. */\n    @Test\n    fun testRunCurrent() = runTest {\n        var stage = 0\n        launch {\n            delay(1)\n            ++stage\n            delay(1)\n            stage += 10\n        }\n        launch {\n            delay(1)\n            ++stage\n            delay(1)\n            stage += 10\n        }\n        testScheduler.advanceTimeBy(1.milliseconds)\n        assertEquals(0, stage)\n        runCurrent()\n        assertEquals(2, stage)\n        testScheduler.advanceTimeBy(1.milliseconds)\n        assertEquals(2, stage)\n        runCurrent()\n        assertEquals(22, stage)\n    }\n\n    /** Tests that [TestCoroutineScheduler.runCurrent] will not run new tasks after the current time has advanced. */\n    @Test\n    fun testRunCurrentNotDrainingQueue() = forTestDispatchers {\n        assertRunsFast {\n            val scheduler = it.scheduler\n            val scope = TestScope(it)\n            var stage = 1\n            scope.launch {\n                delay(SLOW)\n                launch {\n                    delay(SLOW)\n                    stage = 3\n                }\n                scheduler.advanceTimeBy(SLOW.milliseconds)\n                stage = 2\n            }\n            scheduler.advanceTimeBy(SLOW.milliseconds)\n            assertEquals(1, stage)\n            scheduler.runCurrent()\n            assertEquals(2, stage)\n            scheduler.runCurrent()\n            assertEquals(3, stage)\n        }\n    }\n\n    /** Tests that [TestCoroutineScheduler.advanceUntilIdle] doesn't hang when itself running in a scheduler task. */\n    @Test\n    fun testNestedAdvanceUntilIdle() = forTestDispatchers {\n        assertRunsFast {\n            val scheduler = it.scheduler\n            val scope = TestScope(it)\n            var executed = false\n            scope.launch {\n                launch {\n                    delay(SLOW)\n                    executed = true\n                }\n                scheduler.advanceUntilIdle()\n            }\n            scheduler.advanceUntilIdle()\n            assertTrue(executed)\n        }\n    }\n\n    /** Tests [yield] scheduling tasks for future execution and not executing immediately. */\n    @Test\n    fun testYield() = forTestDispatchers {\n        val scope = TestScope(it)\n        var stage = 0\n        scope.launch {\n            yield()\n            assertEquals(1, stage)\n            stage = 2\n        }\n        scope.launch {\n            yield()\n            assertEquals(2, stage)\n            stage = 3\n        }\n        assertEquals(0, stage)\n        stage = 1\n        scope.runCurrent()\n    }\n\n    /** Tests that dispatching the delayed tasks is ordered by their waking times. */\n    @Test\n    fun testDelaysPriority() = forTestDispatchers {\n        val scope = TestScope(it)\n        var lastMeasurement = 0L\n        fun checkTime(time: Long) {\n            assertTrue(lastMeasurement < time)\n            assertEquals(time, scope.currentTime)\n            lastMeasurement = scope.currentTime\n        }\n        scope.launch {\n            launch {\n                delay(100)\n                checkTime(100)\n                val deferred = async {\n                    delay(70)\n                    checkTime(170)\n                }\n                delay(1)\n                checkTime(101)\n                deferred.await()\n                delay(1)\n                checkTime(171)\n            }\n            launch {\n                delay(200)\n                checkTime(200)\n            }\n            launch {\n                delay(150)\n                checkTime(150)\n                delay(22)\n                checkTime(172)\n            }\n            delay(201)\n        }\n        scope.advanceUntilIdle()\n        checkTime(201)\n    }\n\n    private fun TestScope.checkTimeout(\n        timesOut: Boolean, timeoutMillis: Long = SLOW, block: suspend () -> Unit\n    ) = assertRunsFast {\n        var caughtException = false\n        asSpecificImplementation().enter()\n        launch {\n            try {\n                withTimeout(timeoutMillis) {\n                    block()\n                }\n            } catch (e: TimeoutCancellationException) {\n                caughtException = true\n            }\n        }\n        advanceUntilIdle()\n        throwAll(null, asSpecificImplementation().legacyLeave())\n        if (timesOut)\n            assertTrue(caughtException)\n        else\n            assertFalse(caughtException)\n    }\n\n    /** Tests that timeouts get triggered. */\n    @Test\n    fun testSmallTimeouts() = forTestDispatchers {\n        val scope = TestScope(it)\n        scope.checkTimeout(true) {\n            val half = SLOW / 2\n            delay(half)\n            delay(SLOW - half)\n        }\n    }\n\n    /** Tests that timeouts don't get triggered if the code finishes in time. */\n    @Test\n    fun testLargeTimeouts() = forTestDispatchers {\n        val scope = TestScope(it)\n        scope.checkTimeout(false) {\n            val half = SLOW / 2\n            delay(half)\n            delay(SLOW - half - 1)\n        }\n    }\n\n    /** Tests that timeouts get triggered if the code fails to finish in time asynchronously. */\n    @Test\n    fun testSmallAsynchronousTimeouts() = forTestDispatchers {\n        val scope = TestScope(it)\n        val deferred = CompletableDeferred<Unit>()\n        scope.launch {\n            val half = SLOW / 2\n            delay(half)\n            delay(SLOW - half)\n            deferred.complete(Unit)\n        }\n        scope.checkTimeout(true) {\n            deferred.await()\n        }\n    }\n\n    /** Tests that timeouts don't get triggered if the code finishes in time, even if it does so asynchronously. */\n    @Test\n    fun testLargeAsynchronousTimeouts() = forTestDispatchers {\n        val scope = TestScope(it)\n        val deferred = CompletableDeferred<Unit>()\n        scope.launch {\n            val half = SLOW / 2\n            delay(half)\n            delay(SLOW - half - 1)\n            deferred.complete(Unit)\n        }\n        scope.checkTimeout(false) {\n            deferred.await()\n        }\n    }\n\n    @Test\n    fun testAdvanceTimeSource() = runTest {\n        val expected = 1.seconds\n        val before = testTimeSource.markNow()\n        val actual = testTimeSource.measureTime {\n            delay(expected)\n        }\n        assertEquals(expected, actual)\n        val after = testTimeSource.markNow()\n        assertTrue(before < after)\n        assertEquals(expected, after - before)\n    }\n\n    private fun forTestDispatchers(block: (TestDispatcher) -> Unit): Unit =\n        @Suppress(\"DEPRECATION\")\n        listOf(\n            StandardTestDispatcher(),\n            UnconfinedTestDispatcher()\n        ).forEach {\n            try {\n                block(it)\n            } catch (e: Throwable) {\n                throw RuntimeException(\"Test failed for dispatcher $it\", e)\n            }\n        }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/test/TestDispatchersTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.test.internal.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass TestDispatchersTest: OrderedExecutionTestBase() {\n\n    @BeforeTest\n    fun setUp() {\n        Dispatchers.setMain(StandardTestDispatcher())\n    }\n\n    @AfterTest\n    fun tearDown() {\n        Dispatchers.resetMain()\n    }\n\n    /** Tests that asynchronous execution of tests does not happen concurrently with [AfterTest]. */\n    @Test\n    fun testMainMocking() = runTest {\n        val mainAtStart = TestMainDispatcher.currentTestDispatcher\n        assertNotNull(mainAtStart)\n        withContext(Dispatchers.Main) {\n            delay(10)\n        }\n        withContext(Dispatchers.Default) {\n            delay(10)\n        }\n        withContext(Dispatchers.Main) {\n            delay(10)\n        }\n        assertSame(mainAtStart, TestMainDispatcher.currentTestDispatcher)\n    }\n\n    /** Tests that the mocked [Dispatchers.Main] correctly forwards [Delay] methods. */\n    @Test\n    fun testMockedMainImplementsDelay() = runTest {\n        val main = Dispatchers.Main\n        withContext(main) {\n            delay(10)\n        }\n        withContext(Dispatchers.Default) {\n            delay(10)\n        }\n        withContext(main) {\n            delay(10)\n        }\n    }\n\n    /** Tests that [Distpachers.setMain] fails when called with [Dispatchers.Main]. */\n    @Test\n    fun testSelfSet() {\n        assertFailsWith<IllegalArgumentException> { Dispatchers.setMain(Dispatchers.Main) }\n    }\n\n    @Test\n    fun testImmediateDispatcher() = runTest {\n        Dispatchers.setMain(ImmediateDispatcher())\n        expect(1)\n        withContext(Dispatchers.Main) {\n            expect(3)\n        }\n\n        Dispatchers.setMain(RegularDispatcher())\n        withContext(Dispatchers.Main) {\n            expect(6)\n        }\n\n        finish(7)\n    }\n\n    private inner class ImmediateDispatcher : CoroutineDispatcher() {\n        override fun isDispatchNeeded(context: CoroutineContext): Boolean {\n            expect(2)\n            return false\n        }\n\n        override fun dispatch(context: CoroutineContext, block: Runnable) = throw RuntimeException(\"Shouldn't be reached\")\n    }\n\n    private inner class RegularDispatcher : CoroutineDispatcher() {\n        override fun isDispatchNeeded(context: CoroutineContext): Boolean {\n            expect(4)\n            return true\n        }\n\n        override fun dispatch(context: CoroutineContext, block: Runnable) {\n            expect(5)\n            block.run()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/test/TestScopeTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\nimport kotlin.test.assertFailsWith\nimport kotlin.time.Duration.Companion.milliseconds\n\nclass TestScopeTest {\n    /** Tests failing to create a [TestScope] with incorrect contexts. */\n    @Test\n    fun testCreateThrowsOnInvalidArguments() {\n        for (ctx in invalidContexts) {\n            assertFailsWith<IllegalArgumentException> {\n                TestScope(ctx)\n            }\n        }\n    }\n\n    /** Tests that a newly-created [TestScope] provides the correct scheduler. */\n    @Test\n    fun testCreateProvidesScheduler() {\n        // Creates a new scheduler.\n        run {\n            val scope = TestScope()\n            assertNotNull(scope.coroutineContext[TestCoroutineScheduler])\n        }\n        // Reuses the scheduler that the dispatcher is linked to.\n        run {\n            val dispatcher = StandardTestDispatcher()\n            val scope = TestScope(dispatcher)\n            assertSame(dispatcher.scheduler, scope.coroutineContext[TestCoroutineScheduler])\n        }\n        // Uses the scheduler passed to it.\n        run {\n            val scheduler = TestCoroutineScheduler()\n            val scope = TestScope(scheduler)\n            assertSame(scheduler, scope.coroutineContext[TestCoroutineScheduler])\n            assertSame(scheduler, (scope.coroutineContext[ContinuationInterceptor] as TestDispatcher).scheduler)\n        }\n        // Doesn't touch the passed dispatcher and the scheduler if they match.\n        run {\n            val scheduler = TestCoroutineScheduler()\n            val dispatcher = StandardTestDispatcher(scheduler)\n            val scope = TestScope(scheduler + dispatcher)\n            assertSame(scheduler, scope.coroutineContext[TestCoroutineScheduler])\n            assertSame(dispatcher, scope.coroutineContext[ContinuationInterceptor])\n        }\n    }\n\n    /** Part of [testCreateProvidesScheduler], disabled for Native */\n    @Test\n    fun testCreateReusesScheduler() {\n        // Reuses the scheduler of `Dispatchers.Main`\n        run {\n            val scheduler = TestCoroutineScheduler()\n            val mainDispatcher = StandardTestDispatcher(scheduler)\n            Dispatchers.setMain(mainDispatcher)\n            try {\n                val scope = TestScope()\n                assertSame(scheduler, scope.coroutineContext[TestCoroutineScheduler])\n                assertNotSame(mainDispatcher, scope.coroutineContext[ContinuationInterceptor])\n            } finally {\n                Dispatchers.resetMain()\n            }\n        }\n        // Does not reuse the scheduler of `Dispatchers.Main` if one is explicitly passed\n        run {\n            val mainDispatcher = StandardTestDispatcher()\n            Dispatchers.setMain(mainDispatcher)\n            try {\n                val scheduler = TestCoroutineScheduler()\n                val scope = TestScope(scheduler)\n                assertSame(scheduler, scope.coroutineContext[TestCoroutineScheduler])\n                assertNotSame(mainDispatcher.scheduler, scope.coroutineContext[TestCoroutineScheduler])\n                assertNotSame(mainDispatcher, scope.coroutineContext[ContinuationInterceptor])\n            } finally {\n                Dispatchers.resetMain()\n            }\n        }\n    }\n\n    /** Tests that the cleanup procedure throws if there were uncompleted delays by the end. */\n    @Test\n    fun testPresentDelaysThrowing() {\n        val scope = TestScope()\n        var result = false\n        scope.launch {\n            delay(5)\n            result = true\n        }\n        assertFalse(result)\n        scope.asSpecificImplementation().enter()\n        assertFailsWith<UncompletedCoroutinesError> { scope.asSpecificImplementation().legacyLeave() }\n        assertFalse(result)\n    }\n\n    /** Tests that the cleanup procedure throws if there were active jobs by the end. */\n    @Test\n    fun testActiveJobsThrowing() {\n        val scope = TestScope()\n        var result = false\n        val deferred = CompletableDeferred<String>()\n        scope.launch {\n            deferred.await()\n            result = true\n        }\n        assertFalse(result)\n        scope.asSpecificImplementation().enter()\n        assertFailsWith<UncompletedCoroutinesError> { scope.asSpecificImplementation().legacyLeave() }\n        assertFalse(result)\n    }\n\n    /** Tests that the cleanup procedure throws even if it detects that the job is already cancelled. */\n    @Test\n    fun testCancelledDelaysThrowing() {\n        val scope = TestScope()\n        var result = false\n        val deferred = CompletableDeferred<String>()\n        val job = scope.launch {\n            deferred.await()\n            result = true\n        }\n        job.cancel()\n        assertFalse(result)\n        scope.asSpecificImplementation().enter()\n        assertFailsWith<UncompletedCoroutinesError> { scope.asSpecificImplementation().legacyLeave() }\n        assertFalse(result)\n    }\n\n    /** Tests that uncaught exceptions are thrown at the cleanup. */\n    @Test\n    fun testGetsCancelledOnChildFailure(): TestResult {\n        val scope = TestScope()\n        val exception = TestException(\"test\")\n        scope.launch {\n            throw exception\n        }\n        return testResultMap({\n            try {\n                it()\n                fail(\"should not reach\")\n            } catch (e: TestException) {\n                // expected\n            }\n        }) {\n            scope.runTest {\n            }\n        }\n    }\n\n    /** Tests that, when reporting several exceptions, the first one is thrown, with the rest suppressed. */\n    @Test\n    fun testSuppressedExceptions() {\n        TestScope().apply {\n            asSpecificImplementation().enter()\n            launch(SupervisorJob()) { throw TestException(\"x\") }\n            launch(SupervisorJob()) { throw TestException(\"y\") }\n            launch(SupervisorJob()) { throw TestException(\"z\") }\n            runCurrent()\n            val e = asSpecificImplementation().legacyLeave()\n            assertEquals(3, e.size)\n            assertEquals(\"x\", e[0].message)\n            assertEquals(\"y\", e[1].message)\n            assertEquals(\"z\", e[2].message)\n        }\n    }\n\n    /** Tests that the background work is being run at all. */\n    @Test\n    fun testBackgroundWorkBeingRun(): TestResult = runTest {\n        var i = 0\n        var j = 0\n        backgroundScope.launch {\n            ++i\n        }\n        backgroundScope.launch {\n            delay(10)\n            ++j\n        }\n        assertEquals(0, i)\n        assertEquals(0, j)\n        delay(1)\n        assertEquals(1, i)\n        assertEquals(0, j)\n        delay(10)\n        assertEquals(1, i)\n        assertEquals(1, j)\n    }\n\n    /**\n     * Tests that the background work gets cancelled after the test body finishes.\n     */\n    @Test\n    fun testBackgroundWorkCancelled(): TestResult {\n        var cancelled = false\n        return testResultMap({\n            it()\n            assertTrue(cancelled)\n        }) {\n            runTest {\n                var i = 0\n                backgroundScope.launch {\n                    try {\n                        while (isActive) {\n                            ++i\n                            yield()\n                        }\n                    } catch (e: CancellationException) {\n                        cancelled = true\n                    }\n                }\n                repeat(5) {\n                    assertEquals(i, it)\n                    yield()\n                }\n            }\n        }\n    }\n\n    /** Tests the interactions between the time-control commands and the background work. */\n    @Test\n    fun testBackgroundWorkTimeControl(): TestResult = runTest {\n        var i = 0\n        var j = 0\n        backgroundScope.launch {\n            while (true) {\n                ++i\n                delay(100)\n            }\n        }\n        backgroundScope.launch {\n            while (true) {\n                ++j\n                delay(50)\n            }\n        }\n        advanceUntilIdle() // should do nothing, as only background work is left.\n        assertEquals(0, i)\n        assertEquals(0, j)\n        val job = launch {\n            delay(1)\n            // the background work scheduled for earlier gets executed before the normal work scheduled for later does\n            assertEquals(1, i)\n            assertEquals(1, j)\n        }\n        job.join()\n        advanceTimeBy(199.milliseconds) // should work the same for the background tasks\n        assertEquals(2, i)\n        assertEquals(4, j)\n        advanceUntilIdle() // once again, should do nothing\n        assertEquals(2, i)\n        assertEquals(4, j)\n        runCurrent() // should behave the same way as for the normal work\n        assertEquals(3, i)\n        assertEquals(5, j)\n        launch {\n            delay(1001)\n            assertEquals(13, i)\n            assertEquals(25, j)\n        }\n        advanceUntilIdle() // should execute the normal work, and with that, the background one, too\n    }\n\n    /**\n     * Tests that an error in a background coroutine does not cancel the test, but is reported at the end.\n     */\n    @Test\n    fun testBackgroundWorkErrorReporting(): TestResult {\n        var testFinished = false\n        val exception = RuntimeException(\"x\")\n        return testResultMap({\n            try {\n                it()\n                fail(\"unreached\")\n            } catch (e: Throwable) {\n                assertSame(e, exception)\n                assertTrue(testFinished)\n            }\n        }) {\n            runTest {\n                backgroundScope.launch {\n                    throw exception\n                }\n                delay(1000)\n                testFinished = true\n            }\n        }\n    }\n\n    /**\n     * Tests that the background work gets to finish what it's doing after the test is completed.\n     */\n    @Test\n    fun testBackgroundWorkFinalizing(): TestResult {\n        var taskEnded = 0\n        val nTasks = 10\n        return testResultMap({\n            try {\n                it()\n                fail(\"unreached\")\n            } catch (e: TestException) {\n                assertEquals(2, e.suppressedExceptions.size)\n                assertEquals(nTasks, taskEnded)\n            }\n        }) {\n            runTest {\n                repeat(nTasks) {\n                    backgroundScope.launch {\n                        try {\n                            while (true) {\n                                delay(1)\n                            }\n                        } finally {\n                            ++taskEnded\n                            if (taskEnded <= 2)\n                                throw TestException()\n                        }\n                    }\n                }\n                delay(100)\n                throw TestException()\n            }\n        }\n    }\n\n    /**\n     * Tests using [Flow.stateIn] as a background job.\n     */\n    @Test\n    fun testExampleBackgroundJob1() = runTest {\n        val myFlow = flow {\n            var i = 0\n            while (true) {\n                emit(++i)\n                delay(1)\n            }\n        }\n        val stateFlow = myFlow.stateIn(backgroundScope, SharingStarted.Eagerly, 0)\n        var j = 0\n        repeat(100) {\n            assertEquals(j++, stateFlow.value)\n            delay(1)\n        }\n    }\n\n    /**\n     * A test from the documentation of [TestScope.backgroundScope].\n     */\n    @Test\n    fun testExampleBackgroundJob2() = runTest {\n        val channel = Channel<Int>()\n        backgroundScope.launch {\n            var i = 0\n            while (true) {\n                channel.send(i++)\n            }\n        }\n        repeat(100) {\n            assertEquals(it, channel.receive())\n        }\n    }\n\n    /**\n     * Tests that the test will timeout due to idleness even if some background tasks are running.\n     */\n    @Test\n    fun testBackgroundWorkNotPreventingTimeout(): TestResult = testResultMap({\n        try {\n            it()\n            fail(\"unreached\")\n        } catch (_: UncompletedCoroutinesError) {\n\n        }\n    }) {\n        runTest(timeout = 100.milliseconds) {\n            backgroundScope.launch {\n                while (true) {\n                    yield()\n                }\n            }\n            backgroundScope.launch {\n                while (true) {\n                    delay(1)\n                }\n            }\n            val deferred = CompletableDeferred<Unit>()\n            deferred.await()\n        }\n\n    }\n\n    /**\n     * Tests that the background work will not prevent the test from timing out even in some cases\n     * when the unconfined dispatcher is used.\n     */\n    @Test\n    fun testUnconfinedBackgroundWorkNotPreventingTimeout(): TestResult = testResultMap({\n        try {\n            it()\n            fail(\"unreached\")\n        } catch (_: UncompletedCoroutinesError) {\n\n        }\n    }) {\n        runTest(UnconfinedTestDispatcher(), timeout = 100.milliseconds) {\n            /**\n             * Having a coroutine like this will still cause the test to hang:\n                 backgroundScope.launch {\n                     while (true) {\n                         yield()\n                     }\n                 }\n             * The reason is that even the initial [advanceUntilIdle] will never return in this case.\n             */\n            backgroundScope.launch {\n                while (true) {\n                    delay(1)\n                }\n            }\n            val deferred = CompletableDeferred<Unit>()\n            deferred.await()\n        }\n    }\n\n    /**\n     * Tests that even the exceptions in the background scope that don't typically get reported and need to be queried\n     * (like failures in [async]) will still surface in some simple scenarios.\n     */\n    @Test\n    fun testAsyncFailureInBackgroundReported() = testResultMap({\n        try {\n            it()\n            fail(\"unreached\")\n        } catch (e: TestException) {\n            assertEquals(\"z\", e.message)\n            assertEquals(setOf(\"x\", \"y\"), e.suppressedExceptions.map { it.message }.toSet())\n        }\n    }) {\n        runTest {\n            backgroundScope.async {\n                throw TestException(\"x\")\n            }\n            backgroundScope.produce<Unit> {\n                throw TestException(\"y\")\n            }\n            delay(1)\n            throw TestException(\"z\")\n        }\n    }\n\n    /**\n     * Tests that, if an exception reaches the [TestScope] exception reporting mechanism via several\n     * channels, it will only be reported once.\n     */\n    @Test\n    fun testNoDuplicateExceptions() = testResultMap({\n        try {\n            it()\n            fail(\"unreached\")\n        } catch (e: TestException) {\n            assertEquals(\"y\", e.message)\n            assertEquals(listOf(\"x\"), e.suppressedExceptions.map { it.message })\n        }\n    }) {\n        runTest {\n            backgroundScope.launch {\n                throw TestException(\"x\")\n            }\n            delay(1)\n            throw TestException(\"y\")\n        }\n    }\n\n    /**\n     * Tests that [TestScope.withTimeout] notifies the programmer about using the virtual time.\n     */\n    @Test\n    fun testTimingOutWithVirtualTimeMessage() = runTest {\n        try {\n            withTimeout(1_000_000) {\n                Channel<Unit>().receive()\n            }\n        } catch (e: TimeoutCancellationException) {\n            assertContains(e.message!!, \"virtual\")\n        }\n    }\n\n    /*\n     * Tests that the [TestScope] exception reporting mechanism will report the exceptions that happen between\n     * different tests.\n     *\n     * This test must be run manually, because such exceptions still go through the global exception handler\n     * (as there's no guarantee that another test will happen), and the global exception handler will\n     * log the exceptions or, on Native, crash the test suite.\n     *\n     * The JVM-only source set contains a test equivalent to this one that isn't ignored.\n     */\n    @Test\n    @Ignore\n    fun testReportingStrayUncaughtExceptionsBetweenTests() {\n        val thrown = TestException(\"x\")\n        testResultChain({\n            // register a handler for uncaught exceptions\n            runTest { }\n        }, {\n            GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) {\n                throw thrown\n            }\n            runTest {\n                fail(\"unreached\")\n            }\n        }, {\n            // this `runTest` will not report the exception\n            runTest {\n                when (val exception = it.exceptionOrNull()) {\n                    is UncaughtExceptionsBeforeTest -> {\n                        assertEquals(1, exception.suppressedExceptions.size)\n                        assertSame(exception.suppressedExceptions[0], thrown)\n                    }\n                    else -> fail(\"unexpected exception: $exception\")\n                }\n            }\n        })\n    }\n\n    /**\n     * Tests that the uncaught exceptions that happen during the test are reported.\n     */\n    @Test\n    fun testReportingStrayUncaughtExceptionsDuringTest(): TestResult {\n        val thrown = TestException(\"x\")\n        return testResultChain({ _ ->\n            runTest {\n                val job = launch(Dispatchers.Default + NonCancellable) {\n                    throw thrown\n                }\n                job.join()\n            }\n        }, {\n            runTest {\n                assertEquals(thrown, it.exceptionOrNull())\n            }\n        })\n    }\n\n    companion object {\n        internal val invalidContexts = listOf(\n            Dispatchers.Default, // not a [TestDispatcher]\n            CoroutineExceptionHandler { _, _ -> }, // exception handlers can't be overridden\n            StandardTestDispatcher() + TestCoroutineScheduler(), // the dispatcher is not linked to the scheduler\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/common/test/UnconfinedTestDispatcherTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.test.*\n\nclass UnconfinedTestDispatcherTest {\n\n    @Test\n    fun reproducer1742() {\n        class ObservableValue<T>(initial: T) {\n            var value: T = initial\n                private set\n\n            private val listeners = mutableListOf<(T) -> Unit>()\n\n            fun set(value: T) {\n                this.value = value\n                listeners.forEach { it(value) }\n            }\n\n            fun addListener(listener: (T) -> Unit) {\n                listeners.add(listener)\n            }\n\n            fun removeListener(listener: (T) -> Unit) {\n                listeners.remove(listener)\n            }\n        }\n\n        fun <T> ObservableValue<T>.observe(): Flow<T> =\n            callbackFlow {\n                val listener = { value: T ->\n                    if (!isClosedForSend) {\n                        trySend(value)\n                    }\n                }\n                addListener(listener)\n                listener(value)\n                awaitClose { removeListener(listener) }\n            }\n\n        val intProvider = ObservableValue(0)\n        val stringProvider = ObservableValue(\"\")\n        var data = Pair(0, \"\")\n        val scope = CoroutineScope(UnconfinedTestDispatcher())\n        scope.launch {\n            combine(\n                intProvider.observe(),\n                stringProvider.observe()\n            ) { intValue, stringValue -> Pair(intValue, stringValue) }\n                .collect { pair ->\n                    data = pair\n                }\n        }\n\n        intProvider.set(1)\n        stringProvider.set(\"3\")\n        intProvider.set(2)\n        intProvider.set(3)\n\n        scope.cancel()\n        assertEquals(Pair(3, \"3\"), data)\n    }\n\n    @Test\n    fun reproducer2082() = runTest {\n        val subject1 = MutableStateFlow(1)\n        val subject2 = MutableStateFlow(\"a\")\n        val values = mutableListOf<Pair<Int, String>>()\n\n        val job = launch(UnconfinedTestDispatcher(testScheduler)) {\n            combine(subject1, subject2) { intVal, strVal -> intVal to strVal }\n                .collect {\n                    delay(10000)\n                    values += it\n                }\n        }\n\n        subject1.value = 2\n        delay(10000)\n        subject2.value = \"b\"\n        delay(10000)\n\n        subject1.value = 3\n        delay(10000)\n        subject2.value = \"c\"\n        delay(10000)\n        delay(10000)\n        delay(1)\n\n        job.cancel()\n\n        assertEquals(listOf(Pair(1, \"a\"), Pair(2, \"a\"), Pair(2, \"b\"), Pair(3, \"b\"), Pair(3, \"c\")), values)\n    }\n\n    @Test\n    fun reproducer2405() = createTestResult {\n        val dispatcher = UnconfinedTestDispatcher()\n        var collectedError = false\n        withContext(dispatcher) {\n            flow { emit(1) }\n                .combine(\n                    flow<String> { throw IllegalArgumentException() }\n                ) { int, string -> int.toString() + string }\n                .catch { emit(\"error\") }\n                .collect {\n                    assertEquals(\"error\", it)\n                    collectedError = true\n                }\n        }\n        assertTrue(collectedError)\n    }\n\n    /** An example from the [UnconfinedTestDispatcher] documentation. */\n    @Test\n    fun testUnconfinedDispatcher() = runTest {\n        val values = mutableListOf<Int>()\n        val stateFlow = MutableStateFlow(0)\n        val job = launch(UnconfinedTestDispatcher(testScheduler)) {\n            stateFlow.collect {\n                values.add(it)\n            }\n        }\n        stateFlow.value = 1\n        stateFlow.value = 2\n        stateFlow.value = 3\n        job.cancel()\n        assertEquals(listOf(0, 1, 2, 3), values)\n    }\n\n    /** Tests that child coroutines are eagerly entered. */\n    @Test\n    fun testEagerlyEnteringChildCoroutines() = runTest(UnconfinedTestDispatcher()) {\n        var entered = false\n        val deferred = CompletableDeferred<Unit>()\n        var completed = false\n        launch {\n            entered = true\n            deferred.await()\n            completed = true\n        }\n        assertTrue(entered) // `entered = true` already executed.\n        assertFalse(completed) // however, the child coroutine then suspended, so it is enqueued.\n        deferred.complete(Unit) // resume the coroutine.\n        assertTrue(completed) // now the child coroutine is immediately completed.\n    }\n\n    /** Tests that the [TestCoroutineScheduler] used for [Dispatchers.Main] gets used by default. */\n    @Test\n    fun testSchedulerReuse() {\n        val dispatcher1 = StandardTestDispatcher()\n        Dispatchers.setMain(dispatcher1)\n        try {\n            val dispatcher2 = UnconfinedTestDispatcher()\n            assertSame(dispatcher1.scheduler, dispatcher2.scheduler)\n        } finally {\n            Dispatchers.resetMain()\n        }\n    }\n\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/js/src/TestBuilders.kt",
        "content": "package kotlinx.coroutines.test\nimport kotlinx.coroutines.*\nimport kotlin.js.*\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"ACTUAL_TYPE_ALIAS_TO_CLASS_WITH_DECLARATION_SITE_VARIANCE\")\npublic actual typealias TestResult = Promise<Unit>\n\ninternal actual fun systemPropertyImpl(name: String): String? = null\n\ninternal actual fun createTestResult(testProcedure: suspend CoroutineScope.() -> Unit): TestResult =\n    GlobalScope.promise {\n        testProcedure()\n    }\n\ninternal actual fun dumpCoroutines() { }\n"
    },
    {
        "path": "kotlinx-coroutines-test/js/src/internal/TestMainDispatcher.kt",
        "content": "package kotlinx.coroutines.test.internal\nimport kotlinx.coroutines.*\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\ninternal actual fun Dispatchers.getTestMainDispatcher(): TestMainDispatcher =\n    when (val mainDispatcher = Main) {\n        is TestMainDispatcher -> mainDispatcher\n        else -> TestMainDispatcher(mainDispatcher).also { injectMain(it) }\n    }\n"
    },
    {
        "path": "kotlinx-coroutines-test/js/test/Helpers.kt",
        "content": "package kotlinx.coroutines.test\n\nactual fun testResultChain(block: () -> TestResult, after: (Result<Unit>) -> TestResult): TestResult =\n    block().then(\n        {\n            after(Result.success(Unit))\n        }, {\n            after(Result.failure(it))\n        })\n"
    },
    {
        "path": "kotlinx-coroutines-test/js/test/PromiseTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass PromiseTest {\n    @Test\n    fun testCompletionFromPromise() = runTest {\n        var promiseEntered = false\n        val p = promise {\n            delay(1)\n            promiseEntered = true\n        }\n        delay(2)\n        p.await()\n        assertTrue(promiseEntered)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/src/TestBuildersJvm.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.internal.*\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual typealias TestResult = Unit\n\ninternal actual fun createTestResult(testProcedure: suspend CoroutineScope.() -> Unit) {\n    runBlocking {\n        testProcedure()\n    }\n}\n\ninternal actual fun systemPropertyImpl(name: String): String? =\n    try {\n        System.getProperty(name)\n    } catch (e: SecurityException) {\n        null\n    }\n\ninternal actual fun dumpCoroutines() {\n    @Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n    if (DebugProbesImpl.isInstalled) {\n        DebugProbesImpl.install()\n        try {\n            DebugProbesImpl.dumpCoroutines(System.err)\n            System.err.flush()\n        } finally {\n            DebugProbesImpl.uninstall()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/src/internal/TestMainDispatcherJvm.kt",
        "content": "package kotlinx.coroutines.test.internal\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\n\ninternal class TestMainDispatcherFactory : MainDispatcherFactory {\n\n    override fun createDispatcher(allFactories: List<MainDispatcherFactory>): MainCoroutineDispatcher {\n        val otherFactories = allFactories.filter { it !== this }\n        val secondBestFactory = otherFactories.maxByOrNull { it.loadPriority } ?: MissingMainCoroutineDispatcherFactory\n        val dispatcher = secondBestFactory.tryCreateDispatcher(otherFactories)\n        return TestMainDispatcher(dispatcher)\n    }\n\n    /**\n     * [Int.MAX_VALUE] -- test dispatcher always wins no matter what factories are present in the classpath.\n     * By default, all actions are delegated to the second-priority dispatcher, so that it won't be the issue.\n     */\n    override val loadPriority: Int\n        get() = Int.MAX_VALUE\n}\n\ninternal actual fun Dispatchers.getTestMainDispatcher(): TestMainDispatcher {\n    val mainDispatcher = Main\n    require(mainDispatcher is TestMainDispatcher) { \"TestMainDispatcher is not set as main dispatcher, have $mainDispatcher instead.\" }\n    return mainDispatcher\n}"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/src/migration/DelayController.kt",
        "content": "@file:Suppress(\"DEPRECATION_ERROR\")\n\npackage kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\n\n/**\n * Control the virtual clock time of a [CoroutineDispatcher].\n *\n * Testing libraries may expose this interface to the tests instead of [TestCoroutineDispatcher].\n *\n * This interface is deprecated without replacement.\n * Instead, [TestCoroutineScheduler] is supposed to be used to control the virtual time.\n * Please see the\n * [migration guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md)\n * for an instruction on how to update the code for the new API.\n */\n@ExperimentalCoroutinesApi\n@Deprecated(\n    \"Use `TestCoroutineScheduler` to control virtual time.\",\n    level = DeprecationLevel.ERROR\n)\n// Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\npublic interface DelayController {\n    /**\n     * Returns the current virtual clock-time as it is known to this Dispatcher.\n     *\n     * @return The virtual clock-time\n     */\n    @ExperimentalCoroutinesApi\n    public val currentTime: Long\n\n    /**\n     * Moves the Dispatcher's virtual clock forward by a specified amount of time.\n     *\n     * The amount the clock is progressed may be larger than the requested `delayTimeMillis` if the code under test uses\n     * blocking coroutines.\n     *\n     * The virtual clock time will advance once for each delay resumed until the next delay exceeds the requested\n     * `delayTimeMills`. In the following test, the virtual time will progress by 2_000 then 1 to resume three different\n     * calls to delay.\n     *\n     * ```\n     * @Test\n     * fun advanceTimeTest() = runBlockingTest {\n     *     foo()\n     *     advanceTimeBy(2_000)  // advanceTimeBy(2_000) will progress through the first two delays\n     *     // virtual time is 2_000, next resume is at 2_001\n     *     advanceTimeBy(2)      // progress through the last delay of 501 (note 500ms were already advanced)\n     *     // virtual time is 2_0002\n     * }\n     *\n     * fun CoroutineScope.foo() {\n     *     launch {\n     *         delay(1_000)    // advanceTimeBy(2_000) will progress through this delay (resume @ virtual time 1_000)\n     *         // virtual time is 1_000\n     *         delay(500)      // advanceTimeBy(2_000) will progress through this delay (resume @ virtual time 1_500)\n     *         // virtual time is 1_500\n     *         delay(501)      // advanceTimeBy(2_000) will not progress through this delay (resume @ virtual time 2_001)\n     *         // virtual time is 2_001\n     *     }\n     * }\n     * ```\n     *\n     * @param delayTimeMillis The amount of time to move the CoroutineContext's clock forward.\n     * @return The amount of delay-time that this Dispatcher's clock has been forwarded.\n     */\n    @ExperimentalCoroutinesApi\n    public fun advanceTimeBy(delayTimeMillis: Long): Long\n\n    /**\n     * Immediately execute all pending tasks and advance the virtual clock-time to the last delay.\n     *\n     * If new tasks are scheduled due to advancing virtual time, they will be executed before `advanceUntilIdle`\n     * returns.\n     *\n     * @return the amount of delay-time that this Dispatcher's clock has been forwarded in milliseconds.\n     */\n    @ExperimentalCoroutinesApi\n    public fun advanceUntilIdle(): Long\n\n    /**\n     * Run any tasks that are pending at or before the current virtual clock-time.\n     *\n     * Calling this function will never advance the clock.\n     */\n    @ExperimentalCoroutinesApi\n    public fun runCurrent()\n\n    /**\n     * Call after test code completes to ensure that the dispatcher is properly cleaned up.\n     *\n     * @throws AssertionError if any pending tasks are active, however it will not throw for suspended\n     * coroutines.\n     */\n    @ExperimentalCoroutinesApi\n    @Throws(AssertionError::class)\n    public fun cleanupTestCoroutines()\n\n    /**\n     * Run a block of code in a paused dispatcher.\n     *\n     * By pausing the dispatcher any new coroutines will not execute immediately. After block executes, the dispatcher\n     * will resume auto-advancing.\n     *\n     * This is useful when testing functions that start a coroutine. By pausing the dispatcher assertions or\n     * setup may be done between the time the coroutine is created and started.\n     */\n    @Deprecated(\n        \"Please use a dispatcher that is paused by default, like `StandardTestDispatcher`.\",\n        level = DeprecationLevel.ERROR\n    )\n    // Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\n    public suspend fun pauseDispatcher(block: suspend () -> Unit)\n\n    /**\n     * Pause the dispatcher.\n     *\n     * When paused, the dispatcher will not execute any coroutines automatically, and you must call [runCurrent] or\n     * [advanceTimeBy], or [advanceUntilIdle] to execute coroutines.\n     */\n    @Deprecated(\n        \"Please use a dispatcher that is paused by default, like `StandardTestDispatcher`.\",\n        level = DeprecationLevel.ERROR\n    )\n    // Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\n    public fun pauseDispatcher()\n\n    /**\n     * Resume the dispatcher from a paused state.\n     *\n     * Resumed dispatchers will automatically progress through all coroutines scheduled at the current time. To advance\n     * time and execute coroutines scheduled in the future use, one of [advanceTimeBy],\n     * or [advanceUntilIdle].\n     */\n    @Deprecated(\n        \"Please use a dispatcher that is paused by default, like `StandardTestDispatcher`.\",\n        level = DeprecationLevel.ERROR\n    )\n    // Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\n    public fun resumeDispatcher()\n}\n\ninternal interface SchedulerAsDelayController : DelayController {\n    val scheduler: TestCoroutineScheduler\n\n    /** @suppress */\n    @Deprecated(\n        \"This property delegates to the test scheduler, which may cause confusing behavior unless made explicit.\",\n        ReplaceWith(\"this.scheduler.currentTime\"),\n        level = DeprecationLevel.ERROR\n    )\n    // Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\n    override val currentTime: Long\n        get() = scheduler.currentTime\n\n\n    /** @suppress */\n    @Deprecated(\n        \"This function delegates to the test scheduler, which may cause confusing behavior unless made explicit.\",\n        ReplaceWith(\"this.scheduler.apply { advanceTimeBy(delayTimeMillis); runCurrent() }\"),\n        level = DeprecationLevel.ERROR\n    )\n    // Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\n    override fun advanceTimeBy(delayTimeMillis: Long): Long {\n        val oldTime = scheduler.currentTime\n        scheduler.advanceTimeBy(delayTimeMillis)\n        scheduler.runCurrent()\n        return scheduler.currentTime - oldTime\n    }\n\n    /** @suppress */\n    @Deprecated(\n        \"This function delegates to the test scheduler, which may cause confusing behavior unless made explicit.\",\n        ReplaceWith(\"this.scheduler.advanceUntilIdle()\"),\n        level = DeprecationLevel.ERROR\n    )\n    // Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\n    override fun advanceUntilIdle(): Long {\n        val oldTime = scheduler.currentTime\n        scheduler.advanceUntilIdle()\n        return scheduler.currentTime - oldTime\n    }\n\n    /** @suppress */\n    @Deprecated(\n        \"This function delegates to the test scheduler, which may cause confusing behavior unless made explicit.\",\n        ReplaceWith(\"this.scheduler.runCurrent()\"),\n        level = DeprecationLevel.ERROR\n    )\n    // Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\n    override fun runCurrent(): Unit = scheduler.runCurrent()\n\n    /** @suppress */\n    @ExperimentalCoroutinesApi\n    override fun cleanupTestCoroutines() {\n        // process any pending cancellations or completions, but don't advance time\n        scheduler.runCurrent()\n        if (!scheduler.isIdle(strict = false)) {\n            throw UncompletedCoroutinesError(\n                \"Unfinished coroutines during tear-down. Ensure all coroutines are\" +\n                    \" completed or cancelled by your test.\"\n            )\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/src/migration/TestBuildersDeprecated.kt",
        "content": "@file:Suppress(\"DEPRECATION\")\n@file:JvmName(\"TestBuildersKt\")\n@file:JvmMultifileClass\n\npackage kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.jvm.*\nimport kotlin.time.Duration.Companion.milliseconds\n\n/**\n * Executes a [testBody] inside an immediate execution dispatcher.\n *\n * This method is deprecated in favor of [runTest]. Please see the\n * [migration guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md)\n * for an instruction on how to update the code for the new API.\n *\n * This is similar to [runBlocking] but it will immediately progress past delays and into [launch] and [async] blocks.\n * You can use this to write tests that execute in the presence of calls to [delay] without causing your test to take\n * extra time.\n *\n * ```\n * @Test\n * fun exampleTest() = runBlockingTest {\n *     val deferred = async {\n *         delay(1_000)\n *         async {\n *             delay(1_000)\n *         }.await()\n *     }\n *\n *     deferred.await() // result available immediately\n * }\n *\n * ```\n *\n * This method requires that all coroutines launched inside [testBody] complete, or are cancelled, as part of the test\n * conditions.\n *\n * Unhandled exceptions thrown by coroutines in the test will be re-thrown at the end of the test.\n *\n * @throws AssertionError If the [testBody] does not complete (or cancel) all coroutines that it launches\n * (including coroutines suspended on join/await).\n *\n * @param context additional context elements. If [context] contains [CoroutineDispatcher] or [CoroutineExceptionHandler],\n *        then they must implement [DelayController] and [TestCoroutineExceptionHandler] respectively.\n * @param testBody The code of the unit-test.\n */\n@Deprecated(\n    \"Use `runTest` instead to support completing from other dispatchers. \" +\n        \"Please see the migration guide for details: \" +\n        \"https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md\",\n    level = DeprecationLevel.WARNING\n)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic fun runBlockingTest(\n    context: CoroutineContext = EmptyCoroutineContext,\n    testBody: suspend TestCoroutineScope.() -> Unit\n) {\n    val scope = createTestCoroutineScope(TestCoroutineDispatcher() + SupervisorJob() + context)\n    val scheduler = scope.testScheduler\n    val deferred = scope.async {\n        scope.testBody()\n    }\n    scheduler.advanceUntilIdle()\n    deferred.getCompletionExceptionOrNull()?.let {\n        throw it\n    }\n    scope.cleanupTestCoroutines()\n}\n\n/**\n * A version of [runBlockingTest] that works with [TestScope].\n */\n@Deprecated(\"Use `runTest` instead to support completing from other dispatchers.\", level = DeprecationLevel.WARNING)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic fun runBlockingTestOnTestScope(\n    context: CoroutineContext = EmptyCoroutineContext,\n    testBody: suspend TestScope.() -> Unit\n) {\n    val completeContext = TestCoroutineDispatcher() + SupervisorJob() + context\n    val startJobs = completeContext.activeJobs()\n    val scope = TestScope(completeContext).asSpecificImplementation()\n    scope.enter()\n    scope.start(CoroutineStart.UNDISPATCHED, scope) {\n        scope.testBody()\n    }\n    scope.testScheduler.advanceUntilIdle()\n    val throwable = try {\n        scope.getCompletionExceptionOrNull()\n    } catch (e: IllegalStateException) {\n        null // the deferred was not completed yet; `scope.legacyLeave()` should complain then about unfinished jobs\n    }\n    scope.backgroundScope.cancel()\n    scope.testScheduler.advanceUntilIdleOr { false }\n    throwable?.let {\n        val exceptions = try {\n            scope.legacyLeave()\n        } catch (e: UncompletedCoroutinesError) {\n            listOf()\n        }\n        throwAll(it, exceptions)\n        return\n    }\n    throwAll(null, scope.legacyLeave())\n    val jobs = completeContext.activeJobs() - startJobs\n    if (jobs.isNotEmpty())\n        throw UncompletedCoroutinesError(\"Some jobs were not completed at the end of the test: $jobs\")\n}\n\n/**\n * Convenience method for calling [runBlockingTest] on an existing [TestCoroutineScope].\n *\n * This method is deprecated in favor of [runTest], whereas [TestCoroutineScope] is deprecated in favor of [TestScope].\n * Please see the\n * [migration guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md)\n * for an instruction on how to update the code for the new API.\n */\n@Deprecated(\n    \"Use `runTest` instead to support completing from other dispatchers. \" +\n        \"Please see the migration guide for details: \" +\n        \"https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md\",\n    level = DeprecationLevel.WARNING\n)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic fun TestCoroutineScope.runBlockingTest(block: suspend TestCoroutineScope.() -> Unit): Unit =\n    runBlockingTest(coroutineContext, block)\n\n/**\n * Convenience method for calling [runBlockingTestOnTestScope] on an existing [TestScope].\n */\n@Deprecated(\"Use `runTest` instead to support completing from other dispatchers.\", level = DeprecationLevel.WARNING)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic fun TestScope.runBlockingTest(block: suspend TestScope.() -> Unit): Unit =\n    runBlockingTestOnTestScope(coroutineContext, block)\n\n/**\n * Convenience method for calling [runBlockingTest] on an existing [TestCoroutineDispatcher].\n *\n * This method is deprecated in favor of [runTest], whereas [TestCoroutineScope] is deprecated in favor of [TestScope].\n * Please see the\n * [migration guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md)\n * for an instruction on how to update the code for the new API.\n */\n@Deprecated(\n    \"Use `runTest` instead to support completing from other dispatchers. \" +\n        \"Please see the migration guide for details: \" +\n        \"https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md\",\n    level = DeprecationLevel.WARNING\n)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic fun TestCoroutineDispatcher.runBlockingTest(block: suspend TestCoroutineScope.() -> Unit): Unit =\n    runBlockingTest(this, block)\n\n/**\n * This is an overload of [runTest] that works with [TestCoroutineScope].\n */\n@ExperimentalCoroutinesApi\n@Deprecated(\"Use `runTest` instead.\", level = DeprecationLevel.WARNING)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic fun runTestWithLegacyScope(\n    context: CoroutineContext = EmptyCoroutineContext,\n    dispatchTimeoutMs: Long = DEFAULT_DISPATCH_TIMEOUT_MS,\n    testBody: suspend TestCoroutineScope.() -> Unit\n) {\n    if (context[RunningInRunTest] != null)\n        throw IllegalStateException(\"Calls to `runTest` can't be nested. Please read the docs on `TestResult` for details.\")\n    val testScope = TestBodyCoroutine(createTestCoroutineScope(context + RunningInRunTest))\n    return createTestResult {\n        runTestCoroutineLegacy(\n            testScope,\n            dispatchTimeoutMs.milliseconds,\n            TestBodyCoroutine::tryGetCompletionCause,\n            testBody\n        ) {\n            try {\n                testScope.cleanup()\n                emptyList()\n            } catch (e: UncompletedCoroutinesError) {\n                throw e\n            } catch (e: Throwable) {\n                listOf(e)\n            }\n        }\n    }\n}\n\n/**\n * Runs a test in a [TestCoroutineScope] based on this one.\n *\n * Calls [runTest] using a coroutine context from this [TestCoroutineScope]. The [TestCoroutineScope] used to run the\n * [block] will be different from this one, but will use its [Job] as a parent.\n *\n * Since this function returns [TestResult], in order to work correctly on the JS, its result must be returned\n * immediately from the test body. See the docs for [TestResult] for details.\n */\n@ExperimentalCoroutinesApi\n@Deprecated(\"Use `TestScope.runTest` instead.\", level = DeprecationLevel.WARNING)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic fun TestCoroutineScope.runTest(\n    dispatchTimeoutMs: Long = DEFAULT_DISPATCH_TIMEOUT_MS,\n    block: suspend TestCoroutineScope.() -> Unit\n): TestResult = runTestWithLegacyScope(coroutineContext, dispatchTimeoutMs, block)\n\nprivate class TestBodyCoroutine(\n    private val testScope: TestCoroutineScope,\n) : AbstractCoroutine<Unit>(testScope.coroutineContext, initParentJob = true, active = true), TestCoroutineScope {\n\n    override val testScheduler get() = testScope.testScheduler\n\n    @Deprecated(\n        \"This deprecation is to prevent accidentally calling `cleanupTestCoroutines` in our own code.\",\n        ReplaceWith(\"this.cleanup()\"),\n        DeprecationLevel.ERROR\n    )\n    override fun cleanupTestCoroutines() =\n        throw UnsupportedOperationException(\n            \"Calling `cleanupTestCoroutines` inside `runTest` is prohibited: \" +\n                \"it will be called at the end of the test in any case.\"\n        )\n\n    fun cleanup() = testScope.cleanupTestCoroutines()\n\n    /** Throws an exception if the coroutine is not completing. */\n    fun tryGetCompletionCause(): Throwable? = completionCause\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/src/migration/TestCoroutineDispatcher.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * [CoroutineDispatcher] that performs both immediate and lazy execution of coroutines in tests\n * and uses a [TestCoroutineScheduler] to control its virtual clock.\n *\n * By default, [TestCoroutineDispatcher] is immediate. That means any tasks scheduled to be run without delay are\n * immediately executed. If they were scheduled with a delay, the virtual clock-time must be advanced via one of the\n * methods on the dispatcher's [scheduler].\n *\n * When switched to lazy execution using [pauseDispatcher] any coroutines started via [launch] or [async] will\n * not execute until a call to [DelayController.runCurrent] or the virtual clock-time has been advanced via one of the\n * methods on [DelayController].\n *\n * @see DelayController\n */\n@Deprecated(\"The execution order of `TestCoroutineDispatcher` can be confusing, and the mechanism of \" +\n    \"pausing is typically misunderstood. Please use `StandardTestDispatcher` or `UnconfinedTestDispatcher` instead.\",\n    level = DeprecationLevel.WARNING)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic class TestCoroutineDispatcher(public override val scheduler: TestCoroutineScheduler = TestCoroutineScheduler()):\n    TestDispatcher(), Delay, SchedulerAsDelayController\n{\n    private var dispatchImmediately = true\n        set(value) {\n            field = value\n            if (value) {\n                // there may already be tasks from setup code we need to run\n                scheduler.advanceUntilIdle()\n            }\n        }\n\n    /** @suppress */\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        checkSchedulerInContext(scheduler, context)\n        if (dispatchImmediately) {\n            scheduler.sendDispatchEvent(context)\n            block.run()\n        } else {\n            post(block, context)\n        }\n    }\n\n    /** @suppress */\n    override fun dispatchYield(context: CoroutineContext, block: Runnable) {\n        checkSchedulerInContext(scheduler, context)\n        post(block, context)\n    }\n\n    /** @suppress */\n    override fun toString(): String = \"TestCoroutineDispatcher[scheduler=$scheduler]\"\n\n    private fun post(block: Runnable, context: CoroutineContext) =\n        scheduler.registerEvent(this, 0, block, context) { false }\n\n    /** @suppress */\n    @Deprecated(\n        \"Please use a dispatcher that is paused by default, like `StandardTestDispatcher`.\",\n        level = DeprecationLevel.ERROR\n    )\n    override suspend fun pauseDispatcher(block: suspend () -> Unit) {\n        val previous = dispatchImmediately\n        dispatchImmediately = false\n        try {\n            block()\n        } finally {\n            dispatchImmediately = previous\n        }\n    }\n\n    /** @suppress */\n    @Deprecated(\n        \"Please use a dispatcher that is paused by default, like `StandardTestDispatcher`.\",\n        level = DeprecationLevel.ERROR\n    )\n    override fun pauseDispatcher() {\n        dispatchImmediately = false\n    }\n\n    /** @suppress */\n    @Deprecated(\n        \"Please use a dispatcher that is paused by default, like `StandardTestDispatcher`.\",\n        level = DeprecationLevel.ERROR\n    )\n    override fun resumeDispatcher() {\n        dispatchImmediately = true\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/src/migration/TestCoroutineExceptionHandler.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n/**\n * Access uncaught coroutine exceptions captured during test execution.\n */\n@Deprecated(\n    \"Deprecated for removal without a replacement. \" +\n        \"Consider whether the default mechanism of handling uncaught exceptions is sufficient. \" +\n        \"If not, try writing your own `CoroutineExceptionHandler` and \" +\n        \"please report your use case at https://github.com/Kotlin/kotlinx.coroutines/issues.\",\n    level = DeprecationLevel.ERROR\n)\n// Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\npublic interface UncaughtExceptionCaptor {\n    /**\n     * List of uncaught coroutine exceptions.\n     *\n     * The returned list is a copy of the currently caught exceptions.\n     * During [cleanupTestCoroutines] the first element of this list is rethrown if it is not empty.\n     */\n    public val uncaughtExceptions: List<Throwable>\n\n    /**\n     * Call after the test completes to ensure that there were no uncaught exceptions.\n     *\n     * The first exception in uncaughtExceptions is rethrown. All other exceptions are\n     * printed using [Throwable.printStackTrace].\n     *\n     * @throws Throwable the first uncaught exception, if there are any uncaught exceptions.\n     */\n    public fun cleanupTestCoroutines()\n}\n\n/**\n * An exception handler that captures uncaught exceptions in tests.\n */\n@Suppress(\"DEPRECATION_ERROR\")\n@Deprecated(\n    \"Deprecated for removal without a replacement. \" +\n        \"It may be to define one's own `CoroutineExceptionHandler` if you just need to handle '\" +\n        \"uncaught exceptions without a special `TestCoroutineScope` integration.\", level = DeprecationLevel.ERROR\n)\n// Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\npublic class TestCoroutineExceptionHandler :\n    AbstractCoroutineContextElement(CoroutineExceptionHandler), CoroutineExceptionHandler, UncaughtExceptionCaptor {\n    private val _exceptions = mutableListOf<Throwable>()\n    private val _lock = SynchronizedObject()\n    private var _coroutinesCleanedUp = false\n\n    @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n    override fun handleException(context: CoroutineContext, exception: Throwable) {\n        synchronized(_lock) {\n            if (_coroutinesCleanedUp) {\n                handleUncaughtCoroutineException(context, exception)\n            }\n            _exceptions += exception\n        }\n    }\n\n    public override val uncaughtExceptions: List<Throwable>\n        get() = synchronized(_lock) { _exceptions.toList() }\n\n    public override fun cleanupTestCoroutines() {\n        synchronized(_lock) {\n            _coroutinesCleanedUp = true\n            val exception = _exceptions.firstOrNull() ?: return\n            // log the rest\n            _exceptions.drop(1).forEach { it.printStackTrace() }\n            throw exception\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/src/migration/TestCoroutineScope.kt",
        "content": "@file:Suppress(\"DEPRECATION_ERROR\", \"DEPRECATION\")\n\npackage kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n/**\n * A scope which provides detailed control over the execution of coroutines for tests.\n *\n * This scope is deprecated in favor of [TestScope].\n * Please see the\n * [migration guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md)\n * for an instruction on how to update the code for the new API.\n */\n@ExperimentalCoroutinesApi\n@Deprecated(\"Use `TestScope` in combination with `runTest` instead.\" +\n    \"Please see the migration guide for details: \" +\n    \"https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md\",\n    level = DeprecationLevel.WARNING)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic interface TestCoroutineScope : CoroutineScope {\n    /**\n     * Called after the test completes.\n     *\n     * - It checks that there were no uncaught exceptions caught by its [CoroutineExceptionHandler].\n     *   If there were any, then the first one is thrown, whereas the rest are suppressed by it.\n     * - It runs the tasks pending in the scheduler at the current time. If there are any uncompleted tasks afterwards,\n     *   it fails with [UncompletedCoroutinesError].\n     * - It checks whether some new child [Job]s were created but not completed since this [TestCoroutineScope] was\n     *   created. If so, it fails with [UncompletedCoroutinesError].\n     *\n     * For backward compatibility, if the [CoroutineExceptionHandler] is an [UncaughtExceptionCaptor], its\n     * [TestCoroutineExceptionHandler.cleanupTestCoroutines] behavior is performed.\n     * Likewise, if the [ContinuationInterceptor] is a [DelayController], its [DelayController.cleanupTestCoroutines]\n     * is called.\n     *\n     * @throws Throwable the first uncaught exception, if there are any uncaught exceptions.\n     * @throws AssertionError if any pending tasks are active.\n     * @throws IllegalStateException if called more than once.\n     */\n    @ExperimentalCoroutinesApi\n    @Deprecated(\"Please call `runTest`, which automatically performs the cleanup, instead of using this function.\")\n    // Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\n    public fun cleanupTestCoroutines()\n\n    /**\n     * The delay-skipping scheduler used by the test dispatchers running the code in this scope.\n     */\n    @ExperimentalCoroutinesApi\n    public val testScheduler: TestCoroutineScheduler\n}\n\nprivate class TestCoroutineScopeImpl(\n    override val coroutineContext: CoroutineContext\n) : TestCoroutineScope {\n    private val lock = SynchronizedObject()\n    private var exceptions = mutableListOf<Throwable>()\n    private var cleanedUp = false\n\n    /**\n     * Reports an exception so that it is thrown on [cleanupTestCoroutines].\n     *\n     * If several exceptions are reported, only the first one will be thrown, and the other ones will be suppressed by\n     * it.\n     *\n     * Returns `false` if [cleanupTestCoroutines] was already called.\n     */\n    fun reportException(throwable: Throwable): Boolean =\n        synchronized(lock) {\n            if (cleanedUp) {\n                false\n            } else {\n                exceptions.add(throwable)\n                true\n            }\n        }\n\n    override val testScheduler: TestCoroutineScheduler\n        get() = coroutineContext[TestCoroutineScheduler]!!\n\n    /** These jobs existed before the coroutine scope was used, so it's alright if they don't get cancelled. */\n    private val initialJobs = coroutineContext.activeJobs()\n\n    @Deprecated(\"Please call `runTest`, which automatically performs the cleanup, instead of using this function.\")\n    override fun cleanupTestCoroutines() {\n        val delayController = coroutineContext.delayController\n        val hasUnfinishedJobs = if (delayController != null) {\n            try {\n                delayController.cleanupTestCoroutines()\n                false\n            } catch (e: UncompletedCoroutinesError) {\n                true\n            }\n        } else {\n            testScheduler.runCurrent()\n            !testScheduler.isIdle(strict = false)\n        }\n        (coroutineContext[CoroutineExceptionHandler] as? UncaughtExceptionCaptor)?.cleanupTestCoroutines()\n        synchronized(lock) {\n            if (cleanedUp)\n                throw IllegalStateException(\"Attempting to clean up a test coroutine scope more than once.\")\n            cleanedUp = true\n        }\n        exceptions.firstOrNull()?.let { toThrow ->\n            exceptions.drop(1).forEach { toThrow.addSuppressed(it) }\n            throw toThrow\n        }\n        if (hasUnfinishedJobs)\n            throw UncompletedCoroutinesError(\n                \"Unfinished coroutines during teardown. Ensure all coroutines are\" +\n                    \" completed or cancelled by your test.\"\n            )\n        val jobs = coroutineContext.activeJobs()\n        if ((jobs - initialJobs).isNotEmpty())\n            throw UncompletedCoroutinesError(\"Test finished with active jobs: $jobs\")\n    }\n}\n\ninternal fun CoroutineContext.activeJobs(): Set<Job> {\n    return checkNotNull(this[Job]).children.filter { it.isActive }.toSet()\n}\n\n/**\n * A coroutine scope for launching test coroutines using [TestCoroutineDispatcher].\n *\n * [createTestCoroutineScope] is a similar function that defaults to [StandardTestDispatcher].\n */\n@Deprecated(\n    \"This constructs a `TestCoroutineScope` with a deprecated `CoroutineDispatcher` by default. \" +\n        \"Please use `createTestCoroutineScope` instead.\",\n    ReplaceWith(\n        \"createTestCoroutineScope(TestCoroutineDispatcher() + TestCoroutineExceptionHandler() + context)\",\n        \"kotlin.coroutines.EmptyCoroutineContext\"\n    ),\n    level = DeprecationLevel.WARNING\n)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic fun TestCoroutineScope(context: CoroutineContext = EmptyCoroutineContext): TestCoroutineScope {\n    val scheduler = context[TestCoroutineScheduler] ?: TestCoroutineScheduler()\n    return createTestCoroutineScope(TestCoroutineDispatcher(scheduler) + TestCoroutineExceptionHandler() + context)\n}\n\n/**\n * A coroutine scope for launching test coroutines.\n *\n * This is a function for aiding in migration from [TestCoroutineScope] to [TestScope].\n * Please see the\n * [migration guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md)\n * for an instruction on how to update the code for the new API.\n *\n * It ensures that all the test module machinery is properly initialized.\n * - If [context] doesn't define a [TestCoroutineScheduler] for orchestrating the virtual time used for delay-skipping,\n *   a new one is created, unless either\n *   - a [TestDispatcher] is provided, in which case [TestDispatcher.scheduler] is used;\n *   - at the moment of the creation of the scope, [Dispatchers.Main] is delegated to a [TestDispatcher], in which case\n *     its [TestCoroutineScheduler] is used.\n * - If [context] doesn't have a [ContinuationInterceptor], a [StandardTestDispatcher] is created.\n * - A [CoroutineExceptionHandler] is created that makes [TestCoroutineScope.cleanupTestCoroutines] throw if there were\n *   any uncaught exceptions, or forwards the exceptions further in a platform-specific manner if the cleanup was\n *   already performed when an exception happened. Passing a [CoroutineExceptionHandler] is illegal, unless it's an\n *   [UncaughtExceptionCaptor], in which case the behavior is preserved for the time being for backward compatibility.\n *   If you need to have a specific [CoroutineExceptionHandler], please pass it to [launch] on an already-created\n *   [TestCoroutineScope] and share your use case at\n *   [our issue tracker](https://github.com/Kotlin/kotlinx.coroutines/issues).\n * - If [context] provides a [Job], that job is used for the new scope; otherwise, a [CompletableJob] is created.\n *\n * @throws IllegalArgumentException if [context] has both [TestCoroutineScheduler] and a [TestDispatcher] linked to a\n * different scheduler.\n * @throws IllegalArgumentException if [context] has a [ContinuationInterceptor] that is not a [TestDispatcher].\n * @throws IllegalArgumentException if [context] has an [CoroutineExceptionHandler] that is not an\n * [UncaughtExceptionCaptor].\n */\n@ExperimentalCoroutinesApi\n@Deprecated(\n    \"This function was introduced in order to help migrate from TestCoroutineScope to TestScope. \" +\n        \"Please use TestScope() construction instead, or just runTest(), without creating a scope.\",\n    level = DeprecationLevel.WARNING\n)\n// Since 1.6.0, kept as warning in 1.7.0, ERROR in 1.8.0 and removed as experimental in 1.9.0\npublic fun createTestCoroutineScope(context: CoroutineContext = EmptyCoroutineContext): TestCoroutineScope {\n    val ctxWithDispatcher = context.withDelaySkipping()\n    var scope: TestCoroutineScopeImpl? = null\n    val ownExceptionHandler =\n        object : AbstractCoroutineContextElement(CoroutineExceptionHandler), TestCoroutineScopeExceptionHandler {\n            override fun handleException(context: CoroutineContext, exception: Throwable) {\n                if (!scope!!.reportException(exception))\n                    throw exception // let this exception crash everything\n            }\n        }\n    val exceptionHandler = when (val exceptionHandler = ctxWithDispatcher[CoroutineExceptionHandler]) {\n        is UncaughtExceptionCaptor -> exceptionHandler\n        null -> ownExceptionHandler\n        is TestCoroutineScopeExceptionHandler -> ownExceptionHandler\n        else -> throw IllegalArgumentException(\n            \"A CoroutineExceptionHandler was passed to TestCoroutineScope. \" +\n                \"Please pass it as an argument to a `launch` or `async` block on an already-created scope \" +\n                \"if uncaught exceptions require special treatment.\"\n        )\n    }\n    val job: Job = ctxWithDispatcher[Job] ?: Job()\n    return TestCoroutineScopeImpl(ctxWithDispatcher + exceptionHandler + job).also {\n        scope = it\n    }\n}\n\n/** A marker that shows that this [CoroutineExceptionHandler] was created for [TestCoroutineScope]. With this,\n * constructing a new [TestCoroutineScope] with the [CoroutineScope.coroutineContext] of an existing one will override\n * the exception handler, instead of failing. */\nprivate interface TestCoroutineScopeExceptionHandler : CoroutineExceptionHandler\n\nprivate inline val CoroutineContext.delayController: DelayController?\n    get() {\n        val handler = this[ContinuationInterceptor]\n        return handler as? DelayController\n    }\n\n\n/**\n * The current virtual time on [testScheduler][TestCoroutineScope.testScheduler].\n * @see TestCoroutineScheduler.currentTime\n */\n@ExperimentalCoroutinesApi\npublic val TestCoroutineScope.currentTime: Long\n    get() = coroutineContext.delayController?.currentTime ?: testScheduler.currentTime\n\n/**\n * Advances the [testScheduler][TestCoroutineScope.testScheduler] by [delayTimeMillis] and runs the tasks up to that\n * moment (inclusive).\n *\n * @see TestCoroutineScheduler.advanceTimeBy\n */\n@ExperimentalCoroutinesApi\n@Deprecated(\n    \"The name of this function is misleading: it not only advances the time, but also runs the tasks \" +\n        \"scheduled *at* the ending moment.\",\n    ReplaceWith(\"this.testScheduler.apply { advanceTimeBy(delayTimeMillis); runCurrent() }\"),\n    DeprecationLevel.ERROR\n)\n// Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\npublic fun TestCoroutineScope.advanceTimeBy(delayTimeMillis: Long): Unit =\n    when (val controller = coroutineContext.delayController) {\n        null -> {\n            testScheduler.advanceTimeBy(delayTimeMillis)\n            testScheduler.runCurrent()\n        }\n        else -> {\n            controller.advanceTimeBy(delayTimeMillis)\n            Unit\n        }\n    }\n\n/**\n * Advances the [testScheduler][TestCoroutineScope.testScheduler] to the point where there are no tasks remaining.\n * @see TestCoroutineScheduler.advanceUntilIdle\n */\n@ExperimentalCoroutinesApi\npublic fun TestCoroutineScope.advanceUntilIdle() {\n    coroutineContext.delayController?.advanceUntilIdle() ?: testScheduler.advanceUntilIdle()\n}\n\n/**\n * Run any tasks that are pending at the current virtual time, according to\n * the [testScheduler][TestCoroutineScope.testScheduler].\n *\n * @see TestCoroutineScheduler.runCurrent\n */\n@ExperimentalCoroutinesApi\npublic fun TestCoroutineScope.runCurrent() {\n    coroutineContext.delayController?.runCurrent() ?: testScheduler.runCurrent()\n}\n\n@ExperimentalCoroutinesApi\n@Deprecated(\n    \"The test coroutine scope isn't able to pause its dispatchers in the general case. \" +\n        \"Only `TestCoroutineDispatcher` supports pausing; pause it directly, or use a dispatcher that is always \" +\n        \"\\\"paused\\\", like `StandardTestDispatcher`.\",\n    ReplaceWith(\n        \"(this.coroutineContext[ContinuationInterceptor]!! as DelayController).pauseDispatcher(block)\",\n        \"kotlin.coroutines.ContinuationInterceptor\"\n    ),\n    DeprecationLevel.ERROR\n)\n// Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\npublic suspend fun TestCoroutineScope.pauseDispatcher(block: suspend () -> Unit) {\n    delayControllerForPausing.pauseDispatcher(block)\n}\n\n@ExperimentalCoroutinesApi\n@Deprecated(\n    \"The test coroutine scope isn't able to pause its dispatchers in the general case. \" +\n        \"Only `TestCoroutineDispatcher` supports pausing; pause it directly, or use a dispatcher that is always \" +\n        \"\\\"paused\\\", like `StandardTestDispatcher`.\",\n    ReplaceWith(\n        \"(this.coroutineContext[ContinuationInterceptor]!! as DelayController).pauseDispatcher()\",\n        \"kotlin.coroutines.ContinuationInterceptor\"\n    ),\n    level = DeprecationLevel.ERROR\n)\n// Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\npublic fun TestCoroutineScope.pauseDispatcher() {\n    delayControllerForPausing.pauseDispatcher()\n}\n\n@ExperimentalCoroutinesApi\n@Deprecated(\n    \"The test coroutine scope isn't able to pause its dispatchers in the general case. \" +\n        \"Only `TestCoroutineDispatcher` supports pausing; pause it directly, or use a dispatcher that is always \" +\n        \"\\\"paused\\\", like `StandardTestDispatcher`.\",\n    ReplaceWith(\n        \"(this.coroutineContext[ContinuationInterceptor]!! as DelayController).resumeDispatcher()\",\n        \"kotlin.coroutines.ContinuationInterceptor\"\n    ),\n    level = DeprecationLevel.ERROR\n)\n// Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\npublic fun TestCoroutineScope.resumeDispatcher() {\n    delayControllerForPausing.resumeDispatcher()\n}\n\n/**\n * List of uncaught coroutine exceptions, for backward compatibility.\n *\n * The returned list is a copy of the exceptions caught during execution.\n * During [TestCoroutineScope.cleanupTestCoroutines] the first element of this list is rethrown if it is not empty.\n *\n * Exceptions are only collected in this list if the [UncaughtExceptionCaptor] is in the test context.\n */\n@Deprecated(\n    \"This list is only populated if `UncaughtExceptionCaptor` is in the test context, and so can be \" +\n        \"easily misused. It is only present for backward compatibility and will be removed in the subsequent \" +\n        \"releases. If you need to check the list of exceptions, please consider creating your own \" +\n        \"`CoroutineExceptionHandler`.\",\n    level = DeprecationLevel.ERROR\n)\n// Since 1.6.0, ERROR in 1.7.0 and removed as experimental in 1.8.0\npublic val TestCoroutineScope.uncaughtExceptions: List<Throwable>\n    get() = (coroutineContext[CoroutineExceptionHandler] as? UncaughtExceptionCaptor)?.uncaughtExceptions\n        ?: emptyList()\n\nprivate val TestCoroutineScope.delayControllerForPausing: DelayController\n    get() = coroutineContext.delayController\n        ?: throw IllegalStateException(\"This scope isn't able to pause its dispatchers\")\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/DumpOnTimeoutTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.debug.*\nimport org.junit.Test\nimport java.io.*\nimport kotlin.test.*\nimport kotlin.time.Duration.Companion.milliseconds\n\nclass DumpOnTimeoutTest {\n    /**\n     * Tests that the dump on timeout contains the correct stacktrace.\n     */\n    @Test\n    fun testDumpOnTimeout() {\n        val oldErr = System.err\n        val baos = ByteArrayOutputStream()\n        try {\n            System.setErr(PrintStream(baos, true))\n            DebugProbes.withDebugProbes {\n                try {\n                    runTest(timeout = 100.milliseconds) {\n                        uniquelyNamedFunction()\n                    }\n                    throw IllegalStateException(\"unreachable\")\n                } catch (e: UncompletedCoroutinesError) {\n                    // do nothing\n                }\n            }\n            baos.toString().let {\n                assertTrue(it.contains(\"uniquelyNamedFunction\"), \"Actual trace:\\n$it\")\n            }\n        } finally {\n            System.setErr(oldErr)\n        }\n    }\n\n    fun CoroutineScope.uniquelyNamedFunction() {\n        while (true) {\n            ensureActive()\n            Thread.sleep(10)\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/HelpersJvm.kt",
        "content": "package kotlinx.coroutines.test\n\nactual fun testResultChain(block: () -> TestResult, after: (Result<Unit>) -> TestResult): TestResult {\n    try {\n        block()\n        after(Result.success(Unit))\n    } catch (e: Throwable) {\n        after(Result.failure(e))\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/MemoryLeakTest.kt",
        "content": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.test.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\n\nclass MemoryLeakTest {\n\n    @Test\n    fun testCancellationLeakInTestCoroutineScheduler() = runTest {\n        val leakingObject = Any()\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            delay(1)\n            // This code is needed to hold a reference to `leakingObject` until the job itself is weakly reachable.\n            leakingObject.hashCode()\n        }\n        job.cancel()\n        FieldWalker.assertReachableCount(1, testScheduler) { it === leakingObject }\n        runCurrent()\n        FieldWalker.assertReachableCount(0, testScheduler) { it === leakingObject }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/MultithreadingTest.kt",
        "content": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.test.*\nimport kotlin.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass MultithreadingTest {\n\n    @Test\n    fun incorrectlyCalledRunBlocking_doesNotHaveSameInterceptor() = runBlockingTest {\n        // this code is an error as a production test, please do not use this as an example\n\n        // this test exists to document this error condition, if it's possible to make this code work please update\n        val outerInterceptor = coroutineContext[ContinuationInterceptor]\n        // runBlocking always requires an argument to pass the context in tests\n        runBlocking {\n            assertNotSame(coroutineContext[ContinuationInterceptor], outerInterceptor)\n        }\n    }\n\n    @Test\n    fun testSingleThreadExecutor() = runBlocking {\n        val mainThread = Thread.currentThread()\n        Dispatchers.setMain(Dispatchers.Unconfined)\n        newSingleThreadContext(\"testSingleThread\").use { threadPool ->\n            withContext(Dispatchers.Main) {\n                assertSame(mainThread, Thread.currentThread())\n            }\n\n            Dispatchers.setMain(threadPool)\n            withContext(Dispatchers.Main) {\n                assertNotSame(mainThread, Thread.currentThread())\n            }\n            assertSame(mainThread, Thread.currentThread())\n\n            withContext(Dispatchers.Main.immediate) {\n                assertNotSame(mainThread, Thread.currentThread())\n            }\n            assertSame(mainThread, Thread.currentThread())\n\n            Dispatchers.setMain(Dispatchers.Unconfined)\n            withContext(Dispatchers.Main.immediate) {\n                assertSame(mainThread, Thread.currentThread())\n            }\n            assertSame(mainThread, Thread.currentThread())\n        }\n    }\n\n    @Test\n    fun whenDispatchCalled_runsOnCurrentThread() {\n        val currentThread = Thread.currentThread()\n        val subject = TestCoroutineDispatcher()\n        val scope = TestCoroutineScope(subject)\n\n        val deferred = scope.async(Dispatchers.Default) {\n            withContext(subject) {\n                assertNotSame(currentThread, Thread.currentThread())\n                3\n            }\n        }\n\n        runBlocking {\n            // just to ensure the above code terminates\n            assertEquals(3, deferred.await())\n        }\n    }\n\n    @Test\n    fun whenAllDispatchersMocked_runsOnSameThread() {\n        val currentThread = Thread.currentThread()\n        val subject = TestCoroutineDispatcher()\n        val scope = TestCoroutineScope(subject)\n\n        val deferred = scope.async(subject) {\n            withContext(subject) {\n                assertSame(currentThread, Thread.currentThread())\n                3\n            }\n        }\n\n        runBlocking {\n            // just to ensure the above code terminates\n            assertEquals(3, deferred.await())\n        }\n    }\n\n    /** Tests that resuming the coroutine of [runTest] asynchronously in reasonable time succeeds. */\n    @Test\n    fun testResumingFromAnotherThread() = runTest {\n        suspendCancellableCoroutine<Unit> { cont ->\n            thread {\n                Thread.sleep(10)\n                cont.resume(Unit)\n            }\n        }\n    }\n\n    /** Tests that [StandardTestDispatcher] is not executed in-place but confined to the thread in which the\n     * virtual time control happens. */\n    @Test\n    fun testStandardTestDispatcherIsConfined(): Unit = runBlocking {\n        val scheduler = TestCoroutineScheduler()\n        val initialThread = Thread.currentThread()\n        val job = launch(StandardTestDispatcher(scheduler)) {\n            assertEquals(initialThread, Thread.currentThread())\n            withContext(Dispatchers.IO) {\n                val ioThread = Thread.currentThread()\n                assertNotSame(initialThread, ioThread)\n            }\n            assertEquals(initialThread, Thread.currentThread())\n        }\n        scheduler.advanceUntilIdle()\n        while (job.isActive) {\n            scheduler.receiveDispatchEvent()\n            scheduler.advanceUntilIdle()\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/RunTestStressTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.concurrent.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass RunTestStressTest {\n    /** Tests that notifications about asynchronous resumptions aren't lost. */\n    @Test\n    fun testRunTestActivityNotificationsRace() {\n        val n = 1_000 * stressTestMultiplier\n        for (i in 0 until n) {\n            runTest {\n                suspendCancellableCoroutine<Unit> { cont ->\n                    thread {\n                        cont.resume(Unit)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/UncaughtExceptionsTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport kotlin.test.*\n\n/**\n * Tests that check the behavior of the test framework when there are stray uncaught exceptions.\n * These tests are JVM-only because only the JVM allows to set a global uncaught exception handler and validate the\n * behavior without checking the test logs.\n * Nevertheless, each test here has a corresponding test in the common source set that can be run manually.\n */\nclass UncaughtExceptionsTest {\n\n    val oldExceptionHandler = Thread.getDefaultUncaughtExceptionHandler()\n    val uncaughtExceptions = mutableListOf<Throwable>()\n\n    @BeforeTest\n    fun setUp() {\n        Thread.setDefaultUncaughtExceptionHandler { thread, throwable ->\n            uncaughtExceptions.add(throwable)\n        }\n    }\n\n    @AfterTest\n    fun tearDown() {\n        Thread.setDefaultUncaughtExceptionHandler(oldExceptionHandler)\n    }\n\n    @Test\n    fun testReportingStrayUncaughtExceptionsBetweenTests() {\n        TestScopeTest().testReportingStrayUncaughtExceptionsBetweenTests()\n        assertEquals(1, uncaughtExceptions.size, \"Expected 1 uncaught exception, but got $uncaughtExceptions\")\n        val exception = assertIs<TestException>(uncaughtExceptions.single())\n        assertEquals(\"x\", exception.message)\n    }\n\n    @Test\n    fun testExceptionCaptorCleanedUpOnPreliminaryExit() {\n        RunTestTest().testExceptionCaptorCleanedUpOnPreliminaryExit()\n        assertEquals(2, uncaughtExceptions.size, \"Expected 2 uncaught exceptions, but got $uncaughtExceptions\")\n        for (exception in uncaughtExceptions) {\n            assertIs<TestException>(exception)\n        }\n        assertEquals(\"A\", uncaughtExceptions[0].message)\n        assertEquals(\"B\", uncaughtExceptions[1].message)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/migration/RunBlockingTestOnTestScopeTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\nimport kotlin.test.assertFailsWith\n\n/** Copy of [RunTestTest], but for [runBlockingTestOnTestScope], where applicable. */\n@Suppress(\"DEPRECATION\")\nclass RunBlockingTestOnTestScopeTest {\n\n    @Test\n    fun testRunTestWithIllegalContext() {\n        for (ctx in TestScopeTest.invalidContexts) {\n            assertFailsWith<IllegalArgumentException> {\n                runBlockingTestOnTestScope(ctx) { }\n            }\n        }\n    }\n\n    @Test\n    fun testThrowingInRunTestBody() {\n        assertFailsWith<RuntimeException> {\n            runBlockingTestOnTestScope {\n                throw RuntimeException()\n            }\n        }\n    }\n\n    @Test\n    fun testThrowingInRunTestPendingTask() {\n        assertFailsWith<RuntimeException> {\n            runBlockingTestOnTestScope {\n                launch {\n                    delay(SLOW)\n                    throw RuntimeException()\n                }\n            }\n        }\n    }\n\n    @Test\n    fun reproducer2405() = runBlockingTestOnTestScope {\n        val dispatcher = StandardTestDispatcher(testScheduler)\n        var collectedError = false\n        withContext(dispatcher) {\n            flow { emit(1) }\n                .combine(\n                    flow<String> { throw IllegalArgumentException() }\n                ) { int, string -> int.toString() + string }\n                .catch { emit(\"error\") }\n                .collect {\n                    assertEquals(\"error\", it)\n                    collectedError = true\n                }\n        }\n        assertTrue(collectedError)\n    }\n\n    @Test\n    fun testChildrenCancellationOnTestBodyFailure() {\n        var job: Job? = null\n        assertFailsWith<AssertionError> {\n            runBlockingTestOnTestScope {\n                job = launch {\n                    while (true) {\n                        delay(1000)\n                    }\n                }\n                throw AssertionError()\n            }\n        }\n        assertTrue(job!!.isCancelled)\n    }\n\n    @Test\n    fun testTimeout() {\n        assertFailsWith<TimeoutCancellationException> {\n            runBlockingTestOnTestScope {\n                withTimeout(50) {\n                    launch {\n                        delay(1000)\n                    }\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testRunTestThrowsRootCause() {\n        assertFailsWith<TestException> {\n            runBlockingTestOnTestScope {\n                launch {\n                    throw TestException()\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testCompletesOwnJob() {\n        var handlerCalled = false\n        runBlockingTestOnTestScope {\n            coroutineContext.job.invokeOnCompletion {\n                handlerCalled = true\n            }\n        }\n        assertTrue(handlerCalled)\n    }\n\n    @Test\n    fun testDoesNotCompleteGivenJob() {\n        var handlerCalled = false\n        val job = Job()\n        job.invokeOnCompletion {\n            handlerCalled = true\n        }\n        runBlockingTestOnTestScope(job) {\n            assertTrue(coroutineContext.job in job.children)\n        }\n        assertFalse(handlerCalled)\n        assertEquals(0, job.children.filter { it.isActive }.count())\n    }\n\n    @Test\n    fun testSuppressedExceptions() {\n        try {\n            runBlockingTestOnTestScope {\n                launch(SupervisorJob()) { throw TestException(\"x\") }\n                launch(SupervisorJob()) { throw TestException(\"y\") }\n                launch(SupervisorJob()) { throw TestException(\"z\") }\n                throw TestException(\"w\")\n            }\n            fail(\"should not be reached\")\n        } catch (e: TestException) {\n            assertEquals(\"w\", e.message)\n            val suppressed = e.suppressedExceptions +\n                (e.suppressedExceptions.firstOrNull()?.suppressedExceptions ?: emptyList())\n            assertEquals(3, suppressed.size)\n            assertEquals(\"x\", suppressed[0].message)\n            assertEquals(\"y\", suppressed[1].message)\n            assertEquals(\"z\", suppressed[2].message)\n        }\n    }\n\n    @Test\n    fun testScopeRunTestExceptionHandler(): TestResult {\n        val scope = TestCoroutineScope()\n        return testResultMap({\n            try {\n                it()\n                fail(\"should not be reached\")\n            } catch (e: TestException) {\n                // expected\n            }\n        }) {\n            scope.runTest {\n                launch(SupervisorJob()) { throw TestException(\"x\") }\n            }\n        }\n    }\n\n    @Test\n    fun testBackgroundWorkBeingRun() = runBlockingTestOnTestScope {\n        var i = 0\n        var j = 0\n        backgroundScope.launch {\n            yield()\n            ++i\n        }\n        backgroundScope.launch {\n            yield()\n            delay(10)\n            ++j\n        }\n        assertEquals(0, i)\n        assertEquals(0, j)\n        delay(1)\n        assertEquals(1, i)\n        assertEquals(0, j)\n        delay(10)\n        assertEquals(1, i)\n        assertEquals(1, j)\n    }\n\n    @Test\n    fun testBackgroundWorkCancelled() {\n        var cancelled = false\n        runBlockingTestOnTestScope {\n            var i = 0\n            backgroundScope.launch {\n                yield()\n                try {\n                    while (isActive) {\n                        ++i\n                        yield()\n                    }\n                } catch (e: CancellationException) {\n                    cancelled = true\n                }\n            }\n            repeat(5) {\n                assertEquals(i, it)\n                yield()\n            }\n        }\n        assertTrue(cancelled)\n    }\n\n    @Test\n    fun testBackgroundWorkTimeControl(): TestResult = runBlockingTestOnTestScope {\n        var i = 0\n        var j = 0\n        backgroundScope.launch {\n            yield()\n            while (true) {\n                ++i\n                delay(100)\n            }\n        }\n        backgroundScope.launch {\n            yield()\n            while (true) {\n                ++j\n                delay(50)\n            }\n        }\n        advanceUntilIdle() // should do nothing, as only background work is left.\n        assertEquals(0, i)\n        assertEquals(0, j)\n        val job = launch {\n            delay(1)\n            // the background work scheduled for earlier gets executed before the normal work scheduled for later does\n            assertEquals(1, i)\n            assertEquals(1, j)\n        }\n        job.join()\n        advanceTimeBy(199) // should work the same for the background tasks\n        assertEquals(2, i)\n        assertEquals(4, j)\n        advanceUntilIdle() // once again, should do nothing\n        assertEquals(2, i)\n        assertEquals(4, j)\n        runCurrent() // should behave the same way as for the normal work\n        assertEquals(3, i)\n        assertEquals(5, j)\n        launch {\n            delay(1001)\n            assertEquals(13, i)\n            assertEquals(25, j)\n        }\n        advanceUntilIdle() // should execute the normal work, and with that, the background one, too\n    }\n\n    @Test\n    fun testBackgroundWorkErrorReporting() {\n        var testFinished = false\n        val exception = RuntimeException(\"x\")\n        try {\n            runBlockingTestOnTestScope {\n                backgroundScope.launch {\n                    throw exception\n                }\n                delay(1000)\n                testFinished = true\n            }\n            fail(\"unreached\")\n        } catch (e: Throwable) {\n            assertSame(e, exception)\n            assertTrue(testFinished)\n        }\n    }\n\n    @Test\n    fun testBackgroundWorkFinalizing() {\n        var taskEnded = 0\n        val nTasks = 10\n        try {\n            runBlockingTestOnTestScope {\n                repeat(nTasks) {\n                    backgroundScope.launch {\n                        try {\n                            while (true) {\n                                delay(1)\n                            }\n                        } finally {\n                            ++taskEnded\n                            if (taskEnded <= 2)\n                                throw TestException()\n                        }\n                    }\n                }\n                delay(100)\n                throw TestException()\n            }\n            fail(\"unreached\")\n        } catch (e: TestException) {\n            assertEquals(2, e.suppressedExceptions.size)\n            assertEquals(nTasks, taskEnded)\n        }\n    }\n\n    @Test\n    fun testExampleBackgroundJob1() = runBlockingTestOnTestScope {\n        val myFlow = flow {\n            yield()\n            var i = 0\n            while (true) {\n                emit(++i)\n                delay(1)\n            }\n        }\n        val stateFlow = myFlow.stateIn(backgroundScope, SharingStarted.Eagerly, 0)\n        var j = 0\n        repeat(100) {\n            assertEquals(j++, stateFlow.value)\n            delay(1)\n        }\n    }\n\n    @Test\n    fun testExampleBackgroundJob2() = runBlockingTestOnTestScope {\n        val channel = Channel<Int>()\n        backgroundScope.launch {\n            var i = 0\n            while (true) {\n                channel.send(i++)\n            }\n        }\n        repeat(100) {\n            assertEquals(it, channel.receive())\n        }\n    }\n\n    @Test\n    fun testAsyncFailureInBackgroundReported() =\n        try {\n            runBlockingTestOnTestScope {\n                backgroundScope.async {\n                    throw TestException(\"x\")\n                }\n                backgroundScope.produce<Unit> {\n                    throw TestException(\"y\")\n                }\n                delay(1)\n                throw TestException(\"z\")\n            }\n            fail(\"unreached\")\n        } catch (e: TestException) {\n            assertEquals(\"z\", e.message)\n            assertEquals(setOf(\"x\", \"y\"), e.suppressedExceptions.map { it.message }.toSet())\n        }\n\n    @Test\n    fun testNoDuplicateExceptions() =\n        try {\n            runBlockingTestOnTestScope {\n                backgroundScope.launch {\n                    throw TestException(\"x\")\n                }\n                delay(1)\n                throw TestException(\"y\")\n            }\n            fail(\"unreached\")\n        } catch (e: TestException) {\n            assertEquals(\"y\", e.message)\n            assertEquals(listOf(\"x\"), e.suppressedExceptions.map { it.message })\n        }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/migration/RunTestLegacyScopeTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\nimport kotlin.test.assertFailsWith\n\n/** Copy of [RunTestTest], but for [TestCoroutineScope] */\n@Suppress(\"DEPRECATION\")\nclass RunTestLegacyScopeTest {\n\n    @Test\n    fun testWithContextDispatching() = runTestWithLegacyScope {\n        var counter = 0\n        withContext(Dispatchers.Default) {\n            counter += 1\n        }\n        assertEquals(counter, 1)\n    }\n\n    @Test\n    fun testJoiningForkedJob() = runTestWithLegacyScope {\n        var counter = 0\n        val job = GlobalScope.launch {\n            counter += 1\n        }\n        job.join()\n        assertEquals(counter, 1)\n    }\n\n    @Test\n    fun testSuspendCoroutine() = runTestWithLegacyScope {\n        val answer = suspendCoroutine<Int> {\n            it.resume(42)\n        }\n        assertEquals(42, answer)\n    }\n\n    @Test\n    fun testNestedRunTestForbidden() = runTestWithLegacyScope {\n        assertFailsWith<IllegalStateException> {\n            runTest { }\n        }\n    }\n\n    @Test\n    fun testRunTestWithZeroTimeoutWithControlledDispatches() = runTestWithLegacyScope(dispatchTimeoutMs = 0) {\n        // below is some arbitrary concurrent code where all dispatches go through the same scheduler.\n        launch {\n            delay(2000)\n        }\n        val deferred = async {\n            val job = launch(StandardTestDispatcher(testScheduler)) {\n                launch {\n                    delay(500)\n                }\n                delay(1000)\n            }\n            job.join()\n        }\n        deferred.await()\n    }\n\n    @Test\n    fun testRunTestWithSmallTimeout() = testResultMap({ fn ->\n        assertFailsWith<UncompletedCoroutinesError> { fn() }\n    }) {\n        runTestWithLegacyScope(dispatchTimeoutMs = 100) {\n            withContext(Dispatchers.Default) {\n                delay(10000)\n                3\n            }\n            fail(\"shouldn't be reached\")\n        }\n    }\n\n    @Test\n    fun testRunTestWithLargeTimeout() = runTestWithLegacyScope(dispatchTimeoutMs = 5000) {\n        withContext(Dispatchers.Default) {\n            delay(50)\n        }\n    }\n\n    @Test\n    fun testRunTestTimingOutAndThrowing() = testResultMap({ fn ->\n        try {\n            fn()\n            fail(\"unreached\")\n        } catch (e: UncompletedCoroutinesError) {\n            @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n            val suppressed = unwrap(e).suppressedExceptions\n            assertEquals(1, suppressed.size)\n            assertIs<TestException>(suppressed[0]).also {\n                assertEquals(\"A\", it.message)\n            }\n        }\n    }) {\n        runTestWithLegacyScope(dispatchTimeoutMs = 1) {\n            coroutineContext[CoroutineExceptionHandler]!!.handleException(coroutineContext, TestException(\"A\"))\n            withContext(Dispatchers.Default) {\n                delay(10000)\n                3\n            }\n            fail(\"shouldn't be reached\")\n        }\n    }\n\n    @Test\n    fun testRunTestWithIllegalContext() {\n        for (ctx in TestScopeTest.invalidContexts) {\n            assertFailsWith<IllegalArgumentException> {\n                runTestWithLegacyScope(ctx) { }\n            }\n        }\n    }\n\n    @Test\n    fun testThrowingInRunTestBody() = testResultMap({\n        assertFailsWith<RuntimeException> { it() }\n    }) {\n        runTestWithLegacyScope {\n            throw RuntimeException()\n        }\n    }\n\n    @Test\n    fun testThrowingInRunTestPendingTask() = testResultMap({\n        assertFailsWith<RuntimeException> { it() }\n    }) {\n        runTestWithLegacyScope {\n            launch {\n                delay(SLOW)\n                throw RuntimeException()\n            }\n        }\n    }\n\n    @Test\n    fun reproducer2405() = runTestWithLegacyScope {\n        val dispatcher = StandardTestDispatcher(testScheduler)\n        var collectedError = false\n        withContext(dispatcher) {\n            flow { emit(1) }\n                .combine(\n                    flow<String> { throw IllegalArgumentException() }\n                ) { int, string -> int.toString() + string }\n                .catch { emit(\"error\") }\n                .collect {\n                    assertEquals(\"error\", it)\n                    collectedError = true\n                }\n        }\n        assertTrue(collectedError)\n    }\n\n    @Test\n    fun testChildrenCancellationOnTestBodyFailure(): TestResult {\n        var job: Job? = null\n        return testResultMap({\n            assertFailsWith<AssertionError> { it() }\n            assertTrue(job!!.isCancelled)\n        }) {\n            runTestWithLegacyScope {\n                job = launch {\n                    while (true) {\n                        delay(1000)\n                    }\n                }\n                throw AssertionError()\n            }\n        }\n    }\n\n    @Test\n    fun testTimeout() = testResultMap({\n        assertFailsWith<TimeoutCancellationException> { it() }\n    }) {\n        runTestWithLegacyScope {\n            withTimeout(50) {\n                launch {\n                    delay(1000)\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testRunTestThrowsRootCause() = testResultMap({\n        assertFailsWith<TestException> { it() }\n    }) {\n        runTestWithLegacyScope {\n            launch {\n                throw TestException()\n            }\n        }\n    }\n\n    @Test\n    fun testCompletesOwnJob(): TestResult {\n        var handlerCalled = false\n        return testResultMap({\n            it()\n            assertTrue(handlerCalled)\n        }) {\n            runTestWithLegacyScope {\n                coroutineContext.job.invokeOnCompletion {\n                    handlerCalled = true\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testDoesNotCompleteGivenJob(): TestResult {\n        var handlerCalled = false\n        val job = Job()\n        job.invokeOnCompletion {\n            handlerCalled = true\n        }\n        return testResultMap({\n            it()\n            assertFalse(handlerCalled)\n            assertEquals(0, job.children.filter { it.isActive }.count())\n        }) {\n            runTestWithLegacyScope(job) {\n                assertTrue(coroutineContext.job in job.children)\n            }\n        }\n    }\n\n    @Test\n    fun testSuppressedExceptions() = testResultMap({\n        try {\n            it()\n            fail(\"should not be reached\")\n        } catch (e: TestException) {\n            assertEquals(\"w\", e.message)\n            val suppressed = e.suppressedExceptions +\n                (e.suppressedExceptions.firstOrNull()?.suppressedExceptions ?: emptyList())\n            assertEquals(3, suppressed.size)\n            assertEquals(\"x\", suppressed[0].message)\n            assertEquals(\"y\", suppressed[1].message)\n            assertEquals(\"z\", suppressed[2].message)\n        }\n    }) {\n        runTestWithLegacyScope {\n            launch(SupervisorJob()) { throw TestException(\"x\") }\n            launch(SupervisorJob()) { throw TestException(\"y\") }\n            launch(SupervisorJob()) { throw TestException(\"z\") }\n            throw TestException(\"w\")\n        }\n    }\n\n    @Test\n    fun testScopeRunTestExceptionHandler(): TestResult {\n        val scope = TestCoroutineScope()\n        return testResultMap({\n            try {\n                it()\n                fail(\"should not be reached\")\n            } catch (e: TestException) {\n                // expected\n            }\n        }) {\n            scope.runTest {\n                launch(SupervisorJob()) { throw TestException(\"x\") }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/migration/TestBuildersTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\nclass TestBuildersTest {\n\n    @Test\n    fun scopeRunBlocking_passesDispatcher() {\n        val scope = TestCoroutineScope()\n        scope.runBlockingTest {\n            assertSame(scope.coroutineContext[ContinuationInterceptor], coroutineContext[ContinuationInterceptor])\n        }\n    }\n\n    @Test\n    fun dispatcherRunBlocking_passesDispatcher() {\n        val dispatcher = TestCoroutineDispatcher()\n        dispatcher.runBlockingTest {\n            assertSame(dispatcher, coroutineContext[ContinuationInterceptor])\n        }\n    }\n\n    @Test\n    fun scopeRunBlocking_advancesPreviousDelay() {\n        val scope = TestCoroutineScope()\n        val deferred = scope.async {\n            delay(SLOW)\n            3\n        }\n\n        scope.runBlockingTest {\n            assertRunsFast {\n                assertEquals(3, deferred.await())\n            }\n        }\n    }\n\n    @Test\n    fun dispatcherRunBlocking_advancesPreviousDelay() {\n        val dispatcher = TestCoroutineDispatcher()\n        val scope = CoroutineScope(dispatcher)\n        val deferred = scope.async {\n            delay(SLOW)\n            3\n        }\n\n        dispatcher.runBlockingTest {\n            assertRunsFast {\n                assertEquals(3, deferred.await())\n            }\n        }\n    }\n\n    @Test\n    fun scopeRunBlocking_disablesImmediatelyOnExit() {\n        val scope = TestCoroutineScope()\n        scope.runBlockingTest {\n            assertRunsFast {\n                delay(SLOW)\n            }\n        }\n\n        val deferred = scope.async {\n            delay(SLOW)\n            3\n        }\n        scope.runCurrent()\n        assertTrue(deferred.isActive)\n\n        scope.advanceUntilIdle()\n        assertEquals(3, deferred.getCompleted())\n    }\n\n    @Test\n    fun whenInAsync_runBlocking_nestsProperly() {\n        // this is not a supported use case, but it is possible so ensure it works\n\n        val dispatcher = TestCoroutineDispatcher()\n        val scope = TestCoroutineScope(dispatcher)\n        val deferred = scope.async {\n            delay(1_000)\n            var retval = 2\n            runBlockingTest {\n                delay(1_000)\n                retval++\n            }\n            retval\n        }\n\n        scope.advanceTimeBy(1_000)\n        scope.launch {\n            assertRunsFast {\n                assertEquals(3, deferred.getCompleted())\n            }\n        }\n        scope.runCurrent() // execute the launch without changing to immediate dispatch (testing internals)\n        scope.cleanupTestCoroutines()\n    }\n\n    @Test\n    fun whenInRunBlocking_runBlockingTest_nestsProperly() {\n        // this is not a supported use case, but it is possible so ensure it works\n\n        val scope = TestCoroutineScope()\n        var calls = 0\n\n        scope.runBlockingTest {\n            delay(1_000)\n            calls++\n            runBlockingTest {\n                val job = launch {\n                    delay(1_000)\n                    calls++\n                }\n                assertTrue(job.isActive)\n                advanceUntilIdle()\n                assertFalse(job.isActive)\n                calls++\n            }\n            ++calls\n        }\n\n        assertEquals(4, calls)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/migration/TestCoroutineDispatcherOrderTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\n@Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\nclass TestCoroutineDispatcherOrderTest: OrderedExecutionTestBase() {\n\n    @Test\n    fun testAdvanceTimeBy_progressesOnEachDelay() {\n        val dispatcher = TestCoroutineDispatcher()\n        val scope = TestCoroutineScope(dispatcher)\n\n        expect(1)\n        scope.launch {\n            expect(2)\n            delay(1_000)\n            assertEquals(1_000, dispatcher.currentTime)\n            expect(4)\n            delay(5_00)\n            assertEquals(1_500, dispatcher.currentTime)\n            expect(5)\n            delay(501)\n            assertEquals(2_001, dispatcher.currentTime)\n            expect(7)\n        }\n        expect(3)\n        assertEquals(0, dispatcher.currentTime)\n        dispatcher.advanceTimeBy(2_000)\n        expect(6)\n        assertEquals(2_000, dispatcher.currentTime)\n        dispatcher.advanceTimeBy(2)\n        expect(8)\n        assertEquals(2_002, dispatcher.currentTime)\n        scope.cleanupTestCoroutines()\n        finish(9)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/migration/TestCoroutineDispatcherTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\n@Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\nclass TestCoroutineDispatcherTest {\n    @Test\n    fun whenDispatcherPaused_doesNotAutoProgressCurrent() {\n        val subject = TestCoroutineDispatcher()\n        subject.pauseDispatcher()\n        val scope = CoroutineScope(subject)\n        var executed = 0\n        scope.launch {\n            executed++\n        }\n        assertEquals(0, executed)\n    }\n\n    @Test\n    fun whenDispatcherResumed_doesAutoProgressCurrent() {\n        val subject = TestCoroutineDispatcher()\n        val scope = CoroutineScope(subject)\n        var executed = 0\n        scope.launch {\n            executed++\n        }\n\n        assertEquals(1, executed)\n    }\n\n    @Test\n    fun whenDispatcherResumed_doesNotAutoProgressTime() {\n        val subject = TestCoroutineDispatcher()\n        val scope = CoroutineScope(subject)\n        var executed = 0\n        scope.launch {\n            delay(1_000)\n            executed++\n        }\n\n        assertEquals(0, executed)\n        subject.advanceUntilIdle()\n        assertEquals(1, executed)\n    }\n\n    @Test\n    fun whenDispatcherPaused_thenResume_itDoesDispatchCurrent() {\n        val subject = TestCoroutineDispatcher()\n        subject.pauseDispatcher()\n        val scope = CoroutineScope(subject)\n        var executed = 0\n        scope.launch {\n            executed++\n        }\n\n        assertEquals(0, executed)\n        subject.resumeDispatcher()\n        assertEquals(1, executed)\n    }\n\n    @Test\n    fun whenDispatcherHasUncompletedCoroutines_itThrowsErrorInCleanup() {\n        val subject = TestCoroutineDispatcher()\n        subject.pauseDispatcher()\n        val scope = CoroutineScope(subject)\n        scope.launch {\n            delay(1_000)\n        }\n        assertFailsWith<UncompletedCoroutinesError> { subject.cleanupTestCoroutines() }\n    }\n\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/migration/TestCoroutineExceptionHandlerTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlin.test.*\n\n@Suppress(\"DEPRECATION_ERROR\")\nclass TestCoroutineExceptionHandlerTest {\n    @Test\n    fun whenExceptionsCaught_availableViaProperty() {\n        val subject = TestCoroutineExceptionHandler()\n        val expected = IllegalArgumentException()\n        subject.handleException(subject, expected)\n        assertEquals(listOf(expected), subject.uncaughtExceptions)\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/migration/TestCoroutineScopeTest.kt",
        "content": "@file:Suppress(\"DEPRECATION\")\n\npackage kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\nimport kotlin.test.assertFailsWith\n\nclass TestCoroutineScopeTest {\n    /** Tests failing to create a [TestCoroutineScope] with incorrect contexts. */\n    @Test\n    fun testCreateThrowsOnInvalidArguments() {\n        for (ctx in invalidContexts) {\n            assertFailsWith<IllegalArgumentException> {\n                createTestCoroutineScope(ctx)\n            }\n        }\n    }\n\n    /** Tests that a newly-created [TestCoroutineScope] provides the correct scheduler. */\n    @Test\n    fun testCreateProvidesScheduler() {\n        // Creates a new scheduler.\n        run {\n            val scope = createTestCoroutineScope()\n            assertNotNull(scope.coroutineContext[TestCoroutineScheduler])\n        }\n        // Reuses the scheduler that the dispatcher is linked to.\n        run {\n            val dispatcher = StandardTestDispatcher()\n            val scope = createTestCoroutineScope(dispatcher)\n            assertSame(dispatcher.scheduler, scope.coroutineContext[TestCoroutineScheduler])\n        }\n        // Uses the scheduler passed to it.\n        run {\n            val scheduler = TestCoroutineScheduler()\n            val scope = createTestCoroutineScope(scheduler)\n            assertSame(scheduler, scope.coroutineContext[TestCoroutineScheduler])\n            assertSame(scheduler, (scope.coroutineContext[ContinuationInterceptor] as TestDispatcher).scheduler)\n        }\n        // Doesn't touch the passed dispatcher and the scheduler if they match.\n        run {\n            val scheduler = TestCoroutineScheduler()\n            val dispatcher = StandardTestDispatcher(scheduler)\n            val scope = createTestCoroutineScope(scheduler + dispatcher)\n            assertSame(scheduler, scope.coroutineContext[TestCoroutineScheduler])\n            assertSame(dispatcher, scope.coroutineContext[ContinuationInterceptor])\n        }\n        // Reuses the scheduler of `Dispatchers.Main`\n        run {\n            val scheduler = TestCoroutineScheduler()\n            val mainDispatcher = StandardTestDispatcher(scheduler)\n            Dispatchers.setMain(mainDispatcher)\n            try {\n                val scope = createTestCoroutineScope()\n                assertSame(scheduler, scope.coroutineContext[TestCoroutineScheduler])\n                assertNotSame(mainDispatcher, scope.coroutineContext[ContinuationInterceptor])\n            } finally {\n                Dispatchers.resetMain()\n            }\n        }\n        // Does not reuse the scheduler of `Dispatchers.Main` if one is explicitly passed\n        run {\n            val mainDispatcher = StandardTestDispatcher()\n            Dispatchers.setMain(mainDispatcher)\n            try {\n                val scheduler = TestCoroutineScheduler()\n                val scope = createTestCoroutineScope(scheduler)\n                assertSame(scheduler, scope.coroutineContext[TestCoroutineScheduler])\n                assertNotSame(mainDispatcher.scheduler, scope.coroutineContext[TestCoroutineScheduler])\n                assertNotSame(mainDispatcher, scope.coroutineContext[ContinuationInterceptor])\n            } finally {\n                Dispatchers.resetMain()\n            }\n        }\n    }\n\n    /** Tests that the cleanup procedure throws if there were uncompleted delays by the end. */\n    @Test\n    fun testPresentDelaysThrowing() {\n        val scope = createTestCoroutineScope()\n        var result = false\n        scope.launch {\n            delay(5)\n            result = true\n        }\n        assertFalse(result)\n        assertFailsWith<AssertionError> { scope.cleanupTestCoroutines() }\n        assertFalse(result)\n    }\n\n    /** Tests that the cleanup procedure throws if there were active jobs by the end. */\n    @Test\n    fun testActiveJobsThrowing() {\n        val scope = createTestCoroutineScope()\n        var result = false\n        val deferred = CompletableDeferred<String>()\n        scope.launch {\n            deferred.await()\n            result = true\n        }\n        assertFalse(result)\n        assertFailsWith<AssertionError> { scope.cleanupTestCoroutines() }\n        assertFalse(result)\n    }\n\n    /** Tests that the cleanup procedure doesn't throw if it detects that the job is already cancelled. */\n    @Test\n    fun testCancelledDelaysNotThrowing() {\n        val scope = createTestCoroutineScope()\n        var result = false\n        val deferred = CompletableDeferred<String>()\n        val job = scope.launch {\n            deferred.await()\n            result = true\n        }\n        job.cancel()\n        assertFalse(result)\n        scope.cleanupTestCoroutines()\n        assertFalse(result)\n    }\n\n    /** Tests that uncaught exceptions are thrown at the cleanup. */\n    @Test\n    fun testThrowsUncaughtExceptionsOnCleanup() {\n        val scope = createTestCoroutineScope()\n        val exception = TestException(\"test\")\n        scope.launch {\n            throw exception\n        }\n        assertFailsWith<TestException> {\n            scope.cleanupTestCoroutines()\n        }\n    }\n\n    /** Tests that uncaught exceptions take priority over uncompleted jobs when throwing on cleanup. */\n    @Test\n    fun testUncaughtExceptionsPrioritizedOnCleanup() {\n        val scope = createTestCoroutineScope()\n        val exception = TestException(\"test\")\n        scope.launch {\n            throw exception\n        }\n        scope.launch {\n            delay(1000)\n        }\n        assertFailsWith<TestException> {\n            scope.cleanupTestCoroutines()\n        }\n    }\n\n    /** Tests that cleaning up twice is forbidden. */\n    @Test\n    fun testClosingTwice() {\n        val scope = createTestCoroutineScope()\n        scope.cleanupTestCoroutines()\n        assertFailsWith<IllegalStateException> {\n            scope.cleanupTestCoroutines()\n        }\n    }\n\n    /** Tests that, when reporting several exceptions, the first one is thrown, with the rest suppressed. */\n    @Test\n    fun testSuppressedExceptions() {\n        createTestCoroutineScope().apply {\n            launch(SupervisorJob()) { throw TestException(\"x\") }\n            launch(SupervisorJob()) { throw TestException(\"y\") }\n            launch(SupervisorJob()) { throw TestException(\"z\") }\n            try {\n                cleanupTestCoroutines()\n                fail(\"should not be reached\")\n            } catch (e: TestException) {\n                assertEquals(\"x\", e.message)\n                assertEquals(2, e.suppressedExceptions.size)\n                assertEquals(\"y\", e.suppressedExceptions[0].message)\n                assertEquals(\"z\", e.suppressedExceptions[1].message)\n            }\n        }\n    }\n\n    /** Tests that constructing a new [TestCoroutineScope] using another one's scope works and overrides the exception\n     * handler. */\n    @Test\n    fun testCopyingContexts() {\n        val deferred = CompletableDeferred<Unit>()\n        val scope1 = createTestCoroutineScope()\n        scope1.launch { deferred.await() } // a pending job in the outer scope\n        val scope2 = createTestCoroutineScope(scope1.coroutineContext)\n        val scope3 = createTestCoroutineScope(scope1.coroutineContext)\n        assertEquals(\n            scope1.coroutineContext.minusKey(CoroutineExceptionHandler),\n            scope2.coroutineContext.minusKey(CoroutineExceptionHandler))\n        scope2.launch(SupervisorJob()) { throw TestException(\"x\") } // will fail the cleanup of scope2\n        try {\n            scope2.cleanupTestCoroutines()\n            fail(\"should not be reached\")\n        } catch (e: TestException) { }\n        scope3.cleanupTestCoroutines() // the pending job in the outer scope will not cause this to fail\n        try {\n            scope1.cleanupTestCoroutines()\n            fail(\"should not be reached\")\n        } catch (e: UncompletedCoroutinesError) {\n            // the pending job in the outer scope\n        }\n    }\n\n    companion object {\n        internal val invalidContexts = listOf(\n            Dispatchers.Default, // not a [TestDispatcher]\n            CoroutineExceptionHandler { _, _ -> }, // not an [UncaughtExceptionCaptor]\n            StandardTestDispatcher() + TestCoroutineScheduler(), // the dispatcher is not linked to the scheduler\n        )\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/migration/TestRunBlockingOrderTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\n@Suppress(\"DEPRECATION\")\nclass TestRunBlockingOrderTest: OrderedExecutionTestBase() {\n\n    @Test\n    fun testLaunchImmediate() = runBlockingTest {\n        expect(1)\n        launch {\n            expect(2)\n        }\n        finish(3)\n    }\n\n    @Test\n    fun testYield() = runBlockingTest {\n        expect(1)\n        launch {\n            expect(2)\n            yield()\n            finish(4)\n        }\n        expect(3)\n    }\n\n    @Test\n    fun testLaunchWithDelayCompletes() = runBlockingTest {\n        expect(1)\n        launch {\n            delay(100)\n            finish(3)\n        }\n        expect(2)\n    }\n\n    @Test\n    fun testLaunchDelayOrdered() = runBlockingTest {\n        expect(1)\n        launch {\n            delay(200) // long delay\n            finish(4)\n        }\n        launch  {\n            delay(100) // shorter delay\n            expect(3)\n        }\n        expect(2)\n    }\n\n    @Test\n    fun testVeryLongDelay() = runBlockingTest {\n        expect(1)\n        delay(100) // move time forward a bit some that naive time + delay gives an overflow\n        launch {\n            delay(Long.MAX_VALUE / 2) // very long delay\n            finish(4)\n        }\n        launch  {\n            delay(100) // short delay\n            expect(3)\n        }\n        expect(2)\n    }\n\n    @Test\n    fun testAdvanceUntilIdle_inRunBlocking() = runBlockingTest {\n        expect(1)\n        assertRunsFast {\n            advanceUntilIdle()   // ensure this doesn't block forever\n        }\n        finish(2)\n    }\n}"
    },
    {
        "path": "kotlinx-coroutines-test/jvm/test/migration/TestRunBlockingTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport kotlin.test.*\nimport kotlin.test.assertFailsWith\n\n@Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\nclass TestRunBlockingTest {\n\n    @Test\n    fun delay_advancesTimeAutomatically() = runBlockingTest {\n        assertRunsFast {\n            delay(SLOW)\n        }\n    }\n\n    @Test\n    fun callingSuspendWithDelay_advancesAutomatically() = runBlockingTest {\n        suspend fun withDelay(): Int {\n            delay(SLOW)\n            return 3\n        }\n\n        assertRunsFast {\n            assertEquals(3, withDelay())\n        }\n    }\n\n    @Test\n    fun launch_advancesAutomatically()  = runBlockingTest {\n        val job = launch {\n            delay(SLOW)\n        }\n        assertRunsFast {\n            job.join()\n            assertTrue(job.isCompleted)\n        }\n    }\n\n    @Test\n    fun async_advancesAutomatically() = runBlockingTest {\n        val deferred = async {\n            delay(SLOW)\n            3\n        }\n\n        assertRunsFast {\n            assertEquals(3, deferred.await())\n        }\n    }\n\n    @Test\n    fun whenUsingTimeout_triggersWhenDelayed() {\n        assertFailsWith<TimeoutCancellationException> {\n            runBlockingTest {\n                assertRunsFast {\n                    withTimeout(SLOW) {\n                        delay(SLOW)\n                    }\n                }\n            }\n        }\n    }\n\n    @Test\n    fun whenUsingTimeout_doesNotTriggerWhenFast() = runBlockingTest {\n        assertRunsFast {\n            withTimeout(SLOW) {\n                delay(0)\n            }\n        }\n    }\n\n    @Test\n    fun whenUsingTimeout_triggersWhenWaiting() {\n        assertFailsWith<TimeoutCancellationException> {\n            runBlockingTest {\n                val uncompleted = CompletableDeferred<Unit>()\n                assertRunsFast {\n                    withTimeout(SLOW) {\n                        uncompleted.await()\n                    }\n                }\n            }\n        }\n    }\n\n    @Test\n    fun whenUsingTimeout_doesNotTriggerWhenComplete() = runBlockingTest {\n        val completed = CompletableDeferred<Unit>()\n        assertRunsFast {\n            completed.complete(Unit)\n            withTimeout(SLOW) {\n                completed.await()\n            }\n        }\n    }\n\n    @Test\n    fun testDelayInAsync_withAwait() = runBlockingTest {\n        assertRunsFast {\n            val deferred = async {\n                delay(SLOW)\n                3\n            }\n            assertEquals(3, deferred.await())\n        }\n    }\n\n    @Test\n    fun whenUsingTimeout_inAsync_triggersWhenDelayed() {\n        assertFailsWith<TimeoutCancellationException> {\n            runBlockingTest {\n                val deferred = async {\n                    withTimeout(SLOW) {\n                        delay(SLOW)\n                    }\n                }\n\n                assertRunsFast {\n                    deferred.await()\n                }\n            }\n        }\n    }\n\n    @Test\n    fun whenUsingTimeout_inAsync_doesNotTriggerWhenNotDelayed() = runBlockingTest {\n        val deferred = async {\n            withTimeout(SLOW) {\n                delay(0)\n            }\n        }\n\n        assertRunsFast {\n            deferred.await()\n        }\n    }\n\n    @Test\n    fun whenUsingTimeout_inLaunch_triggersWhenDelayed() {\n        assertFailsWith<TimeoutCancellationException> {\n            runBlockingTest {\n                val job = launch {\n                    withTimeout(1) {\n                        delay(SLOW + 1)\n                    }\n                }\n\n                assertRunsFast {\n                    job.join()\n                    throw job.getCancellationException()\n                }\n            }\n        }\n    }\n\n    @Test\n    fun whenUsingTimeout_inLaunch_doesNotTriggerWhenNotDelayed() = runBlockingTest {\n        val job = launch {\n            withTimeout(SLOW) {\n                delay(0)\n            }\n        }\n\n        assertRunsFast {\n            job.join()\n            assertTrue(job.isCompleted)\n        }\n    }\n\n    @Test\n    fun throwingException_throws() {\n        assertFailsWith<IllegalArgumentException> {\n            runBlockingTest {\n                assertRunsFast {\n                    delay(SLOW)\n                    throw IllegalArgumentException(\"Test\")\n                }\n            }\n        }\n    }\n\n    @Test\n    fun throwingException_inLaunch_throws() {\n        assertFailsWith<IllegalArgumentException> {\n            runBlockingTest {\n                val job = launch {\n                    delay(SLOW)\n                    throw IllegalArgumentException(\"Test\")\n                }\n\n                assertRunsFast {\n                    job.join()\n                    throw job.getCancellationException().cause ?: AssertionError(\"expected exception\")\n                }\n            }\n        }\n    }\n\n    @Test\n    fun throwingException__inAsync_throws() {\n        assertFailsWith<IllegalArgumentException> {\n            runBlockingTest {\n                val deferred: Deferred<Unit> = async {\n                    delay(SLOW)\n                    throw IllegalArgumentException(\"Test\")\n                }\n\n                assertRunsFast {\n                    deferred.await()\n                }\n            }\n        }\n    }\n\n    @Test\n    fun callingLaunchFunction_executesLaunchBlockImmediately() = runBlockingTest {\n        assertRunsFast {\n            var executed = false\n            launch {\n                delay(SLOW)\n                executed = true\n            }\n\n            delay(SLOW)\n            assertTrue(executed)\n        }\n    }\n\n    @Test\n    fun callingAsyncFunction_executesAsyncBlockImmediately() = runBlockingTest {\n        assertRunsFast {\n            var executed = false\n            val deferred = async {\n                delay(SLOW)\n                executed = true\n            }\n            advanceTimeBy(SLOW)\n\n            assertTrue(deferred.isCompleted)\n            assertTrue(executed)\n        }\n    }\n\n    @Test\n    fun nestingBuilders_executesSecondLevelImmediately() = runBlockingTest {\n        assertRunsFast {\n            var levels = 0\n            launch {\n                delay(SLOW)\n                levels++\n                launch {\n                    delay(SLOW)\n                    levels++\n                }\n            }\n            advanceUntilIdle()\n\n            assertEquals(2, levels)\n        }\n    }\n\n    @Test\n    fun testCancellationException() = runBlockingTest {\n        var actual: CancellationException? = null\n        val uncompleted = CompletableDeferred<Unit>()\n        val job = launch {\n            actual = kotlin.runCatching { uncompleted.await() }.exceptionOrNull() as? CancellationException\n        }\n\n        assertNull(actual)\n        job.cancel()\n        assertNotNull(actual)\n    }\n\n    @Test\n    fun testCancellationException_notThrown() = runBlockingTest {\n        val uncompleted = CompletableDeferred<Unit>()\n        val job = launch {\n            uncompleted.await()\n        }\n\n        job.cancel()\n        job.join()\n    }\n\n    @Test\n    fun whenACoroutineLeaks_errorIsThrown() {\n        assertFailsWith<UncompletedCoroutinesError> {\n            runBlockingTest {\n                val uncompleted = CompletableDeferred<Unit>()\n                launch {\n                    uncompleted.await()\n                }\n            }\n        }\n    }\n\n    @Test\n    fun runBlockingTestBuilder_throwsOnBadDispatcher() {\n        assertFailsWith<IllegalArgumentException> {\n            runBlockingTest(Dispatchers.Default) {\n\n            }\n        }\n    }\n\n    @Test\n    fun runBlockingTestBuilder_throwsOnBadHandler() {\n        assertFailsWith<IllegalArgumentException> {\n            runBlockingTest(CoroutineExceptionHandler { _, _ -> }) {\n\n            }\n        }\n    }\n\n    @Test\n    fun pauseDispatcher_disablesAutoAdvance_forCurrent() = runBlockingTest {\n        var mutable = 0\n        pauseDispatcher {\n            launch {\n                mutable++\n            }\n            assertEquals(0, mutable)\n            runCurrent()\n            assertEquals(1, mutable)\n        }\n    }\n\n    @Test\n    fun pauseDispatcher_disablesAutoAdvance_forDelay() = runBlockingTest {\n        var mutable = 0\n        pauseDispatcher {\n            launch {\n                mutable++\n                delay(SLOW)\n                mutable++\n            }\n            assertEquals(0, mutable)\n            runCurrent()\n            assertEquals(1, mutable)\n            advanceTimeBy(SLOW)\n            assertEquals(2, mutable)\n        }\n    }\n\n    @Test\n    fun pauseDispatcher_withDelay_resumesAfterPause() = runBlockingTest {\n        var mutable = 0\n        assertRunsFast {\n            pauseDispatcher {\n                delay(1_000)\n                mutable++\n            }\n        }\n        assertEquals(1, mutable)\n    }\n\n\n    @Test\n    fun testWithTestContextThrowingAnAssertionError() {\n        assertFailsWith<TestException> {\n            runBlockingTest {\n                val expectedError = TestException(\"hello\")\n\n                launch {\n                    throw expectedError\n                }\n\n                // don't rethrow or handle the exception\n            }\n        }\n    }\n\n    @Test\n    fun testExceptionHandlingWithLaunch() {\n        assertFailsWith<TestException> {\n            runBlockingTest {\n                val expectedError = TestException(\"hello\")\n\n                launch {\n                    throw expectedError\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testExceptions_notThrownImmediately() {\n        assertFailsWith<TestException> {\n            runBlockingTest {\n                val expectedException = TestException(\"hello\")\n                val result = runCatching {\n                    launch {\n                        throw expectedException\n                    }\n                }\n                runCurrent()\n                assertEquals(true, result.isSuccess)\n            }\n        }\n    }\n\n\n    private val exceptionHandler = TestCoroutineExceptionHandler()\n\n    @Test\n    fun testPartialContextOverride() = runBlockingTest(CoroutineName(\"named\")) {\n        assertEquals(CoroutineName(\"named\"), coroutineContext[CoroutineName])\n        assertNotNull(coroutineContext[CoroutineExceptionHandler])\n        assertNotSame(coroutineContext[CoroutineExceptionHandler], exceptionHandler)\n    }\n\n    @Test\n    fun testPartialDispatcherOverride() {\n        assertFailsWith<IllegalArgumentException> {\n            runBlockingTest(Dispatchers.Unconfined) {\n                fail(\"Unreached\")\n            }\n        }\n    }\n\n    @Test\n    fun testOverrideExceptionHandler() = runBlockingTest(exceptionHandler) {\n        assertSame(coroutineContext[CoroutineExceptionHandler], exceptionHandler)\n    }\n\n    @Test\n    fun testOverrideExceptionHandlerError() {\n        assertFailsWith<IllegalArgumentException> {\n            runBlockingTest(CoroutineExceptionHandler { _, _ -> }) {\n                fail(\"Unreached\")\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/native/src/TestBuilders.kt",
        "content": "package kotlinx.coroutines.test\nimport kotlinx.coroutines.*\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual typealias TestResult = Unit\n\ninternal actual fun createTestResult(testProcedure: suspend CoroutineScope.() -> Unit) {\n    runBlocking {\n        testProcedure()\n    }\n}\n\ninternal actual fun systemPropertyImpl(name: String): String? = null\n\ninternal actual fun dumpCoroutines() { }\n"
    },
    {
        "path": "kotlinx-coroutines-test/native/src/internal/TestMainDispatcher.kt",
        "content": "package kotlinx.coroutines.test.internal\nimport kotlinx.coroutines.*\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\ninternal actual fun Dispatchers.getTestMainDispatcher(): TestMainDispatcher =\n    when (val mainDispatcher = Main) {\n        is TestMainDispatcher -> mainDispatcher\n        else -> TestMainDispatcher(mainDispatcher).also { injectMain(it) }\n    }\n"
    },
    {
        "path": "kotlinx-coroutines-test/native/test/Helpers.kt",
        "content": "package kotlinx.coroutines.test\n\nactual fun testResultChain(block: () -> TestResult, after: (Result<Unit>) -> TestResult): TestResult {\n    try {\n        block()\n        after(Result.success(Unit))\n    } catch (e: Throwable) {\n        after(Result.failure(e))\n    }\n}\n"
    },
    {
        "path": "kotlinx-coroutines-test/wasmJs/src/TestBuilders.kt",
        "content": "package kotlinx.coroutines.test\nimport kotlinx.coroutines.*\nimport kotlin.js.*\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"ACTUAL_TYPE_ALIAS_TO_CLASS_WITH_DECLARATION_SITE_VARIANCE\")\npublic actual typealias TestResult = Promise<JsAny?>\n\ninternal actual fun systemPropertyImpl(name: String): String? = null\n\ninternal actual fun createTestResult(testProcedure: suspend CoroutineScope.() -> Unit): TestResult =\n    GlobalScope.promise {\n        testProcedure()\n    }\n\ninternal actual fun dumpCoroutines() { }"
    },
    {
        "path": "kotlinx-coroutines-test/wasmJs/src/internal/TestMainDispatcher.kt",
        "content": "package kotlinx.coroutines.test.internal\nimport kotlinx.coroutines.*\n\n@Suppress(\"INVISIBLE_MEMBER\")\ninternal actual fun Dispatchers.getTestMainDispatcher(): TestMainDispatcher =\n    when (val mainDispatcher = Main) {\n        is TestMainDispatcher -> mainDispatcher\n        else -> TestMainDispatcher(mainDispatcher).also { injectMain(it) }\n    }\n"
    },
    {
        "path": "kotlinx-coroutines-test/wasmJs/test/Helpers.kt",
        "content": "package kotlinx.coroutines.test\n\nactual fun testResultChain(block: () -> TestResult, after: (Result<Unit>) -> TestResult): TestResult =\n    block().then(\n        {\n            after(Result.success(Unit))\n            null\n        }, {\n            after(Result.failure(it.toThrowableOrNull() ?: Throwable(\"Unexpected non-Kotlin exception $it\")))\n            null\n        })\n"
    },
    {
        "path": "kotlinx-coroutines-test/wasmJs/test/PromiseTest.kt",
        "content": "package kotlinx.coroutines.test\n\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nclass PromiseTest {\n    @Test\n    fun testCompletionFromPromise() = runTest {\n        var promiseEntered = false\n        val p = promise {\n            delay(1)\n            promiseEntered = true\n        }\n        delay(2)\n        p.await<JsAny>()\n        assertTrue(promiseEntered)\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/build.gradle.kts",
        "content": "import org.jetbrains.kotlin.gradle.dsl.*\n\ndependencies {\n    implementation(project(\":kotlinx-coroutines-reactive\"))\n}\n\njava {\n    sourceCompatibility = JavaVersion.VERSION_1_9\n    targetCompatibility = JavaVersion.VERSION_1_9\n}\n\ntasks {\n    compileKotlin {\n        compilerOptions.jvmTarget = JvmTarget.JVM_9\n    }\n\n    compileTestKotlin {\n        compilerOptions.jvmTarget = JvmTarget.JVM_9\n    }\n}\n\nexternalDocumentationLink(\n    url = \"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html\"\n)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/src/Await.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.*\nimport java.util.concurrent.*\nimport org.reactivestreams.FlowAdapters\nimport kotlinx.coroutines.reactive.*\n\n/**\n * Awaits the first value from the given publisher without blocking the thread and returns the resulting value, or, if\n * the publisher has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Flow.Subscription] and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the publisher does not emit any value\n */\npublic suspend fun <T> Flow.Publisher<T>.awaitFirst(): T =\n    FlowAdapters.toPublisher(this).awaitFirst()\n\n/**\n * Awaits the first value from the given publisher, or returns the [default] value if none is emitted, without blocking\n * the thread, and returns the resulting value, or, if this publisher has produced an error, throws the corresponding\n * exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Flow.Subscription] and resumes with [CancellationException].\n */\npublic suspend fun <T> Flow.Publisher<T>.awaitFirstOrDefault(default: T): T =\n    FlowAdapters.toPublisher(this).awaitFirstOrDefault(default)\n\n/**\n * Awaits the first value from the given publisher, or returns `null` if none is emitted, without blocking the thread,\n * and returns the resulting value, or, if this publisher has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Flow.Subscription] and resumes with [CancellationException].\n */\npublic suspend fun <T> Flow.Publisher<T>.awaitFirstOrNull(): T? =\n    FlowAdapters.toPublisher(this).awaitFirstOrNull()\n\n/**\n * Awaits the first value from the given publisher, or calls [defaultValue] to get a value if none is emitted, without\n * blocking the thread, and returns the resulting value, or, if this publisher has produced an error, throws the\n * corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Flow.Subscription] and resumes with [CancellationException].\n */\npublic suspend fun <T> Flow.Publisher<T>.awaitFirstOrElse(defaultValue: () -> T): T =\n    FlowAdapters.toPublisher(this).awaitFirstOrElse(defaultValue)\n\n/**\n * Awaits the last value from the given publisher without blocking the thread and\n * returns the resulting value, or, if this publisher has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Flow.Subscription] and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the publisher does not emit any value\n */\npublic suspend fun <T> Flow.Publisher<T>.awaitLast(): T =\n    FlowAdapters.toPublisher(this).awaitLast()\n\n/**\n * Awaits the single value from the given publisher without blocking the thread and returns the resulting value, or,\n * if this publisher has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Flow.Subscription] and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the publisher does not emit any value\n * @throws IllegalArgumentException if the publisher emits more than one value\n */\npublic suspend fun <T> Flow.Publisher<T>.awaitSingle(): T =\n    FlowAdapters.toPublisher(this).awaitSingle()\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/src/Publish.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.reactive.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\nimport org.reactivestreams.FlowAdapters\n\n/**\n * Creates a cold reactive [Flow.Publisher] that runs a given [block] in a coroutine.\n *\n * Every time the returned flux is subscribed, it starts a new coroutine in the specified [context].\n * The coroutine emits (via [Flow.Subscriber.onNext]) values with [send][ProducerScope.send],\n * completes (via [Flow.Subscriber.onComplete]) when the coroutine completes or channel is explicitly closed, and emits\n * errors (via [Flow.Subscriber.onError]) if the coroutine throws an exception or closes channel with a cause.\n * Unsubscribing cancels the running coroutine.\n *\n * Invocations of [send][ProducerScope.send] are suspended appropriately when subscribers apply back-pressure and to\n * ensure that [onNext][Flow.Subscriber.onNext] is not invoked concurrently.\n *\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is\n * used.\n *\n * **Note: This is an experimental api.** Behaviour of publishers that work as children in a parent scope with respect\n *        to cancellation and error handling may change in the future.\n *\n * @throws IllegalArgumentException if the provided [context] contains a [Job] instance.\n */\npublic fun <T> flowPublish(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Flow.Publisher<T> = FlowAdapters.toFlowPublisher(publish(context, block))\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/src/ReactiveFlow.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.asFlow\nimport kotlinx.coroutines.reactive.asPublisher as asReactivePublisher\nimport kotlinx.coroutines.reactive.collect\nimport kotlinx.coroutines.channels.*\nimport org.reactivestreams.*\nimport kotlin.coroutines.*\nimport java.util.concurrent.Flow as JFlow\n\n/**\n * Transforms the given reactive [Flow Publisher][JFlow.Publisher] into [Flow].\n * Use the [buffer] operator on the resulting flow to specify the size of the back-pressure.\n * In effect, it specifies the value of the subscription's [request][JFlow.Subscription.request].\n * The [default buffer capacity][Channel.BUFFERED] for a suspending channel is used by default.\n *\n * If any of the resulting flow transformations fails, the subscription is immediately cancelled and all the in-flight\n * elements are discarded.\n */\npublic fun <T : Any> JFlow.Publisher<T>.asFlow(): Flow<T> =\n    FlowAdapters.toPublisher(this).asFlow()\n\n/**\n * Transforms the given flow into a reactive specification compliant [Flow Publisher][JFlow.Publisher].\n *\n * An optional [context] can be specified to control the execution context of calls to the [Flow Subscriber][Subscriber]\n * methods.\n * A [CoroutineDispatcher] can be set to confine them to a specific thread; various [ThreadContextElement] can be set to\n * inject additional context into the caller thread. By default, the [Unconfined][Dispatchers.Unconfined] dispatcher\n * is used, so calls are performed from an arbitrary thread.\n */\n@JvmOverloads // binary compatibility\npublic fun <T : Any> Flow<T>.asPublisher(context: CoroutineContext = EmptyCoroutineContext): JFlow.Publisher<T> =\n    FlowAdapters.toFlowPublisher(asReactivePublisher(context))\n\n/**\n * Subscribes to this [Flow Publisher][JFlow.Publisher] and performs the specified action for each received element.\n *\n * If [action] throws an exception at some point, the subscription is cancelled, and the exception is rethrown from\n * [collect]. Also, if the publisher signals an error, that error is rethrown from [collect].\n */\npublic suspend inline fun <T> JFlow.Publisher<T>.collect(action: (T) -> Unit): Unit =\n    FlowAdapters.toPublisher(this).collect(action)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/test/AwaitTest.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.concurrent.Flow as JFlow\n\nclass AwaitTest: TestBase() {\n\n    /** Tests that calls to [awaitFirst] (and, thus, to the rest of these functions) throw [CancellationException] and\n     * unsubscribe from the publisher when their [Job] is cancelled. */\n    @Test\n    fun testAwaitCancellation() = runTest {\n        expect(1)\n        val publisher = JFlow.Publisher<Int> { s ->\n            s.onSubscribe(object : JFlow.Subscription {\n                override fun request(n: Long) {\n                    expect(3)\n                }\n\n                override fun cancel() {\n                    expect(5)\n                }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                publisher.awaitFirst()\n            } catch (e: CancellationException) {\n                expect(6)\n                throw e\n            }\n        }\n        expect(4)\n        job.cancelAndJoin()\n        finish(7)\n    }\n\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/test/FlowAsPublisherTest.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.Test\nimport java.util.concurrent.Flow as JFlow\nimport kotlin.test.*\n\nclass FlowAsPublisherTest : TestBase() {\n\n    @Test\n    fun testErrorOnCancellationIsReported() {\n        expect(1)\n        flow {\n            try {\n                emit(2)\n            } finally {\n                expect(3)\n                throw TestException()\n            }\n        }.asPublisher().subscribe(object : JFlow.Subscriber<Int> {\n            private lateinit var subscription: JFlow.Subscription\n\n            override fun onComplete() {\n                expectUnreached()\n            }\n\n            override fun onSubscribe(s: JFlow.Subscription?) {\n                subscription = s!!\n                subscription.request(2)\n            }\n\n            override fun onNext(t: Int) {\n                expect(t)\n                subscription.cancel()\n            }\n\n            override fun onError(t: Throwable?) {\n                assertIs<TestException>(t)\n                expect(4)\n            }\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testCancellationIsNotReported() {\n        expect(1)\n        flow {\n            emit(2)\n        }.asPublisher().subscribe(object : JFlow.Subscriber<Int> {\n            private lateinit var subscription: JFlow.Subscription\n\n            override fun onComplete() {\n                expectUnreached()\n            }\n\n            override fun onSubscribe(s: JFlow.Subscription?) {\n                subscription = s!!\n                subscription.request(2)\n            }\n\n            override fun onNext(t: Int) {\n                expect(t)\n                subscription.cancel()\n            }\n\n            override fun onError(t: Throwable?) {\n                expectUnreached()\n            }\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testFlowWithTimeout() = runTest {\n        val publisher = flow<Int> {\n            expect(2)\n            withTimeout(1) { delay(Long.MAX_VALUE) }\n        }.asPublisher()\n        try {\n            expect(1)\n            publisher.awaitFirstOrNull()\n        } catch (e: CancellationException) {\n            expect(3)\n        }\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/test/IntegrationTest.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlinx.coroutines.flow.flowOn\nimport kotlinx.coroutines.testing.exceptions.*\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport java.util.concurrent.Flow as JFlow\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass IntegrationTest(\n    private val ctx: Ctx,\n    private val delay: Boolean\n) : TestBase() {\n\n    enum class Ctx {\n        MAIN        { override fun invoke(context: CoroutineContext): CoroutineContext = context.minusKey(Job) },\n        DEFAULT     { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Default },\n        UNCONFINED  { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Unconfined };\n\n        abstract operator fun invoke(context: CoroutineContext): CoroutineContext\n    }\n\n    companion object {\n        @Parameterized.Parameters(name = \"ctx={0}, delay={1}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = Ctx.values().flatMap { ctx ->\n            listOf(false, true).map { delay ->\n                arrayOf(ctx, delay)\n            }\n        }\n    }\n\n    @Test\n    fun testEmpty(): Unit = runBlocking {\n        val pub = flowPublish<String>(ctx(coroutineContext)) {\n            if (delay) delay(1)\n            // does not send anything\n        }\n        assertFailsWith<NoSuchElementException> { pub.awaitFirst() }\n        assertEquals(\"OK\", pub.awaitFirstOrDefault(\"OK\"))\n        assertNull(pub.awaitFirstOrNull())\n        assertEquals(\"ELSE\", pub.awaitFirstOrElse { \"ELSE\" })\n        assertFailsWith<NoSuchElementException> { pub.awaitLast() }\n        assertFailsWith<NoSuchElementException> { pub.awaitSingle() }\n        var cnt = 0\n        pub.collect { cnt++ }\n        assertEquals(0, cnt)\n    }\n\n    @Test\n    fun testSingle() = runBlocking {\n        val pub = flowPublish(ctx(coroutineContext)) {\n            if (delay) delay(1)\n            send(\"OK\")\n        }\n        assertEquals(\"OK\", pub.awaitFirst())\n        assertEquals(\"OK\", pub.awaitFirstOrDefault(\"!\"))\n        assertEquals(\"OK\", pub.awaitFirstOrNull())\n        assertEquals(\"OK\", pub.awaitFirstOrElse { \"ELSE\" })\n        assertEquals(\"OK\", pub.awaitLast())\n        assertEquals(\"OK\", pub.awaitSingle())\n        var cnt = 0\n        pub.collect {\n            assertEquals(\"OK\", it)\n            cnt++\n        }\n        assertEquals(1, cnt)\n    }\n\n    @Test\n    fun testNumbers() = runBlocking {\n        val n = 100 * stressTestMultiplier\n        val pub = flowPublish(ctx(coroutineContext)) {\n            for (i in 1..n) {\n                send(i)\n                if (delay) delay(1)\n            }\n        }\n        assertEquals(1, pub.awaitFirst())\n        assertEquals(1, pub.awaitFirstOrDefault(0))\n        assertEquals(n, pub.awaitLast())\n        assertEquals(1, pub.awaitFirstOrNull())\n        assertEquals(1, pub.awaitFirstOrElse { 0 })\n        assertFailsWith<IllegalArgumentException> { pub.awaitSingle() }\n        checkNumbers(n, pub)\n        val flow = pub.asFlow()\n        checkNumbers(n, flow.flowOn(ctx(coroutineContext)).asPublisher())\n    }\n\n    @Test\n    fun testCancelWithoutValue() = runTest {\n        val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {\n            flowPublish<String> {\n                hang {}\n            }.awaitFirst()\n        }\n\n        job.cancel()\n        job.join()\n    }\n\n    @Test\n    fun testEmptySingle() = runTest(unhandled = listOf { e -> e is NoSuchElementException}) {\n        expect(1)\n        val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {\n            flowPublish<String> {\n                yield()\n                expect(2)\n                // Nothing to emit\n            }.awaitFirst()\n        }\n\n        job.join()\n        finish(3)\n    }\n\n    private suspend fun checkNumbers(n: Int, pub: JFlow.Publisher<Int>) {\n        var last = 0\n        pub.collect {\n            assertEquals(++last, it)\n        }\n        assertEquals(n, last)\n    }\n\n}\n\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/test/PublishTest.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.testing.exceptions.*\nimport org.junit.Test\nimport java.util.concurrent.Flow as JFlow\nimport kotlin.test.*\n\nclass PublishTest : TestBase() {\n    @Test\n    fun testBasicEmpty() = runTest {\n        expect(1)\n        val publisher = flowPublish<Int>(currentDispatcher()) {\n            expect(5)\n        }\n        expect(2)\n        publisher.subscribe(object : JFlow.Subscriber<Int> {\n            override fun onSubscribe(s: JFlow.Subscription?) { expect(3) }\n            override fun onNext(t: Int?) { expectUnreached() }\n            override fun onComplete() { expect(6) }\n            override fun onError(t: Throwable?) { expectUnreached() }\n        })\n        expect(4)\n        yield() // to publish coroutine\n        finish(7)\n    }\n\n    @Test\n    fun testBasicSingle() = runTest {\n        expect(1)\n        val publisher = flowPublish(currentDispatcher()) {\n            expect(5)\n            send(42)\n            expect(7)\n        }\n        expect(2)\n        publisher.subscribe(object : JFlow.Subscriber<Int> {\n            override fun onSubscribe(s: JFlow.Subscription) {\n                expect(3)\n                s.request(1)\n            }\n            override fun onNext(t: Int) {\n                expect(6)\n                assertEquals(42, t)\n            }\n            override fun onComplete() { expect(8) }\n            override fun onError(t: Throwable?) { expectUnreached() }\n        })\n        expect(4)\n        yield() // to publish coroutine\n        finish(9)\n    }\n\n    @Test\n    fun testBasicError() = runTest {\n        expect(1)\n        val publisher = flowPublish<Int>(currentDispatcher()) {\n            expect(5)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        publisher.subscribe(object : JFlow.Subscriber<Int> {\n            override fun onSubscribe(s: JFlow.Subscription) {\n                expect(3)\n                s.request(1)\n            }\n            override fun onNext(t: Int) { expectUnreached() }\n            override fun onComplete() { expectUnreached() }\n            override fun onError(t: Throwable) {\n                expect(6)\n                assertIs<RuntimeException>(t)\n                assertEquals(\"OK\", t.message)\n            }\n        })\n        expect(4)\n        yield() // to publish coroutine\n        finish(7)\n    }\n\n    @Test\n    fun testHandleFailureAfterCancel() = runTest {\n        expect(1)\n\n        val eh = CoroutineExceptionHandler { _, t ->\n            assertIs<RuntimeException>(t)\n            expect(6)\n        }\n        val publisher = flowPublish<Unit>(Dispatchers.Unconfined + eh) {\n            try {\n                expect(3)\n                delay(10000)\n            } finally {\n                expect(5)\n                throw RuntimeException(\"FAILED\") // crash after cancel\n            }\n        }\n        var sub: JFlow.Subscription? = null\n        publisher.subscribe(object : JFlow.Subscriber<Unit> {\n            override fun onComplete() {\n                expectUnreached()\n            }\n\n            override fun onSubscribe(s: JFlow.Subscription) {\n                expect(2)\n                sub = s\n            }\n\n            override fun onNext(t: Unit?) {\n                expectUnreached()\n            }\n\n            override fun onError(t: Throwable?) {\n                expectUnreached()\n            }\n        })\n        expect(4)\n        sub!!.cancel()\n        finish(7)\n    }\n\n    /** Tests that, as soon as `ProducerScope.close` is called, `isClosedForSend` starts returning `true`. */\n    @Test\n    fun testChannelClosing() = runTest {\n        expect(1)\n        val publisher = flowPublish<Int>(Dispatchers.Unconfined) {\n            expect(3)\n            close()\n            assert(isClosedForSend)\n            expect(4)\n        }\n        try {\n            expect(2)\n            publisher.awaitFirstOrNull()\n        } catch (e: CancellationException) {\n            expect(5)\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testOnNextError() = runTest {\n        val latch = CompletableDeferred<Unit>()\n        expect(1)\n        assertCallsExceptionHandlerWith<TestException> { exceptionHandler ->\n            val publisher = flowPublish(currentDispatcher() + exceptionHandler) {\n                expect(4)\n                try {\n                    send(\"OK\")\n                } catch (e: Throwable) {\n                    expect(6)\n                    assert(e is TestException)\n                    assert(isClosedForSend)\n                    latch.complete(Unit)\n                }\n            }\n            expect(2)\n            publisher.subscribe(object : JFlow.Subscriber<String> {\n                override fun onComplete() {\n                    expectUnreached()\n                }\n\n                override fun onSubscribe(s: JFlow.Subscription) {\n                    expect(3)\n                    s.request(1)\n                }\n\n                override fun onNext(t: String) {\n                    expect(5)\n                    assertEquals(\"OK\", t)\n                    throw TestException()\n                }\n\n                override fun onError(t: Throwable) {\n                    expectUnreached()\n                }\n            })\n            latch.await()\n        }\n        finish(7)\n    }\n\n    /** Tests the behavior when a call to `onNext` fails after the channel is already closed. */\n    @Test\n    fun testOnNextErrorAfterCancellation() = runTest {\n        assertCallsExceptionHandlerWith<TestException> { handler ->\n            var producerScope: ProducerScope<Int>? = null\n            CompletableDeferred<Unit>()\n            expect(1)\n            var job: Job? = null\n            val publisher = flowPublish<Int>(handler + Dispatchers.Unconfined) {\n                producerScope = this\n                expect(4)\n                job = launch {\n                    delay(Long.MAX_VALUE)\n                }\n            }\n            expect(2)\n            publisher.subscribe(object : JFlow.Subscriber<Int> {\n                override fun onSubscribe(s: JFlow.Subscription) {\n                    expect(3)\n                    s.request(Long.MAX_VALUE)\n                }\n\n                override fun onNext(t: Int) {\n                    expect(6)\n                    assertEquals(1, t)\n                    job!!.cancel()\n                    throw TestException()\n                }\n\n                override fun onError(t: Throwable?) {\n                    /* Correct changes to the implementation could lead to us entering or not entering this method, but\n                    it only matters that if we do, it is the \"correct\" exception that was validly used to cancel the\n                    coroutine that gets passed here and not `TestException`. */\n                    assertIs<CancellationException>(t)\n                }\n\n                override fun onComplete() {\n                    expectUnreached()\n                }\n            })\n            expect(5)\n            val result: ChannelResult<Unit> = producerScope!!.trySend(1)\n            val e = result.exceptionOrNull()!!\n            assertIs<CancellationException>(e, \"The actual error: $e\")\n            assertTrue(producerScope!!.isClosedForSend)\n            assertTrue(result.isFailure)\n        }\n        finish(7)\n    }\n\n    @Test\n    fun testFailingConsumer() = runTest {\n        val pub = flowPublish(currentDispatcher()) {\n            repeat(3) {\n                expect(it + 1) // expect(1), expect(2) *should* be invoked\n                send(it)\n            }\n        }\n        try {\n            pub.collect {\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testIllegalArgumentException() {\n        assertFailsWith<IllegalArgumentException> { flowPublish<Int>(Job()) { } }\n    }\n\n    /** Tests that `trySend` doesn't throw in `flowPublish`. */\n    @Test\n    fun testTrySendNotThrowing() = runTest {\n        var producerScope: ProducerScope<Int>? = null\n        expect(1)\n        val publisher = flowPublish<Int>(Dispatchers.Unconfined) {\n            producerScope = this\n            expect(3)\n            delay(Long.MAX_VALUE)\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            publisher.awaitFirstOrNull()\n            expectUnreached()\n        }\n        job.cancel()\n        expect(4)\n        val result = producerScope!!.trySend(1)\n        assertTrue(result.isFailure)\n        finish(5)\n    }\n\n    /** Tests that all methods on `flowPublish` fail without closing the channel when attempting to emit `null`. */\n    @Test\n    fun testEmittingNull() = runTest {\n        val publisher = flowPublish {\n            assertFailsWith<NullPointerException> { send(null) }\n            assertFailsWith<NullPointerException> { trySend(null) }\n            send(\"OK\")\n        }\n        assertEquals(\"OK\", publisher.awaitFirstOrNull())\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/test/PublisherAsFlowTest.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.testing.flow.*\nimport kotlin.test.*\n\nclass PublisherAsFlowTest : TestBase() {\n    @Test\n    fun testCancellation() = runTest {\n        var onNext = 0\n        var onCancelled = 0\n        var onError = 0\n\n        val publisher = flowPublish(currentDispatcher()) {\n            coroutineContext[Job]?.invokeOnCompletion {\n                if (it is CancellationException) ++onCancelled\n            }\n\n            repeat(100) {\n                send(it)\n            }\n        }\n\n        publisher.asFlow().launchIn(CoroutineScope(Dispatchers.Unconfined)) {\n            onEach {\n                ++onNext\n                throw RuntimeException()\n            }\n            catch<Throwable> {\n                ++onError\n            }\n        }.join()\n\n\n        assertEquals(1, onNext)\n        assertEquals(1, onError)\n        assertEquals(1, onCancelled)\n    }\n\n    @Test\n    fun testBufferSize1() = runTest {\n        val publisher = flowPublish(currentDispatcher()) {\n            expect(1)\n            send(3)\n\n            expect(2)\n            send(5)\n\n            expect(4)\n            send(7)\n            expect(6)\n        }\n\n        publisher.asFlow().buffer(1).collect {\n            expect(it)\n        }\n\n        finish(8)\n    }\n\n    @Test\n    fun testBufferSizeDefault() = runTest {\n        val publisher = flowPublish(currentDispatcher()) {\n            repeat(64) {\n                send(it + 1)\n                expect(it + 1)\n            }\n            assertFalse { trySend(-1).isSuccess }\n        }\n\n        publisher.asFlow().collect {\n            expect(64 + it)\n        }\n\n        finish(129)\n    }\n\n    @Test\n    fun testDefaultCapacityIsProperlyOverwritten() = runTest {\n        val publisher = flowPublish(currentDispatcher()) {\n            expect(1)\n            send(3)\n            expect(2)\n            send(5)\n            expect(4)\n            send(7)\n            expect(6)\n        }\n\n        publisher.asFlow().flowOn(wrapperDispatcher()).buffer(1).collect {\n            expect(it)\n        }\n\n        finish(8)\n    }\n\n    @Test\n    fun testBufferSize10() = runTest {\n        val publisher = flowPublish(currentDispatcher()) {\n            expect(1)\n            send(5)\n\n            expect(2)\n            send(6)\n\n            expect(3)\n            send(7)\n            expect(4)\n        }\n\n        publisher.asFlow().buffer(10).collect {\n            expect(it)\n        }\n\n        finish(8)\n    }\n\n    @Test\n    fun testConflated() = runTest {\n        val publisher = flowPublish(currentDispatcher()) {\n            for (i in 1..5) send(i)\n        }\n        val list = publisher.asFlow().conflate().toList()\n        assertEquals(listOf(1, 5), list)\n    }\n\n    @Test\n    fun testProduce() = runTest {\n        val flow = flowPublish(currentDispatcher()) { repeat(10) { send(it) } }.asFlow()\n        check((0..9).toList(), flow.produceIn(this))\n        check((0..9).toList(), flow.buffer(2).produceIn(this))\n        check((0..9).toList(), flow.buffer(Channel.UNLIMITED).produceIn(this))\n        check(listOf(0, 9), flow.conflate().produceIn(this))\n    }\n\n    private suspend fun check(expected: List<Int>, channel: ReceiveChannel<Int>) {\n        val result = ArrayList<Int>(10)\n        channel.consumeEach { result.add(it) }\n        assertEquals(expected, result)\n    }\n\n    @Test\n    fun testProduceCancellation() = runTest {\n        expect(1)\n        // publisher is an async coroutine, so it overproduces to the channel, but still gets cancelled\n        val flow = flowPublish(currentDispatcher()) {\n            expect(3)\n            repeat(10) { value ->\n                when (value) {\n                    in 0..6 -> send(value)\n                    7 -> try {\n                        send(value)\n                    } catch (e: CancellationException) {\n                        expect(5)\n                        throw e\n                    }\n                    else -> expectUnreached()\n                }\n            }\n        }.asFlow().buffer(1)\n        assertFailsWith<TestException> {\n            coroutineScope {\n                expect(2)\n                val channel = flow.produceIn(this)\n                channel.consumeEach { value ->\n                    when (value) {\n                        in 0..4 -> {}\n                        5 -> {\n                            expect(4)\n                            throw TestException()\n                        }\n                        else -> expectUnreached()\n                    }\n                }\n            }\n        }\n        finish(6)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/test/PublisherBackpressureTest.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.concurrent.Flow as JFlow\n\nclass PublisherBackpressureTest : TestBase() {\n    @Test\n    fun testCancelWhileBPSuspended() = runBlocking {\n        expect(1)\n        val observable = flowPublish(currentDispatcher()) {\n            expect(5)\n            send(\"A\") // will not suspend, because an item was requested\n            expect(7)\n            send(\"B\") // second requested item\n            expect(9)\n            try {\n                send(\"C\") // will suspend (no more requested)\n            } finally {\n                expect(12)\n            }\n            expectUnreached()\n        }\n        expect(2)\n        var sub: JFlow.Subscription? = null\n        observable.subscribe(object : JFlow.Subscriber<String> {\n            override fun onSubscribe(s: JFlow.Subscription) {\n                sub = s\n                expect(3)\n                s.request(2) // request two items\n            }\n\n            override fun onNext(t: String) {\n                when (t) {\n                    \"A\" -> expect(6)\n                    \"B\" -> expect(8)\n                    else -> error(\"Should not happen\")\n                }\n            }\n\n            override fun onComplete() {\n                expectUnreached()\n            }\n\n            override fun onError(e: Throwable) {\n                expectUnreached()\n            }\n        })\n        expect(4)\n        yield() // yield to observable coroutine\n        expect(10)\n        sub!!.cancel() // now unsubscribe -- shall cancel coroutine (& do not signal)\n        expect(11)\n        yield() // shall perform finally in coroutine\n        finish(13)\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/test/PublisherCollectTest.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.Test\nimport org.reactivestreams.*\nimport kotlin.test.*\nimport java.util.concurrent.Flow as JFlow\n\nclass PublisherCollectTest: TestBase() {\n\n    /** Tests the simple scenario where the publisher outputs a bounded stream of values to collect. */\n    @Test\n    fun testCollect() = runTest {\n        val x = 100\n        val xSum = x * (x + 1) / 2\n        val publisher = JFlow.Publisher<Int> { subscriber ->\n            var requested = 0L\n            var lastOutput = 0\n            subscriber.onSubscribe(object: JFlow.Subscription {\n\n                override fun request(n: Long) {\n                    requested += n\n                    if (n <= 0) {\n                        subscriber.onError(IllegalArgumentException())\n                        return\n                    }\n                    while (lastOutput < x && lastOutput < requested) {\n                        lastOutput += 1\n                        subscriber.onNext(lastOutput)\n                    }\n                    if (lastOutput == x)\n                        subscriber.onComplete()\n                }\n\n                override fun cancel() {\n                    /** According to rule 3.5 of the\n                     * [reactive spec](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.5),\n                     * this method can be called by the subscriber at any point, so it's not an error if it's called\n                     * in this scenario. */\n                }\n\n            })\n        }\n        var sum = 0\n        publisher.collect {\n            sum += it\n        }\n        assertEquals(xSum, sum)\n    }\n\n    /** Tests the behavior of [collect] when the publisher raises an error. */\n    @Test\n    fun testCollectThrowingPublisher() = runTest {\n        val errorString = \"Too many elements requested\"\n        val x = 100\n        val xSum = x * (x + 1) / 2\n        val publisher = Publisher<Int> { subscriber ->\n            var requested = 0L\n            var lastOutput = 0\n            subscriber.onSubscribe(object: Subscription {\n\n                override fun request(n: Long) {\n                    requested += n\n                    if (n <= 0) {\n                        subscriber.onError(IllegalArgumentException())\n                        return\n                    }\n                    while (lastOutput < x && lastOutput < requested) {\n                        lastOutput += 1\n                        subscriber.onNext(lastOutput)\n                    }\n                    if (lastOutput == x)\n                        subscriber.onError(IllegalArgumentException(errorString))\n                }\n\n                override fun cancel() {\n                    /** See the comment for the corresponding part of [testCollect]. */\n                }\n\n            })\n        }\n        var sum = 0\n        try {\n            publisher.collect {\n                sum += it\n            }\n        } catch (e: IllegalArgumentException) {\n            assertEquals(errorString, e.message)\n        }\n        assertEquals(xSum, sum)\n    }\n\n    /** Tests the behavior of [collect] when the action throws. */\n    @Test\n    fun testCollectThrowingAction() = runTest {\n        val errorString = \"Too many elements produced\"\n        val x = 100\n        val xSum = x * (x + 1) / 2\n        val publisher = Publisher<Int> { subscriber ->\n            var requested = 0L\n            var lastOutput = 0\n            subscriber.onSubscribe(object: Subscription {\n\n                override fun request(n: Long) {\n                    requested += n\n                    if (n <= 0) {\n                        subscriber.onError(IllegalArgumentException())\n                        return\n                    }\n                    while (lastOutput < x && lastOutput < requested) {\n                        lastOutput += 1\n                        subscriber.onNext(lastOutput)\n                    }\n                }\n\n                override fun cancel() {\n                    assertEquals(x, lastOutput)\n                    expect(x + 2)\n                }\n\n            })\n        }\n        var sum = 0\n        try {\n            expect(1)\n            var i = 1\n            publisher.collect {\n                sum += it\n                i += 1\n                expect(i)\n                if (sum >= xSum) {\n                    throw IllegalArgumentException(errorString)\n                }\n            }\n        } catch (e: IllegalArgumentException) {\n            expect(x + 3)\n            assertEquals(errorString, e.message)\n        }\n        finish(x + 4)\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/test/PublisherCompletionStressTest.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.*\nimport kotlin.coroutines.*\n\nclass PublisherCompletionStressTest : TestBase() {\n    private val N_REPEATS = 10_000 * stressTestMultiplier\n\n    private fun CoroutineScope.range(context: CoroutineContext, start: Int, count: Int) = flowPublish(context) {\n        for (x in start until start + count) send(x)\n    }\n\n    @Test\n    fun testCompletion() {\n        val rnd = Random()\n        repeat(N_REPEATS) {\n            val count = rnd.nextInt(5)\n            runBlocking {\n                withTimeout(5000) {\n                    var received = 0\n                    range(Dispatchers.Default, 1, count).collect { x ->\n                        received++\n                        if (x != received) error(\"$x != $received\")\n                    }\n                    if (received != count) error(\"$received != $count\")\n                }\n            }\n        }\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-jdk9/test/PublisherMultiTest.kt",
        "content": "package kotlinx.coroutines.jdk9\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass PublisherMultiTest : TestBase() {\n    @Test\n    fun testConcurrentStress() = runBlocking {\n        val n = 10_000 * stressTestMultiplier\n        val observable = flowPublish {\n            // concurrent emitters (many coroutines)\n            val jobs = List(n) {\n                // launch\n                launch {\n                    send(it)\n                }\n            }\n            jobs.forEach { it.join() }\n        }\n        val resultSet = mutableSetOf<Int>()\n        observable.collect {\n            assertTrue(resultSet.add(it))\n        }\n        assertEquals(n, resultSet.size)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/build.gradle.kts",
        "content": "plugins {\n    // apply plugin to use autocomplete for Kover DSL\n    id(\"org.jetbrains.kotlinx.kover\")\n}\n\nval reactiveStreamsVersion = property(\"reactive_streams_version\")\n\ndependencies {\n    api(\"org.reactivestreams:reactive-streams:$reactiveStreamsVersion\")\n    testImplementation(\"org.reactivestreams:reactive-streams-tck:$reactiveStreamsVersion\")\n}\n\nval testNG by tasks.registering(Test::class) {\n    useTestNG()\n    reports.html.outputLocation = layout.buildDirectory.dir(\"reports/testng\")\n    include(\"**/*ReactiveStreamTckTest.*\")\n    // Skip testNG when tests are filtered with --tests, otherwise it simply fails\n    onlyIf {\n        filter.includePatterns.isEmpty()\n    }\n    doFirst {\n        // Classic gradle, nothing works without doFirst\n        println(\"TestNG tests: ($includes)\")\n    }\n}\n\ntasks.test {\n    reports.html.outputLocation = layout.buildDirectory.dir(\"reports/junit\")\n}\n\ntasks.check {\n    dependsOn(testNG)\n}\n\nexternalDocumentationLink(\n    url = \"https://www.reactive-streams.org/reactive-streams-$reactiveStreamsVersion-javadoc/\"\n)\n\nkover {\n    reports {\n        filters {\n            excludes {\n                classes(\n                    \"kotlinx.coroutines.reactive.FlowKt\", // Deprecated\n                    \"kotlinx.coroutines.reactive.FlowKt__MigrationKt\", // Deprecated\n                    \"kotlinx.coroutines.reactive.ConvertKt\" // Deprecated\n                )\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/src/Await.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.*\nimport org.reactivestreams.Publisher\nimport org.reactivestreams.Subscriber\nimport org.reactivestreams.Subscription\nimport java.lang.IllegalStateException\nimport kotlin.coroutines.*\n\n/**\n * Awaits the first value from the given publisher without blocking the thread and returns the resulting value, or, if\n * the publisher has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the publisher does not emit any value\n */\npublic suspend fun <T> Publisher<T>.awaitFirst(): T = awaitOne(Mode.FIRST)\n\n/**\n * Awaits the first value from the given publisher, or returns the [default] value if none is emitted, without blocking\n * the thread, and returns the resulting value, or, if this publisher has produced an error, throws the corresponding\n * exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n */\npublic suspend fun <T> Publisher<T>.awaitFirstOrDefault(default: T): T = awaitOne(Mode.FIRST_OR_DEFAULT, default)\n\n/**\n * Awaits the first value from the given publisher, or returns `null` if none is emitted, without blocking the thread,\n * and returns the resulting value, or, if this publisher has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n */\npublic suspend fun <T> Publisher<T>.awaitFirstOrNull(): T? = awaitOne(Mode.FIRST_OR_DEFAULT)\n\n/**\n * Awaits the first value from the given publisher, or calls [defaultValue] to get a value if none is emitted, without\n * blocking the thread, and returns the resulting value, or, if this publisher has produced an error, throws the\n * corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n */\npublic suspend fun <T> Publisher<T>.awaitFirstOrElse(defaultValue: () -> T): T = awaitOne(Mode.FIRST_OR_DEFAULT) ?: defaultValue()\n\n/**\n * Awaits the last value from the given publisher without blocking the thread and\n * returns the resulting value, or, if this publisher has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the publisher does not emit any value\n */\npublic suspend fun <T> Publisher<T>.awaitLast(): T = awaitOne(Mode.LAST)\n\n/**\n * Awaits the single value from the given publisher without blocking the thread and returns the resulting value, or,\n * if this publisher has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the publisher does not emit any value\n * @throws IllegalArgumentException if the publisher emits more than one value\n */\npublic suspend fun <T> Publisher<T>.awaitSingle(): T = awaitOne(Mode.SINGLE)\n\n/**\n * Awaits the single value from the given publisher, or returns the [default] value if none is emitted, without\n * blocking the thread, and returns the resulting value, or, if this publisher has produced an error, throws the\n * corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n *\n * ### Deprecation\n *\n * This method is deprecated because the conventions established in Kotlin mandate that an operation with the name\n * `awaitSingleOrDefault` returns the default value instead of throwing in case there is an error; however, this would\n * also mean that this method would return the default value if there are *too many* values. This could be confusing to\n * those who expect this function to validate that there is a single element or none at all emitted, and cases where\n * there are no elements are indistinguishable from those where there are too many, though these cases have different\n * meaning.\n *\n * @throws NoSuchElementException if the publisher does not emit any value\n * @throws IllegalArgumentException if the publisher emits more than one value\n *\n * @suppress\n */\n@Deprecated(\n    message = \"Deprecated without a replacement due to its name incorrectly conveying the behavior. \" +\n        \"Please consider using awaitFirstOrDefault().\",\n    level = DeprecationLevel.HIDDEN\n) // Warning since 1.5, error in 1.6, hidden in 1.7\npublic suspend fun <T> Publisher<T>.awaitSingleOrDefault(default: T): T = awaitOne(Mode.SINGLE_OR_DEFAULT, default)\n\n/**\n * Awaits the single value from the given publisher without blocking the thread and returns the resulting value, or, if\n * this publisher has produced an error, throws the corresponding exception. If more than one value or none were\n * produced by the publisher, `null` is returned.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n *\n * ### Deprecation\n *\n * This method is deprecated because the conventions established in Kotlin mandate that an operation with the name\n * `awaitSingleOrNull` returns `null` instead of throwing in case there is an error; however, this would\n * also mean that this method would return `null` if there are *too many* values. This could be confusing to\n * those who expect this function to validate that there is a single element or none at all emitted, and cases where\n * there are no elements are indistinguishable from those where there are too many, though these cases have different\n * meaning.\n *\n * @throws IllegalArgumentException if the publisher emits more than one value\n * @suppress\n */\n@Deprecated(\n    message = \"Deprecated without a replacement due to its name incorrectly conveying the behavior. \" +\n        \"There is a specialized version for Reactor's Mono, please use that where applicable. \" +\n        \"Alternatively, please consider using awaitFirstOrNull().\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingleOrNull()\", \"kotlinx.coroutines.reactor\")\n) // Warning since 1.5, error in 1.6, hidden in 1.7\npublic suspend fun <T> Publisher<T>.awaitSingleOrNull(): T? = awaitOne(Mode.SINGLE_OR_DEFAULT)\n\n/**\n * Awaits the single value from the given publisher, or calls [defaultValue] to get a value if none is emitted, without\n * blocking the thread, and returns the resulting value, or, if this publisher has produced an error, throws the\n * corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n *\n * ### Deprecation\n *\n * This method is deprecated because the conventions established in Kotlin mandate that an operation with the name\n * `awaitSingleOrElse` returns the calculated value instead of throwing in case there is an error; however, this would\n * also mean that this method would return the calculated value if there are *too many* values. This could be confusing\n * to those who expect this function to validate that there is a single element or none at all emitted, and cases where\n * there are no elements are indistinguishable from those where there are too many, though these cases have different\n * meaning.\n *\n * @throws IllegalArgumentException if the publisher emits more than one value\n * @suppress\n */\n@Deprecated(\n    message = \"Deprecated without a replacement due to its name incorrectly conveying the behavior. \" +\n        \"Please consider using awaitFirstOrElse().\",\n    level = DeprecationLevel.HIDDEN\n) // Warning since 1.5, error in 1.6, hidden in 1.7\npublic suspend fun <T> Publisher<T>.awaitSingleOrElse(defaultValue: () -> T): T =\n    awaitOne(Mode.SINGLE_OR_DEFAULT) ?: defaultValue()\n\n// ------------------------ private ------------------------\n\nprivate enum class Mode(val s: String) {\n    FIRST(\"awaitFirst\"),\n    FIRST_OR_DEFAULT(\"awaitFirstOrDefault\"),\n    LAST(\"awaitLast\"),\n    SINGLE(\"awaitSingle\"),\n    SINGLE_OR_DEFAULT(\"awaitSingleOrDefault\");\n    override fun toString(): String = s\n}\n\nprivate suspend fun <T> Publisher<T>.awaitOne(\n    mode: Mode,\n    default: T? = null\n): T = suspendCancellableCoroutine { cont ->\n    /* This implementation must obey\n    https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#2-subscriber-code\n    The numbers of rules are taken from there. */\n    injectCoroutineContext(cont.context).subscribe(object : Subscriber<T> {\n        // It is unclear whether 2.13 implies (T: Any), but if so, it seems that we don't break anything by not adhering\n        private var subscription: Subscription? = null\n        private var value: T? = null\n        private var seenValue = false\n        private var inTerminalState = false\n\n        override fun onSubscribe(sub: Subscription) {\n            /** cancelling the new subscription due to rule 2.5, though the publisher would either have to\n             * subscribe more than once, which would break 2.12, or leak this [Subscriber]. */\n            if (subscription != null) {\n                withSubscriptionLock {\n                    sub.cancel()\n                }\n                return\n            }\n            subscription = sub\n            cont.invokeOnCancellation {\n                withSubscriptionLock {\n                    sub.cancel()\n                }\n            }\n            withSubscriptionLock {\n                sub.request(if (mode == Mode.FIRST || mode == Mode.FIRST_OR_DEFAULT) 1 else Long.MAX_VALUE)\n            }\n        }\n\n        override fun onNext(t: T) {\n            val sub = subscription.let {\n                if (it == null) {\n                    /** Enforce rule 1.9: expect [Subscriber.onSubscribe] before any other signals. */\n                    handleCoroutineException(cont.context,\n                        IllegalStateException(\"'onNext' was called before 'onSubscribe'\"))\n                    return\n                } else {\n                    it\n                }\n            }\n            if (inTerminalState) {\n                gotSignalInTerminalStateException(cont.context, \"onNext\")\n                return\n            }\n            when (mode) {\n                Mode.FIRST, Mode.FIRST_OR_DEFAULT -> {\n                    if (seenValue) {\n                        moreThanOneValueProvidedException(cont.context, mode)\n                        return\n                    }\n                    seenValue = true\n                    withSubscriptionLock {\n                        sub.cancel()\n                    }\n                    cont.resume(t)\n                }\n                Mode.LAST, Mode.SINGLE, Mode.SINGLE_OR_DEFAULT -> {\n                    if ((mode == Mode.SINGLE || mode == Mode.SINGLE_OR_DEFAULT) && seenValue) {\n                        withSubscriptionLock {\n                            sub.cancel()\n                        }\n                        /* the check for `cont.isActive` is needed in case `sub.cancel() above calls `onComplete` or\n                         `onError` on its own. */\n                        if (cont.isActive) {\n                            cont.resumeWithException(IllegalArgumentException(\"More than one onNext value for $mode\"))\n                        }\n                    } else {\n                        value = t\n                        seenValue = true\n                    }\n                }\n            }\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun onComplete() {\n            if (!tryEnterTerminalState(\"onComplete\")) {\n                return\n            }\n            if (seenValue) {\n                /* the check for `cont.isActive` is needed because, otherwise, if the publisher doesn't acknowledge the\n                call to `cancel` for modes `SINGLE*` when more than one value was seen, it may call `onComplete`, and\n                here `cont.resume` would fail. */\n                if (mode != Mode.FIRST_OR_DEFAULT && mode != Mode.FIRST && cont.isActive) {\n                    cont.resume(value as T)\n                }\n                return\n            }\n            when {\n                (mode == Mode.FIRST_OR_DEFAULT || mode == Mode.SINGLE_OR_DEFAULT) -> {\n                    cont.resume(default as T)\n                }\n                cont.isActive -> {\n                    // the check for `cont.isActive` is just a slight optimization and doesn't affect correctness\n                    cont.resumeWithException(NoSuchElementException(\"No value received via onNext for $mode\"))\n                }\n            }\n        }\n\n        override fun onError(e: Throwable) {\n            if (tryEnterTerminalState(\"onError\")) {\n                cont.resumeWithException(e)\n            }\n        }\n\n        /**\n         * Enforce rule 2.4: assume that the [Publisher] is in a terminal state after [onError] or [onComplete].\n         */\n        private fun tryEnterTerminalState(signalName: String): Boolean {\n            if (inTerminalState) {\n                gotSignalInTerminalStateException(cont.context, signalName)\n                return false\n            }\n            inTerminalState = true\n            return true\n        }\n\n        /**\n         * Enforce rule 2.7: [Subscription.request] and [Subscription.cancel] must be executed serially\n         */\n        @Synchronized\n        private fun withSubscriptionLock(block: () -> Unit) {\n            block()\n        }\n    })\n}\n\n/**\n * Enforce rule 2.4 (detect publishers that don't respect rule 1.7): don't process anything after a terminal\n * state was reached.\n */\nprivate fun gotSignalInTerminalStateException(context: CoroutineContext, signalName: String) =\n    handleCoroutineException(context,\n        IllegalStateException(\"'$signalName' was called after the publisher already signalled being in a terminal state\"))\n\n/**\n * Enforce rule 1.1: it is invalid for a publisher to provide more values than requested.\n */\nprivate fun moreThanOneValueProvidedException(context: CoroutineContext, mode: Mode) =\n    handleCoroutineException(context,\n        IllegalStateException(\"Only a single value was requested in '$mode', but the publisher provided more\"))\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/src/Channel.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport org.reactivestreams.*\n\n/**\n * Subscribes to this [Publisher] and performs the specified action for each received element.\n *\n * If [action] throws an exception at some point, the subscription is cancelled, and the exception is rethrown from\n * [collect]. Also, if the publisher signals an error, that error is rethrown from [collect].\n */\npublic suspend inline fun <T> Publisher<T>.collect(action: (T) -> Unit): Unit =\n    toChannel().consumeEach(action)\n\n@PublishedApi\ninternal fun <T> Publisher<T>.toChannel(request: Int = 1): ReceiveChannel<T> {\n    val channel = SubscriptionChannel<T>(request)\n    subscribe(channel)\n    return channel\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\", \"SubscriberImplementation\")\nprivate class SubscriptionChannel<T>(\n    private val request: Int\n) : BufferedChannel<T>(capacity = Channel.UNLIMITED), Subscriber<T> {\n    init {\n        require(request >= 0) { \"Invalid request size: $request\" }\n    }\n\n    private val _subscription = atomic<Subscription?>(null)\n\n    // requested from subscription minus number of received minus number of enqueued receivers,\n    // can be negative if we have receivers, but no subscription yet\n    private val _requested = atomic(0)\n\n    // --------------------- BufferedChannel overrides -------------------------------\n    @Suppress(\"CANNOT_OVERRIDE_INVISIBLE_MEMBER\")\n    override fun onReceiveEnqueued() {\n        _requested.loop { wasRequested ->\n            val subscription = _subscription.value\n            val needRequested = wasRequested - 1\n            if (subscription != null && needRequested < 0) { // need to request more from subscription\n                // try to fixup by making request\n                if (wasRequested != request && !_requested.compareAndSet(wasRequested, request))\n                    return@loop // continue looping if failed\n                subscription.request((request - needRequested).toLong())\n                return\n            }\n            // just do book-keeping\n            if (_requested.compareAndSet(wasRequested, needRequested)) return\n        }\n    }\n\n    @Suppress(\"CANNOT_OVERRIDE_INVISIBLE_MEMBER\")\n    override fun onReceiveDequeued() {\n        _requested.incrementAndGet()\n    }\n\n    @Suppress(\"CANNOT_OVERRIDE_INVISIBLE_MEMBER\")\n    override fun onClosedIdempotent() {\n        _subscription.getAndSet(null)?.cancel() // cancel exactly once\n    }\n\n    // --------------------- Subscriber overrides -------------------------------\n    override fun onSubscribe(s: Subscription) {\n        _subscription.value = s\n        while (true) { // lock-free loop on _requested\n            if (isClosedForSend) {\n                s.cancel()\n                return\n            }\n            val wasRequested = _requested.value\n            if (wasRequested >= request) return // ok -- normal story\n            // otherwise, receivers came before we had subscription or need to make initial request\n            // try to fixup by making request\n            if (!_requested.compareAndSet(wasRequested, request)) continue\n            s.request((request - wasRequested).toLong())\n            return\n        }\n    }\n\n    override fun onNext(t: T) {\n        _requested.decrementAndGet()\n        trySend(t) // Safe to ignore return value here, expectedly racing with cancellation\n    }\n\n    override fun onComplete() {\n        close(cause = null)\n    }\n\n    override fun onError(e: Throwable) {\n        close(cause = e)\n    }\n}\n\n/** @suppress */\n@Deprecated(\n    message = \"Transforming publisher to channel is deprecated, use asFlow() instead\",\n    level = DeprecationLevel.HIDDEN) // ERROR in 1.4, HIDDEN in 1.6.0\npublic fun <T> Publisher<T>.openSubscription(request: Int = 1): ReceiveChannel<T> {\n    val channel = SubscriptionChannel<T>(request)\n    subscribe(channel)\n    return channel\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/src/ContextInjector.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.InternalCoroutinesApi\nimport org.reactivestreams.Publisher\nimport kotlin.coroutines.CoroutineContext\n\n/** @suppress */\n@InternalCoroutinesApi\npublic interface ContextInjector {\n    /**\n     * Injects `ReactorContext` element from the given context into the `SubscriberContext` of the publisher.\n     * This API used as an indirection layer between `reactive` and `reactor` modules.\n     */\n    public fun <T> injectCoroutineContext(publisher: Publisher<T>, coroutineContext: CoroutineContext): Publisher<T>\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/src/Convert.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.channels.*\nimport org.reactivestreams.*\nimport kotlin.coroutines.*\n\n/** @suppress */\n@Deprecated(message = \"Deprecated in the favour of consumeAsFlow()\",\n    level = DeprecationLevel.HIDDEN, // Error in 1.4, HIDDEN in 1.6.0\n    replaceWith = ReplaceWith(\"this.consumeAsFlow().asPublisher(context)\", imports = [\"kotlinx.coroutines.flow.consumeAsFlow\"]))\npublic fun <T> ReceiveChannel<T>.asPublisher(context: CoroutineContext = EmptyCoroutineContext): Publisher<T> = publish(context) {\n    for (t in this@asPublisher)\n        send(t)\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/src/Migration.kt",
        "content": "@file:JvmMultifileClass\n@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.reactivestreams.*\n\n// Binary compatibility with Spring 5.2 RC\n/** @suppress */\n@Deprecated(\n    message = \"Replaced in favor of ReactiveFlow extension, please import kotlinx.coroutines.reactive.* instead of kotlinx.coroutines.reactive.FlowKt\",\n    level = DeprecationLevel.HIDDEN\n)\n@JvmName(\"asFlow\")\npublic fun <T : Any> Publisher<T>.asFlowDeprecated(): Flow<T> = asFlow()\n\n// Binary compatibility with Spring 5.2 RC\n/** @suppress */\n@Deprecated(\n    message = \"Replaced in favor of ReactiveFlow extension, please import kotlinx.coroutines.reactive.* instead of kotlinx.coroutines.reactive.FlowKt\",\n    level = DeprecationLevel.HIDDEN\n)\n@JvmName(\"asPublisher\")\npublic fun <T : Any> Flow<T>.asPublisherDeprecated(): Publisher<T> = asPublisher()\n\n/** @suppress */\n@Deprecated(\n    message = \"batchSize parameter is deprecated, use .buffer() instead to control the backpressure\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"asFlow().buffer(batchSize)\", imports = [\"kotlinx.coroutines.flow.*\"])\n)\npublic fun <T : Any> Publisher<T>.asFlow(batchSize: Int): Flow<T> = asFlow().buffer(batchSize)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/src/Publish.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport kotlinx.coroutines.sync.*\nimport org.reactivestreams.*\nimport kotlin.coroutines.*\n\n/**\n * Creates a cold reactive [Publisher] that runs a given [block] in a coroutine.\n *\n * Every time the returned flux is subscribed, it starts a new coroutine in the specified [context].\n * The coroutine emits (via [Subscriber.onNext]) values with [send][ProducerScope.send],\n * completes (via [Subscriber.onComplete]) when the coroutine completes or channel is explicitly closed, and emits\n * errors (via [Subscriber.onError]) if the coroutine throws an exception or closes channel with a cause.\n * Unsubscribing cancels the running coroutine.\n *\n * Invocations of [send][ProducerScope.send] are suspended appropriately when subscribers apply back-pressure and to\n * ensure that [onNext][Subscriber.onNext] is not invoked concurrently.\n *\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is\n * used.\n *\n * **Note: This is an experimental api.** Behaviour of publishers that work as children in a parent scope with respect\n *        to cancellation and error handling may change in the future.\n *\n * @throws IllegalArgumentException if the provided [context] contains a [Job] instance.\n */\npublic fun <T> publish(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Publisher<T> {\n    require(context[Job] === null) { \"Publisher context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via subscription. Had $context\" }\n    return publishInternal(GlobalScope, context, DEFAULT_HANDLER, block)\n}\n\n/** @suppress For internal use from other reactive integration modules only */\n@InternalCoroutinesApi\npublic fun <T> publishInternal(\n    scope: CoroutineScope, // support for legacy publish in scope\n    context: CoroutineContext,\n    exceptionOnCancelHandler: (Throwable, CoroutineContext) -> Unit,\n    block: suspend ProducerScope<T>.() -> Unit\n): Publisher<T> = Publisher { subscriber ->\n    // specification requires NPE on null subscriber\n    if (subscriber == null) throw NullPointerException(\"Subscriber cannot be null\")\n    val newContext = scope.newCoroutineContext(context)\n    val coroutine = PublisherCoroutine(newContext, subscriber, exceptionOnCancelHandler)\n    subscriber.onSubscribe(coroutine) // do it first (before starting coroutine), to avoid unnecessary suspensions\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate const val CLOSED = -1L    // closed, but have not signalled onCompleted/onError yet\nprivate const val SIGNALLED = -2L  // already signalled subscriber onCompleted/onError\nprivate val DEFAULT_HANDLER: (Throwable, CoroutineContext) -> Unit = { t, ctx -> if (t !is CancellationException) handleCoroutineException(ctx, t) }\n\n/** @suppress */\n@Suppress(\"CONFLICTING_JVM_DECLARATIONS\", \"RETURN_TYPE_MISMATCH_ON_INHERITANCE\")\n@InternalCoroutinesApi\npublic class PublisherCoroutine<in T>(\n    parentContext: CoroutineContext,\n    private val subscriber: Subscriber<T>,\n    private val exceptionOnCancelHandler: (Throwable, CoroutineContext) -> Unit\n) : AbstractCoroutine<Unit>(parentContext, false, true), ProducerScope<T>, Subscription {\n    override val channel: SendChannel<T> get() = this\n\n    private val _nRequested = atomic(0L) // < 0 when closed (CLOSED or SIGNALLED)\n\n    @Volatile\n    private var cancelled = false // true after Subscription.cancel() is invoked\n\n    override val isClosedForSend: Boolean get() = !isActive\n    override fun close(cause: Throwable?): Boolean = cancelCoroutine(cause)\n    override fun invokeOnClose(handler: (Throwable?) -> Unit): Nothing =\n        throw UnsupportedOperationException(\"PublisherCoroutine doesn't support invokeOnClose\")\n\n    // Mutex is locked when either nRequested == 0 or while subscriber.onXXX is being invoked\n    private val mutex: Mutex = Mutex(locked = true)\n\n    @Suppress(\"UNCHECKED_CAST\", \"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n    override val onSend: SelectClause2<T, SendChannel<T>> get() = SelectClause2Impl(\n        clauseObject = this,\n        regFunc = PublisherCoroutine<*>::registerSelectForSend as RegistrationFunction,\n        processResFunc = PublisherCoroutine<*>::processResultSelectSend as ProcessResultFunction\n    )\n\n    @Suppress(\"UNCHECKED_CAST\", \"UNUSED_PARAMETER\")\n    private fun registerSelectForSend(select: SelectInstance<*>, element: Any?) {\n        // Try to acquire the mutex and complete in the registration phase.\n        if (mutex.tryLock()) {\n            select.selectInRegistrationPhase(Unit)\n            return\n        }\n        // Start a new coroutine that waits for the mutex, invoking `trySelect(..)` after that.\n        // Please note that at the point of the `trySelect(..)` invocation the corresponding\n        // `select` can still be in the registration phase, making this `trySelect(..)` bound to fail.\n        // In this case, the `onSend` clause will be re-registered, which alongside with the mutex\n        // manipulation makes the resulting solution obstruction-free.\n        launch {\n            mutex.lock()\n            if (!select.trySelect(this@PublisherCoroutine, Unit)) {\n                mutex.unlock()\n            }\n        }\n    }\n\n    @Suppress(\"RedundantNullableReturnType\", \"UNUSED_PARAMETER\", \"UNCHECKED_CAST\")\n    private fun processResultSelectSend(element: Any?, selectResult: Any?): Any? {\n        doLockedNext(element as T)?.let { throw it }\n        return this@PublisherCoroutine\n    }\n\n    override fun trySend(element: T): ChannelResult<Unit> =\n        if (!mutex.tryLock()) {\n            ChannelResult.failure()\n        } else {\n            when (val throwable = doLockedNext(element)) {\n                null -> ChannelResult.success(Unit)\n                else -> ChannelResult.closed(throwable)\n            }\n        }\n\n    public override suspend fun send(element: T) {\n        mutex.lock()\n        doLockedNext(element)?.let { throw it }\n    }\n\n    /*\n     * This code is not trivial because of the following properties:\n     * 1. It ensures conformance to the reactive specification that mandates that onXXX invocations should not\n     *    be concurrent. It uses Mutex to protect all onXXX invocation and ensure conformance even when multiple\n     *    coroutines are invoking `send` function.\n     * 2. Normally, `onComplete/onError` notification is sent only when coroutine and all its children are complete.\n     *    However, nothing prevents `publish` coroutine from leaking reference to it send channel to some\n     *    globally-scoped coroutine that is invoking `send` outside of this context. Without extra precaution this may\n     *    lead to `onNext` that is concurrent with `onComplete/onError`, so that is why signalling for\n     *    `onComplete/onError` is also done under the same mutex.\n     * 3. The reactive specification forbids emitting more elements than requested, so `onNext` is forbidden until the\n     *    subscriber actually requests some elements. This is implemented by the mutex being locked when emitting\n     *    elements is not permitted (`_nRequested.value == 0`).\n     */\n\n    /**\n     * Attempts to emit a value to the subscriber and, if back-pressure permits this, unlock the mutex.\n     *\n     * Requires that the caller has locked the mutex before this invocation.\n     *\n     * If the channel is closed, returns the corresponding [Throwable]; otherwise, returns `null` to denote success.\n     *\n     * @throws NullPointerException if the passed element is `null`\n     */\n    private fun doLockedNext(elem: T): Throwable? {\n        if (elem == null) {\n            unlockAndCheckCompleted()\n            throw NullPointerException(\"Attempted to emit `null` inside a reactive publisher\")\n        }\n        /** This guards against the case when the caller of this function managed to lock the mutex not because some\n         * elements were requested--and thus it is permitted to call `onNext`--but because the channel was closed.\n         *\n         * It may look like there is a race condition here between `isActive` and a concurrent cancellation, but it's\n         * okay for a cancellation to happen during `onNext`, as the reactive spec only requires that we *eventually*\n         * stop signalling the subscriber. */\n        if (!isActive) {\n            unlockAndCheckCompleted()\n            return getCancellationException()\n        }\n        // notify the subscriber\n        try {\n            subscriber.onNext(elem)\n        } catch (cause: Throwable) {\n            /** The reactive streams spec forbids the subscribers from throwing from [Subscriber.onNext] unless the\n             * element is `null`, which we check not to be the case. Therefore, we report this exception to the handler\n             * for uncaught exceptions and consider the subscription cancelled, as mandated by\n             * https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#2.13.\n             *\n             * Some reactive implementations, like RxJava or Reactor, are known to throw from [Subscriber.onNext] if the\n             * execution encounters an exception they consider to be \"fatal\", like [VirtualMachineError] or\n             * [ThreadDeath]. Us using the handler for the undeliverable exceptions to signal \"fatal\" exceptions is\n             * inconsistent with RxJava and Reactor, which attempt to bubble the exception up the call chain as soon as\n             * possible. However, we can't do much better here, as simply throwing from all methods indiscriminately\n             * would violate the contracts we place on them. */\n            cancelled = true\n            val causeDelivered = close(cause)\n            unlockAndCheckCompleted()\n            return if (causeDelivered) {\n                // `cause` is the reason this channel is closed\n                cause\n            } else {\n                // Someone else closed the channel during `onNext`. We report `cause` as an undeliverable exception.\n                exceptionOnCancelHandler(cause, context)\n                getCancellationException()\n            }\n        }\n        // now update nRequested\n        while (true) { // lock-free loop on nRequested\n            val current = _nRequested.value\n            if (current < 0) break // closed from inside onNext => unlock\n            if (current == Long.MAX_VALUE) break // no back-pressure => unlock\n            val updated = current - 1\n            if (_nRequested.compareAndSet(current, updated)) {\n                if (updated == 0L) {\n                    // return to keep locked due to back-pressure\n                    return null\n                }\n                break // unlock if updated > 0\n            }\n        }\n        unlockAndCheckCompleted()\n        return null\n    }\n\n    private fun unlockAndCheckCompleted() {\n       /*\n        * There is no sense to check completion before doing `unlock`, because completion might\n        * happen after this check and before `unlock` (see `signalCompleted` that does not do anything\n        * if it fails to acquire the lock that we are still holding).\n        * We have to recheck `isCompleted` after `unlock` anyway.\n        */\n        mutex.unlock()\n        // check isCompleted and try to regain lock to signal completion\n        if (isCompleted && mutex.tryLock()) {\n            doLockedSignalCompleted(completionCause, completionCauseHandled)\n        }\n    }\n\n    // assert: mutex.isLocked() & isCompleted\n    private fun doLockedSignalCompleted(cause: Throwable?, handled: Boolean) {\n        try {\n            if (_nRequested.value == SIGNALLED)\n                return\n            _nRequested.value = SIGNALLED // we'll signal onError/onCompleted (the final state, so no CAS needed)\n            // Specification requires that after the cancellation is requested we eventually stop calling onXXX\n            if (cancelled) {\n                // If the parent failed to handle this exception, then we must not lose the exception\n                if (cause != null && !handled) exceptionOnCancelHandler(cause, context)\n                return\n            }\n            if (cause == null) {\n                try {\n                    subscriber.onComplete()\n                } catch (e: Throwable) {\n                    handleCoroutineException(context, e)\n                }\n            } else {\n                try {\n                    // This can't be the cancellation exception from `cancel`, as then `cancelled` would be `true`.\n                    subscriber.onError(cause)\n                } catch (e: Throwable) {\n                    if (e !== cause) {\n                        cause.addSuppressed(e)\n                    }\n                    handleCoroutineException(context, cause)\n                }\n            }\n        } finally {\n            mutex.unlock()\n        }\n    }\n\n    override fun request(n: Long) {\n        if (n <= 0) {\n            // Specification requires to call onError with IAE for n <= 0\n            cancelCoroutine(IllegalArgumentException(\"non-positive subscription request $n\"))\n            return\n        }\n        while (true) { // lock-free loop for nRequested\n            val cur = _nRequested.value\n            if (cur < 0) return // already closed for send, ignore requests, as mandated by the reactive streams spec\n            var upd = cur + n\n            if (upd < 0 || n == Long.MAX_VALUE)\n                upd = Long.MAX_VALUE\n            if (cur == upd) return // nothing to do\n            if (_nRequested.compareAndSet(cur, upd)) {\n                // unlock the mutex when we don't have back-pressure anymore\n                if (cur == 0L) {\n                    /** In a sense, after a successful CAS, it is this invocation, not the coroutine itself, that owns\n                     * the lock, given that `upd` is necessarily strictly positive. Thus, no other operation has the\n                     * right to lower the value on [_nRequested], it can only grow or become [CLOSED]. Therefore, it is\n                     * impossible for any other operations to assume that they own the lock without actually acquiring\n                     * it. */\n                    unlockAndCheckCompleted()\n                }\n                return\n            }\n        }\n    }\n\n    // assert: isCompleted\n    private fun signalCompleted(cause: Throwable?, handled: Boolean) {\n        while (true) { // lock-free loop for nRequested\n            val current = _nRequested.value\n            if (current == SIGNALLED) return // some other thread holding lock already signalled cancellation/completion\n            check(current >= 0) // no other thread could have marked it as CLOSED, because onCompleted[Exceptionally] is invoked once\n            if (!_nRequested.compareAndSet(current, CLOSED)) continue // retry on failed CAS\n            // Ok -- marked as CLOSED, now can unlock the mutex if it was locked due to backpressure\n            if (current == 0L) {\n                doLockedSignalCompleted(cause, handled)\n            } else {\n                // otherwise mutex was either not locked or locked in concurrent onNext... try lock it to signal completion\n                if (mutex.tryLock()) doLockedSignalCompleted(cause, handled)\n                // Note: if failed `tryLock`, then `doLockedNext` will signal after performing `unlock`\n            }\n            return // done anyway\n        }\n    }\n\n    override fun onCompleted(value: Unit) {\n        signalCompleted(null, false)\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        signalCompleted(cause, handled)\n    }\n\n    override fun cancel() {\n        // Specification requires that after cancellation publisher stops signalling\n        // This flag distinguishes subscription cancellation request from the job crash\n        cancelled = true\n        super.cancel(null)\n    }\n}\n\n@Deprecated(\n    message = \"CoroutineScope.publish is deprecated in favour of top-level publish\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"publish(context, block)\")\n) // Since 1.3.0, will be error in 1.3.1 and hidden in 1.4.0. Binary compatibility with Spring\npublic fun <T> CoroutineScope.publish(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Publisher<T> = publishInternal(this, context, DEFAULT_HANDLER, block)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/src/ReactiveFlow.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.flow.internal.*\nimport kotlinx.coroutines.intrinsics.*\nimport org.reactivestreams.*\nimport java.util.*\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.internal.*\n\n/**\n * Transforms the given reactive [Publisher] into [Flow].\n * Use the [buffer] operator on the resulting flow to specify the size of the back-pressure.\n * In effect, it specifies the value of the subscription's [request][Subscription.request].\n * The [default buffer capacity][Channel.BUFFERED] for a suspending channel is used by default.\n *\n * If any of the resulting flow transformations fails, the subscription is immediately cancelled and all the in-flight\n * elements are discarded.\n *\n * This function is integrated with `ReactorContext` from `kotlinx-coroutines-reactor` module,\n * see its documentation for additional details.\n */\npublic fun <T : Any> Publisher<T>.asFlow(): Flow<T> =\n    PublisherAsFlow(this)\n\n/**\n * Transforms the given flow into a reactive specification compliant [Publisher].\n *\n * This function is integrated with `ReactorContext` from `kotlinx-coroutines-reactor` module,\n * see its documentation for additional details.\n *\n * An optional [context] can be specified to control the execution context of calls to the [Subscriber] methods.\n * A [CoroutineDispatcher] can be set to confine them to a specific thread; various [ThreadContextElement] can be set to\n * inject additional context into the caller thread. By default, the [Unconfined][Dispatchers.Unconfined] dispatcher\n * is used, so calls are performed from an arbitrary thread.\n */\n@JvmOverloads // binary compatibility\npublic fun <T : Any> Flow<T>.asPublisher(context: CoroutineContext = EmptyCoroutineContext): Publisher<T> =\n    FlowAsPublisher(this, Dispatchers.Unconfined + context)\n\nprivate class PublisherAsFlow<T : Any>(\n    private val publisher: Publisher<T>,\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = Channel.BUFFERED,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\n) : ChannelFlow<T>(context, capacity, onBufferOverflow) {\n    override fun create(context: CoroutineContext, capacity: Int, onBufferOverflow: BufferOverflow): ChannelFlow<T> =\n        PublisherAsFlow(publisher, context, capacity, onBufferOverflow)\n\n    /*\n     * The @Suppress is for Channel.CHANNEL_DEFAULT_CAPACITY.\n     * It's too counter-intuitive to be public, and moving it to Flow companion\n     * will also create undesired effect.\n     */\n    @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n    private val requestSize: Long\n        get() =\n            if (onBufferOverflow != BufferOverflow.SUSPEND) {\n                Long.MAX_VALUE // request all, since buffering strategy is to never suspend\n            } else when (capacity) {\n                Channel.RENDEZVOUS -> 1L // need to request at least one anyway\n                Channel.UNLIMITED -> Long.MAX_VALUE // reactive streams way to say \"give all\", must be Long.MAX_VALUE\n                Channel.BUFFERED -> Channel.CHANNEL_DEFAULT_CAPACITY.toLong()\n                else -> capacity.toLong().also { check(it >= 1) }\n            }\n\n    override suspend fun collect(collector: FlowCollector<T>) {\n        val collectContext = coroutineContext\n        val newDispatcher = context[ContinuationInterceptor]\n        if (newDispatcher == null || newDispatcher == collectContext[ContinuationInterceptor]) {\n            // fast path -- subscribe directly in this dispatcher\n            return collectImpl(collectContext + context, collector)\n        }\n        // slow path -- produce in a separate dispatcher\n        collectSlowPath(collector)\n    }\n\n    private suspend fun collectSlowPath(collector: FlowCollector<T>) {\n        coroutineScope {\n            collector.emitAll(produceImpl(this + context))\n        }\n    }\n\n    private suspend fun collectImpl(injectContext: CoroutineContext, collector: FlowCollector<T>) {\n        val subscriber = ReactiveSubscriber<T>(capacity, onBufferOverflow, requestSize)\n        // inject subscribe context into publisher\n        publisher.injectCoroutineContext(injectContext).subscribe(subscriber)\n        try {\n            var consumed = 0L\n            while (true) {\n                val value = subscriber.takeNextOrNull() ?: break\n                coroutineContext.ensureActive()\n                collector.emit(value)\n                if (++consumed == requestSize) {\n                    consumed = 0L\n                    subscriber.makeRequest()\n                }\n            }\n        } finally {\n            subscriber.cancel()\n        }\n    }\n\n    // The second channel here is used for produceIn/broadcastIn and slow-path (dispatcher change)\n    override suspend fun collectTo(scope: ProducerScope<T>) =\n        collectImpl(scope.coroutineContext, SendingCollector(scope.channel))\n}\n\n@Suppress(\"ReactiveStreamsSubscriberImplementation\")\nprivate class ReactiveSubscriber<T : Any>(\n    capacity: Int,\n    onBufferOverflow: BufferOverflow,\n    private val requestSize: Long\n) : Subscriber<T> {\n    private lateinit var subscription: Subscription\n\n    // This implementation of ReactiveSubscriber always uses \"offer\" in its onNext implementation and it cannot\n    // be reliable with rendezvous channel, so a rendezvous channel is replaced with buffer=1 channel\n    private val channel = Channel<T>(if (capacity == Channel.RENDEZVOUS) 1 else capacity, onBufferOverflow)\n\n    suspend fun takeNextOrNull(): T? {\n        val result = channel.receiveCatching()\n        result.exceptionOrNull()?.let { throw it }\n        return result.getOrElse { null } // Closed channel\n    }\n\n    override fun onNext(value: T) {\n        // Controlled by requestSize\n        require(channel.trySend(value).isSuccess) { \"Element $value was not added to channel because it was full, $channel\" }\n    }\n\n    override fun onComplete() {\n        channel.close()\n    }\n\n    override fun onError(t: Throwable?) {\n        channel.close(t)\n    }\n\n    override fun onSubscribe(s: Subscription) {\n        subscription = s\n        makeRequest()\n    }\n\n    fun makeRequest() {\n        subscription.request(requestSize)\n    }\n\n    fun cancel() {\n        subscription.cancel()\n    }\n}\n\n// ContextInjector service is implemented in `kotlinx-coroutines-reactor` module only.\n// If `kotlinx-coroutines-reactor` module is not included, the list is empty.\nprivate val contextInjectors: Array<ContextInjector> =\n    ServiceLoader.load(ContextInjector::class.java, ContextInjector::class.java.classLoader)\n        .iterator().asSequence()\n        .toList().toTypedArray() // R8 opto\n\ninternal fun <T> Publisher<T>.injectCoroutineContext(coroutineContext: CoroutineContext) =\n    contextInjectors.fold(this) { pub, contextInjector -> contextInjector.injectCoroutineContext(pub, coroutineContext) }\n\n/**\n * Adapter that transforms [Flow] into TCK-complaint [Publisher].\n * [cancel] invocation cancels the original flow.\n */\n@Suppress(\"ReactiveStreamsPublisherImplementation\")\nprivate class FlowAsPublisher<T : Any>(\n    private val flow: Flow<T>,\n    private val context: CoroutineContext\n) : Publisher<T> {\n    override fun subscribe(subscriber: Subscriber<in T>?) {\n        if (subscriber == null) throw NullPointerException()\n        subscriber.onSubscribe(FlowSubscription(flow, subscriber, context))\n    }\n}\n\n/** @suppress */\n@InternalCoroutinesApi\npublic class FlowSubscription<T>(\n    @JvmField public val flow: Flow<T>,\n    @JvmField public val subscriber: Subscriber<in T>,\n    context: CoroutineContext\n) : Subscription, AbstractCoroutine<Unit>(context, initParentJob = false, true) {\n    /*\n     * We deliberately set initParentJob to false and do not establish parent-child\n     * relationship because FlowSubscription doesn't support it\n     */\n    private val requested = atomic(0L)\n    private val producer = atomic<Continuation<Unit>?>(createInitialContinuation())\n    @Volatile\n    private var cancellationRequested = false\n\n    // This code wraps startCoroutineCancellable into continuation\n    private fun createInitialContinuation(): Continuation<Unit> = Continuation(coroutineContext) {\n        ::flowProcessing.startCoroutineCancellable(this)\n    }\n\n    private suspend fun flowProcessing() {\n        try {\n            consumeFlow()\n        } catch (cause: Throwable) {\n            @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n            val unwrappedCause = unwrap(cause)\n            if (!cancellationRequested || isActive || unwrappedCause !== getCancellationException()) {\n                try {\n                    subscriber.onError(cause)\n                } catch (e: Throwable) {\n                    // Last ditch report\n                    cause.addSuppressed(e)\n                    handleCoroutineException(coroutineContext, cause)\n                }\n            }\n            return\n        }\n        // We only call this if `consumeFlow()` finished successfully\n        try {\n            subscriber.onComplete()\n        } catch (e: Throwable) {\n            handleCoroutineException(coroutineContext, e)\n        }\n    }\n\n    /*\n     * This method has at most one caller at any time (triggered from the `request` method)\n     */\n    private suspend fun consumeFlow() {\n        flow.collect { value ->\n            // Emit the value\n            subscriber.onNext(value)\n            // Suspend if needed before requesting the next value\n            if (requested.decrementAndGet() <= 0) {\n                suspendCancellableCoroutine<Unit> {\n                    producer.value = it\n                }\n            } else {\n                // check for cancellation if we don't suspend\n                coroutineContext.ensureActive()\n            }\n        }\n    }\n\n    override fun cancel() {\n        cancellationRequested = true\n        cancel(null)\n    }\n\n    override fun request(n: Long) {\n        if (n <= 0) return\n        val old = requested.getAndUpdate { value ->\n            val newValue = value + n\n            if (newValue <= 0L) Long.MAX_VALUE else newValue\n        }\n        if (old <= 0L) {\n            assert(old == 0L)\n            // Emitter is not started yet or has suspended -- spin on race with suspendCancellableCoroutine\n            while (true) {\n                val producer = producer.getAndSet(null) ?: continue // spin if not set yet\n                producer.resume(Unit)\n                break\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/AwaitCancellationStressTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.reactivestreams.*\nimport java.util.concurrent.locks.*\n\n/**\n * This test checks implementation of rule 2.7 for await methods - serial execution of subscription methods\n */\nclass AwaitCancellationStressTest : TestBase() {\n    private val iterations = 10_000 * stressTestMultiplier\n\n    @Test\n    fun testAwaitCancellationOrder() = runTest {\n        repeat(iterations) {\n            val job = launch(Dispatchers.Default) {\n                testPublisher().awaitFirst()\n            }\n            job.cancelAndJoin()\n        }\n    }\n\n    private fun testPublisher() = Publisher<Int> { s ->\n        val lock = ReentrantLock()\n        s.onSubscribe(object : Subscription {\n            override fun request(n: Long) {\n                check(lock.tryLock())\n                s.onNext(42)\n                lock.unlock()\n            }\n\n            override fun cancel() {\n                check(lock.tryLock())\n                lock.unlock()\n            }\n        })\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/AwaitTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.reactivestreams.*\n\nclass AwaitTest: TestBase() {\n\n    /** Tests that calls to [awaitFirst] (and, thus, to the rest of these functions) throw [CancellationException] and\n     * unsubscribe from the publisher when their [Job] is cancelled. */\n    @Test\n    fun testAwaitCancellation() = runTest {\n        expect(1)\n        val publisher = Publisher<Int> { s ->\n            s.onSubscribe(object: Subscription {\n                override fun request(n: Long) {\n                    expect(3)\n                }\n\n                override fun cancel() {\n                    expect(5)\n                }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                publisher.awaitFirst()\n            } catch (e: CancellationException) {\n                expect(6)\n                throw e\n            }\n        }\n        expect(4)\n        job.cancelAndJoin()\n        finish(7)\n    }\n\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/CancelledParentAttachTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.*\n\n\nclass CancelledParentAttachTest : TestBase() {;\n\n    @Test\n    fun testFlow() = runTest {\n        val f = flowOf(1, 2, 3).cancellable()\n        val j = Job().also { it.cancel() }\n        f.asPublisher(j).asFlow().collect()\n    }\n\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/FlowAsPublisherTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport kotlinx.coroutines.flow.*\nimport org.junit.Test\nimport org.reactivestreams.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass FlowAsPublisherTest : TestBase() {\n    @Test\n    fun testErrorOnCancellationIsReported() {\n        expect(1)\n        flow {\n            try {\n                emit(2)\n            } finally {\n                expect(3)\n                throw TestException()\n            }\n        }.asPublisher().subscribe(object : Subscriber<Int> {\n            private lateinit var subscription: Subscription\n\n            override fun onComplete() {\n                expectUnreached()\n            }\n\n            override fun onSubscribe(s: Subscription?) {\n                subscription = s!!\n                subscription.request(2)\n            }\n\n            override fun onNext(t: Int) {\n                expect(t)\n                subscription.cancel()\n            }\n\n            override fun onError(t: Throwable?) {\n                assertIs<TestException>(t)\n                expect(4)\n            }\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testCancellationIsNotReported() {\n        expect(1)\n        flow {\n            emit(2)\n        }.asPublisher().subscribe(object : Subscriber<Int> {\n            private lateinit var subscription: Subscription\n\n            override fun onComplete() {\n                expectUnreached()\n            }\n\n            override fun onSubscribe(s: Subscription?) {\n                subscription = s!!\n                subscription.request(2)\n            }\n\n            override fun onNext(t: Int) {\n                expect(t)\n                subscription.cancel()\n            }\n\n            override fun onError(t: Throwable?) {\n                expectUnreached()\n            }\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testUnconfinedDefaultContext() {\n        expect(1)\n        val thread = Thread.currentThread()\n        fun checkThread() {\n            assertSame(thread, Thread.currentThread())\n        }\n        flowOf(42).asPublisher().subscribe(object : Subscriber<Int> {\n            private lateinit var subscription: Subscription\n\n            override fun onSubscribe(s: Subscription) {\n                expect(2)\n                subscription = s\n                subscription.request(2)\n            }\n\n            override fun onNext(t: Int) {\n                checkThread()\n                expect(3)\n                assertEquals(42, t)\n            }\n\n            override fun onComplete() {\n                checkThread()\n                expect(4)\n            }\n\n            override fun onError(t: Throwable?) {\n                expectUnreached()\n            }\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testConfinedContext() {\n        expect(1)\n        val threadName = \"FlowAsPublisherTest.testConfinedContext\"\n        fun checkThread() {\n            val currentThread = Thread.currentThread()\n            assertTrue(currentThread.name.startsWith(threadName), \"Unexpected thread $currentThread\")\n        }\n        val completed = CountDownLatch(1)\n        newSingleThreadContext(threadName).use { dispatcher ->\n            flowOf(42).asPublisher(dispatcher).subscribe(object : Subscriber<Int> {\n                private lateinit var subscription: Subscription\n\n                override fun onSubscribe(s: Subscription) {\n                    expect(2)\n                    subscription = s\n                    subscription.request(2)\n                }\n\n                override fun onNext(t: Int) {\n                    checkThread()\n                    expect(3)\n                    assertEquals(42, t)\n                }\n\n                override fun onComplete() {\n                    checkThread()\n                    expect(4)\n                    completed.countDown()\n                }\n\n                override fun onError(t: Throwable?) {\n                    expectUnreached()\n                }\n            })\n            completed.await()\n        }\n        finish(5)\n    }\n\n    @Test\n    fun testFlowWithTimeout() = runTest {\n        val publisher = flow<Int> {\n            expect(2)\n            withTimeout(1) { delay(Long.MAX_VALUE) }\n        }.asPublisher()\n        try {\n            expect(1)\n            publisher.awaitFirstOrNull()\n        } catch (e: CancellationException) {\n            expect(3)\n        }\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/IntegrationTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.exceptions.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport org.reactivestreams.*\nimport java.lang.IllegalStateException\nimport java.lang.RuntimeException\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass IntegrationTest(\n    private val ctx: Ctx,\n    private val delay: Boolean\n) : TestBase() {\n\n    enum class Ctx {\n        MAIN        { override fun invoke(context: CoroutineContext): CoroutineContext = context.minusKey(Job) },\n        DEFAULT     { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Default },\n        UNCONFINED  { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Unconfined };\n\n        abstract operator fun invoke(context: CoroutineContext): CoroutineContext\n    }\n\n    companion object {\n        @Parameterized.Parameters(name = \"ctx={0}, delay={1}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = Ctx.values().flatMap { ctx ->\n            listOf(false, true).map { delay ->\n                arrayOf(ctx, delay)\n            }\n        }\n    }\n\n    @Test\n    fun testEmpty(): Unit = runBlocking {\n        val pub = publish<String>(ctx(coroutineContext)) {\n            if (delay) delay(1)\n            // does not send anything\n        }\n        assertFailsWith<NoSuchElementException> { pub.awaitFirst() }\n        assertEquals(\"OK\", pub.awaitFirstOrDefault(\"OK\"))\n        assertNull(pub.awaitFirstOrNull())\n        assertEquals(\"ELSE\", pub.awaitFirstOrElse { \"ELSE\" })\n        assertFailsWith<NoSuchElementException> { pub.awaitLast() }\n        assertFailsWith<NoSuchElementException> { pub.awaitSingle() }\n        var cnt = 0\n        pub.collect { cnt++ }\n        assertEquals(0, cnt)\n    }\n\n    @Test\n    fun testSingle() = runBlocking {\n        val pub = publish(ctx(coroutineContext)) {\n            if (delay) delay(1)\n            send(\"OK\")\n        }\n        assertEquals(\"OK\", pub.awaitFirst())\n        assertEquals(\"OK\", pub.awaitFirstOrDefault(\"!\"))\n        assertEquals(\"OK\", pub.awaitFirstOrNull())\n        assertEquals(\"OK\", pub.awaitFirstOrElse { \"ELSE\" })\n        assertEquals(\"OK\", pub.awaitLast())\n        assertEquals(\"OK\", pub.awaitSingle())\n        var cnt = 0\n        pub.collect {\n            assertEquals(\"OK\", it)\n            cnt++\n        }\n        assertEquals(1, cnt)\n    }\n\n    @Test\n    fun testCancelWithoutValue() = runTest {\n        val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {\n            publish<String> {\n                hang {}\n            }.awaitFirst()\n        }\n\n        job.cancel()\n        job.join()\n    }\n\n    @Test\n    fun testEmptySingle() = runTest(unhandled = listOf { e -> e is NoSuchElementException }) {\n        expect(1)\n        val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {\n            publish<String> {\n                yield()\n                expect(2)\n                // Nothing to emit\n            }.awaitFirst()\n        }\n\n        job.join()\n        finish(3)\n    }\n\n    /**\n     * Test that the continuation is not being resumed after it has already failed due to there having been too many\n     * values passed.\n     */\n    @Test\n    fun testNotCompletingFailedAwait() = runTest {\n        try {\n            expect(1)\n            Publisher<Int> { sub ->\n                sub.onSubscribe(object: Subscription {\n                    override fun request(n: Long) {\n                        expect(2)\n                        sub.onNext(1)\n                        sub.onNext(2)\n                        expect(4)\n                        sub.onComplete()\n                    }\n\n                    override fun cancel() {\n                        expect(3)\n                    }\n                })\n            }.awaitSingle()\n        } catch (e: java.lang.IllegalArgumentException) {\n            expect(5)\n        }\n        finish(6)\n    }\n\n    /**\n     * Test the behavior of [awaitOne] on unconforming publishers.\n     */\n    @Test\n    fun testAwaitOnNonconformingPublishers() = runTest {\n        fun <T> publisher(block: Subscriber<in T>.(n: Long) -> Unit) =\n            Publisher<T> { subscriber ->\n                subscriber.onSubscribe(object: Subscription {\n                    override fun request(n: Long) {\n                        subscriber.block(n)\n                    }\n\n                    override fun cancel() {\n                    }\n                })\n            }\n        val dummyMessage = \"dummy\"\n        val dummyThrowable = RuntimeException(dummyMessage)\n        suspend fun <T> assertDetectsBadPublisher(\n            operation: suspend Publisher<T>.() -> T,\n            message: String,\n            block: Subscriber<in T>.(n: Long) -> Unit,\n        ) {\n            assertCallsExceptionHandlerWith<IllegalStateException> {\n                try {\n                    publisher(block).operation()\n                } catch (e: Throwable) {\n                    if (e.message != dummyMessage)\n                        throw e\n                }\n            }.let {\n                assertTrue(\"Expected the message to contain '$message', got '${it.message}'\") {\n                    it.message?.contains(message) ?: false\n                }\n            }\n        }\n\n        // Rule 1.1 broken: the publisher produces more values than requested.\n        assertDetectsBadPublisher<Int>({ awaitFirst() }, \"provided more\") {\n            onNext(1)\n            onNext(2)\n            onComplete()\n        }\n\n        // Rule 1.7 broken: the publisher calls a method on a subscriber after reaching the terminal state.\n        assertDetectsBadPublisher<Int>({ awaitSingle() }, \"terminal state\") {\n            onNext(1)\n            onError(dummyThrowable)\n            onComplete()\n        }\n        assertDetectsBadPublisher<Int>({ awaitFirst() }, \"terminal state\") {\n            onNext(0)\n            onComplete()\n            onComplete()\n        }\n        assertDetectsBadPublisher<Int>({ awaitFirstOrDefault(1) }, \"terminal state\") {\n            onComplete()\n            onNext(3)\n        }\n        assertDetectsBadPublisher<Int>({ awaitSingle() }, \"terminal state\") {\n            onError(dummyThrowable)\n            onNext(3)\n        }\n\n        // Rule 1.9 broken (the first signal to the subscriber was not 'onSubscribe')\n        assertCallsExceptionHandlerWith<IllegalStateException> {\n            try {\n                Publisher<Int> { subscriber ->\n                    subscriber.onNext(3)\n                    subscriber.onComplete()\n                }.awaitFirst()\n            } catch (e: NoSuchElementException) {\n                // intentionally blank\n            }\n        }.let { assertTrue(it.message?.contains(\"onSubscribe\") ?: false) }\n    }\n\n    @Test\n    fun testPublishWithTimeout() = runTest {\n        val publisher = publish<Int> {\n            expect(2)\n            withTimeout(1) { delay(100) }\n        }\n        try {\n            expect(1)\n            publisher.awaitFirstOrNull()\n        } catch (e: CancellationException) {\n            expect(3)\n        }\n        finish(4)\n    }\n\n}\n\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/IterableFlowTckTest.kt",
        "content": "@file:Suppress(\"UNCHECKED_CAST\")\n\npackage kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.flow.*\nimport org.junit.Ignore\nimport org.junit.Test\nimport org.reactivestreams.*\nimport org.reactivestreams.tck.*\nimport java.util.concurrent.*\nimport java.util.concurrent.ForkJoinPool.*\nimport kotlin.test.*\n\nclass IterableFlowTckTest : PublisherVerification<Long>(TestEnvironment()) {\n\n    private fun generate(num: Long): Array<Long> {\n        return Array(if (num >= Integer.MAX_VALUE) 1000000 else num.toInt()) { it.toLong() }\n    }\n\n    override fun createPublisher(elements: Long): Publisher<Long> {\n        return generate(elements).asIterable().asFlow().asPublisher()\n    }\n\n    @Suppress(\"SubscriberImplementation\")\n    override fun createFailedPublisher(): Publisher<Long>? {\n        /*\n         * This is a hack for our adapter structure:\n         * Tests assume that calling \"collect\" is enough for publisher to fail and it is not\n         * true for our implementation\n         */\n        val pub = { error(42) }.asFlow().asPublisher()\n        return Publisher { subscriber ->\n            pub.subscribe(object : Subscriber<Long> by subscriber as Subscriber<Long> {\n                override fun onSubscribe(s: Subscription) {\n                    subscriber.onSubscribe(s)\n                    s.request(1)\n                }\n            })\n        }\n    }\n\n    @Test\n    fun testStackOverflowTrampoline() {\n        val latch = CountDownLatch(1)\n        val collected = ArrayList<Long>()\n        val toRequest = 1000L\n        val array = generate(toRequest)\n        val publisher = array.asIterable().asFlow().asPublisher()\n\n        publisher.subscribe(object : Subscriber<Long> {\n            private lateinit var s: Subscription\n\n            override fun onSubscribe(s: Subscription) {\n                this.s = s\n                s.request(1)\n            }\n\n            override fun onNext(aLong: Long) {\n                collected.add(aLong)\n\n                s.request(1)\n            }\n\n            override fun onError(t: Throwable) {\n\n            }\n\n            override fun onComplete() {\n                latch.countDown()\n            }\n        })\n\n        latch.await(5, TimeUnit.SECONDS)\n        assertEquals(collected, array.toList())\n    }\n\n    @Test\n    fun testConcurrentRequest() {\n        val latch = CountDownLatch(1)\n        val collected = ArrayList<Long>()\n        val n = 50000L\n        val array = generate(n)\n        val publisher = array.asIterable().asFlow().asPublisher()\n\n        publisher.subscribe(object : Subscriber<Long> {\n            private var s: Subscription? = null\n\n            override fun onSubscribe(s: Subscription) {\n                this.s = s\n                for (i in 0..n) {\n                    commonPool().execute { s.request(1) }\n                }\n            }\n\n            override fun onNext(aLong: Long) {\n                collected.add(aLong)\n            }\n\n            override fun onError(t: Throwable) {\n\n            }\n\n            override fun onComplete() {\n                latch.countDown()\n            }\n        })\n\n        latch.await()\n        assertEquals(array.toList(), collected)\n    }\n\n    @Ignore\n    override fun required_spec309_requestZeroMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() {\n        // This test has a bug in it\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/PublishTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.sync.*\nimport kotlinx.coroutines.testing.exceptions.*\nimport org.junit.Test\nimport org.reactivestreams.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass PublishTest : TestBase() {\n    @Test\n    fun testBasicEmpty() = runTest {\n        expect(1)\n        val publisher = publish<Int>(currentDispatcher()) {\n            expect(5)\n        }\n        expect(2)\n        publisher.subscribe(object : Subscriber<Int> {\n            override fun onSubscribe(s: Subscription?) { expect(3) }\n            override fun onNext(t: Int?) { expectUnreached() }\n            override fun onComplete() { expect(6) }\n            override fun onError(t: Throwable?) { expectUnreached() }\n        })\n        expect(4)\n        yield() // to publish coroutine\n        finish(7)\n    }\n\n    @Test\n    fun testBasicSingle() = runTest {\n        expect(1)\n        val publisher = publish(currentDispatcher()) {\n            expect(5)\n            send(42)\n            expect(7)\n        }\n        expect(2)\n        publisher.subscribe(object : Subscriber<Int> {\n            override fun onSubscribe(s: Subscription) {\n                expect(3)\n                s.request(1)\n            }\n            override fun onNext(t: Int) {\n                expect(6)\n                assertEquals(42, t)\n            }\n            override fun onComplete() { expect(8) }\n            override fun onError(t: Throwable?) { expectUnreached() }\n        })\n        expect(4)\n        yield() // to publish coroutine\n        finish(9)\n    }\n\n    @Test\n    fun testBasicError() = runTest {\n        expect(1)\n        val publisher = publish<Int>(currentDispatcher()) {\n            expect(5)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        publisher.subscribe(object : Subscriber<Int> {\n            override fun onSubscribe(s: Subscription) {\n                expect(3)\n                s.request(1)\n            }\n            override fun onNext(t: Int) { expectUnreached() }\n            override fun onComplete() { expectUnreached() }\n            override fun onError(t: Throwable) {\n                expect(6)\n                assertIs<RuntimeException>(t)\n                assertEquals(\"OK\", t.message)\n            }\n        })\n        expect(4)\n        yield() // to publish coroutine\n        finish(7)\n    }\n\n    @Test\n    fun testHandleFailureAfterCancel() = runTest {\n        expect(1)\n\n        val eh = CoroutineExceptionHandler { _, t ->\n            assertIs<RuntimeException>(t)\n            expect(6)\n        }\n        val publisher = publish<Unit>(Dispatchers.Unconfined + eh) {\n            try {\n                expect(3)\n                delay(10000)\n            } finally {\n                expect(5)\n                throw RuntimeException(\"FAILED\") // crash after cancel\n            }\n        }\n        var sub: Subscription? = null\n        publisher.subscribe(object : Subscriber<Unit> {\n            override fun onComplete() {\n                expectUnreached()\n            }\n\n            override fun onSubscribe(s: Subscription) {\n                expect(2)\n                sub = s\n            }\n\n            override fun onNext(t: Unit?) {\n                expectUnreached()\n            }\n\n            override fun onError(t: Throwable?) {\n                expectUnreached()\n            }\n        })\n        expect(4)\n        sub!!.cancel()\n        finish(7)\n    }\n\n    /** Tests that, as soon as `ProducerScope.close` is called, `isClosedForSend` starts returning `true`. */\n    @Test\n    fun testChannelClosing() = runTest {\n        expect(1)\n        val publisher = publish<Int>(Dispatchers.Unconfined) {\n            expect(3)\n            close()\n            assert(isClosedForSend)\n            expect(4)\n        }\n        try {\n            expect(2)\n            publisher.awaitFirstOrNull()\n        } catch (e: CancellationException) {\n            expect(5)\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testOnNextError() = runTest {\n        val latch = CompletableDeferred<Unit>()\n        expect(1)\n        assertCallsExceptionHandlerWith<TestException> { exceptionHandler ->\n            val publisher = publish(currentDispatcher() + exceptionHandler) {\n                expect(4)\n                try {\n                    send(\"OK\")\n                } catch (e: Throwable) {\n                    expect(6)\n                    assert(e is TestException)\n                    assert(isClosedForSend)\n                    latch.complete(Unit)\n                }\n            }\n            expect(2)\n            publisher.subscribe(object : Subscriber<String> {\n                override fun onComplete() {\n                    expectUnreached()\n                }\n\n                override fun onSubscribe(s: Subscription) {\n                    expect(3)\n                    s.request(1)\n                }\n\n                override fun onNext(t: String) {\n                    expect(5)\n                    assertEquals(\"OK\", t)\n                    throw TestException()\n                }\n\n                override fun onError(t: Throwable) {\n                    expectUnreached()\n                }\n            })\n            latch.await()\n        }\n        finish(7)\n    }\n\n    /** Tests the behavior when a call to `onNext` fails after the channel is already closed. */\n    @Test\n    fun testOnNextErrorAfterCancellation() = runTest {\n        assertCallsExceptionHandlerWith<TestException> { handler ->\n            var producerScope: ProducerScope<Int>? = null\n            CompletableDeferred<Unit>()\n            expect(1)\n            var job: Job? = null\n            val publisher = publish<Int>(handler + Dispatchers.Unconfined) {\n                producerScope = this\n                expect(4)\n                job = launch {\n                    delay(Long.MAX_VALUE)\n                }\n            }\n            expect(2)\n            publisher.subscribe(object : Subscriber<Int> {\n                override fun onSubscribe(s: Subscription) {\n                    expect(3)\n                    s.request(Long.MAX_VALUE)\n                }\n\n                override fun onNext(t: Int) {\n                    expect(6)\n                    assertEquals(1, t)\n                    job!!.cancel()\n                    throw TestException()\n                }\n\n                override fun onError(t: Throwable?) {\n                    /* Correct changes to the implementation could lead to us entering or not entering this method, but\n                    it only matters that if we do, it is the \"correct\" exception that was validly used to cancel the\n                    coroutine that gets passed here and not `TestException`. */\n                    assertIs<CancellationException>(t)\n                }\n\n                override fun onComplete() {\n                    expectUnreached()\n                }\n            })\n            expect(5)\n            val result: ChannelResult<Unit> = producerScope!!.trySend(1)\n            val e = result.exceptionOrNull()!!\n            assertIs<CancellationException>(e, \"The actual error: $e\")\n            assertTrue(producerScope!!.isClosedForSend)\n            assertTrue(result.isFailure)\n        }\n        finish(7)\n    }\n\n    @Test\n    fun testFailingConsumer() = runTest {\n        val pub = publish(currentDispatcher()) {\n            repeat(3) {\n                expect(it + 1) // expect(1), expect(2) *should* be invoked\n                send(it)\n            }\n        }\n        try {\n            pub.collect {\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testIllegalArgumentException() {\n        assertFailsWith<IllegalArgumentException> { publish<Int>(Job()) { } }\n    }\n\n    /** Tests that `trySend` doesn't throw in `publish`. */\n    @Test\n    fun testTrySendNotThrowing() = runTest {\n        var producerScope: ProducerScope<Int>? = null\n        expect(1)\n        val publisher = publish<Int>(Dispatchers.Unconfined) {\n            producerScope = this\n            expect(3)\n            delay(Long.MAX_VALUE)\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            publisher.awaitFirstOrNull()\n            expectUnreached()\n        }\n        job.cancel()\n        expect(4)\n        val result = producerScope!!.trySend(1)\n        assertTrue(result.isFailure)\n        finish(5)\n    }\n\n    /** Tests that all methods on `publish` fail without closing the channel when attempting to emit `null`. */\n    @Test\n    fun testEmittingNull() = runTest {\n        val publisher = publish {\n            assertFailsWith<NullPointerException> { send(null) }\n            assertFailsWith<NullPointerException> { trySend(null) }\n            send(\"OK\")\n        }\n        assertEquals(\"OK\", publisher.awaitFirstOrNull())\n    }\n\n    @Test\n    fun testOnSendCancelled() = runTest {\n        val latch = CountDownLatch(1)\n        val published = publish(Dispatchers.Default) {\n            expect(2)\n            // Collector is ready\n            send(1)\n            try {\n                send(2)\n                expectUnreached()\n            } catch (e: CancellationException) {\n                // publisher cancellation is async\n                latch.countDown()\n                throw e\n            }\n        }\n\n        expect(1)\n        val collectorLatch = Mutex(true)\n        val job = launch {\n            published.asFlow().buffer(0).collect {\n                collectorLatch.unlock()\n                hang { expect(4) }\n            }\n        }\n        collectorLatch.lock()\n        expect(3)\n        job.cancelAndJoin()\n        latch.await()\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/PublisherAsFlowTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.testing.flow.*\nimport org.reactivestreams.*\nimport kotlin.test.*\n\nclass PublisherAsFlowTest : TestBase() {\n    @Test\n    fun testCancellation() = runTest {\n        var onNext = 0\n        var onCancelled = 0\n        var onError = 0\n\n        val publisher = publish(currentDispatcher()) {\n            coroutineContext[Job]?.invokeOnCompletion {\n                if (it is CancellationException) ++onCancelled\n            }\n\n            repeat(100) {\n                send(it)\n            }\n        }\n\n        publisher.asFlow().launchIn(CoroutineScope(Dispatchers.Unconfined)) {\n            onEach {\n                ++onNext\n                throw RuntimeException()\n            }\n            catch<Throwable> {\n                ++onError\n            }\n        }.join()\n\n\n        assertEquals(1, onNext)\n        assertEquals(1, onError)\n        assertEquals(1, onCancelled)\n    }\n\n    @Test\n    fun testBufferSize1() = runTest {\n        val publisher = publish(currentDispatcher()) {\n            expect(1)\n            send(3)\n\n            expect(2)\n            send(5)\n\n            expect(4)\n            send(7)\n            expect(6)\n        }\n\n        publisher.asFlow().buffer(1).collect {\n            expect(it)\n        }\n\n        finish(8)\n    }\n\n    @Test\n    fun testBufferSizeDefault() = runTest {\n        val publisher = publish(currentDispatcher()) {\n            repeat(64) {\n                send(it + 1)\n                expect(it + 1)\n            }\n            assertFalse { trySend(-1).isSuccess }\n        }\n\n        publisher.asFlow().collect {\n            expect(64 + it)\n        }\n\n        finish(129)\n    }\n\n    @Test\n    fun testDefaultCapacityIsProperlyOverwritten() = runTest {\n        val publisher = publish(currentDispatcher()) {\n            expect(1)\n            send(3)\n            expect(2)\n            send(5)\n            expect(4)\n            send(7)\n            expect(6)\n        }\n\n        publisher.asFlow().flowOn(wrapperDispatcher()).buffer(1).collect {\n            expect(it)\n        }\n\n        finish(8)\n    }\n\n    @Test\n    fun testBufferSize10() = runTest {\n        val publisher = publish(currentDispatcher()) {\n            expect(1)\n            send(5)\n\n            expect(2)\n            send(6)\n\n            expect(3)\n            send(7)\n            expect(4)\n        }\n\n        publisher.asFlow().buffer(10).collect {\n            expect(it)\n        }\n\n        finish(8)\n    }\n\n    @Test\n    fun testConflated() = runTest {\n        val publisher = publish(currentDispatcher()) {\n            for (i in 1..5) send(i)\n        }\n        val list = publisher.asFlow().conflate().toList()\n        assertEquals(listOf(1, 5), list)\n    }\n\n    @Test\n    fun testProduce() = runTest {\n        val flow = publish(currentDispatcher()) { repeat(10) { send(it) } }.asFlow()\n        check((0..9).toList(), flow.produceIn(this))\n        check((0..9).toList(), flow.buffer(2).produceIn(this))\n        check((0..9).toList(), flow.buffer(Channel.UNLIMITED).produceIn(this))\n        check(listOf(0, 9), flow.conflate().produceIn(this))\n    }\n\n    private suspend fun check(expected: List<Int>, channel: ReceiveChannel<Int>) {\n        val result = ArrayList<Int>(10)\n        channel.consumeEach { result.add(it) }\n        assertEquals(expected, result)\n    }\n\n    @Test\n    fun testProduceCancellation() = runTest {\n        expect(1)\n        // publisher is an async coroutine, so it overproduces to the channel, but still gets cancelled\n        val flow = publish(currentDispatcher()) {\n            expect(3)\n            repeat(10) { value ->\n                when (value) {\n                    in 0..6 -> send(value)\n                    7 -> try {\n                        send(value)\n                    } catch (e: CancellationException) {\n                        expect(5)\n                        throw e\n                    }\n                    else -> expectUnreached()\n                }\n            }\n        }.asFlow().buffer(1)\n        assertFailsWith<TestException> {\n            coroutineScope {\n                expect(2)\n                val channel = flow.produceIn(this)\n                channel.consumeEach { value ->\n                    when (value) {\n                        in 0..4 -> {}\n                        5 -> {\n                            expect(4)\n                            throw TestException()\n                        }\n                        else -> expectUnreached()\n                    }\n                }\n            }\n        }\n        finish(6)\n    }\n\n    @Test\n    fun testRequestRendezvous() =\n        testRequestSizeWithBuffer(Channel.RENDEZVOUS, BufferOverflow.SUSPEND, 1)\n\n    @Test\n    fun testRequestBuffer1() =\n        testRequestSizeWithBuffer(1, BufferOverflow.SUSPEND, 1)\n\n    @Test\n    fun testRequestBuffer10() =\n        testRequestSizeWithBuffer(10, BufferOverflow.SUSPEND, 10)\n\n    @Test\n    fun testRequestBufferUnlimited() =\n        testRequestSizeWithBuffer(Channel.UNLIMITED, BufferOverflow.SUSPEND, Long.MAX_VALUE)\n\n    @Test\n    fun testRequestBufferOverflowSuspend() =\n        testRequestSizeWithBuffer(Channel.BUFFERED, BufferOverflow.SUSPEND, 64)\n\n    @Test\n    fun testRequestBufferOverflowDropOldest() =\n        testRequestSizeWithBuffer(Channel.BUFFERED, BufferOverflow.DROP_OLDEST, Long.MAX_VALUE)\n\n    @Test\n    fun testRequestBufferOverflowDropLatest() =\n        testRequestSizeWithBuffer(Channel.BUFFERED, BufferOverflow.DROP_LATEST, Long.MAX_VALUE)\n\n    @Test\n    fun testRequestBuffer10OverflowDropOldest() =\n        testRequestSizeWithBuffer(10, BufferOverflow.DROP_OLDEST, Long.MAX_VALUE)\n\n    @Test\n    fun testRequestBuffer10OverflowDropLatest() =\n        testRequestSizeWithBuffer(10, BufferOverflow.DROP_LATEST, Long.MAX_VALUE)\n\n    /**\n     * Tests `publisher.asFlow.buffer(...)` chain, verifying expected requests size and that only expected\n     * values are delivered.\n     */\n    private fun testRequestSizeWithBuffer(\n        capacity: Int,\n        onBufferOverflow: BufferOverflow,\n        expectedRequestSize: Long\n    ) = runTest {\n        val m = 50\n        // publishers numbers from 1 to m\n        val publisher = Publisher<Int> { s ->\n            s.onSubscribe(object : Subscription {\n                var lastSent = 0\n                var remaining = 0L\n                override fun request(n: Long) {\n                    assertEquals(expectedRequestSize, n)\n                    remaining += n\n                    check(remaining >= 0)\n                    while (lastSent < m && remaining > 0) {\n                        s.onNext(++lastSent)\n                        remaining--\n                    }\n                    if (lastSent == m) s.onComplete()\n                }\n\n                override fun cancel() {}\n            })\n        }\n        val flow = publisher\n            .asFlow()\n            .buffer(capacity, onBufferOverflow)\n        val list = flow.toList()\n        val runSize = if (capacity == Channel.BUFFERED) 1 else capacity\n        val expected = when (onBufferOverflow) {\n            // Everything is expected to be delivered\n            BufferOverflow.SUSPEND -> (1..m).toList()\n            // Only the last one (by default) or the last \"capacity\" items delivered\n            BufferOverflow.DROP_OLDEST -> (m - runSize + 1..m).toList()\n            // Only the first one (by default) or the first \"capacity\" items delivered\n            BufferOverflow.DROP_LATEST -> (1..runSize).toList()\n        }\n        assertEquals(expected, list)\n    }\n\n    @Test\n    fun testException() = runTest {\n        expect(1)\n        val p = publish<Int> { throw TestException() }.asFlow()\n        p.catch {\n            assertTrue { it is TestException }\n            finish(2)\n        }.collect()\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/PublisherBackpressureTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.reactivestreams.*\n\nclass PublisherBackpressureTest : TestBase() {\n    @Test\n    fun testCancelWhileBPSuspended() = runBlocking {\n        expect(1)\n        val observable = publish(currentDispatcher()) {\n            expect(5)\n            send(\"A\") // will not suspend, because an item was requested\n            expect(7)\n            send(\"B\") // second requested item\n            expect(9)\n            try {\n                send(\"C\") // will suspend (no more requested)\n            } finally {\n                expect(12)\n            }\n            expectUnreached()\n        }\n        expect(2)\n        var sub: Subscription? = null\n        observable.subscribe(object : Subscriber<String> {\n            override fun onSubscribe(s: Subscription) {\n                sub = s\n                expect(3)\n                s.request(2) // request two items\n            }\n\n            override fun onNext(t: String) {\n                when (t) {\n                    \"A\" -> expect(6)\n                    \"B\" -> expect(8)\n                    else -> error(\"Should not happen\")\n                }\n            }\n\n            override fun onComplete() {\n                expectUnreached()\n            }\n\n            override fun onError(e: Throwable) {\n                expectUnreached()\n            }\n        })\n        expect(4)\n        yield() // yield to observable coroutine\n        expect(10)\n        sub!!.cancel() // now unsubscribe -- shall cancel coroutine (& do not signal)\n        expect(11)\n        yield() // shall perform finally in coroutine\n        finish(13)\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/PublisherCollectTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport org.reactivestreams.*\nimport kotlin.test.*\n\nclass PublisherCollectTest: TestBase() {\n\n    /** Tests the simple scenario where the publisher outputs a bounded stream of values to collect. */\n    @Test\n    fun testCollect() = runTest {\n        val x = 100\n        val xSum = x * (x + 1) / 2\n        val publisher = Publisher<Int> { subscriber ->\n            var requested = 0L\n            var lastOutput = 0\n            subscriber.onSubscribe(object: Subscription {\n\n                override fun request(n: Long) {\n                    requested += n\n                    if (n <= 0) {\n                        subscriber.onError(IllegalArgumentException())\n                        return\n                    }\n                    while (lastOutput < x && lastOutput < requested) {\n                        lastOutput += 1\n                        subscriber.onNext(lastOutput)\n                    }\n                    if (lastOutput == x)\n                        subscriber.onComplete()\n                }\n\n                override fun cancel() {\n                    /** According to rule 3.5 of the\n                     * [reactive spec](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.5),\n                     * this method can be called by the subscriber at any point, so it's not an error if it's called\n                     * in this scenario. */\n                }\n\n            })\n        }\n        var sum = 0\n        publisher.collect {\n            sum += it\n        }\n        assertEquals(xSum, sum)\n    }\n\n    /** Tests the behavior of [collect] when the publisher raises an error. */\n    @Test\n    fun testCollectThrowingPublisher() = runTest {\n        val errorString = \"Too many elements requested\"\n        val x = 100\n        val xSum = x * (x + 1) / 2\n        val publisher = Publisher<Int> { subscriber ->\n            var requested = 0L\n            var lastOutput = 0\n            subscriber.onSubscribe(object: Subscription {\n\n                override fun request(n: Long) {\n                    requested += n\n                    if (n <= 0) {\n                        subscriber.onError(IllegalArgumentException())\n                        return\n                    }\n                    while (lastOutput < x && lastOutput < requested) {\n                        lastOutput += 1\n                        subscriber.onNext(lastOutput)\n                    }\n                    if (lastOutput == x)\n                        subscriber.onError(IllegalArgumentException(errorString))\n                }\n\n                override fun cancel() {\n                    /** See the comment for the corresponding part of [testCollect]. */\n                }\n\n            })\n        }\n        var sum = 0\n        try {\n            publisher.collect {\n                sum += it\n            }\n        } catch (e: IllegalArgumentException) {\n            assertEquals(errorString, e.message)\n        }\n        assertEquals(xSum, sum)\n    }\n\n    /** Tests the behavior of [collect] when the action throws. */\n    @Test\n    fun testCollectThrowingAction() = runTest {\n        val errorString = \"Too many elements produced\"\n        val x = 100\n        val xSum = x * (x + 1) / 2\n        val publisher = Publisher<Int> { subscriber ->\n            var requested = 0L\n            var lastOutput = 0\n            subscriber.onSubscribe(object: Subscription {\n\n                override fun request(n: Long) {\n                    requested += n\n                    if (n <= 0) {\n                        subscriber.onError(IllegalArgumentException())\n                        return\n                    }\n                    while (lastOutput < x && lastOutput < requested) {\n                        lastOutput += 1\n                        subscriber.onNext(lastOutput)\n                    }\n                }\n\n                override fun cancel() {\n                    assertEquals(x, lastOutput)\n                    expect(x + 2)\n                }\n\n            })\n        }\n        var sum = 0\n        try {\n            expect(1)\n            var i = 1\n            publisher.collect {\n                sum += it\n                i += 1\n                expect(i)\n                if (sum >= xSum) {\n                    throw IllegalArgumentException(errorString)\n                }\n            }\n        } catch (e: IllegalArgumentException) {\n            expect(x + 3)\n            assertEquals(errorString, e.message)\n        }\n        finish(x + 4)\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/PublisherCompletionStressTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.*\nimport kotlin.coroutines.*\n\nclass PublisherCompletionStressTest : TestBase() {\n    private val N_REPEATS = 10_000 * stressTestMultiplier\n\n    private fun CoroutineScope.range(context: CoroutineContext, start: Int, count: Int) = publish(context) {\n        for (x in start until start + count) send(x)\n    }\n\n    @Test\n    fun testCompletion() {\n        val rnd = Random()\n        repeat(N_REPEATS) {\n            val count = rnd.nextInt(5)\n            runBlocking {\n                withTimeout(5000) {\n                    var received = 0\n                    range(Dispatchers.Default, 1, count).collect { x ->\n                        received++\n                        if (x != received) error(\"$x != $received\")\n                    }\n                    if (received != count) error(\"$received != $count\")\n                }\n            }\n        }\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/PublisherMultiTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass PublisherMultiTest : TestBase() {\n    @Test\n    fun testConcurrentStress() = runBlocking {\n        val n = 10_000 * stressTestMultiplier\n        val observable = publish {\n            // concurrent emitters (many coroutines)\n            val jobs = List(n) {\n                // launch\n                launch(Dispatchers.Default) {\n                    send(it)\n                }\n            }\n            jobs.forEach { it.join() }\n        }\n        val resultSet = mutableSetOf<Int>()\n        observable.collect {\n            assertTrue(resultSet.add(it))\n        }\n        assertEquals(n, resultSet.size)\n    }\n\n    @Test\n    fun testConcurrentStressOnSend() = runBlocking {\n        val n = 10_000 * stressTestMultiplier\n        val observable = publish<Int> {\n            // concurrent emitters (many coroutines)\n            val jobs = List(n) {\n                // launch\n                launch(Dispatchers.Default) {\n                    select<Unit> {\n                        onSend(it) {}\n                    }\n                }\n            }\n            jobs.forEach { it.join() }\n        }\n        val resultSet = mutableSetOf<Int>()\n        observable.collect {\n            assertTrue(resultSet.add(it))\n        }\n        assertEquals(n, resultSet.size)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/PublisherRequestStressTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.flow.Flow\nimport org.junit.*\nimport org.reactivestreams.*\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport kotlin.coroutines.*\nimport kotlin.random.*\n\n/**\n * This stress-test is self-contained reproducer for the race in [Flow.asPublisher] extension\n * that was originally reported in the issue\n * [#2109](https://github.com/Kotlin/kotlinx.coroutines/issues/2109).\n * The original reproducer used a flow that loads a file using AsynchronousFileChannel\n * (that issues completion callbacks from multiple threads)\n * and uploads it to S3 via Amazon SDK, which internally uses netty for I/O\n * (which uses a single thread for connection-related callbacks).\n *\n * This stress-test essentially mimics the logic in multiple interacting threads: several emitter threads that form\n * the flow and a single requesting thread works on the subscriber's side to periodically request more\n * values when the number of items requested drops below the threshold.\n */\n@Suppress(\"ReactiveStreamsSubscriberImplementation\")\nclass PublisherRequestStressTest : TestBase() {\n\n    private val testDurationSec = 3 * stressTestMultiplier\n\n    // Original code in Amazon SDK uses 4 and 16 as low/high watermarks.\n    // These constants were chosen so that problem reproduces asap with particular this code.\n    private val minDemand = 8L\n    private val maxDemand = 16L\n\n    private val nEmitThreads = 4\n\n    private val emitThreadNo = AtomicInteger()\n\n    private val emitPool = Executors.newFixedThreadPool(nEmitThreads) { r ->\n        Thread(r, \"PublisherRequestStressTest-emit-${emitThreadNo.incrementAndGet()}\")\n    }\n\n    private val reqPool = Executors.newSingleThreadExecutor { r ->\n        Thread(r, \"PublisherRequestStressTest-req\")\n    }\n\n    private val nextValue = AtomicLong(0)\n\n    @After\n    fun tearDown() {\n        emitPool.shutdown()\n        reqPool.shutdown()\n        emitPool.awaitTermination(10, TimeUnit.SECONDS)\n        reqPool.awaitTermination(10, TimeUnit.SECONDS)\n    }\n\n    private lateinit var subscription: Subscription\n\n    @Test\n    fun testRequestStress() {\n        val expectedValue = AtomicLong(0)\n        val requestedTill = AtomicLong(0)\n        val callingOnNext = AtomicInteger()\n\n        val publisher = mtFlow().asPublisher()\n        var error = false\n        \n        publisher.subscribe(object : Subscriber<Long> {\n            private var demand = 0L // only updated from reqPool\n\n            override fun onComplete() {\n                // Typically unreached, but, rarely, `emitPool` may shut down before the cancellation is performed.\n            }\n\n            override fun onSubscribe(sub: Subscription) {\n                subscription = sub\n                maybeRequestMore()\n            }\n\n            private fun maybeRequestMore() {\n                if (demand >= minDemand) return\n                val nextDemand = Random.nextLong(minDemand + 1..maxDemand)\n                val more = nextDemand - demand\n                demand = nextDemand\n                requestedTill.addAndGet(more)\n                subscription.request(more)\n            }\n\n            override fun onNext(value: Long) {\n                check(callingOnNext.getAndIncrement() == 0) // make sure it is not concurrent\n                // check for expected value\n                check(value == expectedValue.get())\n                // check that it does not exceed requested values\n                check(value < requestedTill.get())\n                val nextExpected = value + 1\n                expectedValue.set(nextExpected)\n                // send more requests from request thread\n                reqPool.execute {\n                    demand-- // processed an item\n                    maybeRequestMore()\n                }\n                callingOnNext.decrementAndGet()\n            }\n\n            override fun onError(ex: Throwable?) {\n                error = true\n                error(\"Failed\", ex)\n            }\n        })\n        var prevExpected = -1L\n        for (second in 1..testDurationSec) {\n            if (error) break\n            Thread.sleep(1000)\n            val expected = expectedValue.get()\n            println(\"$second: expectedValue = $expected\")\n            check(expected > prevExpected) // should have progress\n            prevExpected = expected\n        }\n        if (!error) {\n            subscription.cancel()\n            runBlocking {\n                (subscription as AbstractCoroutine<*>).join()\n            }\n        }\n    }\n\n    private fun mtFlow(): Flow<Long> = flow {\n        while (currentCoroutineContext().isActive) {\n            emit(aWait())\n        }\n    }\n\n    private suspend fun aWait(): Long = suspendCancellableCoroutine { cont ->\n        emitPool.execute(Runnable {\n            cont.resume(nextValue.getAndIncrement())\n        })\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/PublisherSubscriptionSelectTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass PublisherSubscriptionSelectTest(private val request: Int) : TestBase() {\n    companion object {\n        @Parameterized.Parameters(name = \"request = {0}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = listOf(0, 1, 10).map { arrayOf<Any>(it) }\n    }\n\n    @Test\n    fun testSelect() = runTest {\n        // source with n ints\n        val n = 1000 * stressTestMultiplier\n        val source = publish { repeat(n) { send(it) } }\n        var a = 0\n        var b = 0\n        // open two subs\n        val channelA = source.toChannel(request)\n        val channelB = source.toChannel(request)\n        loop@ while (true) {\n            val done: Int = select {\n                channelA.onReceiveCatching { result ->\n                    result.onSuccess { assertEquals(a++, it) }\n                    if (result.isSuccess) 1 else 0\n                }\n                channelB.onReceiveCatching { result ->\n                    result.onSuccess { assertEquals(b++, it) }\n                    if (result.isSuccess) 2 else 0\n                }\n            }\n            when (done) {\n                0 -> break@loop\n                1 -> {\n                    val r = channelB.receiveCatching().getOrNull()\n                    if (r != null) assertEquals(b++, r)\n                }\n                2 -> {\n                    val r = channelA.receiveCatching().getOrNull()\n                    if (r != null) assertEquals(a++, r)\n                }\n            }\n        }\n\n        channelA.cancel()\n        channelB.cancel()\n        // should receive one of them fully\n        assertTrue(a == n || b == n)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/RangePublisherBufferedTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.flow.*\nimport org.junit.*\nimport org.reactivestreams.*\nimport org.reactivestreams.example.unicast.*\nimport org.reactivestreams.tck.*\n\nclass RangePublisherBufferedTest :\n    PublisherVerification<Int>(TestEnvironment(50, 50))\n{\n    override fun createPublisher(elements: Long): Publisher<Int> {\n        return RangePublisher(1, elements.toInt()).asFlow().buffer(2).asPublisher()\n    }\n\n    override fun createFailedPublisher(): Publisher<Int>? {\n        return null\n    }\n\n    @Ignore\n    override fun required_spec309_requestZeroMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() {\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/RangePublisherTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport org.junit.*\nimport org.reactivestreams.*\nimport org.reactivestreams.example.unicast.*\nimport org.reactivestreams.tck.*\n\nclass RangePublisherTest : PublisherVerification<Int>(TestEnvironment(50, 50)) {\n\n    override fun createPublisher(elements: Long): Publisher<Int> {\n        return RangePublisher(1, elements.toInt()).asFlow().asPublisher()\n    }\n\n    override fun createFailedPublisher(): Publisher<Int>? {\n        return null\n    }\n\n    @Ignore\n    override fun required_spec309_requestZeroMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() {\n    }\n}\n\nclass RangePublisherWrappedTwiceTest : PublisherVerification<Int>(TestEnvironment(50, 50)) {\n\n    override fun createPublisher(elements: Long): Publisher<Int> {\n        return RangePublisher(1, elements.toInt()).asFlow().asPublisher().asFlow().asPublisher()\n    }\n\n    override fun createFailedPublisher(): Publisher<Int>? {\n        return null\n    }\n\n    @Ignore\n    override fun required_spec309_requestZeroMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() {\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/ReactiveStreamTckTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.reactivestreams.*\nimport org.reactivestreams.tck.*\nimport org.testng.*\nimport org.testng.annotations.*\n\n\nclass ReactiveStreamTckTest : TestBase() {\n\n    @Factory(dataProvider = \"dispatchers\")\n    fun createTests(dispatcher: Dispatcher): Array<Any> {\n        return arrayOf(ReactiveStreamTckTestSuite(dispatcher))\n    }\n\n    @DataProvider(name = \"dispatchers\")\n    public fun dispatchers(): Array<Array<Any>> = Dispatcher.values().map { arrayOf<Any>(it) }.toTypedArray()\n\n\n    public class ReactiveStreamTckTestSuite(\n        private val dispatcher: Dispatcher\n    ) : PublisherVerification<Long>(TestEnvironment(500, 500)) {\n\n        override fun createPublisher(elements: Long): Publisher<Long> =\n            publish(dispatcher.dispatcher) {\n                for (i in 1..elements) send(i)\n            }\n\n        override fun createFailedPublisher(): Publisher<Long> =\n            publish(dispatcher.dispatcher) {\n                throw TestException()\n            }\n\n        @Test\n        public override fun optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() {\n            throw SkipException(\"Skipped\")\n        }\n\n        class TestException : Exception()\n    }\n}\n\nenum class Dispatcher(val dispatcher: CoroutineDispatcher) {\n    DEFAULT(Dispatchers.Default),\n    UNCONFINED(Dispatchers.Unconfined)\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactive/test/UnboundedIntegerIncrementPublisherTest.kt",
        "content": "package kotlinx.coroutines.reactive\n\nimport org.junit.*\nimport org.reactivestreams.example.unicast.AsyncIterablePublisher\nimport org.reactivestreams.Publisher\nimport org.reactivestreams.example.unicast.InfiniteIncrementNumberPublisher\nimport org.reactivestreams.tck.TestEnvironment\nimport java.util.concurrent.Executors\nimport java.util.concurrent.ExecutorService\nimport org.reactivestreams.tck.PublisherVerification\nimport org.testng.annotations.AfterClass\nimport org.testng.annotations.BeforeClass\nimport org.testng.annotations.Test\n\n@Test\nclass UnboundedIntegerIncrementPublisherTest : PublisherVerification<Int>(TestEnvironment()) {\n\n    private var e: ExecutorService? = null\n\n    @BeforeClass\n    internal fun before() {\n        e = Executors.newFixedThreadPool(4)\n    }\n\n    @AfterClass\n    internal fun after() {\n        if (e != null) e!!.shutdown()\n    }\n\n    override fun createPublisher(elements: Long): Publisher<Int> {\n        return InfiniteIncrementNumberPublisher(e!!).asFlow().asPublisher()\n    }\n\n    override fun createFailedPublisher(): Publisher<Int> {\n        return AsyncIterablePublisher(object : Iterable<Int> {\n            override fun iterator(): Iterator<Int> {\n                throw RuntimeException(\"Error state signal!\")\n            }\n        }, e!!)\n    }\n\n    override fun maxElementsFromPublisher(): Long {\n        return super.publisherUnableToSignalOnComplete()\n    }\n\n    @Ignore\n    override fun required_spec309_requestZeroMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() {\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/build.gradle.kts",
        "content": "import org.jetbrains.kotlin.gradle.dsl.*\n\nplugins {\n    // apply plugin to use autocomplete for Kover DSL\n    id(\"org.jetbrains.kotlinx.kover\")\n}\n\ndependencies {\n    api(\"io.projectreactor:reactor-core:${version(\"reactor\")}\")\n    api(project(\":kotlinx-coroutines-reactive\"))\n}\n\njava {\n    targetCompatibility = JavaVersion.VERSION_1_8\n    sourceCompatibility = JavaVersion.VERSION_1_8\n}\n\ntasks {\n    compileKotlin {\n        compilerOptions.jvmTarget = JvmTarget.JVM_1_8\n    }\n\n    compileTestKotlin {\n        compilerOptions.jvmTarget = JvmTarget.JVM_1_8\n    }\n}\n\n// the version of the docs can be different from the version of the Reactor\n// library itself: https://github.com/reactor/reactor-core/issues/3794\nexternalDocumentationLink(\n    url = \"https://projectreactor.io/docs/core/${version(\"reactor_docs\")}/api/\"\n)\n\n\nkover {\n    reports {\n        filters {\n            excludes {\n                classes(\n                    \"kotlinx.coroutines.reactor.FlowKt\", // Deprecated\n                    \"kotlinx.coroutines.reactor.ConvertKt\\$asFlux$1\" // Deprecated\n                )\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/src/Convert.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport reactor.core.publisher.*\nimport kotlin.coroutines.*\n\n/**\n * Converts this job to the hot reactive mono that signals\n * with [success][MonoSink.success] when the corresponding job completes.\n *\n * Every subscriber gets the signal at the same time.\n * Unsubscribing from the resulting mono **does not** affect the original job in any way.\n *\n * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change\n *    in the future to account for the concept of structured concurrency.\n *\n * @param context -- the coroutine context from which the resulting mono is going to be signalled\n */\npublic fun Job.asMono(context: CoroutineContext): Mono<Unit> = mono(context) { this@asMono.join() }\n/**\n * Converts this deferred value to the hot reactive mono that signals\n * [success][MonoSink.success] or [error][MonoSink.error].\n *\n * Every subscriber gets the same completion value.\n * Unsubscribing from the resulting mono **does not** affect the original deferred value in any way.\n *\n * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change\n *    in the future to account for the concept of structured concurrency.\n *\n * @param context -- the coroutine context from which the resulting mono is going to be signalled\n */\npublic fun <T> Deferred<T?>.asMono(context: CoroutineContext): Mono<T> = mono(context) { this@asMono.await() }\n\n/**\n * Converts a stream of elements received from the channel to the hot reactive flux.\n *\n * Every subscriber receives values from this channel in a **fan-out** fashion. If the are multiple subscribers,\n * they'll receive values in a round-robin way.\n * @param context -- the coroutine context from which the resulting flux is going to be signalled\n * @suppress\n */\n@Deprecated(message = \"Deprecated in the favour of consumeAsFlow()\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.consumeAsFlow().asFlux(context)\", imports = [\"kotlinx.coroutines.flow.consumeAsFlow\"]))\npublic fun <T> ReceiveChannel<T>.asFlux(context: CoroutineContext = EmptyCoroutineContext): Flux<T> = flux(context) {\n    for (t in this@asFlux)\n        send(t)\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/src/Flux.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.reactive.*\nimport org.reactivestreams.*\nimport reactor.core.*\nimport reactor.core.publisher.*\nimport reactor.util.context.*\nimport kotlin.coroutines.*\n\n/**\n * Creates a cold reactive [Flux] that runs the given [block] in a coroutine.\n * Every time the returned flux is subscribed, it starts a new coroutine in the specified [context].\n * The coroutine emits ([Subscriber.onNext]) values with [send][ProducerScope.send], completes ([Subscriber.onComplete])\n * when the coroutine completes, or, in case the coroutine throws an exception or the channel is closed,\n * emits the error ([Subscriber.onError]) and closes the channel with the cause.\n * Unsubscribing cancels the running coroutine.\n *\n * Invocations of [send][ProducerScope.send] are suspended appropriately when subscribers apply back-pressure and to\n * ensure that [onNext][Subscriber.onNext] is not invoked concurrently.\n *\n * **Note: This is an experimental api.** Behaviour of publishers that work as children in a parent scope with respect\n *        to cancellation and error handling may change in the future.\n *\n * @throws IllegalArgumentException if the provided [context] contains a [Job] instance.\n */\npublic fun <T> flux(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Flux<T> {\n    require(context[Job] === null) { \"Flux context cannot contain job in it.\" +\n        \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return Flux.from(reactorPublish(GlobalScope, context, block))\n}\n\nprivate fun <T> reactorPublish(\n    scope: CoroutineScope,\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Publisher<T> = Publisher onSubscribe@{ subscriber: Subscriber<in T>? ->\n    if (subscriber !is CoreSubscriber) {\n        subscriber.reject(IllegalArgumentException(\"Subscriber is not an instance of CoreSubscriber, context can not be extracted.\"))\n        return@onSubscribe\n    }\n    val currentContext = subscriber.currentContext()\n    val reactorContext = context.extendReactorContext(currentContext)\n    val newContext = scope.newCoroutineContext(context + reactorContext)\n    val coroutine = PublisherCoroutine(newContext, subscriber, REACTOR_HANDLER)\n    subscriber.onSubscribe(coroutine) // do it first (before starting coroutine), to avoid unnecessary suspensions\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate val REACTOR_HANDLER: (Throwable, CoroutineContext) -> Unit = { cause, ctx ->\n    if (cause !is CancellationException) {\n        try {\n            Operators.onOperatorError(cause, ctx[ReactorContext]?.context ?: Context.empty())\n        } catch (e: Throwable) {\n            cause.addSuppressed(e)\n            handleCoroutineException(ctx, cause)\n        }\n    }\n}\n\n/** The proper way to reject the subscriber, according to\n * [the reactive spec](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.9)\n */\nprivate fun <T> Subscriber<T>?.reject(t: Throwable) {\n    if (this == null)\n        throw NullPointerException(\"The subscriber can not be null\")\n    onSubscribe(object: Subscription {\n        override fun request(n: Long) {\n            // intentionally left blank\n        }\n        override fun cancel() {\n            // intentionally left blank\n        }\n    })\n    onError(t)\n}\n\n/**\n * @suppress\n */\n@Deprecated(\n    message = \"CoroutineScope.flux is deprecated in favour of top-level flux\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"flux(context, block)\")\n) // Since 1.3.0, will be error in 1.3.1 and hidden in 1.4.0. Binary compatibility with Spring\npublic fun <T> CoroutineScope.flux(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Flux<T> =\n    Flux.from(reactorPublish(this, context, block))\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/src/Migration.kt",
        "content": "@file:JvmName(\"FlowKt\")\n\npackage kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.flow.*\nimport reactor.core.publisher.*\n\n/** @suppress **/\n@Deprecated(\n    message = \"Replaced in favor of ReactiveFlow extension, please import kotlinx.coroutines.reactor.* instead of kotlinx.coroutines.reactor.FlowKt\",\n    level = DeprecationLevel.HIDDEN\n) // Compatibility with Spring 5.2-RC\n@JvmName(\"asFlux\")\npublic fun <T : Any> Flow<T>.asFluxDeprecated(): Flux<T> = asFlux()\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/src/Mono.kt",
        "content": "@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n\npackage kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.reactive.*\nimport org.reactivestreams.*\nimport reactor.core.*\nimport reactor.core.publisher.*\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.internal.*\n\n/**\n * Creates a cold [mono][Mono] that runs a given [block] in a coroutine and emits its result.\n * Every time the returned mono is subscribed, it starts a new coroutine.\n * If the result of [block] is `null`, [MonoSink.success] is invoked without a value.\n * Unsubscribing cancels the running coroutine.\n *\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n *\n * @throws IllegalArgumentException if the provided [context] contains a [Job] instance.\n */\npublic fun <T> mono(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> T?\n): Mono<T> {\n    require(context[Job] === null) { \"Mono context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return monoInternal(GlobalScope, context, block)\n}\n\n/**\n * Awaits the single value from the given [Mono] without blocking the thread and returns the resulting value, or, if\n * this publisher has produced an error, throws the corresponding exception. If the Mono completed without a value,\n * `null` is returned.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n */\npublic suspend fun <T> Mono<T>.awaitSingleOrNull(): T? = suspendCancellableCoroutine { cont ->\n    injectCoroutineContext(cont.context).subscribe(object : Subscriber<T> {\n        private var value: T? = null\n\n        override fun onSubscribe(s: Subscription) {\n            cont.invokeOnCancellation { s.cancel() }\n            s.request(Long.MAX_VALUE)\n        }\n\n        override fun onComplete() {\n            cont.resume(value)\n            value = null\n        }\n\n        override fun onNext(t: T) {\n            // We don't return the value immediately because the process that emitted it may not be finished yet.\n            // Resuming now could lead to race conditions between emitter and the awaiting code.\n            value = t\n        }\n\n        override fun onError(error: Throwable) { cont.resumeWithException(error) }\n    })\n}\n\n/**\n * Awaits the single value from the given [Mono] without blocking the thread and returns the resulting value, or,\n * if this Mono has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately cancels its [Subscription] and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the Mono does not emit any value\n */\n// TODO: consider using https://github.com/Kotlin/kotlinx.coroutines/issues/2607 once that lands\npublic suspend fun <T> Mono<T>.awaitSingle(): T = awaitSingleOrNull() ?: throw NoSuchElementException()\n\nprivate fun <T> monoInternal(\n    scope: CoroutineScope, // support for legacy mono in scope\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> T?\n): Mono<T> = Mono.create { sink ->\n    val reactorContext = context.extendReactorContext(sink.currentContext())\n    val newContext = scope.newCoroutineContext(context + reactorContext)\n    val coroutine = MonoCoroutine(newContext, sink)\n    sink.onDispose(coroutine)\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate class MonoCoroutine<in T>(\n    parentContext: CoroutineContext,\n    private val sink: MonoSink<T>\n) : AbstractCoroutine<T>(parentContext, false, true), Disposable {\n    @Volatile\n    private var disposed = false\n\n    override fun onCompleted(value: T) {\n        if (value == null) sink.success() else sink.success(value)\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        /** Cancellation exceptions that were caused by [dispose], that is, came from downstream, are not errors. */\n        val unwrappedCause = unwrap(cause)\n        if (getCancellationException() !== unwrappedCause || !disposed) {\n            try {\n                /** If [sink] turns out to already be in a terminal state, this exception will be passed through the\n                 * [Hooks.onOperatorError] hook, which is the way to signal undeliverable exceptions in Reactor. */\n                sink.error(cause)\n            } catch (e: Throwable) {\n                // In case of improper error implementation or fatal exceptions\n                cause.addSuppressed(e)\n                handleCoroutineException(context, cause)\n            }\n        }\n    }\n\n    override fun dispose() {\n        disposed = true\n        cancel()\n    }\n\n    override fun isDisposed(): Boolean = disposed\n}\n\n/**\n * @suppress\n */\n@Deprecated(\n    message = \"CoroutineScope.mono is deprecated in favour of top-level mono\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"mono(context, block)\")\n) // Since 1.3.0, will be error in 1.3.1 and hidden in 1.4.0\npublic fun <T> CoroutineScope.mono(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> T?\n): Mono<T> = monoInternal(this, context, block)\n\n/**\n * This is a lint function that was added already deprecated in order to guard against confusing usages on [Mono].\n * On [Publisher] instances other than [Mono], this function is not deprecated.\n *\n * Both [awaitFirst] and [awaitSingle] await the first value, or throw [NoSuchElementException] if there is none, but\n * the name [Mono.awaitSingle] better reflects the semantics of [Mono].\n *\n * For example, consider this code:\n * ```\n * myDbClient.findById(uniqueId).awaitFirst() // findById returns a `Mono`\n * ```\n * It looks like more than one value could be returned from `findById` and [awaitFirst] discards the extra elements,\n * when in fact, at most a single value can be present.\n *\n * @suppress\n */\n@Deprecated(\n    message = \"Mono produces at most one value, so the semantics of dropping the remaining elements are not useful. \" +\n        \"Please use awaitSingle() instead.\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingle()\")\n) // Warning since 1.5, error in 1.6\npublic suspend fun <T> Mono<T>.awaitFirst(): T = awaitSingle()\n\n/**\n * This is a lint function that was added already deprecated in order to guard against confusing usages on [Mono].\n * On [Publisher] instances other than [Mono], this function is not deprecated.\n *\n * Both [awaitFirstOrDefault] and [awaitSingleOrNull] await the first value, or return some special value if there\n * is none, but the name [Mono.awaitSingleOrNull] better reflects the semantics of [Mono].\n *\n * For example, consider this code:\n * ```\n * myDbClient.findById(uniqueId).awaitFirstOrDefault(default) // findById returns a `Mono`\n * ```\n * It looks like more than one value could be returned from `findById` and [awaitFirstOrDefault] discards the extra\n * elements, when in fact, at most a single value can be present.\n *\n * @suppress\n */\n@Deprecated(\n    message = \"Mono produces at most one value, so the semantics of dropping the remaining elements are not useful. \" +\n        \"Please use awaitSingleOrNull() instead.\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingleOrNull() ?: default\")\n) // Warning since 1.5, error in 1.6\npublic suspend fun <T> Mono<T>.awaitFirstOrDefault(default: T): T = awaitSingleOrNull() ?: default\n\n/**\n * This is a lint function that was added already deprecated in order to guard against confusing usages on [Mono].\n * On [Publisher] instances other than [Mono], this function is not deprecated.\n *\n * Both [awaitFirstOrNull] and [awaitSingleOrNull] await the first value, or return some special value if there\n * is none, but the name [Mono.awaitSingleOrNull] better reflects the semantics of [Mono].\n *\n * For example, consider this code:\n * ```\n * myDbClient.findById(uniqueId).awaitFirstOrNull() // findById returns a `Mono`\n * ```\n * It looks like more than one value could be returned from `findById` and [awaitFirstOrNull] discards the extra\n * elements, when in fact, at most a single value can be present.\n *\n * @suppress\n */\n@Deprecated(\n    message = \"Mono produces at most one value, so the semantics of dropping the remaining elements are not useful. \" +\n        \"Please use awaitSingleOrNull() instead.\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingleOrNull()\")\n) // Warning since 1.5, error in 1.6\npublic suspend fun <T> Mono<T>.awaitFirstOrNull(): T? = awaitSingleOrNull()\n\n/**\n * This is a lint function that was added already deprecated in order to guard against confusing usages on [Mono].\n * On [Publisher] instances other than [Mono], this function is not deprecated.\n *\n * Both [awaitFirstOrElse] and [awaitSingleOrNull] await the first value, or return some special value if there\n * is none, but the name [Mono.awaitSingleOrNull] better reflects the semantics of [Mono].\n *\n * For example, consider this code:\n * ```\n * myDbClient.findById(uniqueId).awaitFirstOrElse(defaultValue) // findById returns a `Mono`\n * ```\n * It looks like more than one value could be returned from `findById` and [awaitFirstOrElse] discards the extra\n * elements, when in fact, at most a single value can be present.\n *\n * @suppress\n */\n@Deprecated(\n    message = \"Mono produces at most one value, so the semantics of dropping the remaining elements are not useful. \" +\n        \"Please use awaitSingleOrNull() instead.\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingleOrNull() ?: defaultValue()\")\n) // Warning since 1.5, error in 1.6\npublic suspend fun <T> Mono<T>.awaitFirstOrElse(defaultValue: () -> T): T = awaitSingleOrNull() ?: defaultValue()\n\n/**\n * This is a lint function that was added already deprecated in order to guard against confusing usages on [Mono].\n * On [Publisher] instances other than [Mono], this function is not deprecated.\n *\n * Both [awaitLast] and [awaitSingle] await the single value, or throw [NoSuchElementException] if there is none, but\n * the name [Mono.awaitSingle] better reflects the semantics of [Mono].\n *\n * For example, consider this code:\n * ```\n * myDbClient.findById(uniqueId).awaitLast() // findById returns a `Mono`\n * ```\n * It looks like more than one value could be returned from `findById` and [awaitLast] discards the initial elements,\n * when in fact, at most a single value can be present.\n *\n * @suppress\n */\n@Deprecated(\n    message = \"Mono produces at most one value, so the last element is the same as the first. \" +\n        \"Please use awaitSingle() instead.\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingle()\")\n) // Warning since 1.5, error in 1.6\npublic suspend fun <T> Mono<T>.awaitLast(): T = awaitSingle()\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/src/ReactorContext.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.reactive.*\nimport reactor.util.context.*\n\n/**\n * Wraps Reactor's [Context] into a [CoroutineContext] element for seamless integration between\n * Reactor and kotlinx.coroutines.\n * [Context.asCoroutineContext] puts Reactor's [Context] elements into a [CoroutineContext],\n * which can be used to propagate the information about Reactor's [Context] through coroutines.\n *\n * This context element is implicitly propagated through subscribers' context by all Reactive integrations,\n * such as [mono], [flux], [Publisher.asFlow][asFlow], [Flow.asPublisher][asPublisher] and [Flow.asFlux][asFlux].\n * Functions that subscribe to a reactive stream\n * (e.g. [Publisher.awaitFirst][kotlinx.coroutines.reactive.awaitFirst]), too, propagate [ReactorContext]\n * to the subscriber's [Context].\n **\n * ### Examples of Reactive context integration.\n *\n * #### Propagating ReactorContext to Reactor's Context\n * ```\n * val flux = myDatabaseService.getUsers()\n *     .contextWrite { ctx -> println(ctx); ctx }\n * flux.awaitFirst() // Will print \"null\"\n *\n * // Now add ReactorContext\n * withContext(Context.of(\"answer\", \"42\").asCoroutineContext()) {\n *    flux.awaitFirst() // Will print \"Context{'key'='value'}\"\n * }\n * ```\n *\n * #### Propagating subscriber's Context to ReactorContext:\n * ```\n * val flow = flow {\n *     println(\"Reactor context in Flow: \" + currentCoroutineContext()[ReactorContext])\n * }\n * // No context\n * flow.asFlux()\n *     .subscribe() // Will print 'Reactor context in Flow: null'\n * // Add subscriber's context\n * flow.asFlux()\n *     .contextWrite { ctx -> ctx.put(\"answer\", 42) }\n *     .subscribe() // Will print \"Reactor context in Flow: Context{'answer'=42}\"\n * ```\n */\npublic class ReactorContext(public val context: Context) : AbstractCoroutineContextElement(ReactorContext) {\n\n    // `Context.of` is zero-cost if the argument is a `Context`\n    public constructor(contextView: ContextView): this(Context.of(contextView))\n\n    public companion object Key : CoroutineContext.Key<ReactorContext>\n\n    override fun toString(): String = context.toString()\n}\n\n/**\n * Wraps the given [ContextView] into [ReactorContext], so it can be added to the coroutine's context\n * and later used via `coroutineContext[ReactorContext]`.\n */\npublic fun ContextView.asCoroutineContext(): ReactorContext = ReactorContext(this)\n\n/** @suppress */\n@Deprecated(\"The more general version for ContextView should be used instead\", level = DeprecationLevel.HIDDEN)\npublic fun Context.asCoroutineContext(): ReactorContext = readOnly().asCoroutineContext() // `readOnly()` is zero-cost.\n\n/**\n * Updates the Reactor context in this [CoroutineContext], adding (or possibly replacing) some values.\n */\ninternal fun CoroutineContext.extendReactorContext(extensions: ContextView): CoroutineContext =\n    (this[ReactorContext]?.context?.putAll(extensions) ?: extensions).asCoroutineContext()\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/src/ReactorContextInjector.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.reactive.*\nimport org.reactivestreams.*\nimport reactor.core.publisher.*\nimport reactor.util.context.*\nimport kotlin.coroutines.*\n\ninternal class ReactorContextInjector : ContextInjector {\n    /**\n     * Injects all values from the [ReactorContext] entry of the given coroutine context\n     * into the downstream [Context] of Reactor's [Publisher] instances of [Mono] or [Flux].\n     */\n    override fun <T> injectCoroutineContext(publisher: Publisher<T>, coroutineContext: CoroutineContext): Publisher<T> {\n        val reactorContext = coroutineContext[ReactorContext]?.context ?: return publisher\n        return when(publisher) {\n            is Mono -> publisher.contextWrite(reactorContext)\n            is Flux -> publisher.contextWrite(reactorContext)\n            else -> publisher\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/src/ReactorFlow.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.flowOn\nimport kotlinx.coroutines.reactive.FlowSubscription\nimport org.reactivestreams.*\nimport reactor.core.CoreSubscriber\nimport reactor.core.publisher.Flux\nimport kotlin.coroutines.*\n\n/**\n * Converts the given flow to a cold flux.\n * The original flow is cancelled when the flux subscriber is disposed.\n *\n * This function is integrated with [ReactorContext], see its documentation for additional details.\n *\n * An optional [context] can be specified to control the execution context of calls to [Subscriber] methods.\n * You can set a [CoroutineDispatcher] to confine them to a specific thread and/or various [ThreadContextElement] to\n * inject additional context into the caller thread. By default, the [Unconfined][Dispatchers.Unconfined] dispatcher\n * is used, so calls are performed from an arbitrary thread.\n */\n@JvmOverloads // binary compatibility\npublic fun <T: Any> Flow<T>.asFlux(context: CoroutineContext = EmptyCoroutineContext): Flux<T> =\n    FlowAsFlux(this, Dispatchers.Unconfined + context)\n\nprivate class FlowAsFlux<T : Any>(\n    private val flow: Flow<T>,\n    private val context: CoroutineContext\n) : Flux<T>() {\n    override fun subscribe(subscriber: CoreSubscriber<in T>) {\n        val hasContext = !subscriber.currentContext().isEmpty\n        val source = if (hasContext) flow.flowOn(subscriber.currentContext().asCoroutineContext()) else flow\n        subscriber.onSubscribe(FlowSubscription(source, subscriber, context))\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/src/Scheduler.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.*\nimport reactor.core.Disposable\nimport reactor.core.scheduler.Scheduler\nimport java.util.concurrent.TimeUnit\nimport kotlin.coroutines.CoroutineContext\n\n/**\n * Converts an instance of [Scheduler] to an implementation of [CoroutineDispatcher].\n */\npublic fun Scheduler.asCoroutineDispatcher(): SchedulerCoroutineDispatcher = SchedulerCoroutineDispatcher(this)\n\n/**\n * Implements [CoroutineDispatcher] on top of an arbitrary [Scheduler].\n * @param scheduler a scheduler.\n */\npublic class SchedulerCoroutineDispatcher(\n    /**\n     * Underlying scheduler of current [CoroutineDispatcher].\n     */\n    public val scheduler: Scheduler\n) : CoroutineDispatcher(), Delay {\n    /** @suppress */\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        scheduler.schedule(block)\n    }\n\n    /** @suppress */\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val disposable = scheduler.schedule({\n            with(continuation) { resumeUndispatched(Unit) }\n        }, timeMillis, TimeUnit.MILLISECONDS)\n        continuation.disposeOnCancellation(disposable.asDisposableHandle())\n    }\n\n    /** @suppress */\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle =\n        scheduler.schedule(block, timeMillis, TimeUnit.MILLISECONDS).asDisposableHandle()\n\n    /** @suppress */\n    override fun toString(): String = scheduler.toString()\n    /** @suppress */\n    override fun equals(other: Any?): Boolean = other is SchedulerCoroutineDispatcher && other.scheduler === scheduler\n    /** @suppress */\n    override fun hashCode(): Int = System.identityHashCode(scheduler)\n}\n\nprivate fun Disposable.asDisposableHandle(): DisposableHandle =\n    object : DisposableHandle {\n        override fun dispose() = this@asDisposableHandle.dispose()\n    }\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/test/BackpressureTest.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.Test\nimport reactor.core.publisher.*\nimport kotlin.test.*\n\nclass BackpressureTest : TestBase() {\n    @Test\n    fun testBackpressureDropDirect() = runTest {\n        expect(1)\n        Flux.fromArray(arrayOf(1))\n            .onBackpressureDrop()\n            .collect {\n                assertEquals(1, it)\n                expect(2)\n            }\n        finish(3)\n    }\n\n    @Test\n    fun testBackpressureDropFlow() = runTest {\n        expect(1)\n        Flux.fromArray(arrayOf(1))\n            .onBackpressureDrop()\n            .asFlow()\n            .collect {\n                assertEquals(1, it)\n                expect(2)\n            }\n        finish(3)\n    }\n\n    @Test\n    fun testCooperativeCancellation() = runTest {\n        val flow = Flux.fromIterable((0L..Long.MAX_VALUE)).asFlow()\n        flow.onEach { if (it > 10) currentCoroutineContext().cancel() }.launchIn(this + Dispatchers.Default).join()\n    }\n\n    @Test\n    fun testCooperativeCancellationForBuffered() = runTest(expected = { it is CancellationException }) {\n        val flow = Flux.fromIterable((0L..Long.MAX_VALUE)).asFlow()\n        val channel = flow.onEach { if (it > 10) currentCoroutineContext().cancel() }.produceIn(this + Dispatchers.Default)\n        channel.consumeEach { /* Do nothing, just consume elements */ }\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/test/Check.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport reactor.core.publisher.Flux\nimport reactor.core.publisher.Mono\n\nfun <T> checkMonoValue(\n        mono: Mono<T>,\n        checker: (T) -> Unit\n) {\n    val monoValue = mono.block()\n    checker(monoValue)\n}\n\nfun checkErroneous(\n        mono: Mono<*>,\n        checker: (Throwable) -> Unit\n) {\n    try {\n        mono.block()\n        error(\"Should have failed\")\n    } catch (e: Throwable) {\n        checker(e)\n    }\n}\n\nfun <T> checkSingleValue(\n        flux: Flux<T>,\n        checker: (T) -> Unit\n) {\n    val singleValue = flux.toIterable().single()\n    checker(singleValue)\n}\n\nfun checkErroneous(\n        flux: Flux<*>,\n        checker: (Throwable) -> Unit\n) {\n    val singleNotification = flux.materialize().toIterable().single()\n    checker(singleNotification.throwable)\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/test/ConvertTest.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass ConvertTest : TestBase() {\n    @Test\n    fun testJobToMonoSuccess() = runBlocking {\n        expect(1)\n        val job = launch {\n            expect(3)\n        }\n        val mono = job.asMono(coroutineContext.minusKey(Job))\n        mono.subscribe {\n            expect(4)\n        }\n        expect(2)\n        yield()\n        finish(5)\n    }\n\n    @Test\n    fun testJobToMonoFail() = runBlocking {\n        expect(1)\n        val job = async(NonCancellable) {\n            expect(3)\n            throw RuntimeException(\"OK\")\n        }\n        val mono = job.asMono(coroutineContext.minusKey(Job))\n        mono.subscribe(\n                { fail(\"no item should be emitted\") },\n                { expect(4) }\n        )\n        expect(2)\n        yield()\n        finish(5)\n    }\n\n    @Test\n    fun testDeferredToMono() {\n        val d = GlobalScope.async {\n            delay(50)\n            \"OK\"\n        }\n        val mono1 = d.asMono(Dispatchers.Unconfined)\n        checkMonoValue(mono1) {\n            assertEquals(\"OK\", it)\n        }\n        val mono2 = d.asMono(Dispatchers.Unconfined)\n        checkMonoValue(mono2) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testDeferredToMonoEmpty() {\n        val d = GlobalScope.async {\n            delay(50)\n            null\n        }\n        val mono1 = d.asMono(Dispatchers.Unconfined)\n        checkMonoValue(mono1, Assert::assertNull)\n        val mono2 = d.asMono(Dispatchers.Unconfined)\n        checkMonoValue(mono2, Assert::assertNull)\n    }\n\n    @Test\n    fun testDeferredToMonoFail() {\n        val d = GlobalScope.async {\n            delay(50)\n            throw TestRuntimeException(\"OK\")\n        }\n        val mono1 = d.asMono(Dispatchers.Unconfined)\n        checkErroneous(mono1) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n        val mono2 = d.asMono(Dispatchers.Unconfined)\n        checkErroneous(mono2) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n    }\n\n    @Test\n    fun testToFlux() {\n        val c = GlobalScope.produce {\n            delay(50)\n            send(\"O\")\n            delay(50)\n            send(\"K\")\n        }\n        val flux = c.consumeAsFlow().asFlux(Dispatchers.Unconfined)\n        checkMonoValue(flux.reduce { t1, t2 -> t1 + t2 }) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testToFluxFail() {\n        val c = GlobalScope.produce {\n            delay(50)\n            send(\"O\")\n            delay(50)\n            throw TestException(\"K\")\n        }\n        val flux = c.consumeAsFlow().asFlux(Dispatchers.Unconfined)\n        val mono = mono(Dispatchers.Unconfined) {\n            var result = \"\"\n            try {\n                flux.collect { result += it }\n            } catch(e: Throwable) {\n                check(e is TestException)\n                result += e.message\n            }\n            result\n        }\n        checkMonoValue(mono) {\n            assertEquals(\"OK\", it)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/test/FlowAsFluxTest.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.Test\nimport org.reactivestreams.*\nimport reactor.core.publisher.*\nimport reactor.util.context.Context\nimport java.util.concurrent.*\nimport kotlin.test.*\n\n@Suppress(\"ReactiveStreamsSubscriberImplementation\")\nclass FlowAsFluxTest : TestBase() {\n    @Test\n    fun testFlowAsFluxContextPropagation() {\n        val flux = flow {\n            (1..4).forEach { i -> emit(createMono(i).awaitSingle()) }\n        }\n            .asFlux()\n            .contextWrite(Context.of(1, \"1\"))\n            .contextWrite(Context.of(2, \"2\", 3, \"3\", 4, \"4\"))\n        val list = flux.collectList().block()!!\n        assertEquals(listOf(\"1\", \"2\", \"3\", \"4\"), list)\n    }\n\n    private fun createMono(i: Int): Mono<String> = mono {\n        val ctx = coroutineContext[ReactorContext]!!.context\n        ctx.getOrDefault(i, \"noValue\")\n    }\n\n    @Test\n    fun testFluxAsFlowContextPropagationWithFlowOn() = runTest {\n        expect(1)\n        Flux.create<String> {\n            it.next(\"OK\")\n            it.complete()\n        }\n            .contextWrite { ctx ->\n                expect(2)\n                assertEquals(\"CTX\", ctx.get(1))\n                ctx\n            }\n            .asFlow()\n            .flowOn(ReactorContext(Context.of(1, \"CTX\")))\n            .collect {\n                expect(3)\n                assertEquals(\"OK\", it)\n            }\n        finish(4)\n    }\n\n    @Test\n    fun testFluxAsFlowContextPropagationFromScope() = runTest {\n        expect(1)\n        withContext(ReactorContext(Context.of(1, \"CTX\"))) {\n            Flux.create<String> {\n                    it.next(\"OK\")\n                    it.complete()\n                }\n            .contextWrite { ctx ->\n                expect(2)\n                assertEquals(\"CTX\", ctx.get(1))\n                ctx\n            }\n            .asFlow()\n            .collect {\n                expect(3)\n                assertEquals(\"OK\", it)\n            }\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testUnconfinedDefaultContext() {\n        expect(1)\n        val thread = Thread.currentThread()\n        fun checkThread() {\n            assertSame(thread, Thread.currentThread())\n        }\n        flowOf(42).asFlux().subscribe(object : Subscriber<Int> {\n            private lateinit var subscription: Subscription\n\n            override fun onSubscribe(s: Subscription) {\n                expect(2)\n                subscription = s\n                subscription.request(2)\n            }\n\n            override fun onNext(t: Int) {\n                checkThread()\n                expect(3)\n                assertEquals(42, t)\n            }\n\n            override fun onComplete() {\n                checkThread()\n                expect(4)\n            }\n\n            override fun onError(t: Throwable?) {\n                expectUnreached()\n            }\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testConfinedContext() {\n        expect(1)\n        val threadName = \"FlowAsFluxTest.testConfinedContext\"\n        fun checkThread() {\n            val currentThread = Thread.currentThread()\n            assertTrue(currentThread.name.startsWith(threadName), \"Unexpected thread $currentThread\")\n        }\n        val completed = CountDownLatch(1)\n        newSingleThreadContext(threadName).use { dispatcher ->\n            flowOf(42).asFlux(dispatcher).subscribe(object : Subscriber<Int> {\n                private lateinit var subscription: Subscription\n\n                override fun onSubscribe(s: Subscription) {\n                    expect(2)\n                    subscription = s\n                    subscription.request(2)\n                }\n\n                override fun onNext(t: Int) {\n                    checkThread()\n                    expect(3)\n                    assertEquals(42, t)\n                }\n\n                override fun onComplete() {\n                    checkThread()\n                    expect(4)\n                    completed.countDown()\n                }\n\n                override fun onError(t: Throwable?) {\n                    expectUnreached()\n                }\n            })\n            completed.await()\n        }\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-reactor/test/FluxCompletionStressTest.kt",
        "content": "package kotlinx.coroutines.reactor\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.*\nimport java.util.*\nimport kotlin.coroutines.*\n\nclass FluxCompletionStressTest : TestBase() {\n    private val N_REPEATS = 10_000 * stressTestMultiplier\n\n    private fun CoroutineScope.range(context: CoroutineContext, start: Int, count: Int) = flux(context) {\n        for (x in start until start + count) send(x)\n    }\n\n    @Test\n    fun testCompletion() {\n        val rnd = Random()\n        repeat(N_REPEATS) {\n            val count = rnd.nextInt(5)\n            runBlocking {\n                withTimeout(5000) {\n                    var received = 0\n                    range(Dispatchers.Default, 1, count).collect { x ->\n                        received++\n                        if (x != received) error(\"$x != $received\")\n                    }\n                    if (received != count) error(\"$received != $count\")\n                }\n            }\n        }\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/build.gradle.kts",
        "content": "import org.jetbrains.dokka.gradle.DokkaTaskPartial\nimport java.net.*\n\ndependencies {\n    api(project(\":kotlinx-coroutines-reactive\"))\n    testImplementation(\"org.reactivestreams:reactive-streams-tck:${version(\"reactive_streams\")}\")\n    api(\"io.reactivex.rxjava2:rxjava:${version(\"rxjava2\")}\")\n}\n\ntasks.withType(DokkaTaskPartial::class) {\n    dokkaSourceSets.configureEach {\n        externalDocumentationLink {\n            url = URL(\"http://reactivex.io/RxJava/2.x/javadoc/\")\n            packageListUrl = projectDir.toPath().resolve(\"package.list\").toUri().toURL()\n        }\n    }\n}\n\nval testNG by tasks.registering(Test::class) {\n    useTestNG()\n    reports.html.outputLocation = file(\"$buildDir/reports/testng\")\n    include(\"**/*ReactiveStreamTckTest.*\")\n    // Skip testNG when tests are filtered with --tests, otherwise it simply fails\n    onlyIf {\n        filter.includePatterns.isEmpty()\n    }\n    doFirst {\n        // Classic gradle, nothing works without doFirst\n        println(\"TestNG tests: ($includes)\")\n    }\n}\n\nval test by tasks.getting(Test::class) {\n    dependsOn(testNG)\n    reports.html.outputLocation = file(\"$buildDir/reports/junit\")\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxAwait.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport io.reactivex.disposables.Disposable\nimport kotlinx.coroutines.CancellableContinuation\nimport kotlinx.coroutines.CancellationException\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport kotlin.coroutines.*\n\n// ------------------------ CompletableSource ------------------------\n\n/**\n * Awaits for completion of this completable without blocking the thread.\n * Returns `Unit`, or throws the corresponding exception if this completable produces an error.\n *\n * This suspending function is cancellable. If the [Job] of the invoking coroutine is cancelled while this\n * suspending function is suspended, this function immediately resumes with [CancellationException] and disposes of its\n * subscription.\n */\npublic suspend fun CompletableSource.await(): Unit = suspendCancellableCoroutine { cont ->\n    subscribe(object : CompletableObserver {\n        override fun onSubscribe(d: Disposable) {\n            cont.disposeOnCancellation(d)\n        }\n\n        override fun onComplete() {\n            cont.resume(Unit)\n        }\n\n        override fun onError(e: Throwable) {\n            cont.resumeWithException(e)\n        }\n    })\n}\n\n// ------------------------ MaybeSource ------------------------\n\n/**\n * Awaits for completion of the [MaybeSource] without blocking the thread.\n * Returns the resulting value, or `null` if no value is produced, or throws the corresponding exception if this\n * [MaybeSource] produces an error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this\n * function immediately resumes with [CancellationException] and disposes of its subscription.\n */\npublic suspend fun <T> MaybeSource<T>.awaitSingleOrNull(): T? = suspendCancellableCoroutine { cont ->\n    subscribe(object : MaybeObserver<T> {\n        override fun onSubscribe(d: Disposable) {\n            cont.disposeOnCancellation(d)\n        }\n\n        override fun onComplete() {\n            cont.resume(null)\n        }\n\n        override fun onSuccess(t: T & Any) {\n            cont.resume(t)\n        }\n\n        override fun onError(error: Throwable) {\n            cont.resumeWithException(error)\n        }\n    })\n}\n\n/**\n * Awaits for completion of the [MaybeSource] without blocking the thread.\n * Returns the resulting value, or throws if either no value is produced or this [MaybeSource] produces an error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this\n * function immediately resumes with [CancellationException] and disposes of its subscription.\n *\n * @throws NoSuchElementException if no elements were produced by this [MaybeSource].\n */\npublic suspend fun <T> MaybeSource<T>.awaitSingle(): T = awaitSingleOrNull() ?: throw NoSuchElementException()\n\n/**\n * Awaits for completion of the maybe without blocking a thread.\n * Returns the resulting value, null if no value was produced or throws the corresponding exception if this\n * maybe had produced error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function\n * immediately resumes with [CancellationException].\n *\n * ### Deprecation\n *\n * Deprecated in favor of [awaitSingleOrNull] in order to reflect that `null` can be returned to denote the absence of\n * a value, as opposed to throwing in such case.\n * @suppress\n */\n@Deprecated(\n    message = \"Deprecated in favor of awaitSingleOrNull()\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingleOrNull()\")\n) // Warning since 1.5, error in 1.6, hidden in 1.7\npublic suspend fun <T> MaybeSource<T>.await(): T? = awaitSingleOrNull()\n\n/**\n * Awaits for completion of the maybe without blocking a thread.\n * Returns the resulting value, [default] if no value was produced or throws the corresponding exception if this\n * maybe had produced error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function\n * immediately resumes with [CancellationException].\n *\n * ### Deprecation\n *\n * Deprecated in favor of [awaitSingleOrNull] for naming consistency (see the deprecation of [MaybeSource.await] for\n * details).\n * @suppress\n */\n@Deprecated(\n    message = \"Deprecated in favor of awaitSingleOrNull()\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingleOrNull() ?: default\")\n) // Warning since 1.5, error in 1.6, hidden in 1.7\npublic suspend fun <T> MaybeSource<T>.awaitOrDefault(default: T): T = awaitSingleOrNull() ?: default\n\n// ------------------------ SingleSource ------------------------\n\n/**\n * Awaits for completion of the single value response without blocking the thread.\n * Returns the resulting value, or throws the corresponding exception if this response produces an error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n */\npublic suspend fun <T> SingleSource<T>.await(): T = suspendCancellableCoroutine { cont ->\n    subscribe(object : SingleObserver<T> {\n        override fun onSubscribe(d: Disposable) {\n            cont.disposeOnCancellation(d)\n        }\n\n        override fun onSuccess(t: T & Any) {\n            cont.resume(t)\n        }\n\n        override fun onError(error: Throwable) {\n            cont.resumeWithException(error)\n        }\n    })\n}\n\n// ------------------------ ObservableSource ------------------------\n\n/**\n * Awaits the first value from the given [Observable] without blocking the thread and returns the resulting value, or,\n * if the observable has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the observable does not emit any value\n */\npublic suspend fun <T> ObservableSource<T>.awaitFirst(): T = awaitOne(Mode.FIRST)\n\n/**\n * Awaits the first value from the given [Observable], or returns the [default] value if none is emitted, without\n * blocking the thread, and returns the resulting value, or, if this observable has produced an error, throws the\n * corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n */\npublic suspend fun <T> ObservableSource<T>.awaitFirstOrDefault(default: T): T = awaitOne(Mode.FIRST_OR_DEFAULT, default)\n\n/**\n * Awaits the first value from the given [Observable], or returns `null` if none is emitted, without blocking the\n * thread, and returns the resulting value, or, if this observable has produced an error, throws the corresponding\n * exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n */\npublic suspend fun <T> ObservableSource<T>.awaitFirstOrNull(): T? = awaitOne(Mode.FIRST_OR_DEFAULT)\n\n/**\n * Awaits the first value from the given [Observable], or calls [defaultValue] to get a value if none is emitted,\n * without blocking the thread, and returns the resulting value, or, if this observable has produced an error, throws\n * the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n */\npublic suspend fun <T> ObservableSource<T>.awaitFirstOrElse(defaultValue: () -> T): T =\n    awaitOne(Mode.FIRST_OR_DEFAULT) ?: defaultValue()\n\n/**\n * Awaits the last value from the given [Observable] without blocking the thread and\n * returns the resulting value, or, if this observable has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the observable does not emit any value\n */\npublic suspend fun <T> ObservableSource<T>.awaitLast(): T = awaitOne(Mode.LAST)\n\n/**\n * Awaits the single value from the given observable without blocking the thread and returns the resulting value, or,\n * if this observable has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the observable does not emit any value\n * @throws IllegalArgumentException if the observable emits more than one value\n */\npublic suspend fun <T> ObservableSource<T>.awaitSingle(): T = awaitOne(Mode.SINGLE)\n\n// ------------------------ private ------------------------\n\ninternal fun CancellableContinuation<*>.disposeOnCancellation(d: Disposable) =\n    invokeOnCancellation { d.dispose() }\n\nprivate enum class Mode(val s: String) {\n    FIRST(\"awaitFirst\"),\n    FIRST_OR_DEFAULT(\"awaitFirstOrDefault\"),\n    LAST(\"awaitLast\"),\n    SINGLE(\"awaitSingle\");\n    override fun toString(): String = s\n}\n\nprivate suspend fun <T> ObservableSource<T>.awaitOne(\n    mode: Mode,\n    default: T? = null\n): T = suspendCancellableCoroutine { cont ->\n    subscribe(object : Observer<T> {\n        private lateinit var subscription: Disposable\n        private var value: T? = null\n        private var seenValue = false\n\n        override fun onSubscribe(sub: Disposable) {\n            subscription = sub\n            cont.invokeOnCancellation { sub.dispose() }\n        }\n\n        override fun onNext(t: T & Any) {\n            when (mode) {\n                Mode.FIRST, Mode.FIRST_OR_DEFAULT -> {\n                    if (!seenValue) {\n                        seenValue = true\n                        cont.resume(t)\n                        subscription.dispose()\n                    }\n                }\n                Mode.LAST, Mode.SINGLE -> {\n                    if (mode == Mode.SINGLE && seenValue) {\n                        if (cont.isActive)\n                            cont.resumeWithException(IllegalArgumentException(\"More than one onNext value for $mode\"))\n                        subscription.dispose()\n                    } else {\n                        value = t\n                        seenValue = true\n                    }\n                }\n            }\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun onComplete() {\n            if (seenValue) {\n                if (cont.isActive) cont.resume(value as T)\n                return\n            }\n            when {\n                mode == Mode.FIRST_OR_DEFAULT -> {\n                    cont.resume(default as T)\n                }\n                cont.isActive -> {\n                    cont.resumeWithException(NoSuchElementException(\"No value received via onNext for $mode\"))\n                }\n            }\n        }\n\n        override fun onError(e: Throwable) {\n            cont.resumeWithException(e)\n        }\n    })\n}\n\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxCancellable.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.functions.*\nimport io.reactivex.plugins.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\ninternal class RxCancellable(private val job: Job) : Cancellable {\n    override fun cancel() {\n        job.cancel()\n    }\n}\n\ninternal fun handleUndeliverableException(cause: Throwable, context: CoroutineContext) {\n    if (cause is CancellationException) return // Async CE should be completely ignored\n    try {\n        RxJavaPlugins.onError(cause)\n    } catch (e: Throwable) {\n        cause.addSuppressed(e)\n        handleCoroutineException(context, cause)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxChannel.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\n\n/**\n * Subscribes to this [MaybeSource] and performs the specified action for each received element.\n *\n * If [action] throws an exception at some point or if the [MaybeSource] raises an error, the exception is rethrown from\n * [collect].\n */\npublic suspend inline fun <T> MaybeSource<T>.collect(action: (T) -> Unit): Unit =\n    toChannel().consumeEach(action)\n\n/**\n * Subscribes to this [ObservableSource] and performs the specified action for each received element.\n *\n * If [action] throws an exception at some point, the subscription is cancelled, and the exception is rethrown from\n * [collect]. Also, if the [ObservableSource] signals an error, that error is rethrown from [collect].\n */\npublic suspend inline fun <T> ObservableSource<T>.collect(action: (T) -> Unit): Unit =\n    toChannel().consumeEach(action)\n\n@PublishedApi\ninternal fun <T> MaybeSource<T>.toChannel(): ReceiveChannel<T> {\n    val channel = SubscriptionChannel<T>()\n    subscribe(channel)\n    return channel\n}\n\n@PublishedApi\ninternal fun <T> ObservableSource<T>.toChannel(): ReceiveChannel<T> {\n    val channel = SubscriptionChannel<T>()\n    subscribe(channel)\n    return channel\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\nprivate class SubscriptionChannel<T> :\n    BufferedChannel<T>(capacity = Channel.UNLIMITED), Observer<T>, MaybeObserver<T>\n{\n    private val _subscription = atomic<Disposable?>(null)\n\n    @Suppress(\"CANNOT_OVERRIDE_INVISIBLE_MEMBER\")\n    override fun onClosedIdempotent() {\n        _subscription.getAndSet(null)?.dispose() // dispose exactly once\n    }\n\n    // Observer overrider\n    override fun onSubscribe(sub: Disposable) {\n        _subscription.value = sub\n    }\n\n    override fun onSuccess(t: T & Any) {\n        trySend(t)\n        close(cause = null)\n    }\n\n    override fun onNext(t: T & Any) {\n        trySend(t) // Safe to ignore return value here, expectedly racing with cancellation\n    }\n\n    override fun onComplete() {\n        close(cause = null)\n    }\n\n    override fun onError(e: Throwable) {\n        close(cause = e)\n    }\n}\n\n/** @suppress */\n@Deprecated(message = \"Deprecated in the favour of Flow\", level = DeprecationLevel.HIDDEN) // ERROR in 1.4.0, HIDDEN in 1.6.0\npublic fun <T> ObservableSource<T & Any>.openSubscription(): ReceiveChannel<T> {\n    val channel = SubscriptionChannel<T>()\n    subscribe(channel)\n    return channel\n}\n\n/** @suppress */\n@Deprecated(message = \"Deprecated in the favour of Flow\", level = DeprecationLevel.HIDDEN) // ERROR in 1.4.0, HIDDEN in 1.6.0\npublic fun <T> MaybeSource<T & Any>.openSubscription(): ReceiveChannel<T> {\n    val channel = SubscriptionChannel<T>()\n    subscribe(channel)\n    return channel\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxCompletable.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Creates cold [Completable] that runs a given [block] in a coroutine and emits its result.\n * Every time the returned completable is subscribed, it starts a new coroutine.\n * Unsubscribing cancels running coroutine.\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n */\npublic fun rxCompletable(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> Unit\n): Completable {\n    require(context[Job] === null) { \"Completable context cannot contain job in it. \" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return rxCompletableInternal(GlobalScope, context, block)\n}\n\nprivate fun rxCompletableInternal(\n    scope: CoroutineScope, // support for legacy rxCompletable in scope\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> Unit\n): Completable = Completable.create { subscriber ->\n    val newContext = scope.newCoroutineContext(context)\n    val coroutine = RxCompletableCoroutine(newContext, subscriber)\n    subscriber.setCancellable(RxCancellable(coroutine))\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate class RxCompletableCoroutine(\n    parentContext: CoroutineContext,\n    private val subscriber: CompletableEmitter\n) : AbstractCoroutine<Unit>(parentContext, false, true) {\n    override fun onCompleted(value: Unit) {\n        try {\n            subscriber.onComplete()\n        } catch (e: Throwable) {\n            handleUndeliverableException(e, context)\n        }\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        try {\n            if (subscriber.tryOnError(cause)) {\n                return\n            }\n        } catch (e: Throwable) {\n            cause.addSuppressed(e)\n        }\n        handleUndeliverableException(cause, context)\n    }\n}\n\n/**\n * @suppress\n */\n@Deprecated(\n    message = \"CoroutineScope.rxCompletable is deprecated in favour of top-level rxCompletable\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"rxCompletable(context, block)\")\n) // Since 1.3.0, will be error in 1.3.1 and hidden in 1.4.0\npublic fun CoroutineScope.rxCompletable(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> Unit\n): Completable = rxCompletableInternal(this, context, block)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxConvert.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.reactivestreams.*\nimport java.util.concurrent.atomic.*\nimport kotlin.coroutines.*\n\n/**\n * Converts this job to the hot reactive completable that signals\n * with [onCompleted][CompletableObserver.onComplete] when the corresponding job completes.\n *\n * Every subscriber gets the signal at the same time.\n * Unsubscribing from the resulting completable **does not** affect the original job in any way.\n *\n * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change\n *    in the future to account for the concept of structured concurrency.\n *\n * @param context -- the coroutine context from which the resulting completable is going to be signalled\n */\npublic fun Job.asCompletable(context: CoroutineContext): Completable = rxCompletable(context) {\n    this@asCompletable.join()\n}\n\n/**\n * Converts this deferred value to the hot reactive maybe that signals\n * [onComplete][MaybeEmitter.onComplete], [onSuccess][MaybeEmitter.onSuccess] or [onError][MaybeEmitter.onError].\n *\n * Every subscriber gets the same completion value.\n * Unsubscribing from the resulting maybe **does not** affect the original deferred value in any way.\n *\n * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change\n *    in the future to account for the concept of structured concurrency.\n *\n * @param context -- the coroutine context from which the resulting maybe is going to be signalled\n */\npublic fun <T> Deferred<T?>.asMaybe(context: CoroutineContext): Maybe<T> = rxMaybe(context) {\n    this@asMaybe.await()\n}\n\n/**\n * Converts this deferred value to the hot reactive single that signals either\n * [onSuccess][SingleObserver.onSuccess] or [onError][SingleObserver.onError].\n *\n * Every subscriber gets the same completion value.\n * Unsubscribing from the resulting single **does not** affect the original deferred value in any way.\n *\n * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change\n *    in the future to account for the concept of structured concurrency.\n *\n * @param context -- the coroutine context from which the resulting single is going to be signalled\n */\npublic fun <T : Any> Deferred<T>.asSingle(context: CoroutineContext): Single<T> = rxSingle(context) {\n    this@asSingle.await()\n}\n\n/**\n * Transforms given cold [ObservableSource] into cold [Flow].\n *\n * The resulting flow is _cold_, which means that [ObservableSource.subscribe] is called every time a terminal operator\n * is applied to the resulting flow.\n *\n * A channel with the [default][Channel.BUFFERED] buffer size is used. Use the [buffer] operator on the\n * resulting flow to specify a user-defined value and to control what happens when data is produced faster\n * than consumed, i.e. to control the back-pressure behavior. Check [callbackFlow] for more details.\n */\npublic fun <T: Any> ObservableSource<T>.asFlow(): Flow<T> = callbackFlow {\n    val disposableRef = AtomicReference<Disposable>()\n    val observer = object : Observer<T> {\n        override fun onComplete() { close() }\n        override fun onSubscribe(d: Disposable) { if (!disposableRef.compareAndSet(null, d)) d.dispose() }\n        override fun onNext(t: T) {\n            /*\n             * Channel was closed by the downstream, so the exception (if any)\n             * also was handled by the same downstream\n             */\n            try {\n                trySendBlocking(t)\n            } catch (e: InterruptedException) {\n                // RxJava interrupts the source\n            }\n        }\n        override fun onError(e: Throwable) { close(e) }\n    }\n\n    subscribe(observer)\n    awaitClose { disposableRef.getAndSet(Disposables.disposed())?.dispose() }\n}\n\n/**\n * Converts the given flow to a cold observable.\n * The original flow is cancelled when the observable subscriber is disposed.\n *\n * An optional [context] can be specified to control the execution context of calls to [Observer] methods.\n * You can set a [CoroutineDispatcher] to confine them to a specific thread and/or various [ThreadContextElement] to\n * inject additional context into the caller thread. By default, the [Unconfined][Dispatchers.Unconfined] dispatcher\n * is used, so calls are performed from an arbitrary thread.\n */\npublic fun <T: Any> Flow<T>.asObservable(context: CoroutineContext = EmptyCoroutineContext) : Observable<T> = Observable.create { emitter ->\n    /*\n     * ATOMIC is used here to provide stable behaviour of subscribe+dispose pair even if\n     * asObservable is already invoked from unconfined\n     */\n    val job = GlobalScope.launch(Dispatchers.Unconfined + context, start = CoroutineStart.ATOMIC) {\n        try {\n            collect { value -> emitter.onNext(value) }\n            emitter.onComplete()\n        } catch (e: Throwable) {\n            // 'create' provides safe emitter, so we can unconditionally call on* here if exception occurs in `onComplete`\n            if (e !is CancellationException) {\n                if (!emitter.tryOnError(e)) {\n                    handleUndeliverableException(e, coroutineContext)\n                }\n            } else {\n                emitter.onComplete()\n            }\n        }\n    }\n    emitter.setCancellable(RxCancellable(job))\n}\n\n/**\n * Converts the given flow to a cold flowable.\n * The original flow is cancelled when the flowable subscriber is disposed.\n *\n * An optional [context] can be specified to control the execution context of calls to [Subscriber] methods.\n * You can set a [CoroutineDispatcher] to confine them to a specific thread and/or various [ThreadContextElement] to\n * inject additional context into the caller thread. By default, the [Unconfined][Dispatchers.Unconfined] dispatcher\n * is used, so calls are performed from an arbitrary thread.\n */\npublic fun <T: Any> Flow<T>.asFlowable(context: CoroutineContext = EmptyCoroutineContext): Flowable<T> =\n    Flowable.fromPublisher(asPublisher(context))\n\n@Deprecated(\n    message = \"Deprecated in the favour of Flow\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.consumeAsFlow().asObservable(context)\", \"kotlinx.coroutines.flow.consumeAsFlow\")\n) // Deprecated since 1.4.0\npublic fun <T : Any> ReceiveChannel<T>.asObservable(context: CoroutineContext): Observable<T> = rxObservable(context) {\n    for (t in this@asObservable)\n        send(t)\n}\n\n/** @suppress **/\n@Suppress(\"UNUSED\") // KT-42513\n@JvmOverloads // binary compatibility\n@JvmName(\"from\")\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"\") // Since 1.4, was experimental prior to that\npublic fun <T: Any> Flow<T>._asFlowable(context: CoroutineContext = EmptyCoroutineContext): Flowable<T> =\n    asFlowable(context)\n\n/** @suppress **/\n@Suppress(\"UNUSED\") // KT-42513\n@JvmOverloads // binary compatibility\n@JvmName(\"from\")\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"\") // Since 1.4, was experimental prior to that\npublic fun <T: Any> Flow<T>._asObservable(context: CoroutineContext = EmptyCoroutineContext) : Observable<T> = asObservable(context)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxFlowable.kt",
        "content": "@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n\npackage kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.reactive.*\nimport kotlin.coroutines.*\nimport kotlin.internal.*\n\n/**\n * Creates cold [flowable][Flowable] that will run a given [block] in a coroutine.\n * Every time the returned flowable is subscribed, it starts a new coroutine.\n *\n * Coroutine emits ([ObservableEmitter.onNext]) values with `send`, completes ([ObservableEmitter.onComplete])\n * when the coroutine completes or channel is explicitly closed and emits error ([ObservableEmitter.onError])\n * if coroutine throws an exception or closes channel with a cause.\n * Unsubscribing cancels running coroutine.\n *\n * Invocations of `send` are suspended appropriately when subscribers apply back-pressure and to ensure that\n * `onNext` is not invoked concurrently.\n *\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n *\n * **Note: This is an experimental api.** Behaviour of publishers that work as children in a parent scope with respect\n */\npublic fun <T: Any> rxFlowable(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Flowable<T> {\n    require(context[Job] === null) { \"Flowable context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return Flowable.fromPublisher(publishInternal(GlobalScope, context, RX_HANDLER, block))\n}\n\n/** @suppress */\n@Deprecated(\n    message = \"CoroutineScope.rxFlowable is deprecated in favour of top-level rxFlowable\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"rxFlowable(context, block)\")\n) // Since 1.3.0, will be error in 1.3.1 and hidden in 1.4.0\n@LowPriorityInOverloadResolution\npublic fun <T: Any> CoroutineScope.rxFlowable(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Flowable<T> = Flowable.fromPublisher(publishInternal(this, context, RX_HANDLER, block))\n\nprivate val RX_HANDLER: (Throwable, CoroutineContext) -> Unit = ::handleUndeliverableException\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxMaybe.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Creates cold [maybe][Maybe] that will run a given [block] in a coroutine and emits its result.\n * If [block] result is `null`, [onComplete][MaybeObserver.onComplete] is invoked without a value.\n * Every time the returned observable is subscribed, it starts a new coroutine.\n * Unsubscribing cancels running coroutine.\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n */\npublic fun <T> rxMaybe(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> T?\n): Maybe<T> {\n    require(context[Job] === null) { \"Maybe context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return rxMaybeInternal(GlobalScope, context, block)\n}\n\nprivate fun <T> rxMaybeInternal(\n    scope: CoroutineScope, // support for legacy rxMaybe in scope\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> T?\n): Maybe<T> = Maybe.create { subscriber ->\n    val newContext = scope.newCoroutineContext(context)\n    val coroutine = RxMaybeCoroutine(newContext, subscriber)\n    subscriber.setCancellable(RxCancellable(coroutine))\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate class RxMaybeCoroutine<T>(\n    parentContext: CoroutineContext,\n    private val subscriber: MaybeEmitter<T>\n) : AbstractCoroutine<T>(parentContext, false, true) {\n    override fun onCompleted(value: T) {\n        try {\n            if (value == null) subscriber.onComplete() else subscriber.onSuccess(value)\n        } catch (e: Throwable) {\n            handleUndeliverableException(e, context)\n        }\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        try {\n            if (subscriber.tryOnError(cause)) {\n                return\n            }\n        } catch (e: Throwable) {\n            cause.addSuppressed(e)\n        }\n        handleUndeliverableException(cause, context)\n    }\n}\n\n/** @suppress */\n@Deprecated(\n    message = \"CoroutineScope.rxMaybe is deprecated in favour of top-level rxMaybe\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"rxMaybe(context, block)\")\n) // Since 1.3.0, will be error in 1.3.1 and hidden in 1.4.0\npublic fun <T> CoroutineScope.rxMaybe(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> T?\n): Maybe<T> = rxMaybeInternal(this, context, block)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxObservable.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport io.reactivex.exceptions.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.internal.*\nimport kotlinx.coroutines.selects.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.coroutines.*\n\n/**\n * Creates cold [observable][Observable] that will run a given [block] in a coroutine.\n * Every time the returned observable is subscribed, it starts a new coroutine.\n *\n * Coroutine emits ([ObservableEmitter.onNext]) values with `send`, completes ([ObservableEmitter.onComplete])\n * when the coroutine completes or channel is explicitly closed and emits error ([ObservableEmitter.onError])\n * if coroutine throws an exception or closes channel with a cause.\n * Unsubscribing cancels running coroutine.\n *\n * Invocations of `send` are suspended appropriately to ensure that `onNext` is not invoked concurrently.\n * Note that Rx 2.x [Observable] **does not support backpressure**.\n *\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n */\npublic fun <T : Any> rxObservable(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Observable<T> {\n    require(context[Job] === null) { \"Observable context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return rxObservableInternal(GlobalScope, context, block)\n}\n\nprivate fun <T : Any> rxObservableInternal(\n    scope: CoroutineScope, // support for legacy rxObservable in scope\n    context: CoroutineContext,\n    block: suspend ProducerScope<T>.() -> Unit\n): Observable<T> = Observable.create { subscriber ->\n    val newContext = scope.newCoroutineContext(context)\n    val coroutine = RxObservableCoroutine(newContext, subscriber)\n    subscriber.setCancellable(RxCancellable(coroutine)) // do it first (before starting coroutine), to await unnecessary suspensions\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate const val OPEN = 0        // open channel, still working\nprivate const val CLOSED = -1     // closed, but have not signalled onCompleted/onError yet\nprivate const val SIGNALLED = -2  // already signalled subscriber onCompleted/onError\n\nprivate class RxObservableCoroutine<T : Any>(\n    parentContext: CoroutineContext,\n    private val subscriber: ObservableEmitter<T>\n) : AbstractCoroutine<Unit>(parentContext, false, true), ProducerScope<T> {\n    override val channel: SendChannel<T> get() = this\n\n    private val _signal = atomic(OPEN)\n\n    override val isClosedForSend: Boolean get() = !isActive\n    override fun close(cause: Throwable?): Boolean = cancelCoroutine(cause)\n    override fun invokeOnClose(handler: (Throwable?) -> Unit) =\n        throw UnsupportedOperationException(\"RxObservableCoroutine doesn't support invokeOnClose\")\n\n    // Mutex is locked when either nRequested == 0 or while subscriber.onXXX is being invoked\n    private val mutex: Mutex = Mutex()\n\n    @Suppress(\"UNCHECKED_CAST\", \"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n    override val onSend: SelectClause2<T, SendChannel<T>> get() = SelectClause2Impl(\n        clauseObject = this,\n        regFunc = RxObservableCoroutine<*>::registerSelectForSend as RegistrationFunction,\n        processResFunc = RxObservableCoroutine<*>::processResultSelectSend as ProcessResultFunction\n    )\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun registerSelectForSend(select: SelectInstance<*>, element: Any?) {\n        // Try to acquire the mutex and complete in the registration phase.\n        if (mutex.tryLock()) {\n            select.selectInRegistrationPhase(Unit)\n            return\n        }\n        // Start a new coroutine that waits for the mutex, invoking `trySelect(..)` after that.\n        // Please note that at the point of the `trySelect(..)` invocation the corresponding\n        // `select` can still be in the registration phase, making this `trySelect(..)` bound to fail.\n        // In this case, the `onSend` clause will be re-registered, which alongside with the mutex\n        // manipulation makes the resulting solution obstruction-free.\n        launch {\n            mutex.lock()\n            if (!select.trySelect(this@RxObservableCoroutine, Unit)) {\n                mutex.unlock()\n            }\n        }\n    }\n\n    @Suppress(\"RedundantNullableReturnType\", \"UNUSED_PARAMETER\", \"UNCHECKED_CAST\")\n    private fun processResultSelectSend(element: Any?, selectResult: Any?): Any? {\n        doLockedNext(element as T)?.let { throw it }\n        return this@RxObservableCoroutine\n    }\n\n    override fun trySend(element: T): ChannelResult<Unit> =\n        if (!mutex.tryLock()) {\n            ChannelResult.failure()\n        } else {\n            when (val throwable = doLockedNext(element)) {\n                null -> ChannelResult.success(Unit)\n                else -> ChannelResult.closed(throwable)\n            }\n        }\n\n    override suspend fun send(element: T) {\n        mutex.lock()\n        doLockedNext(element)?.let { throw it }\n    }\n\n    // assert: mutex.isLocked()\n    private fun doLockedNext(elem: T): Throwable? {\n        // check if already closed for send\n        if (!isActive) {\n            doLockedSignalCompleted(completionCause, completionCauseHandled)\n            return getCancellationException()\n        }\n        // notify subscriber\n        try {\n            subscriber.onNext(elem)\n        } catch (e: Throwable) {\n            val cause = UndeliverableException(e)\n            val causeDelivered = close(cause)\n            unlockAndCheckCompleted()\n            return if (causeDelivered) {\n                // `cause` is the reason this channel is closed\n                cause\n            } else {\n                // Someone else closed the channel during `onNext`. We report `cause` as an undeliverable exception.\n                handleUndeliverableException(cause, context)\n                getCancellationException()\n            }\n        }\n        /*\n         * There is no sense to check for `isActive` before doing `unlock`, because cancellation/completion might\n         * happen after this check and before `unlock` (see signalCompleted that does not do anything\n         * if it fails to acquire the lock that we are still holding).\n         * We have to recheck `isCompleted` after `unlock` anyway.\n         */\n        unlockAndCheckCompleted()\n        return null\n    }\n\n    private fun unlockAndCheckCompleted() {\n        mutex.unlock()\n        // recheck isActive\n        if (!isActive && mutex.tryLock())\n            doLockedSignalCompleted(completionCause, completionCauseHandled)\n    }\n\n    // assert: mutex.isLocked()\n    private fun doLockedSignalCompleted(cause: Throwable?, handled: Boolean) {\n        // cancellation failures\n        try {\n            if (_signal.value == SIGNALLED)\n                return\n            _signal.value = SIGNALLED // we'll signal onError/onCompleted (that the final state -- no CAS needed)\n            @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n            val unwrappedCause = cause?.let { unwrap(it) }\n            if (unwrappedCause == null) {\n                try {\n                    subscriber.onComplete()\n                } catch (e: Exception) {\n                    handleUndeliverableException(e, context)\n                }\n            } else if (unwrappedCause is UndeliverableException && !handled) {\n                /** Such exceptions are not reported to `onError`, as, according to the reactive specifications,\n                 * exceptions thrown from the Subscriber methods must be treated as if the Subscriber was already\n                 * cancelled. */\n                handleUndeliverableException(cause, context)\n            } else if (unwrappedCause !== getCancellationException() || !subscriber.isDisposed) {\n                try {\n                    /** If the subscriber is already in a terminal state, the error will be signalled to\n                     * `RxJavaPlugins.onError`. */\n                    subscriber.onError(cause)\n                } catch (e: Exception) {\n                    cause.addSuppressed(e)\n                    handleUndeliverableException(cause, context)\n                }\n            }\n        } finally {\n            mutex.unlock()\n        }\n    }\n\n    private fun signalCompleted(cause: Throwable?, handled: Boolean) {\n        if (!_signal.compareAndSet(OPEN, CLOSED)) return // abort, other thread invoked doLockedSignalCompleted\n        if (mutex.tryLock()) // if we can acquire the lock\n            doLockedSignalCompleted(cause, handled)\n    }\n\n    override fun onCompleted(value: Unit) {\n        signalCompleted(null, false)\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        signalCompleted(cause, handled)\n    }\n}\n\n/** @suppress */\n@Deprecated(\n    message = \"CoroutineScope.rxObservable is deprecated in favour of top-level rxObservable\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"rxObservable(context, block)\")\n) // Since 1.3.0, will be error in 1.3.1 and hidden in 1.4.0\npublic fun <T : Any> CoroutineScope.rxObservable(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Observable<T> = rxObservableInternal(this, context, block)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxScheduler.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport io.reactivex.plugins.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n/**\n * Converts an instance of [Scheduler] to an implementation of [CoroutineDispatcher]\n * and provides native support of [delay] and [withTimeout].\n */\npublic fun Scheduler.asCoroutineDispatcher(): CoroutineDispatcher =\n    if (this is DispatcherScheduler) {\n        dispatcher\n    } else {\n        SchedulerCoroutineDispatcher(this)\n    }\n\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.4.2, binary compatibility with earlier versions\")\n@JvmName(\"asCoroutineDispatcher\")\npublic fun Scheduler.asCoroutineDispatcher0(): SchedulerCoroutineDispatcher =\n    SchedulerCoroutineDispatcher(this)\n\n/**\n * Converts an instance of [CoroutineDispatcher] to an implementation of [Scheduler].\n */\npublic fun CoroutineDispatcher.asScheduler(): Scheduler =\n    if (this is SchedulerCoroutineDispatcher) {\n        scheduler\n    } else {\n        DispatcherScheduler(this)\n    }\n\nprivate class DispatcherScheduler(@JvmField val dispatcher: CoroutineDispatcher) : Scheduler() {\n\n    private val schedulerJob = SupervisorJob()\n\n    /**\n     * The scope for everything happening in this [DispatcherScheduler].\n     *\n     * Running tasks, too, get launched under this scope, because [shutdown] should cancel the running tasks as well.\n     */\n    private val scope = CoroutineScope(schedulerJob + dispatcher)\n\n    /**\n     * The counter of created workers, for their pretty-printing.\n     */\n    private val workerCounter = atomic(1L)\n\n    override fun scheduleDirect(block: Runnable, delay: Long, unit: TimeUnit): Disposable =\n        scope.scheduleTask(block, unit.toMillis(delay)) { task ->\n            Runnable { scope.launch { task() } }\n        }\n\n    override fun createWorker(): Worker = DispatcherWorker(workerCounter.getAndIncrement(), dispatcher, schedulerJob)\n\n    override fun shutdown() {\n        schedulerJob.cancel()\n    }\n\n    private class DispatcherWorker(\n        private val counter: Long,\n        private val dispatcher: CoroutineDispatcher,\n        parentJob: Job\n    ) : Worker() {\n\n        private val workerJob = SupervisorJob(parentJob)\n        private val workerScope = CoroutineScope(workerJob + dispatcher)\n        private val blockChannel = Channel<suspend () -> Unit>(Channel.UNLIMITED)\n\n        init {\n            workerScope.launch {\n                blockChannel.consumeEach {\n                    it()\n                }\n            }\n        }\n\n        override fun schedule(block: Runnable, delay: Long, unit: TimeUnit): Disposable =\n            workerScope.scheduleTask(block, unit.toMillis(delay)) { task ->\n                Runnable { blockChannel.trySend(task) }\n            }\n\n        override fun isDisposed(): Boolean = !workerScope.isActive\n\n        override fun dispose() {\n            blockChannel.close()\n            workerJob.cancel()\n        }\n\n        override fun toString(): String = \"$dispatcher (worker $counter, ${if (isDisposed) \"disposed\" else \"active\"})\"\n    }\n\n    override fun toString(): String = dispatcher.toString()\n}\n\nprivate typealias Task = suspend () -> Unit\n\n/**\n * Schedule [block] so that an adapted version of it, wrapped in [adaptForScheduling], executes after [delayMillis]\n * milliseconds.\n */\nprivate fun CoroutineScope.scheduleTask(\n    block: Runnable,\n    delayMillis: Long,\n    adaptForScheduling: (Task) -> Runnable\n): Disposable {\n    val ctx = coroutineContext\n    var handle: DisposableHandle? = null\n    val disposable = Disposables.fromRunnable {\n        // null if delay <= 0\n        handle?.dispose()\n    }\n    val decoratedBlock = RxJavaPlugins.onSchedule(block)\n    suspend fun task() {\n        if (disposable.isDisposed) return\n        try {\n            runInterruptible {\n                decoratedBlock.run()\n            }\n        } catch (e: Throwable) {\n            handleUndeliverableException(e, ctx)\n        }\n    }\n\n    val toSchedule = adaptForScheduling(::task)\n    if (!isActive) return Disposables.disposed()\n    if (delayMillis <= 0) {\n        toSchedule.run()\n    } else {\n        @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n        ctx.delay.invokeOnTimeout(delayMillis, toSchedule, ctx).let { handle = it }\n    }\n    return disposable\n}\n\n/**\n * Implements [CoroutineDispatcher] on top of an arbitrary [Scheduler].\n */\npublic class SchedulerCoroutineDispatcher(\n    /**\n     * Underlying scheduler of current [CoroutineDispatcher].\n     */\n    public val scheduler: Scheduler\n) : CoroutineDispatcher(), Delay {\n    /** @suppress */\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        scheduler.scheduleDirect(block)\n    }\n\n    /** @suppress */\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val disposable = scheduler.scheduleDirect({\n            with(continuation) { resumeUndispatched(Unit) }\n        }, timeMillis, TimeUnit.MILLISECONDS)\n        continuation.disposeOnCancellation(disposable)\n    }\n\n    /** @suppress */\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        val disposable = scheduler.scheduleDirect(block, timeMillis, TimeUnit.MILLISECONDS)\n        return DisposableHandle { disposable.dispose() }\n    }\n\n    /** @suppress */\n    override fun toString(): String = scheduler.toString()\n\n    /** @suppress */\n    override fun equals(other: Any?): Boolean = other is SchedulerCoroutineDispatcher && other.scheduler === scheduler\n\n    /** @suppress */\n    override fun hashCode(): Int = System.identityHashCode(scheduler)\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/src/RxSingle.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Creates cold [single][Single] that will run a given [block] in a coroutine and emits its result.\n * Every time the returned observable is subscribed, it starts a new coroutine.\n * Unsubscribing cancels running coroutine.\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n */\npublic fun <T : Any> rxSingle(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> T\n): Single<T> {\n    require(context[Job] === null) { \"Single context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return rxSingleInternal(GlobalScope, context, block)\n}\n\nprivate fun <T : Any> rxSingleInternal(\n    scope: CoroutineScope, // support for legacy rxSingle in scope\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> T\n): Single<T> = Single.create { subscriber ->\n    val newContext = scope.newCoroutineContext(context)\n    val coroutine = RxSingleCoroutine(newContext, subscriber)\n    subscriber.setCancellable(RxCancellable(coroutine))\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate class RxSingleCoroutine<T: Any>(\n    parentContext: CoroutineContext,\n    private val subscriber: SingleEmitter<T>\n) : AbstractCoroutine<T>(parentContext, false, true) {\n    override fun onCompleted(value: T) {\n        try {\n            subscriber.onSuccess(value)\n        } catch (e: Throwable) {\n            handleUndeliverableException(e, context)\n        }\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        try {\n            if (subscriber.tryOnError(cause)) {\n                return\n            }\n        } catch (e: Throwable) {\n            cause.addSuppressed(e)\n        }\n        handleUndeliverableException(cause, context)\n    }\n}\n\n/** @suppress */\n@Deprecated(\n    message = \"CoroutineScope.rxSingle is deprecated in favour of top-level rxSingle\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"rxSingle(context, block)\")\n) // Since 1.3.0, will be error in 1.3.1 and hidden in 1.4.0\npublic fun <T : Any> CoroutineScope.rxSingle(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> T\n): Single<T> = rxSingleInternal(this, context, block)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/BackpressureTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass BackpressureTest : TestBase() {\n    @Test\n    fun testBackpressureDropDirect() = runTest {\n        expect(1)\n        Flowable.fromArray(1)\n            .onBackpressureDrop()\n            .collect {\n                assertEquals(1, it)\n                expect(2)\n            }\n        finish(3)\n    }\n\n    @Test\n    fun testBackpressureDropFlow() = runTest {\n        expect(1)\n        Flowable.fromArray(1)\n            .onBackpressureDrop()\n            .asFlow()\n            .collect {\n                assertEquals(1, it)\n                expect(2)\n            }\n        finish(3)\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/Check.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport io.reactivex.functions.Consumer\nimport io.reactivex.plugins.*\n\nfun <T> checkSingleValue(\n    observable: Observable<T>,\n    checker: (T) -> Unit\n) {\n    val singleValue = observable.blockingSingle()\n    checker(singleValue)\n}\n\nfun checkErroneous(\n        observable: Observable<*>,\n        checker: (Throwable) -> Unit\n) {\n    val singleNotification = observable.materialize().blockingSingle()\n    val error = singleNotification.error ?: error(\"Excepted error\")\n    checker(error)\n}\n\nfun <T> checkSingleValue(\n    single: Single<T>,\n    checker: (T) -> Unit\n) {\n    val singleValue = single.blockingGet()\n    checker(singleValue)\n}\n\nfun checkErroneous(\n    single: Single<*>,\n    checker: (Throwable) -> Unit\n) {\n    try {\n        single.blockingGet()\n        error(\"Should have failed\")\n    } catch (e: Throwable) {\n        checker(e)\n    }\n}\n\nfun <T> checkMaybeValue(\n        maybe: Maybe<T>,\n        checker: (T?) -> Unit\n) {\n    val maybeValue = maybe.toFlowable().blockingIterable().firstOrNull()\n    checker(maybeValue)\n}\n\n@Suppress(\"UNCHECKED_CAST\")\nfun checkErroneous(\n    maybe: Maybe<*>,\n    checker: (Throwable) -> Unit\n) {\n    try {\n        (maybe as Maybe<Any>).blockingGet()\n        error(\"Should have failed\")\n    } catch (e: Throwable) {\n        checker(e)\n    }\n}\n\ninline fun withExceptionHandler(noinline handler: (Throwable) -> Unit, block: () -> Unit) {\n    val original = RxJavaPlugins.getErrorHandler()\n    RxJavaPlugins.setErrorHandler { handler(it) }\n    try {\n        block()\n    } finally {\n        RxJavaPlugins.setErrorHandler(original)\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/CompletableTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport io.reactivex.exceptions.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass CompletableTest : TestBase() {\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(4)\n        }\n        expect(2)\n        completable.subscribe {\n            expect(5)\n        }\n        expect(3)\n        yield() // to completable coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        completable.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to completable coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n        }\n        expect(2)\n        // nothing is called on a disposed rx2 completable\n        val sub = completable.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testAwaitSuccess() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(3)\n        }\n        expect(2)\n        completable.await() // shall launch coroutine\n        finish(4)\n    }\n\n    @Test\n    fun testAwaitFailure() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(3)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        try {\n            completable.await() // shall launch coroutine and throw exception\n            expectUnreached()\n        } catch (e: RuntimeException) {\n            finish(4)\n            assertEquals(\"OK\", e.message)\n        }\n    }\n\n    /** Tests that calls to [await] throw [CancellationException] and dispose of the subscription when their [Job] is\n     * cancelled. */\n    @Test\n    fun testAwaitCancellation() = runTest {\n        expect(1)\n        val completable = CompletableSource { s ->\n            s.onSubscribe(object: Disposable {\n                override fun dispose() { expect(4) }\n                override fun isDisposed(): Boolean { expectUnreached(); return false }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                completable.await()\n            } catch (e: CancellationException) {\n                expect(5)\n                throw e\n            }\n        }\n        expect(3)\n        job.cancelAndJoin()\n        finish(6)\n    }\n\n    @Test\n    fun testSuppressedException() = runTest {\n        val completable = rxCompletable(currentDispatcher()) {\n            launch(start = CoroutineStart.ATOMIC) {\n                throw TestException() // child coroutine fails\n            }\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException2() // but parent throws another exception while cleaning up\n            }\n        }\n        try {\n            completable.await()\n            expectUnreached()\n        } catch (e: TestException) {\n            assertIs<TestException2>(e.suppressed[0])\n        }\n    }\n\n    @Test\n    fun testUnhandledException() = runTest {\n        expect(1)\n        var disposable: Disposable? = null\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is TestException)\n            expect(5)\n        }\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(4)\n            disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException() // would not be able to handle it since mono is disposed\n            }\n        }\n        withExceptionHandler(handler) {\n            completable.subscribe(object : CompletableObserver {\n                override fun onSubscribe(d: Disposable) {\n                    expect(2)\n                    disposable = d\n                }\n\n                override fun onComplete() {\n                    expectUnreached()\n                }\n\n                override fun onError(t: Throwable) {\n                    expectUnreached()\n                }\n            })\n            expect(3)\n            yield() // run coroutine\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSubscribe() = runTest {\n        val handler: (Throwable) -> Unit = { e ->\n            assertTrue(e is UndeliverableException && e.cause is LinkageError); expect(2)\n        }\n\n        withExceptionHandler(handler) {\n            rxCompletable(Dispatchers.Unconfined) {\n                expect(1)\n            }.subscribe { throw LinkageError() }\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSingle() = runTest {\n        rxCompletable(Dispatchers.Unconfined) {\n            throw LinkageError()\n        }.subscribe({ expectUnreached()  }, { expect(1); assertIs<LinkageError>(it) })\n        finish(2)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ConvertTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.Assert\nimport org.junit.Test\nimport kotlin.test.*\n\nclass ConvertTest : TestBase() {\n    @Test\n    fun testToCompletableSuccess() = runBlocking {\n        expect(1)\n        val job = launch {\n            expect(3)\n        }\n        val completable = job.asCompletable(coroutineContext.minusKey(Job))\n        completable.subscribe {\n            expect(4)\n        }\n        expect(2)\n        yield()\n        finish(5)\n    }\n\n    @Test\n    fun testToCompletableFail() = runBlocking {\n        expect(1)\n        val job = async(NonCancellable) { // don't kill parent on exception\n            expect(3)\n            throw RuntimeException(\"OK\")\n        }\n        val completable = job.asCompletable(coroutineContext.minusKey(Job))\n        completable.subscribe {\n            expect(4)\n        }\n        expect(2)\n        yield()\n        finish(5)\n    }\n\n    @Test\n    fun testToMaybe() {\n        val d = GlobalScope.async {\n            delay(50)\n            \"OK\"\n        }\n        val maybe1 = d.asMaybe(Dispatchers.Unconfined)\n        checkMaybeValue(maybe1) {\n            assertEquals(\"OK\", it)\n        }\n        val maybe2 = d.asMaybe(Dispatchers.Unconfined)\n        checkMaybeValue(maybe2) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testToMaybeEmpty() {\n        val d = GlobalScope.async {\n            delay(50)\n            null\n        }\n        val maybe1 = d.asMaybe(Dispatchers.Unconfined)\n        checkMaybeValue(maybe1, Assert::assertNull)\n        val maybe2 = d.asMaybe(Dispatchers.Unconfined)\n        checkMaybeValue(maybe2, Assert::assertNull)\n    }\n\n    @Test\n    fun testToMaybeFail() {\n        val d = GlobalScope.async {\n            delay(50)\n            throw TestRuntimeException(\"OK\")\n        }\n        val maybe1 = d.asMaybe(Dispatchers.Unconfined)\n        checkErroneous(maybe1) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n        val maybe2 = d.asMaybe(Dispatchers.Unconfined)\n        checkErroneous(maybe2) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n    }\n\n    @Test\n    fun testToSingle() {\n        val d = GlobalScope.async {\n            delay(50)\n            \"OK\"\n        }\n        val single1 = d.asSingle(Dispatchers.Unconfined)\n        checkSingleValue(single1) {\n            assertEquals(\"OK\", it)\n        }\n        val single2 = d.asSingle(Dispatchers.Unconfined)\n        checkSingleValue(single2) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testToSingleFail() {\n        val d = GlobalScope.async {\n            delay(50)\n            throw TestRuntimeException(\"OK\")\n        }\n        val single1 = d.asSingle(Dispatchers.Unconfined)\n        checkErroneous(single1) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n        val single2 = d.asSingle(Dispatchers.Unconfined)\n        checkErroneous(single2) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n    }\n\n    @Test\n    fun testToObservable() {\n        val c = GlobalScope.produce {\n            delay(50)\n            send(\"O\")\n            delay(50)\n            send(\"K\")\n        }\n        val observable = c.consumeAsFlow().asObservable(Dispatchers.Unconfined)\n        checkSingleValue(observable.reduce { t1, t2 -> t1 + t2 }.toSingle()) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testToObservableFail() {\n        val c = GlobalScope.produce {\n            delay(50)\n            send(\"O\")\n            delay(50)\n            throw TestException(\"K\")\n        }\n        val observable = c.consumeAsFlow().asObservable(Dispatchers.Unconfined)\n        val single = rxSingle(Dispatchers.Unconfined) {\n            var result = \"\"\n            try {\n                observable.collect { result += it }\n            } catch(e: Throwable) {\n                check(e is TestException)\n                result += e.message\n            }\n            result\n        }\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/FlowAsFlowableTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.Test\nimport org.reactivestreams.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\n@Suppress(\"ReactiveStreamsSubscriberImplementation\")\nclass FlowAsFlowableTest : TestBase() {\n    @Test\n    fun testUnconfinedDefaultContext() {\n        expect(1)\n        val thread = Thread.currentThread()\n        fun checkThread() {\n            assertSame(thread, Thread.currentThread())\n        }\n        flowOf(42).asFlowable().subscribe(object : Subscriber<Int> {\n            private lateinit var subscription: Subscription\n\n            override fun onSubscribe(s: Subscription) {\n                expect(2)\n                subscription = s\n                subscription.request(2)\n            }\n\n            override fun onNext(t: Int) {\n                checkThread()\n                expect(3)\n                assertEquals(42, t)\n            }\n\n            override fun onComplete() {\n                checkThread()\n                expect(4)\n            }\n\n            override fun onError(t: Throwable?) {\n                expectUnreached()\n            }\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testConfinedContext() {\n        expect(1)\n        val threadName = \"FlowAsFlowableTest.testConfinedContext\"\n        fun checkThread() {\n            val currentThread = Thread.currentThread()\n            assertTrue(currentThread.name.startsWith(threadName), \"Unexpected thread $currentThread\")\n        }\n        val completed = CountDownLatch(1)\n        newSingleThreadContext(threadName).use { dispatcher ->\n            flowOf(42).asFlowable(dispatcher).subscribe(object : Subscriber<Int> {\n                private lateinit var subscription: Subscription\n\n                override fun onSubscribe(s: Subscription) {\n                    expect(2)\n                    subscription = s\n                    subscription.request(2)\n                }\n\n                override fun onNext(t: Int) {\n                    checkThread()\n                    expect(3)\n                    assertEquals(42, t)\n                }\n\n                override fun onComplete() {\n                    checkThread()\n                    expect(4)\n                    completed.countDown()\n                }\n\n                override fun onError(t: Throwable?) {\n                    expectUnreached()\n                }\n            })\n            completed.await()\n        }\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/FlowAsObservableTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass FlowAsObservableTest : TestBase() {\n    @Test\n    fun testBasicSuccess() = runTest {\n        expect(1)\n        val observable = flow {\n            expect(3)\n            emit(\"OK\")\n        }.asObservable()\n\n        expect(2)\n        observable.subscribe { value ->\n            expect(4)\n            assertEquals(\"OK\", value)\n        }\n\n        finish(5)\n    }\n\n    @Test\n    fun testBasicFailure() = runTest {\n        expect(1)\n        val observable = flow<Int> {\n            expect(3)\n            throw RuntimeException(\"OK\")\n        }.asObservable()\n\n        expect(2)\n        observable.subscribe({ expectUnreached() }, { error ->\n            expect(4)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testBasicUnsubscribe() = runTest {\n        expect(1)\n        val observable = flow<Int> {\n            expect(3)\n            hang {\n                expect(4)\n            }\n        }.asObservable()\n\n        expect(2)\n        val sub = observable.subscribe({ expectUnreached() }, { expectUnreached() })\n        sub.dispose() // will cancel coroutine\n        finish(5)\n    }\n\n    @Test\n    fun testNotifyOnceOnCancellation() = runTest {\n        val observable =\n            flow {\n                expect(3)\n                emit(\"OK\")\n                hang {\n                    expect(7)\n                }\n            }.asObservable()\n                .doOnNext {\n                    expect(4)\n                    assertEquals(\"OK\", it)\n                }\n                .doOnDispose {\n                    expect(6) // notified once!\n                }\n\n        expect(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            observable.collect {\n                expect(5)\n                assertEquals(\"OK\", it)\n            }\n        }\n\n        yield()\n        job.cancelAndJoin()\n        finish(8)\n    }\n\n    @Test\n    fun testFailingConsumer() = runTest {\n        expect(1)\n        val observable = flow {\n            expect(2)\n            emit(\"OK\")\n            hang {\n                expect(4)\n            }\n\n        }.asObservable()\n\n        try {\n            observable.collect {\n                expect(3)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            finish(5)\n        }\n    }\n\n    @Test\n    fun testNonAtomicStart() = runTest {\n        withContext(Dispatchers.Unconfined) {\n            val observable = flow<Int> {\n                expect(1)\n            }.asObservable()\n\n            val disposable = observable.subscribe({ expectUnreached() }, { expectUnreached() }, { expectUnreached() })\n            disposable.dispose()\n        }\n        finish(2)\n    }\n\n    @Test\n    fun testFlowCancelledFromWithin() = runTest {\n        val observable = flow {\n            expect(1)\n            emit(1)\n            kotlin.coroutines.coroutineContext.cancel()\n            kotlin.coroutines.coroutineContext.ensureActive()\n            expectUnreached()\n        }.asObservable()\n\n        observable.subscribe({ expect(2) }, { expectUnreached() }, { finish(3) })\n    }\n\n    @Test\n    fun testUnconfinedDefaultContext() {\n        expect(1)\n        val thread = Thread.currentThread()\n        fun checkThread() {\n            assertSame(thread, Thread.currentThread())\n        }\n        flowOf(42).asObservable().subscribe(object : Observer<Int> {\n            override fun onSubscribe(d: Disposable) {\n                expect(2)\n            }\n\n            override fun onNext(t: Int) {\n                checkThread()\n                expect(3)\n                assertEquals(42, t)\n            }\n\n            override fun onComplete() {\n                checkThread()\n                expect(4)\n            }\n\n            override fun onError(t: Throwable) {\n                expectUnreached()\n            }\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testConfinedContext() {\n        expect(1)\n        val threadName = \"FlowAsObservableTest.testConfinedContext\"\n        fun checkThread() {\n            val currentThread = Thread.currentThread()\n            assertTrue(currentThread.name.startsWith(threadName), \"Unexpected thread $currentThread\")\n        }\n        val completed = CountDownLatch(1)\n        newSingleThreadContext(threadName).use { dispatcher ->\n            flowOf(42).asObservable(dispatcher).subscribe(object : Observer<Int> {\n                override fun onSubscribe(d: Disposable) {\n                    expect(2)\n                }\n\n                override fun onNext(t: Int) {\n                    checkThread()\n                    expect(3)\n                    assertEquals(42, t)\n                }\n\n                override fun onComplete() {\n                    checkThread()\n                    expect(4)\n                    completed.countDown()\n                }\n\n                override fun onError(e: Throwable) {\n                    expectUnreached()\n                }\n            })\n            completed.await()\n        }\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/FlowableContextTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass FlowableContextTest : TestBase() {\n    private val dispatcher = newSingleThreadContext(\"FlowableContextTest\")\n\n    @After\n    fun tearDown() {\n        dispatcher.close()\n    }\n\n    @Test\n    fun testFlowableCreateAsFlowThread() = runTest {\n        expect(1)\n        val mainThread = Thread.currentThread()\n        val dispatcherThread = withContext(dispatcher) { Thread.currentThread() }\n        assertTrue(dispatcherThread != mainThread)\n        Flowable.create<String>({\n            assertEquals(dispatcherThread, Thread.currentThread())\n            it.onNext(\"OK\")\n            it.onComplete()\n        }, BackpressureStrategy.BUFFER)\n            .asFlow()\n            .flowOn(dispatcher)\n            .collect {\n                expect(2)\n                assertEquals(\"OK\", it)\n                assertEquals(mainThread, Thread.currentThread())\n            }\n        finish(3)\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/FlowableExceptionHandlingTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.exceptions.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass FlowableExceptionHandlingTest : TestBase() {\n\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    private inline fun <reified T : Throwable> handler(expect: Int) = { t: Throwable ->\n        assertTrue(t is UndeliverableException && t.cause is T)\n        expect(expect)\n    }\n\n    private fun cehUnreached() = CoroutineExceptionHandler { _, _ -> expectUnreached() }\n\n    @Test\n    fun testException() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable<Int>(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            throw TestException()\n        }.subscribe({\n            expectUnreached()\n        }, {\n            expect(2) // Reported to onError\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalException() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable<Int>(Dispatchers.Unconfined) {\n            expect(1)\n            throw LinkageError()\n        }.subscribe({\n            expectUnreached()\n        }, {\n            expect(2) // Fatal exceptions are not treated as special\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable<Int>(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            throw TestException()\n        }.publish()\n            .refCount()\n            .subscribe({\n                expectUnreached()\n            }, {\n                expect(2) // Reported to onError\n            })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable<Int>(Dispatchers.Unconfined) {\n            expect(1)\n            throw LinkageError()\n        }.publish()\n            .refCount()\n            .subscribe({\n                expectUnreached()\n            }, {\n                expect(2)\n            })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>(3)) {\n        rxFlowable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.subscribe({\n            expect(2)\n            throw LinkageError()\n        }, { expectUnreached() }) // Fatal exception is rethrown from `onNext` => the subscription is thought to be cancelled\n        finish(4)\n    }\n\n    @Test\n    fun testExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            send(Unit)\n        }.subscribe({\n            expect(2)\n            throw TestException()\n        }, { expect(3) }) // not reported to onError because came from the subscribe itself\n        finish(4)\n    }\n\n    @Test\n    fun testAsynchronousExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            send(Unit)\n        }.publish()\n            .refCount()\n            .subscribe({\n                expect(2)\n                throw RuntimeException()\n            }, { expect(3) })\n        finish(4)\n    }\n\n    @Test\n    fun testAsynchronousFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>(3)) {\n        rxFlowable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.publish()\n            .refCount()\n            .subscribe({\n                expect(2)\n                throw LinkageError()\n            }, { expectUnreached() })\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/FlowableTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass FlowableTest : TestBase() {\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val observable = rxFlowable(currentDispatcher()) {\n            expect(4)\n            send(\"OK\")\n        }\n        expect(2)\n        observable.subscribe { value ->\n            expect(5)\n            assertEquals(\"OK\", value)\n        }\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val observable = rxFlowable<String>(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        observable.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val observable = rxFlowable<String>(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n        }\n        expect(2)\n        val sub = observable.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testNotifyOnceOnCancellation() = runTest {\n        expect(1)\n        val observable =\n            rxFlowable(currentDispatcher()) {\n                expect(5)\n                send(\"OK\")\n                try {\n                    delay(Long.MAX_VALUE)\n                } catch (e: CancellationException) {\n                    expect(11)\n                }\n            }\n            .doOnNext {\n                expect(6)\n                assertEquals(\"OK\", it)\n            }\n            .doOnCancel {\n                expect(10) // notified once!\n            }\n        expect(2)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(3)\n            observable.collect {\n                expect(8)\n                assertEquals(\"OK\", it)\n            }\n        }\n        expect(4)\n        yield() // to observable code\n        expect(7)\n        yield() // to consuming coroutines\n        expect(9)\n        job.cancel()\n        job.join()\n        finish(12)\n    }\n\n    @Test\n    fun testFailingConsumer() = runTest {\n        val pub = rxFlowable(currentDispatcher()) {\n            repeat(3) {\n                expect(it + 1) // expect(1), expect(2) *should* be invoked\n                send(it)\n            }\n        }\n        try {\n            pub.collect {\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            finish(3)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/IntegrationTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass IntegrationTest(\n    private val ctx: Ctx,\n    private val delay: Boolean\n) : TestBase() {\n\n    enum class Ctx {\n        MAIN        { override fun invoke(context: CoroutineContext): CoroutineContext = context.minusKey(Job) },\n        DEFAULT     { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Default },\n        UNCONFINED  { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Unconfined };\n\n        abstract operator fun invoke(context: CoroutineContext): CoroutineContext\n    }\n\n    companion object {\n        @Parameterized.Parameters(name = \"ctx={0}, delay={1}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = Ctx.values().flatMap { ctx ->\n            listOf(false, true).map { delay ->\n                arrayOf(ctx, delay)\n            }\n        }\n    }\n\n    @Test\n    fun testEmpty(): Unit = runBlocking {\n        val observable = rxObservable<String>(ctx(coroutineContext)) {\n            if (delay) delay(1)\n            // does not send anything\n        }\n        assertFailsWith<NoSuchElementException> { observable.awaitFirst() }\n        assertEquals(\"OK\", observable.awaitFirstOrDefault(\"OK\"))\n        assertNull(observable.awaitFirstOrNull())\n        assertEquals(\"ELSE\", observable.awaitFirstOrElse { \"ELSE\" })\n        assertFailsWith<NoSuchElementException> { observable.awaitLast() }\n        assertFailsWith<NoSuchElementException> { observable.awaitSingle() }\n        var cnt = 0\n        observable.collect {\n            cnt++\n        }\n        assertEquals(0, cnt)\n    }\n\n    @Test\n    fun testSingle() = runBlocking {\n        val observable = rxObservable(ctx(coroutineContext)) {\n            if (delay) delay(1)\n            send(\"OK\")\n        }\n        assertEquals(\"OK\", observable.awaitFirst())\n        assertEquals(\"OK\", observable.awaitFirstOrDefault(\"OK\"))\n        assertEquals(\"OK\", observable.awaitFirstOrNull())\n        assertEquals(\"OK\", observable.awaitFirstOrElse { \"ELSE\" })\n        assertEquals(\"OK\", observable.awaitLast())\n        assertEquals(\"OK\", observable.awaitSingle())\n        var cnt = 0\n        observable.collect {\n            assertEquals(\"OK\", it)\n            cnt++\n        }\n        assertEquals(1, cnt)\n    }\n\n    @Test\n    fun testNumbers() = runBlocking<Unit> {\n        val n = 100 * stressTestMultiplier\n        val observable = rxObservable(ctx(coroutineContext)) {\n            for (i in 1..n) {\n                send(i)\n                if (delay) delay(1)\n            }\n        }\n        assertEquals(1, observable.awaitFirst())\n        assertEquals(1, observable.awaitFirstOrDefault(0))\n        assertEquals(1, observable.awaitFirstOrNull())\n        assertEquals(1, observable.awaitFirstOrElse { 0 })\n        assertEquals(n, observable.awaitLast())\n        assertFailsWith<IllegalArgumentException> { observable.awaitSingle() }\n        checkNumbers(n, observable)\n        val channel = observable.toChannel()\n        checkNumbers(n, channel.consumeAsFlow().asObservable(ctx(coroutineContext)))\n        channel.cancel()\n    }\n\n    @Test\n    fun testCancelWithoutValue() = runTest {\n        val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {\n            rxObservable<String> {\n                hang {  }\n            }.awaitFirst()\n        }\n\n        job.cancel()\n        job.join()\n    }\n\n    @Test\n    fun testEmptySingle() = runTest(unhandled = listOf({e -> e is NoSuchElementException})) {\n        expect(1)\n        val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {\n            rxObservable<String> {\n                yield()\n                expect(2)\n                // Nothing to emit\n            }.awaitFirst()\n        }\n\n        job.join()\n        finish(3)\n    }\n\n    @Test\n    fun testObservableWithTimeout() = runTest {\n        val observable = rxObservable<Int> {\n            expect(2)\n            withTimeout(1) { delay(100) }\n        }\n        try {\n            expect(1)\n            observable.awaitFirstOrNull()\n        } catch (e: CancellationException) {\n            expect(3)\n        }\n        finish(4)\n    }\n\n    private suspend fun checkNumbers(n: Int, observable: Observable<Int>) {\n        var last = 0\n        observable.collect {\n            assertEquals(++last, it)\n        }\n        assertEquals(n, last)\n    }\n\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/IterableFlowAsFlowableTckTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport io.reactivex.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.*\nimport org.reactivestreams.*\nimport org.reactivestreams.tck.*\n\nclass IterableFlowAsFlowableTckTest : PublisherVerification<Long>(TestEnvironment()) {\n\n    private fun generate(num: Long): Array<Long> {\n        return Array(if (num >= Integer.MAX_VALUE) 1000000 else num.toInt()) { it.toLong() }\n    }\n\n    override fun createPublisher(elements: Long): Flowable<Long> {\n        return generate(elements).asIterable().asFlow().asFlowable()\n    }\n\n    override fun createFailedPublisher(): Publisher<Long>? = null\n\n    @Ignore\n    override fun required_spec309_requestZeroMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() {\n        //\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/LeakedExceptionTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport io.reactivex.exceptions.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.Test\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\nimport kotlin.test.*\n\n// Check that exception is not leaked to the global exception handler\nclass LeakedExceptionTest : TestBase() {\n\n    private val handler: (Throwable) -> Unit =\n        { assertTrue { it is UndeliverableException && it.cause is TestException } }\n\n    @Test\n    fun testSingle() = withExceptionHandler(handler) {\n        withFixedThreadPool(4) { dispatcher ->\n            val flow = rxSingle<Unit>(dispatcher) { throw TestException() }.toFlowable().asFlow()\n            runBlocking {\n                repeat(10000) {\n                    combine(flow, flow) { _, _ -> Unit }\n                        .catch {}\n                        .collect {}\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testObservable() = withExceptionHandler(handler) {\n        withFixedThreadPool(4) { dispatcher ->\n            val flow = rxObservable<Unit>(dispatcher) { throw TestException() }\n                .toFlowable(BackpressureStrategy.BUFFER)\n                .asFlow()\n            runBlocking {\n                repeat(10000) {\n                    combine(flow, flow) { _, _ -> Unit }\n                        .catch {}\n                        .collect {}\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testFlowable() = withExceptionHandler(handler) {\n        withFixedThreadPool(4) { dispatcher ->\n            val flow = rxFlowable<Unit>(dispatcher) { throw TestException() }.asFlow()\n            runBlocking {\n                repeat(10000) {\n                    combine(flow, flow) { _, _ -> Unit }\n                        .catch {}\n                        .collect {}\n                }\n            }\n        }\n    }\n\n    /**\n     * This test doesn't test much and was added to display a problem with straighforward use of\n     * [withExceptionHandler].\n     *\n     * If one was to remove `dispatcher` and launch `rxFlowable` with an empty coroutine context,\n     * this test would fail fairly often, while other tests were also vulnerable, but the problem is\n     * much more difficult to reproduce. Thus, this test is a justification for adding `dispatcher`\n     * to other tests.\n     *\n     * See the commit that introduced this test for a better explanation.\n     */\n    @Test\n    fun testResettingExceptionHandler() = withExceptionHandler(handler) {\n        withFixedThreadPool(4) { dispatcher ->\n            val flow = rxFlowable<Unit>(dispatcher) {\n                if ((0..1).random() == 0) {\n                    Thread.sleep(100)\n                }\n                throw TestException()\n            }.asFlow()\n            runBlocking {\n                combine(flow, flow) { _, _ -> Unit }\n                    .catch {}\n                    .collect {}\n            }\n        }\n    }\n\n    /**\n     * Run in a thread pool, then wait for all the tasks to finish.\n     */\n    private fun withFixedThreadPool(numberOfThreads: Int, block: (CoroutineDispatcher) -> Unit) {\n        val pool = Executors.newFixedThreadPool(numberOfThreads)\n        val dispatcher = pool.asCoroutineDispatcher()\n        block(dispatcher)\n        pool.shutdown()\n        while (!pool.awaitTermination(10, TimeUnit.SECONDS)) {\n            /* deliberately empty */\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/MaybeTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport io.reactivex.exceptions.*\nimport io.reactivex.internal.functions.Functions.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass MaybeTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            \"OK\"\n        }\n        expect(2)\n        maybe.subscribe { value ->\n            expect(5)\n            assertEquals(\"OK\", value)\n        }\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicEmpty() = runBlocking {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            null\n        }\n        expect(2)\n        maybe.subscribe (emptyConsumer(), ON_ERROR_MISSING, {\n            expect(5)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        maybe.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n        }\n        expect(2)\n        // nothing is called on a disposed rx2 maybe\n        val sub = maybe.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testMaybeNoWait() {\n        val maybe = rxMaybe {\n            \"OK\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testMaybeAwait() = runBlocking {\n        assertEquals(\"OK\", Maybe.just(\"O\").awaitSingleOrNull() + \"K\")\n        assertEquals(\"OK\", Maybe.just(\"O\").awaitSingle() + \"K\")\n    }\n\n    @Test\n    fun testMaybeAwaitForNull(): Unit = runBlocking {\n        assertNull(Maybe.empty<String>().awaitSingleOrNull())\n        assertFailsWith<NoSuchElementException> { Maybe.empty<String>().awaitSingle() }\n    }\n\n    /** Tests that calls to [awaitSingleOrNull] throw [CancellationException] and dispose of the subscription when their\n     * [Job] is cancelled. */\n    @Test\n    fun testMaybeAwaitCancellation() = runTest {\n        expect(1)\n        val maybe = MaybeSource<Int> { s ->\n            s.onSubscribe(object: Disposable {\n                override fun dispose() { expect(4) }\n                override fun isDisposed(): Boolean { expectUnreached(); return false }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                maybe.awaitSingleOrNull()\n            } catch (e: CancellationException) {\n                expect(5)\n                throw e\n            }\n        }\n        expect(3)\n        job.cancelAndJoin()\n        finish(6)\n    }\n\n    @Test\n    fun testMaybeEmitAndAwait() {\n        val maybe = rxMaybe {\n            Maybe.just(\"O\").awaitSingleOrNull() + \"K\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testMaybeWithDelay() {\n        val maybe = rxMaybe {\n            Observable.timer(50, TimeUnit.MILLISECONDS).map { \"O\" }.awaitSingle() + \"K\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testMaybeException() {\n        val maybe = rxMaybe {\n            Observable.just(\"O\", \"K\").awaitSingle() + \"K\"\n        }\n\n        checkErroneous(maybe) {\n            assert(it is IllegalArgumentException)\n        }\n    }\n\n    @Test\n    fun testAwaitFirst() {\n        val maybe = rxMaybe {\n            Observable.just(\"O\", \"#\").awaitFirst() + \"K\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitLast() {\n        val maybe = rxMaybe {\n            Observable.just(\"#\", \"O\").awaitLast() + \"K\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromObservable() {\n        val maybe = rxMaybe {\n            try {\n                Observable.error<String>(RuntimeException(\"O\")).awaitFirst()\n            } catch (e: RuntimeException) {\n                Observable.just(e.message!!).awaitLast() + \"K\"\n            }\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromCoroutine() {\n        val maybe = rxMaybe<String> {\n            throw IllegalStateException(Observable.just(\"O\").awaitSingle() + \"K\")\n        }\n\n        checkErroneous(maybe) {\n            assert(it is IllegalStateException)\n            assertEquals(\"OK\", it.message)\n        }\n    }\n\n    @Test\n    fun testCancelledConsumer() = runTest {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            try {\n                delay(Long.MAX_VALUE)\n            } catch (e: CancellationException) {\n                expect(6)\n            }\n            42\n        }\n        expect(2)\n        val timeout = withTimeoutOrNull(100) {\n            expect(3)\n            maybe.collect {\n                expectUnreached()\n            }\n            expectUnreached()\n        }\n        assertNull(timeout)\n        expect(5)\n        yield() // must cancel code inside maybe!!!\n        finish(7)\n    }\n\n    /** Tests the simple scenario where the Maybe doesn't output a value. */\n    @Test\n    fun testMaybeCollectEmpty() = runTest {\n        expect(1)\n        Maybe.empty<Int>().collect {\n            expectUnreached()\n        }\n        finish(2)\n    }\n\n    /** Tests the simple scenario where the Maybe doesn't output a value. */\n    @Test\n    fun testMaybeCollectSingle() = runTest {\n        expect(1)\n        Maybe.just(\"OK\").collect {\n            assertEquals(\"OK\", it)\n            expect(2)\n        }\n        finish(3)\n    }\n\n    /** Tests the behavior of [collect] when the Maybe raises an error. */\n    @Test\n    fun testMaybeCollectThrowingMaybe() = runTest {\n        expect(1)\n        try {\n            Maybe.error<Int>(TestException()).collect {\n                expectUnreached()\n            }\n        } catch (e: TestException) {\n            expect(2)\n        }\n        finish(3)\n    }\n\n    /** Tests the behavior of [collect] when the action throws. */\n    @Test\n    fun testMaybeCollectThrowingAction() = runTest {\n        expect(1)\n        try {\n            Maybe.just(\"OK\").collect {\n                expect(2)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            expect(3)\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testSuppressedException() = runTest {\n        val maybe = rxMaybe(currentDispatcher()) {\n            launch(start = CoroutineStart.ATOMIC) {\n                throw TestException() // child coroutine fails\n            }\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException2() // but parent throws another exception while cleaning up\n            }\n        }\n        try {\n            maybe.awaitSingleOrNull()\n            expectUnreached()\n        } catch (e: TestException) {\n            assertIs<TestException2>(e.suppressed[0])\n        }\n    }\n\n    @Test\n    fun testUnhandledException() = runTest {\n        expect(1)\n        var disposable: Disposable? = null\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is TestException)\n            expect(5)\n        }\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException() // would not be able to handle it since mono is disposed\n            }\n        }\n        withExceptionHandler(handler) {\n            maybe.subscribe(object : MaybeObserver<Unit> {\n                override fun onSubscribe(d: Disposable) {\n                    expect(2)\n                    disposable = d\n                }\n\n                override fun onComplete() {\n                    expectUnreached()\n                }\n\n                override fun onSuccess(t: Unit) {\n                    expectUnreached()\n                }\n\n                override fun onError(t: Throwable) {\n                    expectUnreached()\n                }\n            })\n            expect(3)\n            yield() // run coroutine\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSubscribe() = runTest {\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is LinkageError)\n            expect(2)\n        }\n\n        withExceptionHandler(handler) {\n            rxMaybe(Dispatchers.Unconfined) {\n                expect(1)\n                42\n            }.subscribe { throw LinkageError() }\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSingle() = runTest {\n        rxMaybe(Dispatchers.Unconfined) {\n            throw LinkageError()\n        }.subscribe({ expectUnreached()  }, { expect(1); assertIs<LinkageError>(it) })\n        finish(2)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ObservableAsFlowTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.Observable\nimport io.reactivex.ObservableSource\nimport io.reactivex.Observer\nimport io.reactivex.disposables.Disposables\nimport io.reactivex.subjects.PublishSubject\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.testing.flow.*\nimport kotlin.test.*\n\nclass ObservableAsFlowTest : TestBase() {\n    @Test\n    fun testCancellation() = runTest {\n        var onNext = 0\n        var onCancelled = 0\n        var onError = 0\n\n        val source = rxObservable(currentDispatcher()) {\n            coroutineContext[Job]?.invokeOnCompletion {\n                if (it is CancellationException) ++onCancelled\n            }\n\n            repeat(100) {\n                send(it)\n            }\n        }\n\n        source.asFlow().launchIn(CoroutineScope(Dispatchers.Unconfined)) {\n            onEach {\n                ++onNext\n                throw RuntimeException()\n            }\n            catch<Throwable> {\n                ++onError\n            }\n        }.join()\n\n\n        assertEquals(1, onNext)\n        assertEquals(1, onError)\n        assertEquals(1, onCancelled)\n    }\n\n    @Test\n    fun testImmediateCollection() {\n        val source = PublishSubject.create<Int>()\n        val flow = source.asFlow()\n        GlobalScope.launch(Dispatchers.Unconfined) {\n            expect(1)\n            flow.collect { expect(it) }\n            expect(6)\n        }\n        expect(2)\n        source.onNext(3)\n        expect(4)\n        source.onNext(5)\n        source.onComplete()\n        finish(7)\n    }\n\n    @Test\n    fun testOnErrorCancellation() {\n        val source = PublishSubject.create<Int>()\n        val flow = source.asFlow()\n        val exception = RuntimeException()\n        GlobalScope.launch(Dispatchers.Unconfined) {\n            try {\n                expect(1)\n                flow.collect { expect(it) }\n                expectUnreached()\n            }\n            catch (e: Exception) {\n                assertSame(exception, e.cause)\n                expect(5)\n            }\n            expect(6)\n        }\n        expect(2)\n        source.onNext(3)\n        expect(4)\n        source.onError(exception)\n        finish(7)\n    }\n\n    @Test\n    fun testUnsubscribeOnCollectionException() {\n        val source = PublishSubject.create<Int>()\n        val flow = source.asFlow()\n        val exception = RuntimeException()\n        GlobalScope.launch(Dispatchers.Unconfined) {\n            try {\n                expect(1)\n                flow.collect {\n                    expect(it)\n                    if (it == 3) throw exception\n                }\n                expectUnreached()\n            }\n            catch (e: Exception) {\n                assertSame(exception, e.cause)\n                expect(4)\n            }\n            expect(5)\n        }\n        expect(2)\n        assertTrue(source.hasObservers())\n        source.onNext(3)\n        assertFalse(source.hasObservers())\n        finish(6)\n    }\n\n    @Test\n    fun testLateOnSubscribe() {\n        var observer: Observer<in Int>? = null\n        val source = ObservableSource<Int> { observer = it }\n        val flow = source.asFlow()\n        assertNull(observer)\n        val job = GlobalScope.launch(Dispatchers.Unconfined) {\n            expect(1)\n            flow.collect { expectUnreached() }\n            expectUnreached()\n        }\n        expect(2)\n        assertNotNull(observer)\n        job.cancel()\n        val disposable = Disposables.empty()\n        observer!!.onSubscribe(disposable)\n        assertTrue(disposable.isDisposed)\n        finish(3)\n    }\n\n    @Test\n    fun testBufferUnlimited() = runTest {\n        val source = rxObservable(currentDispatcher()) {\n            expect(1); send(10)\n            expect(2); send(11)\n            expect(3); send(12)\n            expect(4); send(13)\n            expect(5); send(14)\n            expect(6); send(15)\n            expect(7); send(16)\n            expect(8); send(17)\n            expect(9)\n        }\n        source.asFlow().buffer(Channel.UNLIMITED).collect { expect(it) }\n        finish(18)\n    }\n\n    @Test\n    fun testConflated() = runTest {\n        val source = Observable.range(1, 5)\n        val list = source.asFlow().conflate().toList()\n        assertEquals(listOf(1, 5), list)\n    }\n\n    @Test\n    fun testLongRange() = runTest {\n        val source = Observable.range(1, 10_000)\n        val count = source.asFlow().count()\n        assertEquals(10_000, count)\n    }\n\n    @Test\n    fun testProduce() = runTest {\n        val source = Observable.range(0, 10)\n        val flow = source.asFlow()\n        check((0..9).toList(), flow.produceIn(this))\n        check((0..9).toList(), flow.buffer(Channel.UNLIMITED).produceIn(this))\n        check((0..9).toList(), flow.buffer(2).produceIn(this))\n        check((0..9).toList(), flow.buffer(0).produceIn(this))\n        check(listOf(0, 9), flow.conflate().produceIn(this))\n    }\n\n    private suspend fun check(expected: List<Int>, channel: ReceiveChannel<Int>) {\n        val result = ArrayList<Int>(10)\n        channel.consumeEach { result.add(it) }\n        assertEquals(expected, result)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ObservableCollectTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass ObservableCollectTest: TestBase() {\n\n    /** Tests the behavior of [collect] when the publisher raises an error. */\n    @Test\n    fun testObservableCollectThrowingObservable() = runTest {\n        expect(1)\n        var sum = 0\n        try {\n            rxObservable {\n                for (i in 0..100) {\n                    send(i)\n                }\n                throw TestException()\n            }.collect {\n                sum += it\n            }\n        } catch (e: TestException) {\n            assertTrue(sum > 0)\n            finish(2)\n        }\n    }\n\n    /** Tests the behavior of [collect] when the action throws. */\n    @Test\n    fun testObservableCollectThrowingAction() = runTest {\n        expect(1)\n        var sum = 0\n        val expectedSum = 5\n        try {\n            var disposed = false\n            ObservableSource<Int> { observer ->\n                launch(Dispatchers.Default) {\n                    observer.onSubscribe(object : Disposable {\n                        override fun dispose() {\n                            disposed = true\n                            expect(expectedSum + 2)\n                        }\n\n                        override fun isDisposed(): Boolean = disposed\n                    })\n                    while (!disposed) {\n                        observer.onNext(1)\n                    }\n                }\n            }.collect {\n                expect(sum + 2)\n                sum += it\n                if (sum == expectedSum) {\n                    throw TestException()\n                }\n            }\n        } catch (e: TestException) {\n            assertEquals(expectedSum, sum)\n            finish(expectedSum + 3)\n        }\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ObservableCompletionStressTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.*\nimport kotlin.coroutines.*\n\nclass ObservableCompletionStressTest : TestBase() {\n    private val N_REPEATS = 10_000 * stressTestMultiplier\n\n    private fun range(context: CoroutineContext, start: Int, count: Int) = rxObservable(context) {\n        for (x in start until start + count) send(x)\n    }\n\n    @Test\n    fun testCompletion() {\n        val rnd = Random()\n        repeat(N_REPEATS) {\n            val count = rnd.nextInt(5)\n            runBlocking {\n                withTimeout(5000) {\n                    var received = 0\n                    range(Dispatchers.Default, 1, count).collect { x ->\n                        received++\n                        if (x != received) error(\"$x != $received\")\n                    }\n                    if (received != count) error(\"$received != $count\")\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ObservableExceptionHandlingTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.exceptions.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass ObservableExceptionHandlingTest : TestBase() {\n\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    private inline fun <reified T : Throwable> handler(expect: Int) = { t: Throwable ->\n        assertTrue(t is UndeliverableException && t.cause is T, \"$t\")\n        expect(expect)\n    }\n\n    private fun cehUnreached() = CoroutineExceptionHandler { _, _ -> expectUnreached() }\n\n    @Test\n    fun testException() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable<Int>(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            throw TestException()\n        }.subscribe({\n            expectUnreached()\n        }, {\n            expect(2) // Reported to onError\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalException() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable<Int>(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            throw LinkageError()\n        }.subscribe({\n            expectUnreached()\n        }, {\n            expect(2)\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable<Int>(Dispatchers.Unconfined) {\n            expect(1)\n            throw TestException()\n        }.publish()\n            .refCount()\n            .subscribe({\n                expectUnreached()\n            }, {\n                expect(2) // Reported to onError\n            })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable<Int>(Dispatchers.Unconfined) {\n            expect(1)\n            throw LinkageError()\n        }.publish()\n            .refCount()\n            .subscribe({\n                expectUnreached()\n            }, {\n                expect(2) // Fatal exceptions are not treated in a special manner\n            })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>(3)) {\n        val latch = CountDownLatch(1)\n        rxObservable(Dispatchers.Unconfined) {\n            expect(1)\n            val result = trySend(Unit)\n            val exception = result.exceptionOrNull()\n            assertIs<UndeliverableException>(exception)\n            assertIs<LinkageError>(exception.cause)\n            assertTrue(isClosedForSend)\n            expect(4)\n            latch.countDown()\n        }.subscribe({\n            expect(2)\n            throw LinkageError()\n        }, { expectUnreached() }) // Unreached because RxJava bubbles up fatal exceptions, causing `onNext` to throw.\n        latch.await()\n        finish(5)\n    }\n\n    @Test\n    fun testExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.subscribe({\n            expect(2)\n            throw TestException()\n        }, { expect(3) })\n        finish(4)\n    }\n\n    @Test\n    fun testAsynchronousExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.publish()\n            .refCount()\n            .subscribe({\n                expect(2)\n                throw RuntimeException()\n            }, { expect(3) })\n        finish(4)\n    }\n\n    @Test\n    fun testAsynchronousFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>(3)) {\n        rxObservable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.publish()\n            .refCount()\n            .subscribe({\n                expect(2)\n                throw LinkageError()\n            }, { expectUnreached() }) // Unreached because RxJava bubbles up fatal exceptions, causing `onNext` to throw.\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ObservableMultiTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.Test\nimport java.io.*\nimport kotlin.test.*\n\n/**\n * Test emitting multiple values with [rxObservable].\n */\nclass ObservableMultiTest : TestBase() {\n    @Test\n    fun testNumbers() {\n        val n = 100 * stressTestMultiplier\n        val observable = rxObservable {\n            repeat(n) { send(it) }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals((0 until n).toList(), list)\n        }\n    }\n\n\n    @Test\n    fun testConcurrentStress() {\n        val n = 10_000 * stressTestMultiplier\n        val observable = rxObservable {\n            newCoroutineContext(coroutineContext)\n            // concurrent emitters (many coroutines)\n            val jobs = List(n) {\n                // launch\n                launch {\n                    val i = it\n                    send(i)\n                }\n            }\n            jobs.forEach { it.join() }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals(n, list.size)\n            assertEquals((0 until n).toList(), list.sorted())\n        }\n    }\n\n    @Test\n    fun testConcurrentStressOnSend() {\n        val n = 10_000 * stressTestMultiplier\n        val observable = rxObservable<Int> {\n            newCoroutineContext(coroutineContext)\n            // concurrent emitters (many coroutines)\n            val jobs = List(n) {\n                // launch\n                launch(Dispatchers.Default) {\n                    val i = it\n                    select<Unit> {\n                        onSend(i) {}\n                    }\n                }\n            }\n            jobs.forEach { it.join() }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals(n, list.size)\n            assertEquals((0 until n).toList(), list.sorted())\n        }\n    }\n\n    @Test\n    fun testIteratorResendUnconfined() {\n        val n = 10_000 * stressTestMultiplier\n        val observable = rxObservable(Dispatchers.Unconfined) {\n            Observable.range(0, n).collect { send(it) }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals((0 until n).toList(), list)\n        }\n    }\n\n    @Test\n    fun testIteratorResendPool() {\n        val n = 10_000 * stressTestMultiplier\n        val observable = rxObservable {\n            Observable.range(0, n).collect { send(it) }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals((0 until n).toList(), list)\n        }\n    }\n\n    @Test\n    fun testSendAndCrash() {\n        val observable = rxObservable {\n            send(\"O\")\n            throw IOException(\"K\")\n        }\n        val single = rxSingle {\n            var result = \"\"\n            try {\n                observable.collect { result += it }\n            } catch(e: IOException) {\n                result += e.message\n            }\n            result\n        }\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ObservableSingleTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass ObservableSingleTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testSingleNoWait() {\n        val observable = rxObservable {\n            send(\"OK\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleAwait() = runBlocking {\n        assertEquals(\"OK\", Observable.just(\"O\").awaitSingle() + \"K\")\n    }\n\n    @Test\n    fun testSingleEmitAndAwait() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\").awaitSingle() + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleWithDelay() {\n        val observable = rxObservable {\n            send(Observable.timer(50, TimeUnit.MILLISECONDS).map { \"O\" }.awaitSingle() + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleException() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\", \"K\").awaitSingle() + \"K\")\n        }\n\n        checkErroneous(observable) {\n            assertIs<IllegalArgumentException>(it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirst() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\", \"#\").awaitFirst() + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrDefault() {\n        val observable = rxObservable {\n            send(Observable.empty<String>().awaitFirstOrDefault(\"O\") + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrDefaultWithValues() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\", \"#\").awaitFirstOrDefault(\"!\") + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrNull() {\n        val observable = rxObservable {\n            send(Observable.empty<String>().awaitFirstOrNull() ?: \"OK\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrNullWithValues() {\n        val observable = rxObservable {\n            send((Observable.just(\"O\", \"#\").awaitFirstOrNull() ?: \"!\") + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrElse() {\n        val observable = rxObservable {\n            send(Observable.empty<String>().awaitFirstOrElse { \"O\" } + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrElseWithValues() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\", \"#\").awaitFirstOrElse { \"!\" } + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitLast() {\n        val observable = rxObservable {\n            send(Observable.just(\"#\", \"O\").awaitLast() + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    /** Tests that calls to [awaitFirst] (and, thus, the other methods) throw [CancellationException] and dispose of\n     * the subscription when their [Job] is cancelled. */\n    @Test\n    fun testAwaitCancellation() = runTest {\n        expect(1)\n        val observable = ObservableSource<Int> { s ->\n            s.onSubscribe(object: Disposable {\n                override fun dispose() { expect(4) }\n                override fun isDisposed(): Boolean { expectUnreached(); return false }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                observable.awaitFirst()\n            } catch (e: CancellationException) {\n                expect(5)\n                throw e\n            }\n        }\n        expect(3)\n        job.cancelAndJoin()\n        finish(6)\n    }\n\n\n    @Test\n    fun testExceptionFromObservable() {\n        val observable = rxObservable {\n            try {\n                send(Observable.error<String>(RuntimeException(\"O\")).awaitFirst())\n            } catch (e: RuntimeException) {\n                send(Observable.just(e.message!!).awaitLast() + \"K\")\n            }\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromCoroutine() {\n        val observable = rxObservable<String> {\n            throw IllegalStateException(Observable.just(\"O\").awaitSingle() + \"K\")\n        }\n\n        checkErroneous(observable) {\n            assertIs<IllegalStateException>(it)\n            assertEquals(\"OK\", it.message)\n        }\n    }\n\n    @Test\n    fun testObservableIteration() {\n        val observable = rxObservable {\n            var result = \"\"\n            Observable.just(\"O\", \"K\").collect { result += it }\n            send(result)\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testObservableIterationFailure() {\n        val observable = rxObservable {\n            try {\n                Observable.error<String>(RuntimeException(\"OK\")).collect { fail(\"Should not be here\") }\n                send(\"Fail\")\n            } catch (e: RuntimeException) {\n                send(e.message!!)\n            }\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ObservableSourceAsFlowStressTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.*\nimport java.util.concurrent.*\n\nclass ObservableSourceAsFlowStressTest : TestBase() {\n\n    private val iterations = 100 * stressTestMultiplierSqrt\n\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testAsFlowCancellation() = runTest {\n        repeat(iterations) {\n            val latch = Channel<Unit>(1)\n            var i = 0\n            val observable = Observable.interval(100L, TimeUnit.MICROSECONDS)\n                .doOnNext {  if (++i > 100) latch.trySend(Unit) }\n            val job = observable.asFlow().launchIn(CoroutineScope(Dispatchers.Default))\n            latch.receive()\n            job.cancelAndJoin()\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ObservableSubscriptionSelectTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.Test\nimport kotlin.onSuccess\nimport kotlin.test.*\n\nclass ObservableSubscriptionSelectTest : TestBase() {\n    @Test\n    fun testSelect() = runTest {\n        // source with n ints\n        val n = 1000 * stressTestMultiplier\n        val source = rxObservable { repeat(n) { send(it) } }\n        var a = 0\n        var b = 0\n        // open two subs\n        val channelA = source.toChannel()\n        val channelB = source.toChannel()\n        loop@ while (true) {\n            val done: Int = select {\n                channelA.onReceiveCatching { result ->\n                    result.onSuccess { assertEquals(a++, it) }\n                    if (result.isSuccess) 1 else 0\n                }\n                channelB.onReceiveCatching { result ->\n                    result.onSuccess { assertEquals(b++, it) }\n                    if (result.isSuccess) 2 else 0\n                }\n            }\n            when (done) {\n                0 -> break@loop\n                1 -> {\n                    val r = channelB.receiveCatching().getOrNull()\n                    if (r != null) assertEquals(b++, r)\n                }\n                2 -> {\n                    val r = channelA.receiveCatching().getOrNull()\n                    if (r != null) assertEquals(a++, r)\n                }\n            }\n        }\n        channelA.cancel()\n        channelB.cancel()\n        // should receive one of them fully\n        assertTrue(a == n || b == n)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/ObservableTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport io.reactivex.plugins.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass ObservableTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val observable = rxObservable(currentDispatcher()) {\n            expect(4)\n            send(\"OK\")\n        }\n        expect(2)\n        observable.subscribe { value ->\n            expect(5)\n            assertEquals(\"OK\", value)\n        }\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val observable = rxObservable<String>(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        observable.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val observable = rxObservable<String>(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n        }\n        expect(2)\n        val sub = observable.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testNotifyOnceOnCancellation() = runTest {\n        expect(1)\n        val observable =\n            rxObservable(currentDispatcher()) {\n                expect(5)\n                send(\"OK\")\n                try {\n                    delay(Long.MAX_VALUE)\n                } catch (e: CancellationException) {\n                    expect(11)\n                }\n            }\n            .doOnNext {\n                expect(6)\n                assertEquals(\"OK\", it)\n            }\n            .doOnDispose {\n                expect(10) // notified once!\n            }\n        expect(2)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(3)\n            observable.collect {\n                expect(8)\n                assertEquals(\"OK\", it)\n            }\n        }\n        expect(4)\n        yield() // to observable code\n        expect(7)\n        yield() // to consuming coroutines\n        expect(9)\n        job.cancel()\n        job.join()\n        finish(12)\n    }\n\n    @Test\n    fun testFailingConsumer() = runTest {\n        expect(1)\n        val pub = rxObservable(currentDispatcher()) {\n            expect(2)\n            send(\"OK\")\n            try {\n                delay(Long.MAX_VALUE)\n            } catch (e: CancellationException) {\n                finish(5)\n            }\n        }\n        try {\n            pub.collect {\n                expect(3)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            expect(4)\n        }\n    }\n\n    @Test\n    fun testExceptionAfterCancellation() {\n        // Test that no exceptions were reported to the global EH (it will fail the test if so)\n        val handler = { e: Throwable ->\n            assertFalse(e is CancellationException)\n        }\n        withExceptionHandler(handler) {\n            RxJavaPlugins.setErrorHandler {\n                require(it !is CancellationException)\n            }\n            Observable\n                .interval(1, TimeUnit.MILLISECONDS)\n                .take(1000)\n                .switchMapSingle {\n                    rxSingle {\n                        timeBomb().await()\n                    }\n                }\n                .blockingSubscribe({}, {})\n        }\n    }\n\n    private fun timeBomb() = Single.timer(1, TimeUnit.MILLISECONDS).doOnSuccess { throw TestException() }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/SchedulerStressTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.concurrent.*\n\nclass SchedulerStressTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxCachedThreadScheduler-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    /**\n     * Test that we don't get an OOM if we schedule many jobs at once.\n     * It's expected that if you don't dispose you'd see an OOM error.\n     */\n    @Test\n    fun testSchedulerDisposed(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableDisposed(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerDisposed(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        val worker = scheduler.createWorker()\n        testRunnableDisposed(worker::schedule)\n    }\n\n    private suspend fun testRunnableDisposed(block: RxSchedulerBlockNoDelay) {\n        val n = 2000 * stressTestMultiplier\n        repeat(n) {\n            val a = ByteArray(1000000) //1MB\n            val disposable = block(Runnable {\n                keepMe(a)\n                expectUnreached()\n            })\n            disposable.dispose()\n            yield() // allow the scheduled task to observe that it was disposed\n        }\n    }\n\n    /**\n     * Test function that holds a reference. Used for testing OOM situations\n     */\n    private fun keepMe(a: ByteArray) {\n        Thread.sleep(a.size / (a.size + 1) + 10L)\n    }\n\n    /**\n     * Test that we don't get an OOM if we schedule many delayed jobs at once. It's expected that if you don't dispose that you'd\n     * see a OOM error.\n     */\n    @Test\n    fun testSchedulerDisposedDuringDelay(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableDisposedDuringDelay(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerDisposedDuringDelay(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        val worker = scheduler.createWorker()\n        testRunnableDisposedDuringDelay(worker::schedule)\n    }\n\n    private fun testRunnableDisposedDuringDelay(block: RxSchedulerBlockWithDelay) {\n        val n = 2000 * stressTestMultiplier\n        repeat(n) {\n            val a = ByteArray(1000000) //1MB\n            val delayMillis: Long = 10\n            val disposable = block(Runnable {\n                keepMe(a)\n                expectUnreached()\n            }, delayMillis, TimeUnit.MILLISECONDS)\n            disposable.dispose()\n        }\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/SchedulerTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport io.reactivex.plugins.*\nimport io.reactivex.schedulers.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport org.junit.*\nimport org.junit.Test\nimport java.lang.Runnable\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.AtomicReference\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass SchedulerTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxCachedThreadScheduler-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testIoScheduler(): Unit = runTest {\n        expect(1)\n        val mainThread = Thread.currentThread()\n        withContext(Schedulers.io().asCoroutineDispatcher()) {\n            val t1 = Thread.currentThread()\n            assertNotSame(t1, mainThread)\n            expect(2)\n            delay(100)\n            val t2 = Thread.currentThread()\n            assertNotSame(t2, mainThread)\n            expect(3)\n        }\n        finish(4)\n    }\n\n    /** Tests [toString] implementations of [CoroutineDispatcher.asScheduler] and its [Scheduler.Worker]. */\n    @Test\n    fun testSchedulerToString() {\n        val name = \"Dispatchers.Default\"\n        val scheduler = Dispatchers.Default.asScheduler()\n        assertContains(scheduler.toString(), name)\n        val worker = scheduler.createWorker()\n        val activeWorkerName = worker.toString()\n        assertContains(worker.toString(), name)\n        worker.dispose()\n        val disposedWorkerName = worker.toString()\n        assertNotEquals(activeWorkerName, disposedWorkerName)\n    }\n\n    private fun runSchedulerTest(nThreads: Int = 1, action: (Scheduler) -> Unit) {\n        val future = CompletableFuture<Unit>()\n        try {\n            newFixedThreadPoolContext(nThreads, \"test\").use { dispatcher ->\n                RxJavaPlugins.setErrorHandler {\n                    if (!future.completeExceptionally(it)) {\n                        handleUndeliverableException(it, dispatcher)\n                    }\n                }\n                action(dispatcher.asScheduler())\n            }\n        } finally {\n            RxJavaPlugins.setErrorHandler(null)\n        }\n        future.complete(Unit)\n        future.getNow(Unit) // rethrow any encountered errors\n    }\n\n    private fun ensureSeparateThread(schedule: (Runnable, Long, TimeUnit) -> Unit, scheduleNoDelay: (Runnable) -> Unit) {\n        val mainThread = Thread.currentThread()\n        val cdl1 = CountDownLatch(1)\n        val cdl2 = CountDownLatch(1)\n        expect(1)\n        val thread = AtomicReference<Thread?>(null)\n        fun checkThread() {\n            val current = Thread.currentThread()\n            thread.getAndSet(current)?.let { assertEquals(it, current) }\n        }\n        schedule({\n            assertNotSame(mainThread, Thread.currentThread())\n            checkThread()\n            cdl2.countDown()\n        }, 300, TimeUnit.MILLISECONDS)\n        scheduleNoDelay {\n            expect(2)\n            checkThread()\n            assertNotSame(mainThread, Thread.currentThread())\n            cdl1.countDown()\n        }\n        cdl1.await()\n        cdl2.await()\n        finish(3)\n    }\n\n    /**\n     * Tests [Scheduler.scheduleDirect] for [CoroutineDispatcher.asScheduler] on a single-threaded dispatcher.\n     */\n    @Test\n    fun testSingleThreadedDispatcherDirect(): Unit = runSchedulerTest(1) {\n        ensureSeparateThread(it::scheduleDirect, it::scheduleDirect)\n    }\n\n    /**\n     * Tests [Scheduler.Worker.schedule] for [CoroutineDispatcher.asScheduler] running its tasks on the correct thread.\n     */\n    @Test\n    fun testSingleThreadedWorker(): Unit = runSchedulerTest(1) {\n        val worker = it.createWorker()\n        ensureSeparateThread(worker::schedule, worker::schedule)\n    }\n\n    private fun checkCancelling(schedule: (Runnable, Long, TimeUnit) -> Disposable) {\n        // cancel the task before it has a chance to run.\n        val handle1 = schedule({\n            throw IllegalStateException(\"should have been successfully cancelled\")\n        }, 10_000, TimeUnit.MILLISECONDS)\n        handle1.dispose()\n        // cancel the task after it started running.\n        val cdl1 = CountDownLatch(1)\n        val cdl2 = CountDownLatch(1)\n        val handle2 = schedule({\n            cdl1.countDown()\n            cdl2.await()\n            if (Thread.interrupted())\n                throw IllegalStateException(\"cancelling the task should not interrupt the thread\")\n        }, 100, TimeUnit.MILLISECONDS)\n        cdl1.await()\n        handle2.dispose()\n        cdl2.countDown()\n    }\n\n    /**\n     * Test cancelling [Scheduler.scheduleDirect] for [CoroutineDispatcher.asScheduler].\n     */\n    @Test\n    fun testCancellingDirect(): Unit = runSchedulerTest {\n        checkCancelling(it::scheduleDirect)\n    }\n\n    /**\n     * Test cancelling [Scheduler.Worker.schedule] for [CoroutineDispatcher.asScheduler].\n     */\n    @Test\n    fun testCancellingWorker(): Unit = runSchedulerTest {\n        val worker = it.createWorker()\n        checkCancelling(worker::schedule)\n    }\n\n    /**\n     * Test shutting down [CoroutineDispatcher.asScheduler].\n     */\n    @Test\n    fun testShuttingDown() {\n        val n = 5\n        runSchedulerTest(nThreads = n) { scheduler ->\n            val cdl1 = CountDownLatch(n)\n            val cdl2 = CountDownLatch(1)\n            val cdl3 = CountDownLatch(n)\n            repeat(n) {\n                scheduler.scheduleDirect {\n                    cdl1.countDown()\n                    try {\n                        cdl2.await()\n                    } catch (e: InterruptedException) {\n                        // this is the expected outcome\n                        cdl3.countDown()\n                    }\n                }\n            }\n            cdl1.await()\n            scheduler.shutdown()\n            if (!cdl3.await(1, TimeUnit.SECONDS)) {\n                cdl2.countDown()\n                error(\"the tasks were not cancelled when the scheduler was shut down\")\n            }\n        }\n    }\n\n    /** Tests that there are no uncaught exceptions if [Disposable.dispose] on a worker happens when tasks are present. */\n    @Test\n    fun testDisposingWorker() = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        val worker = scheduler.createWorker()\n        yield() // so that the worker starts waiting on the channel\n        assertFalse(worker.isDisposed)\n        worker.dispose()\n        assertTrue(worker.isDisposed)\n    }\n\n    /** Tests trying to use a [Scheduler.Worker]/[Scheduler] after [Scheduler.Worker.dispose]/[Scheduler.shutdown]. */\n    @Test\n    fun testSchedulingAfterDisposing() = runSchedulerTest {\n        expect(1)\n        val worker = it.createWorker()\n        // use CDL to ensure that the worker has properly initialized\n        val cdl1 = CountDownLatch(1)\n        setScheduler(2, 3)\n        val disposable1 = worker.schedule {\n            cdl1.countDown()\n        }\n        cdl1.await()\n        expect(4)\n        assertFalse(disposable1.isDisposed)\n        setScheduler(6, -1)\n        // check that the worker automatically disposes of the tasks after being disposed\n        assertFalse(worker.isDisposed)\n        worker.dispose()\n        assertTrue(worker.isDisposed)\n        expect(5)\n        val disposable2 = worker.schedule {\n            expectUnreached()\n        }\n        assertTrue(disposable2.isDisposed)\n        setScheduler(7, 8)\n        // ensure that the scheduler still works\n        val cdl2 = CountDownLatch(1)\n        val disposable3 = it.scheduleDirect {\n            cdl2.countDown()\n        }\n        cdl2.await()\n        expect(9)\n        assertFalse(disposable3.isDisposed)\n        // check that the scheduler automatically disposes of the tasks after being shut down\n        it.shutdown()\n        setScheduler(10, -1)\n        val disposable4 = it.scheduleDirect {\n            expectUnreached()\n        }\n        assertTrue(disposable4.isDisposed)\n        RxJavaPlugins.setScheduleHandler(null)\n        finish(11)\n    }\n\n    @Test\n    fun testSchedulerWithNoDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithNoDelay(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerWithNoDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithNoDelay(scheduler.createWorker()::schedule)\n    }\n\n    private suspend fun testRunnableWithNoDelay(block: RxSchedulerBlockNoDelay) {\n        expect(1)\n        suspendCancellableCoroutine<Unit> {\n            block(Runnable {\n                expect(2)\n                it.resume(Unit)\n            })\n        }\n        yield()\n        finish(3)\n    }\n\n    @Test\n    fun testSchedulerWithDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler::scheduleDirect, 300)\n    }\n\n    @Test\n    fun testSchedulerWorkerWithDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler.createWorker()::schedule, 300)\n    }\n\n    @Test\n    fun testSchedulerWithZeroDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerWithZeroDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler.createWorker()::schedule)\n    }\n\n    private suspend fun testRunnableWithDelay(block: RxSchedulerBlockWithDelay, delayMillis: Long = 0) {\n        expect(1)\n        suspendCancellableCoroutine<Unit> {\n            block({\n                expect(2)\n                it.resume(Unit)\n            }, delayMillis, TimeUnit.MILLISECONDS)\n        }\n        finish(3)\n    }\n\n    @Test\n    fun testAsSchedulerWithNegativeDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler::scheduleDirect, -1)\n    }\n\n    @Test\n    fun testAsSchedulerWorkerWithNegativeDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler.createWorker()::schedule, -1)\n    }\n\n    @Test\n    fun testSchedulerImmediateDispose(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableImmediateDispose(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerImmediateDispose(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableImmediateDispose(scheduler.createWorker()::schedule)\n    }\n\n    private fun testRunnableImmediateDispose(block: RxSchedulerBlockNoDelay) {\n        val disposable = block {\n            expectUnreached()\n        }\n        disposable.dispose()\n    }\n\n    @Test\n    fun testConvertDispatcherToOriginalScheduler(): Unit = runTest {\n        val originalScheduler = Schedulers.io()\n        val dispatcher = originalScheduler.asCoroutineDispatcher()\n        val scheduler = dispatcher.asScheduler()\n        assertSame(originalScheduler, scheduler)\n    }\n\n    @Test\n    fun testConvertSchedulerToOriginalDispatcher(): Unit = runTest {\n        val originalDispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = originalDispatcher.asScheduler()\n        val dispatcher = scheduler.asCoroutineDispatcher()\n        assertSame(originalDispatcher, dispatcher)\n    }\n\n    @Test\n    fun testSchedulerExpectRxPluginsCall(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableExpectRxPluginsCall(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerExpectRxPluginsCall(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableExpectRxPluginsCall(scheduler.createWorker()::schedule)\n    }\n\n    private suspend fun testRunnableExpectRxPluginsCall(block: RxSchedulerBlockNoDelay) {\n        expect(1)\n        setScheduler(2, 4)\n        suspendCancellableCoroutine<Unit> {\n            block(Runnable {\n                expect(5)\n                it.resume(Unit)\n            })\n            expect(3)\n        }\n        RxJavaPlugins.setScheduleHandler(null)\n        finish(6)\n    }\n\n    @Test\n    fun testSchedulerExpectRxPluginsCallWithDelay(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableExpectRxPluginsCallDelay(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerExpectRxPluginsCallWithDelay(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        val worker = scheduler.createWorker()\n        testRunnableExpectRxPluginsCallDelay(worker::schedule)\n    }\n\n    private suspend fun testRunnableExpectRxPluginsCallDelay(block: RxSchedulerBlockWithDelay) {\n        expect(1)\n        setScheduler(2, 4)\n        suspendCancellableCoroutine<Unit> {\n            block({\n                expect(5)\n                it.resume(Unit)\n            }, 10, TimeUnit.MILLISECONDS)\n            expect(3)\n        }\n        RxJavaPlugins.setScheduleHandler(null)\n        finish(6)\n    }\n\n    private fun setScheduler(expectedCountOnSchedule: Int, expectCountOnRun: Int) {\n        RxJavaPlugins.setScheduleHandler {\n            expect(expectedCountOnSchedule)\n            Runnable {\n                expect(expectCountOnRun)\n                it.run()\n            }\n        }\n    }\n\n    /**\n     * Tests that [Scheduler.Worker] runs all work sequentially.\n     */\n    @Test\n    fun testWorkerSequentialOrdering() = runTest {\n        expect(1)\n        val scheduler = Dispatchers.Default.asScheduler()\n        val worker = scheduler.createWorker()\n        val iterations = 100\n        for (i in 0..iterations) {\n            worker.schedule {\n                expect(2 + i)\n            }\n        }\n        suspendCoroutine<Unit> {\n            worker.schedule {\n                it.resume(Unit)\n            }\n        }\n        finish((iterations + 2) + 1)\n    }\n\n    /**\n     * Test that ensures that delays are actually respected (tasks scheduled sooner in the future run before tasks scheduled later,\n     * even when the later task is submitted before the earlier one)\n     */\n    @Test\n    fun testSchedulerRespectsDelays(): Unit = runTest {\n        val scheduler = Dispatchers.Default.asScheduler()\n        testRunnableRespectsDelays(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerRespectsDelays(): Unit = runTest {\n        val scheduler = Dispatchers.Default.asScheduler()\n        testRunnableRespectsDelays(scheduler.createWorker()::schedule)\n    }\n\n    private suspend fun testRunnableRespectsDelays(block: RxSchedulerBlockWithDelay) {\n        expect(1)\n        val semaphore = Semaphore(2, 2)\n        block({\n            expect(3)\n            semaphore.release()\n        }, 100, TimeUnit.MILLISECONDS)\n        block({\n            expect(2)\n            semaphore.release()\n        }, 1, TimeUnit.MILLISECONDS)\n        semaphore.acquire()\n        semaphore.acquire()\n        finish(4)\n    }\n\n    /**\n     * Tests that cancelling a runnable in one worker doesn't affect work in another scheduler.\n     *\n     * This is part of expected behavior documented.\n     */\n    @Test\n    fun testMultipleWorkerCancellation(): Unit = runTest {\n        expect(1)\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        suspendCancellableCoroutine<Unit> {\n            val workerOne = scheduler.createWorker()\n            workerOne.schedule({\n                expect(3)\n                it.resume(Unit)\n            }, 50, TimeUnit.MILLISECONDS)\n            val workerTwo = scheduler.createWorker()\n            workerTwo.schedule({\n                expectUnreached()\n            }, 1000, TimeUnit.MILLISECONDS)\n            workerTwo.dispose()\n            expect(2)\n        }\n        finish(4)\n    }\n}\n\ntypealias RxSchedulerBlockNoDelay = (Runnable) -> Disposable\ntypealias RxSchedulerBlockWithDelay = (Runnable, Long, TimeUnit) -> Disposable"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx2/test/SingleTest.kt",
        "content": "package kotlinx.coroutines.rx2\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.*\nimport io.reactivex.disposables.*\nimport io.reactivex.exceptions.*\nimport io.reactivex.functions.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass SingleTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val single = rxSingle(currentDispatcher()) {\n            expect(4)\n            \"OK\"\n        }\n        expect(2)\n        single.subscribe { value ->\n            expect(5)\n            assertEquals(\"OK\", value)\n        }\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val single = rxSingle(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        single.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val single = rxSingle(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n\n        }\n        expect(2)\n        // nothing is called on a disposed rx2 single\n        val sub = single.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testSingleNoWait() {\n        val single = rxSingle {\n            \"OK\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleAwait() = runBlocking {\n        assertEquals(\"OK\", Single.just(\"O\").await() + \"K\")\n    }\n\n    /** Tests that calls to [await] throw [CancellationException] and dispose of the subscription when their\n     * [Job] is cancelled. */\n    @Test\n    fun testSingleAwaitCancellation() = runTest {\n        expect(1)\n        val single = SingleSource<Int> { s ->\n            s.onSubscribe(object: Disposable {\n                override fun dispose() { expect(4) }\n                override fun isDisposed(): Boolean { expectUnreached(); return false }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                single.await()\n            } catch (e: CancellationException) {\n                expect(5)\n                throw e\n            }\n        }\n        expect(3)\n        job.cancelAndJoin()\n        finish(6)\n    }\n\n    @Test\n    fun testSingleEmitAndAwait() {\n        val single = rxSingle {\n            Single.just(\"O\").await() + \"K\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleWithDelay() {\n        val single = rxSingle {\n            Observable.timer(50, TimeUnit.MILLISECONDS).map { \"O\" }.awaitSingle() + \"K\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleException() {\n        val single = rxSingle {\n            Observable.just(\"O\", \"K\").awaitSingle() + \"K\"\n        }\n\n        checkErroneous(single) {\n            assert(it is IllegalArgumentException)\n        }\n    }\n\n    @Test\n    fun testAwaitFirst() {\n        val single = rxSingle {\n            Observable.just(\"O\", \"#\").awaitFirst() + \"K\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitLast() {\n        val single = rxSingle {\n            Observable.just(\"#\", \"O\").awaitLast() + \"K\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromObservable() {\n        val single = rxSingle {\n            try {\n                Observable.error<String>(RuntimeException(\"O\")).awaitFirst()\n            } catch (e: RuntimeException) {\n                Observable.just(e.message!!).awaitLast() + \"K\"\n            }\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromCoroutine() {\n        val single = rxSingle<String> {\n            throw IllegalStateException(Observable.just(\"O\").awaitSingle() + \"K\")\n        }\n\n        checkErroneous(single) {\n            assert(it is IllegalStateException)\n            assertEquals(\"OK\", it.message)\n        }\n    }\n\n    @Test\n    fun testSuppressedException() = runTest {\n        val single = rxSingle(currentDispatcher()) {\n            launch(start = CoroutineStart.ATOMIC) {\n                throw TestException() // child coroutine fails\n            }\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException2() // but parent throws another exception while cleaning up\n            }\n        }\n        try {\n            single.await()\n            expectUnreached()\n        } catch (e: TestException) {\n            assertIs<TestException2>(e.suppressed[0])\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSubscribe() = runTest {\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is LinkageError)\n            expect(2)\n        }\n        withExceptionHandler(handler) {\n            rxSingle(Dispatchers.Unconfined) {\n                expect(1)\n                42\n            }.subscribe(Consumer {\n                throw LinkageError()\n            })\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSingle() = runTest {\n        rxSingle(Dispatchers.Unconfined) {\n            throw LinkageError()\n        }.subscribe { _, e -> assertIs<LinkageError>(e); expect(1) }\n\n        finish(2)\n    }\n\n    @Test\n    fun testUnhandledException() = runTest {\n        expect(1)\n        var disposable: Disposable? = null\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is TestException)\n            expect(5)\n        }\n        val single = rxSingle(currentDispatcher()) {\n            expect(4)\n            disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException() // would not be able to handle it since mono is disposed\n            }\n        }\n        withExceptionHandler(handler) {\n            single.subscribe(object : SingleObserver<Unit> {\n                override fun onSubscribe(d: Disposable) {\n                    expect(2)\n                    disposable = d\n                }\n\n                override fun onSuccess(t: Unit) {\n                    expectUnreached()\n                }\n\n                override fun onError(t: Throwable) {\n                    expectUnreached()\n                }\n            })\n            expect(3)\n            yield() // run coroutine\n            finish(6)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/build.gradle.kts",
        "content": "import org.jetbrains.dokka.gradle.DokkaTaskPartial\nimport java.net.*\n\ndependencies {\n    api(project(\":kotlinx-coroutines-reactive\"))\n    testImplementation(\"org.reactivestreams:reactive-streams-tck:${version(\"reactive_streams\")}\")\n    api(\"io.reactivex.rxjava3:rxjava:${version(\"rxjava3\")}\")\n}\n\ntasks.withType(DokkaTaskPartial::class) {\n    dokkaSourceSets.configureEach {\n        externalDocumentationLink {\n            url = URL(\"https://reactivex.io/RxJava/3.x/javadoc/\")\n            packageListUrl = projectDir.toPath().resolve(\"package.list\").toUri().toURL()\n        }\n    }\n}\n\nval testNG by tasks.registering(Test::class) {\n    useTestNG()\n    reports.html.outputLocation = file(\"$buildDir/reports/testng\")\n    include(\"**/*ReactiveStreamTckTest.*\")\n    // Skip testNG when tests are filtered with --tests, otherwise it simply fails\n    onlyIf {\n        filter.includePatterns.isEmpty()\n    }\n    doFirst {\n        // Classic gradle, nothing works without doFirst\n        println(\"TestNG tests: ($includes)\")\n    }\n}\n\nval test by tasks.getting(Test::class) {\n    dependsOn(testNG)\n    reports.html.outputLocation = file(\"$buildDir/reports/junit\")\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxAwait.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.Disposable\nimport kotlinx.coroutines.CancellableContinuation\nimport kotlinx.coroutines.CancellationException\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport kotlin.coroutines.*\n\n// ------------------------ CompletableSource ------------------------\n\n/**\n * Awaits for completion of this completable without blocking the thread.\n * Returns `Unit`, or throws the corresponding exception if this completable produces an error.\n *\n * This suspending function is cancellable. If the [Job] of the invoking coroutine is cancelled while this\n * suspending function is suspended, this function immediately resumes with [CancellationException] and disposes of its\n * subscription.\n */\npublic suspend fun CompletableSource.await(): Unit = suspendCancellableCoroutine { cont ->\n    subscribe(object : CompletableObserver {\n        override fun onSubscribe(d: Disposable) { cont.disposeOnCancellation(d) }\n        override fun onComplete() { cont.resume(Unit) }\n        override fun onError(e: Throwable) { cont.resumeWithException(e) }\n    })\n}\n\n// ------------------------ MaybeSource ------------------------\n\n/**\n * Awaits for completion of the [MaybeSource] without blocking the thread.\n * Returns the resulting value, or `null` if no value is produced, or throws the corresponding exception if this\n * [MaybeSource] produces an error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this\n * function immediately resumes with [CancellationException] and disposes of its subscription.\n */\npublic suspend fun <T> MaybeSource<T & Any>.awaitSingleOrNull(): T? = suspendCancellableCoroutine { cont ->\n    subscribe(object : MaybeObserver<T & Any> {\n        override fun onSubscribe(d: Disposable) { cont.disposeOnCancellation(d) }\n        override fun onComplete() { cont.resume(null) }\n        override fun onSuccess(t: T & Any) { cont.resume(t) }\n        override fun onError(error: Throwable) { cont.resumeWithException(error) }\n    })\n}\n\n/**\n * Awaits for completion of the [MaybeSource] without blocking the thread.\n * Returns the resulting value, or throws if either no value is produced or this [MaybeSource] produces an error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this\n * function immediately resumes with [CancellationException] and disposes of its subscription.\n *\n * @throws NoSuchElementException if no elements were produced by this [MaybeSource].\n */\npublic suspend fun <T> MaybeSource<T & Any>.awaitSingle(): T = awaitSingleOrNull() ?: throw NoSuchElementException()\n\n/**\n * Awaits for completion of the maybe without blocking a thread.\n * Returns the resulting value, null if no value was produced or throws the corresponding exception if this\n * maybe had produced error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function\n * immediately resumes with [CancellationException].\n *\n * ### Deprecation\n *\n * Deprecated in favor of [awaitSingleOrNull] in order to reflect that `null` can be returned to denote the absence of\n * a value, as opposed to throwing in such case.\n *\n * @suppress\n */\n@Deprecated(\n    message = \"Deprecated in favor of awaitSingleOrNull()\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingleOrNull()\")\n) // Warning since 1.5, error in 1.6, hidden in 1.7\npublic suspend fun <T> MaybeSource<T & Any>.await(): T? = awaitSingleOrNull()\n\n/**\n * Awaits for completion of the maybe without blocking a thread.\n * Returns the resulting value, [default] if no value was produced or throws the corresponding exception if this\n * maybe had produced error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while this suspending function is waiting, this function\n * immediately resumes with [CancellationException].\n *\n * ### Deprecation\n *\n * Deprecated in favor of [awaitSingleOrNull] for naming consistency (see the deprecation of [MaybeSource.await] for\n * details).\n *\n * @suppress\n */\n@Deprecated(\n    message = \"Deprecated in favor of awaitSingleOrNull()\",\n    level = DeprecationLevel.HIDDEN,\n    replaceWith = ReplaceWith(\"this.awaitSingleOrNull() ?: default\")\n) // Warning since 1.5, error in 1.6, hidden in 1.7\npublic suspend fun <T> MaybeSource<T & Any>.awaitOrDefault(default: T): T = awaitSingleOrNull() ?: default\n\n// ------------------------ SingleSource ------------------------\n\n/**\n * Awaits for completion of the single value response without blocking the thread.\n * Returns the resulting value, or throws the corresponding exception if this response produces an error.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n */\npublic suspend fun <T> SingleSource<T & Any>.await(): T = suspendCancellableCoroutine { cont ->\n    subscribe(object : SingleObserver<T & Any> {\n        override fun onSubscribe(d: Disposable) { cont.disposeOnCancellation(d) }\n        override fun onSuccess(t: T & Any) { cont.resume(t) }\n        override fun onError(error: Throwable) { cont.resumeWithException(error) }\n    })\n}\n\n// ------------------------ ObservableSource ------------------------\n\n/**\n * Awaits the first value from the given [Observable] without blocking the thread and returns the resulting value, or,\n * if the observable has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the observable does not emit any value\n */\n@Suppress(\"UNCHECKED_CAST\")\npublic suspend fun <T> ObservableSource<T & Any>.awaitFirst(): T = awaitOne(Mode.FIRST) as T\n\n/**\n * Awaits the first value from the given [Observable], or returns the [default] value if none is emitted, without\n * blocking the thread, and returns the resulting value, or, if this observable has produced an error, throws the\n * corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n */\n@Suppress(\"UNCHECKED_CAST\")\npublic suspend fun <T> ObservableSource<T & Any>.awaitFirstOrDefault(default: T): T =\n    awaitOne(Mode.FIRST_OR_DEFAULT, default) as T\n\n/**\n * Awaits the first value from the given [Observable], or returns `null` if none is emitted, without blocking the\n * thread, and returns the resulting value, or, if this observable has produced an error, throws the corresponding\n * exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n */\npublic suspend fun <T> ObservableSource<T & Any>.awaitFirstOrNull(): T? = awaitOne(Mode.FIRST_OR_DEFAULT)\n\n/**\n * Awaits the first value from the given [Observable], or calls [defaultValue] to get a value if none is emitted,\n * without blocking the thread, and returns the resulting value, or, if this observable has produced an error, throws\n * the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n */\npublic suspend fun <T> ObservableSource<T & Any>.awaitFirstOrElse(defaultValue: () -> T): T =\n    awaitOne(Mode.FIRST_OR_DEFAULT) ?: defaultValue()\n\n/**\n * Awaits the last value from the given [Observable] without blocking the thread and\n * returns the resulting value, or, if this observable has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the observable does not emit any value\n */\n@Suppress(\"UNCHECKED_CAST\")\npublic suspend fun <T> ObservableSource<T & Any>.awaitLast(): T = awaitOne(Mode.LAST) as T\n\n/**\n * Awaits the single value from the given observable without blocking the thread and returns the resulting value, or,\n * if this observable has produced an error, throws the corresponding exception.\n *\n * This suspending function is cancellable.\n * If the [Job] of the current coroutine is cancelled while the suspending function is waiting, this\n * function immediately disposes of its subscription and resumes with [CancellationException].\n *\n * @throws NoSuchElementException if the observable does not emit any value\n * @throws IllegalArgumentException if the observable emits more than one value\n */\n@Suppress(\"UNCHECKED_CAST\")\npublic suspend fun <T> ObservableSource<T & Any>.awaitSingle(): T = awaitOne(Mode.SINGLE) as T\n\n// ------------------------ private ------------------------\n\ninternal fun CancellableContinuation<*>.disposeOnCancellation(d: Disposable) =\n    invokeOnCancellation { d.dispose() }\n\nprivate enum class Mode(@JvmField val s: String) {\n    FIRST(\"awaitFirst\"),\n    FIRST_OR_DEFAULT(\"awaitFirstOrDefault\"),\n    LAST(\"awaitLast\"),\n    SINGLE(\"awaitSingle\");\n    override fun toString(): String = s\n}\n\nprivate suspend fun <T> ObservableSource<T & Any>.awaitOne(\n    mode: Mode,\n    default: T? = null\n): T? = suspendCancellableCoroutine { cont ->\n    subscribe(object : Observer<T & Any> {\n        private lateinit var subscription: Disposable\n        private var value: T? = null\n        private var seenValue = false\n\n        override fun onSubscribe(sub: Disposable) {\n            subscription = sub\n            cont.invokeOnCancellation { sub.dispose() }\n        }\n\n        override fun onNext(t: T & Any) {\n            when (mode) {\n                Mode.FIRST, Mode.FIRST_OR_DEFAULT -> {\n                    if (!seenValue) {\n                        seenValue = true\n                        cont.resume(t)\n                        subscription.dispose()\n                    }\n                }\n                Mode.LAST, Mode.SINGLE -> {\n                    if (mode == Mode.SINGLE && seenValue) {\n                        if (cont.isActive)\n                            cont.resumeWithException(IllegalArgumentException(\"More than one onNext value for $mode\"))\n                        subscription.dispose()\n                    } else {\n                        value = t\n                        seenValue = true\n                    }\n                }\n            }\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun onComplete() {\n            if (seenValue) {\n                if (cont.isActive) cont.resume(value as T)\n                return\n            }\n            when {\n                mode == Mode.FIRST_OR_DEFAULT -> {\n                    cont.resume(default as T)\n                }\n                cont.isActive -> {\n                    cont.resumeWithException(NoSuchElementException(\"No value received via onNext for $mode\"))\n                }\n            }\n        }\n\n        override fun onError(e: Throwable) {\n            cont.resumeWithException(e)\n        }\n    })\n}\n\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxCancellable.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.functions.*\nimport io.reactivex.rxjava3.plugins.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\ninternal class RxCancellable(private val job: Job) : Cancellable {\n    override fun cancel() {\n        job.cancel()\n    }\n}\n\ninternal fun handleUndeliverableException(cause: Throwable, context: CoroutineContext) {\n    if (cause is CancellationException) return // Async CE should be completely ignored\n    try {\n        RxJavaPlugins.onError(cause)\n    } catch (e: Throwable) {\n        cause.addSuppressed(e)\n        handleCoroutineException(context, cause)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxChannel.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\n\n/**\n * Subscribes to this [MaybeSource] and returns a channel to receive elements emitted by it.\n * The resulting channel shall be [cancelled][ReceiveChannel.cancel] to unsubscribe from this source.\n *\n * This API is internal in the favour of [Flow].\n * [MaybeSource] doesn't have a corresponding [Flow] adapter, so it should be transformed to [Observable] first.\n */\n@PublishedApi\ninternal fun <T> MaybeSource<T & Any>.openSubscription(): ReceiveChannel<T> {\n    val channel = SubscriptionChannel<T>()\n    subscribe(channel)\n    return channel\n}\n\n/**\n * Subscribes to this [ObservableSource] and returns a channel to receive elements emitted by it.\n * The resulting channel shall be [cancelled][ReceiveChannel.cancel] to unsubscribe from this source.\n *\n * This API is internal in the favour of [Flow].\n * [ObservableSource] doesn't have a corresponding [Flow] adapter, so it should be transformed to [Observable] first.\n */\n@PublishedApi\ninternal fun <T> ObservableSource<T & Any>.openSubscription(): ReceiveChannel<T> {\n    val channel = SubscriptionChannel<T>()\n    subscribe(channel)\n    return channel\n}\n\n/**\n * Subscribes to this [MaybeSource] and performs the specified action for each received element.\n *\n * If [action] throws an exception at some point or if the [MaybeSource] raises an error, the exception is rethrown from\n * [collect].\n */\npublic suspend inline fun <T> MaybeSource<T & Any>.collect(action: (T) -> Unit): Unit =\n    openSubscription().consumeEach(action)\n\n/**\n * Subscribes to this [ObservableSource] and performs the specified action for each received element.\n *\n * If [action] throws an exception at some point, the subscription is cancelled, and the exception is rethrown from\n * [collect]. Also, if the [ObservableSource] signals an error, that error is rethrown from [collect].\n */\npublic suspend inline fun <T> ObservableSource<T & Any>.collect(action: (T) -> Unit): Unit = openSubscription().consumeEach(action)\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\nprivate class SubscriptionChannel<T> :\n    BufferedChannel<T>(capacity = Channel.UNLIMITED), Observer<T & Any>, MaybeObserver<T & Any>\n{\n    private val _subscription = atomic<Disposable?>(null)\n\n    @Suppress(\"CANNOT_OVERRIDE_INVISIBLE_MEMBER\")\n    override fun onClosedIdempotent() {\n        _subscription.getAndSet(null)?.dispose() // dispose exactly once\n    }\n\n    // Observer overrider\n    override fun onSubscribe(sub: Disposable) {\n        _subscription.value = sub\n    }\n\n    override fun onSuccess(t: T & Any) {\n        trySend(t)\n        close(cause = null)\n    }\n\n    override fun onNext(t: T & Any) {\n        trySend(t) // Safe to ignore return value here, expectedly racing with cancellation\n    }\n\n    override fun onComplete() {\n        close(cause = null)\n    }\n\n    override fun onError(e: Throwable) {\n        close(cause = e)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxCompletable.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Creates cold [Completable] that runs a given [block] in a coroutine and emits its result.\n * Every time the returned completable is subscribed, it starts a new coroutine.\n * Unsubscribing cancels running coroutine.\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n */\npublic fun rxCompletable(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> Unit\n): Completable {\n    require(context[Job] === null) { \"Completable context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return rxCompletableInternal(GlobalScope, context, block)\n}\n\nprivate fun rxCompletableInternal(\n    scope: CoroutineScope, // support for legacy rxCompletable in scope\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> Unit\n): Completable = Completable.create { subscriber ->\n    val newContext = scope.newCoroutineContext(context)\n    val coroutine = RxCompletableCoroutine(newContext, subscriber)\n    subscriber.setCancellable(RxCancellable(coroutine))\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate class RxCompletableCoroutine(\n    parentContext: CoroutineContext,\n    private val subscriber: CompletableEmitter\n) : AbstractCoroutine<Unit>(parentContext, false, true) {\n    override fun onCompleted(value: Unit) {\n        try {\n            subscriber.onComplete()\n        } catch (e: Throwable) {\n            handleUndeliverableException(e, context)\n        }\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        try {\n            if (subscriber.tryOnError(cause)) {\n                return\n            }\n        } catch (e: Throwable) {\n            cause.addSuppressed(e)\n        }\n        handleUndeliverableException(cause, context)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxConvert.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.reactivestreams.*\nimport java.util.concurrent.atomic.*\nimport kotlin.coroutines.*\n\n/**\n * Converts this job to the hot reactive completable that signals\n * with [onCompleted][CompletableObserver.onComplete] when the corresponding job completes.\n *\n * Every subscriber gets the signal at the same time.\n * Unsubscribing from the resulting completable **does not** affect the original job in any way.\n *\n * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change\n *    in the future to account for the concept of structured concurrency.\n *\n * @param context -- the coroutine context from which the resulting completable is going to be signalled\n */\npublic fun Job.asCompletable(context: CoroutineContext): Completable = rxCompletable(context) {\n    this@asCompletable.join()\n}\n\n/**\n * Converts this deferred value to the hot reactive maybe that signals\n * [onComplete][MaybeEmitter.onComplete], [onSuccess][MaybeEmitter.onSuccess] or [onError][MaybeEmitter.onError].\n *\n * Every subscriber gets the same completion value.\n * Unsubscribing from the resulting maybe **does not** affect the original deferred value in any way.\n *\n * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change\n *    in the future to account for the concept of structured concurrency.\n *\n * @param context -- the coroutine context from which the resulting maybe is going to be signalled\n */\npublic fun <T> Deferred<T?>.asMaybe(context: CoroutineContext): Maybe<T & Any> = rxMaybe(context) {\n    this@asMaybe.await()\n}\n\n/**\n * Converts this deferred value to the hot reactive single that signals either\n * [onSuccess][SingleObserver.onSuccess] or [onError][SingleObserver.onError].\n *\n * Every subscriber gets the same completion value.\n * Unsubscribing from the resulting single **does not** affect the original deferred value in any way.\n *\n * **Note: This is an experimental api.** Conversion of coroutines primitives to reactive entities may change\n *    in the future to account for the concept of structured concurrency.\n *\n * @param context -- the coroutine context from which the resulting single is going to be signalled\n */\npublic fun <T : Any> Deferred<T>.asSingle(context: CoroutineContext): Single<T> = rxSingle(context) {\n    this@asSingle.await()\n}\n\n/**\n * Transforms given cold [ObservableSource] into cold [Flow].\n *\n * The resulting flow is _cold_, which means that [ObservableSource.subscribe] is called every time a terminal operator\n * is applied to the resulting flow.\n *\n * A channel with the [default][Channel.BUFFERED] buffer size is used. Use the [buffer] operator on the\n * resulting flow to specify a user-defined value and to control what happens when data is produced faster\n * than consumed, i.e. to control the back-pressure behavior. Check [callbackFlow] for more details.\n */\npublic fun <T: Any> ObservableSource<T>.asFlow(): Flow<T> = callbackFlow {\n    val disposableRef = AtomicReference<Disposable>()\n    val observer = object : Observer<T> {\n        override fun onComplete() { close() }\n        override fun onSubscribe(d: Disposable) { if (!disposableRef.compareAndSet(null, d)) d.dispose() }\n        override fun onNext(t: T) {\n            /*\n             * Channel was closed by the downstream, so the exception (if any)\n             * also was handled by the same downstream\n             */\n            try {\n                trySendBlocking(t)\n            } catch (e: InterruptedException) {\n                // RxJava interrupts the source\n            }\n        }\n        override fun onError(e: Throwable) { close(e) }\n    }\n\n    subscribe(observer)\n    awaitClose { disposableRef.getAndSet(Disposable.disposed())?.dispose() }\n}\n\n/**\n * Converts the given flow to a cold observable.\n * The original flow is cancelled when the observable subscriber is disposed.\n *\n * An optional [context] can be specified to control the execution context of calls to [Observer] methods.\n * You can set a [CoroutineDispatcher] to confine them to a specific thread and/or various [ThreadContextElement] to\n * inject additional context into the caller thread. By default, the [Unconfined][Dispatchers.Unconfined] dispatcher\n * is used, so calls are performed from an arbitrary thread.\n */\npublic fun <T: Any> Flow<T>.asObservable(context: CoroutineContext = EmptyCoroutineContext) : Observable<T> = Observable.create { emitter ->\n    /*\n     * ATOMIC is used here to provide stable behaviour of subscribe+dispose pair even if\n     * asObservable is already invoked from unconfined\n     */\n    val job = GlobalScope.launch(Dispatchers.Unconfined + context, start = CoroutineStart.ATOMIC) {\n        try {\n            collect { value -> emitter.onNext(value) }\n            emitter.onComplete()\n        } catch (e: Throwable) {\n            // 'create' provides safe emitter, so we can unconditionally call on* here if exception occurs in `onComplete`\n            if (e !is CancellationException) {\n                if (!emitter.tryOnError(e)) {\n                    handleUndeliverableException(e, coroutineContext)\n                }\n            } else {\n                emitter.onComplete()\n            }\n        }\n    }\n    emitter.setCancellable(RxCancellable(job))\n}\n\n/**\n * Converts the given flow to a cold flowable.\n * The original flow is cancelled when the flowable subscriber is disposed.\n *\n * An optional [context] can be specified to control the execution context of calls to [Subscriber] methods.\n * You can set a [CoroutineDispatcher] to confine them to a specific thread and/or various [ThreadContextElement] to\n * inject additional context into the caller thread. By default, the [Unconfined][Dispatchers.Unconfined] dispatcher\n * is used, so calls are performed from an arbitrary thread.\n */\npublic fun <T: Any> Flow<T>.asFlowable(context: CoroutineContext = EmptyCoroutineContext): Flowable<T> =\n    Flowable.fromPublisher(asPublisher(context))\n\n/** @suppress */\n@Suppress(\"UNUSED\") // KT-42513\n@JvmOverloads // binary compatibility\n@JvmName(\"from\")\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"\") // Since 1.4, was experimental prior to that\npublic fun <T: Any> Flow<T>._asFlowable(context: CoroutineContext = EmptyCoroutineContext): Flowable<T> =\n    asFlowable(context)\n\n/** @suppress */\n@Suppress(\"UNUSED\") // KT-42513\n@JvmOverloads // binary compatibility\n@JvmName(\"from\")\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"\") // Since 1.4, was experimental prior to that\npublic fun <T: Any> Flow<T>._asObservable(context: CoroutineContext = EmptyCoroutineContext) : Observable<T> = asObservable(context)\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxFlowable.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.reactive.*\nimport kotlin.coroutines.*\n\n/**\n * Creates cold [flowable][Flowable] that will run a given [block] in a coroutine.\n * Every time the returned flowable is subscribed, it starts a new coroutine.\n *\n * Coroutine emits ([ObservableEmitter.onNext]) values with `send`, completes ([ObservableEmitter.onComplete])\n * when the coroutine completes or channel is explicitly closed and emits error ([ObservableEmitter.onError])\n * if coroutine throws an exception or closes channel with a cause.\n * Unsubscribing cancels running coroutine.\n *\n * Invocations of `send` are suspended appropriately when subscribers apply back-pressure and to ensure that\n * `onNext` is not invoked concurrently.\n *\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n *\n * **Note: This is an experimental api.** Behaviour of publishers that work as children in a parent scope with respect\n */\npublic fun <T: Any> rxFlowable(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Flowable<T> {\n    require(context[Job] === null) { \"Flowable context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return Flowable.fromPublisher(publishInternal(GlobalScope, context, RX_HANDLER, block))\n}\n\nprivate val RX_HANDLER: (Throwable, CoroutineContext) -> Unit = ::handleUndeliverableException\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxMaybe.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Creates cold [maybe][Maybe] that will run a given [block] in a coroutine and emits its result.\n * If [block] result is `null`, [onComplete][MaybeObserver.onComplete] is invoked without a value.\n * Every time the returned observable is subscribed, it starts a new coroutine.\n * Unsubscribing cancels running coroutine.\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n */\npublic fun <T> rxMaybe(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> T?\n): Maybe<T & Any> {\n    require(context[Job] === null) { \"Maybe context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return rxMaybeInternal(GlobalScope, context, block)\n}\n\nprivate fun <T> rxMaybeInternal(\n    scope: CoroutineScope, // support for legacy rxMaybe in scope\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> T?\n): Maybe<T & Any> = Maybe.create { subscriber ->\n    val newContext = scope.newCoroutineContext(context)\n    val coroutine = RxMaybeCoroutine(newContext, subscriber)\n    subscriber.setCancellable(RxCancellable(coroutine))\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate class RxMaybeCoroutine<T: Any>(\n    parentContext: CoroutineContext,\n    private val subscriber: MaybeEmitter<T>\n) : AbstractCoroutine<T?>(parentContext, false, true) {\n    override fun onCompleted(value: T?) {\n        try {\n            if (value == null) subscriber.onComplete() else subscriber.onSuccess(value)\n        } catch (e: Throwable) {\n            handleUndeliverableException(e, context)\n        }\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        try {\n            if (subscriber.tryOnError(cause)) {\n                return\n            }\n        } catch (e: Throwable) {\n            cause.addSuppressed(e)\n        }\n        handleUndeliverableException(cause, context)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxObservable.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.exceptions.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport kotlinx.coroutines.sync.*\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.internal.*\n\n/**\n * Creates cold [observable][Observable] that will run a given [block] in a coroutine.\n * Every time the returned observable is subscribed, it starts a new coroutine.\n *\n * Coroutine emits ([ObservableEmitter.onNext]) values with `send`, completes ([ObservableEmitter.onComplete])\n * when the coroutine completes or channel is explicitly closed and emits error ([ObservableEmitter.onError])\n * if coroutine throws an exception or closes channel with a cause.\n * Unsubscribing cancels running coroutine.\n *\n * Invocations of `send` are suspended appropriately to ensure that `onNext` is not invoked concurrently.\n * Note that Rx 2.x [Observable] **does not support backpressure**.\n *\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n */\npublic fun <T : Any> rxObservable(\n    context: CoroutineContext = EmptyCoroutineContext,\n    @BuilderInference block: suspend ProducerScope<T>.() -> Unit\n): Observable<T> {\n    require(context[Job] === null) { \"Observable context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return rxObservableInternal(GlobalScope, context, block)\n}\n\nprivate fun <T : Any> rxObservableInternal(\n    scope: CoroutineScope, // support for legacy rxObservable in scope\n    context: CoroutineContext,\n    block: suspend ProducerScope<T>.() -> Unit\n): Observable<T> = Observable.create { subscriber ->\n    val newContext = scope.newCoroutineContext(context)\n    val coroutine = RxObservableCoroutine(newContext, subscriber)\n    subscriber.setCancellable(RxCancellable(coroutine)) // do it first (before starting coroutine), to await unnecessary suspensions\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate const val OPEN = 0        // open channel, still working\nprivate const val CLOSED = -1     // closed, but have not signalled onCompleted/onError yet\nprivate const val SIGNALLED = -2  // already signalled subscriber onCompleted/onError\n\nprivate class RxObservableCoroutine<T : Any>(\n    parentContext: CoroutineContext,\n    private val subscriber: ObservableEmitter<T>\n) : AbstractCoroutine<Unit>(parentContext, false, true), ProducerScope<T> {\n    override val channel: SendChannel<T> get() = this\n\n    private val _signal = atomic(OPEN)\n\n    override val isClosedForSend: Boolean get() = !isActive\n    override fun close(cause: Throwable?): Boolean = cancelCoroutine(cause)\n    override fun invokeOnClose(handler: (Throwable?) -> Unit) =\n        throw UnsupportedOperationException(\"RxObservableCoroutine doesn't support invokeOnClose\")\n\n    // Mutex is locked when either nRequested == 0 or while subscriber.onXXX is being invoked\n    private val mutex: Mutex = Mutex()\n\n    @Suppress(\"UNCHECKED_CAST\", \"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n    override val onSend: SelectClause2<T, SendChannel<T>> get() = SelectClause2Impl(\n        clauseObject = this,\n        regFunc = RxObservableCoroutine<*>::registerSelectForSend as RegistrationFunction,\n        processResFunc = RxObservableCoroutine<*>::processResultSelectSend as ProcessResultFunction\n    )\n\n    @Suppress(\"UNUSED_PARAMETER\")\n    private fun registerSelectForSend(select: SelectInstance<*>, element: Any?) {\n        // Try to acquire the mutex and complete in the registration phase.\n        if (mutex.tryLock()) {\n            select.selectInRegistrationPhase(Unit)\n            return\n        }\n        // Start a new coroutine that waits for the mutex, invoking `trySelect(..)` after that.\n        // Please note that at the point of the `trySelect(..)` invocation the corresponding\n        // `select` can still be in the registration phase, making this `trySelect(..)` bound to fail.\n        // In this case, the `onSend` clause will be re-registered, which alongside with the mutex\n        // manipulation makes the resulting solution obstruction-free.\n        launch {\n            mutex.lock()\n            if (!select.trySelect(this@RxObservableCoroutine, Unit)) {\n                mutex.unlock()\n            }\n        }\n    }\n\n    @Suppress(\"RedundantNullableReturnType\", \"UNUSED_PARAMETER\", \"UNCHECKED_CAST\")\n    private fun processResultSelectSend(element: Any?, selectResult: Any?): Any? {\n        doLockedNext(element as T)?.let { throw it }\n        return this@RxObservableCoroutine\n    }\n\n    override fun trySend(element: T): ChannelResult<Unit> =\n        if (!mutex.tryLock()) {\n            ChannelResult.failure()\n        } else {\n            when (val throwable = doLockedNext(element)) {\n                null -> ChannelResult.success(Unit)\n                else -> ChannelResult.closed(throwable)\n            }\n        }\n\n    override suspend fun send(element: T) {\n        mutex.lock()\n        doLockedNext(element)?.let { throw it }\n    }\n\n    // assert: mutex.isLocked()\n    private fun doLockedNext(elem: T): Throwable? {\n        // check if already closed for send\n        if (!isActive) {\n            doLockedSignalCompleted(completionCause, completionCauseHandled)\n            return getCancellationException()\n        }\n        // notify subscriber\n        try {\n            subscriber.onNext(elem)\n        } catch (e: Throwable) {\n            val cause = UndeliverableException(e)\n            val causeDelivered = close(cause)\n            unlockAndCheckCompleted()\n            return if (causeDelivered) {\n                // `cause` is the reason this channel is closed\n                cause\n            } else {\n                // Someone else closed the channel during `onNext`. We report `cause` as an undeliverable exception.\n                handleUndeliverableException(cause, context)\n                getCancellationException()\n            }\n        }\n        /*\n         * There is no sense to check for `isActive` before doing `unlock`, because cancellation/completion might\n         * happen after this check and before `unlock` (see signalCompleted that does not do anything\n         * if it fails to acquire the lock that we are still holding).\n         * We have to recheck `isCompleted` after `unlock` anyway.\n         */\n        unlockAndCheckCompleted()\n        return null\n    }\n\n    private fun unlockAndCheckCompleted() {\n        mutex.unlock()\n        // recheck isActive\n        if (!isActive && mutex.tryLock())\n            doLockedSignalCompleted(completionCause, completionCauseHandled)\n    }\n\n    // assert: mutex.isLocked()\n    private fun doLockedSignalCompleted(cause: Throwable?, handled: Boolean) {\n        // cancellation failures\n        try {\n            if (_signal.value == SIGNALLED)\n                return\n            _signal.value = SIGNALLED // we'll signal onError/onCompleted (that the final state -- no CAS needed)\n            @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n            val unwrappedCause = cause?.let { unwrap(it) }\n            if (unwrappedCause == null) {\n                try {\n                    subscriber.onComplete()\n                } catch (e: Exception) {\n                    handleUndeliverableException(e, context)\n                }\n            } else if (unwrappedCause is UndeliverableException && !handled) {\n                /** Such exceptions are not reported to `onError`, as, according to the reactive specifications,\n                 * exceptions thrown from the Subscriber methods must be treated as if the Subscriber was already\n                 * cancelled. */\n                handleUndeliverableException(cause, context)\n            } else if (unwrappedCause !== getCancellationException() || !subscriber.isDisposed) {\n                try {\n                    /** If the subscriber is already in a terminal state, the error will be signalled to\n                     * `RxJavaPlugins.onError`. */\n                    subscriber.onError(cause)\n                } catch (e: Exception) {\n                    cause.addSuppressed(e)\n                    handleUndeliverableException(cause, context)\n                }\n            }\n        } finally {\n            mutex.unlock()\n        }\n    }\n\n    private fun signalCompleted(cause: Throwable?, handled: Boolean) {\n        if (!_signal.compareAndSet(OPEN, CLOSED)) return // abort, other thread invoked doLockedSignalCompleted\n        if (mutex.tryLock()) // if we can acquire the lock\n            doLockedSignalCompleted(cause, handled)\n    }\n\n    override fun onCompleted(value: Unit) {\n        signalCompleted(null, false)\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        signalCompleted(cause, handled)\n    }\n}\n\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxScheduler.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.*\nimport io.reactivex.rxjava3.plugins.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n/**\n * Converts an instance of [Scheduler] to an implementation of [CoroutineDispatcher]\n * and provides native support of [delay] and [withTimeout].\n */\npublic fun Scheduler.asCoroutineDispatcher(): CoroutineDispatcher =\n    if (this is DispatcherScheduler) {\n        dispatcher\n    } else {\n        SchedulerCoroutineDispatcher(this)\n    }\n\n@Deprecated(level = DeprecationLevel.HIDDEN, message = \"Since 1.4.2, binary compatibility with earlier versions\")\n@JvmName(\"asCoroutineDispatcher\")\npublic fun Scheduler.asCoroutineDispatcher0(): SchedulerCoroutineDispatcher =\n    SchedulerCoroutineDispatcher(this)\n\n/**\n * Converts an instance of [CoroutineDispatcher] to an implementation of [Scheduler].\n */\npublic fun CoroutineDispatcher.asScheduler(): Scheduler =\n    if (this is SchedulerCoroutineDispatcher) {\n        scheduler\n    } else {\n        DispatcherScheduler(this)\n    }\n\nprivate class DispatcherScheduler(@JvmField val dispatcher: CoroutineDispatcher) : Scheduler() {\n\n    private val schedulerJob = SupervisorJob()\n\n    /**\n     * The scope for everything happening in this [DispatcherScheduler].\n     *\n     * Running tasks, too, get launched under this scope, because [shutdown] should cancel the running tasks as well.\n     */\n    private val scope = CoroutineScope(schedulerJob + dispatcher)\n\n    /**\n     * The counter of created workers, for their pretty-printing.\n     */\n    private val workerCounter = atomic(1L)\n\n    override fun scheduleDirect(block: Runnable, delay: Long, unit: TimeUnit): Disposable =\n        scope.scheduleTask(block, unit.toMillis(delay)) { task ->\n            Runnable { scope.launch { task() } }\n        }\n\n    override fun createWorker(): Worker = DispatcherWorker(workerCounter.getAndIncrement(), dispatcher, schedulerJob)\n\n    override fun shutdown() {\n        schedulerJob.cancel()\n    }\n\n    private class DispatcherWorker(\n        private val counter: Long,\n        private val dispatcher: CoroutineDispatcher,\n        parentJob: Job\n    ) : Worker() {\n\n        private val workerJob = SupervisorJob(parentJob)\n        private val workerScope = CoroutineScope(workerJob + dispatcher)\n        private val blockChannel = Channel<suspend () -> Unit>(Channel.UNLIMITED)\n\n        init {\n            workerScope.launch {\n                blockChannel.consumeEach {\n                    it()\n                }\n            }\n        }\n\n        override fun schedule(block: Runnable, delay: Long, unit: TimeUnit): Disposable =\n            workerScope.scheduleTask(block, unit.toMillis(delay)) { task ->\n                Runnable { blockChannel.trySend(task) }\n            }\n\n        override fun isDisposed(): Boolean = !workerScope.isActive\n\n        override fun dispose() {\n            blockChannel.close()\n            workerJob.cancel()\n        }\n\n        override fun toString(): String = \"$dispatcher (worker $counter, ${if (isDisposed) \"disposed\" else \"active\"})\"\n    }\n\n    override fun toString(): String = dispatcher.toString()\n}\n\nprivate typealias Task = suspend () -> Unit\n\n/**\n * Schedule [block] so that an adapted version of it, wrapped in [adaptForScheduling], executes after [delayMillis]\n * milliseconds.\n */\nprivate fun CoroutineScope.scheduleTask(\n    block: Runnable,\n    delayMillis: Long,\n    adaptForScheduling: (Task) -> Runnable\n): Disposable {\n    val ctx = coroutineContext\n    var handle: DisposableHandle? = null\n    val disposable = Disposable.fromRunnable {\n        // null if delay <= 0\n        handle?.dispose()\n    }\n    val decoratedBlock = RxJavaPlugins.onSchedule(block)\n    suspend fun task() {\n        if (disposable.isDisposed) return\n        try {\n            runInterruptible {\n                decoratedBlock.run()\n            }\n        } catch (e: Throwable) {\n            handleUndeliverableException(e, ctx)\n        }\n    }\n\n    val toSchedule = adaptForScheduling(::task)\n    if (!isActive) return Disposable.disposed()\n    if (delayMillis <= 0) {\n        toSchedule.run()\n    } else {\n        @Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\") // do not remove the INVISIBLE_REFERENCE suppression: required in K2\n        ctx.delay.invokeOnTimeout(delayMillis, toSchedule, ctx).let { handle = it }\n    }\n    return disposable\n}\n\n/**\n * Implements [CoroutineDispatcher] on top of an arbitrary [Scheduler].\n */\npublic class SchedulerCoroutineDispatcher(\n    /**\n     * Underlying scheduler of current [CoroutineDispatcher].\n     */\n    public val scheduler: Scheduler\n) : CoroutineDispatcher(), Delay {\n    /** @suppress */\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        scheduler.scheduleDirect(block)\n    }\n\n    /** @suppress */\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val disposable = scheduler.scheduleDirect({\n            with(continuation) { resumeUndispatched(Unit) }\n        }, timeMillis, TimeUnit.MILLISECONDS)\n        continuation.disposeOnCancellation(disposable)\n    }\n\n    /** @suppress */\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        val disposable = scheduler.scheduleDirect(block, timeMillis, TimeUnit.MILLISECONDS)\n        return DisposableHandle { disposable.dispose() }\n    }\n\n    /** @suppress */\n    override fun toString(): String = scheduler.toString()\n\n    /** @suppress */\n    override fun equals(other: Any?): Boolean = other is SchedulerCoroutineDispatcher && other.scheduler === scheduler\n\n    /** @suppress */\n    override fun hashCode(): Int = System.identityHashCode(scheduler)\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/src/RxSingle.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Creates cold [single][Single] that will run a given [block] in a coroutine and emits its result.\n * Every time the returned observable is subscribed, it starts a new coroutine.\n * Unsubscribing cancels running coroutine.\n * Coroutine context can be specified with [context] argument.\n * If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used.\n * Method throws [IllegalArgumentException] if provided [context] contains a [Job] instance.\n */\npublic fun <T : Any> rxSingle(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> T\n): Single<T> {\n    require(context[Job] === null) { \"Single context cannot contain job in it.\" +\n            \"Its lifecycle should be managed via Disposable handle. Had $context\" }\n    return rxSingleInternal(GlobalScope, context, block)\n}\n\nprivate fun <T : Any> rxSingleInternal(\n    scope: CoroutineScope, // support for legacy rxSingle in scope\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> T\n): Single<T> = Single.create { subscriber ->\n    val newContext = scope.newCoroutineContext(context)\n    val coroutine = RxSingleCoroutine(newContext, subscriber)\n    subscriber.setCancellable(RxCancellable(coroutine))\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n}\n\nprivate class RxSingleCoroutine<T: Any>(\n    parentContext: CoroutineContext,\n    private val subscriber: SingleEmitter<T>\n) : AbstractCoroutine<T>(parentContext, false, true) {\n    override fun onCompleted(value: T) {\n        try {\n            subscriber.onSuccess(value)\n        } catch (e: Throwable) {\n            handleUndeliverableException(e, context)\n        }\n    }\n\n    override fun onCancelled(cause: Throwable, handled: Boolean) {\n        try {\n            if (subscriber.tryOnError(cause)) {\n                return\n            }\n        } catch (e: Throwable) {\n            cause.addSuppressed(e)\n        }\n        handleUndeliverableException(cause, context)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/BackpressureTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass BackpressureTest : TestBase() {\n    @Test\n    fun testBackpressureDropDirect() = runTest {\n        expect(1)\n        Flowable.fromArray(1)\n            .onBackpressureDrop()\n            .collect {\n                assertEquals(1, it)\n                expect(2)\n            }\n        finish(3)\n    }\n\n    @Test\n    fun testBackpressureDropFlow() = runTest {\n        expect(1)\n        Flowable.fromArray(1)\n            .onBackpressureDrop()\n            .asFlow()\n            .collect {\n                assertEquals(1, it)\n                expect(2)\n            }\n        finish(3)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/Check.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.plugins.*\n\nfun <T : Any> checkSingleValue(\n    observable: Observable<T>,\n    checker: (T) -> Unit\n) {\n    val singleValue = observable.blockingSingle()\n    checker(singleValue)\n}\n\nfun checkErroneous(\n    observable: Observable<*>,\n    checker: (Throwable) -> Unit\n) {\n    val singleNotification = observable.materialize().blockingSingle()\n    val error = singleNotification.error ?: error(\"Excepted error\")\n    checker(error)\n}\n\nfun <T : Any> checkSingleValue(\n    single: Single<T>,\n    checker: (T) -> Unit\n) {\n    val singleValue = single.blockingGet()\n    checker(singleValue)\n}\n\nfun checkErroneous(\n    single: Single<*>,\n    checker: (Throwable) -> Unit\n) {\n    try {\n        single.blockingGet()\n        error(\"Should have failed\")\n    } catch (e: Throwable) {\n        checker(e)\n    }\n}\n\nfun <T> checkMaybeValue(\n    maybe: Maybe<T>,\n    checker: (T?) -> Unit\n) {\n    val maybeValue = maybe.toFlowable().blockingIterable().firstOrNull()\n    checker(maybeValue)\n}\n\n@Suppress(\"UNCHECKED_CAST\")\nfun checkErroneous(\n    maybe: Maybe<*>,\n    checker: (Throwable) -> Unit\n) {\n    try {\n        (maybe as Maybe<Any>).blockingGet()\n        error(\"Should have failed\")\n    } catch (e: Throwable) {\n        checker(e)\n    }\n}\n\ninline fun withExceptionHandler(noinline handler: (Throwable) -> Unit, block: () -> Unit) {\n    val original = RxJavaPlugins.getErrorHandler()\n    RxJavaPlugins.setErrorHandler { handler(it) }\n    try {\n        block()\n    } finally {\n        RxJavaPlugins.setErrorHandler(original)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/CompletableTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.*\nimport io.reactivex.rxjava3.exceptions.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass CompletableTest : TestBase() {\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(4)\n        }\n        expect(2)\n        completable.subscribe {\n            expect(5)\n        }\n        expect(3)\n        yield() // to completable coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        completable.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to completable coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n        }\n        expect(2)\n        // nothing is called on a disposed rx3 completable\n        val sub = completable.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testAwaitSuccess() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(3)\n        }\n        expect(2)\n        completable.await() // shall launch coroutine\n        finish(4)\n    }\n\n    @Test\n    fun testAwaitFailure() = runBlocking {\n        expect(1)\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(3)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        try {\n            completable.await() // shall launch coroutine and throw exception\n            expectUnreached()\n        } catch (e: RuntimeException) {\n            finish(4)\n            assertEquals(\"OK\", e.message)\n        }\n    }\n\n    /** Tests that calls to [await] throw [CancellationException] and dispose of the subscription when their [Job] is\n     * cancelled. */\n    @Test\n    fun testAwaitCancellation() = runTest {\n        expect(1)\n        val completable = CompletableSource { s ->\n            s.onSubscribe(object: Disposable {\n                override fun dispose() { expect(4) }\n                override fun isDisposed(): Boolean { expectUnreached(); return false }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                completable.await()\n            } catch (e: CancellationException) {\n                expect(5)\n                throw e\n            }\n        }\n        expect(3)\n        job.cancelAndJoin()\n        finish(6)\n    }\n\n    @Test\n    fun testSuppressedException() = runTest {\n        val completable = rxCompletable(currentDispatcher()) {\n            launch(start = CoroutineStart.ATOMIC) {\n                throw TestException() // child coroutine fails\n            }\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException2() // but parent throws another exception while cleaning up\n            }\n        }\n        try {\n            completable.await()\n            expectUnreached()\n        } catch (e: TestException) {\n            assertIs<TestException2>(e.suppressed[0])\n        }\n    }\n\n    @Test\n    fun testUnhandledException() = runTest {\n        expect(1)\n        var disposable: Disposable? = null\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is TestException)\n            expect(5)\n        }\n        val completable = rxCompletable(currentDispatcher()) {\n            expect(4)\n            disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException() // would not be able to handle it since mono is disposed\n            }\n        }\n        withExceptionHandler(handler) {\n            completable.subscribe(object : CompletableObserver {\n                override fun onSubscribe(d: Disposable) {\n                    expect(2)\n                    disposable = d\n                }\n\n                override fun onComplete() {\n                    expectUnreached()\n                }\n\n                override fun onError(t: Throwable) {\n                    expectUnreached()\n                }\n            })\n            expect(3)\n            yield() // run coroutine\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSubscribe() = runTest {\n        val handler: (Throwable) -> Unit = { e ->\n            assertTrue(e is UndeliverableException && e.cause is LinkageError); expect(2)\n        }\n\n        withExceptionHandler(handler) {\n            rxCompletable(Dispatchers.Unconfined) {\n                expect(1)\n            }.subscribe { throw LinkageError() }\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSingle() = runTest {\n        rxCompletable(Dispatchers.Unconfined) {\n            throw LinkageError()\n        }.subscribe({ expectUnreached()  }, { expect(1); assertIs<LinkageError>(it) })\n        finish(2)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ConvertTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.consumeAsFlow\nimport org.junit.Assert\nimport org.junit.Test\nimport kotlin.test.*\n\nclass ConvertTest : TestBase() {\n    @Test\n    fun testToCompletableSuccess() = runBlocking {\n        expect(1)\n        val job = launch {\n            expect(3)\n        }\n        val completable = job.asCompletable(coroutineContext.minusKey(Job))\n        completable.subscribe {\n            expect(4)\n        }\n        expect(2)\n        yield()\n        finish(5)\n    }\n\n    @Test\n    fun testToCompletableFail() = runBlocking {\n        expect(1)\n        val job = async(NonCancellable) { // don't kill parent on exception\n            expect(3)\n            throw RuntimeException(\"OK\")\n        }\n        val completable = job.asCompletable(coroutineContext.minusKey(Job))\n        completable.subscribe {\n            expect(4)\n        }\n        expect(2)\n        yield()\n        finish(5)\n    }\n\n    @Test\n    fun testToMaybe() {\n        val d = GlobalScope.async {\n            delay(50)\n            \"OK\"\n        }\n        val maybe1 = d.asMaybe(Dispatchers.Unconfined)\n        checkMaybeValue(maybe1) {\n            assertEquals(\"OK\", it)\n        }\n        val maybe2 = d.asMaybe(Dispatchers.Unconfined)\n        checkMaybeValue(maybe2) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testToMaybeEmpty() {\n        val d = GlobalScope.async {\n            delay(50)\n            null\n        }\n        val maybe1 = d.asMaybe(Dispatchers.Unconfined)\n        checkMaybeValue(maybe1, Assert::assertNull)\n        val maybe2 = d.asMaybe(Dispatchers.Unconfined)\n        checkMaybeValue(maybe2, Assert::assertNull)\n    }\n\n    @Test\n    fun testToMaybeFail() {\n        val d = GlobalScope.async {\n            delay(50)\n            throw TestRuntimeException(\"OK\")\n        }\n        val maybe1 = d.asMaybe(Dispatchers.Unconfined)\n        checkErroneous(maybe1) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n        val maybe2 = d.asMaybe(Dispatchers.Unconfined)\n        checkErroneous(maybe2) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n    }\n\n    @Test\n    fun testToSingle() {\n        val d = GlobalScope.async {\n            delay(50)\n            \"OK\"\n        }\n        val single1 = d.asSingle(Dispatchers.Unconfined)\n        checkSingleValue(single1) {\n            assertEquals(\"OK\", it)\n        }\n        val single2 = d.asSingle(Dispatchers.Unconfined)\n        checkSingleValue(single2) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testToSingleFail() {\n        val d = GlobalScope.async {\n            delay(50)\n            throw TestRuntimeException(\"OK\")\n        }\n        val single1 = d.asSingle(Dispatchers.Unconfined)\n        checkErroneous(single1) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n        val single2 = d.asSingle(Dispatchers.Unconfined)\n        checkErroneous(single2) {\n            check(it is TestRuntimeException && it.message == \"OK\") { \"$it\" }\n        }\n    }\n\n    @Test\n    fun testToObservable() {\n        val c = GlobalScope.produce {\n            delay(50)\n            send(\"O\")\n            delay(50)\n            send(\"K\")\n        }\n        val observable = c.consumeAsFlow().asObservable()\n        checkSingleValue(observable.reduce { t1, t2 -> t1 + t2 }.toSingle()) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testToObservableFail() {\n        val c = GlobalScope.produce {\n            delay(50)\n            send(\"O\")\n            delay(50)\n            throw TestException(\"K\")\n        }\n        val observable = c.consumeAsFlow().asObservable()\n        val single = rxSingle(Dispatchers.Unconfined) {\n            var result = \"\"\n            try {\n                observable.collect { result += it }\n            } catch(e: Throwable) {\n                check(e is TestException)\n                result += e.message\n            }\n            result\n        }\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/FlowAsFlowableTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.Test\nimport org.reactivestreams.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\n@Suppress(\"ReactiveStreamsSubscriberImplementation\")\nclass FlowAsFlowableTest : TestBase() {\n    @Test\n    fun testUnconfinedDefaultContext() {\n        expect(1)\n        val thread = Thread.currentThread()\n        fun checkThread() {\n            assertSame(thread, Thread.currentThread())\n        }\n        flowOf(42).asFlowable().subscribe(object : Subscriber<Int> {\n            private lateinit var subscription: Subscription\n\n            override fun onSubscribe(s: Subscription) {\n                expect(2)\n                subscription = s\n                subscription.request(2)\n            }\n\n            override fun onNext(t: Int) {\n                checkThread()\n                expect(3)\n                assertEquals(42, t)\n            }\n\n            override fun onComplete() {\n                checkThread()\n                expect(4)\n            }\n\n            override fun onError(t: Throwable?) {\n                expectUnreached()\n            }\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testConfinedContext() {\n        expect(1)\n        val threadName = \"FlowAsFlowableTest.testConfinedContext\"\n        fun checkThread() {\n            val currentThread = Thread.currentThread()\n            assertTrue(currentThread.name.startsWith(threadName), \"Unexpected thread $currentThread\")\n        }\n        val completed = CountDownLatch(1)\n        newSingleThreadContext(threadName).use { dispatcher ->\n            flowOf(42).asFlowable(dispatcher).subscribe(object : Subscriber<Int> {\n                private lateinit var subscription: Subscription\n\n                override fun onSubscribe(s: Subscription) {\n                    expect(2)\n                    subscription = s\n                    subscription.request(2)\n                }\n\n                override fun onNext(t: Int) {\n                    checkThread()\n                    expect(3)\n                    assertEquals(42, t)\n                }\n\n                override fun onComplete() {\n                    checkThread()\n                    expect(4)\n                    completed.countDown()\n                }\n\n                override fun onError(t: Throwable?) {\n                    expectUnreached()\n                }\n            })\n            completed.await()\n        }\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/FlowAsObservableTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass FlowAsObservableTest : TestBase() {\n    @Test\n    fun testBasicSuccess() = runTest {\n        expect(1)\n        val observable = flow {\n            expect(3)\n            emit(\"OK\")\n        }.asObservable()\n\n        expect(2)\n        observable.subscribe { value ->\n            expect(4)\n            assertEquals(\"OK\", value)\n        }\n\n        finish(5)\n    }\n\n    @Test\n    fun testBasicFailure() = runTest {\n        expect(1)\n        val observable = flow<Int> {\n            expect(3)\n            throw RuntimeException(\"OK\")\n        }.asObservable()\n\n        expect(2)\n        observable.subscribe({ expectUnreached() }, { error ->\n            expect(4)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testBasicUnsubscribe() = runTest {\n        expect(1)\n        val observable = flow<Int> {\n            expect(3)\n            hang {\n                expect(4)\n            }\n        }.asObservable()\n\n        expect(2)\n        val sub = observable.subscribe({ expectUnreached() }, { expectUnreached() })\n        sub.dispose() // will cancel coroutine\n        finish(5)\n    }\n\n    @Test\n    fun testNotifyOnceOnCancellation() = runTest {\n        val observable =\n            flow {\n                expect(3)\n                emit(\"OK\")\n                hang {\n                    expect(7)\n                }\n            }.asObservable()\n                .doOnNext {\n                    expect(4)\n                    assertEquals(\"OK\", it)\n                }\n                .doOnDispose {\n                    expect(6) // notified once!\n                }\n\n        expect(1)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(2)\n            observable.collect {\n                expect(5)\n                assertEquals(\"OK\", it)\n            }\n        }\n\n        yield()\n        job.cancelAndJoin()\n        finish(8)\n    }\n\n    @Test\n    fun testFailingConsumer() = runTest {\n        expect(1)\n        val observable = flow {\n            expect(2)\n            emit(\"OK\")\n            hang {\n                expect(4)\n            }\n\n        }.asObservable()\n\n        try {\n            observable.collect {\n                expect(3)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            finish(5)\n        }\n    }\n\n    @Test\n    fun testNonAtomicStart() = runTest {\n        withContext(Dispatchers.Unconfined) {\n            val observable = flow<Int> {\n                expect(1)\n            }.asObservable()\n\n            val disposable = observable.subscribe({ expectUnreached() }, { expectUnreached() }, { expectUnreached() })\n            disposable.dispose()\n        }\n        finish(2)\n    }\n\n    @Test\n    fun testFlowCancelledFromWithin() = runTest {\n        val observable = flow {\n            expect(1)\n            emit(1)\n            kotlin.coroutines.coroutineContext.cancel()\n            kotlin.coroutines.coroutineContext.ensureActive()\n            expectUnreached()\n        }.asObservable()\n\n        observable.subscribe({ expect(2) }, { expectUnreached() }, { finish(3) })\n    }\n\n    @Test\n    fun testUnconfinedDefaultContext() {\n        expect(1)\n        val thread = Thread.currentThread()\n        fun checkThread() {\n            assertSame(thread, Thread.currentThread())\n        }\n        flowOf(42).asObservable().subscribe(object : Observer<Int> {\n            override fun onSubscribe(d: Disposable) {\n                expect(2)\n            }\n\n            override fun onNext(t: Int) {\n                checkThread()\n                expect(3)\n                assertEquals(42, t)\n            }\n\n            override fun onComplete() {\n                checkThread()\n                expect(4)\n            }\n\n            override fun onError(t: Throwable) {\n                expectUnreached()\n            }\n        })\n        finish(5)\n    }\n\n    @Test\n    fun testConfinedContext() {\n        expect(1)\n        val threadName = \"FlowAsObservableTest.testConfinedContext\"\n        fun checkThread() {\n            val currentThread = Thread.currentThread()\n            assertTrue(currentThread.name.startsWith(threadName), \"Unexpected thread $currentThread\")\n        }\n        val completed = CountDownLatch(1)\n        newSingleThreadContext(threadName).use { dispatcher ->\n            flowOf(42).asObservable(dispatcher).subscribe(object : Observer<Int> {\n                override fun onSubscribe(d: Disposable) {\n                    expect(2)\n                }\n\n                override fun onNext(t: Int) {\n                    checkThread()\n                    expect(3)\n                    assertEquals(42, t)\n                }\n\n                override fun onComplete() {\n                    checkThread()\n                    expect(4)\n                    completed.countDown()\n                }\n\n                override fun onError(e: Throwable) {\n                    expectUnreached()\n                }\n            })\n            completed.await()\n        }\n        finish(5)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/FlowableContextTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass FlowableContextTest : TestBase() {\n    private val dispatcher = newSingleThreadContext(\"FlowableContextTest\")\n\n    @After\n    fun tearDown() {\n        dispatcher.close()\n    }\n\n    @Test\n    fun testFlowableCreateAsFlowThread() = runTest {\n        expect(1)\n        val mainThread = Thread.currentThread()\n        val dispatcherThread = withContext(dispatcher) { Thread.currentThread() }\n        assertTrue(dispatcherThread != mainThread)\n        Flowable.create<String>({\n            assertEquals(dispatcherThread, Thread.currentThread())\n            it.onNext(\"OK\")\n            it.onComplete()\n        }, BackpressureStrategy.BUFFER)\n            .asFlow()\n            .flowOn(dispatcher)\n            .collect {\n                expect(2)\n                assertEquals(\"OK\", it)\n                assertEquals(mainThread, Thread.currentThread())\n            }\n        finish(3)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/FlowableExceptionHandlingTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.exceptions.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass FlowableExceptionHandlingTest : TestBase() {\n\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    private inline fun <reified T : Throwable> handler(expect: Int) = { t: Throwable ->\n        assertTrue(t is UndeliverableException && t.cause is T)\n        expect(expect)\n    }\n\n    private fun cehUnreached() = CoroutineExceptionHandler { _, _ -> expectUnreached() }\n\n    @Test\n    fun testException() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable<Int>(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            throw TestException()\n        }.subscribe({\n            expectUnreached()\n        }, {\n            expect(2) // Reported to onError\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalException() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable<Int>(Dispatchers.Unconfined) {\n            expect(1)\n            throw LinkageError()\n        }.subscribe({\n            expectUnreached()\n        }, {\n            expect(2) // Fatal exceptions are not treated as special\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable<Int>(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            throw TestException()\n        }.publish()\n            .refCount()\n            .subscribe({\n                expectUnreached()\n            }, {\n                expect(2) // Reported to onError\n            })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable<Int>(Dispatchers.Unconfined) {\n            expect(1)\n            throw LinkageError()\n        }.publish()\n            .refCount()\n            .subscribe({\n                expectUnreached()\n            }, {\n                expect(2)\n            })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>(3)) {\n        rxFlowable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.subscribe({\n            expect(2)\n            throw LinkageError()\n        }, { expectUnreached() }) // Fatal exception is rethrown from `onNext` => the subscription is thought to be cancelled\n        finish(4)\n    }\n\n    @Test\n    fun testExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            send(Unit)\n        }.subscribe({\n            expect(2)\n            throw TestException()\n        }, { expect(3) }) // not reported to onError because came from the subscribe itself\n        finish(4)\n    }\n\n    @Test\n    fun testAsynchronousExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {\n        rxFlowable(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            send(Unit)\n        }.publish()\n            .refCount()\n            .subscribe({\n                expect(2)\n                throw RuntimeException()\n            }, { expect(3) })\n        finish(4)\n    }\n\n    @Test\n    fun testAsynchronousFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>(3)) {\n        rxFlowable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.publish()\n            .refCount()\n            .subscribe({\n                expect(2)\n                throw LinkageError()\n            }, { expectUnreached() })\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/FlowableTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass FlowableTest : TestBase() {\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val observable = rxFlowable(currentDispatcher()) {\n            expect(4)\n            send(\"OK\")\n        }\n        expect(2)\n        observable.subscribe { value ->\n            expect(5)\n            assertEquals(\"OK\", value)\n        }\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val observable = rxFlowable<String>(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        observable.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val observable = rxFlowable<String>(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n        }\n        expect(2)\n        val sub = observable.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testNotifyOnceOnCancellation() = runTest {\n        expect(1)\n        val observable =\n            rxFlowable(currentDispatcher()) {\n                expect(5)\n                send(\"OK\")\n                try {\n                    delay(Long.MAX_VALUE)\n                } catch (e: CancellationException) {\n                    expect(11)\n                }\n            }\n            .doOnNext {\n                expect(6)\n                assertEquals(\"OK\", it)\n            }\n            .doOnCancel {\n                expect(10) // notified once!\n            }\n        expect(2)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(3)\n            observable.collect {\n                expect(8)\n                assertEquals(\"OK\", it)\n            }\n        }\n        expect(4)\n        yield() // to observable code\n        expect(7)\n        yield() // to consuming coroutines\n        expect(9)\n        job.cancel()\n        job.join()\n        finish(12)\n    }\n\n    @Test\n    fun testFailingConsumer() = runTest {\n        val pub = rxFlowable(currentDispatcher()) {\n            repeat(3) {\n                expect(it + 1) // expect(1), expect(2) *should* be invoked\n                send(it)\n            }\n        }\n        try {\n            pub.collect {\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            finish(3)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/IntegrationTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.consumeAsFlow\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.junit.runners.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\n@RunWith(Parameterized::class)\nclass IntegrationTest(\n    private val ctx: Ctx,\n    private val delay: Boolean\n) : TestBase() {\n\n    enum class Ctx {\n        MAIN        { override fun invoke(context: CoroutineContext): CoroutineContext = context.minusKey(Job) },\n        DEFAULT     { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Default },\n        UNCONFINED  { override fun invoke(context: CoroutineContext): CoroutineContext = Dispatchers.Unconfined };\n\n        abstract operator fun invoke(context: CoroutineContext): CoroutineContext\n    }\n\n    companion object {\n        @Parameterized.Parameters(name = \"ctx={0}, delay={1}\")\n        @JvmStatic\n        fun params(): Collection<Array<Any>> = Ctx.values().flatMap { ctx ->\n            listOf(false, true).map { delay ->\n                arrayOf(ctx, delay)\n            }\n        }\n    }\n\n    @Test\n    fun testEmpty(): Unit = runBlocking {\n        val observable = rxObservable<String>(ctx(coroutineContext)) {\n            if (delay) delay(1)\n            // does not send anything\n        }\n        assertFailsWith<NoSuchElementException> { observable.awaitFirst() }\n        assertEquals(\"OK\", observable.awaitFirstOrDefault(\"OK\"))\n        assertNull(observable.awaitFirstOrNull())\n        assertEquals(\"ELSE\", observable.awaitFirstOrElse { \"ELSE\" })\n        assertFailsWith<NoSuchElementException> { observable.awaitLast() }\n        assertFailsWith<NoSuchElementException> { observable.awaitSingle() }\n        var cnt = 0\n        observable.collect {\n            cnt++\n        }\n        assertEquals(0, cnt)\n    }\n\n    @Test\n    fun testSingle() = runBlocking {\n        val observable = rxObservable(ctx(coroutineContext)) {\n            if (delay) delay(1)\n            send(\"OK\")\n        }\n        assertEquals(\"OK\", observable.awaitFirst())\n        assertEquals(\"OK\", observable.awaitFirstOrDefault(\"OK\"))\n        assertEquals(\"OK\", observable.awaitFirstOrNull())\n        assertEquals(\"OK\", observable.awaitFirstOrElse { \"ELSE\" })\n        assertEquals(\"OK\", observable.awaitLast())\n        assertEquals(\"OK\", observable.awaitSingle())\n        var cnt = 0\n        observable.collect {\n            assertEquals(\"OK\", it)\n            cnt++\n        }\n        assertEquals(1, cnt)\n    }\n\n    @Test\n    fun testNumbers() = runBlocking<Unit> {\n        val n = 100 * stressTestMultiplier\n        val observable = rxObservable(ctx(coroutineContext)) {\n            for (i in 1..n) {\n                send(i)\n                if (delay) delay(1)\n            }\n        }\n        assertEquals(1, observable.awaitFirst())\n        assertEquals(1, observable.awaitFirstOrDefault(0))\n        assertEquals(1, observable.awaitFirstOrNull())\n        assertEquals(1, observable.awaitFirstOrElse { 0 })\n        assertEquals(n, observable.awaitLast())\n        assertFailsWith<IllegalArgumentException> { observable.awaitSingle() }\n        checkNumbers(n, observable)\n        val channel = observable.openSubscription()\n        ctx(coroutineContext)\n        checkNumbers(n, channel.consumeAsFlow().asObservable())\n        channel.cancel()\n    }\n\n    @Test\n    fun testCancelWithoutValue() = runTest {\n        val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {\n            rxObservable<String> {\n                hang {  }\n            }.awaitFirst()\n        }\n\n        job.cancel()\n        job.join()\n    }\n\n    @Test\n    fun testEmptySingle() = runTest(unhandled = listOf({e -> e is NoSuchElementException})) {\n        expect(1)\n        val job = launch(Job(), start = CoroutineStart.UNDISPATCHED) {\n            rxObservable<String> {\n                yield()\n                expect(2)\n                // Nothing to emit\n            }.awaitFirst()\n        }\n\n        job.join()\n        finish(3)\n    }\n\n    @Test\n    fun testObservableWithTimeout() = runTest {\n        val observable = rxObservable<Int> {\n            expect(2)\n            withTimeout(1) { delay(100) }\n        }\n        try {\n            expect(1)\n            observable.awaitFirstOrNull()\n        } catch (e: CancellationException) {\n            expect(3)\n        }\n        finish(4)\n    }\n\n    private suspend fun checkNumbers(n: Int, observable: Observable<Int>) {\n        var last = 0\n        observable.collect {\n            assertEquals(++last, it)\n        }\n        assertEquals(n, last)\n    }\n\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/IterableFlowAsFlowableTckTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.*\nimport org.reactivestreams.*\nimport org.reactivestreams.tck.*\n\nclass IterableFlowAsFlowableTckTest : PublisherVerification<Long>(TestEnvironment()) {\n\n    private fun generate(num: Long): Array<Long> {\n        return Array(if (num >= Integer.MAX_VALUE) 1000000 else num.toInt()) { it.toLong() }\n    }\n\n    override fun createPublisher(elements: Long): Flowable<Long> {\n        return generate(elements).asIterable().asFlow().asFlowable()\n    }\n\n    override fun createFailedPublisher(): Publisher<Long>? = null\n\n    @Ignore\n    override fun required_spec309_requestZeroMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() {\n    }\n\n    @Ignore\n    override fun required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() {\n        //\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/LeakedExceptionTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.exceptions.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.reactive.*\nimport org.junit.Test\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\nimport kotlin.test.*\n\n// Check that exception is not leaked to the global exception handler\nclass LeakedExceptionTest : TestBase() {\n\n    private val handler: (Throwable) -> Unit =\n        { assertTrue { it is UndeliverableException && it.cause is TestException } }\n\n    @Test\n    fun testSingle() = withExceptionHandler(handler) {\n        withFixedThreadPool(4) { dispatcher ->\n            val flow = rxSingle<Unit>(dispatcher) { throw TestException() }.toFlowable().asFlow()\n            runBlocking {\n                repeat(10000) {\n                    combine(flow, flow) { _, _ -> Unit }\n                        .catch {}\n                        .collect {}\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testObservable() = withExceptionHandler(handler) {\n        withFixedThreadPool(4) { dispatcher ->\n            val flow = rxObservable<Unit>(dispatcher) { throw TestException() }\n                .toFlowable(BackpressureStrategy.BUFFER)\n                .asFlow()\n            runBlocking {\n                repeat(10000) {\n                    combine(flow, flow) { _, _ -> Unit }\n                        .catch {}\n                        .collect {}\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testFlowable() = withExceptionHandler(handler) {\n        withFixedThreadPool(4) { dispatcher ->\n            val flow = rxFlowable<Unit>(dispatcher) { throw TestException() }.asFlow()\n            runBlocking {\n                repeat(10000) {\n                    combine(flow, flow) { _, _ -> Unit }\n                        .catch {}\n                        .collect {}\n                }\n            }\n        }\n    }\n\n    /**\n     * This test doesn't test much and was added to display a problem with straighforward use of\n     * [withExceptionHandler].\n     *\n     * If one was to remove `dispatcher` and launch `rxFlowable` with an empty coroutine context,\n     * this test would fail fairly often, while other tests were also vulnerable, but the problem is\n     * much more difficult to reproduce. Thus, this test is a justification for adding `dispatcher`\n     * to other tests.\n     *\n     * See the commit that introduced this test for a better explanation.\n     */\n    @Test\n    fun testResettingExceptionHandler() = withExceptionHandler(handler) {\n        withFixedThreadPool(4) { dispatcher ->\n            val flow = rxFlowable<Unit>(dispatcher) {\n                if ((0..1).random() == 0) {\n                    Thread.sleep(100)\n                }\n                throw TestException()\n            }.asFlow()\n            runBlocking {\n                combine(flow, flow) { _, _ -> Unit }\n                    .catch {}\n                    .collect {}\n            }\n        }\n    }\n\n    /**\n     * Run in a thread pool, then wait for all the tasks to finish.\n     */\n    private fun withFixedThreadPool(numberOfThreads: Int, block: (CoroutineDispatcher) -> Unit) {\n        val pool = Executors.newFixedThreadPool(numberOfThreads)\n        val dispatcher = pool.asCoroutineDispatcher()\n        block(dispatcher)\n        pool.shutdown()\n        while (!pool.awaitTermination(10, TimeUnit.SECONDS)) {\n            /* deliberately empty */\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/MaybeTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.*\nimport io.reactivex.rxjava3.exceptions.*\nimport io.reactivex.rxjava3.internal.functions.Functions.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass MaybeTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            \"OK\"\n        }\n        expect(2)\n        maybe.subscribe { value ->\n            expect(5)\n            assertEquals(\"OK\", value)\n        }\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicEmpty() = runBlocking {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            null\n        }\n        expect(2)\n        maybe.subscribe (emptyConsumer(), ON_ERROR_MISSING, {\n            expect(5)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        maybe.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n        }\n        expect(2)\n        // nothing is called on a disposed rx2 maybe\n        val sub = maybe.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testMaybeNoWait() {\n        val maybe = rxMaybe {\n            \"OK\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testMaybeAwait() = runBlocking {\n        assertEquals(\"OK\", Maybe.just(\"O\").awaitSingleOrNull() + \"K\")\n        assertEquals(\"OK\", Maybe.just(\"O\").awaitSingle() + \"K\")\n    }\n\n    @Test\n    fun testMaybeAwaitForNull(): Unit = runBlocking {\n        assertNull(Maybe.empty<String>().awaitSingleOrNull())\n        assertFailsWith<NoSuchElementException> { Maybe.empty<String>().awaitSingle() }\n    }\n\n    /** Tests that calls to [awaitSingleOrNull] throw [CancellationException] and dispose of the subscription when their\n     * [Job] is cancelled. */\n    @Test\n    fun testMaybeAwaitCancellation() = runTest {\n        expect(1)\n        val maybe = MaybeSource<Int> { s ->\n            s.onSubscribe(object: Disposable {\n                override fun dispose() { expect(4) }\n                override fun isDisposed(): Boolean { expectUnreached(); return false }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                maybe.awaitSingleOrNull()\n            } catch (e: CancellationException) {\n                expect(5)\n                throw e\n            }\n        }\n        expect(3)\n        job.cancelAndJoin()\n        finish(6)\n    }\n\n    @Test\n    fun testMaybeEmitAndAwait() {\n        val maybe = rxMaybe {\n            Maybe.just(\"O\").awaitSingleOrNull() + \"K\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testMaybeWithDelay() {\n        val maybe = rxMaybe {\n            Observable.timer(50, TimeUnit.MILLISECONDS).map { \"O\" }.awaitSingle() + \"K\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testMaybeException() {\n        val maybe = rxMaybe {\n            Observable.just(\"O\", \"K\").awaitSingle() + \"K\"\n        }\n\n        checkErroneous(maybe) {\n            assert(it is IllegalArgumentException)\n        }\n    }\n\n    @Test\n    fun testAwaitFirst() {\n        val maybe = rxMaybe {\n            Observable.just(\"O\", \"#\").awaitFirst() + \"K\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitLast() {\n        val maybe = rxMaybe {\n            Observable.just(\"#\", \"O\").awaitLast() + \"K\"\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromObservable() {\n        val maybe = rxMaybe {\n            try {\n                Observable.error<String>(RuntimeException(\"O\")).awaitFirst()\n            } catch (e: RuntimeException) {\n                Observable.just(e.message!!).awaitLast() + \"K\"\n            }\n        }\n\n        checkMaybeValue(maybe) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromCoroutine() {\n        val maybe = rxMaybe<String> {\n            throw IllegalStateException(Observable.just(\"O\").awaitSingle() + \"K\")\n        }\n\n        checkErroneous(maybe) {\n            assert(it is IllegalStateException)\n            assertEquals(\"OK\", it.message)\n        }\n    }\n\n    @Test\n    fun testCancelledConsumer() = runTest {\n        expect(1)\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            try {\n                delay(Long.MAX_VALUE)\n            } catch (e: CancellationException) {\n                expect(6)\n            }\n            42\n        }\n        expect(2)\n        val timeout = withTimeoutOrNull(100) {\n            expect(3)\n            maybe.collect {\n                expectUnreached()\n            }\n            expectUnreached()\n        }\n        assertNull(timeout)\n        expect(5)\n        yield() // must cancel code inside maybe!!!\n        finish(7)\n    }\n\n    /** Tests the simple scenario where the Maybe doesn't output a value. */\n    @Test\n    fun testMaybeCollectEmpty() = runTest {\n        expect(1)\n        Maybe.empty<Int>().collect {\n            expectUnreached()\n        }\n        finish(2)\n    }\n\n    /** Tests the simple scenario where the Maybe doesn't output a value. */\n    @Test\n    fun testMaybeCollectSingle() = runTest {\n        expect(1)\n        Maybe.just(\"OK\").collect {\n            assertEquals(\"OK\", it)\n            expect(2)\n        }\n        finish(3)\n    }\n\n    /** Tests the behavior of [collect] when the Maybe raises an error. */\n    @Test\n    fun testMaybeCollectThrowingMaybe() = runTest {\n        expect(1)\n        try {\n            Maybe.error<Int>(TestException()).collect {\n                expectUnreached()\n            }\n        } catch (e: TestException) {\n            expect(2)\n        }\n        finish(3)\n    }\n\n    /** Tests the behavior of [collect] when the action throws. */\n    @Test\n    fun testMaybeCollectThrowingAction() = runTest {\n        expect(1)\n        try {\n            Maybe.just(\"OK\").collect {\n                expect(2)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            expect(3)\n        }\n        finish(4)\n    }\n\n    @Test\n    fun testSuppressedException() = runTest {\n        val maybe = rxMaybe(currentDispatcher()) {\n            launch(start = CoroutineStart.ATOMIC) {\n                throw TestException() // child coroutine fails\n            }\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException2() // but parent throws another exception while cleaning up\n            }\n        }\n        try {\n            maybe.awaitSingleOrNull()\n            expectUnreached()\n        } catch (e: TestException) {\n            assertIs<TestException2>(e.suppressed[0])\n        }\n    }\n\n    @Test\n    fun testUnhandledException() = runTest {\n        expect(1)\n        var disposable: Disposable? = null\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is TestException)\n            expect(5)\n        }\n        val maybe = rxMaybe(currentDispatcher()) {\n            expect(4)\n            disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException() // would not be able to handle it since mono is disposed\n            }\n        }\n        withExceptionHandler(handler) {\n            maybe.subscribe(object : MaybeObserver<Unit> {\n                override fun onSubscribe(d: Disposable) {\n                    expect(2)\n                    disposable = d\n                }\n\n                override fun onComplete() {\n                    expectUnreached()\n                }\n\n                override fun onSuccess(t: Unit) {\n                    expectUnreached()\n                }\n\n                override fun onError(t: Throwable) {\n                    expectUnreached()\n                }\n            })\n            expect(3)\n            yield() // run coroutine\n            finish(6)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSubscribe() = runTest {\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is LinkageError)\n            expect(2)\n        }\n\n        withExceptionHandler(handler) {\n            rxMaybe(Dispatchers.Unconfined) {\n                expect(1)\n                42\n            }.subscribe { throw LinkageError() }\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSingle() = runTest {\n        rxMaybe(Dispatchers.Unconfined) {\n            throw LinkageError()\n        }.subscribe({ expectUnreached()  }, { expect(1); assertIs<LinkageError>(it) })\n        finish(2)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ObservableAsFlowTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.Observable\nimport io.reactivex.rxjava3.core.ObservableSource\nimport io.reactivex.rxjava3.core.Observer\nimport io.reactivex.rxjava3.disposables.Disposable\nimport io.reactivex.rxjava3.subjects.PublishSubject\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.testing.flow.*\nimport kotlin.test.*\n\nclass ObservableAsFlowTest : TestBase() {\n    @Test\n    fun testCancellation() = runTest {\n        var onNext = 0\n        var onCancelled = 0\n        var onError = 0\n\n        val source = rxObservable(currentDispatcher()) {\n            coroutineContext[Job]?.invokeOnCompletion {\n                if (it is CancellationException) ++onCancelled\n            }\n\n            repeat(100) {\n                send(it)\n            }\n        }\n\n        source.asFlow().launchIn(CoroutineScope(Dispatchers.Unconfined)) {\n            onEach {\n                ++onNext\n                throw RuntimeException()\n            }\n            catch<Throwable> {\n                ++onError\n            }\n        }.join()\n\n\n        assertEquals(1, onNext)\n        assertEquals(1, onError)\n        assertEquals(1, onCancelled)\n    }\n\n    @Test\n    fun testImmediateCollection() {\n        val source = PublishSubject.create<Int>()\n        val flow = source.asFlow()\n        GlobalScope.launch(Dispatchers.Unconfined) {\n            expect(1)\n            flow.collect { expect(it) }\n            expect(6)\n        }\n        expect(2)\n        source.onNext(3)\n        expect(4)\n        source.onNext(5)\n        source.onComplete()\n        finish(7)\n    }\n\n    @Test\n    fun testOnErrorCancellation() {\n        val source = PublishSubject.create<Int>()\n        val flow = source.asFlow()\n        val exception = RuntimeException()\n        GlobalScope.launch(Dispatchers.Unconfined) {\n            try {\n                expect(1)\n                flow.collect { expect(it) }\n                expectUnreached()\n            }\n            catch (e: Exception) {\n                assertSame(exception, e.cause)\n                expect(5)\n            }\n            expect(6)\n        }\n        expect(2)\n        source.onNext(3)\n        expect(4)\n        source.onError(exception)\n        finish(7)\n    }\n\n    @Test\n    fun testUnsubscribeOnCollectionException() {\n        val source = PublishSubject.create<Int>()\n        val flow = source.asFlow()\n        val exception = RuntimeException()\n        GlobalScope.launch(Dispatchers.Unconfined) {\n            try {\n                expect(1)\n                flow.collect {\n                    expect(it)\n                    if (it == 3) throw exception\n                }\n                expectUnreached()\n            }\n            catch (e: Exception) {\n                assertSame(exception, e.cause)\n                expect(4)\n            }\n            expect(5)\n        }\n        expect(2)\n        assertTrue(source.hasObservers())\n        source.onNext(3)\n        assertFalse(source.hasObservers())\n        finish(6)\n    }\n\n    @Test\n    fun testLateOnSubscribe() {\n        var observer: Observer<in Int>? = null\n        val source = ObservableSource<Int> { observer = it }\n        val flow = source.asFlow()\n        assertNull(observer)\n        val job = GlobalScope.launch(Dispatchers.Unconfined) {\n            expect(1)\n            flow.collect { expectUnreached() }\n            expectUnreached()\n        }\n        expect(2)\n        assertNotNull(observer)\n        job.cancel()\n        val disposable = Disposable.empty()\n        observer!!.onSubscribe(disposable)\n        assertTrue(disposable.isDisposed)\n        finish(3)\n    }\n\n    @Test\n    fun testBufferUnlimited() = runTest {\n        val source = rxObservable(currentDispatcher()) {\n            expect(1); send(10)\n            expect(2); send(11)\n            expect(3); send(12)\n            expect(4); send(13)\n            expect(5); send(14)\n            expect(6); send(15)\n            expect(7); send(16)\n            expect(8); send(17)\n            expect(9)\n        }\n        source.asFlow().buffer(Channel.UNLIMITED).collect { expect(it) }\n        finish(18)\n    }\n\n    @Test\n    fun testConflated() = runTest {\n        val source = Observable.range(1, 5)\n        val list = source.asFlow().conflate().toList()\n        assertEquals(listOf(1, 5), list)\n    }\n\n    @Test\n    fun testLongRange() = runTest {\n        val source = Observable.range(1, 10_000)\n        val count = source.asFlow().count()\n        assertEquals(10_000, count)\n    }\n\n    @Test\n    fun testProduce() = runTest {\n        val source = Observable.range(0, 10)\n        val flow = source.asFlow()\n        check((0..9).toList(), flow.produceIn(this))\n        check((0..9).toList(), flow.buffer(Channel.UNLIMITED).produceIn(this))\n        check((0..9).toList(), flow.buffer(2).produceIn(this))\n        check((0..9).toList(), flow.buffer(0).produceIn(this))\n        check(listOf(0, 9), flow.conflate().produceIn(this))\n    }\n\n    private suspend fun check(expected: List<Int>, channel: ReceiveChannel<Int>) {\n        val result = ArrayList<Int>(10)\n        channel.consumeEach { result.add(it) }\n        assertEquals(expected, result)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ObservableCollectTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.ObservableSource\nimport io.reactivex.rxjava3.disposables.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass ObservableCollectTest: TestBase() {\n\n    /** Tests the behavior of [collect] when the publisher raises an error. */\n    @Test\n    fun testObservableCollectThrowingObservable() = runTest {\n        expect(1)\n        var sum = 0\n        try {\n            rxObservable {\n                for (i in 0..100) {\n                    send(i)\n                }\n                throw TestException()\n            }.collect {\n                sum += it\n            }\n        } catch (e: TestException) {\n            assertTrue(sum > 0)\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testObservableCollectThrowingAction() = runTest {\n        expect(1)\n        var sum = 0\n        val expectedSum = 5\n        try {\n            var disposed = false\n            ObservableSource<Int> { observer ->\n                launch(Dispatchers.Default) {\n                    observer.onSubscribe(object : Disposable {\n                        override fun dispose() {\n                            disposed = true\n                            expect(expectedSum + 2)\n                        }\n\n                        override fun isDisposed(): Boolean = disposed\n                    })\n                    while (!disposed) {\n                        observer.onNext(1)\n                    }\n                }\n            }.collect {\n                expect(sum + 2)\n                sum += it\n                if (sum == expectedSum) {\n                    throw TestException()\n                }\n            }\n        } catch (e: TestException) {\n            assertEquals(expectedSum, sum)\n            finish(expectedSum + 3)\n        }\n    }\n}"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ObservableCompletionStressTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.*\nimport kotlin.coroutines.*\n\nclass ObservableCompletionStressTest : TestBase() {\n    private val N_REPEATS = 10_000 * stressTestMultiplier\n\n    private fun CoroutineScope.range(context: CoroutineContext, start: Int, count: Int) = rxObservable(context) {\n        for (x in start until start + count) send(x)\n    }\n\n    @Test\n    fun testCompletion() {\n        val rnd = Random()\n        repeat(N_REPEATS) {\n            val count = rnd.nextInt(5)\n            runBlocking {\n                withTimeout(5000) {\n                    var received = 0\n                    range(Dispatchers.Default, 1, count).collect { x ->\n                        received++\n                        if (x != received) error(\"$x != $received\")\n                    }\n                    if (received != count) error(\"$received != $count\")\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ObservableExceptionHandlingTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.exceptions.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass ObservableExceptionHandlingTest : TestBase() {\n\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    private inline fun <reified T : Throwable> handler(expect: Int) = { t: Throwable ->\n        assertTrue(t is UndeliverableException && t.cause is T, \"$t\")\n        expect(expect)\n    }\n\n    private fun cehUnreached() = CoroutineExceptionHandler { _, _ -> expectUnreached() }\n\n    @Test\n    fun testException() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable<Int>(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            throw TestException()\n        }.subscribe({\n            expectUnreached()\n        }, {\n            expect(2) // Reported to onError\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalException() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable<Int>(Dispatchers.Unconfined + cehUnreached()) {\n            expect(1)\n            throw LinkageError()\n        }.subscribe({\n            expectUnreached()\n        }, {\n            expect(2)\n        })\n        finish(3)\n    }\n\n    @Test\n    fun testExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable<Int>(Dispatchers.Unconfined) {\n            expect(1)\n            throw TestException()\n        }.publish()\n            .refCount()\n            .subscribe({\n                expectUnreached()\n            }, {\n                expect(2) // Reported to onError\n            })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalExceptionAsynchronous() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable<Int>(Dispatchers.Unconfined) {\n            expect(1)\n            throw LinkageError()\n        }.publish()\n            .refCount()\n            .subscribe({\n                expectUnreached()\n            }, {\n                expect(2) // Fatal exceptions are not treated in a special manner\n            })\n        finish(3)\n    }\n\n    @Test\n    fun testFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>(3)) {\n        val latch = CountDownLatch(1)\n        rxObservable(Dispatchers.Unconfined) {\n            expect(1)\n            val result = trySend(Unit)\n            val exception = result.exceptionOrNull()\n            assertIs<UndeliverableException>(exception)\n            assertIs<LinkageError>(exception.cause)\n            assertTrue(isClosedForSend)\n            expect(4)\n            latch.countDown()\n        }.subscribe({\n            expect(2)\n            throw LinkageError()\n        }, { expectUnreached() }) // Unreached because RxJava bubbles up fatal exceptions, causing `onNext` to throw.\n        latch.await()\n        finish(5)\n    }\n\n    @Test\n    fun testExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.subscribe({\n            expect(2)\n            throw TestException()\n        }, { expect(3) })\n        finish(4)\n    }\n\n    @Test\n    fun testAsynchronousExceptionFromSubscribe() = withExceptionHandler({ expectUnreached() }) {\n        rxObservable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.publish()\n            .refCount()\n            .subscribe({\n                expect(2)\n                throw RuntimeException()\n            }, { expect(3) })\n        finish(4)\n    }\n\n    @Test\n    fun testAsynchronousFatalExceptionFromSubscribe() = withExceptionHandler(handler<LinkageError>(3)) {\n        rxObservable(Dispatchers.Unconfined) {\n            expect(1)\n            send(Unit)\n        }.publish()\n            .refCount()\n            .subscribe({\n                expect(2)\n                throw LinkageError()\n            }, { expectUnreached() }) // Unreached because RxJava bubbles up fatal exceptions, causing `onNext` to throw.\n        finish(4)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ObservableMultiTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.Test\nimport java.io.*\nimport kotlin.test.*\n\n/**\n * Test emitting multiple values with [rxObservable].\n */\nclass ObservableMultiTest : TestBase() {\n    @Test\n    fun testNumbers() {\n        val n = 100 * stressTestMultiplier\n        val observable = rxObservable {\n            repeat(n) { send(it) }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals((0 until n).toList(), list)\n        }\n    }\n\n\n    @Test\n    fun testConcurrentStress() {\n        val n = 10_000 * stressTestMultiplier\n        val observable = rxObservable {\n            newCoroutineContext(coroutineContext)\n            // concurrent emitters (many coroutines)\n            val jobs = List(n) {\n                // launch\n                launch(Dispatchers.Default) {\n                    val i = it\n                    send(i)\n                }\n            }\n            jobs.forEach { it.join() }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals(n, list.size)\n            assertEquals((0 until n).toList(), list.sorted())\n        }\n    }\n\n    @Test\n    fun testConcurrentStressOnSend() {\n        val n = 10_000 * stressTestMultiplier\n        val observable = rxObservable<Int> {\n            newCoroutineContext(coroutineContext)\n            // concurrent emitters (many coroutines)\n            val jobs = List(n) {\n                // launch\n                launch(Dispatchers.Default) {\n                    val i = it\n                    select<Unit> {\n                        onSend(i) {}\n                    }\n                }\n            }\n            jobs.forEach { it.join() }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals(n, list.size)\n            assertEquals((0 until n).toList(), list.sorted())\n        }\n    }\n\n    @Test\n    fun testIteratorResendUnconfined() {\n        val n = 10_000 * stressTestMultiplier\n        val observable = rxObservable(Dispatchers.Unconfined) {\n            Observable.range(0, n).collect { send(it) }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals((0 until n).toList(), list)\n        }\n    }\n\n    @Test\n    fun testIteratorResendPool() {\n        val n = 10_000 * stressTestMultiplier\n        val observable = rxObservable {\n            Observable.range(0, n).collect { send(it) }\n        }\n        checkSingleValue(observable.toList()) { list ->\n            assertEquals((0 until n).toList(), list)\n        }\n    }\n\n    @Test\n    fun testSendAndCrash() {\n        val observable = rxObservable {\n            send(\"O\")\n            throw IOException(\"K\")\n        }\n        val single = rxSingle {\n            var result = \"\"\n            try {\n                observable.collect { result += it }\n            } catch(e: IOException) {\n                result += e.message\n            }\n            result\n        }\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ObservableSingleTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass ObservableSingleTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testSingleNoWait() {\n        val observable = rxObservable {\n            send(\"OK\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleAwait() = runBlocking {\n        assertEquals(\"OK\", Observable.just(\"O\").awaitSingle() + \"K\")\n    }\n\n    @Test\n    fun testSingleEmitAndAwait() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\").awaitSingle() + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleWithDelay() {\n        val observable = rxObservable {\n            send(Observable.timer(50, TimeUnit.MILLISECONDS).map { \"O\" }.awaitSingle() + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleException() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\", \"K\").awaitSingle() + \"K\")\n        }\n\n        checkErroneous(observable) {\n            assertIs<IllegalArgumentException>(it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirst() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\", \"#\").awaitFirst() + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrDefault() {\n        val observable = rxObservable {\n            send(Observable.empty<String>().awaitFirstOrDefault(\"O\") + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrDefaultWithValues() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\", \"#\").awaitFirstOrDefault(\"!\") + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrNull() {\n        val observable = rxObservable {\n            send(Observable.empty<String>().awaitFirstOrNull() ?: \"OK\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrNullWithValues() {\n        val observable = rxObservable {\n            send((Observable.just(\"O\", \"#\").awaitFirstOrNull() ?: \"!\") + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrElse() {\n        val observable = rxObservable {\n            send(Observable.empty<String>().awaitFirstOrElse { \"O\" } + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitFirstOrElseWithValues() {\n        val observable = rxObservable {\n            send(Observable.just(\"O\", \"#\").awaitFirstOrElse { \"!\" } + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitLast() {\n        val observable = rxObservable {\n            send(Observable.just(\"#\", \"O\").awaitLast() + \"K\")\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    /** Tests that calls to [awaitFirst] (and, thus, the other methods) throw [CancellationException] and dispose of\n     * the subscription when their [Job] is cancelled. */\n    @Test\n    fun testAwaitCancellation() = runTest {\n        expect(1)\n        val observable = ObservableSource<Int> { s ->\n            s.onSubscribe(object: Disposable {\n                override fun dispose() { expect(4) }\n                override fun isDisposed(): Boolean { expectUnreached(); return false }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                observable.awaitFirst()\n            } catch (e: CancellationException) {\n                expect(5)\n                throw e\n            }\n        }\n        expect(3)\n        job.cancelAndJoin()\n        finish(6)\n    }\n\n\n    @Test\n    fun testExceptionFromObservable() {\n        val observable = rxObservable {\n            try {\n                send(Observable.error<String>(RuntimeException(\"O\")).awaitFirst())\n            } catch (e: RuntimeException) {\n                send(Observable.just(e.message!!).awaitLast() + \"K\")\n            }\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromCoroutine() {\n        val observable = rxObservable<String> {\n            throw IllegalStateException(Observable.just(\"O\").awaitSingle() + \"K\")\n        }\n\n        checkErroneous(observable) {\n            assertIs<IllegalStateException>(it)\n            assertEquals(\"OK\", it.message)\n        }\n    }\n\n    @Test\n    fun testObservableIteration() {\n        val observable = rxObservable {\n            var result = \"\"\n            Observable.just(\"O\", \"K\").collect { result += it }\n            send(result)\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testObservableIterationFailure() {\n        val observable = rxObservable {\n            try {\n                Observable.error<String>(RuntimeException(\"OK\")).collect { fail(\"Should not be here\") }\n                send(\"Fail\")\n            } catch (e: RuntimeException) {\n                send(e.message!!)\n            }\n        }\n\n        checkSingleValue(observable) {\n            assertEquals(\"OK\", it)\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ObservableSourceAsFlowStressTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.*\nimport java.util.concurrent.*\n\nclass ObservableSourceAsFlowStressTest : TestBase() {\n\n    private val iterations = 100 * stressTestMultiplierSqrt\n\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testAsFlowCancellation() = runTest {\n        repeat(iterations) {\n            val latch = Channel<Unit>(1)\n            var i = 0\n            val observable = Observable.interval(100L, TimeUnit.MICROSECONDS)\n                .doOnNext {  if (++i > 100) latch.trySend(Unit) }\n            val job = observable.asFlow().launchIn(CoroutineScope(Dispatchers.Default))\n            latch.receive()\n            job.cancelAndJoin()\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ObservableSubscriptionSelectTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.selects.*\nimport org.junit.Test\nimport kotlin.onSuccess\nimport kotlin.test.*\n\nclass ObservableSubscriptionSelectTest : TestBase() {\n    @Test\n    fun testSelect() = runTest {\n        // source with n ints\n        val n = 1000 * stressTestMultiplier\n        val source = rxObservable { repeat(n) { send(it) } }\n        var a = 0\n        var b = 0\n        // open two subs\n        val channelA = source.openSubscription()\n        val channelB = source.openSubscription()\n        loop@ while (true) {\n            val done: Int = select {\n                channelA.onReceiveCatching { result ->\n                    result.onSuccess { assertEquals(a++, it) }\n                    if (result.isSuccess) 1 else 0\n                }\n                channelB.onReceiveCatching { result ->\n                    result.onSuccess { assertEquals(b++, it) }\n                    if (result.isSuccess) 2 else 0\n                }\n            }\n            when (done) {\n                0 -> break@loop\n                1 -> {\n                    val r = channelB.receiveCatching().getOrNull()\n                    if (r != null) assertEquals(b++, r)\n                }\n                2 -> {\n                    val r = channelA.receiveCatching().getOrNull()\n                    if (r != null) assertEquals(a++, r)\n                }\n            }\n        }\n        channelA.cancel()\n        channelB.cancel()\n        // should receive one of them fully\n        assertTrue(a == n || b == n)\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/ObservableTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.plugins.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass ObservableTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val observable = rxObservable(currentDispatcher()) {\n            expect(4)\n            send(\"OK\")\n        }\n        expect(2)\n        observable.subscribe { value ->\n            expect(5)\n            assertEquals(\"OK\", value)\n        }\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val observable = rxObservable<String>(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        observable.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val observable = rxObservable<String>(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n        }\n        expect(2)\n        val sub = observable.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testNotifyOnceOnCancellation() = runTest {\n        expect(1)\n        val observable =\n            rxObservable(currentDispatcher()) {\n                expect(5)\n                send(\"OK\")\n                try {\n                    delay(Long.MAX_VALUE)\n                } catch (e: CancellationException) {\n                    expect(11)\n                }\n            }\n            .doOnNext {\n                expect(6)\n                assertEquals(\"OK\", it)\n            }\n            .doOnDispose {\n                expect(10) // notified once!\n            }\n        expect(2)\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            expect(3)\n            observable.collect {\n                expect(8)\n                assertEquals(\"OK\", it)\n            }\n        }\n        expect(4)\n        yield() // to observable code\n        expect(7)\n        yield() // to consuming coroutines\n        expect(9)\n        job.cancel()\n        job.join()\n        finish(12)\n    }\n\n    @Test\n    fun testFailingConsumer() = runTest {\n        expect(1)\n        val pub = rxObservable(currentDispatcher()) {\n            expect(2)\n            send(\"OK\")\n            try {\n                delay(Long.MAX_VALUE)\n            } catch (e: CancellationException) {\n                finish(5)\n            }\n        }\n        try {\n            pub.collect {\n                expect(3)\n                throw TestException()\n            }\n        } catch (e: TestException) {\n            expect(4)\n        }\n    }\n\n    @Test\n    fun testExceptionAfterCancellation() {\n        // Test that no exceptions were reported to the global EH (it will fail the test if so)\n        val handler = { e: Throwable ->\n            assertFalse(e is CancellationException)\n        }\n        withExceptionHandler(handler) {\n            RxJavaPlugins.setErrorHandler {\n                require(it !is CancellationException)\n            }\n            Observable\n                .interval(1, TimeUnit.MILLISECONDS)\n                .take(1000)\n                .switchMapSingle {\n                    rxSingle {\n                        timeBomb().await()\n                    }\n                }\n                .blockingSubscribe({}, {})\n        }\n    }\n\n    private fun timeBomb() = Single.timer(1, TimeUnit.MILLISECONDS).doOnSuccess { throw TestException() }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/SchedulerStressTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport java.util.concurrent.*\n\nclass SchedulerStressTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxCachedThreadScheduler-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    /**\n     * Test that we don't get an OOM if we schedule many jobs at once.\n     * It's expected that if you don't dispose you'd see an OOM error.\n     */\n    @Test\n    fun testSchedulerDisposed(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableDisposed(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerDisposed(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        val worker = scheduler.createWorker()\n        testRunnableDisposed(worker::schedule)\n    }\n\n    private suspend fun testRunnableDisposed(block: RxSchedulerBlockNoDelay) {\n        val n = 2000 * stressTestMultiplier\n        repeat(n) {\n            val a = ByteArray(1000000) //1MB\n            val disposable = block(Runnable {\n                keepMe(a)\n                expectUnreached()\n            })\n            disposable.dispose()\n            yield() // allow the scheduled task to observe that it was disposed\n        }\n    }\n\n    /**\n     * Test function that holds a reference. Used for testing OOM situations\n     */\n    private fun keepMe(a: ByteArray) {\n        Thread.sleep(a.size / (a.size + 1) + 10L)\n    }\n\n    /**\n     * Test that we don't get an OOM if we schedule many delayed jobs at once. It's expected that if you don't dispose that you'd\n     * see a OOM error.\n     */\n    @Test\n    fun testSchedulerDisposedDuringDelay(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableDisposedDuringDelay(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerDisposedDuringDelay(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        val worker = scheduler.createWorker()\n        testRunnableDisposedDuringDelay(worker::schedule)\n    }\n\n    private fun testRunnableDisposedDuringDelay(block: RxSchedulerBlockWithDelay) {\n        val n = 2000 * stressTestMultiplier\n        repeat(n) {\n            val a = ByteArray(1000000) //1MB\n            val delayMillis: Long = 10\n            val disposable = block(Runnable {\n                keepMe(a)\n                expectUnreached()\n            }, delayMillis, TimeUnit.MILLISECONDS)\n            disposable.dispose()\n        }\n    }\n}\n"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/SchedulerTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.*\nimport io.reactivex.rxjava3.plugins.*\nimport io.reactivex.rxjava3.schedulers.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.sync.*\nimport org.junit.*\nimport org.junit.Test\nimport java.lang.Runnable\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.AtomicReference\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\nclass SchedulerTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxCachedThreadScheduler-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testIoScheduler(): Unit = runTest {\n        expect(1)\n        val mainThread = Thread.currentThread()\n        withContext(Schedulers.io().asCoroutineDispatcher()) {\n            val t1 = Thread.currentThread()\n            assertNotSame(t1, mainThread)\n            expect(2)\n            delay(100)\n            val t2 = Thread.currentThread()\n            assertNotSame(t2, mainThread)\n            expect(3)\n        }\n        finish(4)\n    }\n\n    /** Tests [toString] implementations of [CoroutineDispatcher.asScheduler] and its [Scheduler.Worker]. */\n    @Test\n    fun testSchedulerToString() {\n        val name = \"Dispatchers.Default\"\n        val scheduler = Dispatchers.Default.asScheduler()\n        assertContains(scheduler.toString(), name)\n        val worker = scheduler.createWorker()\n        val activeWorkerName = worker.toString()\n        assertContains(worker.toString(), name)\n        worker.dispose()\n        val disposedWorkerName = worker.toString()\n        assertNotEquals(activeWorkerName, disposedWorkerName)\n    }\n\n    private fun runSchedulerTest(nThreads: Int = 1, action: (Scheduler) -> Unit) {\n        val future = CompletableFuture<Unit>()\n        try {\n            newFixedThreadPoolContext(nThreads, \"test\").use { dispatcher ->\n                RxJavaPlugins.setErrorHandler {\n                    if (!future.completeExceptionally(it)) {\n                        handleUndeliverableException(it, dispatcher)\n                    }\n                }\n                action(dispatcher.asScheduler())\n            }\n        } finally {\n            RxJavaPlugins.setErrorHandler(null)\n        }\n        future.complete(Unit)\n        future.getNow(Unit) // rethrow any encountered errors\n    }\n\n    private fun ensureSeparateThread(schedule: (Runnable, Long, TimeUnit) -> Unit, scheduleNoDelay: (Runnable) -> Unit) {\n        val mainThread = Thread.currentThread()\n        val cdl1 = CountDownLatch(1)\n        val cdl2 = CountDownLatch(1)\n        expect(1)\n        val thread = AtomicReference<Thread?>(null)\n        fun checkThread() {\n            val current = Thread.currentThread()\n            thread.getAndSet(current)?.let { assertEquals(it, current) }\n        }\n        schedule({\n            assertNotSame(mainThread, Thread.currentThread())\n            checkThread()\n            cdl2.countDown()\n        }, 300, TimeUnit.MILLISECONDS)\n        scheduleNoDelay {\n            expect(2)\n            checkThread()\n            assertNotSame(mainThread, Thread.currentThread())\n            cdl1.countDown()\n        }\n        cdl1.await()\n        cdl2.await()\n        finish(3)\n    }\n\n    /**\n     * Tests [Scheduler.scheduleDirect] for [CoroutineDispatcher.asScheduler] on a single-threaded dispatcher.\n     */\n    @Test\n    fun testSingleThreadedDispatcherDirect(): Unit = runSchedulerTest(1) {\n        ensureSeparateThread(it::scheduleDirect, it::scheduleDirect)\n    }\n\n    /**\n     * Tests [Scheduler.Worker.schedule] for [CoroutineDispatcher.asScheduler] running its tasks on the correct thread.\n     */\n    @Test\n    fun testSingleThreadedWorker(): Unit = runSchedulerTest(1) {\n        val worker = it.createWorker()\n        ensureSeparateThread(worker::schedule, worker::schedule)\n    }\n\n    private fun checkCancelling(schedule: (Runnable, Long, TimeUnit) -> Disposable) {\n        // cancel the task before it has a chance to run.\n        val handle1 = schedule({\n            throw IllegalStateException(\"should have been successfully cancelled\")\n        }, 10_000, TimeUnit.MILLISECONDS)\n        handle1.dispose()\n        // cancel the task after it started running.\n        val cdl1 = CountDownLatch(1)\n        val cdl2 = CountDownLatch(1)\n        val handle2 = schedule({\n            cdl1.countDown()\n            cdl2.await()\n            if (Thread.interrupted())\n                throw IllegalStateException(\"cancelling the task should not interrupt the thread\")\n        }, 100, TimeUnit.MILLISECONDS)\n        cdl1.await()\n        handle2.dispose()\n        cdl2.countDown()\n    }\n\n    /**\n     * Test cancelling [Scheduler.scheduleDirect] for [CoroutineDispatcher.asScheduler].\n     */\n    @Test\n    fun testCancellingDirect(): Unit = runSchedulerTest {\n        checkCancelling(it::scheduleDirect)\n    }\n\n    /**\n     * Test cancelling [Scheduler.Worker.schedule] for [CoroutineDispatcher.asScheduler].\n     */\n    @Test\n    fun testCancellingWorker(): Unit = runSchedulerTest {\n        val worker = it.createWorker()\n        checkCancelling(worker::schedule)\n    }\n\n    /**\n     * Test shutting down [CoroutineDispatcher.asScheduler].\n     */\n    @Test\n    fun testShuttingDown() {\n        val n = 5\n        runSchedulerTest(nThreads = n) { scheduler ->\n            val cdl1 = CountDownLatch(n)\n            val cdl2 = CountDownLatch(1)\n            val cdl3 = CountDownLatch(n)\n            repeat(n) {\n                scheduler.scheduleDirect {\n                    cdl1.countDown()\n                    try {\n                        cdl2.await()\n                    } catch (e: InterruptedException) {\n                        // this is the expected outcome\n                        cdl3.countDown()\n                    }\n                }\n            }\n            cdl1.await()\n            scheduler.shutdown()\n            if (!cdl3.await(1, TimeUnit.SECONDS)) {\n                cdl2.countDown()\n                error(\"the tasks were not cancelled when the scheduler was shut down\")\n            }\n        }\n    }\n\n    /** Tests that there are no uncaught exceptions if [Disposable.dispose] on a worker happens when tasks are present. */\n    @Test\n    fun testDisposingWorker() = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        val worker = scheduler.createWorker()\n        yield() // so that the worker starts waiting on the channel\n        assertFalse(worker.isDisposed)\n        worker.dispose()\n        assertTrue(worker.isDisposed)\n    }\n\n    /** Tests trying to use a [Scheduler.Worker]/[Scheduler] after [Scheduler.Worker.dispose]/[Scheduler.shutdown]. */\n    @Test\n    fun testSchedulingAfterDisposing() = runSchedulerTest {\n        expect(1)\n        val worker = it.createWorker()\n        // use CDL to ensure that the worker has properly initialized\n        val cdl1 = CountDownLatch(1)\n        setScheduler(2, 3)\n        val disposable1 = worker.schedule {\n            cdl1.countDown()\n        }\n        cdl1.await()\n        expect(4)\n        assertFalse(disposable1.isDisposed)\n        setScheduler(6, -1)\n        // check that the worker automatically disposes of the tasks after being disposed\n        assertFalse(worker.isDisposed)\n        worker.dispose()\n        assertTrue(worker.isDisposed)\n        expect(5)\n        val disposable2 = worker.schedule {\n            expectUnreached()\n        }\n        assertTrue(disposable2.isDisposed)\n        setScheduler(7, 8)\n        // ensure that the scheduler still works\n        val cdl2 = CountDownLatch(1)\n        val disposable3 = it.scheduleDirect {\n            cdl2.countDown()\n        }\n        cdl2.await()\n        expect(9)\n        assertFalse(disposable3.isDisposed)\n        // check that the scheduler automatically disposes of the tasks after being shut down\n        it.shutdown()\n        setScheduler(10, -1)\n        val disposable4 = it.scheduleDirect {\n            expectUnreached()\n        }\n        assertTrue(disposable4.isDisposed)\n        RxJavaPlugins.setScheduleHandler(null)\n        finish(11)\n    }\n\n    @Test\n    fun testSchedulerWithNoDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithNoDelay(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerWithNoDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithNoDelay(scheduler.createWorker()::schedule)\n    }\n\n    private suspend fun testRunnableWithNoDelay(block: RxSchedulerBlockNoDelay) {\n        expect(1)\n        suspendCancellableCoroutine<Unit> {\n            block(Runnable {\n                expect(2)\n                it.resume(Unit)\n            })\n        }\n        yield()\n        finish(3)\n    }\n\n    @Test\n    fun testSchedulerWithDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler::scheduleDirect, 300)\n    }\n\n    @Test\n    fun testSchedulerWorkerWithDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler.createWorker()::schedule, 300)\n    }\n\n    @Test\n    fun testSchedulerWithZeroDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerWithZeroDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler.createWorker()::schedule)\n    }\n\n    private suspend fun testRunnableWithDelay(block: RxSchedulerBlockWithDelay, delayMillis: Long = 0) {\n        expect(1)\n        suspendCancellableCoroutine<Unit> {\n            block({\n                expect(2)\n                it.resume(Unit)\n            }, delayMillis, TimeUnit.MILLISECONDS)\n        }\n        finish(3)\n    }\n\n    @Test\n    fun testAsSchedulerWithNegativeDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler::scheduleDirect, -1)\n    }\n\n    @Test\n    fun testAsSchedulerWorkerWithNegativeDelay(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableWithDelay(scheduler.createWorker()::schedule, -1)\n    }\n\n    @Test\n    fun testSchedulerImmediateDispose(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableImmediateDispose(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerImmediateDispose(): Unit = runTest {\n        val scheduler = (currentDispatcher() as CoroutineDispatcher).asScheduler()\n        testRunnableImmediateDispose(scheduler.createWorker()::schedule)\n    }\n\n    private fun testRunnableImmediateDispose(block: RxSchedulerBlockNoDelay) {\n        val disposable = block {\n            expectUnreached()\n        }\n        disposable.dispose()\n    }\n\n    @Test\n    fun testConvertDispatcherToOriginalScheduler(): Unit = runTest {\n        val originalScheduler = Schedulers.io()\n        val dispatcher = originalScheduler.asCoroutineDispatcher()\n        val scheduler = dispatcher.asScheduler()\n        assertSame(originalScheduler, scheduler)\n    }\n\n    @Test\n    fun testConvertSchedulerToOriginalDispatcher(): Unit = runTest {\n        val originalDispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = originalDispatcher.asScheduler()\n        val dispatcher = scheduler.asCoroutineDispatcher()\n        assertSame(originalDispatcher, dispatcher)\n    }\n\n    @Test\n    fun testSchedulerExpectRxPluginsCall(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableExpectRxPluginsCall(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerExpectRxPluginsCall(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableExpectRxPluginsCall(scheduler.createWorker()::schedule)\n    }\n\n    private suspend fun testRunnableExpectRxPluginsCall(block: RxSchedulerBlockNoDelay) {\n        expect(1)\n        setScheduler(2, 4)\n        suspendCancellableCoroutine<Unit> {\n            block(Runnable {\n                expect(5)\n                it.resume(Unit)\n            })\n            expect(3)\n        }\n        RxJavaPlugins.setScheduleHandler(null)\n        finish(6)\n    }\n\n    @Test\n    fun testSchedulerExpectRxPluginsCallWithDelay(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        testRunnableExpectRxPluginsCallDelay(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerExpectRxPluginsCallWithDelay(): Unit = runTest {\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        val worker = scheduler.createWorker()\n        testRunnableExpectRxPluginsCallDelay(worker::schedule)\n    }\n\n    private suspend fun testRunnableExpectRxPluginsCallDelay(block: RxSchedulerBlockWithDelay) {\n        expect(1)\n        setScheduler(2, 4)\n        suspendCancellableCoroutine<Unit> {\n            block({\n                expect(5)\n                it.resume(Unit)\n            }, 10, TimeUnit.MILLISECONDS)\n            expect(3)\n        }\n        RxJavaPlugins.setScheduleHandler(null)\n        finish(6)\n    }\n\n    private fun setScheduler(expectedCountOnSchedule: Int, expectCountOnRun: Int) {\n        RxJavaPlugins.setScheduleHandler {\n            expect(expectedCountOnSchedule)\n            Runnable {\n                expect(expectCountOnRun)\n                it.run()\n            }\n        }\n    }\n\n    /**\n     * Tests that [Scheduler.Worker] runs all work sequentially.\n     */\n    @Test\n    fun testWorkerSequentialOrdering() = runTest {\n        expect(1)\n        val scheduler = Dispatchers.Default.asScheduler()\n        val worker = scheduler.createWorker()\n        val iterations = 100\n        for (i in 0..iterations) {\n            worker.schedule {\n                expect(2 + i)\n            }\n        }\n        suspendCoroutine<Unit> {\n            worker.schedule {\n                it.resume(Unit)\n            }\n        }\n        finish((iterations + 2) + 1)\n    }\n\n    /**\n     * Test that ensures that delays are actually respected (tasks scheduled sooner in the future run before tasks scheduled later,\n     * even when the later task is submitted before the earlier one)\n     */\n    @Test\n    fun testSchedulerRespectsDelays(): Unit = runTest {\n        val scheduler = Dispatchers.Default.asScheduler()\n        testRunnableRespectsDelays(scheduler::scheduleDirect)\n    }\n\n    @Test\n    fun testSchedulerWorkerRespectsDelays(): Unit = runTest {\n        val scheduler = Dispatchers.Default.asScheduler()\n        testRunnableRespectsDelays(scheduler.createWorker()::schedule)\n    }\n\n    private suspend fun testRunnableRespectsDelays(block: RxSchedulerBlockWithDelay) {\n        expect(1)\n        val semaphore = Semaphore(2, 2)\n        block({\n            expect(3)\n            semaphore.release()\n        }, 100, TimeUnit.MILLISECONDS)\n        block({\n            expect(2)\n            semaphore.release()\n        }, 1, TimeUnit.MILLISECONDS)\n        semaphore.acquire()\n        semaphore.acquire()\n        finish(4)\n    }\n\n    /**\n     * Tests that cancelling a runnable in one worker doesn't affect work in another scheduler.\n     *\n     * This is part of expected behavior documented.\n     */\n    @Test\n    fun testMultipleWorkerCancellation(): Unit = runTest {\n        expect(1)\n        val dispatcher = currentDispatcher() as CoroutineDispatcher\n        val scheduler = dispatcher.asScheduler()\n        suspendCancellableCoroutine<Unit> {\n            val workerOne = scheduler.createWorker()\n            workerOne.schedule({\n                expect(3)\n                it.resume(Unit)\n            }, 50, TimeUnit.MILLISECONDS)\n            val workerTwo = scheduler.createWorker()\n            workerTwo.schedule({\n                expectUnreached()\n            }, 1000, TimeUnit.MILLISECONDS)\n            workerTwo.dispose()\n            expect(2)\n        }\n        finish(4)\n    }\n}\n\ntypealias RxSchedulerBlockNoDelay = (Runnable) -> Disposable\ntypealias RxSchedulerBlockWithDelay = (Runnable, Long, TimeUnit) -> Disposable"
    },
    {
        "path": "reactive/kotlinx-coroutines-rx3/test/SingleTest.kt",
        "content": "package kotlinx.coroutines.rx3\n\nimport kotlinx.coroutines.testing.*\nimport io.reactivex.rxjava3.core.*\nimport io.reactivex.rxjava3.disposables.*\nimport io.reactivex.rxjava3.exceptions.*\nimport io.reactivex.rxjava3.functions.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\nimport org.junit.*\nimport org.junit.Test\nimport java.util.concurrent.*\nimport kotlin.test.*\n\nclass SingleTest : TestBase() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"RxComputationThreadPool-\", \"RxCachedWorkerPoolEvictor-\", \"RxSchedulerPurge-\")\n    }\n\n    @Test\n    fun testBasicSuccess() = runBlocking {\n        expect(1)\n        val single = rxSingle(currentDispatcher()) {\n            expect(4)\n            \"OK\"\n        }\n        expect(2)\n        single.subscribe { value ->\n            expect(5)\n            assertEquals(\"OK\", value)\n        }\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n    @Test\n    fun testBasicFailure() = runBlocking {\n        expect(1)\n        val single = rxSingle(currentDispatcher()) {\n            expect(4)\n            throw RuntimeException(\"OK\")\n        }\n        expect(2)\n        single.subscribe({\n            expectUnreached()\n        }, { error ->\n            expect(5)\n            assertIs<RuntimeException>(error)\n            assertEquals(\"OK\", error.message)\n        })\n        expect(3)\n        yield() // to started coroutine\n        finish(6)\n    }\n\n\n    @Test\n    fun testBasicUnsubscribe() = runBlocking {\n        expect(1)\n        val single = rxSingle(currentDispatcher()) {\n            expect(4)\n            yield() // back to main, will get cancelled\n            expectUnreached()\n\n        }\n        expect(2)\n        // nothing is called on a disposed rx3 single\n        val sub = single.subscribe({\n            expectUnreached()\n        }, {\n            expectUnreached()\n        })\n        expect(3)\n        yield() // to started coroutine\n        expect(5)\n        sub.dispose() // will cancel coroutine\n        yield()\n        finish(6)\n    }\n\n    @Test\n    fun testSingleNoWait() {\n        val single = rxSingle {\n            \"OK\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleAwait() = runBlocking {\n        assertEquals(\"OK\", Single.just(\"O\").await() + \"K\")\n    }\n\n    /** Tests that calls to [await] throw [CancellationException] and dispose of the subscription when their\n     * [Job] is cancelled. */\n    @Test\n    fun testSingleAwaitCancellation() = runTest {\n        expect(1)\n        val single = SingleSource<Int> { s ->\n            s.onSubscribe(object: Disposable {\n                override fun dispose() { expect(4) }\n                override fun isDisposed(): Boolean { expectUnreached(); return false }\n            })\n        }\n        val job = launch(start = CoroutineStart.UNDISPATCHED) {\n            try {\n                expect(2)\n                single.await()\n            } catch (e: CancellationException) {\n                expect(5)\n                throw e\n            }\n        }\n        expect(3)\n        job.cancelAndJoin()\n        finish(6)\n    }\n\n    @Test\n    fun testSingleEmitAndAwait() {\n        val single = rxSingle {\n            Single.just(\"O\").await() + \"K\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleWithDelay() {\n        val single = rxSingle {\n            Observable.timer(50, TimeUnit.MILLISECONDS).map { \"O\" }.awaitSingle() + \"K\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testSingleException() {\n        val single = rxSingle {\n            Observable.just(\"O\", \"K\").awaitSingle() + \"K\"\n        }\n\n        checkErroneous(single) {\n            assert(it is IllegalArgumentException)\n        }\n    }\n\n    @Test\n    fun testAwaitFirst() {\n        val single = rxSingle {\n            Observable.just(\"O\", \"#\").awaitFirst() + \"K\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testAwaitLast() {\n        val single = rxSingle {\n            Observable.just(\"#\", \"O\").awaitLast() + \"K\"\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromObservable() {\n        val single = rxSingle {\n            try {\n                Observable.error<String>(RuntimeException(\"O\")).awaitFirst()\n            } catch (e: RuntimeException) {\n                Observable.just(e.message!!).awaitLast() + \"K\"\n            }\n        }\n\n        checkSingleValue(single) {\n            assertEquals(\"OK\", it)\n        }\n    }\n\n    @Test\n    fun testExceptionFromCoroutine() {\n        val single = rxSingle<String> {\n            throw IllegalStateException(Observable.just(\"O\").awaitSingle() + \"K\")\n        }\n\n        checkErroneous(single) {\n            assert(it is IllegalStateException)\n            assertEquals(\"OK\", it.message)\n        }\n    }\n\n    @Test\n    fun testSuppressedException() = runTest {\n        val single = rxSingle(currentDispatcher()) {\n            launch(start = CoroutineStart.ATOMIC) {\n                throw TestException() // child coroutine fails\n            }\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException2() // but parent throws another exception while cleaning up\n            }\n        }\n        try {\n            single.await()\n            expectUnreached()\n        } catch (e: TestException) {\n            assertIs<TestException2>(e.suppressed[0])\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSubscribe() = runTest {\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is LinkageError)\n            expect(2)\n        }\n        withExceptionHandler(handler) {\n            rxSingle(Dispatchers.Unconfined) {\n                expect(1)\n                42\n            }.subscribe(Consumer {\n                throw LinkageError()\n            })\n            finish(3)\n        }\n    }\n\n    @Test\n    fun testFatalExceptionInSingle() = runTest {\n        rxSingle(Dispatchers.Unconfined) {\n            throw LinkageError()\n        }.subscribe { _, e -> assertIs<LinkageError>(e); expect(1) }\n\n        finish(2)\n    }\n\n    @Test\n    fun testUnhandledException() = runTest {\n        expect(1)\n        var disposable: Disposable? = null\n        val handler = { e: Throwable ->\n            assertTrue(e is UndeliverableException && e.cause is TestException)\n            expect(5)\n        }\n        val single = rxSingle(currentDispatcher()) {\n            expect(4)\n            disposable!!.dispose() // cancel our own subscription, so that delay will get cancelled\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                throw TestException() // would not be able to handle it since mono is disposed\n            }\n        }\n        withExceptionHandler(handler) {\n            single.subscribe(object : SingleObserver<Unit> {\n                override fun onSubscribe(d: Disposable) {\n                    expect(2)\n                    disposable = d\n                }\n\n                override fun onSuccess(t: Unit) {\n                    expectUnreached()\n                }\n\n                override fun onError(t: Throwable) {\n                    expectUnreached()\n                }\n            })\n            expect(3)\n            yield() // run coroutine\n            finish(6)\n        }\n    }\n}\n"
    },
    {
        "path": "settings.gradle.kts",
        "content": "pluginManagement {\n    val javafx_plugin_version: String by settings\n    plugins {\n        id(\"org.openjfx.javafxplugin\") version javafx_plugin_version\n        id(\"me.champeau.jmh\") version \"0.7.2\"\n    }\n\n    repositories {\n        maven(url = \"https://maven.pkg.jetbrains.space/kotlin/p/dokka/dev/\")\n        gradlePluginPortal()\n    }\n}\n\nrootProject.name = \"kotlinx.coroutines\"\n\nfun module(path: String) {\n    val i = path.lastIndexOf(\"/\")\n    val name = path.substring(i + 1)\n    include(name)\n    project(\":$name\").projectDir = file(path)\n}\nval prop = System.getProperty(\"build_snapshot_train\")\nvar build_snapshot_train: String by extra\nbuild_snapshot_train = if (prop != null && prop != \"\") \"true\" else \"false\"\n// ---------------------------\n\ninclude(\"benchmarks\")\nmodule(\"test-utils\")\n\ninclude(\"kotlinx-coroutines-core\")\n\nmodule(\"kotlinx-coroutines-test\")\nmodule(\"kotlinx-coroutines-debug\")\nmodule(\"kotlinx-coroutines-bom\")\n\n\nmodule(\"integration/kotlinx-coroutines-guava\")\nmodule(\"integration/kotlinx-coroutines-jdk8\")\nmodule(\"integration/kotlinx-coroutines-slf4j\")\nmodule(\"integration/kotlinx-coroutines-play-services\")\n\nmodule(\"reactive/kotlinx-coroutines-reactive\")\nmodule(\"reactive/kotlinx-coroutines-reactor\")\nmodule(\"reactive/kotlinx-coroutines-jdk9\")\nmodule(\"reactive/kotlinx-coroutines-rx2\")\nmodule(\"reactive/kotlinx-coroutines-rx3\")\nmodule(\"ui/kotlinx-coroutines-android\")\nmodule(\"ui/kotlinx-coroutines-android/android-unit-tests\")\nif (JavaVersion.current().isJava11Compatible()) {\n    module(\"ui/kotlinx-coroutines-javafx\")\n}\nmodule(\"ui/kotlinx-coroutines-swing\")\n"
    },
    {
        "path": "test-utils/build.gradle.kts",
        "content": "/*\n * Copyright 2016-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license.\n */\n\nkotlin {\n    sourceSets {\n        commonMain.dependencies {\n            api(\"org.jetbrains.kotlin:kotlin-test-common:${version(\"kotlin\")}\")\n            api(\"org.jetbrains.kotlin:kotlin-test-annotations-common:${version(\"kotlin\")}\")\n        }\n        jvmMain.dependencies {\n            api(\"org.jetbrains.kotlin:kotlin-test:${version(\"kotlin\")}\")\n            // Workaround to make addSuppressed work in tests\n            api(\"org.jetbrains.kotlin:kotlin-reflect:${version(\"kotlin\")}\")\n            api(\"org.jetbrains.kotlin:kotlin-stdlib-jdk7:${version(\"kotlin\")}\")\n            api(\"org.jetbrains.kotlin:kotlin-test-junit:${version(\"kotlin\")}\")\n            api(\"junit:junit:${version(\"junit\")}\")\n        }\n        jsMain.dependencies {\n            api(\"org.jetbrains.kotlin:kotlin-test-js:${version(\"kotlin\")}\")\n        }\n        val wasmJsMain by getting {\n            dependencies {\n                api(\"org.jetbrains.kotlin:kotlin-test-wasm-js:${version(\"kotlin\")}\")\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "test-utils/common/src/LaunchFlow.kt",
        "content": "package kotlinx.coroutines.testing.flow\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.jvm.*\nimport kotlin.reflect.*\n\npublic typealias Handler<T> = suspend CoroutineScope.(T) -> Unit\n\n/*\n * Design of this builder is not yet stable, so leaving it as is.\n */\npublic class LaunchFlowBuilder<T> {\n    /*\n     * NB: this implementation is a temporary ad-hoc (and slightly incorrect)\n     * solution until coroutine-builders are ready\n     *\n     * NB 2: this internal stuff is required to workaround KT-30795\n     */\n    @PublishedApi\n    internal var onEach: Handler<T>? = null\n    @PublishedApi\n    internal var finally: Handler<Throwable?>? = null\n    @PublishedApi\n    internal var exceptionHandlers = LinkedHashMap<KClass<*>, Handler<Throwable>>()\n\n    public fun onEach(action: suspend CoroutineScope.(value: T) -> Unit) {\n        check(onEach == null) { \"onEach block is already registered\" }\n        check(exceptionHandlers.isEmpty()) { \"onEach block should be registered before exceptionHandlers block\" }\n        check(finally == null) { \"onEach block should be registered before finally block\" }\n        onEach = action\n    }\n\n    public inline fun <reified T : Throwable> catch(noinline action: suspend CoroutineScope.(T) -> Unit) {\n        check(onEach != null) { \"onEach block should be registered first\" }\n        check(finally == null) { \"exceptionHandlers block should be registered before finally block\" }\n        @Suppress(\"UNCHECKED_CAST\")\n        exceptionHandlers[T::class] = action as Handler<Throwable>\n    }\n\n    public fun finally(action: suspend CoroutineScope.(cause: Throwable?) -> Unit) {\n        check(finally == null) { \"Finally block is already registered\" }\n        check(onEach != null) { \"onEach block should be registered before finally block\" }\n        if (finally == null) finally = action\n    }\n\n    internal fun build(): Handlers<T> =\n        Handlers(onEach ?: error(\"onEach is not registered\"), exceptionHandlers, finally)\n}\n\ninternal class Handlers<T>(\n    @JvmField\n    internal var onEach: Handler<T>,\n    @JvmField\n    internal var exceptionHandlers: Map<KClass<*>, Handler<Throwable>>,\n    @JvmField\n    internal var finally: Handler<Throwable?>?\n)\n\nprivate fun <T> CoroutineScope.launchFlow(\n    flow: Flow<T>,\n    builder: LaunchFlowBuilder<T>.() -> Unit\n): Job {\n    val handlers = LaunchFlowBuilder<T>().apply(builder).build()\n    return launch {\n        var caught: Throwable? = null\n        try {\n            coroutineScope {\n                flow.collect { value ->\n                    handlers.onEach(this, value)\n                }\n            }\n        } catch (e: Throwable) {\n            handlers.exceptionHandlers.forEach { (key, value) ->\n                if (key.isInstance(e)) {\n                    caught = e\n                    value.invoke(this, e)\n                    return@forEach\n                }\n            }\n            if (caught == null) {\n                caught = e\n                throw e\n            }\n        } finally {\n            cancel() // TODO discuss\n            handlers.finally?.invoke(CoroutineScope(coroutineContext + NonCancellable), caught)\n        }\n    }\n}\n\npublic fun <T> Flow<T>.launchIn(\n    scope: CoroutineScope,\n    builder: LaunchFlowBuilder<T>.() -> Unit\n): Job = scope.launchFlow(this, builder)\n"
    },
    {
        "path": "test-utils/common/src/MainDispatcherTestBase.kt",
        "content": "package kotlinx.coroutines.testing\n\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nabstract class MainDispatcherTestBase: TestBase() {\n\n    open fun shouldSkipTesting(): Boolean = false\n\n    open suspend fun spinTest(testBody: Job) {\n        testBody.join()\n    }\n\n    abstract fun isMainThread(): Boolean?\n\n    /** Runs the given block as a test, unless [shouldSkipTesting] indicates that the environment is not suitable. */\n    fun runTestOrSkip(block: suspend CoroutineScope.() -> Unit): TestResult {\n        // written as a block body to make the need to return `TestResult` explicit\n        return runTest {\n            if (shouldSkipTesting()) return@runTest\n            val testBody = launch(Dispatchers.Default) {\n                block()\n            }\n            spinTest(testBody)\n        }\n    }\n\n    /** Tests the [toString] behavior of [Dispatchers.Main] and [MainCoroutineDispatcher.immediate] */\n    @Test\n    fun testMainDispatcherToString() {\n        assertEquals(\"Dispatchers.Main\", Dispatchers.Main.toString())\n        assertEquals(\"Dispatchers.Main.immediate\", Dispatchers.Main.immediate.toString())\n    }\n\n    /** Tests that the tasks scheduled earlier from [MainCoroutineDispatcher.immediate] will be executed earlier,\n     * even if the immediate dispatcher was entered from the main thread. */\n    @Test\n    fun testMainDispatcherOrderingInMainThread() = runTestOrSkip {\n        withContext(Dispatchers.Main) {\n            testMainDispatcherOrdering()\n        }\n    }\n\n    /** Tests that the tasks scheduled earlier from [MainCoroutineDispatcher.immediate] will be executed earlier\n     * if the immediate dispatcher was entered from outside the main thread. */\n    @Test\n    fun testMainDispatcherOrderingOutsideMainThread() = runTestOrSkip {\n        testMainDispatcherOrdering()\n    }\n\n    /** Tests that [Dispatchers.Main] and its [MainCoroutineDispatcher.immediate] are treated as different values. */\n    @Test\n    fun testHandlerDispatcherNotEqualToImmediate() {\n        assertNotEquals(Dispatchers.Main, Dispatchers.Main.immediate)\n    }\n\n    /** Tests that [Dispatchers.Main] shares its queue with [MainCoroutineDispatcher.immediate]. */\n    @Test\n    fun testImmediateDispatcherYield() = runTestOrSkip {\n        withContext(Dispatchers.Main) {\n            expect(1)\n            checkIsMainThread()\n            // launch in the immediate dispatcher\n            launch(Dispatchers.Main.immediate) {\n                expect(2)\n                yield()\n                expect(4)\n            }\n            expect(3) // after yield\n            yield() // yield back\n            expect(5)\n        }\n        finish(6)\n    }\n\n    /** Tests that entering [MainCoroutineDispatcher.immediate] from [Dispatchers.Main] happens immediately. */\n    @Test\n    fun testEnteringImmediateFromMain() = runTestOrSkip {\n        withContext(Dispatchers.Main) {\n            expect(1)\n            val job = launch { expect(3) }\n            withContext(Dispatchers.Main.immediate) {\n                expect(2)\n            }\n            job.join()\n        }\n        finish(4)\n    }\n\n    /** Tests that dispatching to [MainCoroutineDispatcher.immediate] is required from and only from dispatchers\n     * other than the main dispatchers and that it's always required for [Dispatchers.Main] itself. */\n    @Test\n    fun testDispatchRequirements() = runTestOrSkip {\n        checkDispatchRequirements()\n        withContext(Dispatchers.Main) {\n            checkDispatchRequirements()\n            withContext(Dispatchers.Main.immediate) {\n                checkDispatchRequirements()\n            }\n            checkDispatchRequirements()\n        }\n        checkDispatchRequirements()\n    }\n\n    private suspend fun checkDispatchRequirements() {\n        isMainThread()?.let {\n            assertNotEquals(\n                it,\n                Dispatchers.Main.immediate.isDispatchNeeded(currentCoroutineContext())\n            )\n        }\n        assertTrue(Dispatchers.Main.isDispatchNeeded(currentCoroutineContext()))\n        assertTrue(Dispatchers.Default.isDispatchNeeded(currentCoroutineContext()))\n    }\n\n    /** Tests that launching a coroutine in [MainScope] will execute it in the main thread. */\n    @Test\n    fun testLaunchInMainScope() = runTestOrSkip {\n        var executed = false\n        withMainScope {\n            launch {\n                checkIsMainThread()\n                executed = true\n            }.join()\n            if (!executed) throw AssertionError(\"Should be executed\")\n        }\n    }\n\n    /** Tests that a failure in [MainScope] will not propagate upwards. */\n    @Test\n    fun testFailureInMainScope() = runTestOrSkip {\n        var exception: Throwable? = null\n        withMainScope {\n            launch(CoroutineExceptionHandler { ctx, e -> exception = e }) {\n                checkIsMainThread()\n                throw TestException()\n            }.join()\n        }\n        if (exception!! !is TestException) throw AssertionError(\"Expected TestException, but had $exception\")\n    }\n\n    /** Tests cancellation in [MainScope]. */\n    @Test\n    fun testCancellationInMainScope() = runTestOrSkip {\n        withMainScope {\n            cancel()\n            launch(start = CoroutineStart.ATOMIC) {\n                checkIsMainThread()\n                delay(Long.MAX_VALUE)\n            }.join()\n        }\n    }\n\n    private suspend fun <R> withMainScope(block: suspend CoroutineScope.() -> R): R {\n        MainScope().apply {\n            return block().also { coroutineContext[Job]!!.cancelAndJoin() }\n        }\n    }\n\n    private suspend fun testMainDispatcherOrdering() {\n        withContext(Dispatchers.Main.immediate) {\n            expect(1)\n            launch(Dispatchers.Main) {\n                expect(2)\n            }\n            withContext(Dispatchers.Main) {\n                finish(3)\n            }\n        }\n    }\n\n    abstract class WithRealTimeDelay : MainDispatcherTestBase() {\n        abstract fun scheduleOnMainQueue(block: () -> Unit)\n\n        /** Tests that after a delay, the execution gets back to the main thread. */\n        @Test\n        fun testDelay() = runTestOrSkip {\n            expect(1)\n            checkNotMainThread()\n            scheduleOnMainQueue { expect(2) }\n            withContext(Dispatchers.Main) {\n                checkIsMainThread()\n                expect(3)\n                scheduleOnMainQueue { expect(4) }\n                delay(100)\n                checkIsMainThread()\n                expect(5)\n            }\n            checkNotMainThread()\n            finish(6)\n        }\n\n        /** Tests that [Dispatchers.Main] is in agreement with the default time source: it's not much slower. */\n        @Test\n        fun testWithTimeoutContextDelayNoTimeout() = runTestOrSkip {\n            expect(1)\n            withTimeout(1000) {\n                withContext(Dispatchers.Main) {\n                    checkIsMainThread()\n                    expect(2)\n                    delay(100)\n                    checkIsMainThread()\n                    expect(3)\n                }\n            }\n            checkNotMainThread()\n            finish(4)\n        }\n\n        /** Tests that [Dispatchers.Main] is in agreement with the default time source: it's not much faster. */\n        @Test\n        fun testWithTimeoutContextDelayTimeout() = runTestOrSkip {\n            expect(1)\n            assertFailsWith<TimeoutCancellationException> {\n                withTimeout(300) {\n                    // A substitute for withContext(Dispatcher.Main) that is started even if the 300ms\n                    // timeout happens fsater then dispatch\n                    launch(Dispatchers.Main, start = CoroutineStart.ATOMIC) {\n                        checkIsMainThread()\n                        expect(2)\n                        delay(1000)\n                        expectUnreached()\n                    }.join()\n                }\n                expectUnreached()\n            }\n            checkNotMainThread()\n            finish(3)\n        }\n\n        /** Tests that the timeout of [Dispatchers.Main] is in agreement with its [delay]: it's not much faster. */\n        @Test\n        fun testWithContextTimeoutDelayNoTimeout() = runTestOrSkip {\n            expect(1)\n            withContext(Dispatchers.Main) {\n                withTimeout(1000) {\n                    checkIsMainThread()\n                    expect(2)\n                    delay(100)\n                    checkIsMainThread()\n                    expect(3)\n                }\n            }\n            checkNotMainThread()\n            finish(4)\n        }\n\n        /** Tests that the timeout of [Dispatchers.Main] is in agreement with its [delay]: it's not much slower. */\n        @Test\n        fun testWithContextTimeoutDelayTimeout() = runTestOrSkip {\n            expect(1)\n            assertFailsWith<TimeoutCancellationException> {\n                withContext(Dispatchers.Main) {\n                    withTimeout(100) {\n                        checkIsMainThread()\n                        expect(2)\n                        delay(1000)\n                        expectUnreached()\n                    }\n                }\n                expectUnreached()\n            }\n            checkNotMainThread()\n            finish(3)\n        }\n    }\n\n    fun checkIsMainThread() { isMainThread()?.let { check(it) } }\n    fun checkNotMainThread() { isMainThread()?.let { check(!it) } }\n}\n"
    },
    {
        "path": "test-utils/common/src/TestBase.common.kt",
        "content": "@file:Suppress(\"unused\")\npackage kotlinx.coroutines.testing\n\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\nimport kotlin.time.*\nimport kotlin.time.Duration.Companion.seconds\n\n/**\n * The number of milliseconds that is sure not to pass [assertRunsFast].\n */\nconst val SLOW = 100_000L\n\n/**\n * Asserts that a block completed within [timeout].\n */\ninline fun <T> assertRunsFast(timeout: Duration, block: () -> T): T {\n    val result: T\n    val elapsed = TimeSource.Monotonic.measureTime { result = block() }\n    assertTrue(\"Should complete in $timeout, but took $elapsed\") { elapsed < timeout }\n    return result\n}\n\n/**\n * Asserts that a block completed within two seconds.\n */\ninline fun <T> assertRunsFast(block: () -> T): T = assertRunsFast(2.seconds, block)\n\n/**\n * Whether the tests should trace their calls to `expect` and `finish` with `println`.\n * `false` by default. On the JVM, can be set to `true` by setting the `test.verbose` system property.\n */\nexpect val VERBOSE: Boolean\n\ninterface OrderedExecution {\n    /** Expect the next action to be [index] in order. */\n    fun expect(index: Int)\n\n    /** Expect this action to be final, with the given [index]. */\n    fun finish(index: Int)\n\n    /** * Asserts that this line is never executed. */\n    fun expectUnreached()\n\n    /**\n     * Checks that [finish] was called.\n     *\n     * By default, it is allowed to not call [finish] if [expect] was not called.\n     * This is useful for tests that don't check the ordering of events.\n     * When [allowNotUsingExpect] is set to `false`, it is an error to not call [finish] in any case.\n     */\n    fun checkFinishCall(allowNotUsingExpect: Boolean = true)\n\n    class Impl : OrderedExecution {\n        private val actionIndex = atomic(0)\n\n        override fun expect(index: Int) {\n            val wasIndex = actionIndex.incrementAndGet()\n            if (VERBOSE) println(\"expect($index), wasIndex=$wasIndex\")\n            check(index == wasIndex) {\n                if (wasIndex < 0) \"Expecting action index $index but it is actually finished\"\n                else \"Expecting action index $index but it is actually $wasIndex\"\n            }\n        }\n\n        override fun finish(index: Int) {\n            val wasIndex = actionIndex.getAndSet(Int.MIN_VALUE) + 1\n            if (VERBOSE) println(\"finish($index), wasIndex=${if (wasIndex < 0) \"finished\" else wasIndex}\")\n            check(index == wasIndex) {\n                if (wasIndex < 0) \"Finished more than once\"\n                else \"Finishing with action index $index but it is actually $wasIndex\"\n            }\n        }\n\n        override fun expectUnreached() {\n            error(\"Should not be reached, ${\n                actionIndex.value.let {\n                    when {\n                        it < 0 -> \"already finished\"\n                        it == 0 -> \"'expect' was not called yet\"\n                        else -> \"the last executed action was $it\"\n                    }\n                }\n            }\")\n        }\n\n        override fun checkFinishCall(allowNotUsingExpect: Boolean) {\n            actionIndex.value.let {\n                assertTrue(\n                    it < 0 || allowNotUsingExpect && it == 0,\n                    \"Expected `finish(${actionIndex.value + 1})` to be called, but the test finished\"\n                )\n            }\n        }\n    }\n}\n\ninterface ErrorCatching {\n    /**\n     * Returns `true` if errors were logged in the test.\n     */\n    fun hasError(): Boolean\n\n    /**\n     * Directly reports an error to the test catching facilities.\n     */\n    fun reportError(error: Throwable)\n\n    class Impl : ErrorCatching {\n\n        private val errors = mutableListOf<Throwable>()\n        private val lock = SynchronizedObject()\n        private var closed = false\n\n        override fun hasError(): Boolean = synchronized(lock) {\n            errors.isNotEmpty()\n        }\n\n        override fun reportError(error: Throwable) {\n            synchronized(lock) {\n                if (closed) {\n                    lastResortReportException(error)\n                } else {\n                    errors.add(error)\n                }\n            }\n        }\n\n        fun close() {\n            synchronized(lock) {\n                if (closed) {\n                    lastResortReportException(IllegalStateException(\"ErrorCatching closed more than once\"))\n                }\n                closed = true\n                errors.firstOrNull()?.let {\n                    for (error in errors.drop(1))\n                        it.addSuppressed(error)\n                    throw it\n                }\n            }\n        }\n    }\n}\n\n/**\n * Reports an error *somehow* so that it doesn't get completely forgotten.\n */\ninternal expect fun lastResortReportException(error: Throwable)\n\n/**\n * Throws [IllegalStateException] when `value` is false, like `check` in stdlib, but also ensures that the\n * test will not complete successfully even if this exception is consumed somewhere in the test.\n */\npublic inline fun ErrorCatching.check(value: Boolean, lazyMessage: () -> Any) {\n    if (!value) error(lazyMessage())\n}\n\n/**\n * Throws [IllegalStateException], like `error` in stdlib, but also ensures that the test will not\n * complete successfully even if this exception is consumed somewhere in the test.\n */\nfun ErrorCatching.error(message: Any, cause: Throwable? = null): Nothing {\n    throw IllegalStateException(message.toString(), cause).also {\n        reportError(it)\n    }\n}\n\n/**\n * A class inheriting from which allows to check the execution order inside tests.\n *\n * @see TestBase\n */\nopen class OrderedExecutionTestBase : OrderedExecution\n{\n    // TODO: move to by-delegation when [reset] is no longer needed.\n    private var orderedExecutionDelegate = OrderedExecution.Impl()\n\n    @AfterTest\n    fun checkFinished() { orderedExecutionDelegate.checkFinishCall() }\n\n    /** Resets counter and finish flag. Workaround for parametrized tests absence in common */\n    public fun reset() {\n        orderedExecutionDelegate.checkFinishCall()\n        orderedExecutionDelegate = OrderedExecution.Impl()\n    }\n\n    override fun expect(index: Int) = orderedExecutionDelegate.expect(index)\n\n    override fun finish(index: Int) = orderedExecutionDelegate.finish(index)\n\n    override fun expectUnreached() = orderedExecutionDelegate.expectUnreached()\n\n    override fun checkFinishCall(allowNotUsingExpect: Boolean) =\n        orderedExecutionDelegate.checkFinishCall(allowNotUsingExpect)\n}\n\nfun <T> T.void() {}\n\n@OptionalExpectation\nexpect annotation class NoJs()\n\n@OptionalExpectation\nexpect annotation class NoNative()\n\nexpect val isStressTest: Boolean\nexpect val stressTestMultiplier: Int\nexpect val stressTestMultiplierSqrt: Int\n\n/**\n * The result of a multiplatform asynchronous test.\n * Aliases into Unit on K/JVM and K/N, and into Promise on K/JS.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect class TestResult\n\npublic expect open class TestBase(): OrderedExecutionTestBase, ErrorCatching {\n    public fun println(message: Any?)\n\n    public fun runTest(\n        expected: ((Throwable) -> Boolean)? = null,\n        unhandled: List<(Throwable) -> Boolean> = emptyList(),\n        block: suspend CoroutineScope.() -> Unit\n    ): TestResult\n}\n\npublic suspend inline fun hang(onCancellation: () -> Unit) {\n    try {\n        suspendCancellableCoroutine<Unit> { }\n    } finally {\n        onCancellation()\n    }\n}\n\nsuspend inline fun <reified T : Throwable> assertFailsWith(flow: Flow<*>) = assertFailsWith<T> { flow.collect() }\n\npublic suspend fun Flow<Int>.sum() = fold(0) { acc, value -> acc + value }\npublic suspend fun Flow<Long>.longSum() = fold(0L) { acc, value -> acc + value }\n\n// data is added to avoid stacktrace recovery because CopyableThrowable is not accessible from common modules\npublic class TestException(message: String? = null, private val data: Any? = null) : Throwable(message)\npublic class TestException1(message: String? = null, private val data: Any? = null) : Throwable(message)\npublic class TestException2(message: String? = null, private val data: Any? = null) : Throwable(message)\npublic class TestException3(message: String? = null, private val data: Any? = null) : Throwable(message)\npublic class TestCancellationException(message: String? = null, private val data: Any? = null) :\n    CancellationException(message)\n\npublic class TestRuntimeException(message: String? = null, private val data: Any? = null) : RuntimeException(message)\npublic class RecoverableTestException(message: String? = null) : RuntimeException(message)\npublic class RecoverableTestCancellationException(message: String? = null) : CancellationException(message)\n\npublic fun wrapperDispatcher(context: CoroutineContext): CoroutineContext {\n    val dispatcher = context[ContinuationInterceptor] as CoroutineDispatcher\n    return object : CoroutineDispatcher() {\n        override fun isDispatchNeeded(context: CoroutineContext): Boolean =\n            dispatcher.isDispatchNeeded(context)\n\n        override fun dispatch(context: CoroutineContext, block: Runnable) =\n            dispatcher.dispatch(context, block)\n    }\n}\n\npublic suspend fun wrapperDispatcher(): CoroutineContext = wrapperDispatcher(coroutineContext)\nclass BadClass {\n    override fun equals(other: Any?): Boolean = error(\"equals\")\n    override fun hashCode(): Int = error(\"hashCode\")\n    override fun toString(): String = error(\"toString\")\n}\n\npublic expect val isJavaAndWindows: Boolean\n\npublic expect val isNative: Boolean\n\n/*\n * In common tests we emulate parameterized tests\n * by iterating over parameters space in the single @Test method.\n * This kind of tests is too slow for JS and does not fit into\n * the default Mocha timeout, so we're using this flag to bail-out\n * and run such tests only on JVM and K/N.\n */\npublic expect val isBoundByJsTestTimeout: Boolean\n"
    },
    {
        "path": "test-utils/js/src/TestBase.kt",
        "content": "package kotlinx.coroutines.testing\n\nimport kotlinx.coroutines.*\nimport kotlin.test.*\nimport kotlin.js.*\n\nactual typealias NoJs = Ignore\n\nactual val VERBOSE = false\n\nactual val isStressTest: Boolean = false\nactual val stressTestMultiplier: Int = 1\nactual val stressTestMultiplierSqrt: Int = 1\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"ACTUAL_TYPE_ALIAS_TO_CLASS_WITH_DECLARATION_SITE_VARIANCE\")\nactual typealias TestResult = Promise<Unit>\n\ninternal actual fun lastResortReportException(error: Throwable) {\n    println(error)\n    console.log(error)\n}\n\nactual open class TestBase(\n    private val errorCatching: ErrorCatching.Impl\n): OrderedExecutionTestBase(), ErrorCatching by errorCatching {\n    private var lastTestPromise: Promise<*>? = null\n\n    actual constructor(): this(errorCatching = ErrorCatching.Impl())\n\n    actual fun println(message: Any?) {\n        kotlin.io.println(message)\n    }\n\n    actual fun runTest(\n        expected: ((Throwable) -> Boolean)?,\n        unhandled: List<(Throwable) -> Boolean>,\n        block: suspend CoroutineScope.() -> Unit\n    ): TestResult {\n        var exCount = 0\n        var ex: Throwable? = null\n        /*\n         * This is an additional sanity check against `runTest` mis-usage on JS.\n         * The only way to write an async test on JS is to return Promise from the test function.\n         * _Just_ launching promise and returning `Unit` won't suffice as the underlying test framework\n         * won't be able to detect an asynchronous failure in a timely manner.\n         * We cannot detect such situations, but we can detect the most common erroneous pattern\n         * in our code base, an attempt to use multiple `runTest` in the same `@Test` method,\n         * which typically is a premise to the same error:\n         * ```\n         * @Test\n         * fun incorrectTestForJs() { // <- promise is not returned\n         *     for (parameter in parameters) {\n         *         runTest {\n         *             runTestForParameter(parameter)\n         *         }\n         *     }\n         * }\n         * ```\n         */\n        if (lastTestPromise != null) {\n            error(\"Attempt to run multiple asynchronous test within one @Test method\")\n        }\n        val result = GlobalScope.promise(block = block, context = CoroutineExceptionHandler { _, e ->\n            if (e is CancellationException) return@CoroutineExceptionHandler // are ignored\n            exCount++\n            when {\n                exCount > unhandled.size ->\n                    error(\"Too many unhandled exceptions $exCount, expected ${unhandled.size}, got: $e\", e)\n                !unhandled[exCount - 1](e) ->\n                    error(\"Unhandled exception was unexpected: $e\", e)\n            }\n        }).catch { e ->\n            ex = e\n            if (expected != null) {\n                if (!expected(e)) {\n                    console.log(e)\n                    error(\"Unexpected exception $e\", e)\n                }\n            } else\n                throw e\n        }.finally {\n            if (ex == null && expected != null) error(\"Exception was expected but none produced\")\n            if (exCount < unhandled.size)\n                error(\"Too few unhandled exceptions $exCount, expected ${unhandled.size}\")\n            errorCatching.close()\n            checkFinishCall()\n        }\n        lastTestPromise = result\n        return result\n    }\n}\n\nactual val isNative = false\n\nactual val isBoundByJsTestTimeout = true\n\nactual val isJavaAndWindows: Boolean get() = false\n"
    },
    {
        "path": "test-utils/jvm/src/Exceptions.kt",
        "content": "package kotlinx.coroutines.testing.exceptions\n\nimport kotlinx.coroutines.*\nimport java.io.*\nimport java.util.*\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.test.*\n\ninline fun <reified T : Throwable> checkException(exception: Throwable) {\n    assertIs<T>(exception)\n    assertTrue(exception.suppressed.isEmpty())\n    assertNull(exception.cause)\n}\n\nfun checkCycles(t: Throwable) {\n    val sw = StringWriter()\n    t.printStackTrace(PrintWriter(sw))\n    assertFalse(sw.toString().contains(\"CIRCULAR REFERENCE\"))\n}\n\nclass CapturingHandler : AbstractCoroutineContextElement(CoroutineExceptionHandler),\n    CoroutineExceptionHandler\n{\n    private var unhandled: ArrayList<Throwable>? = ArrayList()\n\n    override fun handleException(context: CoroutineContext, exception: Throwable) = synchronized<Unit>(this) {\n        unhandled!!.add(exception)\n    }\n\n    fun getException(): Throwable = synchronized(this) {\n        val size = unhandled!!.size\n        assert(size == 1) { \"Expected one unhandled exception, but have $size: $unhandled\" }\n        return unhandled!![0].also { unhandled = null }\n    }\n}\n\nfun captureExceptionsRun(\n    context: CoroutineContext = EmptyCoroutineContext,\n    block: suspend CoroutineScope.() -> Unit\n): Throwable {\n    val handler = CapturingHandler()\n    runBlocking(context + handler, block = block)\n    return handler.getException()\n}\n\n@OptIn(ExperimentalContracts::class)\nsuspend inline fun <reified E: Throwable> assertCallsExceptionHandlerWith(\n    crossinline operation: suspend (CoroutineExceptionHandler) -> Unit): E {\n    contract {\n        callsInPlace(operation, InvocationKind.EXACTLY_ONCE)\n    }\n    val handler = CapturingHandler()\n    return withContext(handler) {\n        operation(handler)\n        assertIs<E>(handler.getException())\n    }\n}\n"
    },
    {
        "path": "test-utils/jvm/src/ExecutorRule.kt",
        "content": "package kotlinx.coroutines.testing\n\nimport kotlinx.coroutines.*\nimport org.junit.rules.*\nimport org.junit.runner.*\nimport org.junit.runners.model.*\nimport java.lang.Runnable\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\nclass ExecutorRule(private val numberOfThreads: Int) : TestRule, ExecutorCoroutineDispatcher() {\n\n    private var _executor: ExecutorCoroutineDispatcher? = null\n    override val executor: Executor\n        get() = _executor?.executor ?: error(\"Executor is not initialized\")\n\n    override fun apply(base: Statement, description: Description): Statement {\n        return object : Statement() {\n            override fun evaluate() {\n                val threadPrefix = description.className.substringAfterLast(\".\") + \"#\" + description.methodName\n                _executor = newFixedThreadPoolContext(numberOfThreads, threadPrefix)\n                ignoreLostThreads(threadPrefix)\n                try {\n                    return base.evaluate()\n                } finally {\n                    val service = executor as ExecutorService\n                    service.shutdown()\n                    if (!service.awaitTermination(10, TimeUnit.SECONDS)) {\n                        error(\"Test $description timed out\")\n                    }\n                }\n            }\n        }\n    }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        _executor?.dispatch(context, block) ?: error(\"Executor is not initialized\")\n    }\n\n    override fun close() {\n        error(\"Cannot be closed manually\")\n    }\n}\n"
    },
    {
        "path": "test-utils/jvm/src/FieldWalker.kt",
        "content": "package kotlinx.coroutines.testing\n\nimport java.lang.ref.*\nimport java.lang.reflect.*\nimport java.text.*\nimport java.util.*\nimport java.util.Collections.*\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.*\nimport java.util.concurrent.locks.*\nimport kotlin.test.*\n\nobject FieldWalker {\n    sealed class Ref {\n        object RootRef : Ref()\n        class FieldRef(val parent: Any, val name: String) : Ref()\n        class ArrayRef(val parent: Any, val index: Int) : Ref()\n    }\n\n    private val fieldsCache = HashMap<Class<*>, List<Field>>()\n\n    init {\n        // excluded/terminal classes (don't walk them)\n        fieldsCache += listOf(\n            Any::class, String::class, Thread::class, Throwable::class, StackTraceElement::class,\n            WeakReference::class, ReferenceQueue::class, AbstractMap::class, Enum::class,\n            ReentrantLock::class, ReentrantReadWriteLock::class, SimpleDateFormat::class, ThreadPoolExecutor::class,\n            CountDownLatch::class,\n        )\n            .map { it.java }\n            .associateWith { emptyList() }\n    }\n\n    /*\n     * Reflectively starts to walk through object graph and returns identity set of all reachable objects.\n     * Use [walkRefs] if you need a path from root for debugging.\n     */\n    public fun walk(root: Any?): Set<Any> = walkRefs(root, false).keys\n\n    public fun assertReachableCount(expected: Int, root: Any?, rootStatics: Boolean = false, predicate: (Any) -> Boolean) {\n        val visited = walkRefs(root, rootStatics)\n        val actual = visited.keys.filter(predicate)\n        if (actual.size != expected) {\n            val textDump = actual.joinToString(\"\") { \"\\n\\t\" + showPath(it, visited) }\n            assertEquals(\n                expected, actual.size,\n                \"Unexpected number objects. Expected $expected, found ${actual.size}$textDump\"\n            )\n        }\n    }\n\n    /*\n     * Reflectively starts to walk through object graph and map to all the reached object to their path\n     * in from root. Use [showPath] do display a path if needed.\n     */\n    private fun walkRefs(root: Any?, rootStatics: Boolean): IdentityHashMap<Any, Ref> {\n        val visited = IdentityHashMap<Any, Ref>()\n        if (root == null) return visited\n        visited[root] = Ref.RootRef\n        val stack = ArrayDeque<Any>()\n        stack.addLast(root)\n        var statics = rootStatics\n        while (stack.isNotEmpty()) {\n            val element = stack.removeLast()\n            try {\n                visit(element, visited, stack, statics)\n                statics = false // only scan root static when asked\n            } catch (e: Exception) {\n                error(\"Failed to visit element ${showPath(element, visited)}: $e\")\n            }\n        }\n        return visited\n    }\n\n    private fun showPath(element: Any, visited: Map<Any, Ref>): String {\n        val path = ArrayList<String>()\n        var cur = element\n        while (true) {\n            when (val ref = visited.getValue(cur)) {\n                Ref.RootRef -> break\n                is Ref.FieldRef -> {\n                    cur = ref.parent\n                    path += \"|${ref.parent.javaClass.simpleName}::${ref.name}\"\n                }\n                is Ref.ArrayRef -> {\n                    cur = ref.parent\n                    path += \"[${ref.index}]\"\n                }\n                else -> {\n                    // Nothing, kludge for IDE\n                }\n            }\n        }\n        path.reverse()\n        return path.joinToString(\"\")\n    }\n\n    private fun visit(element: Any, visited: IdentityHashMap<Any, Ref>, stack: ArrayDeque<Any>, statics: Boolean) {\n        val type = element.javaClass\n        when {\n            // Special code for arrays\n            type.isArray && !type.componentType.isPrimitive -> {\n                @Suppress(\"UNCHECKED_CAST\")\n                val array = element as Array<Any?>\n                array.forEachIndexed { index, value ->\n                    push(value, visited, stack) { Ref.ArrayRef(element, index) }\n                }\n            }\n            // Special code for platform types that cannot be reflectively accessed on modern JDKs\n            type.name.startsWith(\"java.\") && element is Collection<*> -> {\n                element.forEachIndexed { index, value ->\n                    push(value, visited, stack) { Ref.ArrayRef(element, index) }\n                }\n            }\n            type.name.startsWith(\"java.\") && element is Map<*, *> -> {\n                push(element.keys, visited, stack) { Ref.FieldRef(element, \"keys\") }\n                push(element.values, visited, stack) { Ref.FieldRef(element, \"values\") }\n            }\n            element is AtomicReference<*> -> {\n                push(element.get(), visited, stack) { Ref.FieldRef(element, \"value\") }\n            }\n            element is AtomicReferenceArray<*> -> {\n                for (index in 0 until element.length()) {\n                    push(element[index], visited, stack) { Ref.ArrayRef(element, index) }\n                }\n            }\n            element is AtomicLongFieldUpdater<*> -> {\n                /* filter it out here to suppress its subclasses too */\n            }\n            // All the other classes are reflectively scanned\n            else -> fields(type, statics).forEach { field ->\n                push(field.get(element), visited, stack) { Ref.FieldRef(element, field.name) }\n                // special case to scan Throwable cause (cannot get it reflectively)\n                if (element is Throwable) {\n                    push(element.cause, visited, stack) { Ref.FieldRef(element, \"cause\") }\n                }\n            }\n        }\n    }\n\n    private inline fun push(value: Any?, visited: IdentityHashMap<Any, Ref>, stack: ArrayDeque<Any>, ref: () -> Ref) {\n        if (value != null && !visited.containsKey(value)) {\n            visited[value] = ref()\n            stack.addLast(value)\n        }\n    }\n\n    private fun fields(type0: Class<*>, rootStatics: Boolean): List<Field> {\n        fieldsCache[type0]?.let { return it }\n        val result = ArrayList<Field>()\n        var type = type0\n        var statics = rootStatics\n        while (true) {\n            val fields = type.declaredFields.filter {\n                !it.type.isPrimitive\n                    && (statics || !Modifier.isStatic(it.modifiers))\n                    && !(it.type.isArray && it.type.componentType.isPrimitive)\n                    && it.name != \"previousOut\" // System.out from TestBase that we store in a field to restore later\n            }\n            check(fields.isEmpty() || !type.name.startsWith(\"java.\")) {\n                \"\"\"\n                    Trying to walk through JDK's '$type' will get into illegal reflective access on JDK 9+.\n                    Either modify your test to avoid usage of this class or update FieldWalker code to retrieve \n                    the captured state of this class without going through reflection (see how collections are handled).  \n                \"\"\".trimIndent()\n            }\n            fields.forEach { it.isAccessible = true } // make them all accessible\n            result.addAll(fields)\n            type = type.superclass\n            statics = false\n            val superFields = fieldsCache[type] // will stop at Any anyway\n            if (superFields != null) {\n                result.addAll(superFields)\n                break\n            }\n        }\n        fieldsCache[type0] = result\n        return result\n    }\n}\n"
    },
    {
        "path": "test-utils/jvm/src/TestBase.kt",
        "content": "package kotlinx.coroutines.testing\n\nimport kotlinx.coroutines.scheduling.*\nimport java.io.*\nimport java.util.*\nimport kotlin.coroutines.*\nimport kotlinx.coroutines.*\nimport kotlin.test.*\n\nactual val VERBOSE = try {\n    System.getProperty(\"test.verbose\")?.toBoolean() ?: false\n} catch (e: SecurityException) {\n    false\n}\n\n/**\n * Is `true` when running in a nightly stress test mode.\n */\nactual val isStressTest = System.getProperty(\"stressTest\")?.toBoolean() ?: false\n\nactual val stressTestMultiplierSqrt = if (isStressTest) 5 else 1\n\nprivate const val SHUTDOWN_TIMEOUT = 1_000L // 1s at most to wait per thread\n\n/**\n * Multiply various constants in stress tests by this factor, so that they run longer during nightly stress test.\n */\nactual val stressTestMultiplier = stressTestMultiplierSqrt * stressTestMultiplierSqrt\n\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\nactual typealias TestResult = Unit\n\ninternal actual fun lastResortReportException(error: Throwable) {\n    System.err.println(\"${error.message}${error.cause?.let { \": $it\" } ?: \"\"}\")\n    error.cause?.printStackTrace(System.err)\n    System.err.println(\"--- Detected at ---\")\n    Throwable().printStackTrace(System.err)\n}\n\n/**\n * Base class for tests, so that tests for predictable scheduling of actions in multiple coroutines sharing a single\n * thread can be written. Use it like this:\n *\n * ```\n * class MyTest : TestBase() {\n *    @Test\n *    fun testSomething() = runBlocking { // run in the context of the main thread\n *        expect(1) // initiate action counter\n *        launch { // use the context of the main thread\n *           expect(3) // the body of this coroutine in going to be executed in the 3rd step\n *        }\n *        expect(2) // launch just scheduled coroutine for execution later, so this line is executed second\n *        yield() // yield main thread to the launched job\n *        finish(4) // fourth step is the last one. `finish` must be invoked or test fails\n *    }\n * }\n * ```\n */\nactual open class TestBase(\n    private var disableOutCheck: Boolean,\n    private val errorCatching: ErrorCatching.Impl = ErrorCatching.Impl()\n): OrderedExecutionTestBase(), ErrorCatching by errorCatching {\n\n    actual constructor(): this(false)\n\n    // Shutdown sequence\n    private lateinit var threadsBefore: Set<Thread>\n    private val uncaughtExceptions = Collections.synchronizedList(ArrayList<Throwable>())\n    private var originalUncaughtExceptionHandler: Thread.UncaughtExceptionHandler? = null\n    /*\n     * System.out that we redefine in order to catch any debugging/diagnostics\n     * 'println' from main source set.\n     * NB: We do rely on the name 'previousOut' in the FieldWalker in order to skip its\n     * processing\n     */\n    private lateinit var previousOut: PrintStream\n\n    private object TestOutputStream : PrintStream(object : OutputStream() {\n        override fun write(b: Int) {\n            error(\"Detected unexpected call to 'println' from source code\")\n        }\n    })\n\n    actual fun println(message: Any?) {\n        if (disableOutCheck) kotlin.io.println(message)\n        else previousOut.println(message)\n    }\n\n    @BeforeTest\n    fun before() {\n        initPoolsBeforeTest()\n        threadsBefore = currentThreads()\n        originalUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler()\n        Thread.setDefaultUncaughtExceptionHandler { t, e ->\n            println(\"Exception in thread $t: $e\") // The same message as in default handler\n            e.printStackTrace()\n            uncaughtExceptions.add(e)\n        }\n        if (!disableOutCheck) {\n            previousOut = System.out\n            System.setOut(TestOutputStream)\n        }\n    }\n\n    @AfterTest\n    fun onCompletion() {\n        // onCompletion should not throw exceptions before it finishes all cleanup, so that other tests always\n        // start in a clear, restored state\n        checkFinishCall()\n        if (!disableOutCheck) { // Restore global System.out first\n            System.setOut(previousOut)\n        }\n        // Shutdown all thread pools\n        shutdownPoolsAfterTest()\n        // Check that are now leftover threads\n        runCatching {\n            checkTestThreads(threadsBefore)\n        }.onFailure {\n            reportError(it)\n        }\n        // Restore original uncaught exception handler after the main shutdown sequence\n        Thread.setDefaultUncaughtExceptionHandler(originalUncaughtExceptionHandler)\n        if (uncaughtExceptions.isNotEmpty()) {\n            error(\"Expected no uncaught exceptions, but got $uncaughtExceptions\")\n        }\n        // The very last action -- throw error if any was detected\n        errorCatching.close()\n    }\n\n    actual fun runTest(\n        expected: ((Throwable) -> Boolean)?,\n        unhandled: List<(Throwable) -> Boolean>,\n        block: suspend CoroutineScope.() -> Unit\n    ): TestResult {\n        var exCount = 0\n        var ex: Throwable? = null\n        try {\n            runBlocking(block = block, context = CoroutineExceptionHandler { _, e ->\n                if (e is CancellationException) return@CoroutineExceptionHandler // are ignored\n                exCount++\n                when {\n                    exCount > unhandled.size ->\n                        error(\"Too many unhandled exceptions $exCount, expected ${unhandled.size}, got: $e\", e)\n                    !unhandled[exCount - 1](e) ->\n                        error(\"Unhandled exception was unexpected: $e\", e)\n                }\n            })\n        } catch (e: Throwable) {\n            ex = e\n            if (expected != null) {\n                if (!expected(e))\n                    error(\"Unexpected exception: $e\", e)\n            } else {\n                throw e\n            }\n        } finally {\n            if (ex == null && expected != null) error(\"Exception was expected but none produced\")\n        }\n        if (exCount < unhandled.size)\n            error(\"Too few unhandled exceptions $exCount, expected ${unhandled.size}\")\n    }\n\n    protected suspend fun currentDispatcher() = coroutineContext[ContinuationInterceptor]!!\n}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun initPoolsBeforeTest() {\n    DefaultScheduler.usePrivateScheduler()\n}\n\n@Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\nfun shutdownPoolsAfterTest() {\n    DefaultScheduler.shutdown(SHUTDOWN_TIMEOUT)\n    DefaultExecutor.shutdownForTests(SHUTDOWN_TIMEOUT)\n    DefaultScheduler.restore()\n}\n\nactual val isNative = false\n\nactual val isBoundByJsTestTimeout = false\n\n/*\n * We ignore tests that test **real** non-virtualized tests with time on Windows, because\n * our CI Windows is virtualized itself (oh, the irony) and its clock resolution is dozens of ms,\n * which makes such tests flaky.\n */\nactual val isJavaAndWindows: Boolean = System.getProperty(\"os.name\")!!.contains(\"Windows\")\n"
    },
    {
        "path": "test-utils/jvm/src/Threads.kt",
        "content": "package kotlinx.coroutines.testing\n\nimport kotlinx.coroutines.*\nimport java.lang.Runnable\n\nprivate const val WAIT_LOST_THREADS = 10_000L // 10s\nprivate val ignoreLostThreads = mutableSetOf<String>()\n\nfun ignoreLostThreads(vararg s: String) { ignoreLostThreads += s }\n\nfun currentThreads(): Set<Thread> {\n    var estimate = 0\n    while (true) {\n        estimate = estimate.coerceAtLeast(Thread.activeCount() + 1)\n        val arrayOfThreads = Array<Thread?>(estimate) { null }\n        val n = Thread.enumerate(arrayOfThreads)\n        if (n >= estimate) {\n            estimate = n + 1\n            continue // retry with a better size estimate\n        }\n        val threads = hashSetOf<Thread>()\n        for (i in 0 until n)\n            threads.add(arrayOfThreads[i]!!)\n        return threads\n    }\n}\n\nfun List<Thread>.dumpThreads(header: String) {\n    println(\"=== $header\")\n    forEach { thread ->\n        println(\"Thread \\\"${thread.name}\\\" ${thread.state}\")\n        val trace = thread.stackTrace\n        for (t in trace) println(\"\\tat ${t.className}.${t.methodName}(${t.fileName}:${t.lineNumber})\")\n        println()\n    }\n    println(\"===\")\n}\n\nclass PoolThread(\n    @JvmField val dispatcher: ExecutorCoroutineDispatcher, // for debugging & tests\n    target: Runnable, name: String\n) : Thread(target, name) {\n    init {\n        isDaemon = true\n    }\n}\n\nfun ExecutorCoroutineDispatcher.dumpThreads(header: String) =\n    currentThreads().filter { it is PoolThread && it.dispatcher == this@dumpThreads }.dumpThreads(header)\n\nfun checkTestThreads(threadsBefore: Set<Thread>) {\n    // give threads some time to shutdown\n    val waitTill = System.currentTimeMillis() + WAIT_LOST_THREADS\n    var diff: List<Thread>\n    do {\n        val threadsAfter = currentThreads()\n        diff = (threadsAfter - threadsBefore).filter { thread ->\n            ignoreLostThreads.none { prefix -> thread.name.startsWith(prefix) }\n        }\n        if (diff.isEmpty()) break\n    } while (System.currentTimeMillis() <= waitTill)\n    ignoreLostThreads.clear()\n    if (diff.isEmpty()) return\n    val message = \"Lost threads ${diff.map { it.name }}\"\n    println(\"!!! $message\")\n    diff.dumpThreads(\"Dumping lost thread stack traces\")\n    error(message)\n}\n"
    },
    {
        "path": "test-utils/native/src/TestBase.kt",
        "content": "package kotlinx.coroutines.testing\n\nimport kotlin.test.*\nimport kotlinx.coroutines.*\n\nactual val VERBOSE = false\n\nactual typealias NoNative = Ignore\n\npublic actual val isStressTest: Boolean = false\npublic actual val stressTestMultiplier: Int = 1\npublic actual val stressTestMultiplierSqrt: Int = 1\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual typealias TestResult = Unit\n\ninternal actual fun lastResortReportException(error: Throwable) {\n    println(error)\n}\n\npublic actual open class TestBase actual constructor(): OrderedExecutionTestBase(), ErrorCatching by ErrorCatching.Impl() {\n    actual fun println(message: Any?) {\n        kotlin.io.println(message)\n    }\n\n    public actual fun runTest(\n        expected: ((Throwable) -> Boolean)?,\n        unhandled: List<(Throwable) -> Boolean>,\n        block: suspend CoroutineScope.() -> Unit\n    ): TestResult {\n        var exCount = 0\n        var ex: Throwable? = null\n        try {\n            runBlocking(block = block, context = CoroutineExceptionHandler { _, e ->\n                if (e is CancellationException) return@CoroutineExceptionHandler // are ignored\n                exCount++\n                when {\n                    exCount > unhandled.size ->\n                        error(\"Too many unhandled exceptions $exCount, expected ${unhandled.size}, got: $e\", e)\n                    !unhandled[exCount - 1](e) ->\n                        error(\"Unhandled exception was unexpected: $e\", e)\n                }\n            })\n        } catch (e: Throwable) {\n            ex = e\n            if (expected != null) {\n                if (!expected(e))\n                    error(\"Unexpected exception: $e\", e)\n            } else\n                throw e\n        } finally {\n            if (ex == null && expected != null) error(\"Exception was expected but none produced\")\n        }\n        if (exCount < unhandled.size)\n            error(\"Too few unhandled exceptions $exCount, expected ${unhandled.size}\")\n    }\n}\n\npublic actual val isNative = true\n\npublic actual val isBoundByJsTestTimeout = false\n\npublic actual val isJavaAndWindows: Boolean get() = false\n"
    },
    {
        "path": "test-utils/wasmJs/src/TestBase.kt",
        "content": "package kotlinx.coroutines.testing\n\nimport kotlin.test.*\nimport kotlin.js.*\nimport kotlinx.coroutines.*\n\nactual val VERBOSE = false\n\nactual typealias NoJs = Ignore\n\nactual val isStressTest: Boolean = false\nactual val stressTestMultiplier: Int = 1\nactual val stressTestMultiplierSqrt: Int = 1\n\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"ACTUAL_TYPE_ALIAS_TO_CLASS_WITH_DECLARATION_SITE_VARIANCE\")\nactual typealias TestResult = Promise<JsAny?>\n\ninternal actual fun lastResortReportException(error: Throwable) {\n    println(error)\n}\n\nactual open class TestBase(\n    private val errorCatching: ErrorCatching.Impl\n): OrderedExecutionTestBase(), ErrorCatching by errorCatching {\n    private var lastTestPromise: Promise<JsAny?>? = null\n\n    actual constructor(): this(errorCatching = ErrorCatching.Impl())\n\n    actual fun println(message: Any?) {\n        kotlin.io.println(message)\n    }\n\n    actual fun runTest(\n        expected: ((Throwable) -> Boolean)?,\n        unhandled: List<(Throwable) -> Boolean>,\n        block: suspend CoroutineScope.() -> Unit\n    ): TestResult {\n        var exCount = 0\n        var ex: Throwable? = null\n        /*\n         * This is an additional sanity check against `runTest` mis-usage on JS.\n         * The only way to write an async test on JS is to return Promise from the test function.\n         * _Just_ launching promise and returning `Unit` won't suffice as the underlying test framework\n         * won't be able to detect an asynchronous failure in a timely manner.\n         * We cannot detect such situations, but we can detect the most common erroneous pattern\n         * in our code base, an attempt to use multiple `runTest` in the same `@Test` method,\n         * which typically is a premise to the same error:\n         * ```\n         * @Test\n         * fun incorrectTestForJs() { // <- promise is not returned\n         *     for (parameter in parameters) {\n         *         runTest {\n         *             runTestForParameter(parameter)\n         *         }\n         *     }\n         * }\n         * ```\n         */\n        if (lastTestPromise != null) {\n            error(\"Attempt to run multiple asynchronous test within one @Test method\")\n        }\n        val result = GlobalScope.promise(block = block, context = CoroutineExceptionHandler { _, e ->\n            if (e is CancellationException) return@CoroutineExceptionHandler // are ignored\n            exCount++\n            when {\n                exCount > unhandled.size ->\n                    error(\"Too many unhandled exceptions $exCount, expected ${unhandled.size}, got: $e\", e)\n                !unhandled[exCount - 1](e) ->\n                    error(\"Unhandled exception was unexpected: $e\", e)\n            }\n        }).catch { jsE ->\n            val e = jsE.toThrowableOrNull() ?: error(\"Unexpected non-Kotlin exception $jsE\")\n            ex = e\n            if (expected != null) {\n                if (!expected(e)) {\n                    println(e)\n                    error(\"Unexpected exception $e\", e)\n                }\n            } else\n                throw e\n            null\n        }.finally {\n            if (ex == null && expected != null) error(\"Exception was expected but none produced\")\n            if (exCount < unhandled.size)\n                error(\"Too few unhandled exceptions $exCount, expected ${unhandled.size}\")\n            errorCatching.close()\n            checkFinishCall()\n        }\n        lastTestPromise = result\n        return result\n    }\n}\n\nactual val isNative = false\n\nactual val isBoundByJsTestTimeout = true\n\nactual val isJavaAndWindows: Boolean get() = false\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/android-unit-tests/build.gradle.kts",
        "content": "project.configureAar()\n\ndependencies {\n    configureAarUnpacking()\n\n    testImplementation(\"com.google.android:android:${version(\"android\")}\")\n    testImplementation(\"org.robolectric:robolectric:${version(\"robolectric\")}\")\n    // Required by robolectric\n    testImplementation(\"androidx.test:core:1.2.0\")\n    testImplementation(\"androidx.test:monitor:1.2.0\")\n\n    testImplementation(project(\":kotlinx-coroutines-test\"))\n    testImplementation(project(\":kotlinx-coroutines-android\"))\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/android-unit-tests/src/EmptyCoroutineScopeImpl.kt",
        "content": "package kotlinx.coroutines.android\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n// Classes for testing service loader\ninternal class EmptyCoroutineScopeImpl1 : CoroutineScope {\n    override val coroutineContext: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n\ninternal class EmptyCoroutineScopeImpl2 : CoroutineScope {\n    override val coroutineContext: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n\ninternal class EmptyCoroutineScopeImpl3 : CoroutineScope {\n    override val coroutineContext: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/android-unit-tests/test/ordered/tests/CustomizedRobolectricTest.kt",
        "content": "package ordered.tests\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.test.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.robolectric.*\nimport org.robolectric.annotation.*\nimport org.robolectric.shadows.*\nimport kotlin.test.*\n\n\nclass InitMainDispatcherBeforeRobolectricTestRunner(testClass: Class<*>) : RobolectricTestRunner(testClass) {\n\n    init {\n        kotlin.runCatching {\n            // touch Main, watch it burn\n            GlobalScope.launch(Dispatchers.Main + CoroutineExceptionHandler { _, _ -> }) {  }\n        }\n    }\n}\n\n@Config(manifest = Config.NONE, sdk = [28])\n@RunWith(InitMainDispatcherBeforeRobolectricTestRunner::class)\n@LooperMode(LooperMode.Mode.LEGACY)\nclass CustomizedRobolectricTest : TestBase() {\n    @Test\n    fun testComponent()  {\n        // Note that main is not set at all\n        val component = TestComponent()\n        checkComponent(component)\n    }\n\n    @Test\n    fun testComponentAfterReset()  {\n        // Note that main is not set at all\n        val component = TestComponent()\n        Dispatchers.setMain(Dispatchers.Unconfined)\n        Dispatchers.resetMain()\n        checkComponent(component)\n    }\n\n\n    private fun checkComponent(component: TestComponent) {\n        val mainLooper = ShadowLooper.getShadowMainLooper()\n        mainLooper.pause()\n        component.launchSomething()\n        assertFalse(component.launchCompleted)\n        mainLooper.unPause()\n        assertTrue(component.launchCompleted)\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/android-unit-tests/test/ordered/tests/FirstMockedMainTest.kt",
        "content": "package ordered.tests\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.test.*\nimport org.junit.*\nimport org.junit.Test\nimport java.lang.IllegalStateException\nimport kotlin.test.*\n\nopen class FirstMockedMainTest : TestBase() {\n\n    @Before\n    fun setUp() {\n        Dispatchers.setMain(Dispatchers.Unconfined)\n    }\n\n    @After\n    fun tearDown() {\n        Dispatchers.resetMain()\n    }\n\n    @Test\n    fun testComponent() {\n        val component = TestComponent()\n        component.launchSomething()\n        assertTrue(component.launchCompleted)\n    }\n\n    @Test\n    fun testFailureWhenReset() {\n        Dispatchers.resetMain()\n        val component = TestComponent()\n        try {\n            component.launchSomething()\n            throw component.caughtException\n        } catch (e: IllegalStateException) {\n            assertTrue(e.message!!.contains(\"Dispatchers.setMain from kotlinx-coroutines-test\"))\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/android-unit-tests/test/ordered/tests/FirstRobolectricTest.kt",
        "content": "package ordered.tests\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.test.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.robolectric.*\nimport org.robolectric.annotation.*\nimport org.robolectric.shadows.*\nimport kotlin.test.*\n\n@RunWith(RobolectricTestRunner::class)\n@Config(manifest = Config.NONE, sdk = [28])\n@LooperMode(LooperMode.Mode.LEGACY)\nopen class FirstRobolectricTest {\n    @Test\n    fun testComponent()  {\n        // Note that main is not set at all\n        val component = TestComponent()\n        checkComponent(component)\n    }\n\n    @Test\n    fun testComponentAfterReset()  {\n        // Note that main is not set at all\n        val component = TestComponent()\n        Dispatchers.setMain(Dispatchers.Unconfined)\n        Dispatchers.resetMain()\n        checkComponent(component)\n    }\n\n    @Test\n    fun testDelay() {\n        val component = TestComponent()\n        val mainLooper = ShadowLooper.getShadowMainLooper()\n        mainLooper.pause()\n        component.launchDelayed()\n        mainLooper.runToNextTask()\n        assertFalse(component.delayedLaunchCompleted)\n        mainLooper.runToNextTask()\n        assertTrue(component.delayedLaunchCompleted)\n    }\n\n    private fun checkComponent(component: TestComponent) {\n        val mainLooper = ShadowLooper.getShadowMainLooper()\n        mainLooper.pause()\n        component.launchSomething()\n        assertFalse(component.launchCompleted)\n        mainLooper.unPause()\n        assertTrue(component.launchCompleted)\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/android-unit-tests/test/ordered/tests/MockedMainTest.kt",
        "content": "package ordered.tests\n\nclass MockedMainTest : FirstMockedMainTest()\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/android-unit-tests/test/ordered/tests/RobolectricTest.kt",
        "content": "package ordered.tests\n\nopen class RobolectricTest : FirstRobolectricTest()\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/android-unit-tests/test/ordered/tests/TestComponent.kt",
        "content": "package ordered.tests\n\nimport kotlinx.coroutines.*\n\npublic class TestComponent {\n    internal lateinit var caughtException: Throwable\n    private val scope =\n        CoroutineScope(SupervisorJob() + Dispatchers.Main + CoroutineExceptionHandler { _, e -> caughtException = e})\n    public var launchCompleted = false\n    public var delayedLaunchCompleted = false\n\n    fun launchSomething() {\n        scope.launch {\n            launchCompleted = true\n        }\n    }\n\n    fun launchDelayed() {\n        scope.launch {\n            delay(Long.MAX_VALUE / 2)\n            delayedLaunchCompleted = true\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/build.gradle.kts",
        "content": "configurations {\n    create(\"r8\")\n}\n\nrepositories {\n    mavenCentral()\n}\n\nproject.configureAar()\n\ndependencies {\n    configureAarUnpacking()\n\n    compileOnly(\"com.google.android:android:${version(\"android\")}\")\n    compileOnly(\"androidx.annotation:annotation:${version(\"androidx_annotation\")}\")\n\n    testImplementation(\"com.google.android:android:${version(\"android\")}\")\n    testImplementation(\"org.robolectric:robolectric:${version(\"robolectric\")}\")\n    // Required by robolectric\n    testImplementation(\"androidx.test:core:1.2.0\")\n    testImplementation(\"androidx.test:monitor:1.2.0\")\n\n\n    testImplementation(\"org.smali:baksmali:${version(\"baksmali\")}\")\n    \"r8\"(\"com.android.tools.build:builder:8.1.0\")\n}\n\nval optimizedDexDir = layout.buildDirectory.dir(\"dex-optim/\")\nval unOptimizedDexDir = layout.buildDirectory.dir(\"dex-unoptim/\")\n\nval optimizedDexFile = optimizedDexDir.map { it.dir(\"classes.dex\") } .get().asFile\nval unOptimizedDexFile = unOptimizedDexDir.map { it.dir(\"classes.dex\") }.get().asFile\n\nval runR8 by tasks.registering(RunR8::class) {\n    outputDex = optimizedDexDir.get().asFile\n    inputConfig = file(\"testdata/r8-test-rules.pro\")\n\n    dependsOn(\"jar\")\n}\n\nval runR8NoOptim by tasks.registering(RunR8::class) {\n    outputDex = unOptimizedDexDir.get().asFile\n    inputConfig = file(\"testdata/r8-test-rules-no-optim.pro\")\n\n    dependsOn(\"jar\")\n}\n\ntasks.test {\n    // Ensure the R8-processed dex is built and supply its path as a property to the test.\n    dependsOn(runR8)\n    dependsOn(runR8NoOptim)\n\n    inputs.files(optimizedDexFile, unOptimizedDexFile)\n\n    systemProperty(\"dexPath\", optimizedDexFile.absolutePath)\n    systemProperty(\"noOptimDexPath\", unOptimizedDexFile.absolutePath)\n\n    // Output custom metric with the size of the optimized dex\n    doLast {\n        println(\"##teamcity[buildStatisticValue key='optimizedDexSize' value='${optimizedDexFile.length()}']\")\n    }\n}\n\nexternalDocumentationLink(\n    url = \"https://developer.android.com/reference/\"\n)\n/*\n * Task used by our ui/android tests to test minification results and keep track of size of the binary.\n */\nopen class RunR8 : JavaExec() {\n\n    @OutputDirectory\n    lateinit var outputDex: File\n\n    @InputFile\n    lateinit var inputConfig: File\n\n    @InputFile\n    val inputConfigCommon: File = File(\"testdata/r8-test-common.pro\")\n\n    @InputFiles\n    val jarFile: File = project.tasks.named<Zip>(\"jar\").get().archiveFile.get().asFile\n\n    init {\n        classpath = project.configurations[\"r8\"]\n        mainClass = \"com.android.tools.r8.R8\"\n    }\n\n    override fun exec() {\n        // Resolve classpath only during execution\n        val arguments = mutableListOf(\n            \"--release\",\n            \"--no-desugaring\",\n            \"--min-api\", \"26\",\n            \"--output\", outputDex.absolutePath,\n            \"--pg-conf\", inputConfig.absolutePath\n        )\n        arguments.addAll(project.configurations[\"runtimeClasspath\"].files.map { it.absolutePath })\n        arguments.add(jarFile.absolutePath)\n\n        args = arguments\n\n        project.delete(outputDex)\n        outputDex.mkdirs()\n\n        super.exec()\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/src/AndroidExceptionPreHandler.kt",
        "content": "package kotlinx.coroutines.android\n\nimport android.os.*\nimport kotlinx.coroutines.*\nimport java.lang.reflect.*\nimport kotlin.coroutines.*\n\ninternal class AndroidExceptionPreHandler :\n    AbstractCoroutineContextElement(CoroutineExceptionHandler), CoroutineExceptionHandler\n{\n    @Volatile\n    private var _preHandler: Any? = this // uninitialized marker\n\n    // Reflectively lookup pre-handler.\n    private fun preHandler(): Method? {\n        val current = _preHandler\n        if (current !== this) return current as Method?\n        val declared = try {\n            Thread::class.java.getDeclaredMethod(\"getUncaughtExceptionPreHandler\").takeIf {\n                Modifier.isPublic(it.modifiers) && Modifier.isStatic(it.modifiers)\n            }\n        } catch (e: Throwable) {\n            null /* not found */\n        }\n        _preHandler = declared\n        return declared\n    }\n\n    override fun handleException(context: CoroutineContext, exception: Throwable) {\n        /*\n         * Android Oreo introduced private API for a global pre-handler for uncaught exceptions, to ensure that the\n         * exceptions are logged even if the default uncaught exception handler is replaced by the app. The pre-handler\n         * is invoked from the Thread's private dispatchUncaughtException() method, so our manual invocation of the\n         * Thread's uncaught exception handler bypasses the pre-handler in Android Oreo, and uncaught coroutine\n         * exceptions are not logged. This issue was addressed in Android Pie, which added a check in the default\n         * uncaught exception handler to invoke the pre-handler if it was not invoked already (see\n         * https://android-review.googlesource.com/c/platform/frameworks/base/+/654578/). So the issue is present only\n         * in Android Oreo.\n         *\n         * We're fixing this by manually invoking the pre-handler using reflection, if running on an Android Oreo SDK\n         * version (26 and 27).\n         */\n        if (Build.VERSION.SDK_INT in 26..27) {\n            (preHandler()?.invoke(null) as? Thread.UncaughtExceptionHandler)\n                ?.uncaughtException(Thread.currentThread(), exception)\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/src/HandlerDispatcher.kt",
        "content": "@file:Suppress(\"unused\")\n\npackage kotlinx.coroutines.android\n\nimport android.os.*\nimport android.view.*\nimport androidx.annotation.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport java.lang.reflect.*\nimport kotlin.coroutines.*\n\n/**\n * Dispatches execution onto Android [Handler].\n *\n * This class provides type-safety and a point for future extensions.\n */\npublic sealed class HandlerDispatcher : MainCoroutineDispatcher(), Delay {\n    /**\n     * Returns dispatcher that executes coroutines immediately when it is already in the right context\n     * (current looper is the same as this handler's looper) without an additional [re-dispatch][CoroutineDispatcher.dispatch].\n     * This dispatcher does not use [Handler.post] when current looper is the same as looper of the handler.\n     *\n     * Immediate dispatcher is safe from stack overflows and in case of nested invocations forms event-loop similar to [Dispatchers.Unconfined].\n     * The event loop is an advanced topic and its implications can be found in [Dispatchers.Unconfined] documentation.\n     *\n     * Example of usage:\n     * ```\n     * suspend fun updateUiElement(val text: String) {\n     *   /*\n     *    * If it is known that updateUiElement can be invoked both from the Main thread and from other threads,\n     *    * `immediate` dispatcher is used as a performance optimization to avoid unnecessary dispatch.\n     *    *\n     *    * In that case, when `updateUiElement` is invoked from the Main thread, `uiElement.text` will be\n     *    * invoked immediately without any dispatching, otherwise, the `Dispatchers.Main` dispatch cycle via\n     *    * `Handler.post` will be triggered.\n     *    */\n     *   withContext(Dispatchers.Main.immediate) {\n     *     uiElement.text = text\n     *   }\n     *   // Do context-independent logic such as logging\n     * }\n     * ```\n     */\n    public abstract override val immediate: HandlerDispatcher\n}\n\ninternal class AndroidDispatcherFactory : MainDispatcherFactory {\n\n    override fun createDispatcher(allFactories: List<MainDispatcherFactory>): MainCoroutineDispatcher {\n        val mainLooper = Looper.getMainLooper() ?: throw IllegalStateException(\"The main looper is not available\")\n        return HandlerContext(mainLooper.asHandler(async = true))\n    }\n\n    override fun hintOnError(): String = \"For tests Dispatchers.setMain from kotlinx-coroutines-test module can be used\"\n\n    override val loadPriority: Int\n        get() = Int.MAX_VALUE / 2\n}\n\n/**\n * Represents an arbitrary [Handler] as an implementation of [CoroutineDispatcher]\n * with an optional [name] for nicer debugging\n *\n * ## Rejected execution\n *\n * If the underlying handler is closed and its message-scheduling methods start to return `false` on\n * an attempt to submit a continuation task to the resulting dispatcher,\n * then the [Job] of the affected task is [cancelled][Job.cancel] and the task is submitted to the\n * [Dispatchers.IO], so that the affected coroutine can cleanup its resources and promptly complete.\n */\n@JvmName(\"from\") // this is for a nice Java API, see issue #255\n@JvmOverloads\npublic fun Handler.asCoroutineDispatcher(name: String? = null): HandlerDispatcher =\n    HandlerContext(this, name)\n\nprivate const val MAX_DELAY = Long.MAX_VALUE / 2 // cannot delay for too long on Android\n\n@VisibleForTesting\ninternal fun Looper.asHandler(async: Boolean): Handler {\n    // Async support was added in API 16.\n    if (!async || Build.VERSION.SDK_INT < 16) {\n        return Handler(this)\n    }\n\n    if (Build.VERSION.SDK_INT >= 28) {\n        // TODO compile against API 28 so this can be invoked without reflection.\n        val factoryMethod = Handler::class.java.getDeclaredMethod(\"createAsync\", Looper::class.java)\n        return factoryMethod.invoke(null, this) as Handler\n    }\n\n    val constructor: Constructor<Handler>\n    try {\n        constructor = Handler::class.java.getDeclaredConstructor(Looper::class.java,\n            Handler.Callback::class.java, Boolean::class.javaPrimitiveType)\n    } catch (ignored: NoSuchMethodException) {\n        // Hidden constructor absent. Fall back to non-async constructor.\n        return Handler(this)\n    }\n    return constructor.newInstance(this, null, true)\n}\n\n@JvmField\n@Deprecated(\"Use Dispatchers.Main instead\", level = DeprecationLevel.HIDDEN)\ninternal val Main: HandlerDispatcher? = runCatching { HandlerContext(Looper.getMainLooper().asHandler(async = true)) }.getOrNull()\n\n/**\n * Implements [CoroutineDispatcher] on top of an arbitrary Android [Handler].\n */\ninternal class HandlerContext private constructor(\n    private val handler: Handler,\n    private val name: String?,\n    private val invokeImmediately: Boolean\n) : HandlerDispatcher(), Delay {\n    /**\n     * Creates [CoroutineDispatcher] for the given Android [handler].\n     *\n     * @param handler a handler.\n     * @param name an optional name for debugging.\n     */\n    constructor(\n        handler: Handler,\n        name: String? = null\n    ) : this(handler, name, false)\n\n    override val immediate: HandlerContext = if (invokeImmediately) this else\n        HandlerContext(handler, name, true)\n\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean {\n        return !invokeImmediately || Looper.myLooper() != handler.looper\n    }\n\n    override fun dispatch(context: CoroutineContext, block: Runnable) {\n        if (!handler.post(block)) {\n            cancelOnRejection(context, block)\n        }\n    }\n\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val block = Runnable {\n            with(continuation) { resumeUndispatched(Unit) }\n        }\n        if (handler.postDelayed(block, timeMillis.coerceAtMost(MAX_DELAY))) {\n            continuation.invokeOnCancellation { handler.removeCallbacks(block) }\n        } else {\n            cancelOnRejection(continuation.context, block)\n        }\n    }\n\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        if (handler.postDelayed(block, timeMillis.coerceAtMost(MAX_DELAY))) {\n            return DisposableHandle { handler.removeCallbacks(block) }\n        }\n        cancelOnRejection(context, block)\n        return NonDisposableHandle\n    }\n\n    private fun cancelOnRejection(context: CoroutineContext, block: Runnable) {\n        context.cancel(CancellationException(\"The task was rejected, the handler underlying the dispatcher '${toString()}' was closed\"))\n        Dispatchers.IO.dispatch(context, block)\n    }\n\n    override fun toString(): String = toStringInternalImpl() ?: run {\n        val str = name ?: handler.toString()\n        if (invokeImmediately) \"$str.immediate\" else str\n    }\n\n    override fun equals(other: Any?): Boolean =\n        other is HandlerContext && other.handler === handler && other.invokeImmediately == invokeImmediately\n    // inlining `Boolean.hashCode()` for Android compatibility, as requested by Animal Sniffer\n    override fun hashCode(): Int = System.identityHashCode(handler) xor if (invokeImmediately) 1231 else 1237\n}\n\n@Volatile\nprivate var choreographer: Choreographer? = null\n\n/**\n * Awaits the next animation frame and returns frame time in nanoseconds.\n */\npublic suspend fun awaitFrame(): Long {\n    // fast path when choreographer is already known\n    val choreographer = choreographer\n    return if (choreographer != null) {\n        suspendCancellableCoroutine { cont ->\n            postFrameCallback(choreographer, cont)\n        }\n    } else {\n        awaitFrameSlowPath()\n    }\n}\n\nprivate suspend fun awaitFrameSlowPath(): Long = suspendCancellableCoroutine { cont ->\n    if (Looper.myLooper() === Looper.getMainLooper()) { // Check if we are already in the main looper thread\n        updateChoreographerAndPostFrameCallback(cont)\n    } else { // post into looper thread to figure it out\n        Dispatchers.Main.dispatch(cont.context, Runnable {\n            updateChoreographerAndPostFrameCallback(cont)\n        })\n    }\n}\n\nprivate fun updateChoreographerAndPostFrameCallback(cont: CancellableContinuation<Long>) {\n    val choreographer = choreographer ?: Choreographer.getInstance()!!.also { choreographer = it }\n    postFrameCallback(choreographer, cont)\n}\n\nprivate fun postFrameCallback(choreographer: Choreographer, cont: CancellableContinuation<Long>) {\n    choreographer.postFrameCallback { nanos ->\n        with(cont) { Dispatchers.Main.resumeUndispatched(nanos) }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/test/AndroidExceptionPreHandlerTest.kt",
        "content": "package kotlinx.coroutines.android\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.robolectric.*\nimport org.robolectric.annotation.*\nimport kotlin.test.*\n\n@RunWith(RobolectricTestRunner::class)\n@Config(manifest = Config.NONE, sdk = [27])\n@LooperMode(LooperMode.Mode.LEGACY)\nclass AndroidExceptionPreHandlerTest : TestBase() {\n    @Test\n    fun testUnhandledException() = runTest {\n        val previousHandler = Thread.getDefaultUncaughtExceptionHandler()\n        try {\n            Thread.setDefaultUncaughtExceptionHandler { _, e ->\n                expect(3)\n                assertIs<TestException>(e)\n            }\n            expect(1)\n            GlobalScope.launch(Dispatchers.Main) {\n                expect(2)\n                throw TestException()\n            }.join()\n            finish(4)\n        } finally {\n            Thread.setDefaultUncaughtExceptionHandler(previousHandler)\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/test/DisabledHandlerTest.kt",
        "content": "package kotlinx.coroutines.android\n\nimport kotlinx.coroutines.testing.*\nimport android.os.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.runner.*\nimport org.robolectric.*\nimport org.robolectric.annotation.*\n\n@RunWith(RobolectricTestRunner::class)\n@Config(manifest = Config.NONE, sdk = [28])\n@LooperMode(LooperMode.Mode.LEGACY)\nclass DisabledHandlerTest : TestBase() {\n\n    private var delegateToSuper = false\n    private val disabledDispatcher = object : Handler() {\n        override fun sendMessageAtTime(msg: Message?, uptimeMillis: Long): Boolean {\n            if (delegateToSuper) return super.sendMessageAtTime(msg, uptimeMillis)\n            return false\n        }\n    }.asCoroutineDispatcher()\n\n    @Test\n    fun testRunBlocking() {\n        expect(1)\n        try {\n            runBlocking(disabledDispatcher) {\n                expectUnreached()\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            finish(2)\n        }\n    }\n\n    @Test\n    fun testInvokeOnCancellation() = runTest {\n        val job = launch(disabledDispatcher, start = CoroutineStart.LAZY) { expectUnreached() }\n        job.invokeOnCompletion { if (it != null) expect(2) }\n        yield()\n        expect(1)\n        job.join()\n        finish(3)\n    }\n\n    @Test\n    fun testWithTimeout() = runTest {\n        delegateToSuper = true\n        try {\n            withContext(disabledDispatcher) {\n                expect(1)\n                delegateToSuper = false\n                delay(Long.MAX_VALUE - 1)\n                expectUnreached()\n            }\n            expectUnreached()\n        } catch (e: CancellationException) {\n            finish(2)\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/test/HandlerDispatcherAsyncTest.kt",
        "content": "package kotlinx.coroutines.android\n\nimport kotlinx.coroutines.testing.*\nimport android.os.*\nimport kotlinx.coroutines.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.robolectric.*\nimport org.robolectric.Shadows.*\nimport org.robolectric.annotation.*\nimport org.robolectric.shadows.*\nimport org.robolectric.util.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\n@RunWith(RobolectricTestRunner::class)\n@Config(manifest = Config.NONE, sdk = [28])\n@LooperMode(LooperMode.Mode.LEGACY)\nclass HandlerDispatcherAsyncTest : TestBase() {\n\n    /**\n     * Because [Dispatchers.Main] is a singleton, we cannot vary its initialization behavior. As a\n     * result we only test its behavior on the newest API level and assert that it uses async\n     * messages. We rely on the other tests to exercise the variance of the mechanism that the main\n     * dispatcher uses to ensure it has correct behavior on all API levels.\n     */\n    @Test\n    fun mainIsAsync() = runTest {\n        ReflectionHelpers.setStaticField(Build.VERSION::class.java, \"SDK_INT\", 28)\n\n        val mainLooper = shadowOf(Looper.getMainLooper())\n        mainLooper.pause()\n        val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)\n\n        val job = launch(Dispatchers.Main) {\n            expect(2)\n        }\n\n        val message = mainMessageQueue.head\n        assertTrue(message.isAsynchronous)\n        job.join(mainLooper)\n    }\n\n    @Test\n    fun asyncMessagesApi14() = runTest {\n        ReflectionHelpers.setStaticField(Build.VERSION::class.java, \"SDK_INT\", 14)\n\n        val main = Looper.getMainLooper().asHandler(async = true).asCoroutineDispatcher()\n\n        val mainLooper = shadowOf(Looper.getMainLooper())\n        mainLooper.pause()\n        val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)\n\n        val job = launch(main) {\n            expect(2)\n        }\n\n        val message = mainMessageQueue.head\n        assertFalse(message.isAsynchronous)\n        job.join(mainLooper)\n    }\n\n    @Test\n    fun asyncMessagesApi16() = runTest {\n        ReflectionHelpers.setStaticField(Build.VERSION::class.java, \"SDK_INT\", 16)\n\n        val main = Looper.getMainLooper().asHandler(async = true).asCoroutineDispatcher()\n\n        val mainLooper = shadowOf(Looper.getMainLooper())\n        mainLooper.pause()\n        val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)\n\n        val job = launch(main) {\n            expect(2)\n        }\n\n        val message = mainMessageQueue.head\n        assertTrue(message.isAsynchronous)\n        job.join(mainLooper)\n    }\n\n    @Test\n    fun asyncMessagesApi28() = runTest {\n        ReflectionHelpers.setStaticField(Build.VERSION::class.java, \"SDK_INT\", 28)\n\n        val main = Looper.getMainLooper().asHandler(async = true).asCoroutineDispatcher()\n\n        val mainLooper = shadowOf(Looper.getMainLooper())\n        mainLooper.pause()\n        val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)\n\n        val job = launch(main) {\n            expect(2)\n        }\n\n        val message = mainMessageQueue.head\n        assertTrue(message.isAsynchronous)\n        job.join(mainLooper)\n    }\n\n    @Test\n    fun noAsyncMessagesIfNotRequested() = runTest {\n        ReflectionHelpers.setStaticField(Build.VERSION::class.java, \"SDK_INT\", 28)\n\n        val main = Looper.getMainLooper().asHandler(async = false).asCoroutineDispatcher()\n\n        val mainLooper = shadowOf(Looper.getMainLooper())\n        mainLooper.pause()\n        val mainMessageQueue = shadowOf(Looper.getMainLooper().queue)\n\n        val job = launch(main) {\n            expect(2)\n        }\n\n        val message = mainMessageQueue.head\n        assertFalse(message.isAsynchronous)\n        job.join(mainLooper)\n    }\n\n    @Test\n    fun testToString() {\n        ReflectionHelpers.setStaticField(Build.VERSION::class.java, \"SDK_INT\", 28)\n        val main = Looper.getMainLooper().asHandler(async = true).asCoroutineDispatcher(\"testName\")\n        assertEquals(\"testName\", main.toString())\n        assertEquals(\"testName.immediate\", main.immediate.toString())\n        assertEquals(\"testName.immediate\", main.immediate.immediate.toString())\n    }\n\n    private suspend fun Job.join(mainLooper: ShadowLooper) {\n        expect(1)\n        mainLooper.unPause()\n        join()\n        finish(3)\n    }\n\n    // TODO compile against API 23+ so this can be invoked without reflection.\n    private val Looper.queue: MessageQueue\n        get() = Looper::class.java.getDeclaredMethod(\"getQueue\").invoke(this) as MessageQueue\n\n    // TODO compile against API 22+ so this can be invoked without reflection.\n    private val Message.isAsynchronous: Boolean\n        get() = Message::class.java.getDeclaredMethod(\"isAsynchronous\").invoke(this) as Boolean\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/test/HandlerDispatcherTest.kt",
        "content": "package kotlinx.coroutines.android\n\nimport kotlinx.coroutines.testing.*\nimport android.os.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.testing.*\nimport org.junit.Test\nimport org.junit.runner.*\nimport org.robolectric.*\nimport org.robolectric.annotation.*\nimport org.robolectric.shadows.*\nimport java.util.concurrent.*\nimport kotlin.test.*\n\n@RunWith(RobolectricTestRunner::class)\n@LooperMode(LooperMode.Mode.LEGACY)\n@Config(manifest = Config.NONE, sdk = [28])\nclass HandlerDispatcherTest : MainDispatcherTestBase.WithRealTimeDelay() {\n    @Test\n    fun testDefaultDelayIsNotDelegatedToMain() = runTest {\n        val mainLooper = Shadows.shadowOf(Looper.getMainLooper())\n        mainLooper.pause()\n        assertFalse { mainLooper.scheduler.areAnyRunnable() }\n\n        val job = launch(Dispatchers.Default, start = CoroutineStart.UNDISPATCHED) {\n            expect(1)\n            delay(Long.MAX_VALUE)\n            expectUnreached()\n        }\n        expect(2)\n        assertEquals(0, mainLooper.scheduler.size())\n        job.cancelAndJoin()\n        finish(3)\n    }\n\n    @Test\n    fun testWithTimeoutIsDelegatedToMain() = runTest {\n        val mainLooper = Shadows.shadowOf(Looper.getMainLooper())\n        mainLooper.pause()\n        assertFalse { mainLooper.scheduler.areAnyRunnable() }\n        val job = launch(Dispatchers.Main, start = CoroutineStart.UNDISPATCHED) {\n            withTimeout(1) {\n                expect(1)\n                hang { expect(3) }\n            }\n            expectUnreached()\n        }\n        expect(2)\n        assertEquals(1, mainLooper.scheduler.size())\n        // Schedule cancellation\n        mainLooper.runToEndOfTasks()\n        job.join()\n        finish(4)\n    }\n\n    @Test\n    fun testDelayDelegatedToMain() = runTest {\n        val mainLooper = Shadows.shadowOf(Looper.getMainLooper())\n        mainLooper.pause()\n        val job = launch(Dispatchers.Main, start = CoroutineStart.UNDISPATCHED) {\n            expect(1)\n            delay(1)\n            expect(3)\n        }\n        expect(2)\n        assertEquals(1, mainLooper.scheduler.size())\n        // Schedule cancellation\n        mainLooper.runToEndOfTasks()\n        job.join()\n        finish(4)\n    }\n\n    @Test\n    fun testAwaitFrame() = runTest {\n        doTestAwaitFrame()\n\n        reset()\n\n        // Now the second test: we cannot test it separately because we're caching choreographer in HandlerDispatcher\n        doTestAwaitWithDetectedChoreographer()\n    }\n\n    private fun CoroutineScope.doTestAwaitFrame() {\n        ShadowChoreographer.setPostFrameCallbackDelay(100)\n        val mainLooper = Shadows.shadowOf(Looper.getMainLooper())\n        mainLooper.pause()\n        launch(Dispatchers.Main, start = CoroutineStart.UNDISPATCHED) {\n            expect(1)\n            awaitFrame()\n            expect(3)\n        }\n        expect(2)\n        // Run choreographer detection\n        mainLooper.runOneTask()\n        finish(4)\n    }\n\n    private fun CoroutineScope.doTestAwaitWithDetectedChoreographer() {\n        ShadowChoreographer.setPostFrameCallbackDelay(100)\n        val mainLooper = Shadows.shadowOf(Looper.getMainLooper())\n        launch(Dispatchers.Main, start = CoroutineStart.UNDISPATCHED) {\n            expect(1)\n            awaitFrame()\n            expect(4)\n        }\n        // Run choreographer detection\n        expect(2)\n        mainLooper.scheduler.advanceBy(50, TimeUnit.MILLISECONDS)\n        expect(3)\n        mainLooper.scheduler.advanceBy(51, TimeUnit.MILLISECONDS)\n        finish(5)\n    }\n\n    override fun isMainThread(): Boolean = Looper.getMainLooper().thread === Thread.currentThread()\n\n    override fun scheduleOnMainQueue(block: () -> Unit) {\n        Handler(Looper.getMainLooper()).post(block)\n    }\n\n    // by default, Robolectric only schedules tasks on the main thread but doesn't run them.\n    // This function nudges it to run them, 10 milliseconds of virtual time at a time.\n    override suspend fun spinTest(testBody: Job) {\n        val mainLooper = Shadows.shadowOf(Looper.getMainLooper())\n        while (testBody.isActive) {\n            Thread.sleep(10, 0)\n            mainLooper.idleFor(10, TimeUnit.MILLISECONDS)\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-android/test/R8ServiceLoaderOptimizationTest.kt",
        "content": "package kotlinx.coroutines.android\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.jf.dexlib2.*\nimport org.junit.Test\nimport java.io.*\nimport java.util.stream.*\nimport kotlin.test.*\n\nclass R8ServiceLoaderOptimizationTest : TestBase() {\n    private val r8Dex = File(System.getProperty(\"dexPath\")!!).asDexFile()\n    private val r8DexNoOptim = File(System.getProperty(\"noOptimDexPath\")!!).asDexFile()\n\n    @Test\n    fun testNoServiceLoaderCalls() {\n        val serviceLoaderInvocations = r8Dex.types.any {\n            it.type == \"Ljava/util/ServiceLoader;\"\n        }\n        assertEquals(\n                false,\n                serviceLoaderInvocations,\n                \"References to the ServiceLoader class were found in the resulting DEX.\"\n        )\n    }\n\n    @Test\n    fun testAndroidDispatcherIsKept() {\n        val hasAndroidDispatcher = r8DexNoOptim.classes.any {\n            it.type == \"Lkotlinx/coroutines/android/AndroidDispatcherFactory;\"\n        }\n\n        assertEquals(true, hasAndroidDispatcher)\n    }\n\n    @Test\n    @Ignore\n    fun testNoOptimRulesMatch() {\n        val paths = listOf(\n                \"META-INF/com.android.tools/proguard/coroutines.pro\",\n                \"META-INF/proguard/coroutines.pro\",\n                \"META-INF/com.android.tools/r8-upto-1.6.0/coroutines.pro\"\n        )\n        paths.associateWith { path ->\n            val ruleSet = javaClass.classLoader.getResourceAsStream(path)!!.bufferedReader().lines().filter { line ->\n                line.isNotBlank() && !line.startsWith(\"#\")\n            }.collect(Collectors.toSet())\n            ruleSet\n        }.asSequence().reduce { acc, entry ->\n            assertEquals(\n                    acc.value,\n                    entry.value,\n                    \"Rule sets between ${acc.key} and ${entry.key} don't match.\"\n            )\n            entry\n        }\n    }\n}\n\nprivate fun File.asDexFile() = DexFileFactory.loadDexFile(this, null)\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/build.gradle.kts",
        "content": "plugins {\n    id(\"org.openjfx.javafxplugin\") version \"0.0.14\"\n}\n\nconfigurations {\n    register(\"javafx\")\n    named(\"compileOnly\") {\n        extendsFrom(configurations[\"javafx\"])\n    }\n    named(\"testImplementation\") {\n        extendsFrom(configurations[\"javafx\"])\n    }\n}\n\njavafx {\n    version = version(\"javafx\")\n    modules = listOf(\"javafx.controls\")\n    configuration = \"javafx\"\n}\n\n// Fixup moduleplugin in order to properly run with classpath\ntasks {\n    test {\n        extensions.configure(org.javamodularity.moduleplugin.extensions.TestModuleOptions::class) {\n            addReads[\"kotlinx.coroutines.javafx\"] = \"kotlin.test,test.utils.jvm\"\n            addReads[\"test.utils.jvm\"] = \"junit,kotlin.test\"\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/src/JavaFxConvert.kt",
        "content": "package kotlinx.coroutines.javafx\n\nimport javafx.beans.value.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.flow.*\n\n/**\n * Creates an instance of a cold [Flow] that subscribes to the given [ObservableValue] and emits\n * its values as they change. The resulting flow is conflated, meaning that if several values arrive in quick\n * succession, only the last one will be emitted.\n * Since this implementation uses [ObservableValue.addListener], even if this [ObservableValue]\n * supports lazy evaluation, eager computation will be enforced while the flow is being collected.\n * All the calls to JavaFX API are performed in [Dispatchers.JavaFx].\n * This flow emits at least the initial value.\n *\n * ### Operator fusion\n *\n * Adjacent applications of [flowOn], [buffer], [conflate], and [produceIn] to the result of `asFlow` are fused.\n * [conflate] has no effect, as this flow is already conflated; one can use [buffer] to change that instead.\n */\n@ExperimentalCoroutinesApi // Since 1.3.x\npublic fun <T> ObservableValue<T>.asFlow(): Flow<T> = callbackFlow<T> {\n    val listener = ChangeListener<T> { _, _, newValue ->\n        /*\n         * Do not propagate the exception to the ObservableValue, it\n         * already should've been handled by the downstream\n         */\n        trySend(newValue)\n    }\n    addListener(listener)\n    send(value)\n    awaitClose {\n        removeListener(listener)\n    }\n}.flowOn(Dispatchers.JavaFx).conflate()\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/src/JavaFxDispatcher.kt",
        "content": "package kotlinx.coroutines.javafx\n\nimport javafx.animation.*\nimport javafx.application.*\nimport javafx.event.*\nimport javafx.util.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport java.lang.UnsupportedOperationException\nimport java.lang.reflect.*\nimport java.util.concurrent.*\nimport kotlin.coroutines.*\n\n/**\n * Dispatches execution onto JavaFx application thread and provides native [delay] support.\n */\n@Suppress(\"unused\")\npublic val Dispatchers.JavaFx: JavaFxDispatcher\n    get() = kotlinx.coroutines.javafx.JavaFx\n\n/**\n * Dispatcher for JavaFx application thread with support for [awaitPulse].\n *\n * This class provides type-safety and a point for future extensions.\n */\npublic sealed class JavaFxDispatcher : MainCoroutineDispatcher(), Delay {\n\n    /** @suppress */\n    override fun dispatch(context: CoroutineContext, block: Runnable): Unit = Platform.runLater(block)\n\n    /** @suppress */\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val timeline = schedule(timeMillis) {\n            with(continuation) { resumeUndispatched(Unit) }\n        }\n        continuation.invokeOnCancellation { timeline.stop() }\n    }\n\n    /** @suppress */\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        val timeline = schedule(timeMillis) {\n            block.run()\n        }\n        return DisposableHandle { timeline.stop() }\n    }\n\n    private fun schedule(timeMillis: Long, handler: EventHandler<ActionEvent>): Timeline =\n        Timeline(KeyFrame(Duration.millis(timeMillis.toDouble()), handler)).apply { play() }\n}\n\ninternal class JavaFxDispatcherFactory : MainDispatcherFactory {\n    override fun createDispatcher(allFactories: List<MainDispatcherFactory>): MainCoroutineDispatcher = JavaFx\n\n    override val loadPriority: Int\n        get() = 1 // Swing has 0\n}\n\nprivate object ImmediateJavaFxDispatcher : JavaFxDispatcher() {\n    override val immediate: MainCoroutineDispatcher\n        get() = this\n\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = !Platform.isFxApplicationThread()\n\n    override fun toString() = toStringInternalImpl() ?: \"JavaFx.immediate\"\n}\n\n/**\n * Dispatches execution onto JavaFx application thread and provides native [delay] support.\n */\ninternal object JavaFx : JavaFxDispatcher() {\n    init {\n        // :kludge: to make sure Toolkit is initialized if we use JavaFx dispatcher outside of JavaFx app\n        initPlatform()\n    }\n\n    override val immediate: MainCoroutineDispatcher\n        get() = ImmediateJavaFxDispatcher\n\n    override fun toString() = toStringInternalImpl() ?: \"JavaFx\"\n}\n\nprivate val pulseTimer by lazy {\n    PulseTimer().apply { start() }\n}\n\n/**\n * Suspends coroutine until next JavaFx pulse and returns time of the pulse on resumption.\n * If the [Job] of the current coroutine is completed while this suspending function is waiting, this function\n * immediately resumes with [CancellationException][kotlinx.coroutines.CancellationException].\n */\npublic suspend fun awaitPulse(): Long = suspendCancellableCoroutine { cont ->\n    pulseTimer.onNext(cont)\n}\n\nprivate class PulseTimer : AnimationTimer() {\n    private val next = CopyOnWriteArrayList<CancellableContinuation<Long>>()\n\n    override fun handle(now: Long) {\n        val cur = next.toTypedArray()\n        next.clear()\n        for (cont in cur)\n            with (cont) { JavaFx.resumeUndispatched(now) }\n    }\n\n    fun onNext(cont: CancellableContinuation<Long>) {\n        next += cont\n    }\n}\n\n/** @return true if initialized successfully, and false if no display is detected */\ninternal fun initPlatform(): Boolean = PlatformInitializer.success\n\n// Lazily try to initialize JavaFx platform just once\nprivate object PlatformInitializer {\n    @JvmField\n    val success = run {\n        /*\n         * Try to instantiate JavaFx platform in a way which works\n         * both on Java 8 and Java 11 and does not produce \"illegal reflective access\".\n         */\n        try {\n            val runnable = Runnable {}\n            // Invoke the public API if it is present.\n            runCatching {\n                Class.forName(\"javafx.application.Platform\")\n                        .getMethod(\"startup\", java.lang.Runnable::class.java)\n            }.map { method ->\n                method.invoke(null, runnable)\n                return@run true\n            }\n            // If we are here, it means the public API is not present. Try the private API.\n            Class.forName(\"com.sun.javafx.application.PlatformImpl\")\n                    .getMethod(\"startup\", java.lang.Runnable::class.java)\n                    .invoke(null, runnable)\n            true\n        } catch (exception: InvocationTargetException) {\n            // Can only happen as a result of [Method.invoke].\n            val cause = exception.cause!!\n            when {\n                // Maybe the problem is that JavaFX is already initialized? Everything is good then.\n                cause is IllegalStateException && \"Toolkit already initialized\" == cause.message -> true\n                // If the problem is the headless environment, it is okay.\n                cause is UnsupportedOperationException && \"Unable to open DISPLAY\" == cause.message -> false\n                // Otherwise, the exception demonstrates an anomaly.\n                else -> throw cause\n            }\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/JavaFxDispatcherTest.kt",
        "content": "package kotlinx.coroutines.javafx\n\nimport kotlinx.coroutines.testing.*\nimport javafx.application.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport kotlin.test.*\n\nclass JavaFxDispatcherTest : MainDispatcherTestBase.WithRealTimeDelay() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"JavaFX Application Thread\", \"Thread-\", \"QuantumRenderer-\", \"InvokeLaterDispatcher\")\n    }\n\n    override fun shouldSkipTesting(): Boolean {\n        if (!initPlatform()) {\n            println(\"Skipping JavaFxTest in headless environment\")\n            return true // ignore test in headless environments\n        }\n        return false\n    }\n\n    override fun isMainThread() = Platform.isFxApplicationThread()\n\n    override fun scheduleOnMainQueue(block: () -> Unit) {\n        Platform.runLater { block() }\n    }\n\n    /** Tests that the Main dispatcher is in fact the JavaFx one. */\n    @Test\n    fun testMainIsJavaFx() {\n        assertSame(Dispatchers.JavaFx, Dispatchers.Main)\n    }\n\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/JavaFxObservableAsFlowTest.kt",
        "content": "package kotlinx.coroutines.javafx\n\nimport kotlinx.coroutines.testing.*\nimport javafx.beans.property.SimpleIntegerProperty\nimport kotlinx.coroutines.testing.TestBase\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport org.junit.Before\nimport org.junit.Test\nimport kotlin.test.*\n\n\nclass JavaFxObservableAsFlowTest : TestBase() {\n\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"JavaFX Application Thread\", \"Thread-\", \"QuantumRenderer-\", \"InvokeLaterDispatcher\")\n    }\n\n    @Test\n    fun testFlowOrder() = runTest {\n        if (!initPlatform()) {\n            println(\"Skipping JavaFxTest in headless environment\")\n            return@runTest // ignore test in headless environments\n        }\n\n        val integerProperty = SimpleIntegerProperty(0)\n        val n = 1000\n        val flow = integerProperty.asFlow().takeWhile { j -> j != n }\n        newSingleThreadContext(\"setter\").use { pool ->\n            launch(pool) {\n                for (i in 1..n) {\n                    launch(Dispatchers.JavaFx) {\n                        integerProperty.set(i)\n                    }\n                }\n            }\n            var i = -1\n            flow.collect { j ->\n                assertTrue(i < (j as Int), \"Elements are neither repeated nor shuffled\")\n                i = j\n            }\n        }\n    }\n\n    @Test\n    fun testConflation() = runTest {\n        if (!initPlatform()) {\n            println(\"Skipping JavaFxTest in headless environment\")\n            return@runTest // ignore test in headless environments\n        }\n\n        withContext(Dispatchers.JavaFx) {\n            val END_MARKER = -1\n            val integerProperty = SimpleIntegerProperty(0)\n            val flow = integerProperty.asFlow().takeWhile { j -> j != END_MARKER }\n            launch {\n                yield() // to subscribe to [integerProperty]\n                yield() // send 0\n                integerProperty.set(1)\n                expect(3)\n                yield() // send 1\n                expect(5)\n                integerProperty.set(2)\n                for (i in (-100..-2)) {\n                    integerProperty.set(i) // should be skipped due to conflation\n                }\n                integerProperty.set(3)\n                expect(6)\n                yield() // send 2 and 3\n                integerProperty.set(-1)\n            }\n            expect(1)\n            flow.collect { i ->\n                when (i) {\n                    0 -> expect(2)\n                    1 -> expect(4)\n                    2 -> expect(7)\n                    3 -> expect(8)\n                    else -> fail(\"i is $i\")\n                }\n            }\n            finish(9)\n        }\n    }\n\n    @Test\n    fun testIntermediateCrash() = runTest {\n        if (!initPlatform()) {\n            println(\"Skipping JavaFxTest in headless environment\")\n            return@runTest // ignore test in headless environments\n        }\n\n        val property = SimpleIntegerProperty(0)\n\n        assertFailsWith<TestException> {\n            property.asFlow().onEach {\n                yield()\n                throw TestException()\n            }.collect()\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/JavaFxStressTest.kt",
        "content": "package kotlinx.coroutines.javafx\n\nimport kotlinx.coroutines.testing.*\nimport javafx.beans.property.SimpleIntegerProperty\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.first\nimport org.junit.*\n\nclass JavaFxStressTest : TestBase() {\n\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"JavaFX Application Thread\", \"Thread-\", \"QuantumRenderer-\", \"InvokeLaterDispatcher\")\n    }\n\n    @get:Rule\n    val pool = ExecutorRule(1)\n\n    @Test\n    fun testCancellationRace() = runTest {\n        if (!initPlatform()) {\n            println(\"Skipping JavaFxTest in headless environment\")\n            return@runTest // ignore test in headless environments\n        }\n\n        val integerProperty = SimpleIntegerProperty(0)\n        val flow = integerProperty.asFlow()\n        var i = 1\n        val n = 1000 * stressTestMultiplier\n        repeat (n) {\n            launch(pool) {\n                flow.first()\n            }\n            withContext(Dispatchers.JavaFx) {\n                integerProperty.set(i)\n            }\n            i += 1\n        }\n    }\n}"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/examples/FxAsFlow.kt",
        "content": "package examples\n\nimport javafx.application.Application\nimport javafx.scene.Scene\nimport javafx.scene.control.*\nimport javafx.scene.layout.GridPane\nimport javafx.stage.Stage\nimport javafx.beans.property.SimpleStringProperty\nimport javafx.event.EventHandler\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.javafx.*\nimport kotlin.coroutines.CoroutineContext\n\nfun main(args: Array<String>) {\n    Application.launch(FxAsFlowApp::class.java, *args)\n}\n\n/**\n * Adapted from\n * https://github.com/ReactiveX/RxJavaFX/blob/a78ca7d15f7d82d201df8fafb6eba732ec17e327/src/test/java/io/reactivex/rxjavafx/RxJavaFXTest.java\n */\nclass FxAsFlowApp: Application(), CoroutineScope {\n\n    private var job = Job()\n    override val coroutineContext: CoroutineContext\n        get() = JavaFx + job\n\n    private val incrementButton = Button(\"Increment\")\n    private val incrementLabel = Label(\"\")\n    private val textInput = TextField()\n    private val flippedTextLabel = Label()\n    private val spinner = Spinner<Int>()\n    private val spinnerChangesLabel = Label()\n\n    public override fun start(  primaryStage: Stage) {\n        val gridPane = GridPane()\n        gridPane.apply {\n            hgap = 10.0\n            vgap = 10.0\n            add(incrementButton, 0, 0)\n            add(incrementLabel, 1, 0)\n            add(textInput, 0, 1)\n            add(flippedTextLabel, 1, 1)\n            add(spinner, 0, 2)\n            add(spinnerChangesLabel, 1, 2)\n        }\n        val scene = Scene(gridPane)\n        primaryStage.apply {\n            width = 275.0\n            setScene(scene)\n            show()\n        }\n    }\n\n    public override fun stop() {\n        super.stop()\n        job.cancel()\n        job = Job()\n    }\n\n    init {\n        // Initializing the \"Increment\" button\n        val stringProperty = SimpleStringProperty()\n        var i = 0\n        incrementButton.onAction = EventHandler {\n            i += 1\n            stringProperty.set(i.toString())\n        }\n        launch {\n            stringProperty.asFlow().collect {\n                if (it != null) {\n                    stringProperty.set(it)\n                }\n            }\n        }\n        incrementLabel.textProperty().bind(stringProperty)\n        // Initializing the reversed text field\n        val stringProperty2 = SimpleStringProperty()\n        launch {\n            textInput.textProperty().asFlow().collect {\n                if (it != null) {\n                    stringProperty2.set(it.reversed())\n                }\n            }\n        }\n        flippedTextLabel.textProperty().bind(stringProperty2)\n        // Initializing the spinner\n        spinner.valueFactory = SpinnerValueFactory.IntegerSpinnerValueFactory(0, 100)\n        spinner.isEditable = true\n        val stringProperty3 = SimpleStringProperty()\n        launch {\n            spinner.valueProperty().asFlow().collect {\n                if (it != null) {\n                    stringProperty3.set(\"NEW: $it\")\n                }\n            }\n        }\n        spinnerChangesLabel.textProperty().bind(stringProperty3)\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/examples/FxExampleApp.kt",
        "content": "package examples\n\nimport javafx.application.*\nimport javafx.scene.*\nimport javafx.scene.control.*\nimport javafx.scene.layout.*\nimport javafx.scene.paint.*\nimport javafx.scene.shape.*\nimport javafx.stage.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.javafx.*\nimport java.text.*\nimport java.util.*\nimport kotlin.coroutines.*\n\nfun main(args: Array<String>) {\n    Application.launch(FxTestApp::class.java, *args)\n}\n\nfun log(msg: String) = println(\"${SimpleDateFormat(\"yyyyMMdd-HHmmss.sss\").format(Date())} [${Thread.currentThread().name}] $msg\")\n\nclass FxTestApp : Application(), CoroutineScope {\n    val buttons = FlowPane().apply {\n        children += Button(\"Rect\").apply {\n            setOnAction { doRect() }\n        }\n        children += Button(\"Circle\").apply {\n            setOnAction { doCircle() }\n        }\n        children += Button(\"Clear\").apply {\n            setOnAction { doClear() }\n        }\n    }\n\n    val root = Pane().apply {\n        children += buttons\n    }\n\n    val scene = Scene(root, 600.0, 400.0)\n\n    override fun start(stage: Stage) {\n        stage.title = \"Hello world!\"\n        stage.scene = scene\n        stage.show()\n    }\n\n    val random = Random()\n    var animationIndex = 0\n    var job = Job()\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.JavaFx + job\n\n    private fun animation(node: Node, block: suspend CoroutineScope.() -> Unit) {\n        root.children += node\n        launch(block = block).also {\n            it.invokeOnCompletion { root.children -= node }\n        }\n    }\n\n    fun doRect() {\n        val node = Rectangle(20.0, 20.0).apply {\n            fill = Color.RED\n        }\n        val index = ++animationIndex\n        val speed = 5.0\n        animation(node) {\n            log(\"Started new 'rect' coroutine #$index\")\n            var vx = speed\n            var vy = speed\n            var counter = 0\n            while (true) {\n                awaitPulse()\n                node.x += vx\n                node.y += vy\n                val xRange = 0.0 .. scene.width - node.width\n                val yRange = 0.0 .. scene.height - node.height\n                if (node.x !in xRange ) {\n                    node.x = node.x.coerceIn(xRange)\n                    vx = -vx\n                }\n                if (node.y !in yRange) {\n                    node.y = node.y.coerceIn(yRange)\n                    vy = -vy\n                }\n                if (counter++ > 100) {\n                    counter = 0\n                    delay(1000) // pause a bit\n                    log(\"Delayed #$index for a while, resume and turn\")\n                    val t = vx\n                    vx = vy\n                    vy = -t\n                }\n            }\n        }\n    }\n\n    fun doCircle() {\n        val node = Circle(20.0).apply {\n            fill = Color.BLUE\n        }\n        val index = ++animationIndex\n        val acceleration = 0.1\n        val maxSpeed = 5.0\n        animation(node) {\n            log(\"Started new 'circle' coroutine #$index\")\n            var sx = random.nextDouble() * maxSpeed\n            var sy = random.nextDouble() * maxSpeed\n            while (true) {\n                awaitPulse()\n                val dx = root.width / 2 - node.translateX\n                val dy = root.height / 2 - node.translateY\n                val dn = Math.sqrt(dx * dx + dy * dy)\n                sx += dx / dn * acceleration\n                sy += dy / dn * acceleration\n                val sn = Math.sqrt(sx * sx + sy * sy)\n                val trim = sn.coerceAtMost(maxSpeed)\n                sx = sx / sn * trim\n                sy = sy / sn * trim\n                node.translateX += sx\n                node.translateY += sy\n            }\n        }\n    }\n\n    fun doClear() {\n        job.cancel()\n        job = Job()\n    }\n}"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-actor-01.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiActor01\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    fab.onClick { // start coroutine when the circle is clicked\n        for (i in 10 downTo 1) { // countdown from 10 to 1 \n            hello.text = \"Countdown $i ...\" // update text\n            delay(500) // wait half a second\n        }\n        hello.text = \"Done!\"\n    }\n}\n\nfun Node.onClick(action: suspend (MouseEvent) -> Unit) {\n    onMouseClicked = EventHandler { event ->\n        GlobalScope.launch(Dispatchers.Main) { \n            action(event)\n        }\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-actor-02.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiActor02\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    fab.onClick { // start coroutine when the circle is clicked\n        for (i in 10 downTo 1) { // countdown from 10 to 1 \n            hello.text = \"Countdown $i ...\" // update text\n            delay(500) // wait half a second\n        }\n        hello.text = \"Done!\"\n    }\n}\n\nfun Node.onClick(action: suspend (MouseEvent) -> Unit) {\n    // launch one actor to handle all events on this node\n    val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main) {\n        for (event in channel) action(event) // pass event to action\n    }\n    // install a listener to offer events to this actor\n    onMouseClicked = EventHandler { event ->\n        eventActor.trySend(event)\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-actor-03.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiActor03\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    fab.onClick { // start coroutine when the circle is clicked\n        for (i in 10 downTo 1) { // countdown from 10 to 1 \n            hello.text = \"Countdown $i ...\" // update text\n            delay(500) // wait half a second\n        }\n        hello.text = \"Done!\"\n    }\n}\n\nfun Node.onClick(action: suspend (MouseEvent) -> Unit) {\n    // launch one actor to handle all events on this node\n    val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main, capacity = Channel.CONFLATED) { // <--- Changed here\n        for (event in channel) action(event) // pass event to action\n    }\n    // install a listener to send events to this actor\n    onMouseClicked = EventHandler { event ->\n        eventActor.trySend(event)\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-advanced-01.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiAdvanced01\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    fab.onMouseClicked = EventHandler {\n        println(\"Before launch\")\n        GlobalScope.launch(Dispatchers.Main) {\n            println(\"Inside coroutine\")\n            delay(100)\n            println(\"After delay\")\n        } \n        println(\"After launch\")\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-advanced-02.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiAdvanced02\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    fab.onMouseClicked = EventHandler {\n        println(\"Before launch\")\n        GlobalScope.launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { // <--- Notice this change\n            println(\"Inside coroutine\")\n            delay(100)                            // <--- And this is where coroutine suspends      \n            println(\"After delay\")\n        }\n        println(\"After launch\")\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-basic-01.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiBasic01\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    // placeholder\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-basic-02.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiBasic02\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    GlobalScope.launch(Dispatchers.Main) { // launch coroutine in the main thread\n        for (i in 10 downTo 1) { // countdown from 10 to 1 \n            hello.text = \"Countdown $i ...\" // update text\n            delay(500) // wait half a second\n        }\n        hello.text = \"Done!\"\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-basic-03.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiBasic03\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    val job = GlobalScope.launch(Dispatchers.Main) { // launch coroutine in the main thread\n        for (i in 10 downTo 1) { // countdown from 10 to 1 \n            hello.text = \"Countdown $i ...\" // update text\n            delay(500) // wait half a second\n        }\n        hello.text = \"Done!\"\n    }\n    fab.onMouseClicked = EventHandler { job.cancel() } // cancel coroutine on click\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-blocking-01.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiBlocking01\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun Node.onClick(action: suspend (MouseEvent) -> Unit) {\n    val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main, capacity = Channel.CONFLATED) {\n        for (event in channel) action(event) // pass event to action\n    }\n    onMouseClicked = EventHandler { event ->\n        eventActor.trySend(event)\n    }\n}\n\nfun fib(x: Int): Int =\n    if (x <= 1) x else fib(x - 1) + fib(x - 2)\n\nfun setup(hello: Text, fab: Circle) {\n    var result = \"none\" // the last result\n    // counting animation \n    GlobalScope.launch(Dispatchers.Main) {\n        var counter = 0\n        while (true) {\n            hello.text = \"${++counter}: $result\"\n            delay(100) // update the text every 100ms\n        }\n    }\n    // compute the next fibonacci number of each click\n    var x = 1\n    fab.onClick {\n        result = \"fib($x) = ${fib(x)}\"\n        x++\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-blocking-02.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiBlocking02\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun Node.onClick(action: suspend (MouseEvent) -> Unit) {\n    val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main, capacity = Channel.CONFLATED) {\n        for (event in channel) action(event) // pass event to action\n    }\n    onMouseClicked = EventHandler { event ->\n        eventActor.trySend(event)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    var result = \"none\" // the last result\n    // counting animation \n    GlobalScope.launch(Dispatchers.Main) {\n        var counter = 0\n        while (true) {\n            hello.text = \"${++counter}: $result\"\n            delay(100) // update the text every 100ms\n        }\n    }\n    // compute next fibonacci number of each click\n    var x = 1\n    fab.onClick {\n        result = \"fib($x) = ${fib(x)}\"\n        x++\n    }\n}\n\nsuspend fun fib(x: Int): Int = withContext(Dispatchers.Default) {\n    if (x <= 1) x else fib(x - 1) + fib(x - 2)\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-javafx/test/guide/example-ui-blocking-03.kt",
        "content": "// This file was automatically generated from coroutines-guide-ui.md by Knit tool. Do not edit.\npackage kotlinx.coroutines.javafx.guide.exampleUiBlocking03\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.javafx.JavaFx as Main\nimport javafx.application.Application\nimport javafx.event.EventHandler\nimport javafx.geometry.*\nimport javafx.scene.*\nimport javafx.scene.input.MouseEvent\nimport javafx.scene.layout.StackPane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.Circle\nimport javafx.scene.text.Text\nimport javafx.stage.Stage\n\nfun main(args: Array<String>) {\n    Application.launch(ExampleApp::class.java, *args)\n}\n\nclass ExampleApp : Application() {\n    val hello = Text(\"Hello World!\").apply {\n        fill = Color.valueOf(\"#C0C0C0\")\n    }\n\n    val fab = Circle(20.0, Color.valueOf(\"#FF4081\"))\n\n    val root = StackPane().apply {\n        children += hello\n        children += fab\n        StackPane.setAlignment(hello, Pos.CENTER)\n        StackPane.setAlignment(fab, Pos.BOTTOM_RIGHT)\n        StackPane.setMargin(fab, Insets(15.0))\n    }\n\n    val scene = Scene(root, 240.0, 380.0).apply {\n        fill = Color.valueOf(\"#303030\")\n    }\n\n    override fun start(stage: Stage) {\n        stage.title = \"Example\"\n        stage.scene = scene\n        stage.show()\n        setup(hello, fab)\n    }\n}\n\nfun Node.onClick(action: suspend (MouseEvent) -> Unit) {\n    val eventActor = GlobalScope.actor<MouseEvent>(Dispatchers.Main, capacity = Channel.CONFLATED) {\n        for (event in channel) action(event) // pass event to action\n    }\n    onMouseClicked = EventHandler { event ->\n        eventActor.trySend(event)\n    }\n}\n\nfun setup(hello: Text, fab: Circle) {\n    var result = \"none\" // the last result\n    // counting animation \n    GlobalScope.launch(Dispatchers.Main) {\n        var counter = 0\n        while (true) {\n            hello.text = \"${++counter}: $result\"\n            delay(100) // update the text every 100ms\n        }\n    }\n    // compute next fibonacci number of each click\n    var x = 1\n    fab.onClick {\n        result = \"fib($x) = ${fib(x)}\"\n        x++\n    }\n}\n\nsuspend fun fib(x: Int): Int = withContext(Dispatchers.Default) {\n    fibBlocking(x)\n}\n\nfun fibBlocking(x: Int): Int = \n    if (x <= 1) x else fibBlocking(x - 1) + fibBlocking(x - 2)\n"
    },
    {
        "path": "ui/kotlinx-coroutines-swing/build.gradle.kts",
        "content": "dependencies {\n    testImplementation(project(\":kotlinx-coroutines-jdk8\"))\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-swing/src/SwingDispatcher.kt",
        "content": "package kotlinx.coroutines.swing\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\nimport java.awt.event.*\nimport javax.swing.*\nimport kotlin.coroutines.*\n\n/**\n * Dispatches execution onto Swing event dispatching thread and provides native [delay] support.\n */\n@Suppress(\"unused\")\npublic val Dispatchers.Swing : SwingDispatcher\n    get() = kotlinx.coroutines.swing.Swing\n\n/**\n * Dispatcher for Swing event dispatching thread.\n *\n * This class provides type-safety and a point for future extensions.\n */\npublic sealed class SwingDispatcher : MainCoroutineDispatcher(), Delay {\n    /** @suppress */\n    override fun dispatch(context: CoroutineContext, block: Runnable): Unit = SwingUtilities.invokeLater(block)\n\n    /** @suppress */\n    override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {\n        val timer = schedule(timeMillis) {\n            with(continuation) { resumeUndispatched(Unit) }\n        }\n        continuation.invokeOnCancellation { timer.stop() }\n    }\n\n    /** @suppress */\n    override fun invokeOnTimeout(timeMillis: Long, block: Runnable, context: CoroutineContext): DisposableHandle {\n        val timer = schedule(timeMillis) {\n            block.run()\n        }\n        return DisposableHandle { timer.stop() }\n    }\n\n    private fun schedule(timeMillis: Long, action: ActionListener): Timer =\n        Timer(timeMillis.coerceAtMost(Int.MAX_VALUE.toLong()).toInt(), action).apply {\n            isRepeats = false\n            start()\n        }\n}\n\ninternal class SwingDispatcherFactory : MainDispatcherFactory {\n    override val loadPriority: Int\n        get() = 0\n\n    override fun createDispatcher(allFactories: List<MainDispatcherFactory>): MainCoroutineDispatcher = Swing\n}\n\nprivate object ImmediateSwingDispatcher : SwingDispatcher() {\n    override val immediate: MainCoroutineDispatcher\n        get() = this\n\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = !SwingUtilities.isEventDispatchThread()\n\n    override fun toString() = toStringInternalImpl() ?: \"Swing.immediate\"\n}\n\n/**\n * Dispatches execution onto Swing event dispatching thread and provides native [delay] support.\n */\ninternal object Swing : SwingDispatcher() {\n\n    /* A workaround so that the dispatcher's initialization crashes with an exception if running in a headless\n    environment. This is needed so that this broken dispatcher is not used as the source of delays. */\n    init {\n        Timer(1) { }.apply {\n            isRepeats = false\n            start()\n        }\n    }\n\n    override val immediate: MainCoroutineDispatcher\n        get() = ImmediateSwingDispatcher\n\n    override fun toString() = toStringInternalImpl() ?: \"Swing\"\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-swing/test/SwingTest.kt",
        "content": "package kotlinx.coroutines.swing\n\nimport kotlinx.coroutines.testing.*\nimport kotlinx.coroutines.*\nimport org.junit.*\nimport org.junit.Test\nimport javax.swing.*\nimport kotlin.test.*\n\nclass SwingTest : MainDispatcherTestBase.WithRealTimeDelay() {\n    @Before\n    fun setup() {\n        ignoreLostThreads(\"AWT-EventQueue-\")\n    }\n\n    override fun isMainThread() = SwingUtilities.isEventDispatchThread()\n\n    override fun scheduleOnMainQueue(block: () -> Unit) {\n        SwingUtilities.invokeLater { block() }\n    }\n\n    /** Tests that the Main dispatcher is in fact the JavaFx one. */\n    @Test\n    fun testMainIsJavaFx() {\n        assertSame(Dispatchers.Swing, Dispatchers.Main)\n    }\n}\n"
    },
    {
        "path": "ui/kotlinx-coroutines-swing/test/examples/SwingExampleApp.kt",
        "content": "package examples\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.future.*\nimport kotlinx.coroutines.swing.*\nimport java.awt.*\nimport java.util.concurrent.*\nimport javax.swing.*\n\nprivate fun createAndShowGUI() {\n    val frame = JFrame(\"Async UI example\")\n    frame.defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n\n    val jProgressBar = JProgressBar(0, 100).apply {\n        value = 0\n        isStringPainted = true\n    }\n\n    val jTextArea = JTextArea(11, 10)\n    jTextArea.margin = Insets(5, 5, 5, 5)\n    jTextArea.isEditable = false\n\n    val panel = JPanel()\n\n    panel.add(jProgressBar)\n    panel.add(jTextArea)\n\n    frame.contentPane.add(panel)\n    frame.pack()\n    frame.isVisible = true\n\n    GlobalScope.launch(Dispatchers.Swing) {\n        for (i in 1..10) {\n            // 'append' method and consequent 'jProgressBar.setValue' are called\n            // within Swing event dispatch thread\n            jTextArea.append(\n                    startLongAsyncOperation(i).await()\n            )\n            jProgressBar.value = i * 10\n        }\n    }\n}\n\nprivate fun startLongAsyncOperation(v: Int) =\n        CompletableFuture.supplyAsync {\n            Thread.sleep(1000)\n            \"Message: $v\\n\"\n        }\n\nfun main(args: Array<String>) {\n    SwingUtilities.invokeLater(::createAndShowGUI)\n}\n"
    }
]